From mik77 at mail.berlios.de  Wed Oct  3 23:22:59 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 3 Oct 2007 23:22:59 +0200
Subject: [Cachewolf-svn] r949 - trunk/src/CacheWolf
Message-ID: <200710032122.l93LMxhC023975@sheep.berlios.de>

Author: mik77
Date: 2007-10-03 23:22:56 +0200 (Wed, 03 Oct 2007)
New Revision: 949

Modified:
   trunk/src/CacheWolf/StatusBar.java
Log:
Filter button moved to the left to avoid SIP-Button

Modified: trunk/src/CacheWolf/StatusBar.java
===================================================================
--- trunk/src/CacheWolf/StatusBar.java	2007-09-29 16:14:03 UTC (rev 948)
+++ trunk/src/CacheWolf/StatusBar.java	2007-10-03 21:22:56 UTC (rev 949)
@@ -25,15 +25,15 @@
 		imgCacheTour.transparentColor=Color.White;
 		btnCacheTour.setPreferredSize(20,13);btnCacheTour.borderWidth=0; 
 		btnCacheTour.setToolTip(MyLocale.getMsg(197,"Show/Hide cachetour"));
-		stats = new DBStats(db);
-		addNext(disp = new mLabel(""),CellConstants.DONTSTRETCH, CellConstants.FILL);
-		disp.setToolTip(MyLocale.getMsg(196,"Total # of caches (GC&OC)\nTotal # visible\nTotal # found"));
 		addNext(btnFlt= new mButton(imgFlt=new mImage("filter.png")),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); 
 		btnFlt.backGround=new ewe.fx.Color(0,255,0); 
 		btnFlt.setPreferredSize(20,13);
 		btnFlt.borderWidth=0; imgFlt.transparentColor=Color.White;
 		btnFlt.setToolTip("Filter status");
 //		addNext(lblFlt= new mLabel("Flt"),CellConstants.DONTSTRETCH, CellConstants.DONTFILL); lblFlt.backGround=new ewe.fx.Color(0,255,0);
+		stats = new DBStats(db);
+		addNext(disp = new mLabel(""),CellConstants.DONTSTRETCH, CellConstants.FILL);
+		disp.setToolTip(MyLocale.getMsg(196,"Total # of caches (GC&OC)\nTotal # visible\nTotal # found"));
 		addLast(lblCenter=new mLabel(""),CellConstants.STRETCH, WEST|CellConstants.FILL);
 		lblCenter.setToolTip(MyLocale.getMsg(195,"Current centre"));
 		updateDisplay();



From pfeffer at mail.berlios.de  Thu Oct  4 01:48:52 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 4 Oct 2007 01:48:52 +0200
Subject: [Cachewolf-svn] r950 - trunk/src/CacheWolf
Message-ID: <200710032348.l93Nmqqd027236@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-04 01:48:49 +0200 (Thu, 04 Oct 2007)
New Revision: 950

Modified:
   trunk/src/CacheWolf/CWPoint.java
Log:
fix: output from 5? 60.00' which used to happen if it is actually 5? 59.9995'

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-10-03 21:22:56 UTC (rev 949)
+++ trunk/src/CacheWolf/CWPoint.java	2007-10-03 23:48:49 UTC (rev 950)
@@ -312,11 +312,14 @@
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLatDeg(int format) {
+		double latdeg = latDec;
+		double lonMin=(Math.abs(latDec) - (int)Math.abs(latDec))*60.0;
+		if (java.lang.Math.round(lonMin)*1000 == 60000) latdeg += 1;
 		switch (format) {
 		case DD: 	return MyLocale.formatDouble(this.latDec, "00.00000").replace(',','.');
 		case CW:
 		case DMM:
-		case DMS:	return MyLocale.formatDouble((int) Math.abs(this.latDec),"00");
+		case DMS:	return MyLocale.formatDouble((int) Math.abs(latdeg),"00");
 		default: return "";
 		}
 	}
@@ -326,11 +329,14 @@
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLonDeg(int format) {
+		double longdeg = lonDec;
+		double lonMin=(Math.abs(lonDec) - (int)Math.abs(lonDec))*60.0;
+		if (java.lang.Math.round(lonMin)*1000 == 60000) longdeg += 1;
 		switch (format) {
 		case DD: 	return MyLocale.formatDouble(this.lonDec, "000.00000").replace(',','.');
 		case CW:
 		case DMM:
-		case DMS:	return MyLocale.formatDouble((int) Math.abs(this.lonDec),"000");
+		case DMS:	return MyLocale.formatDouble((int) Math.abs(longdeg),"000");
 		default: 	return ""; 
 		}
 	}
@@ -341,6 +347,7 @@
 	 */
 	public String getLatMin(int format) {
 		double latMin=(Math.abs(latDec) - (int)Math.abs(latDec))*60.0;
+		if (java.lang.Math.round(latMin)*1000 == 60000) latMin = 0; // TODO this caluclation is doubled from getLatdeg
 		switch (format) {
 			case DD: 	return "";
 			case CW:
@@ -355,6 +362,7 @@
 	 */
 	public String getLonMin(int format) {
 		double lonMin=(Math.abs(lonDec) - (int)Math.abs(lonDec))*60.0;
+		if (java.lang.Math.round(lonMin)*1000 == 60000) lonMin = 0;
 		switch (format) {
 			case DD: 	return "";
 			case CW:



From pfeffer at mail.berlios.de  Thu Oct  4 03:50:49 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 4 Oct 2007 03:50:49 +0200
Subject: [Cachewolf-svn] r951 - trunk/src/CacheWolf
Message-ID: <200710040150.l941onme013690@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-04 03:50:47 +0200 (Thu, 04 Oct 2007)
New Revision: 951

Modified:
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/myTableModel.java
Log:
fix: solved the right-click-problem see: http://www.geoclub.de/ftopic18812-0-asc-30.html
fix: solved shift+click on the checkbox to select several caches at once

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-10-03 23:48:49 UTC (rev 950)
+++ trunk/src/CacheWolf/myTableControl.java	2007-10-04 01:50:47 UTC (rev 951)
@@ -256,26 +256,10 @@
 		Global.mainTab.select(Global.mainTab.descP);
 	}
 	
-	int rowRightMouseClick=-1;
 	public void onEvent(Event ev) {
-	    if (ev instanceof PenEvent) {
-			// Ensure that row is selected on right mouse key to show the correct
-	    	// cache details
-	    	if (ev.type==PenEvent.PEN_DOWN && (((PenEvent)ev).modifiers&PenEvent.RIGHT_BUTTON)!=0) { 
-				Point p=cellAtPoint(((PenEvent)ev).x,((PenEvent)ev).y,null);
-				if (p==null)
-					rowRightMouseClick=-1;
-				else
-					rowRightMouseClick=p.y;
-				// The selection of the row on right mouse click is delayed
-				// until the menu has been drawn to speed up the refreshing of the screen
-			}
+	    if (ev instanceof PenEvent && (ev.type == PenEvent.PEN_DOWN) ){
 			Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
 	    }
-	    if (ev instanceof ControlEvent && ev.type==ControlEvent.POPUP_CLOSED) {
-			// Delayed switch to new row on right mouse click when pop-up menu has been opened
-			Global.mainTab.tbP.selectRow(rowRightMouseClick);
-	    }
 		super.onEvent(ev);
 	}
     ///////////////////////////////////////////////////

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-10-03 23:48:49 UTC (rev 950)
+++ trunk/src/CacheWolf/myTableModel.java	2007-10-04 01:50:47 UTC (rev 951)
@@ -49,7 +49,7 @@
 	 * it is set in myTableControl.onEvent */
 	public int penEventModifiers; 
 	/** The row of the last click where the shift key was pressed */
-	private int lastRow=-1;
+//	private int lastRow=-1;
 	private myTableControl tcControl;
 	
 	public myTableModel(myTableControl tc, FontMetrics fm){
@@ -292,18 +292,15 @@
 			if (cell.y>=0 && cell.x==0) {
 				Global.getProfile().selectionChanged = true;
 				if ((penEventModifiers & IKeys.SHIFT)>0) {
-					if (lastRow!=-1) { // Second row being marked with shift key pressed
-						if (lastRow<cell.y)
-							toggleSelect(lastRow,cell.y);
+					if (tcControl.cursor.y >= 0) { // Second row being marked with shift key pressed
+						if (tcControl.cursor.y<cell.y)
+							toggleSelect(tcControl.cursor.y,cell.y);
 						else
-							toggleSelect(cell.y,lastRow);
-						lastRow=-1;
+							toggleSelect(cell.y,tcControl.cursor.y);
 					} else { // Remember this row as start of range, but don't toggle yet
-						lastRow=cell.y;
 					}
 				} else { // Single row marked
 					toggleSelect(cell.y,cell.y);
-					lastRow=-1;
 				}
 			}
 			if(cell.y == -1){ // Hit a header => sort the table accordingly
@@ -366,5 +363,9 @@
 			}
 		}		
 	}
+	public void select(int row,int col,boolean selectOn) {
+		//super.select(row, col, selectOn);
+		tcControl.cursorTo(row, col, true);
+	}
 	
 }



From salzkammergut at mail.berlios.de  Thu Oct  4 20:55:36 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 4 Oct 2007 20:55:36 +0200
Subject: [Cachewolf-svn] r952 - trunk/src/CacheWolf
Message-ID: <200710041855.l94ItaiJ001841@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-04 20:55:33 +0200 (Thu, 04 Oct 2007)
New Revision: 952

Modified:
   trunk/src/CacheWolf/MainTab.java
Log:
Fix: After creating a new waypoint it was not automatically displayed in the Details panel (http://www.geoclub.de/ftopic18812-40.html - Kappler)

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-10-04 01:50:47 UTC (rev 951)
+++ trunk/src/CacheWolf/MainTab.java	2007-10-04 18:55:33 UTC (rev 952)
@@ -82,6 +82,7 @@
 		radarP.setMainTab(this);
 		c.iconize(new Image("radar.gif"),true);
 		mnuMain.allowProfileChange(true);
+		if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
 	}
 
 	public TablePanel getTablePanel(){
@@ -283,7 +284,7 @@
 		tbP.selectRow(profile.getCacheIndex(waypoint));
 		//Global.mainTab.tbP.refreshTable();
 		if (this.cardPanel.selectedItem==1) { // Detailpanel already selected
-			postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,0));
+			postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,1));
 		} else	
 			select(detP);
 		solverP.setInstructions("");



From mirabilos at mail.berlios.de  Thu Oct  4 20:59:09 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Thu, 4 Oct 2007 20:59:09 +0200
Subject: [Cachewolf-svn] r953 - in trunk: . docs
Message-ID: <200710041859.l94Ix9vO002308@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-04 20:59:09 +0200 (Thu, 04 Oct 2007)
New Revision: 953

Modified:
   trunk/cwberlios.jnf
   trunk/docs/Readme.txt
Log:
we need *.html outside of the .ewe file, otherwise they won?t be displayed


Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-10-04 18:55:33 UTC (rev 952)
+++ trunk/cwberlios.jnf	2007-10-04 18:59:09 UTC (rev 953)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/exp%252526mask%2525!
 3D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip;*.html%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2!
 526appletWidth%253D0%2526appletHeight%253D0%2526appletInFrame%!
 253Dfals
e%2526locale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/exp%252526mask%2525!
 3D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appl!
 etWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfal!
 se%2526l
ocale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico

Modified: trunk/docs/Readme.txt
===================================================================
--- trunk/docs/Readme.txt	2007-10-04 18:55:33 UTC (rev 952)
+++ trunk/docs/Readme.txt	2007-10-04 18:59:09 UTC (rev 953)
@@ -38,4 +38,4 @@
 - Script buildexe.bat bzw. ./buildexe.sh aufrufen, es wird ein Verzeichnis CacheWolf erzeugt mit Unterverzeichnissen f?r die unterschiedlichen Plattformen.
 - mit dem Script runjewel k?nnen ?nderungen an der Datei cwberlios.jnf vorgenommen werden.
 
-An weiteren Dateien neben CacheWolf.ewe werden im Programmverzeichnis noch *.def, *.tpl und attributes/*.gif aus dem Verzeichnis ?resources? ben?tigt. Wahlweise kann man stattdessen auch resources/attributes-big/*.gif in ?Programmverzeichnis?/attributes/ packen.
+An weiteren Dateien neben CacheWolf.ewe werden im Programmverzeichnis noch *.def, *.html, *.tpl und attributes/*.gif aus dem Verzeichnis ?resources? ben?tigt. Wahlweise kann man stattdessen auch resources/attributes-big/*.gif in ?Programmverzeichnis?/attributes/ packen.



From mirabilos at mail.berlios.de  Thu Oct  4 21:11:38 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Thu, 4 Oct 2007 21:11:38 +0200
Subject: [Cachewolf-svn] r954 - trunk/src/CacheWolf
Message-ID: <200710041911.l94JBc9w003751@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-04 21:11:37 +0200 (Thu, 04 Oct 2007)
New Revision: 954

Modified:
   trunk/src/CacheWolf/MainTab.java
Log:
remove line which does not compile:
src/CacheWolf/MainTab.java: In class `CacheWolf.MainTab':
src/CacheWolf/MainTab.java: In constructor `(CacheWolf.MainMenu,CacheWolf.StatusBar)':
src/CacheWolf/MainTab.java:85: error: No variable `noTabs' defined in type `CacheWolf.Preferences'.
                if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
                           ^


Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-10-04 18:59:09 UTC (rev 953)
+++ trunk/src/CacheWolf/MainTab.java	2007-10-04 19:11:37 UTC (rev 954)
@@ -82,7 +82,7 @@
 		radarP.setMainTab(this);
 		c.iconize(new Image("radar.gif"),true);
 		mnuMain.allowProfileChange(true);
-		if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
+//		if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
 	}
 
 	public TablePanel getTablePanel(){



From kalli at mail.berlios.de  Fri Oct  5 21:20:49 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 5 Oct 2007 21:20:49 +0200
Subject: [Cachewolf-svn] r955 - in trunk/src: CacheWolf exp
Message-ID: <200710051920.l95JKnpJ029060@sheep.berlios.de>

Author: kalli
Date: 2007-10-05 21:20:47 +0200 (Fri, 05 Oct 2007)
New Revision: 955

Modified:
   trunk/src/CacheWolf/Preferences.java
   trunk/src/exp/TomTomExporter.java
Log:
Bugfixing: #84 negative (S, W) Koordinates in TomTom-ovi-files
Exportpath of exporter was not saved

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-10-04 19:11:37 UTC (rev 954)
+++ trunk/src/CacheWolf/Preferences.java	2007-10-05 19:20:47 UTC (rev 955)
@@ -598,11 +598,13 @@
 
 	public void setExportPath(String exporter,String path){
 		exporterPaths.put(exporter, path);
+		savePreferences();
 	}
 
 	public void setExportPathFromFileName(String exporter,String filename){
 		File tmpfile = new File (filename);
 		exporterPaths.put(exporter, tmpfile.getPath());
+		savePreferences();
 	}
 
 	public String getExportPath(String exporter){

Modified: trunk/src/exp/TomTomExporter.java
===================================================================
--- trunk/src/exp/TomTomExporter.java	2007-10-04 19:11:37 UTC (rev 954)
+++ trunk/src/exp/TomTomExporter.java	2007-10-05 19:20:47 UTC (rev 955)
@@ -237,21 +237,19 @@
 	}
 
 	public void writeIntBinary(RandomAccessFile outp, int data){
-		int a,b,c,d;
-		d = 0;
-		c = data / 65536;
-		b = (data - c *65536) / 256;
-		a = (data - c * 65536 - b * 256);
-
+		
+		ByteArray buf = new ByteArray();
+		buf.appendInt(data);
 		try {
-			outp.writeByte((byte)a);
-			outp.writeByte((byte)b);
-			outp.writeByte((byte)c);
-			outp.writeByte((byte)d);
+			outp.writeByte(buf.data[3]);
+			outp.writeByte(buf.data[2]);
+			outp.writeByte(buf.data[1]);
+			outp.writeByte(buf.data[0]);
 		} catch (IOException e) {
 			Vm.debug("Error writing to file");
 			e.printStackTrace();
 		}
+
 		return;
 	}
 	



From kalli at mail.berlios.de  Fri Oct  5 21:24:07 2007
From: kalli at mail.berlios.de (kalli at mail.berlios.de)
Date: Fri, 5 Oct 2007 21:24:07 +0200
Subject: [Cachewolf-svn] r956 - trunk
Message-ID: <200710051924.l95JO7X4029260@sheep.berlios.de>

Author: kalli
Date: 2007-10-05 21:24:04 +0200 (Fri, 05 Oct 2007)
New Revision: 956

Modified:
   trunk/cwberlios.jnf
Log:
buildexe.bat didn't work on WinXP, so 
- Removed .zip and .tpl files from Ewe-File
- Unchecked "Use String Pool"

Modified: trunk/cwberlios.jnf
===================================================================
--- trunk/cwberlios.jnf	2007-10-05 19:20:47 UTC (rev 955)
+++ trunk/cwberlios.jnf	2007-10-05 19:24:04 UTC (rev 956)
@@ -1 +1 @@
-command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/exp%252526mask%2525!
 3D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico;*.tp;*.zip%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appl!
 etWidth%253D0%2526appletHeight%253D0%2526appletInFrame%253Dfal!
 se%2526l
ocale%253D%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dtrue%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico
+command=programName%3DCacheWolf%26width%3D0%26height%3D0%26startingClass%3DCacheWolf.CacheWolf%26windowTitle%3DWindow%2BTitle%26ewes%3D%26extra%3D%26pathToEwe%3D%26nativeStack%3D0%26vmStack%3D0%26appletWidth%3D0%26appletHeight%3D0%26appletInFrame%3Dfalse%26locale%3D%26useResources%3Dtrue%26noPopupWindows%3Dfalse%26vmOptions%3D/Xmx%2B12M&eweFiles=&targets=%253DTarget%3Dewe/data/MultiListSelect$SelectedItems%253D%25253DJar%25252B-%25252BJava%25252B1.2%252526%25253DPocketPC%25252B2003%252526%25253DPocketPC%25252B-%25252BARM/XScale%252526%25253DPocketPC%25252B-%25252BMIPS%252526%25253DPocketPC%25252B-%25252BSH3%252526%25253Dx86%25252B-%25252BWin32%25252B-%25252BStatic%25252BLinked&createWithPnf=true&eweInfo=outputFile%3Dwork/CacheWolf.ewe%26entries%3Dewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/CacheWolf/%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253DCacheWolf/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/exp%252526mask%2525!
 3D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dexp/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources%252526mask%25253D*.gif;*.png;*.ico;%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dresources/%252526mask%25253Dcachewolf.Languages.cfg%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253D_config/%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dlib%252526mask%25253D*.class%252526includeSubdirectories%25253Dtrue%252526pathInEwe%25253D%2526ewesoft/apps/jewel/EweDirEntry%253Dpath%25253Dbin/utils%252526mask%25253D*.class%252526includeSubdirectories%25253Dfalse%252526pathInEwe%25253Dutils/%26addCommandLine%3Dtrue%26commandLine%3DprogramName%253DCacheWolf%2526width%253D0%2526height%253D0%2526startingClass%253DCacheWolf.CacheWolf%2526windowTitle%253DWindow%252BTitle%2526ewes%253D%2526extra%253D%2526pathToEwe%253D%2526nativeStack%253D0%2526vmStack%253D0%2526appletWidth%25!
 3D0%2526appletHeight%253D0%2526appletInFrame%253Dfalse%2526loc!
 ale%253D
%2526useResources%253Dtrue%2526noPopupWindows%253Dfalse%2526vmOptions%253D/Xmx%252B12M%26install%3Dtitle%253D%2526category%253DApplications%2526location%253D%2526icon%253D%2526args%253D%2526vmArgs%253D%26addInstallFile%3Dfalse%26usePool%3Dfalse%26useClassPool%3Dfalse&icon=resources/CacheWolf.ico



From mirabilos at mail.berlios.de  Fri Oct  5 22:09:31 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 5 Oct 2007 22:09:31 +0200
Subject: [Cachewolf-svn] r957 - trunk/docs
Message-ID: <200710052009.l95K9VEh000064@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-05 22:09:30 +0200 (Fri, 05 Oct 2007)
New Revision: 957

Modified:
   trunk/docs/Readme.txt
Log:
kalli forgot this in r956


Modified: trunk/docs/Readme.txt
===================================================================
--- trunk/docs/Readme.txt	2007-10-05 19:24:04 UTC (rev 956)
+++ trunk/docs/Readme.txt	2007-10-05 20:09:30 UTC (rev 957)
@@ -38,4 +38,4 @@
 - Script buildexe.bat bzw. ./buildexe.sh aufrufen, es wird ein Verzeichnis CacheWolf erzeugt mit Unterverzeichnissen f?r die unterschiedlichen Plattformen.
 - mit dem Script runjewel k?nnen ?nderungen an der Datei cwberlios.jnf vorgenommen werden.
 
-An weiteren Dateien neben CacheWolf.ewe werden im Programmverzeichnis noch *.def, *.html, *.tpl und attributes/*.gif aus dem Verzeichnis ?resources? ben?tigt. Wahlweise kann man stattdessen auch resources/attributes-big/*.gif in ?Programmverzeichnis?/attributes/ packen.
+An weiteren Dateien neben CacheWolf.ewe werden im Programmverzeichnis noch *.def, *.html, *.tpl, *.zip und attributes/*.gif aus dem Verzeichnis ?resources? ben?tigt. Wahlweise kann man stattdessen auch resources/attributes-big/*.gif in ?Programmverzeichnis?/attributes/ packen.



From pfeffer at mail.berlios.de  Sat Oct  6 00:10:39 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 6 Oct 2007 00:10:39 +0200
Subject: [Cachewolf-svn] r958 - trunk/src/CacheWolf/navi
Message-ID: <200710052210.l95MAdA6006186@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-06 00:10:37 +0200 (Sat, 06 Oct 2007)
New Revision: 958

Modified:
   trunk/src/CacheWolf/navi/MapLoader.java
Log:
fix: expedia-map-downloader: rarely the server doen't answer with a redirect to the map image. So I implemented an automatic retry (5times). See http://www.geoclub.de/viewtopic.php?p=305071#305071

Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2007-10-05 20:09:30 UTC (rev 957)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2007-10-05 22:10:37 UTC (rev 958)
@@ -202,10 +202,16 @@
 		try{
 			File dateiF = new File(datei);
 			if(!dateiF.exists()){
-				sockImg = connImg.connect();
-				//Vm.debug("Redirect: " + connImg.getRedirectTo());
-				quelle = connImg.getRedirectTo();
-				sockImg.close();
+				int i=0;
+				quelle = null;
+				while (quelle == null && i < 5) { // this is necessary because expedia sometimes doesn't directly anser with the redirect to the map-image, but give a page in between. Solved the problem by retrying see also: http://www.geoclub.de/viewtopic.php?p=305071#305071
+					sockImg = connImg.connect();
+					//Vm.debug("Redirect: " + i + connImg.getRedirectTo());
+					quelle = connImg.getRedirectTo();
+					sockImg.close();
+					i++;
+				}
+				if (i > 4) throw new IOException("loadTo: failed to download map: didn't get http-redirect");
 				if(proxy.length()>0){
 					connImg = new HttpConnection(proxy, Convert.parseInt(port), quelle);
 				}else{



From salzkammergut at mail.berlios.de  Sat Oct  6 22:31:29 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 6 Oct 2007 22:31:29 +0200
Subject: [Cachewolf-svn] r959 - trunk/src/CacheWolf
Message-ID: <200710062031.l96KVTls011388@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-06 22:31:23 +0200 (Sat, 06 Oct 2007)
New Revision: 959

Modified:
   trunk/src/CacheWolf/DataMover.java
Log:
DataMover: Now progress bars are displayed for copy/move and delete operations

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2007-10-05 22:10:37 UTC (rev 958)
+++ trunk/src/CacheWolf/DataMover.java	2007-10-06 20:31:23 UTC (rev 959)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import CacheWolf.myTableControl.myProgressBarForm;
 import utils.FileBugfix;
 import ewe.filechooser.FileChooser;
 import ewe.io.*;
@@ -29,16 +30,7 @@
 		if (mBox.execute() != MessageBox.IDOK){
 			return;
 		}
-
-		// Loop through database
-		for(int i = 0; i<srcDB.size(); i++){
-			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.is_filtered==false){
-				deleteCacheFiles(srcHolder.wayPoint, profile.dataDir);
-				srcDB.removeElementAt(i);
-				i--;
-			}//if srcHolder...
-		}//for ... i < srcDB ...
+		processCaches(new Deleter(MyLocale.getMsg(143, "Delete")));
 		// write indexfiles
 		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 	}
@@ -47,14 +39,9 @@
 		int dstPos;
 		Profile dstProfile=new Profile();
 		
-		// Select destination directory
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.baseDir);
-		fc.setTitle(MyLocale.getMsg(148,"Select Target directory"));
-		if(fc.execute() != FormBase.IDCANCEL){
-			dstProfile.dataDir = fc.getChosen() + "/";
-		}
-		else return;
-		if (dstProfile.dataDir.equals(profile.dataDir)) return;
+		dstProfile.dataDir=selectTargetDir();
+		if (dstProfile.dataDir.equals(profile.dataDir) ||
+			dstProfile.dataDir.equals("")) return;
 		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(146,"Cachedata of ALL VISIBLE caches will be copied! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
 		if (mBox.execute() != MessageBox.IDOK){
 			return;
@@ -65,27 +52,7 @@
 		if(ftest.exists()){
 			dstProfile.readIndex();
 		}
-		dstDB=dstProfile.cacheDB;
-		// Loop through database
-		for(int i = 0; i<srcDB.size(); i++){
-			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.is_filtered==false){
-				// does cache exists in destDB ?
-				dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
-				if (dstPos >= 0){
-					deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-					copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-					// Update database
-					dstDB.set(dstPos,srcHolder);
-				}
-				else {
-					deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-					copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-					// Update database
-					dstDB.add(srcHolder);
-				}
-			}//if srcHolder...
-		}//for ... i < srcDB ...
+		processCaches(new Copier(MyLocale.getMsg(141, "Copy"),dstProfile));
 		// write indexfiles and keep the filter status
 		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR,dstProfile.filterActive,dstProfile.filterInverted);
 	}
@@ -95,13 +62,10 @@
 		int dstPos;
 		
 		// Select destination directory
-		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.baseDir);
-		fc.setTitle(MyLocale.getMsg(148,"Select Target directory"));
-		if(fc.execute() != FormBase.IDCANCEL){
-			dstProfile.dataDir = fc.getChosen() + "/";
-		}
-		else return;
-		if (dstProfile.dataDir.equals(profile.dataDir)) return;
+		dstProfile.dataDir=selectTargetDir();
+		if (dstProfile.dataDir.equals(profile.dataDir) ||
+			dstProfile.dataDir.equals("")) return;
+		
 		MessageBox mBox = new MessageBox (MyLocale.getMsg(144,"Warning"),MyLocale.getMsg(147,"Cachedata of ALL VISIBLE caches will be moved! Continue?"), MessageBox.IDYES |MessageBox.IDNO);
 		if (mBox.execute() != MessageBox.IDOK){
 			return;
@@ -110,37 +74,68 @@
 		// Read indexfile of destination, if one exists
 		File ftest = new File(dstProfile.dataDir + "index.xml");
 		if(ftest.exists()){
-			dstProfile.readIndex();		}
-		dstDB = dstProfile.cacheDB;
-		// Loop through database
-		for(int i = 0; i<srcDB.size(); i++){
-			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
-			if(srcHolder.is_filtered==false){
-				// does cache exists in destDB ?
-				dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
-				if (dstPos >= 0){
-					deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-					moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-					// Update database
-					dstDB.set(dstPos,srcHolder);
-					srcDB.removeElementAt(i);
-					i--;
-				}
-				else {
-					deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
-					moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
-					// Update database
-					dstDB.add(srcHolder);
-					srcDB.removeElementAt(i);
-					i--;
-				}
-			}//if srcHolder...
-		}//for ... i < srcDB ...
+			dstProfile.readIndex();		
+		}
+		processCaches(new Mover(MyLocale.getMsg(142, "Move"),dstProfile));
 		// write indexfiles
 		dstProfile.saveIndex(pref, Profile.NO_SHOW_PROGRESS_BAR,dstProfile.filterActive,dstProfile.filterInverted);
 		profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR);
 	}
-
+	
+	 /**
+	  * This function carries out the copy/delete/move with a progress bar. 
+	  * The Executor class defines what operation is to be carried out.
+	  * @param exec
+	  */
+	 private void processCaches(Executor exec) {
+		int size=srcDB.size();
+		int count=0;
+		// Count the number of caches to move/delete/copy
+		for(int i = 0; i<size; i++) {
+			if(((CacheHolder)srcDB.get(i)).is_filtered==false) count++;
+		}
+		myProgressBarForm pbf = new myProgressBarForm();
+		Handle h = new Handle();
+		pbf.setTask(h,exec.title);
+		pbf.exec();
+		
+		int nProcessed=0;
+		// Now do the actual work
+		for(int i = size-1; i>=0; i--){
+			CacheHolder srcHolder=(CacheHolder)srcDB.get(i);
+			if(srcHolder.is_filtered==false){
+				h.progress = ((float)nProcessed++)/(float)count;
+				h.changed();
+				//Now do the copy/delete/move of the cache
+				exec.doIt(i,srcHolder);
+			}
+			if (pbf.isClosed) break;
+		}
+		pbf.exit(0);
+	 }
+	
+	 class myProgressBarForm extends ProgressBarForm {
+		 boolean isClosed=false;
+		 protected boolean canExit(int exitCode) {
+			isClosed=true;
+			return true;
+		 }
+	 }
+	 
+	//////////////////////////////////////////////////////////////////////
+	// Utility functions
+	//////////////////////////////////////////////////////////////////////
+	
+	public String selectTargetDir() {
+		// Select destination directory
+		FileChooser fc = new FileChooser(FileChooser.DIRECTORY_SELECT, pref.baseDir);
+		fc.setTitle(MyLocale.getMsg(148,"Select Target directory"));
+		if(fc.execute() != FormBase.IDCANCEL){
+			return fc.getChosen() + "/";
+		}
+		else return "";
+	}
+	 
 	public void deleteCacheFiles(String wpt, String dir){
 		// delete files in dstDir to clean up trash
 		String tmp[] = new FileBugfix(dir).list(wpt + "*.*", ewe.io.FileBase.LIST_FILES_ONLY);
@@ -183,7 +178,75 @@
 	    catch (Exception ex){
 	    	Vm.debug("Filecopy failed");
 	    }
-	  }
+	}
 
+	//////////////////////////////////////////////////////////////////////
+	// Executor
+	//////////////////////////////////////////////////////////////////////
+		
+	private abstract class Executor {
+		String title;
+		Profile dstProfile;
+		public void doIt(int i, CacheHolder srcHolder){}
+	}
 	 
+	private class Deleter extends Executor {
+		 Deleter(String title) {
+			 this.title=title;
+		 }
+		 public void doIt(int i,CacheHolder srcHolder) {
+			deleteCacheFiles(srcHolder.wayPoint,profile.dataDir);
+			srcDB.removeElementAt(i);
+		 }
+	}
+	 
+	private class Copier extends Executor {
+		 Copier(String title, Profile dstProfile) {
+			 this.title=title;
+			 this.dstProfile=dstProfile;
+		 }
+		 public void doIt(int i,CacheHolder srcHolder) {
+			// does cache exists in destDB ?
+			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
+			if (dstPos >= 0){
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.set(dstPos,srcHolder);
+			}
+			else {
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				copyCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.add(srcHolder);
+			}
+		 }		 
+	}
+
+	private class Mover extends Executor {
+		 Mover(String title, Profile dstProfile) {
+			 this.title=title;
+			 this.dstProfile=dstProfile;
+		 }
+		 public void doIt(int i,CacheHolder srcHolder) {
+			// does cache exists in destDB ?
+			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
+			if (dstPos >= 0){
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.set(dstPos,srcHolder);
+				srcDB.removeElementAt(i);
+				i--;
+			}
+			else {
+				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);
+				moveCacheFiles(srcHolder.wayPoint,profile.dataDir, dstProfile.dataDir);
+				// Update database
+				dstProfile.cacheDB.add(srcHolder);
+				srcDB.removeElementAt(i);
+				i--;
+			}
+		 }		 
+	}
 }



From pfeffer at mail.berlios.de  Sun Oct  7 11:46:53 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sun, 7 Oct 2007 11:46:53 +0200
Subject: [Cachewolf-svn] r960 - in trunk: resources src/CacheWolf/navi
Message-ID: <200710070946.l979krQa022331@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-07 11:46:37 +0200 (Sun, 07 Oct 2007)
New Revision: 960

Added:
   trunk/resources/loupe_all.png
   trunk/resources/loupe_better_overview.png
   trunk/resources/loupe_more_details.png
   trunk/resources/map_cd.png
   trunk/resources/map_off.png
   trunk/resources/map_on.png
   trunk/resources/map_open.png
   trunk/resources/move2center.png
   trunk/resources/move2goto.png
   trunk/resources/move2gps.png
   trunk/resources/res_gps_goto.png
   trunk/resources/res_high.png
   trunk/resources/res_manuell.png
Modified:
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
MovingMap: added icons in the map-menu thanks to blackeye501 for making the icons

Added: trunk/resources/loupe_all.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/loupe_all.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/loupe_better_overview.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/loupe_better_overview.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/loupe_more_details.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/loupe_more_details.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/map_cd.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/map_cd.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/map_off.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/map_off.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/map_on.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/map_on.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/map_open.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/map_open.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/move2center.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/move2center.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/move2goto.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/move2goto.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/move2gps.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/move2gps.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/res_gps_goto.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/res_gps_goto.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/res_high.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/res_high.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/res_manuell.png
===================================================================
(Binary files differ)


Property changes on: trunk/resources/res_manuell.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-10-06 20:31:23 UTC (rev 959)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-10-07 09:46:37 UTC (rev 960)
@@ -1318,25 +1318,25 @@
 	MenuItem miLuminary[];
 
 	Menu mapsMenu;
-	MenuItem selectMapMI = new MenuItem("Select a map manually$s", 0, null);
-	MenuItem changeMapDirMI = new MenuItem("Change map directory$c", 0, null);
-	MenuItem showMapMI = new MenuItem("Show map", 0, null);
-	MenuItem hideMapMI = new MenuItem("Hide map", 0, null);
+	MenuItem selectMapMI = new MenuItem("Select a map manually$s", new IconAndText(new mImage("map_open.png"), "Select a map manually", null, Graphics.RIGHT));
+	MenuItem changeMapDirMI = new MenuItem("Change map directory$c", new IconAndText(new mImage("map_cd.png"), "Change map directory", null, Graphics.RIGHT));
+	MenuItem showMapMI = new MenuItem("Show map", new IconAndText(new mImage("map_on.png"), "Show map", null, Graphics.RIGHT));
+	MenuItem hideMapMI = new MenuItem("Hide map", new IconAndText(new mImage("map_off.png"), "Hide map", null, Graphics.RIGHT));
 	// automatic
 	MenuItem mapChangeModusMI = new MenuItem("Modus for automatic map change", MenuItem.Separator, null);;
-	MenuItem highestResGpsDestMI = new MenuItem("Highest res. containing dest. & cur. position", 0, null); //immer h?chste Aufl?sung w?hlen, die akt. Pos. und Ziel enthalten 
-	MenuItem highestResolutionMI = new MenuItem("Highest resolution", 0, null); //immer h?chste Aufl?sung w?hlen 
-	MenuItem keepManResolutionMI = new MenuItem("Keep manual resolution", 0, null); // manuell gew?hlte Aufl?sung beibehalten  
+	MenuItem highestResGpsDestMI = new MenuItem("Highest res. containing dest. & cur. position", new IconAndText(new mImage("res_gps_goto.png"), "Highest res. containing dest. & cur. position", null, Graphics.RIGHT)); //immer h?chste Aufl?sung w?hlen, die akt. Pos. und Ziel enthalten 
+	MenuItem highestResolutionMI = new MenuItem("Highest resolution", new IconAndText(new mImage("res_high.png"), "Highest resolution", null, Graphics.RIGHT)); //immer h?chste Aufl?sung w?hlen 
+	MenuItem keepManResolutionMI = new MenuItem("Keep manual resolution", new IconAndText(new mImage("res_manuell.png"), "Keep manual resolution", null, Graphics.RIGHT)); // manuell gew?hlte Aufl?sung beibehalten  
 	// manuell
 	MenuItem mapChangeResMI = new MenuItem("Change resolution manually", MenuItem.Separator, null);;
-	MenuItem AllCachesResMI = new MenuItem("Load a map containing all marked caches", 0, null); // Karte w?hlen, die alle markierten Caches enth?lt  
-	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", new IconAndText(new mImage("lupe_more_details.png"), "Load a map with more details", null, Graphics.RIGHT)); // laod a map with more details 
-	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", new IconAndText(new mImage("lupe_better_overview.png"), "Load a map for a better overview", null, Graphics.RIGHT)); // Load a map for a better overview --> lesser details  
+	MenuItem AllCachesResMI = new MenuItem("Load a map containing all marked caches",  new IconAndText(new mImage("loupe_all.png"), "Load a map containing all marked caches", null, Graphics.RIGHT));   
+	MenuItem moreDetailsMI = new MenuItem("Load a map with more details", new IconAndText(new mImage("loupe_more_details.png"), "Load a map with more details", null, Graphics.RIGHT)); // laod a map with more details 
+	MenuItem moreOverviewMI = new MenuItem("Load a map for a better overview", new IconAndText(new mImage("loupe_better_overview.png"), "Load a map for a better overview", null, Graphics.RIGHT)); // Load a map for a better overview --> lesser details  
 	// move map to
 	MenuItem moveToMI = new MenuItem("Move map to an load map", MenuItem.Separator, null);;
-	MenuItem moveToDestMI = new MenuItem("move to goto point", 0, null); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
-	MenuItem moveToGpsMI = new MenuItem("move to GPS position", 0, null);   
-	MenuItem moveToCenterMI = new MenuItem("move to Centre", 0, null);   
+	MenuItem moveToDestMI = new MenuItem("Move to goto point", new IconAndText(new mImage("move2goto.png"), "Move to goto point", null, Graphics.RIGHT)); //* Karte zum Ziel verschieben (und ggf. entsprechende Karte laden) 
+	MenuItem moveToGpsMI = new MenuItem("Move to GPS position", new IconAndText(new mImage("move2gps.png"), "Move to GPS position", null, Graphics.RIGHT));   
+	MenuItem moveToCenterMI = new MenuItem("Move to centre", new IconAndText(new mImage("move2center.png"), "Move to centre", null, Graphics.RIGHT));   
 
 	CacheHolder clickedCache;
 	MovingMap mm;



From mirabilos at mail.berlios.de  Sun Oct  7 12:29:22 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sun, 7 Oct 2007 12:29:22 +0200
Subject: [Cachewolf-svn] r961 - trunk/resources/attributes-big
Message-ID: <200710071029.l97ATM9X025908@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-07 12:29:20 +0200 (Sun, 07 Oct 2007)
New Revision: 961

Added:
   trunk/resources/attributes-big/night-undef.gif
   trunk/resources/attributes-big/oconly-undef.gif
   trunk/resources/attributes-big/wwwlink-no.gif
   trunk/resources/attributes-big/wwwlink-undef.gif
   trunk/resources/attributes-big/wwwlink.gif
Log:
add the remaining opencaching.de attributes
(only night.gif is conflicting, I?m retaining the gc.com one here)


Added: trunk/resources/attributes-big/night-undef.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/night-undef.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/oconly-undef.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/oconly-undef.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/wwwlink-no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/wwwlink-no.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/wwwlink-undef.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/wwwlink-undef.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/resources/attributes-big/wwwlink.gif
===================================================================
(Binary files differ)


Property changes on: trunk/resources/attributes-big/wwwlink.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From salzkammergut at mail.berlios.de  Sun Oct  7 13:08:10 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Oct 2007 13:08:10 +0200
Subject: [Cachewolf-svn] r962 - trunk/src/CacheWolf
Message-ID: <200710071108.l97B8AMO016870@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-07 13:08:00 +0200 (Sun, 07 Oct 2007)
New Revision: 962

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
CacheHolder: modified update function to ensure that valid coordinates are not overwritten by invalid ones. (This affects GPXImporter and Spider).

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-10-07 10:29:20 UTC (rev 961)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-10-07 11:08:00 UTC (rev 962)
@@ -105,8 +105,11 @@
 	this.wayPoint = ch.wayPoint;
 	this.CacheName = ch.CacheName;
 	this.CacheOwner = ch.CacheOwner;
-	this.pos = ch.pos;
-	this.LatLon = ch.LatLon;
+	// Don't overwrite valid coordinates with invalid ones
+	if (ch.pos.isValid() || !this.pos.isValid()) {
+		this.pos = ch.pos;
+		this.LatLon = ch.LatLon;
+	}
 	this.DateHidden = ch.DateHidden;
 	this.CacheSize = ch.CacheSize;
 	this.kilom = ch.kilom;



From salzkammergut at mail.berlios.de  Sun Oct  7 16:55:03 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Oct 2007 16:55:03 +0200
Subject: [Cachewolf-svn] r963 - trunk/src/CacheWolf
Message-ID: <200710071455.l97Et35T008710@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-07 16:54:55 +0200 (Sun, 07 Oct 2007)
New Revision: 963

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/Travelbug.java
   trunk/src/CacheWolf/TravelbugList.java
Log:
When updating a cache (via GPX import for instance), the found date and the mission for travelbugs in the cache are retained.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-10-07 11:08:00 UTC (rev 962)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-10-07 14:54:55 UTC (rev 963)
@@ -101,8 +101,11 @@
 }
 
 public void update(CacheHolder ch) {
-	this.CacheStatus=ch.CacheStatus;
-	this.wayPoint = ch.wayPoint;
+	// Don't overwrite an existing found date
+	if (!this.is_found) {
+		this.CacheStatus=ch.CacheStatus;
+		this.is_found = ch.is_found;
+	}this.wayPoint = ch.wayPoint;
 	this.CacheName = ch.CacheName;
 	this.CacheOwner = ch.CacheOwner;
 	// Don't overwrite valid coordinates with invalid ones
@@ -122,7 +125,6 @@
 	this.is_archived = ch.is_archived;
 	this.is_available = ch.is_available;
 	this.is_owned = ch.is_owned;
-	this.is_found = ch.is_found;
 	this.is_filtered = ch.is_filtered;
 	this.is_log_update = ch.is_log_update;
 	this.is_update = ch.is_update;

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2007-10-07 11:08:00 UTC (rev 962)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2007-10-07 14:54:55 UTC (rev 963)
@@ -65,17 +65,26 @@
 	 
 	  /**
 	 * Method to update an existing cache with new data. This is
-	 * necessary to avoid missing old logs.
+	 * necessary to avoid missing old logs. Called from GPX Importer
 	 * @param newCh new cache data
 	 * @return CacheHolder with updated data
 	 */
 	public CacheHolderDetail update(CacheHolderDetail newCh){
 		  super.update(newCh);
 		  // flags
-		  if (this.is_found == true) this.CacheStatus = MyLocale.getMsg(318,"Found");
+		  if (this.is_found == true && this.CacheStatus.equals("")) this.CacheStatus = MyLocale.getMsg(318,"Found");
 
-		  //travelbugs: overriding is OK, since GPX-File contains all actual travelbugs
+		  //travelbugs:GPX-File contains all actual travelbugs but not the missions
+		  //  we need to check whether the travelbug is already in the existing list
 		  this.has_bug = newCh.Travelbugs.size()>0;
+		  for (int i=newCh.Travelbugs.size()-1; i>=0; i--) {
+			 Travelbug tb=newCh.Travelbugs.getTB(i);  
+		     Travelbug oldTB=this.Travelbugs.find(tb.getName());
+		     // If the bug is already in the cache, we keep it
+		     if (oldTB!=null)
+		    	 newCh.Travelbugs.replace(i,oldTB);
+		    
+		  }
 		  this.Travelbugs = newCh.Travelbugs;
 		  
 		  // URL

Modified: trunk/src/CacheWolf/Travelbug.java
===================================================================
--- trunk/src/CacheWolf/Travelbug.java	2007-10-07 11:08:00 UTC (rev 962)
+++ trunk/src/CacheWolf/Travelbug.java	2007-10-07 14:54:55 UTC (rev 963)
@@ -23,10 +23,10 @@
 
 	/** Construct a travelbug with id, name and mission */
 	public Travelbug(String guid, String name, String mission) {
-		this.guid = guid;
-		this.name = name;
-		this.mission = mission;
-		this.trackingNo="";
+		setGuid(guid);
+		setName(name);
+		setMission(mission);
+		setTrackingNo("");
 	}
 	
 	public String getGuid() {
@@ -42,7 +42,7 @@
 	}
 
 	public void setName(String name) {
-		this.name = name;
+		this.name = SafeXML.cleanback(name);
 	}
 
 	public String getTrackingNo() {

Modified: trunk/src/CacheWolf/TravelbugList.java
===================================================================
--- trunk/src/CacheWolf/TravelbugList.java	2007-10-07 11:08:00 UTC (rev 962)
+++ trunk/src/CacheWolf/TravelbugList.java	2007-10-07 14:54:55 UTC (rev 963)
@@ -33,15 +33,29 @@
 		tbList.add(tb);
 	}
 	
-	/** Trmove a travelbug from the list */
+	/** Remove a travelbug from the list */
 	public void remove(int i) {
 		tbList.removeElementAt(i);
 	}
+
+	/** Replace a travelbug in the list */
+	public void replace(int i, Travelbug tb) {
+		tbList.set(i, tb);
+	}
 	
 	/** Construct an empty travelbug list */
 	public TravelbugList() {
 	}
 	
+	/** Find a travelbug in the list. 
+	 *  Return null if not found */
+	public Travelbug find(String name) {
+		name=name.trim();
+		for (int i=size()-1; i>=0; i--)
+			if (name.equals(getTB(i).getName().trim())) return getTB(i);
+		return null;
+	}
+	
 	/** Convert the old representation to a new one. In the old representation,
 	 * all travelbugs were stored as one HTML string within the cache.xml file.
 	 * This representation does not include the id or guid and does not allow for



From salzkammergut at mail.berlios.de  Sun Oct  7 19:59:18 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Oct 2007 19:59:18 +0200
Subject: [Cachewolf-svn] r964 - in trunk/src/CacheWolf: . navi
Message-ID: <200710071759.l97HxIDZ002642@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-07 19:59:12 +0200 (Sun, 07 Oct 2007)
New Revision: 964

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
MM: Fix: When showing the cache description via the context menu of the MM, the wrong cache description was displayed.

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-10-07 14:54:55 UTC (rev 963)
+++ trunk/src/CacheWolf/MainTab.java	2007-10-07 17:59:12 UTC (rev 964)
@@ -244,8 +244,11 @@
 		gotoP.setDestinationAndSwitch(LatLon); 
 	}
 
-	public void openDesciptionPanel(CacheHolder chi) {
+	public void openDescriptionPanel(CacheHolder chi) {
 		MyLocale.setSIPOff();
+		// To change cache we need to be in panel 0
+		onLeavingPanel(oldCard);
+		onEnteringPanel(0); oldCard=0;
 		int row = profile.getCacheIndex(chi.wayPoint);
 		tbP.selectRow(row);
 		//tbP.tc.scrollToVisible(row, 0);

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-10-07 14:54:55 UTC (rev 963)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-10-07 17:59:12 UTC (rev 964)
@@ -1705,7 +1705,7 @@
 						close.type = WindowEvent.CLOSE;
 						mm.postEvent(close);
 						MainTab mainT = Global.mainTab;
-						mainT.openDesciptionPanel(clickedCache);
+						mainT.openDescriptionPanel(clickedCache);
 					}
 					if (action == newWayPointMenuItem) {
 						kontextMenu.close();



From salzkammergut at mail.berlios.de  Sun Oct  7 21:57:08 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 7 Oct 2007 21:57:08 +0200
Subject: [Cachewolf-svn] r965 - trunk/src/CacheWolf
Message-ID: <200710071957.l97Jv8RH009004@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-07 21:57:05 +0200 (Sun, 07 Oct 2007)
New Revision: 965

Modified:
   trunk/src/CacheWolf/ImagePanel.java
Log:
ImagePanel: Fix for title for user pictures (now positioned properly)

Modified: trunk/src/CacheWolf/ImagePanel.java
===================================================================
--- trunk/src/CacheWolf/ImagePanel.java	2007-10-07 17:59:12 UTC (rev 964)
+++ trunk/src/CacheWolf/ImagePanel.java	2007-10-07 19:57:05 UTC (rev 965)
@@ -55,6 +55,7 @@
 		//this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
 		this.checkScrolls();
 		this.refresh();
+		locY=0;
 		addTitle(MyLocale.getMsg(340,"Cache Images:"));
 		locY = 20;
 		locX = padding;
@@ -106,6 +107,7 @@
 		g.drawText(title, 0,0);
 		g.free();
 		aImg = new AniImage(img);
+		aImg.setLocation(0, locY);
 		addImage(aImg);
 		aImg.refresh();
 	}



From mik77 at mail.berlios.de  Wed Oct 10 22:36:13 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 10 Oct 2007 22:36:13 +0200
Subject: [Cachewolf-svn] r966 - in trunk: resources src/CacheWolf
Message-ID: <200710102036.l9AKaDkA020279@sheep.berlios.de>

Author: mik77
Date: 2007-10-10 22:36:03 +0200 (Wed, 10 Oct 2007)
New Revision: 966

Modified:
   trunk/resources/spider.def
   trunk/src/CacheWolf/SpiderGC.java
Log:
adaption to new GC-design (thanks to blackeye501)

Modified: trunk/resources/spider.def
===================================================================
--- trunk/resources/spider.def	2007-10-07 19:57:05 UTC (rev 965)
+++ trunk/resources/spider.def	2007-10-10 20:36:03 UTC (rev 966)
@@ -13,6 +13,7 @@
 # Version 2.9 - 20070817 Bessere Unterscheidung zwischen Werbung vs.normalen Caches + Caches ohne Richtung/Entfenung
 # Version 2.10 - 20070825 Travelbug support
 # Version 2.11 - 20070907 get travelbug mission by tracking number
+# Version 3.0 - 20071010 adaption to new GC-design
 #============================================================
 # A suffix of Rex indicates a regular expression
 # A suffix of ExStart indicates the start of an Extractor search pattern
@@ -35,7 +36,7 @@
 listBlockRex       = <table id="dlResults"((?s).*?)</table>
 lineRex            = <tr\ bgcolor='#.{6}'>(?:(?s).*?)<td\ valign="top"\ align="left">((?s).*?)</tr>
 distRex            = <br\ />(.*?)(km|mi)</td>
-waypointRex        = </a> \\((.*?)\\)<br>
+waypointRex        = \\(GC(.*?)\\)<br\ />
 showOnlyFound      = &f=1
 firstLine          = http://www.geocaching.com/seek/nearest.aspx?
 nextListPage       = /seek/nearest.aspx
@@ -47,11 +48,11 @@
 fetchAllLogs       = &log=y
 cacheUnavailable   = This\ cache\ is\ temporarily\ unavailable
 cacheArchived      = This cache\ has\ been\ archived
-latLonRex          = <span\ id="LatLon"><b>((?s).*?)</b></span>
+latLonRex          = <span\ id="LatLon"\ style="font-weight:bold;">((?s).*?)</span>
 shortDescRex       = <span\ id="ShortDescription">((?s).*?)</span>
 longDescRex        = <span\ id="LongDescription">((?s).*?)<strong>Additional\ Hints
 cacheNameRex       = <span\ id="CacheName">((?s).*?)</span>
-cacheOwnerRex      = <span\ id="CacheOwner">by\ <a\ href=(?:(?s).*?)>((?s).*?)</a></span></b>
+cacheOwnerRex      = <span\ id="CacheOwner">by\ <a\ href=(?:(?s).*?)>((?s).*?)</a></span>
 dateHiddenRex      = <span\ id="DateHidden">((?s).*?)</span>
 hintsRex           = <span\ id="Hints"\ class="displayMe">((?s).*?)</span>
 sizeRex            = alt="Size:\ ((?s).*?)"\ title="Size:

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-07 19:57:05 UTC (rev 965)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-10 20:36:03 UTC (rev 966)
@@ -49,6 +49,7 @@
 	private static Preferences pref;
 	private Profile profile;
 	private static String viewstate = "";
+	private static String eventvalidation = "";
 	private static String cookieID = "";
 	private static String cookieSession = "";
 	private static double distance = 0;
@@ -111,14 +112,21 @@
 		}
 		if (!infB.isClosed) { // If user has not aborted, we continue
 			Regex rexCookieID = new Regex("(?i)Set-Cookie: userid=(.*?);.*");
-			Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*?)\" />");
+			Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\" />");
+			Regex rexEventvalidation = new Regex("id=\"__EVENTVALIDATION\" value=\"(.*?)\" />");
 			Regex rexCookieSession = new Regex("(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*");
-			rex.search(start);
-			if(rex.didMatch()){
-				viewstate = rex.stringMatched(1);
+			rexViewstate.search(start);
+			if(rexViewstate.didMatch()){
+				viewstate = rexViewstate.stringMatched(1);
 				//Vm.debug("ViewState: " + viewstate);
 			} else
 				pref.log("Viewstate not found before login");
+			rexEventvalidation.search(start);
+			if(rexEventvalidation.didMatch()){
+				eventvalidation = rexEventvalidation.stringMatched(1);
+				//Vm.debug("EVENTVALIDATION: " + eventvalidation);
+			} else
+				pref.log("Eventvalidation not found before login");
 			//Ok now login!
 			try{
 				pref.log("Logging in as "+pref.myAlias);
@@ -126,7 +134,8 @@
 					+ "&" + URL.encodeURL("myUsername",false) +"="+ encodeUTF8(new String(Utils.encodeJavaUtf8String(pref.myAlias)))
 				    + "&" + URL.encodeURL("myPassword",false) +"="+ encodeUTF8(new String(Utils.encodeJavaUtf8String(passwort)))
 				    + "&" + URL.encodeURL("cookie",false) +"="+ URL.encodeURL("on",false)
-				    + "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false);
+				    + "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false)
+	     		    + "&" + URL.encodeURL("__EVENTVALIDATION",false) +"="+ URL.encodeURL(eventvalidation,false);
 				start = fetch_post(loginPage, doc, nextPage);  // /login/default.aspx
 				if(start.indexOf(loginSuccess) > 0)
 					pref.log("Login successful");
@@ -143,11 +152,11 @@
 				return ERR_LOGIN;
 			}
 
-			rex.search(start);
-			if (!rex.didMatch()) {
+			rexViewstate.search(start);
+			if (!rexViewstate.didMatch()) {
 				pref.log("Viewstate not found");
 			}
-			viewstate = rex.stringMatched(1);
+			viewstate = rexViewstate.stringMatched(1);
 			rexCookieID.search(start);
 			if (!rexCookieID.didMatch()) {
 				pref.log("CookieID not found");
@@ -265,7 +274,8 @@
 			ch.is_new = false;
 		}
 		String start = "";
-		Regex rex = new Regex("name=\"__VIEWSTATE\" value=\"(.*)\" />");
+		Regex rexViewstate = new Regex("id=\"__VIEWSTATE\" value=\"(.*)\" />");
+		Regex rexEventvalidation = new Regex("id=\"__EVENTVALIDATION\" value=\"(.*)\" />");
 		String doc = "";
 
 		if (!loggedIn || Global.getPref().forceLogin) {
@@ -317,8 +327,10 @@
 			//Loop till maximum distance has been found or no more caches are in the list
 			while(distance > 0){
 				if (infB.isClosed) break;
-				rex.search(start);
-				viewstate = rex.stringMatched(1);
+				rexViewstate.search(start);
+				viewstate = rexViewstate.stringMatched(1);
+				rexEventvalidation.search(start);
+				eventvalidation = rexEventvalidation.stringMatched(1);
 				//Vm.debug("In loop");
 				Regex listBlockRex = new Regex(p.getProp("listBlockRex")); // "<table id=\"dlResults\"((?s).*?)</table>"
 				listBlockRex.search(start);
@@ -343,10 +355,10 @@
 				if(distance > 0){
 					page_number++;
 					if(page_number >= 15) page_number = 5;
-					doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false)
-					//if(doNotgetFound) doc += "&f=1";
-					    + "&" + URL.encodeURL("__EVENTTARGET",false) +"="+ URL.encodeURL("ResultsPager:_ctl"+page_number,false)
-					    + "&" + URL.encodeURL("__EVENTARGUMENT",false) +"="+ URL.encodeURL("",false);
+					doc = URL.encodeURL("__EVENTTARGET",false) +"="+ URL.encodeURL("pgrTop$_ctl16",false)
+					    + "&" + URL.encodeURL("__EVENTARGUMENT",false) +"="+ URL.encodeURL("",false)
+					    + "&" + URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false)
+					    + "&" + URL.encodeURL("__EVENTVALIDATION",false) +"="+ URL.encodeURL(eventvalidation,false);
 					try{
 						start = "";
 						pref.log("Fetching next list page:" + doc);
@@ -572,7 +584,7 @@
 		inRex = new Regex(p.getProp("waypointRex"));
 		inRex.search(doc);
 		if (!inRex.didMatch()) return "???";
-		return inRex.stringMatched(1);
+		return "GC"+inRex.stringMatched(1);
 	}
 
 	/**



From salzkammergut at mail.berlios.de  Thu Oct 11 22:35:44 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Thu, 11 Oct 2007 22:35:44 +0200
Subject: [Cachewolf-svn] r967 - trunk/src/CacheWolf
Message-ID: <200710112035.l9BKZiQQ008559@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-11 22:35:32 +0200 (Thu, 11 Oct 2007)
New Revision: 967

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
myTableModel: Fix: When the checkbox column was remapped to a column other than 0, it did not work properly.

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-10-10 20:36:03 UTC (rev 966)
+++ trunk/src/CacheWolf/myTableModel.java	2007-10-11 20:35:32 UTC (rev 967)
@@ -289,18 +289,18 @@
 		if (cell==null) return false;
 		try{
 			// Check whether the click is on the checkbox image
-			if (cell.y>=0 && cell.x==0) {
+			if (cell.y>=0 && colMap[cell.x]==0) {
 				Global.getProfile().selectionChanged = true;
 				if ((penEventModifiers & IKeys.SHIFT)>0) {
 					if (tcControl.cursor.y >= 0) { // Second row being marked with shift key pressed
 						if (tcControl.cursor.y<cell.y)
-							toggleSelect(tcControl.cursor.y,cell.y);
+							toggleSelect(tcControl.cursor.y,cell.y,cell.x);
 						else
-							toggleSelect(cell.y,tcControl.cursor.y);
+							toggleSelect(cell.y,tcControl.cursor.y,cell.x);
 					} else { // Remember this row as start of range, but don't toggle yet
 					}
 				} else { // Single row marked
-					toggleSelect(cell.y,cell.y);
+					toggleSelect(cell.y,cell.y,cell.x);
 				}
 			}
 			if(cell.y == -1){ // Hit a header => sort the table accordingly
@@ -340,14 +340,15 @@
 	 * If from!=to, each cache is toggled irrespective of its type (main or addi)
 	 * @param from index of first cache to toggle
 	 * @param to index of last cache to toggle
+	 * @param x is column of checkbox (does not have to be 0)
 	 */
-	void toggleSelect(int from, int to) {
+	void toggleSelect(int from, int to, int x) {
 		CacheHolder ch;
 		boolean singleRow= from == to;
 		for (int j=from; j<=to; j++) {
 			ch=(CacheHolder) cacheDB.get(j);
 			ch.is_Checked= !ch.is_Checked; 
-			tcControl.repaintCell(j, 0);
+			tcControl.repaintCell(j, x);
 			// set the ceckbox also for addi wpts
 			if (ch.hasAddiWpt() && singleRow){
 				CacheHolder addiWpt;
@@ -356,7 +357,7 @@
 					addiWpt = (CacheHolder)ch.addiWpts.get(i);
 					addiWpt.is_Checked = ch.is_Checked;
 					if (!addiWpt.is_filtered){
-						tcControl.repaintCell(cacheDB.find(addiWpt), 0);
+						tcControl.repaintCell(cacheDB.find(addiWpt), x);
 					}
 				}
 				



From mik77 at mail.berlios.de  Fri Oct 12 20:52:17 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 12 Oct 2007 20:52:17 +0200
Subject: [Cachewolf-svn] r968 - trunk/src/CacheWolf
Message-ID: <200710121852.l9CIqHAH026744@sheep.berlios.de>

Author: mik77
Date: 2007-10-12 20:52:12 +0200 (Fri, 12 Oct 2007)
New Revision: 968

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
Don't try to log in, if already logged in.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-11 20:35:32 UTC (rev 967)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-12 18:52:12 UTC (rev 968)
@@ -121,35 +121,40 @@
 				//Vm.debug("ViewState: " + viewstate);
 			} else
 				pref.log("Viewstate not found before login");
-			rexEventvalidation.search(start);
-			if(rexEventvalidation.didMatch()){
-				eventvalidation = rexEventvalidation.stringMatched(1);
-				//Vm.debug("EVENTVALIDATION: " + eventvalidation);
-			} else
-				pref.log("Eventvalidation not found before login");
-			//Ok now login!
-			try{
-				pref.log("Logging in as "+pref.myAlias);
-				doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false)
+			
+			if(start.indexOf(loginSuccess) > 0)
+				pref.log("Already logged in");
+			else {
+				rexEventvalidation.search(start);
+				if(rexEventvalidation.didMatch()){
+					eventvalidation = rexEventvalidation.stringMatched(1);
+					//Vm.debug("EVENTVALIDATION: " + eventvalidation);
+				} else
+					pref.log("Eventvalidation not found before login");
+				//Ok now login!
+				try{
+					pref.log("Logging in as "+pref.myAlias);
+					doc = URL.encodeURL("__VIEWSTATE",false) +"="+ URL.encodeURL(viewstate,false)
 					+ "&" + URL.encodeURL("myUsername",false) +"="+ encodeUTF8(new String(Utils.encodeJavaUtf8String(pref.myAlias)))
-				    + "&" + URL.encodeURL("myPassword",false) +"="+ encodeUTF8(new String(Utils.encodeJavaUtf8String(passwort)))
-				    + "&" + URL.encodeURL("cookie",false) +"="+ URL.encodeURL("on",false)
-				    + "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false)
-	     		    + "&" + URL.encodeURL("__EVENTVALIDATION",false) +"="+ URL.encodeURL(eventvalidation,false);
-				start = fetch_post(loginPage, doc, nextPage);  // /login/default.aspx
-				if(start.indexOf(loginSuccess) > 0)
-					pref.log("Login successful");
-				else {
-					pref.log("Login failed. Wrong Account or Password?");
+					+ "&" + URL.encodeURL("myPassword",false) +"="+ encodeUTF8(new String(Utils.encodeJavaUtf8String(passwort)))
+					+ "&" + URL.encodeURL("cookie",false) +"="+ URL.encodeURL("on",false)
+					+ "&" + URL.encodeURL("Button1",false) +"="+ URL.encodeURL("Login",false)
+					+ "&" + URL.encodeURL("__EVENTVALIDATION",false) +"="+ URL.encodeURL(eventvalidation,false);
+					start = fetch_post(loginPage, doc, nextPage);  // /login/default.aspx
+					if(start.indexOf(loginSuccess) > 0)
+						pref.log("Login successful");
+					else {
+						pref.log("Login failed. Wrong Account or Password?");
+						infB.close(0);
+						(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5501,"Login failed! Wrong account or password?"), MessageBox.OKB)).execute();
+						return ERR_LOGIN;
+					}
+				}catch(Exception ex){
+					pref.log("Login failed.", ex);
 					infB.close(0);
-				    (new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5501,"Login failed! Wrong account or password?"), MessageBox.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5501,"Login failed. Error loading page after login."), MessageBox.OKB)).execute();
 					return ERR_LOGIN;
 				}
-			}catch(Exception ex){
-				pref.log("Login failed.", ex);
-				infB.close(0);
-			    (new MessageBox(MyLocale.getMsg(5500,"Error"), MyLocale.getMsg(5501,"Login failed. Error loading page after login."), MessageBox.OKB)).execute();
-				return ERR_LOGIN;
 			}
 
 			rexViewstate.search(start);



From mik77 at mail.berlios.de  Fri Oct 12 21:25:48 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 12 Oct 2007 21:25:48 +0200
Subject: [Cachewolf-svn] r969 - trunk/src/CacheWolf
Message-ID: <200710121925.l9CJPmms028976@sheep.berlios.de>

Author: mik77
Date: 2007-10-12 21:25:46 +0200 (Fri, 12 Oct 2007)
New Revision: 969

Modified:
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Remember and always use forceLogin pref

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-10-12 18:52:12 UTC (rev 968)
+++ trunk/src/CacheWolf/MainMenu.java	2007-10-12 19:25:46 UTC (rev 969)
@@ -314,6 +314,7 @@
 			if(mev.selectedItem == mnuForceLogin) {
 				mnuForceLogin.modifiers^=MenuItem.Checked;
 				Global.getPref().forceLogin=(mnuForceLogin.modifiers&MenuItem.Checked)!=0;
+				Global.getPref().savePreferences();
 			}
 			///////////////////////////////////////////////////////////////////////
 			// subMenu for export, part of "Application" menu 

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-12 18:52:12 UTC (rev 968)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-12 19:25:46 UTC (rev 969)
@@ -198,7 +198,7 @@
 		if (ch.isAddiWpt()) return false;  // No point re-spidering an addi waypoint, comes with parent
 
 		// check if we need to login
-		if (!loggedIn){
+		if (!loggedIn || Global.getPref().forceLogin){
 			if (this.login()!=Form.IDOK) return false;
 			// loggedIn is already set by this.login()
 		}



From mik77 at mail.berlios.de  Fri Oct 12 22:06:35 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 12 Oct 2007 22:06:35 +0200
Subject: [Cachewolf-svn] r970 - trunk/src/CacheWolf
Message-ID: <200710122006.l9CK6Zpl031827@sheep.berlios.de>

Author: mik77
Date: 2007-10-12 22:06:33 +0200 (Fri, 12 Oct 2007)
New Revision: 970

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
Unnecessary login to GC when updating OC cache removed

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-10-12 19:25:46 UTC (rev 969)
+++ trunk/src/CacheWolf/myTableControl.java	2007-10-12 20:06:33 UTC (rev 970)
@@ -160,8 +160,6 @@
 			SpiderGC spider = new SpiderGC(pref, profile, false);
 			OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
 			//Vm.debug("ByPass? " + profile.byPassIndexActive);
-			if (!spider.loggedIn || Global.getPref().forceLogin) spider.login();
-			if (!spider.loggedIn) return;
 			Vm.showWait(true);
 			boolean alreadySaid = false;
 			boolean alreadySaid2 = false;



From mik77 at mail.berlios.de  Sat Oct 13 12:37:28 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sat, 13 Oct 2007 12:37:28 +0200
Subject: [Cachewolf-svn] r971 - trunk/src/CacheWolf
Message-ID: <200710131037.l9DAbSLW017483@sheep.berlios.de>

Author: mik77
Date: 2007-10-13 12:37:22 +0200 (Sat, 13 Oct 2007)
New Revision: 971

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
Check if regex matches before setting variable to result. 

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-12 20:06:33 UTC (rev 970)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-13 10:37:22 UTC (rev 971)
@@ -332,10 +332,25 @@
 			//Loop till maximum distance has been found or no more caches are in the list
 			while(distance > 0){
 				if (infB.isClosed) break;
+		
 				rexViewstate.search(start);
-				viewstate = rexViewstate.stringMatched(1);
+				if(rexViewstate.didMatch()){
+					viewstate = rexViewstate.stringMatched(1);
+					//Vm.debug("ViewState: " + viewstate);
+				} else {
+					viewstate = "";
+					pref.log("Viewstate not found");
+				}
+				
 				rexEventvalidation.search(start);
-				eventvalidation = rexEventvalidation.stringMatched(1);
+				if(rexEventvalidation.didMatch()){
+					eventvalidation = rexEventvalidation.stringMatched(1);
+					//Vm.debug("EVENTVALIDATION: " + eventvalidation);
+				} else {
+					eventvalidation = "";
+					pref.log("Eventvalidation not found");					
+				}
+
 				//Vm.debug("In loop");
 				Regex listBlockRex = new Regex(p.getProp("listBlockRex")); // "<table id=\"dlResults\"((?s).*?)</table>"
 				listBlockRex.search(start);



From salzkammergut at mail.berlios.de  Sat Oct 13 14:36:16 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 13 Oct 2007 14:36:16 +0200
Subject: [Cachewolf-svn] r972 - in trunk: resources src/CacheWolf
Message-ID: <200710131236.l9DCaG76028142@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-13 14:36:01 +0200 (Sat, 13 Oct 2007)
New Revision: 972

Modified:
   trunk/resources/blue.png
   trunk/resources/bug.png
   trunk/resources/green.png
   trunk/resources/red.png
   trunk/resources/skull.png
   trunk/resources/yellow.png
   trunk/src/CacheWolf/myTableModel.java
Log:
myTableModel: The icons in the list view are now displayed without the white frame (red, blue, yellow, skull and bug) with the correct background color

Modified: trunk/resources/blue.png
===================================================================
(Binary files differ)

Modified: trunk/resources/bug.png
===================================================================
(Binary files differ)

Modified: trunk/resources/green.png
===================================================================
(Binary files differ)

Modified: trunk/resources/red.png
===================================================================
(Binary files differ)

Modified: trunk/resources/skull.png
===================================================================
(Binary files differ)

Modified: trunk/resources/yellow.png
===================================================================
(Binary files differ)

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-10-13 10:37:22 UTC (rev 971)
+++ trunk/src/CacheWolf/myTableModel.java	2007-10-13 12:36:01 UTC (rev 972)
@@ -39,7 +39,7 @@
 	
 	public static Image cacheImages[] = new Image[454]; // Images are used by TableControl
 	private static Image noFindLogs[] = new Image[4];
-	private Image red, blue, green, yellow, skull;
+	private mImage red, blue, yellow, skull; // green
 	private Image checkboxTicked,checkboxUnticked;
 	private mImage bug;
 	private boolean sortAsc = false;
@@ -91,12 +91,12 @@
 		noFindLogs[1] = new Image("no_2_log.png");
 		noFindLogs[2] = new Image("no_3_log.png");
 		noFindLogs[3] = new Image("no_4_log.png");
-		red = new Image("red.png");
-		blue = new Image("blue.png");
-		green = new Image("green.png");
-		yellow = new Image("yellow.png");
-		skull = new Image("skull.png");
-		bug = new mImage("bug.png");
+		red = new mImage("red.png"); red.transparentColor=Color.White;
+		blue = new mImage("blue.png"); blue.transparentColor=Color.White;
+		//green = new mImage("green.png");green.transparentColor=Color.White;
+		yellow = new mImage("yellow.png");yellow.transparentColor=Color.White;
+		skull = new mImage("skull.png");skull.transparentColor=Color.DarkBlue;
+		bug = new mImage("bug.png");bug.transparentColor=Color.DarkBlue;
 		checkboxTicked = new Image("checkboxTicked.png");
 		checkboxUnticked= new Image("checkboxUnticked.png");
 		updateRows();
@@ -246,17 +246,17 @@
 						case 3: // Terrain
 							return (String)ch.terrain;
 						case 4: // Waypoint
-							if(ch.is_incomplete) return new IconAndText((IImage)skull, ch.wayPoint, fm);
-							if(ch.is_update    ) return new IconAndText((IImage)red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
-							if(ch.is_new       ) return new IconAndText((IImage)yellow, ch.wayPoint, fm);
-							if(ch.is_log_update) return new IconAndText((IImage)blue, ch.wayPoint, fm);
+							if(ch.is_incomplete) return new IconAndText(skull, ch.wayPoint, fm);
+							if(ch.is_update    ) return new IconAndText(red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
+							if(ch.is_new       ) return new IconAndText(yellow, ch.wayPoint, fm);
+							if(ch.is_log_update) return new IconAndText(blue, ch.wayPoint, fm);
 							return (String)ch.wayPoint;
 						case 5: // Cachename
 							// Fast return for majority of case
 							if (ch.has_bug == false && ch.noFindLogs==0) return (String)ch.CacheName; 
 							// Now need more checks
 							IconAndText wpVal = new IconAndText();
-							if(ch.has_bug == true) wpVal.addColumn((IImage)bug);
+							if(ch.has_bug == true) wpVal.addColumn(bug);
 							if(ch.noFindLogs > 0){
 								if (ch.noFindLogs > noFindLogs.length) 
 									wpVal.addColumn((IImage)noFindLogs[noFindLogs.length-1]);



From salzkammergut at mail.berlios.de  Sat Oct 13 14:44:48 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 13 Oct 2007 14:44:48 +0200
Subject: [Cachewolf-svn] r973 - trunk/src/CacheWolf
Message-ID: <200710131244.l9DCim4m028533@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-13 14:44:44 +0200 (Sat, 13 Oct 2007)
New Revision: 973

Modified:
   trunk/src/CacheWolf/CacheHolder.java
Log:
CacheHolder: Improved update of CacheStatus when refreshing cache from GC. A CacheStatus which includes hours and minutes is not overwritten. 

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-10-13 12:36:01 UTC (rev 972)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-10-13 12:44:44 UTC (rev 973)
@@ -101,8 +101,15 @@
 }
 
 public void update(CacheHolder ch) {
-	// Don't overwrite an existing found date
-	if (!this.is_found) {
+	/* Here we have to distinguish several cases:
+	   this.is_found       this                ch               Update 'this'
+	   --------------------------------------------------------------------
+	   false               empty               yyyy-mm-dd       yes
+	   true                "Found"             yyyy-mm-dd       yes
+	   true                yyyy-mm-dd          yyyy-mm-dd       no (or yes)
+	   true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
+	*/
+	if (!this.is_found || this.CacheStatus.indexOf(":")<0) {
 		this.CacheStatus=ch.CacheStatus;
 		this.is_found = ch.is_found;
 	}this.wayPoint = ch.wayPoint;



From salzkammergut at mail.berlios.de  Sat Oct 13 16:55:23 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 13 Oct 2007 16:55:23 +0200
Subject: [Cachewolf-svn] r974 - in trunk: resources src/CacheWolf
Message-ID: <200710131455.l9DEtNRp004242@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-13 16:55:18 +0200 (Sat, 13 Oct 2007)
New Revision: 974

Modified:
   trunk/resources/spider.def
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/CacheWolf/myTableControl.java
Log:
SpiderGC: When spidering Addi waypoints, use the prefix given by GC rather than starting at 00. This should avoid having addis twice when using GPX files. (http://www.geoclub.de/ftopic19327-0-asc-0.html)

Modified: trunk/resources/spider.def
===================================================================
--- trunk/resources/spider.def	2007-10-13 12:44:44 UTC (rev 973)
+++ trunk/resources/spider.def	2007-10-13 14:55:18 UTC (rev 974)
@@ -14,6 +14,7 @@
 # Version 2.10 - 20070825 Travelbug support
 # Version 2.11 - 20070907 get travelbug mission by tracking number
 # Version 3.0 - 20071010 adaption to new GC-design
+# Version 3.1 - 20091013 Use the given prefix for addi waypoints
 #============================================================
 # A suffix of Rex indicates a regular expression
 # A suffix of ExStart indicates the start of an Extractor search pattern
@@ -129,6 +130,8 @@
 typeRex            = </a>\ \\((.*)\\)</td>
 rowBlockExStart    = <tr
 rowBlockExEnd      = </tr>
+prefixExStart      = <td\ valign=\"top\"\ align=\"left\">
+prefixExEnd        = </td>
 
 #--------------------------------------
 #Section2e: Attributes

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-13 12:44:44 UTC (rev 973)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-13 14:55:18 UTC (rev 974)
@@ -1018,6 +1018,11 @@
 			rowBlock = exRowBlock.findNext();
 			while(exRowBlock.endOfSearch()==false){
 				CacheHolderDetail cxD = new CacheHolderDetail();
+				Extractor exPrefix=new Extractor(rowBlock,p.getProp("prefixExStart"),p.getProp("prefixExEnd"),0,true);
+				String prefix=exPrefix.findNext();
+				if (prefix.length()==2)
+					cxD.wayPoint=prefix+wayPoint.substring(2);
+				else	
 				cxD.wayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
 				counter++;
 				try{ // If addi exists, try to read it to preserve the notes
@@ -1041,8 +1046,10 @@
 				}else {
 					CacheHolder cx=(CacheHolder) cacheDB.get(idx);
 					if (cx.is_Checked && // Only re-spider existing addi waypoints that are ticked
-				 	   !cx.is_filtered) // and are visible (i.e.  not filtered)
+				 	   !cx.is_filtered) { // and are visible (i.e.  not filtered)
 					   cx.update(cxD);
+					   cx.is_Checked=true;
+					}
 				}
 				rowBlock = exRowBlock.findNext();
 			}

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-10-13 12:44:44 UTC (rev 973)
+++ trunk/src/CacheWolf/myTableControl.java	2007-10-13 14:55:18 UTC (rev 974)
@@ -187,8 +187,8 @@
 							break;
 						} else 
 							profile.hasUnsavedChanges=true;	
-					} else { 
-						if (ch.isAddiWpt() && !ch.mainCache.is_Checked && !alreadySaid2) { // Is the father ticked?
+					} else {
+						if (ch.isAddiWpt() && ch.mainCache!=null && !ch.mainCache.is_Checked && !alreadySaid2) { // Is the father ticked?
 							alreadySaid2=true;
 							(new MessageBox("Information","Hilfswegpunkte k?nnnen nicht direkt gespidert werden\nBitte zus?tzlich den Vater anhaken", MessageBox.OKB)).execute();
 						}



From salzkammergut at mail.berlios.de  Sat Oct 13 20:42:06 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 13 Oct 2007 20:42:06 +0200
Subject: [Cachewolf-svn] r975 - trunk/src/CacheWolf
Message-ID: <200710131842.l9DIg6rO004082@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-13 20:41:59 +0200 (Sat, 13 Oct 2007)
New Revision: 975

Modified:
   trunk/src/CacheWolf/GPXImporter.java
Log:
GPXImporter: Inserted a <br> tag after short_description so that the red dot (cache update) can be set correctly

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-10-13 14:55:18 UTC (rev 974)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-10-13 18:41:59 UTC (rev 975)
@@ -444,7 +444,7 @@
 		}
 
 		if (name.equals("groundspeak:short_description")|| name.equals("summary")) {
-			if (holder.is_HTML)	holder.LongDescription =SafeXML.cleanback(strData);
+			if (holder.is_HTML)	holder.LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
 			else holder.LongDescription =strData;
 			return;
 		}



From salzkammergut at mail.berlios.de  Sat Oct 13 20:54:53 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 13 Oct 2007 20:54:53 +0200
Subject: [Cachewolf-svn] r976 - trunk/src/CacheWolf
Message-ID: <200710131854.l9DIsrTs005004@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-13 20:54:45 +0200 (Sat, 13 Oct 2007)
New Revision: 976

Modified:
   trunk/src/CacheWolf/myTableModel.java
Log:
myTableModel: Updated sequence for additional cache information to reflect the priority (i.e. is_new has higher priority than is_update).

Modified: trunk/src/CacheWolf/myTableModel.java
===================================================================
--- trunk/src/CacheWolf/myTableModel.java	2007-10-13 18:41:59 UTC (rev 975)
+++ trunk/src/CacheWolf/myTableModel.java	2007-10-13 18:54:45 UTC (rev 976)
@@ -247,8 +247,8 @@
 							return (String)ch.terrain;
 						case 4: // Waypoint
 							if(ch.is_incomplete) return new IconAndText(skull, ch.wayPoint, fm);
+							if(ch.is_new       ) return new IconAndText(yellow, ch.wayPoint, fm);
 							if(ch.is_update    ) return new IconAndText(red, ch.wayPoint, fm); // TODO this is for sure quite inefficient, better store it, don't create always new when the table is refreshed or only scrolled
-							if(ch.is_new       ) return new IconAndText(yellow, ch.wayPoint, fm);
 							if(ch.is_log_update) return new IconAndText(blue, ch.wayPoint, fm);
 							return (String)ch.wayPoint;
 						case 5: // Cachename



From salzkammergut at mail.berlios.de  Sun Oct 14 00:38:23 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Oct 2007 00:38:23 +0200
Subject: [Cachewolf-svn] r977 - trunk/src/CacheWolf
Message-ID: <200710132238.l9DMcNU3007747@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-14 00:38:14 +0200 (Sun, 14 Oct 2007)
New Revision: 977

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/SpiderGC.java
Log:
Spider: Fix for red and blue circles and logs when reading GPX file


Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-10-13 18:54:45 UTC (rev 976)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-10-13 22:38:14 UTC (rev 977)
@@ -187,7 +187,7 @@
 
 public void setLatLon(String latLon) {
 	latLon=latLon.trim();
-	if (!latLon.equals(LatLon)) is_update=true;
+	if (!latLon.equals(LatLon.trim())) is_update=true;
 	LatLon = latLon;
 	pos.set(latLon);
 }

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2007-10-13 18:54:45 UTC (rev 976)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2007-10-13 22:38:14 UTC (rev 977)
@@ -38,10 +38,20 @@
 	 }
 
 	 public void setLongDescription(String longDescription) {
-	 	if (!LongDescription.equals(longDescription)) is_update=true;
+	 	if (LongDescription.equals("")) is_new=true;
+	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) is_update=true;
 	 	LongDescription = longDescription;
 	 }
 	 
+	 private String stripControlChars(String desc) {
+		 StringBuffer sb=new StringBuffer(desc.length());
+		 for (int i=0; i<desc.length(); i++) {
+			char c=desc.charAt(i);
+			if (c>' ') sb.append(c);
+		 }
+		 return sb.toString();
+	 }
+	 
 	 public void setHints(String hints) {
 	 	if (!Hints.equals(hints)) is_update=true;
 	 	Hints = hints;
@@ -49,9 +59,19 @@
 	 
 	 public void setCacheLogs(Vector logs) {
 		  // Number of logs has changed, set the log_update flag
-		 if (logs.size()!=CacheLogs.size()) is_log_update=true;
-		 CacheLogs=logs;
-		 // Count the number of not-found logs
+		 //if (logs.size()!=CacheLogs.size()) is_log_update=true;
+		 int size=logs.size();
+		 for (int i=0; i<size; i++) { // Loop over all new logs
+			 addLog((String)logs.elementAt(i));
+		 }
+		 //CacheLogs=logs;
+		 countNotFoundLogs();
+	 }
+
+	 /**
+	  *  Count the number of not-found logs
+	  */
+	 public void countNotFoundLogs() {
 		int countNoFoundLogs = 0;
 		String loganal = "";
 		while(countNoFoundLogs < CacheLogs.size() && countNoFoundLogs < 5){
@@ -162,14 +182,14 @@
 		  //<img src='icon_smile.gif'>&nbsp;2005-10-30 by Schatzpirat</strong><br>
 		  //get Date of latest log in old cachedata
 		  Extractor extOldDate;
-		  String oldLogDate = new String();
+		  String oldLogDate = "";
 		  if(this.CacheLogs.size()>0){
-			extOldDate = new Extractor((String) this.CacheLogs.get(0), ";"," by", 0, true);
-			oldLogDate= new String(extOldDate.findNext());
+			extOldDate = new Extractor((String) this.CacheLogs.get(0), ";"," ", 0, true);
+			oldLogDate= extOldDate.findNext();
 		  }
 
 		  String newLogDate;
-		  Extractor extNewDate = new Extractor(logEntry, ";"," by", 0, true);
+		  Extractor extNewDate = new Extractor(logEntry, ";"," ", 0, true);
 		  newLogDate = extNewDate.findNext();
 		  if (newLogDate.compareTo(oldLogDate)> 0){
 	  		  // oldest log from new cachedata is younger than stored data
@@ -181,12 +201,17 @@
 			  return;
 		  }
 		  if (newLogDate.compareTo(oldLogDate)== 0){
-			  // logdate is equal, so check, if finder is equal
+			  // logdate is equal, so check, if date&finder is equal
 			  String newLogFinder, oldLogFinder;
-			  Extractor extOldFinder = new Extractor((String) this.CacheLogs.get(0), "by ","<", 0, true);
+			  Extractor extOldFinder = new Extractor((String) this.CacheLogs.get(0), ";","<", 0, true);
 			  oldLogFinder = extOldFinder.findNext().toLowerCase();
+			  // Check whether the last old log was inserted without a " by " between date and finder
+			  if (oldLogFinder.indexOf(" by")<0) {
+				  int i=oldLogFinder.indexOf(" ");
+				  if (i>0) oldLogFinder=oldLogFinder.substring(0,i)+" by"+oldLogFinder.substring(i);
+			  }
 			  
-			  Extractor extNewFinder = new Extractor(logEntry, "by ","<", 0, true);
+			  Extractor extNewFinder = new Extractor(logEntry, ";","<", 0, true);
 			  newLogFinder = extNewFinder.findNext().toLowerCase();
 			  
 			  if (newLogFinder.compareTo(oldLogFinder)!= 0){

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-13 18:54:45 UTC (rev 976)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-13 22:38:14 UTC (rev 977)
@@ -455,13 +455,14 @@
 			try{
 				chD.is_new = !isUpdate;
 				chD.is_update = false;
+				chD.is_log_update=false;
 				chD.is_HTML = true;
 				chD.is_available = true;
 				chD.is_archived = false;
 				chD.is_incomplete = false;
 				// Save size of logs to be able to check whether any new logs were added
-				int logsz = chD.CacheLogs.size();
-				chD.CacheLogs.clear();
+				//int logsz = chD.CacheLogs.size();
+				//chD.CacheLogs.clear();
 				chD.addiWpts.clear();
 				chD.Images.clear();
 				chD.ImagesText.clear();
@@ -787,7 +788,7 @@
 				chD.is_found = true;
 				chD.CacheStatus = d;
 			}
-			if (nLogs<=MAXLOGS) reslts.add("<img src='"+ icon +"'>&nbsp;" + d + " " + name +"<br>"+ exLog.findNext());
+			if (nLogs<=MAXLOGS) reslts.add("<img src='"+ icon +"'>&nbsp;" + d + " by " + name +"<br>"+ exLog.findNext());
 
 			singleLog = exSingleLog.findNext();
 			exIcon.setSource(singleLog);
@@ -1020,14 +1021,22 @@
 				CacheHolderDetail cxD = new CacheHolderDetail();
 				Extractor exPrefix=new Extractor(rowBlock,p.getProp("prefixExStart"),p.getProp("prefixExEnd"),0,true);
 				String prefix=exPrefix.findNext();
+				String adWayPoint;
 				if (prefix.length()==2)
-					cxD.wayPoint=prefix+wayPoint.substring(2);
+					adWayPoint=prefix+wayPoint.substring(2);
 				else	
-				cxD.wayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
+				    adWayPoint = MyLocale.formatLong(counter, "00") + wayPoint.substring(2);
 				counter++;
-				try{ // If addi exists, try to read it to preserve the notes
-					cxD.readCache(profile.dataDir);
-				} catch (Exception ex) {};
+				int idx=profile.getCacheIndex(adWayPoint);
+				if (idx>=0) {
+					cxD=new CacheHolderDetail((CacheHolder) cacheDB.get(idx));
+					try{ // If addi exists, try to read it to preserve the notes
+						cxD.readCache(profile.dataDir);
+					} catch (Exception ex) {};
+				} else {
+					cxD=new CacheHolderDetail(); cxD.wayPoint=adWayPoint;
+				}
+				cxD.is_update=false; cxD.is_new=false;
 				nameRex.search(rowBlock);
 				koordRex.search(rowBlock);
 				typeRex.search(rowBlock);
@@ -1039,9 +1048,8 @@
 				cxD.setLongDescription(descRex.stringMatched(1));
 				cxD.is_found = is_found;
 				cxD.saveCacheDetails(profile.dataDir);
-
-				int idx=profile.getCacheIndex(cxD.wayPoint);
 				if (idx<0){
+					cxD.is_new=true; cxD.is_update=false;
 					cacheDB.add(new CacheHolder(cxD));
 				}else {
 					CacheHolder cx=(CacheHolder) cacheDB.get(idx);



From salzkammergut at mail.berlios.de  Sun Oct 14 00:40:09 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Oct 2007 00:40:09 +0200
Subject: [Cachewolf-svn] r978 - trunk/src/CacheWolf
Message-ID: <200710132240.l9DMe9kl011057@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-14 00:40:04 +0200 (Sun, 14 Oct 2007)
New Revision: 978

Modified:
   trunk/src/CacheWolf/GPXImporter.java
Log:
GPXImporter: Renamed Holder to chD in line with other files

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-10-13 22:38:14 UTC (rev 977)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-10-13 22:40:04 UTC (rev 978)
@@ -20,7 +20,7 @@
 	static Preferences pref;
 	Profile profile;
 	Vector cacheDB;
-	CacheHolderDetail holder;
+	CacheHolderDetail chD;
 	String strData, saveDir, logData, logIcon, logDate, logFinder;
 	boolean inWpt, inCache, inLogs, inBug;
 	public XMLElement document;
@@ -160,9 +160,9 @@
 			zaehlerGel = 0;
 		}
 		if (name.equals("wpt")) {
-			holder = new CacheHolderDetail();
-			holder.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
-			holder.LatLon=holder.pos.toString();
+			chD = new CacheHolderDetail();
+			chD.pos.set(Common.parseDouble(atts.getValue("lat")),Common.parseDouble(atts.getValue("lon")));
+			chD.LatLon=chD.pos.toString();
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
@@ -171,20 +171,20 @@
 		}
 		
 		if (name.equals("link")&& inWpt){
-			holder.URL = atts.getValue("href");
+			chD.URL = atts.getValue("href");
 			return;
 		}
 
 		if (name.equals("groundspeak:cache")) {
 			inCache = true;
 			if (atts.getValue("available").equals("True"))
-				holder.is_available = true;
+				chD.is_available = true;
 			else 
-				holder.is_available = false;
+				chD.is_available = false;
 			if (atts.getValue("archived").equals("True"))
-				holder.is_archived = true;
+				chD.is_archived = true;
 			else
-				holder.is_archived = false;
+				chD.is_archived = false;
 			return;
 		}
 
@@ -192,12 +192,12 @@
 			inCache=true;
 			// get status
 			String status = new String(atts.getValue("status"));
-			holder.is_available = false;
-			holder.is_archived = false;
-			if (status.equals("Available")) holder.is_available = true;
-			if (status.equals("Unavailable")) holder.is_available = false;
-			if (status.equals("Draft")) holder.is_available = false;
-			if (status.equals("Archived")) holder.is_archived = true;
+			chD.is_available = false;
+			chD.is_archived = false;
+			if (status.equals("Available")) chD.is_available = true;
+			if (status.equals("Unavailable")) chD.is_available = false;
+			if (status.equals("Draft")) chD.is_available = false;
+			if (status.equals("Archived")) chD.is_archived = true;
 			return;
 		}
 		
@@ -208,14 +208,14 @@
 		
 		if (name.equals("groundspeak:long_description")) {
 			if (atts.getValue("html").toLowerCase().equals("true"))
-				holder.is_HTML= true;
+				chD.is_HTML= true;
 			else 
-				holder.is_HTML = false;
+				chD.is_HTML = false;
 			
 		}
 		if (name.equals("description") || name.equals("terra:description") ) {
 			//set HTML always to true if from oc.de or TC
-			holder.is_HTML= true;
+			chD.is_HTML= true;
 		}
 
 		if (name.equals("groundspeak:logs") || name.equals("log") || name.equals("terra:logs")) {
@@ -256,11 +256,11 @@
 				return;
 			}
 			if (name.equals("groundspeak:log") || name.equals("log") || name.equals("terra:log") ) {
-				holder.CacheLogs.add(logIcon + logDate + " by " + logFinder + "</strong><br>" + logData + "<br>");
+				chD.CacheLogs.add(logIcon + logDate + " by " + logFinder + "<br>" + logData + "<br>");
 				if(logIcon.equals("<img src='icon_smile.gif'>&nbsp;") && 
 						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && logFinder.equalsIgnoreCase(pref.myAlias2)))) {
-							holder.CacheStatus=logDate;
-							holder.is_found=true;
+							chD.CacheStatus=logDate;
+							chD.is_found=true;
 				}
 				return;
 			}
@@ -269,57 +269,42 @@
 		if (name.equals("wpt")){
 			// Add cache Data only, if waypoint not already in database
 			//if (searchWpt(cacheDB, holder.wayPoint)== -1){
-			int index=searchWpt(holder.wayPoint);
+			int index=searchWpt(chD.wayPoint);
 			//Vm.debug("here ?!?!?");
 			//Vm.debug("chould be new!!!!");
 			if (index == -1){
-				//Vm.debug("here A");
-				String loganal = new String();
-				//Check for number sukzessive DNF logs
-				int z = 0;
-				while(z < holder.CacheLogs.size() && z < 5){
-					loganal = (String)holder.CacheLogs.get(z);
-					if(loganal.indexOf("icon_sad")>0) {
-						z++;
-					}else break;
-				}
-				holder.noFindLogs = z;
-				zaehlerGel++;
-				if (zaehlerGel % 5==1) infB.setInfo( (MyLocale.getMsg(4000,"Loaded caches") + ":" + zaehlerGel));
-				holder.is_new = true;
-				cacheDB.add(new CacheHolder(holder));
-				//Vm.debug("here B");
-				//if(doSpider == true && fromOC == false){
+				chD.countNotFoundLogs();
+				chD.is_new = true;
+				cacheDB.add(new CacheHolder(chD));
 				// don't spider additional waypoints, so check
 				// if waypoint starts with "GC"
 				if(doSpider == true) {
-					//Vm.debug("Should be spidering images...");
-					if(spiderOK == true && holder.is_archived == false){
-							if(holder.LatLon.length() > 1){
+					if(spiderOK == true && chD.is_archived == false){
+							if(chD.LatLon.length() > 1){
 							if(getMaps){
-								ParseLatLon pll = new ParseLatLon(holder.LatLon,".");
+								ParseLatLon pll = new ParseLatLon(chD.LatLon,".");
 								pll.parse();
 								//MapLoader mpl = new MapLoader(pref.myproxy, pref.myproxyport);
 								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map.gif", "3");
 								//mpl.loadTo(profile.dataDir + "/" + holder.wayPoint + "_map_2.gif", "10");
 							}
 						}
-					if(holder.wayPoint.startsWith("GC")|| fromTC) {
+					if(chD.wayPoint.startsWith("GC")|| fromTC) {
 						//spiderImages();
 						spiderImagesUsingSpider();
 						//Rename image sources
 						String text;
 						String orig;
 						String imgName;
-						orig = holder.LongDescription;
+						orig = chD.LongDescription;
 						Extractor ex = new Extractor(orig, "<img src=\"", ">", 0, false);
 						text = ex.findNext();
 						int num = 0;
 						while(ex.endOfSearch() == false && spiderOK == true){
 							//Vm.debug("Replacing: " + text);
-							if (num >= holder.ImagesText.getCount())break;
-							imgName = (String)holder.ImagesText.get(num);
-							holder.LongDescription = replace(holder.LongDescription, text, "[[Image: " + imgName + "]]");
+							if (num >= chD.ImagesText.getCount())break;
+							imgName = (String)chD.ImagesText.get(num);
+							chD.LongDescription = replace(chD.LongDescription, text, "[[Image: " + imgName + "]]");
 							num++;
 							text = ex.findNext();
 						}
@@ -327,7 +312,7 @@
 						
 					}
 				}
-				holder.saveCacheDetails(saveDir);
+				chD.saveCacheDetails(saveDir);
 				//crw.saveIndex(cacheDB,saveDir);
 			}
 			//Update cache data
@@ -339,7 +324,7 @@
 					oldCh.readCache(saveDir);
 					//Vm.debug("Done loading");
 				} catch (Exception e) {Vm.debug("Could not open file: " + e.toString());};
-				oldCh.update(holder);
+				oldCh.update(chD);
 				oldCh.saveCacheDetails(saveDir);
 				cacheDB.set(index, new CacheHolder(oldCh));
 				//crw.saveIndex(cacheDB,saveDir);
@@ -349,8 +334,8 @@
 			return;
 		}
 		if (name.equals("sym")&& strData.endsWith("Found")) {
-			holder.is_found = true;
-			holder.CacheStatus = MyLocale.getMsg(318,"Found");
+			chD.is_found = true;
+			chD.CacheStatus = MyLocale.getMsg(318,"Found");
 			return;
 		}
 		if (name.equals("groundspeak:travelbugs")) {
@@ -360,9 +345,9 @@
 
 		if (name.equals("groundspeak:name")&& inBug) {
 			Travelbug tb=new Travelbug(strData);
-			holder.Travelbugs.add(tb);
+			chD.Travelbugs.add(tb);
 			//holder.Bugs += "<b>Name:</b> " + strData + "<br><hr>";
-			holder.has_bug = true;
+			chD.has_bug = true;
 			return;
 		}
 		
@@ -371,7 +356,7 @@
 			//Date = strData.substring(5,7); // month
 			//Date += "/" + strData.substring(8,10); // day
 			//Date += "/" + strData.substring(0,4); // year
-			holder.DateHidden = strData.substring(0,10); //Date;
+			chD.DateHidden = strData.substring(0,10); //Date;
 			return;
 		}
 		// cache information
@@ -380,7 +365,7 @@
 		}
 		
 		if (name.equals("name") && inWpt && !inCache) {
-			holder.wayPoint = strData;
+			chD.wayPoint = strData;
 			//msgA.setText("import " + strData);
 			return;
 		}
@@ -389,80 +374,80 @@
 		// fill name with contents of <desc>, in case of gc.com the name is
 		// later replaced by the contents of <groundspeak:name> which is shorter
 		if (name.equals("desc")&& inWpt ) {
-			holder.CacheName = strData;
+			chD.CacheName = strData;
 			//Vm.debug("CacheName: " + strData);
 			//msgA.setText("import " + strData);
 			return;
 		}
 		if (name.equals("url")&& inWpt){
-			holder.URL = strData;
+			chD.URL = strData;
 			return;
 		}
 		
 		// Text for additional waypoints, no HTML
 		if (name.equals("cmt")&& inWpt){
-			holder.LongDescription = strData;
-			holder.is_HTML = false;
+			chD.LongDescription = strData;
+			chD.is_HTML = false;
 			return;
 		}
 		
 		// aditional wapypoint
 		if (name.equals("type")&& inWpt && !inCache && strData.startsWith("Waypoint")){
-			holder.type= CacheType.typeText2Number(strData);
-			holder.CacheSize = "None";
+			chD.type= CacheType.typeText2Number(strData);
+			chD.CacheSize = "None";
 		}
 
 		
 		if ((name.equals("groundspeak:name")|| name.equals("terra:name")) && inCache) {
-			holder.CacheName = strData;
+			chD.CacheName = strData;
 			return;
 		}
 		if (name.equals("groundspeak:owner") || name.equals("owner")||name.equals("terra:owner")) {
-			holder.CacheOwner = strData;
-			if(pref.myAlias.equals(strData)) holder.is_owned = true;
+			chD.CacheOwner = strData;
+			if(pref.myAlias.equals(strData)) chD.is_owned = true;
 			return;
 		}
 		if (name.equals("groundspeak:difficulty") || name.equals("difficulty") || name.equals("terra:mental_challenge")) {
-			holder.hard = strData.replace('.',',');
+			chD.hard = strData.replace('.',',');
 			return;
 		}
 		if (name.equals("groundspeak:terrain")|| name.equals("terrain")|| name.equals("terra:physical_challenge")) {
-			holder.terrain = strData.replace('.',',');
+			chD.terrain = strData.replace('.',',');
 			return;
 		}
 		if ((name.equals("groundspeak:type") || name.equals("type")|| name.equals("terra:style"))&& inCache){
-			holder.type= CacheType.typeText2Number(strData);
+			chD.type= CacheType.typeText2Number(strData);
 			return;
 		}
 		if (name.equals("groundspeak:container")|| name.equals("container")){
-			holder.CacheSize = strData;
+			chD.CacheSize = strData;
 			return;
 		}
 		
 		if (name.equals("terra:size")){
-			holder.CacheSize = TCSizetoText(strData);
+			chD.CacheSize = TCSizetoText(strData);
 		}
 
 		if (name.equals("groundspeak:short_description")|| name.equals("summary")) {
-			if (holder.is_HTML)	holder.LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
-			else holder.LongDescription =strData;
+			if (chD.is_HTML)	chD.LongDescription =SafeXML.cleanback(strData)+"<br>"; // <br> needed because we also use a <br> in SpiderGC. Without it the comparison in ch.update fails
+			else chD.LongDescription =strData+"\n";
 			return;
 		}
 
 		if (name.equals("groundspeak:long_description")|| name.equals("description")|| name.equals("terra:description")) {
-			if (holder.is_HTML)	holder.LongDescription +=SafeXML.cleanback(strData);
-			else holder.LongDescription +=strData;
+			if (chD.is_HTML)	chD.LongDescription +=SafeXML.cleanback(strData);
+			else chD.LongDescription +=strData;
 			return;
 		}
 		if (name.equals("groundspeak:encoded_hints") || name.equals("hints")) {
-			holder.Hints = Common.rot13(strData);
+			chD.Hints = Common.rot13(strData);
 			return;
 		}
 		
 		if (name.equals("terra:hint")) {
 			// remove "&lt;br&gt;<br>" from the end
 			int indexTrash = strData.indexOf("&lt;br&gt;<br>");
-			if (indexTrash > 0)	holder.Hints = Common.rot13(strData.substring(0,indexTrash));
+			if (indexTrash > 0)	chD.Hints = Common.rot13(strData.substring(0,indexTrash));
 			return;
 		}
 
@@ -540,13 +525,13 @@
 		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
 		
 		if (fromTC) {
-				imgSpider.getImages(holder.LongDescription, holder);
+				imgSpider.getImages(chD.LongDescription, chD);
 		}
 		else {
-			addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + holder.wayPoint ;
+			addr = "http://www.geocaching.com/seek/cache_details.aspx?wp=" + chD.wayPoint ;
 			//Vm.debug(addr + "|");
 			cacheText = SpiderGC.fetch(addr);
-			imgSpider.getImages(cacheText, holder);
+			imgSpider.getImages(cacheText, chD);
 		}
 	}
 	



From bilbowolf at mail.berlios.de  Sun Oct 14 16:22:20 2007
From: bilbowolf at mail.berlios.de (bilbowolf at mail.berlios.de)
Date: Sun, 14 Oct 2007 16:22:20 +0200
Subject: [Cachewolf-svn] r979 - trunk/src/CacheWolf
Message-ID: <200710141422.l9EEMKB7021559@sheep.berlios.de>

Author: bilbowolf
Date: 2007-10-14 16:22:19 +0200 (Sun, 14 Oct 2007)
New Revision: 979

Modified:
   trunk/src/CacheWolf/Version.java
Log:


Modified: trunk/src/CacheWolf/Version.java
===================================================================
--- trunk/src/CacheWolf/Version.java	2007-10-13 22:40:04 UTC (rev 978)
+++ trunk/src/CacheWolf/Version.java	2007-10-14 14:22:19 UTC (rev 979)
@@ -10,7 +10,7 @@
 	static final String VER_MAJOR = "BE";
 	static final String VER_MINOR = "";
 	static final String VER_BUILD = " ";
-	static final String VER_SVN ="$LastChangedRevision$"; //the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
+	static final String VER_SVN ="$LastChangedRevision$"; // the number is automatically replaced by subversion to the latest versionnumer of this file (svn:keywords LastChangedRevision)
 	
 	/**
 	 * @return



From salzkammergut at mail.berlios.de  Sun Oct 14 23:38:20 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 14 Oct 2007 23:38:20 +0200
Subject: [Cachewolf-svn] r980 - in trunk/src: CacheWolf exp
Message-ID: <200710142138.l9ELcKLK029464@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-14 23:38:07 +0200 (Sun, 14 Oct 2007)
New Revision: 980

Added:
   trunk/src/CacheWolf/Log.java
   trunk/src/CacheWolf/LogList.java
Modified:
   trunk/src/CacheWolf/CacheHolderDetail.java
   trunk/src/CacheWolf/GPXImporter.java
   trunk/src/CacheWolf/HintLogPanel.java
   trunk/src/CacheWolf/OCXMLImporter.java
   trunk/src/CacheWolf/ShowCacheInBrowser.java
   trunk/src/CacheWolf/SpiderGC.java
   trunk/src/exp/HTMLExporter.java
Log:
Logs: Start of change to a proper data structure. Within cache.xml logs are still stored as a string but internally they are stored in a Log datastructure with 4 elements: icon, date, logger and message.
When updating caches the new logs are now merged with the old logs.

Modified: trunk/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- trunk/src/CacheWolf/CacheHolderDetail.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/CacheHolderDetail.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -15,7 +15,7 @@
 	  public String LongDescription = EMPTY;
 	  public String LastUpdate = EMPTY;
 	  public String Hints = EMPTY;
-	  public Vector CacheLogs = new Vector(0);
+	  public LogList CacheLogs=new LogList();
 	  public String CacheNotes = EMPTY;
 	  public Vector Images = new Vector();
 	  public Vector ImagesText = new Vector();
@@ -57,31 +57,15 @@
 	 	Hints = hints;
 	 }
 	 
-	 public void setCacheLogs(Vector logs) {
-		  // Number of logs has changed, set the log_update flag
-		 //if (logs.size()!=CacheLogs.size()) is_log_update=true;
-		 int size=logs.size();
-		 for (int i=0; i<size; i++) { // Loop over all new logs
-			 addLog((String)logs.elementAt(i));
+	 public void setCacheLogs(LogList newLogs) {
+		 int size=newLogs.size();
+		 for (int i=size-1; i>=0; i--) { // Loop over all new logs, must start with oldest log
+			 if (CacheLogs.merge(newLogs.getLog(i))>=0) this.is_log_update=true;
 		 }
 		 //CacheLogs=logs;
-		 countNotFoundLogs();
+		 noFindLogs=CacheLogs.countNotFoundLogs();
 	 }
 
-	 /**
-	  *  Count the number of not-found logs
-	  */
-	 public void countNotFoundLogs() {
-		int countNoFoundLogs = 0;
-		String loganal = "";
-		while(countNoFoundLogs < CacheLogs.size() && countNoFoundLogs < 5){
-			loganal = (String)CacheLogs.get(countNoFoundLogs);
-			if(loganal.indexOf("icon_sad")>0) {
-				countNoFoundLogs++;
-			}else break;
-		}
-		noFindLogs = countNoFoundLogs;
-	 }
 	 
 	  /**
 	 * Method to update an existing cache with new data. This is
@@ -114,35 +98,6 @@
 		  setHints(newCh.Hints);
 		  setCacheLogs(newCh.CacheLogs);
 		  
-/*		  Extractor extOldDate;
-		  String oldLogDate = EMPTY;
-		  if(this.CacheLogs.size()>0){
-			extOldDate = new Extractor((String) this.CacheLogs.get(0), ";"," by", 0, true);
-			oldLogDate= new String(extOldDate.findNext());
-		  }
-		  // now loop through new cachedata and compare logentries, 
-		  // starting with oldest log
-		  
-		  //Vm.debug("made it to here!");
-		  int currLog = newCh.CacheLogs.size()-1;
-		  String newLogDate = EMPTY;
-		  while (currLog >= 0 ){
-			  Extractor extNewDate = new Extractor((String) newCh.CacheLogs.get(currLog), ";"," by", 0, true);
-			  newLogDate = extNewDate.findNext();
-			  if (newLogDate.compareTo(oldLogDate)> 0){
-		  		  // oldest log from new cachedata is younger than stored data
-		  		  // put the new logs in front of old logs
-				  //Vm.debug(newCh.wayPoint + " New: " + newLogDate + " Old: " + oldLogDate + " cmp: " + newLogDate.compareTo(oldLogDate));
-				  while (currLog >= 0) this.CacheLogs.add(0, newCh.CacheLogs.get(currLog--));
-				  this.is_log_update = true;
-			  }
-			  else currLog--;
-		  }//while
-		  
-		  //Logs
-		  //<img src='icon_smile.gif'>&nbsp;2005-10-30 by Schatzpirat</strong><br>
-		  //get Date of latest log in old cachedata
-*/
 		  if (newCh.Solver.length()>0) this.Solver=newCh.Solver;
 	 	return this;
 	  }
@@ -173,55 +128,7 @@
 				saveCacheDetails(profile.dataDir);
 			}
 	  }
-	  /**
-	   * Adds a new log to the cachedata 
-	   * @param logEntry
-	   */
-	  public void addLog(String logEntry){
-		  //Logs
-		  //<img src='icon_smile.gif'>&nbsp;2005-10-30 by Schatzpirat</strong><br>
-		  //get Date of latest log in old cachedata
-		  Extractor extOldDate;
-		  String oldLogDate = "";
-		  if(this.CacheLogs.size()>0){
-			extOldDate = new Extractor((String) this.CacheLogs.get(0), ";"," ", 0, true);
-			oldLogDate= extOldDate.findNext();
-		  }
 
-		  String newLogDate;
-		  Extractor extNewDate = new Extractor(logEntry, ";"," ", 0, true);
-		  newLogDate = extNewDate.findNext();
-		  if (newLogDate.compareTo(oldLogDate)> 0){
-	  		  // oldest log from new cachedata is younger than stored data
-	  		  // put the new logs in front of old logs
-			  //Vm.debug(newCh.wayPoint + " New: " + newLogDate + " Old: " + oldLogDate + " cmp: " + newLogDate.compareTo(oldLogDate));
-			  this.CacheLogs.add(0, logEntry);
-			  this.is_log_update = true;
-			  if (logEntry.indexOf("icon_sad")> 0) this.noFindLogs++;
-			  return;
-		  }
-		  if (newLogDate.compareTo(oldLogDate)== 0){
-			  // logdate is equal, so check, if date&finder is equal
-			  String newLogFinder, oldLogFinder;
-			  Extractor extOldFinder = new Extractor((String) this.CacheLogs.get(0), ";","<", 0, true);
-			  oldLogFinder = extOldFinder.findNext().toLowerCase();
-			  // Check whether the last old log was inserted without a " by " between date and finder
-			  if (oldLogFinder.indexOf(" by")<0) {
-				  int i=oldLogFinder.indexOf(" ");
-				  if (i>0) oldLogFinder=oldLogFinder.substring(0,i)+" by"+oldLogFinder.substring(i);
-			  }
-			  
-			  Extractor extNewFinder = new Extractor(logEntry, ";","<", 0, true);
-			  newLogFinder = extNewFinder.findNext().toLowerCase();
-			  
-			  if (newLogFinder.compareTo(oldLogFinder)!= 0){
-				  this.CacheLogs.add(0, logEntry);
-				  this.is_log_update = true;
-				  if (logEntry.indexOf("icon_sad")> 0) this.noFindLogs++;
-			  }
-		  }
-	  }
-
 	  
 		/**
 		*	Method to parse a specific cache.xml file.
@@ -248,7 +155,7 @@
 			
 			dummy = ex.findNext();
 			while(ex.endOfSearch()==false){
-				CacheLogs.add(dummy);
+				CacheLogs.add(new Log(dummy));
 				dummy = ex.findNext();
 			}
 			ex = new Extractor(text, "<NOTES><![CDATA[", "]]></NOTES>", 0, true);
@@ -357,10 +264,7 @@
 				  detfile.print("<HINTS><![CDATA["+Hints+"]]></HINTS>\r\n");
 				  detfile.print("<LOGS>\r\n");
 				  for(int i = 0; i < CacheLogs.size(); i++){
-					  dummy = (String)CacheLogs.get(i);
-					  detfile.print("<LOG><![CDATA[\r\n");
-					  detfile.print(dummy);
-					  detfile.print("\r\n]]></LOG>\r\n");
+					  detfile.print(CacheLogs.getLog(i).toXML());
 				  }
 				  detfile.print("</LOGS>\r\n");
 			

Modified: trunk/src/CacheWolf/GPXImporter.java
===================================================================
--- trunk/src/CacheWolf/GPXImporter.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/GPXImporter.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -256,8 +256,8 @@
 				return;
 			}
 			if (name.equals("groundspeak:log") || name.equals("log") || name.equals("terra:log") ) {
-				chD.CacheLogs.add(logIcon + logDate + " by " + logFinder + "<br>" + logData + "<br>");
-				if(logIcon.equals("<img src='icon_smile.gif'>&nbsp;") && 
+				chD.CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
+				if(logIcon.equals("icon_smile.gif") && 
 						  (logFinder.equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()>0 && logFinder.equalsIgnoreCase(pref.myAlias2)))) {
 							chD.CacheStatus=logDate;
 							chD.is_found=true;
@@ -273,7 +273,7 @@
 			//Vm.debug("here ?!?!?");
 			//Vm.debug("chould be new!!!!");
 			if (index == -1){
-				chD.countNotFoundLogs();
+				chD.noFindLogs=chD.CacheLogs.countNotFoundLogs();
 				chD.is_new = true;
 				cacheDB.add(new CacheHolder(chD));
 				// don't spider additional waypoints, so check
@@ -460,24 +460,24 @@
 	
 
 	public static String typeText2Image(String typeText){
-		if (typeText.equals("Found it")||typeText.equals("Found")||typeText.equals("find")) return "<img src='icon_smile.gif'>&nbsp;";
-		if (typeText.equals("Didn't find it")||typeText.equals("Not Found")||typeText.equals("no_find")) return "<img src='icon_sad.gif'>&nbsp;";
+		if (typeText.equals("Found it")||typeText.equals("Found")||typeText.equals("find")) return "icon_smile.gif";
+		if (typeText.equals("Didn't find it")||typeText.equals("Not Found")||typeText.equals("no_find")) return "icon_sad.gif";
 		if (typeText.equals("Write note")||typeText.equals("Note")||typeText.equals("note")
-			||typeText.equals("Not Attempted")||typeText.equals("Other")) return "<img src='icon_note.gif'>&nbsp;";
-		if (typeText.equals("Enable Listing")) return "<img src='icon_enabled.gif'>&nbsp;";
-		if (typeText.equals("Temporarily Disable Listing")) return "<img src='icon_disabled.gif'>&nbsp;";
-		if (typeText.equals("Webcam Photo Taken")) return "<img src='11.png'>&nbsp;";
-		if (typeText.equals("Attended")) return "<img src='icon_attended.gif'>&nbsp;";
-		if (typeText.equals("Publish Listing")) return "<img src='green.png'>&nbsp;";
-		if (typeText.equals("Will Attend")) return "<img src='icon_rsvp.gif'>&nbsp;";
-		if (typeText.equals("Post Reviewer Note")) return "<img src='big_smile.gif'>&nbsp;";
-		if (typeText.equals("Unarchive")) return "<img src='traffic_cone.gif'>&nbsp;";
-		if (typeText.equals("Archive (show)")) return "<img src='traffic_cone.gif'>&nbsp;";
-		if (typeText.equals("Owner Maintenance")) return "<img src='icon_maint.gif'>&nbsp;";
-		if (typeText.equals("Needs Maintenance")) return "<img src='icon_needsmaint.gif'>&nbsp;";
-		if (typeText.equals("Update Coordinates")) return "<img src='coord_update.gif'>&nbsp;";
+			||typeText.equals("Not Attempted")||typeText.equals("Other")) return "icon_note.gif";
+		if (typeText.equals("Enable Listing")) return "icon_enabled.gif";
+		if (typeText.equals("Temporarily Disable Listing")) return "icon_disabled.gif";
+		if (typeText.equals("Webcam Photo Taken")) return "11.png";
+		if (typeText.equals("Attended")) return "icon_attended.gif";
+		if (typeText.equals("Publish Listing")) return "green.png";
+		if (typeText.equals("Will Attend")) return "icon_rsvp.gif";
+		if (typeText.equals("Post Reviewer Note")) return "big_smile.gif";
+		if (typeText.equals("Unarchive")) return "traffic_cone.gif";
+		if (typeText.equals("Archive (show)")) return "traffic_cone.gif";
+		if (typeText.equals("Owner Maintenance")) return "icon_maint.gif";
+		if (typeText.equals("Needs Maintenance")) return "icon_needsmaint.gif";
+		if (typeText.equals("Update Coordinates")) return "coord_update.gif";
 		//Vm.debug("Unknown Log Type:" + typeText);
-		return typeText +"&nbsp;";
+		return typeText;
 	}
 	
 	public static String TCSizetoText(String size){

Modified: trunk/src/CacheWolf/HintLogPanel.java
===================================================================
--- trunk/src/CacheWolf/HintLogPanel.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/HintLogPanel.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -81,7 +81,7 @@
 		int nLogs=cache.CacheLogs.size();
 		int logsPerPage=Global.getPref().logsPerPage;
 		for(int i = crntLogPosition; i<nLogs; i++){
-			dummy.append((String)cache.CacheLogs.get(i));
+			dummy.append(cache.CacheLogs.getLog(i).toHtml());
 			dummy.append("</br>");
 			if(++counter >= logsPerPage) break;
 		}

Added: trunk/src/CacheWolf/Log.java
===================================================================
--- trunk/src/CacheWolf/Log.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/Log.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -0,0 +1,93 @@
+package CacheWolf;
+
+public class Log {
+	private static String MAXLOGICON="MAXLOG";
+	/** The icon which describes the log e.g. icon_sad */
+	private String icon;
+	/** The date in format yyyy-mm-dd */
+	private String date;
+	/** The person who logged the cache */
+	private String logger;
+	/** The logged message */
+	private String message;
+	
+	/** Create a log from a single line in format<br>
+	 * <pre><img src='ICON'>&nbsp;DATE LOGGER<br>MESSAGE
+	 * or <img src='ICON'>&nbsp;DATE by LOGGER<br>MESSAGE</pre>
+	 * @param logLine
+	 */
+	Log(String logLine) {
+//		<img src='icon_smile.gif'>&nbsp;2007-01-14 xyz<br>a wonderful log
+		int ic1=logLine.indexOf("<img src='");
+		int ic2=logLine.indexOf("'",ic1+10);
+		icon=logLine.substring(ic1+10,ic2);
+		int d1=logLine.indexOf(";");
+		date=logLine.substring(d1+1,d1+11);
+		int l1=d1+12;
+		if (logLine.substring(l1,l1+3).equals("by ")) l1+=3;
+		int l2=logLine.indexOf("<br>",l1);
+		logger=logLine.substring(l1,l2);
+		message=logLine.substring(l2+4);
+	}
+	
+	Log(String icon, String date, String logger, String message) {
+		this.icon=icon;
+		this.date=date;
+		this.logger=logger;
+		this.message=message;
+	}
+	
+	public static Log maxLog() {
+		return new Log(MAXLOGICON,"1900-00-00","","");
+	}
+	
+	public String getIcon() {
+		return icon;
+	}
+	public void setIcon(String icon) {
+		this.icon = icon;
+	}
+	public String getDate() {
+		return date;
+	}
+	public void setDate(String date) {
+		this.date = date;
+	}
+	public String getLogger() {
+		return logger;
+	}
+	public void setLogger(String logger) {
+		this.logger = logger;
+	}
+	public String getMessage() {
+		return message;
+	}
+	public void setMessage(String message) {
+		this.message = message;
+	}
+
+	/** Return XML representation of log for storing in cache.xml */
+	public String toXML(){
+		StringBuffer s=new StringBuffer(400);
+		s.append("<LOG><![CDATA[");
+		s.append(toHtml());
+		s.append("]]></LOG>\r\n");
+		return s.toString();
+	}
+	
+	/** Return HTML representation of log for display on screen */
+	public String toHtml(){
+//		<img src='icon_smile.gif'>&nbsp;2007-01-14 xyz<br>a wonderful log
+		if (icon.equals(MAXLOGICON)) return "Too many logs";
+		StringBuffer s=new StringBuffer(300);
+		s.append("<img src='");
+		s.append(icon);
+		s.append("'>&nbsp;");
+		s.append(date);
+		s.append(" by ");
+		s.append(logger);
+		s.append("<br>");
+		s.append(message.trim());
+		return s.toString();
+	}
+}

Added: trunk/src/CacheWolf/LogList.java
===================================================================
--- trunk/src/CacheWolf/LogList.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/LogList.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -0,0 +1,103 @@
+package CacheWolf;
+
+import ewe.util.Vector;
+
+public class LogList {
+	/** The Vector containing the Log objects 
+	 * The list is always sorted in descending order */
+	private Vector logList=new Vector(10);
+
+	/** Construct an empty Log list */
+	public LogList() {
+	}
+	
+	/** Get the Log at a certain position in the list */
+	public Log getLog(int i) {
+		return (Log) logList.elementAt(i);
+	}
+	
+	/** Return the size of the list */
+	public int size() {
+		return logList.size();
+	}
+	
+	/** Clear the Log list */
+	public void clear() {
+		logList.clear();
+	}
+
+	/** Add a Log to the list */
+	public void add(Log log) {
+		logList.add(log);
+	}
+	
+	/** Remove a Log from the list */
+	public void remove(int i) {
+		logList.removeElementAt(i);
+	}
+
+	/** Replace a Log in the list */
+	public void replace(int i, Log log) {
+		logList.set(i, log);
+	}
+	
+	/** Merge a log into the list at the appropriate position
+	 * @param newLog
+	 * @return the position where the log was placed or -1 if it is already in the list
+	 */ 
+	 
+	public int merge(Log newLog) {
+		String newDate=newLog.getDate();
+		int size=size();
+		int i;
+		for (i=0; i<size; i++) {
+			 int comp=newDate.compareTo(((Log) logList.elementAt(i)).getDate());
+			 if (comp>0) {
+				 logList.insertElementAt(newLog, i);
+				 return i;
+			 }
+			 if (comp==0) break;
+		}
+		// Now i points to the first log with same date as the new log or i==size()
+		if (i==size) {
+			add(newLog);
+			return size;
+		}
+		// Check whether we have any logs with same date by same user
+		String newLogger=newLog.getLogger();
+		String newIcon=newLog.getIcon();
+		while (i<size &&  newDate.equals(((Log) logList.elementAt(i)).getDate())) {
+			Log log=(Log) logList.elementAt(i);
+			if (log.getLogger().equals(newLogger) &&
+				log.getIcon().equals(newIcon)) {
+				// Has the log message changed vs. the one we have in cache.xml?
+				if (!log.getMessage().equals(newLog.getMessage())) {
+					replace(i,newLog);
+					return i;
+				} else
+					return -1; // Log already in list
+			}
+			i++;
+		}
+		if (i==size)
+			add(newLog);
+		else
+			logList.insertElementAt(newLog, i);
+		return i;
+	}
+
+	 /**
+	  *  Count the number of not-found logs
+	  */
+	 public int countNotFoundLogs() {
+		int countNoFoundLogs = 0;
+		while(countNoFoundLogs < size() && countNoFoundLogs < 5){
+			if(getLog(countNoFoundLogs).getIcon().equals("icon_sad")) {
+				countNoFoundLogs++;
+			}else break;
+		}
+		return countNoFoundLogs;
+	 }
+	
+
+}

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -587,8 +587,8 @@
 
 	private void endCacheLog(String name){
 		if (name.equals("cachelog")){ // </cachelog>
-			chD.addLog(logIcon + logDate + " by " + logFinder + "</strong><br>" + logData + "<br>");
-			chD.saveCacheDetails(profile.dataDir);
+			chD.CacheLogs.merge(new Log(logIcon,logDate,logFinder,logData));
+			//chD.saveCacheDetails(profile.dataDir);
 			return;
 		}
 

Modified: trunk/src/CacheWolf/ShowCacheInBrowser.java
===================================================================
--- trunk/src/CacheWolf/ShowCacheInBrowser.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/ShowCacheInBrowser.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -162,7 +162,7 @@
 					Vector logVect=new Vector(chD.CacheLogs.size());
 					for (int i=0; i<chD.CacheLogs.size(); i++) {
 						Hashtable logs=new Hashtable();
-						String log=STRreplace.replace((String)chD.CacheLogs.get(i),"http://www.geocaching.com/images/icons/","");
+						String log=STRreplace.replace(chD.CacheLogs.getLog(i).toHtml(),"http://www.geocaching.com/images/icons/","");
 						int posGt=log.indexOf('>'); // Find the icon which defines the type of log
 						if (posGt<0) {
 							logs.put("LOG",log);

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -738,27 +738,13 @@
 	 * @param chD Cache Details
 	 * @return A HTML string containing the logs
 	 */
-	private Vector getLogs(String doc, CacheHolderDetail chD) throws Exception{
+	private LogList getLogs(String doc, CacheHolderDetail chD) throws Exception{
 		String icon = "";
 		String name = "";
-		Vector reslts = new Vector();
+		LogList reslts = new LogList();
 		Regex blockRex = new Regex(p.getProp("blockRex"));
 		blockRex.search(doc);
 		doc = blockRex.stringMatched(1);
-		//Vm.debug("Log Block: " + doc);
-		/*
-		Vm.debug("Setting log regex");
-		inRex = new Regex("<STRONG><IMG SRC='http://www.geocaching.com/images/icons/((?s).*?)'((?s).*?)&nbsp;((?s).*?)<A NAME=\"((?s).*?)'text-decoration: underline;'>((?s).*?)<A HREF=\"((?s).*?)'text-decoration: underline;'>((?s).*?)</A></strong>((?s).*?)\\[<A href=");
-		inRex.optimize();
-		inRex.search(doc);
-		Vm.debug("Log regex run...");
-		while(inRex.didMatch()){
-			Vm.debug("Logs:" + inRex.stringMatched(1) + " / " + inRex.stringMatched(3)+ " / " + inRex.stringMatched(7)+ " / " + inRex.stringMatched(8));
-			//<img src='icon_smile.gif'>&nbsp;
-			reslts.add("<img src='"+ inRex.stringMatched(1) +"'>&nbsp;" + inRex.stringMatched(3)+ inRex.stringMatched(7)+ inRex.stringMatched(8));
-			inRex.searchFrom(doc, inRex.matchedTo());
-		}
-		*/
 		String singleLog = "";
 		Extractor exSingleLog = new Extractor(doc,p.getProp("singleLogExStart"), p.getProp("singleLogExEnd"), 0, false); // maybe here is some change neccessary because findnext now gives the whole endstring back???
 		singleLog = exSingleLog.findNext();
@@ -788,7 +774,7 @@
 				chD.is_found = true;
 				chD.CacheStatus = d;
 			}
-			if (nLogs<=MAXLOGS) reslts.add("<img src='"+ icon +"'>&nbsp;" + d + " by " + name +"<br>"+ exLog.findNext());
+			if (nLogs<=MAXLOGS) reslts.add(new Log(icon,d,name,exLog.findNext()));
 
 			singleLog = exSingleLog.findNext();
 			exIcon.setSource(singleLog);
@@ -802,7 +788,7 @@
 			if (nLogs>=MAXLOGS && chD.is_found) break;
 		}
 		if (nLogs>MAXLOGS) {
-			reslts.add("<br>More than "+MAXLOGS+" logs.<br>");
+			reslts.add(Log.maxLog());
 		}
 		return reslts;
 	}

Modified: trunk/src/exp/HTMLExporter.java
===================================================================
--- trunk/src/exp/HTMLExporter.java	2007-10-14 14:22:19 UTC (rev 979)
+++ trunk/src/exp/HTMLExporter.java	2007-10-14 21:38:07 UTC (rev 980)
@@ -127,7 +127,7 @@
 						page_tpl.setParam("DECRYPTEDHINTS", Common.rot13(holder.Hints));
 						dummy = new String();
 						for(int j = 0; j<holder.CacheLogs.size(); j++){
-							dummy = dummy + (String)holder.CacheLogs.get(j)+"<br>";
+							dummy = dummy + holder.CacheLogs.getLog(j).toHtml()+"<br>";
 						}
 						page_tpl.setParam("LOGS", dummy);
 						page_tpl.setParam("NOTES", STRreplace.replace(holder.CacheNotes, "\n","<br>"));



From mik77 at mail.berlios.de  Wed Oct 17 20:04:13 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 17 Oct 2007 20:04:13 +0200
Subject: [Cachewolf-svn] r981 - trunk/src/CacheWolf
Message-ID: <200710171804.l9HI4DCY030422@sheep.berlios.de>

Author: mik77
Date: 2007-10-17 20:04:08 +0200 (Wed, 17 Oct 2007)
New Revision: 981

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
 - ignore forceLogin for SpiderSingle

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-14 21:38:07 UTC (rev 980)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-17 18:04:08 UTC (rev 981)
@@ -198,7 +198,7 @@
 		if (ch.isAddiWpt()) return false;  // No point re-spidering an addi waypoint, comes with parent
 
 		// check if we need to login
-		if (!loggedIn || Global.getPref().forceLogin){
+		if (!loggedIn){
 			if (this.login()!=Form.IDOK) return false;
 			// loggedIn is already set by this.login()
 		}



From salzkammergut at mail.berlios.de  Fri Oct 19 22:46:51 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 19 Oct 2007 22:46:51 +0200
Subject: [Cachewolf-svn] r982 - trunk/src/CacheWolf
Message-ID: <200710192046.l9JKkpHo025771@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-19 22:46:46 +0200 (Fri, 19 Oct 2007)
New Revision: 982

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Update to load images with redirect e.g. GCTARB (http://www.geoclub.de/ftopic19631.html)

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-17 18:04:08 UTC (rev 981)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-19 20:46:46 UTC (rev 982)
@@ -966,7 +966,15 @@
 		connImg.setRequestorProperty("Connection", "close");
 		try{
 			pref.log("Trying to fetch image from: " + imgUrl);
-			sockImg = connImg.connect();
+			String redirect=null;
+			do {
+				sockImg = connImg.connect();
+				redirect=connImg.getRedirectTo();
+				if (redirect!=null) {
+					connImg=connImg.getRedirectedConnection(redirect);
+					pref.log("Redirect to "+redirect);
+				}
+			} while(redirect!=null);
 			daten = connImg.readData(connImg.connect());
 			fos = new FileOutputStream(new File(datei));
 			fos.write(daten.toBytes());



From salzkammergut at mail.berlios.de  Fri Oct 19 23:14:42 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 19 Oct 2007 23:14:42 +0200
Subject: [Cachewolf-svn] r983 - trunk/src/CacheWolf
Message-ID: <200710192114.l9JLEgqV026960@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-19 23:14:41 +0200 (Fri, 19 Oct 2007)
New Revision: 983

Modified:
   trunk/src/CacheWolf/LogList.java
Log:
LogList: Fix. When adding logs, the order on the GC website is respected.

Modified: trunk/src/CacheWolf/LogList.java
===================================================================
--- trunk/src/CacheWolf/LogList.java	2007-10-19 20:46:46 UTC (rev 982)
+++ trunk/src/CacheWolf/LogList.java	2007-10-19 21:14:41 UTC (rev 983)
@@ -63,6 +63,7 @@
 			add(newLog);
 			return size;
 		}
+		int firstLog=i;
 		// Check whether we have any logs with same date by same user
 		String newLogger=newLog.getLogger();
 		String newIcon=newLog.getIcon();
@@ -79,11 +80,13 @@
 			}
 			i++;
 		}
-		if (i==size)
+		if (i==size) {
 			add(newLog);
-		else
-			logList.insertElementAt(newLog, i);
-		return i;
+			return i;
+		} else {
+			logList.insertElementAt(newLog, firstLog);
+			return firstLog;
+		}
 	}
 
 	 /**



From salzkammergut at mail.berlios.de  Sat Oct 20 21:46:50 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 20 Oct 2007 21:46:50 +0200
Subject: [Cachewolf-svn] r984 - in trunk: resources src/CacheWolf
Message-ID: <200710201946.l9KJkoZn000424@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-20 21:46:42 +0200 (Sat, 20 Oct 2007)
New Revision: 984

Modified:
   trunk/resources/cachewolf.Languages.cfg
   trunk/src/CacheWolf/Log.java
Log:
Log: Fix. Too many logs resulted in exception.

Modified: trunk/resources/cachewolf.Languages.cfg
===================================================================
--- trunk/resources/cachewolf.Languages.cfg	2007-10-19 21:14:41 UTC (rev 983)
+++ trunk/resources/cachewolf.Languages.cfg	2007-10-20 19:46:42 UTC (rev 984)
@@ -218,6 +218,7 @@
 		733=Addi Wpt
 		734=Kein Hauptwegpunkt gefunden zu
 		735=Addi Waypoints m%fcssen das Format xxYYYY haben, wobei xx beliebige Zeichen und YYYY die Zeichen des Hauptcaches nach dem GC sind
+		736=Zu viele Logs (Maximum in Pr%e4ferenzen einstellen)
 		800=Erstelle Liste
 		801=suche...
 		802=Caches identifiziert. Suche weiter...
@@ -768,6 +769,7 @@
 		733=Addi Wpt
 		734=No main waypoint found for
 		735=Addi Waypoints must have the format xxYYYY, where xx are any 2 chars and YYYY are the main cache's chars after the GC
+		736=Too many logs (Limit can be adjusted in preferences)
 		800=Creating list
 		801=searching...
 		802=Caches identified. searching...

Modified: trunk/src/CacheWolf/Log.java
===================================================================
--- trunk/src/CacheWolf/Log.java	2007-10-19 21:14:41 UTC (rev 983)
+++ trunk/src/CacheWolf/Log.java	2007-10-20 19:46:42 UTC (rev 984)
@@ -18,16 +18,21 @@
 	 */
 	Log(String logLine) {
 //		<img src='icon_smile.gif'>&nbsp;2007-01-14 xyz<br>a wonderful log
-		int ic1=logLine.indexOf("<img src='");
-		int ic2=logLine.indexOf("'",ic1+10);
-		icon=logLine.substring(ic1+10,ic2);
-		int d1=logLine.indexOf(";");
-		date=logLine.substring(d1+1,d1+11);
-		int l1=d1+12;
-		if (logLine.substring(l1,l1+3).equals("by ")) l1+=3;
-		int l2=logLine.indexOf("<br>",l1);
-		logger=logLine.substring(l1,l2);
-		message=logLine.substring(l2+4);
+		try {
+			int ic1=logLine.indexOf("<img src='");
+			int ic2=logLine.indexOf("'",ic1+10);
+			icon=logLine.substring(ic1+10,ic2);
+			int d1=logLine.indexOf(";");
+			date=logLine.substring(d1+1,d1+11);
+			int l1=d1+12;
+			if (logLine.substring(l1,l1+3).equals("by ")) l1+=3;
+			int l2=logLine.indexOf("<br>",l1);
+			logger=logLine.substring(l1,l2);
+			message=logLine.substring(l2+4);
+		} catch (Exception ex) {
+			icon=MAXLOGICON;
+			date="1900-00-00";
+		}
 	}
 	
 	Log(String icon, String date, String logger, String message) {
@@ -78,7 +83,7 @@
 	/** Return HTML representation of log for display on screen */
 	public String toHtml(){
 //		<img src='icon_smile.gif'>&nbsp;2007-01-14 xyz<br>a wonderful log
-		if (icon.equals(MAXLOGICON)) return "Too many logs";
+		if (icon.equals(MAXLOGICON)) return "<hr>"+MyLocale.getMsg(736,"Too many logs")+"<hr>";
 		StringBuffer s=new StringBuffer(300);
 		s.append("<img src='");
 		s.append(icon);



From salzkammergut at mail.berlios.de  Sun Oct 21 18:37:19 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 21 Oct 2007 18:37:19 +0200
Subject: [Cachewolf-svn] r985 - trunk/src/CacheWolf
Message-ID: <200710211637.l9LGbJ1b031544@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-21 18:37:15 +0200 (Sun, 21 Oct 2007)
New Revision: 985

Modified:
   trunk/src/CacheWolf/CWPoint.java
Log:
CWPoint: Fix to deal with the propagation of rounding errors from seconds to minutes to degrees. (See also http://www.geoclub.de/ftopic19709.html). If seconds are 59.95, they are rounded up to 60.0 and need to be displayed as 0 with the minutes value incremented by one.

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-10-20 19:46:42 UTC (rev 984)
+++ trunk/src/CacheWolf/CWPoint.java	2007-10-21 16:37:15 UTC (rev 985)
@@ -312,14 +312,11 @@
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLatDeg(int format) {
-		double latdeg = latDec;
-		double lonMin=(Math.abs(latDec) - (int)Math.abs(latDec))*60.0;
-		if (java.lang.Math.round(lonMin)*1000 == 60000) latdeg += 1;
 		switch (format) {
 		case DD: 	return MyLocale.formatDouble(this.latDec, "00.00000").replace(',','.');
 		case CW:
 		case DMM:
-		case DMS:	return MyLocale.formatDouble((int) Math.abs(latdeg),"00");
+		case DMS:	return getDMS(latDec,0,format);
 		default: return "";
 		}
 	}
@@ -329,14 +326,11 @@
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLonDeg(int format) {
-		double longdeg = lonDec;
-		double lonMin=(Math.abs(lonDec) - (int)Math.abs(lonDec))*60.0;
-		if (java.lang.Math.round(lonMin)*1000 == 60000) longdeg += 1;
 		switch (format) {
 		case DD: 	return MyLocale.formatDouble(this.lonDec, "000.00000").replace(',','.');
 		case CW:
 		case DMM:
-		case DMS:	return MyLocale.formatDouble((int) Math.abs(longdeg),"000");
+		case DMS:	return getDMS(lonDec,0,format);
 		default: 	return ""; 
 		}
 	}
@@ -346,30 +340,15 @@
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLatMin(int format) {
-		double latMin=(Math.abs(latDec) - (int)Math.abs(latDec))*60.0;
-		if (java.lang.Math.round(latMin)*1000 == 60000) latMin = 0; // TODO this caluclation is doubled from getLatdeg
-		switch (format) {
-			case DD: 	return "";
-			case CW:
-			case DMM:	return MyLocale.formatDouble(latMin, "00.000").replace(',','.');
-			case DMS:	return MyLocale.formatDouble((int) Math.abs(latMin),"00");
-			default: return "";
-		}
+		return getDMS(latDec,1,format);
 	}
+
 	/**
 	 * Get minutes of longitude in different formats
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLonMin(int format) {
-		double lonMin=(Math.abs(lonDec) - (int)Math.abs(lonDec))*60.0;
-		if (java.lang.Math.round(lonMin)*1000 == 60000) lonMin = 0;
-		switch (format) {
-			case DD: 	return "";
-			case CW:
-			case DMM:	return MyLocale.formatDouble(lonMin, "00.000").replace(',','.');
-			case DMS:	return MyLocale.formatDouble((int) Math.abs(lonMin),"00");
-			default: return "";
-		}
+		return getDMS(lonDec,1,format);	
 	}
 
 	/**
@@ -377,16 +356,7 @@
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLatSec(int format) {
-		double tmpMin;
-
-		tmpMin = (Math.abs(latDec) - (int)Math.abs(latDec)) * 60;
-		switch (format) {
-			case DD: 	
-			case CW:
-			case DMM: 	return "";
-			case DMS:	return MyLocale.formatDouble((tmpMin - (int)Math.abs(tmpMin)) * 60, "00.0").replace(',','.');
-			default: return "";
-		}
+		return getDMS(latDec,2,format);
 	}
 
 	/**
@@ -394,18 +364,51 @@
 	 * @param format	Format: DD, DMM, DMS,
 	 */
 	public String getLonSec(int format) {
-		double tmpMin;
+		return getDMS(lonDec,2,format);
+	}
 
-		tmpMin = (Math.abs(lonDec) - (int)Math.abs(lonDec)) * 60;
-		switch (format) {
-			case DD: 	
+	/**
+	 * Returns the degrees or minutes or seconds (depending on parameter what) formatted as a string
+	 * To determine the degrees, we need to calculate the minutes (and seconds) just in case rounding errors
+	 * propagate. Equally we need to know the seconds to determine the minutes value.
+	 * @param deg The coordinate in degrees
+	 * @param what 0=deg, 1=min, 2=sec
+	 * @param format DD,CW,DMM,DMS
+	 * @return 
+	 */
+	private String getDMS(double deg, int what, int format) {
+		deg=Math.abs(deg);
+		long iDeg=(int) deg;
+		double tmpMin, tmpSec;
+		tmpMin= (deg - iDeg)*60.0;
+		switch(format) {
+			case DD: return "";
 			case CW:
-			case DMM: 	return "";
-			case DMS:	return MyLocale.formatDouble((tmpMin - (int)Math.abs(tmpMin)) * 60, "00.0").replace(',','.');
-			default: return "";
+			case DMM: 	
+			    // Need to check if minutes would round up to 60
+				if (java.lang.Math.round(tmpMin*1000.0) == 60000) { tmpMin =0;  iDeg++; }
+				if (what==0)
+					return MyLocale.formatLong(iDeg, "00");
+				else
+					return MyLocale.formatDouble(tmpMin, "00.000").replace(',','.');
+				
+			case DMS:
+				tmpSec= (tmpMin - (int)tmpMin) * 60.0;
+				tmpMin=(int) tmpMin;
+				// Check if seconds round up to 60 
+				if (java.lang.Math.round(tmpSec*10.0) == 600) { tmpSec = 0; tmpMin=tmpMin+1.0; }
+				// Check if minutes round up to 60
+				if (java.lang.Math.round(tmpMin) == 60) { tmpMin = 0; iDeg++; }
+				switch (what) {
+					case 0: return MyLocale.formatLong(iDeg, "00");
+					case 1: return MyLocale.formatDouble(tmpMin, "00");
+					case 2: return MyLocale.formatDouble(tmpSec, "00.0").replace(',','.');
+				}
+		
 		}
+		return ""; // Dummy to keep compiler happy
 	}
-
+	
 	/**
 	 * Get "N" or "S" letter for latitude
 	 */



From mik77 at mail.berlios.de  Sun Oct 21 19:49:21 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Sun, 21 Oct 2007 19:49:21 +0200
Subject: [Cachewolf-svn] r986 - trunk/src/CacheWolf/navi
Message-ID: <200710211749.l9LHnLxB000061@sheep.berlios.de>

Author: mik77
Date: 2007-10-21 19:49:09 +0200 (Sun, 21 Oct 2007)
New Revision: 986

Modified:
   trunk/src/CacheWolf/navi/CWGPSPoint.java
   trunk/src/CacheWolf/navi/GotoPanel.java
Log:
Satellites in view added to GotoPanel

Modified: trunk/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- trunk/src/CacheWolf/navi/CWGPSPoint.java	2007-10-21 16:37:15 UTC (rev 985)
+++ trunk/src/CacheWolf/navi/CWGPSPoint.java	2007-10-21 17:49:09 UTC (rev 986)
@@ -31,6 +31,7 @@
 	public String Date;
 	public int Fix; //Fix
 	public int numSat; //Satellites in use, -1 indicates no data, -2 that data could not be interpreted
+	public int numSatsInView; //Satellites in view
 	public double HDOP; // Horizontal dilution of precision
 	public double Alt; //Altitude
 
@@ -52,6 +53,7 @@
 		this.Date="";
 		this.Fix = 0;
 		this.numSat = 0;
+		this.numSatsInView = 0;
 		this.Alt = 0;
 		this.HDOP = 0;
 	}
@@ -78,6 +80,7 @@
 	public void noData(){
 		this.Fix = 0;
 		this.numSat = 0;
+		this.HDOP = 0;
 	}
 
 	/**
@@ -86,6 +89,7 @@
 	public void noDataError(){
 		this.Fix = -1;
 		this.numSat = -1;
+		this.HDOP = -1;
 	}
 
 	/**
@@ -94,6 +98,7 @@
 	public void noInterpretableData(){
 		this.Fix = -2;
 		this.numSat = -2;
+		this.HDOP = -2;
 	}
 
 	public void ticked(int timerId, int elapsed){
@@ -150,6 +155,10 @@
 		return this.numSat;
 	}
 
+	public int getSatsInView(){
+		return this.numSatsInView;
+	}
+
 	public double getAlt(){
 		return this.Alt;
 	}
@@ -292,6 +301,21 @@
 								lonEW, lonDeg, lonMin, "0", CWPoint.DMM);				
 					}
 				} // if
+
+				if (currToken.equals("$GPGSV")){
+					//Vm.debug("In $$GPGSV");
+					i = 0;
+					while(ex.endOfSearch() != true){
+						currToken = ex.findNext();
+						i++;
+						if (currToken.length()==0) continue; // sometimes there are 2 colons directly one after the other like ",," (e.g. loox)
+						switch (i){
+						case 3: this.numSatsInView = Convert.toInt(currToken); interpreted = true; break;
+						} // switch
+					} // while
+					if (Fix > 0) this.set(latNS, latDeg, latMin, "0", lonEW, lonDeg, lonMin, "0", CWPoint.DMM);
+				} // if
+				
 				//Vm.debug("End of examine");
 			} //while
 		} catch (Exception e) {
@@ -321,15 +345,16 @@
 
 
 	public void printAll(){
-		Vm.debug("Latitude:  " + this.getLatDeg(DD));
-		Vm.debug("Longitude: " + this.getLonDeg(DD));
-		Vm.debug("Speed:     " + this.Speed);
-		Vm.debug("Bearing:   " + this.Bear);
-		Vm.debug("Time:      " + this.Time);
-		Vm.debug("Fix:       " + this.Fix);
-		Vm.debug("Sats:      " + this.numSat);
-		Vm.debug("HDOP:      " + this.HDOP);
-		Vm.debug("Alt:       " + this.Alt);
+		Vm.debug("Latitude:     " + this.getLatDeg(DD));
+		Vm.debug("Longitude:    " + this.getLonDeg(DD));
+		Vm.debug("Speed:        " + this.Speed);
+		Vm.debug("Bearing:      " + this.Bear);
+		Vm.debug("Time:         " + this.Time);
+		Vm.debug("Fix:          " + this.Fix);
+		Vm.debug("Sats:         " + this.numSat);
+		Vm.debug("Sats in view: " + this.numSatsInView);
+		Vm.debug("HDOP:         " + this.HDOP);
+		Vm.debug("Alt:          " + this.Alt);
 		Vm.debug("----------------");
 	}
 }

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-10-21 16:37:15 UTC (rev 985)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-10-21 17:49:09 UTC (rev 986)
@@ -237,7 +237,7 @@
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		//Vm.debug("ticked: before");
-		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getHDOP());
+		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getSatsInView(), myNavigation.gpsPos.getHDOP());
 		if ((fix > 0) && (myNavigation.gpsPos.getSats()>= 0)) {
 			// display values only, if signal good
 			//Vm.debug("currTrack.add: nachher");
@@ -415,6 +415,7 @@
 	
 	int m_fix = -1;
 	int m_sats = -1;
+	int m_satsInView = 0;
 	double m_hdop = -1;
 	float m_speed = -1;
 	
@@ -455,9 +456,10 @@
 		refresh();
 	}
 	
-	public void setGpsStatus(int fix, int sats, double hdop) {
+	public void setGpsStatus(int fix, int sats, int satsInView, double hdop) {
 		m_fix = fix;
 		m_sats = sats;
+		m_satsInView = satsInView;
 		m_hdop = hdop;
 		refresh();
 	}
@@ -594,7 +596,9 @@
 		}
 
 		String strSats = "Sats: -";
-		if (m_sats >= 0) strSats = "Sats: " + Convert.toString(m_sats);
+		if (m_sats >= 0) {
+			strSats = "Sats: " + Convert.toString(m_sats) + "/" + Convert.toString(m_satsInView);
+		}
 		String strHdop = "HDOP: -";
 		if (m_hdop >= 0) strHdop = "HDOP: " + Convert.toString(m_hdop);
 



From mik77 at mail.berlios.de  Mon Oct 22 21:35:52 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Mon, 22 Oct 2007 21:35:52 +0200
Subject: [Cachewolf-svn] r987 - trunk/src/CacheWolf
Message-ID: <200710221935.l9MJZqNq030279@sheep.berlios.de>

Author: mik77
Date: 2007-10-22 21:35:46 +0200 (Mon, 22 Oct 2007)
New Revision: 987

Modified:
   trunk/src/CacheWolf/CoordsScreen.java
Log:
Button for getting GPS coordinates added to CoordsScreen

Modified: trunk/src/CacheWolf/CoordsScreen.java
===================================================================
--- trunk/src/CacheWolf/CoordsScreen.java	2007-10-21 17:49:09 UTC (rev 986)
+++ trunk/src/CacheWolf/CoordsScreen.java	2007-10-22 19:35:46 UTC (rev 987)
@@ -1,5 +1,6 @@
 package CacheWolf;
 
+import CacheWolf.navi.Navigate;
 import ewe.ui.*;
 import ewe.fx.Dimension;
 import ewe.sys.*;
@@ -18,7 +19,7 @@
 	mInput inpNSDeg, inpNSm, inpNSs, inpEWDeg, inpEWm, inpEWs;
 	mInput inpUTMZone, inpUTMNorthing, inpUTMEasting;
 	mInput inpText;
-	mButton btnCancel, btnApply, btnCopy, btnPaste, btnParse;
+	mButton btnCancel, btnApply, btnCopy, btnPaste, btnParse, btnGps;
 	CWPoint coordInp = new CWPoint();
 	CellPanel TopP = new CellPanel();
 	CellPanel BottomP = new CellPanel();
@@ -59,8 +60,9 @@
 
 		TopP.addNext(inpUTMZone = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 		TopP.addNext(inpUTMEasting = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		TopP.addLast(inpUTMNorthing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-
+		TopP.addNext(inpUTMNorthing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		TopP.addLast(btnGps = new mButton("GPS"),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		
 		TopP.addLast(new mLabel(MyLocale.getMsg(1405,"To load coordinates from GC, enter GCxxxxx below")),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
 			// Input for free Text
 		TopP.addNext(inpText = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
@@ -232,6 +234,14 @@
 					this.repaintNow();
 				}
 			}
+			
+			if (ev.target == btnGps){
+				Navigate nav=Global.mainTab.nav;
+				CWPoint coord = nav.gpsPos;
+				currFormat = chkFormat.getSelectedIndex();
+				setFields(coord,currFormat);
+				activateFields(currFormat);
+			}
 		}
 		super.onEvent(ev);
 	}



From mik77 at mail.berlios.de  Wed Oct 24 20:38:25 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 24 Oct 2007 20:38:25 +0200
Subject: [Cachewolf-svn] r988 - trunk/src/CacheWolf
Message-ID: <200710241838.l9OIcPB3015516@sheep.berlios.de>

Author: mik77
Date: 2007-10-24 20:38:20 +0200 (Wed, 24 Oct 2007)
New Revision: 988

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
Show progress when updating caches.

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-10-22 19:35:46 UTC (rev 987)
+++ trunk/src/CacheWolf/myTableControl.java	2007-10-24 18:38:20 UTC (rev 988)
@@ -166,27 +166,19 @@
 			boolean test = true;
 			InfoBox infB = new InfoBox("Info", "Loading", InfoBox.PROGRESS_WITH_WARNINGS);
 			infB.exec();
+			
+			Vector cachesToUpdate = new Vector();
 			for(int i = 0; i <	cacheDB.size(); i++){
 				ch = (CacheHolder)cacheDB.get(i);
 				if(ch.is_Checked == true) {
 					if ( ch.wayPoint.length()>1 && (ch.wayPoint.substring(0,2).equalsIgnoreCase("GC") 
-							 					 || ch.wayPoint.substring(0,2).equalsIgnoreCase("OC")))
+							|| ch.wayPoint.substring(0,2).equalsIgnoreCase("OC")))
 //						if ( (ch.wayPoint.length() > 1 && ch.wayPoint.substring(0,2).equalsIgnoreCase("GC")))
 //						Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
 //						Alter code pr?ft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
 //						TODO: Diese Meldungen vor dem Einloggen darstellen						
 					{
-					    infB.setInfo("Loading: " + ch.wayPoint);
-					    infB.redisplay();
-					    if (ch.wayPoint.substring(0,2).equalsIgnoreCase("GC"))   
-					    	test = spider.spiderSingle(i, infB);
-					    else  
-					    	test = ocSync.syncSingle(i, infB);
-					    if (!test) {
-							infB.close(0);
-							break;
-						} else 
-							profile.hasUnsavedChanges=true;	
+						cachesToUpdate.add(new Integer(i));
 					} else {
 						if (ch.isAddiWpt() && ch.mainCache!=null && !ch.mainCache.is_Checked && !alreadySaid2) { // Is the father ticked?
 							alreadySaid2=true;
@@ -195,10 +187,28 @@
 						if (!ch.isAddiWpt() && !alreadySaid) {
 							alreadySaid = true;
 							(new MessageBox("Information",ch.wayPoint+ ": Diese Funktion steht gegenw?rtig nur f?r Geocaching.com und Opencaching.de zur Verf?gung", MessageBox.OKB)).execute();
-			    		}
+						}
 					}
+
 				}
+			}
 
+			for(int j = 0; j <	cachesToUpdate.size(); j++){
+				int i = (Integer)cachesToUpdate.get(j);
+				ch = (CacheHolder)cacheDB.get(i);
+				infB.setInfo("Loading: " + ch.wayPoint);
+				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.wayPoint +" (" + (j+1) + " / " + cachesToUpdate.size() + ")");
+				infB.redisplay();
+				if (ch.wayPoint.substring(0,2).equalsIgnoreCase("GC"))   
+					test = spider.spiderSingle(i, infB);
+				else  
+					test = ocSync.syncSingle(i, infB);
+				if (!test) {
+					infB.close(0);
+					break;
+				} else 
+					profile.hasUnsavedChanges=true;	
+
 //				cacheDB.clear();
 //				profile.readIndex();
 			}



From mik77 at mail.berlios.de  Wed Oct 24 22:58:43 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Wed, 24 Oct 2007 22:58:43 +0200
Subject: [Cachewolf-svn] r989 - trunk/resources
Message-ID: <200710242058.l9OKwhLi024040@sheep.berlios.de>

Author: mik77
Date: 2007-10-24 22:58:35 +0200 (Wed, 24 Oct 2007)
New Revision: 989

Modified:
   trunk/resources/spider.def
Log:
Longer end sequence in regex longDescRex

Modified: trunk/resources/spider.def
===================================================================
--- trunk/resources/spider.def	2007-10-24 18:38:20 UTC (rev 988)
+++ trunk/resources/spider.def	2007-10-24 20:58:35 UTC (rev 989)
@@ -14,7 +14,8 @@
 # Version 2.10 - 20070825 Travelbug support
 # Version 2.11 - 20070907 get travelbug mission by tracking number
 # Version 3.0 - 20071010 adaption to new GC-design
-# Version 3.1 - 20091013 Use the given prefix for addi waypoints
+# Version 3.1 - 20071013 Use the given prefix for addi waypoints
+# Version 3.2 - 20071024 longer end sequence for longDescRex
 #============================================================
 # A suffix of Rex indicates a regular expression
 # A suffix of ExStart indicates the start of an Extractor search pattern
@@ -51,7 +52,7 @@
 cacheArchived      = This cache\ has\ been\ archived
 latLonRex          = <span\ id="LatLon"\ style="font-weight:bold;">((?s).*?)</span>
 shortDescRex       = <span\ id="ShortDescription">((?s).*?)</span>
-longDescRex        = <span\ id="LongDescription">((?s).*?)<strong>Additional\ Hints
+longDescRex        = <span\ id="LongDescription">((?s).*?)<strong>Additional\ Hints&nbsp;\\(</strong>
 cacheNameRex       = <span\ id="CacheName">((?s).*?)</span>
 cacheOwnerRex      = <span\ id="CacheOwner">by\ <a\ href=(?:(?s).*?)>((?s).*?)</a></span>
 dateHiddenRex      = <span\ id="DateHidden">((?s).*?)</span>



From pfeffer at mail.berlios.de  Thu Oct 25 14:05:38 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Oct 2007 14:05:38 +0200
Subject: [Cachewolf-svn] r990 - in trunk/src/CacheWolf: . navi
Message-ID: <200710251205.l9PC5cuQ029390@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-25 14:05:23 +0200 (Thu, 25 Oct 2007)
New Revision: 990

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/CalcPanel.java
   trunk/src/CacheWolf/Common.java
   trunk/src/CacheWolf/DescriptionPanel.java
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/NotesScreen.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/myTableControl.java
   trunk/src/CacheWolf/navi/Area.java
   trunk/src/CacheWolf/navi/GotoPanel.java
   trunk/src/CacheWolf/navi/MapInfoObject.java
   trunk/src/CacheWolf/navi/MapLoader.java
   trunk/src/CacheWolf/navi/MapsList.java
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
MovingMap: much faster loading of the list of maps by renaming the files
DetailsPanel/List: new addi-Wpts are now displayed directly under the main cache
DescriptionPanel: for Addi-Wpts the description is joined with the respective main Waypoint
CacheHolder: new method getCacheDetails returns the respective CacheDetails either loaded from disc or when already in RAM a pointer there. This routine automatically keeps track in RAM of the last 50 cacheholderdetails. This is done to speed some things. Maybe in a later stage writing of the respective .xml can also be postponed (this could speed up import from opencaching significantly)
Notes: new cancel Button and safty questeions

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -1,6 +1,8 @@
 package CacheWolf;
+import ewe.io.IOException;
 import ewe.sys.Convert;
 import ewe.sys.Vm;
+import ewe.ui.MessageBox;
 import ewe.util.Vector;
 
 /**
@@ -86,6 +88,7 @@
 public CacheHolder mainCache;
 /** The date this cache was last synced with OC in format yyyyMMddHHmmss */
 public String lastSyncOC = EMPTY;
+public CacheHolderDetail details = null;
 /** When sorting the cacheDB this field is used. The relevant field is copied here and
  *  the sort is always done on this field to speed up the sorting process 
  */
@@ -233,6 +236,69 @@
 		   }
 	   }
    }
+   
+   /**
+    * True if ch and this belong to the same main cache. 
+    * @param ch
+    * @return
+    */
+   public boolean hasSameMainCache(CacheHolder ch) {
+	   if (this == ch) return true;
+	   if (ch == null) return false;
+	   if ((!this.isAddiWpt()) && (!ch.isAddiWpt())) return false;
+	   CacheHolder main1, main2;
+	   if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
+	   if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
+	   return main1 == main2;
+   }
+   
+   /** 
+    * Call this method to get the long-description and so on.
+    * If the according .xml-file is already read, it will return
+    * that one, otherwise it will be loaded.
+    * To avoid memory problems this routine loads not for more caches than maxDetails
+    * the details. If maxdetails is reached, it will remove from RAM the details 
+    * of the 5 caches that were loaded most long ago.
+    * 
+    * @return the respective CacheHolderDetail, null if according xml-file could not be read
+    */
+   
+   public CacheHolderDetail getCacheDetails(boolean maybenew) {
+	   if (details != null) {
+		   details.update(this);
+		   return details;
+	   }
+	   if (cachesWithLoadedDetails.size() >= maxDetails) removeOldestDetails();
+	   details = new CacheHolderDetail(this);
+	   try {
+		   details.readCache(Global.getProfile().dataDir);
+	   } catch (IOException e) {
+		   if (maybenew) details.update(this);
+		   else {
+			   (new MessageBox("Error", "Could not read cache details for cache: "+this.wayPoint, MessageBox.OKB)).execute();
+			   return null;
+		   } 
+	   }
+	   cachesWithLoadedDetails.add(this);
+	   return details;
+   }
+   
+   public void releaseCacheDetails() {
+	   details = null;
+	   cachesWithLoadedDetails.remove(this);
+   }
+   
+   final static int maxDetails = 50; 
+   static Vector cachesWithLoadedDetails = new Vector(maxDetails);
+   
+   public static void removeOldestDetails() { // TODO save changes if requested?
+	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+   }
+   
 /*
 public void finalize() {nObjects--;
    Vm.debug("Destroying CacheHolder "+wayPoint);

Modified: trunk/src/CacheWolf/CalcPanel.java
===================================================================
--- trunk/src/CacheWolf/CalcPanel.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/CalcPanel.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -166,7 +166,7 @@
 			if (ev.target == btnGoto){
 				readFields(coordInp, bd, currFormat);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				mainT.gotoPoint(coordOut.toString());
+				mainT.gotoPoint(coordOut);
 			}
 			if (ev.target == btnChangeLatLon){
 				CoordsScreen cs = new CoordsScreen();

Modified: trunk/src/CacheWolf/Common.java
===================================================================
--- trunk/src/CacheWolf/Common.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/Common.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -8,34 +8,14 @@
 	private static char digSep=MyLocale.getDigSeparator().charAt(0);
 	private static char notDigSep=MyLocale.getDigSeparator().charAt(0)=='.'?',':'.';
 	
+	/**
+	 * get double value from string. It interpretes "." and "," as decimal separator
+	 * when the string cannot be interpreted, return 0.
+	 * @param value
+	 * @return
+	 */
 	public static double parseDouble(String value){
-
-/*		The following code is EXTREMELY inefficient.
-        ============================================
- 		String a = new String();
-		String b = new String();
-		char separator = '.';
-		double aDbl, bDbl;
-		
-		
-		if (value.indexOf('.') < 0) {
-			if (value.indexOf(',') < 0) value = value + ".0"; // no separartor
-			else separator = ',';
-		}
-		else separator = '.';
-		
-		a = value.substring(0, value.indexOf(separator));
-		aDbl = Convert.toDouble(a);
-
-		
-		b = value.substring(value.indexOf(separator)+1);
-		bDbl = Convert.toDouble(b);
-		// Calc Minutes
-		bDbl = bDbl / java.lang.Math.pow((double)10,(double)b.length()); // Using pow is BAD NEWS!!!
-		
-		return aDbl>=0?aDbl + bDbl:aDbl - bDbl;
-*/      
-		// This is at least a factor of 3 faster (returns 0 for invalid arguments)
+		// returns 0 for invalid arguments
 		try {
 			return java.lang.Double.parseDouble(value.replace(notDigSep,digSep));
 		} catch (Exception e) {
@@ -150,4 +130,16 @@
 		else fileName = name+t[i];
 		return fileName;
 	}
+	/** get the extension of a filename, including "."
+	 * remark: ewe.io.File.getFileExtension return name + extension
+	 * @param fn
+	 * @return
+	 */
+	public static String getFilenameExtension (String fn) {
+		if (fn == null || fn.length() == 0) return "";
+		int dot = fn.lastIndexOf(".");
+		if (dot < 0) return "";
+		return fn.substring(dot, fn.length());
+	}
+
 }

Modified: trunk/src/CacheWolf/DescriptionPanel.java
===================================================================
--- trunk/src/CacheWolf/DescriptionPanel.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/DescriptionPanel.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -28,15 +28,31 @@
 	/**
 	*	Set the text to display. Text should be HTML formated.
 	*/
+	String description = null;
 	public void setText(CacheHolderDetail cache){
-		if (currCache != cache){
-			Vm.showWait(true);
-			if (cache.is_HTML)	disp.setHtml(cache.LongDescription);
-			else				disp.setPlainText(cache.LongDescription);
-			disp.scrollTo(0,false);
+		if (currCache == cache) return;
+		int scrollto = 0;
+		if (cache.hasSameMainCache(currCache)) scrollto = disp.getTopLine();
+		String desc;
+		if (cache == null) desc = "";
+		else {
+			if (cache.isAddiWpt()) {
+				if (cache.LongDescription != null && cache.LongDescription.length() > 0)
+					 desc = cache.LongDescription + "<br>\n"+cache.mainCache.getCacheDetails(true).LongDescription;
+				else desc = cache.mainCache.getCacheDetails(true).LongDescription;
+
+			} else // not an addi-wpt
+				desc = cache.LongDescription;
+		}
+		if (!desc.equals(description)) {
+			Vm.showWait(true); 
+			if (cache.is_HTML)	disp.setHtml(desc);
+			else				disp.setPlainText(desc);
+			disp.scrollTo(scrollto,false);
+			description = desc;
 			Vm.showWait(false);
-			currCache = cache;
 		}
+		currCache = cache;
 	}
 	
 	private void redraw() {

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -25,7 +25,8 @@
 	mButton btnNewWpt, btnShowBug, btnShowMap, btnGoto, btnAddPicture, btnBlack, btnNotes, btnSave, btnCancel;
 	mButton btnFoundDate,btnHiddenDate;
 	Vector cacheDB;
-	CacheHolderDetail thisCache;
+	CacheHolder thisCache;
+	int dbIndex = -1;
 	CellPanel pnlTools = new CellPanel(); 
 	AttributesViewer attV;
 	
@@ -146,34 +147,35 @@
 	
 	
 	/**
-	*	Set the values to display.
+	* @param chD details of the cache to display
+	* @param dbindex index in cacheDB, in which changes will be saved
 	*/
-	public void setDetails(CacheHolderDetail chD){
-		thisCache = chD;
+	public void setDetails(CacheHolder ch){
+		thisCache = ch;
 		dirty_notes = false;
 		dirty_details = false;
-		inpWaypoint.setText(chD.wayPoint);
-		inpName.setText(chD.CacheName);
-	    btnWayLoc.setText(chD.pos.toString());
-		inpHidden.setText(chD.DateHidden);
-		inpOwner.setText(chD.CacheOwner);
-		if (chD.CacheStatus.length()>=10 && chD.CacheStatus.charAt(4)=='-')
-			chcStatus.setText(MyLocale.getMsg(318,"Found")+" "+chD.CacheStatus);
+		inpWaypoint.setText(ch.wayPoint);
+		inpName.setText(ch.CacheName);
+	    btnWayLoc.setText(ch.pos.toString());
+		inpHidden.setText(ch.DateHidden);
+		inpOwner.setText(ch.CacheOwner);
+		if (ch.CacheStatus.length()>=10 && ch.CacheStatus.charAt(4)=='-')
+			chcStatus.setText(MyLocale.getMsg(318,"Found")+" "+ch.CacheStatus);
 		else {
-			chcStatus.setText(chD.CacheStatus);
+			chcStatus.setText(ch.CacheStatus);
 			// If the cache status contains a date, do not overwrite it with 'found' message
-			if(chD.is_found == true) chcStatus.setText(MyLocale.getMsg(318,"Found"));
+			if(ch.is_found == true) chcStatus.setText(MyLocale.getMsg(318,"Found"));
 		}
-		chcType.setInt(transType(chD.type));
-		if(chD.is_black){
+		chcType.setInt(transType(ch.type));
+		if(ch.is_black){
 			btnBlack.image = imgBlack;
 		} else {
 			btnBlack.image = imgBlackNo;
 		}
-		blackStatus=chD.is_black; 
+		blackStatus=ch.is_black; 
 		blackStatusChanged=false;
 		btnBlack.repaintNow();
-		if(chD.has_bug == true) {
+		if(ch.has_bug == true) {
 			//btnShowBug.modify(Control.Disabled,1);
 			btnShowBug.image = imgShowBug;
 		} else {
@@ -181,17 +183,17 @@
 			btnShowBug.image = imgShowBugNo;
 		}
 		btnShowBug.repaintNow();
-		if(chD.CacheSize.equals("Micro")) chcSize.setInt(1);
-		if(chD.CacheSize.equals("Small")) chcSize.setInt(2);
-		if(chD.CacheSize.equals("Regular")) chcSize.setInt(3);
-		if(chD.CacheSize.equals("Large")) chcSize.setInt(4);
-		if(chD.CacheSize.equals("Other")) chcSize.setInt(5);
-		if(chD.CacheSize.equals("Very Large")) chcSize.setInt(6);
-		if(chD.CacheSize.equals("None")) chcSize.setInt(7);
-		if(chD.CacheSize.equals("Not chosen")) chcSize.setInt(7);
-		attV.showImages(chD.attributes);
-		lblTerr.setText((chD.terrain.length()>0) ? (MyLocale.getMsg(1001,"T")+": "+chD.terrain) : "");
-		lblDiff.setText((chD.hard.length()>0)    ? (MyLocale.getMsg(1000,"D")+": "+chD.hard) : ""); 
+		if(ch.CacheSize.equals("Micro")) chcSize.setInt(1);
+		if(ch.CacheSize.equals("Small")) chcSize.setInt(2);
+		if(ch.CacheSize.equals("Regular")) chcSize.setInt(3);
+		if(ch.CacheSize.equals("Large")) chcSize.setInt(4);
+		if(ch.CacheSize.equals("Other")) chcSize.setInt(5);
+		if(ch.CacheSize.equals("Very Large")) chcSize.setInt(6);
+		if(ch.CacheSize.equals("None")) chcSize.setInt(7);
+		if(ch.CacheSize.equals("Not chosen")) chcSize.setInt(7);
+		attV.showImages(ch.getCacheDetails(true).attributes);
+		lblTerr.setText((ch.terrain.length()>0) ? (MyLocale.getMsg(1001,"T")+": "+ch.terrain) : "");
+		lblDiff.setText((ch.hard.length()>0)    ? (MyLocale.getMsg(1000,"D")+": "+ch.hard) : ""); 
 	}
 	
 	
@@ -265,6 +267,25 @@
 	}
 	
 	/**
+	 * if is addi -> returns the respective AddiWpt
+	 * if is main -> returns the respective MainWpt 
+	 *
+	 */
+	public void createWptName() {
+		String wpt = inpWaypoint.getText();
+		if (CacheType.isAddiWpt(transSelect(chcType.getInt())) && 
+				(Global.mainTab.mainCache.startsWith("GC")||Global.mainTab.mainCache.startsWith("OC")||Global.mainTab.mainCache.startsWith("CW")) &&
+				wpt.startsWith("CW")) {
+			// for what was this?: Global.mainTab.lastselected=Global.mainTab.mainCache;
+			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(Global.mainTab.mainCache));
+		} 
+		if (!CacheType.isAddiWpt(transSelect(chcType.getInt())) && !(wpt.startsWith("GC") 
+				|| wpt.startsWith("OC") || wpt.startsWith("CW")) ) {
+			inpWaypoint.setText(Global.getProfile().getNewWayPointName());
+		}
+	}
+	
+	/**
 	*	Method to react to a user input.
 	*/
 	public void onEvent(Event ev){
@@ -272,23 +293,13 @@
 			dirty_details = true;
 			profile.hasUnsavedChanges=true;
 			if (ev.target==chcType) {
-				if (CacheType.isAddiWpt(transSelect(chcType.getInt())) && 
-					(Global.mainTab.mainCache.startsWith("GC")||Global.mainTab.mainCache.startsWith("OC")) &&
-					inpWaypoint.getText().startsWith("CW")) {
-						Global.mainTab.lastselected=Global.mainTab.mainCache;
-						int wptNo=-1;
-						String waypoint;
-						do {
-							waypoint=MyLocale.formatLong(++wptNo,"00")+Global.mainTab.mainCache.substring(2);
-						} while (Global.getProfile().getCacheIndex(waypoint)>=0);
-						inpWaypoint.setText(waypoint);
-				}
+				createWptName();
 			}
 		}
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if(ev.target == btnNotes){
 				dirty_notes=true;
-				NotesScreen nsc = new NotesScreen(thisCache);
+				NotesScreen nsc = new NotesScreen(thisCache.getCacheDetails(true));
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
 			else if(ev.target == btnShowMap){
@@ -304,7 +315,7 @@
 			else if(ev.target == btnShowBug){
 				//InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(), "Travelbugs", false, pref);
 				//is.execute();
-				TravelbugInCacheScreen ts = new TravelbugInCacheScreen(thisCache.Travelbugs.toHtml(), "Travelbugs");
+				TravelbugInCacheScreen ts = new TravelbugInCacheScreen(thisCache.getCacheDetails(true).Travelbugs.toHtml(), "Travelbugs");
 				ts.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
 			else if (ev.target == btnCenter){
@@ -319,18 +330,18 @@
 			}
 			else if (ev.target == btnAddDateTime){
 				dirty_notes=true;
-				String note = thisCache.CacheNotes;
+				String note = thisCache.getCacheDetails(true).CacheNotes;
 				Time dtm = new Time();
 				dtm.getTime();
 				dtm.setFormat("E dd.MM.yyyy '/' HH:mm");
 				if(note.length() > 0)	note = note + "\n" + dtm.toString();
 				else 	note = note + dtm.toString();
 				note = note + "\n";
-				thisCache.CacheNotes = note;
-				thisCache.saveCacheDetails( Global.getProfile().dataDir);
+				thisCache.getCacheDetails(true).CacheNotes = note;
+				thisCache.getCacheDetails(true).saveCacheDetails( Global.getProfile().dataDir);
 			}
 			else if (ev.target == btnAddPicture){
-				thisCache.addUserImage(profile);
+				thisCache.getCacheDetails(true).addUserImage(profile);
 			}
 			else if(ev.target == btnBlack){
 				if(thisCache.is_black) {
@@ -352,7 +363,7 @@
 			}
 			else if (ev.target == btnGoto){
 				// TODO if something changed saveWpt();
-				Global.mainTab.gotoPoint(thisCache.LatLon);
+				Global.mainTab.gotoPoint(thisCache.pos);
 			}
 			else if (ev.target == btnWayLoc){
 				CWPoint coords = new CWPoint(btnWayLoc.getText(),CWPoint.CW);
@@ -444,11 +455,13 @@
 		  thisCache.CacheName = inpName.getText().trim();
 		  thisCache.LatLon = thisCache.pos.toString();
 		  thisCache.DateHidden = inpHidden.getText().trim();
+		  String oldType=thisCache.type;
 		  thisCache.type = transSelect(chcType.getInt());
-		  thisCache.saveCacheDetails(profile.dataDir);
+		 // thisCache.saveCacheDetails(profile.dataDir); // this is redundant, because all changes affecting the details are immediately saved
 		  // Now update the table
-		  CacheHolder ch = (CacheHolder)cacheDB.get(Global.mainTab.tbP.getSelectedCache());
-		  ch.CacheStatus=thisCache.CacheStatus;
+		  CacheHolder ch = thisCache; //(CacheHolder)cacheDB.get(dbIndex);
+		  
+	/*	  ch.CacheStatus=thisCache.CacheStatus;
 		  ch.is_found=thisCache.is_found;
 		  ch.is_owned=thisCache.is_owned;
 		  ch.is_black=thisCache.is_black;
@@ -460,9 +473,8 @@
 		  ch.DateHidden=thisCache.DateHidden;
 		  ch.CacheOwner=thisCache.CacheOwner;
 		  ch.has_bug=thisCache.has_bug;
-		  String oldType=ch.type;
 		  ch.type=thisCache.type;
-		  // If the type has changed from/to an addi waypoint, rebuild the references
+*/		  // If the type has changed from/to an addi waypoint, rebuild the references
 		  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType)) {
 			  // If we changed the type to addi, check that a parent exists
 			  if (CacheType.isAddiWpt(ch.type)) {
@@ -472,11 +484,12 @@
 				  else {
 					  idx=profile.getCacheIndex("GC"+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
 					  if (idx<0) idx=profile.getCacheIndex("OC"+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
+					  if (idx<0) idx=profile.getCacheIndex("CW"+ ch.wayPoint.substring(ch.wayPoint.length() == 5?1:2));
 					  if (idx<0) (new MessageBox(MyLocale.getMsg(144,"Warning"),
 							  MyLocale.getMsg(734,"No main cache found for addi waypoint ")+" "+ch.wayPoint+
 							  "\n"+MyLocale.getMsg(735,"Addi Waypoints must have the format xxYYYY, where xx are any 2 chars and YYYY are the main cache's chars after the GC"),FormBase.OKB)).execute();
 				  }
-				  profile.buildReferences();
+				  profile.buildReferences(); // TODO this takes quite long -> use profile.setAddiRef instead
 			  }
 		  }
 		  // set status also on addi wpts
@@ -484,7 +497,7 @@
 		  dirty_notes=false;
 		  dirty_details=false;
 		  
-		  Global.mainTab.tbP.refreshTable();
+		  // Global.mainTab.tbP.refreshTable(); this is done in mainTab.onLeavingPanel
 		  ////Vm.debug("New status updated!");
 	}
 
@@ -531,7 +544,7 @@
 			}
 			public void popupMenuEvent(Object selectedItem){
 				if (selectedItem==mnuPickupTB) { 
-					Travelbug tb=TravelbugPickup.pickupTravelbug(thisCache.Travelbugs);	
+					Travelbug tb=TravelbugPickup.pickupTravelbug(thisCache.getCacheDetails(true).Travelbugs);	
 					if (tb!=null) {
 						dirty_details=true;
 						// Get the list of my travelbugs
@@ -541,9 +554,9 @@
 						tbjList.addTbPickup(tb,Global.getProfile().name,thisCache.wayPoint);
 						tbjList.saveTravelbugsFile();
 						tbjList=null;
-						setHtml(thisCache.Travelbugs.toHtml());
+						setHtml(thisCache.getCacheDetails(true).Travelbugs.toHtml());
 						repaint();
-						thisCache.has_bug=thisCache.Travelbugs.size()>0;						
+						thisCache.has_bug=thisCache.getCacheDetails(true).Travelbugs.size()>0;						
 					}
 				} else if (selectedItem==mnuDropTB) {
 					tbjList=new TravelbugJourneyList();
@@ -553,13 +566,13 @@
 					tbs.execute();
 					if (tbs.selectedItem>=0) {
 						Travelbug tb=tbl.getTB(tbs.selectedItem);
-						thisCache.Travelbugs.add(tb);
+						thisCache.getCacheDetails(true).Travelbugs.add(tb);
 						tbjList.addTbDrop(tb,Global.getProfile().name,thisCache.wayPoint);
 					}
 					tbjList.saveTravelbugsFile();
 					tbjList=null;
-					thisCache.has_bug=thisCache.Travelbugs.size()>0;
-					setHtml(thisCache.Travelbugs.toHtml());
+					thisCache.has_bug=thisCache.getCacheDetails(true).Travelbugs.size()>0;
+					setHtml(thisCache.getCacheDetails(true).Travelbugs.toHtml());
 					repaint();
 					dirty_details=true;
 				} else 

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/MainTab.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -36,7 +36,7 @@
 	StatusBar statBar;
 	public MovingMap mm;
 	Navigate nav;
-	String mainCache="";
+	public String mainCache="";
 	int oldCard=0;
 	boolean cacheDirty=false;
 	
@@ -128,8 +128,9 @@
 				ch = (CacheHolder)cacheDB.get(tbP.getSelectedCache());
 				lastselected=ch.wayPoint;  // Used in Parser.Skeleton
 				try {
-					chD=new CacheHolderDetail(ch);
-					chD.readCache(profile.dataDir);//Vm.debug("MainTab:readCache "+chD.wayPoint+"/S:"+chD.Solver);
+					chD = ch.getCacheDetails(true);
+					//chD=new CacheHolderDetail(ch);
+					//chD.readCache(profile.dataDir);//Vm.debug("MainTab:readCache "+chD.wayPoint+"/S:"+chD.Solver);
 				} catch(Exception e){
 					//Vm.debug("Error loading: "+ch.wayPoint);
 				}
@@ -140,6 +141,9 @@
 			if(detP.isDirty()) {
 				cacheDirty=true;
 				detP.saveDirtyWaypoint();
+				tbP.myMod.updateRows();
+				tbP.selectRow(profile.getCacheIndex(detP.thisCache.wayPoint));
+				tbP.refreshTable();
 			}
 		}
 		if (panelNo==5) { // Leaving the Solver Panel
@@ -178,13 +182,11 @@
 				newWaypoint(chD=new CacheHolderDetail()); 
 			}
 			MyLocale.setSIPButton();
-			detP.setDetails(chD);
+			detP.setDetails(ch);
 			break;
 		case 2: // Description Panel
-			if (chD!=null) {
 				MyLocale.setSIPOff();
 				descP.setText(chD);
-			}
 			break;
 		case 3: // Picture Panel
 			if (chD!=null) {
@@ -205,7 +207,7 @@
 					chMain=new CacheHolderDetail(chD.mainCache);
 					try {
 						chMain.readCache(profile.dataDir); //Vm.debug("mainT:readCache "+chD.wayPoint+"=>Main=>"+chMain.wayPoint+"/S:"+chMain.Solver);
-					} catch(Exception e){pref.log("Error reading cache",e);}
+					} catch(Exception e){pref.log("Error reading cache .xml",e);}
 					solverP.setInstructions(chMain.Solver);
 				} else {
 					//Vm.debug("mainT: Waypoint:"+chD.wayPoint);
@@ -233,15 +235,17 @@
 	/** Update the distances of all caches to the centre and display a message 
 	 */
 	public void updateBearDist(){// Called from DetailsPanel, GotoPanel and myTableControl
+		MessageBox info = new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \n werden neu berechnet...").replace('~','\n'), 0);
+		info.exec();
 		tbP.pref = pref;
 		profile.updateBearingDistance();
 		//tbP.refreshTable();
+		info.close(0);
 		tbP.tc.repaint();
-		//(new MessageBox(MyLocale.getMsg(327,"Information"), MyLocale.getMsg(1024,"Entfernungen in der Listenansicht \nvom aktuellen Standpunkt aus \nneu berechnet").replace('~','\n'), MessageBox.OKB)).execute();
 	}
 
-	public void gotoPoint(String LatLon) { // TODO ?bergabe nicht als String
-		gotoP.setDestinationAndSwitch(LatLon); 
+	public void gotoPoint(CWPoint where) { 
+		gotoP.setDestinationAndSwitch(where); 
 	}
 
 	public void openDescriptionPanel(CacheHolder chi) {
@@ -268,7 +272,7 @@
 	 */
 	public void newWaypoint(CacheHolder ch){
 		onLeavingPanel(oldCard);
-		onEnteringPanel(0); oldCard=0;
+		updatePendingChanges(); // was: onEnteringPanel(0); oldCard=0;
 		mainCache=lastselected;
 		int selectedIndex = profile.getCacheIndex( lastselected );
 		if (selectedIndex >= 0) {
@@ -279,19 +283,21 @@
 		}
 		//if (detP.isDirty()) detP.saveDirtyWaypoint();
 		Global.getProfile().hasUnsavedChanges=true;
-		String waypoint= ch.wayPoint = profile.getNewWayPointName();
-		ch.type = "0";
+		ch.wayPoint = profile.getNewWayPointName();
+		if (ch.type == null || ch.type == "") ch.type = "0";
 		ch.CacheSize = "None";
+		chD = ch.getCacheDetails(true);
+		this.ch = ch;
 		cacheDB.add(ch);
-		tbP.myMod.updateRows();
-		tbP.selectRow(profile.getCacheIndex(waypoint));
+		//tbP.myMod.updateRows();
+		//tbP.selectRow(profile.getCacheIndex(waypoint));
 		//Global.mainTab.tbP.refreshTable();
 		if (this.cardPanel.selectedItem==1) { // Detailpanel already selected
 			postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,1));
 		} else	
 			select(detP);
-		solverP.setInstructions("");
-		tbP.refreshTable();
+		solverP.setInstructions(""); // TODO save them first, don't delete them when the new one is an addi
+		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
 	}
 

Modified: trunk/src/CacheWolf/NotesScreen.java
===================================================================
--- trunk/src/CacheWolf/NotesScreen.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/NotesScreen.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -16,6 +16,7 @@
 	CacheHolderDetail thisCache = null;
 	mButton addDateTime = new mButton((IImage)new mImage("date_time.png"));
 	mButton btSave = new mButton(MyLocale.getMsg(127,"Save"));
+	mButton cancelBtn = new mButton("Cancel");
 	ScrollBarPanel sbp = new ScrollBarPanel(wayNotes);
 	
 	public NotesScreen(CacheHolderDetail ch){
@@ -27,6 +28,7 @@
 		addLast(sbp.setTag(Control.SPAN, new Dimension(3,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
 		titleControls=new CellPanel();
 		titleControls.addNext(addDateTime,CellConstants.HSTRETCH,CellConstants.HFILL);
+		titleControls.addNext(cancelBtn,CellConstants.HSTRETCH,CellConstants.HFILL);
 		titleControls.addLast(btSave,CellConstants.HSTRETCH,CellConstants.HFILL);
 	}
 	
@@ -47,6 +49,23 @@
 				thisCache.saveCacheDetails( Global.getProfile().dataDir);
 				this.close(0);
 			}
+			if(ev.target == cancelBtn){
+				if ( (!thisCache.CacheNotes.equals(wayNotes.getText())) ) {
+					if ( (new MessageBox("Warning", "You will loose any changes made to the notes. Do you want to continue?"
+							, MessageBox.YESB|MessageBox.NOB)).execute() == MessageBox.IDYES) {
+						this.close(0);
+					}
+				} else this.close(0); // no changes -> exit without asking
+			} 
+			if(ev.target == titleOK){
+				if ( (!thisCache.CacheNotes.equals(wayNotes.getText())) ) {
+					if ( (new MessageBox("Warning", "Save changes made to the notes?"
+							, MessageBox.YESB|MessageBox.NOB)).execute() == MessageBox.IDYES) {
+						thisCache.CacheNotes = wayNotes.getText();
+						thisCache.saveCacheDetails( Global.getProfile().dataDir);
+					}
+				}
+			}
 		}
 		super.onEvent(ev);
 	}

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/Profile.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -344,10 +344,11 @@
 	public String getNewWayPointName(){
 		String strWp=null;
 		long  lgWp=1;
-		if (cacheDB.size()==0 )
+		int s = cacheDB.size(); 
+		if (s ==0 )
 			return "CW0000";
 		//Create new waypoint,look if not in db
-		for(int i = 0;i < cacheDB.size();i++){
+		for(int i = 0;i < s;i++){
 			strWp = "CW" + MyLocale.formatLong(lgWp, "0000");
 			if(((CacheHolder)cacheDB.get(i)).wayPoint.indexOf(strWp) >=0 ){
 				//waypoint exists in database
@@ -357,7 +358,32 @@
 		}
 		return strWp;
 	}
+	
+	public String getNewAddiWayPointName(String forcache) {
+		int wptNo=-1;
+		String waypoint;
+		do {
+			waypoint=MyLocale.formatLong(++wptNo,"00")+forcache.substring(2);
+		} while (Global.getProfile().getCacheIndex(waypoint)>=0);
+		return waypoint;
+	}
 
+	/**
+	 * Call this after getNewAddiWayPointName to set the references between main and addi correctly
+	 * @param ch
+	 */
+	public void setAddiRef(CacheHolder ch) {
+		String mainwpt = ch.wayPoint.substring(ch.wayPoint.length()-4);
+		int mainindex = getCacheIndex("GC"+mainwpt);
+		if (mainindex < 0) mainindex = getCacheIndex("OC"+mainwpt);
+		if (mainindex < 0) mainindex = getCacheIndex("CW"+mainwpt);
+		if (mainindex < 0) throw new IllegalArgumentException("no main cache found for: " + ch.wayPoint);
+		CacheHolder mainch = (CacheHolder)cacheDB.get(mainindex);
+		mainch.addiWpts.add(ch);
+		ch.mainCache = mainch;
+	}
+
+
 	public String toString() {
 		return "Profile: Name="+name+"\nCentre="+centre.toString()+"\ndataDir="+dataDir+"\nlastSyncOC="+
 		last_sync_opencaching+"\ndistOC="+distOC;
@@ -452,20 +478,12 @@
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.isAddiWpt()) {
 				//search main cache
-				if (ch.wayPoint.length() == 5){
-					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(1));
-				} 
-				else {
-					index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
-				}
-				if (index == null) { // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
-					if (ch.wayPoint.length() == 5){
-						index = (Integer) dbIndex.get("OC"+ ch.wayPoint.substring(1));
-					} 
-					else {
-						index = (Integer) dbIndex.get("OC"+ ch.wayPoint.substring(2));
-					}
-				}
+				index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(ch.wayPoint.length()-4));
+				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
+					index = (Integer) dbIndex.get("OC"+ ch.wayPoint.substring(ch.wayPoint.length()-4));
+				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
+					index = (Integer) dbIndex.get("CW"+ ch.wayPoint.substring(ch.wayPoint.length()-4));
+				
 				if (index != null) {
 					mainCh = (CacheHolder) cacheDB.get(index.intValue());
 					mainCh.addiWpts.add(ch);
@@ -489,7 +507,8 @@
 		}
 
 	}
-
+	
+	
 	/** Ensure that all filters have the proper length so that the 'charAt' access in the filter
 	 * do not cause nullPointer Exceptions
 	 */

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/myTableControl.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -235,7 +235,7 @@
 
 		if (selectedItem.toString().equals(MyLocale.getMsg(1010,"Goto"))){
 			ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());
-			Global.mainTab.gotoPoint(ch.LatLon);
+			Global.mainTab.gotoPoint(ch.pos);
 		}
 		if (selectedItem.toString().equalsIgnoreCase(MyLocale.getMsg(1020,"Open online in Browser"))){
 			ch = (CacheHolder)cacheDB.get(tbp.getSelectedCache());

Modified: trunk/src/CacheWolf/navi/Area.java
===================================================================
--- trunk/src/CacheWolf/navi/Area.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/navi/Area.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -1,5 +1,6 @@
 package CacheWolf.navi;
 
+import ewe.util.CharArray;
 import CacheWolf.CWPoint;
 
 public class Area {
@@ -86,52 +87,51 @@
 				 return AT_LEFT_EDGE;
 			 return NOT_ON_EDGE;
 	 }
-	 /*
+	 
+	 /**
+	  * get an easy find string for this area
+	  * @return
+	  */
 	 public String getEasyFindString() {
-		 String ul = getEasyFindString(topleft, 60);
-		 String br = getEasyFindString(buttomright, 60);
+		 String ul = getEasyFindString(topleft, 30);
+		 String br = getEasyFindString(buttomright, 30);
 		 int i;
 		 for (i=0; i<br.length(); i++ ) {
 			 if (ul.charAt(i) != br.charAt(i)) break;
 		 }
-		 ewe.sys.Vm.debug(ul+"\n"+br+"\n i:"+i);
+		 //ewe.sys.Vm.debug(ul+"\n"+br+"\n i:"+i);
 		 return ul.substring(0, i);
 	 }
-	 */
+	 
 	 /**
-	  * 
-	  * @param prec number of digits to return, min 2, max: 63
+	  * get an easy find string for a given point with precision prec
+	  * @param prec number of digits to return, min 2, max: 30
 	  * @return
 	  */
-	 /*
 	 public static String getEasyFindString(CWPoint p, int prec) {
 		 double longinrange = p.lonDec;
 		 if (longinrange > 180) longinrange -= 180;
-		 Double kw = new Double(((p.latDec+90)/180) * (double) (1l << (prec)));
-		 long lat = new Double(((p.latDec+90)/180) * (double) (1l << (prec))).longValue(); // TODO handle negative values
-		 lat = kw.longValue();
-		 kw = (double) (1l << (prec));
+		 Double kw = new Double(((p.latDec+90)/180) * (double) (1 << (prec)));
+		 int lat = new Double(((p.latDec+90)/180) * (double) (1 << (prec))).intValue(); // TODO handle negative values
+		 lat = kw.intValue();
+		 //kw = (double) (1 << (prec));
 		 
 		 kw = new Double(((longinrange+180)/360) * (2 ^ (prec -1)));
-		 long lon = new Double(((longinrange+180)/360) * (double) (1l << (prec))).longValue(); // 180 = 10110100
+		 int lon = new Double(((longinrange+180)/360) * (double) (1 << (prec))).intValue(); // 180 = 10110100
 		 String ret = "";
-		 Long tmp;
+		 int tmp;
 		 for (int i=prec-1; i>=0;  i--) {
-			 tmp = (1l << i);
-			 tmp = (lat & (1l << i));
-			 tmp = ((lat & (1l << i)) >> i);
-			 tmp = ((lon & (1l << i)) >> i) + (((lat & (1l << i) ) << 1) >> i);
-			 ret += tmp.toString();
+			 tmp = (1 << i);
+			 tmp = (lat & (1 << i));
+			 tmp = ((lat & (1 << i)) >> i);
+			 tmp = ((lon & (1 << i)) >> i) + (((lat & (1 << i) ) << 1) >> i);
+			 ret += Integer.toString(tmp);
 		 }
-/*		 Area cmp = new Area(new CWPoint (90,0), new CWPoint(-90,180));
-		 if (cmp.isInBound(this)) ret += "0";
-		 else ret += "1";
-		 int i;
-		 while (true) {
-			 for (i=0) 
-			 break;
-		 }
-	*/	/* return ret;
+		 return ret;
 	 }
-*/
+	 
+	 static public boolean containsRoughly(String boundingbox, String q) {
+		 if (boundingbox.length() <= q.length() ) return q.startsWith(boundingbox);
+		 else return boundingbox.startsWith(q);
+	 }
 }
\ No newline at end of file

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -2,6 +2,7 @@
 
 import CacheWolf.CWPoint;
 import CacheWolf.CacheHolder;
+import CacheWolf.CacheType;
 import CacheWolf.CoordsScreen;
 import CacheWolf.DetailsPanel;
 import CacheWolf.Global;
@@ -210,8 +211,8 @@
 	 * set the coords of the destination and switch to gotoPanel  
 	 * @param LatLon destination
 	 */ 
-	public void setDestinationAndSwitch(String LatLon) {
-		myNavigation.setDestination(LatLon);
+	public void setDestinationAndSwitch(CWPoint where) {
+		myNavigation.setDestination(where);
 		mainT.select(this);
 	}
 	
@@ -389,6 +390,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = myNavigation.gpsPos.toString();
 				ch.pos = new CWPoint(myNavigation.gpsPos);
+			//	ch.type = "51"; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint

Modified: trunk/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- trunk/src/CacheWolf/navi/MapInfoObject.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/navi/MapInfoObject.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -385,6 +385,16 @@
 		return calcLatLon(p.x, p.y);
 	}
 	
+	/**
+	 * Get the prefix used for easy and fast finding of the best map
+	 * The filname of the .wfl and respective image should start with this
+	 * prefix in order to make finding the best map much faster 
+	 * @return
+	 */
+	public String getFfPrefix() {
+		return "FF1"+getEasyFindString()+"E-";
+	}
+	
 /*	public Area getArea(){
 		return new Area(new CWPoint(topleft), new CWPoint(buttomright));
 	} */

Modified: trunk/src/CacheWolf/navi/MapLoader.java
===================================================================
--- trunk/src/CacheWolf/navi/MapLoader.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/navi/MapLoader.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -168,6 +168,17 @@
 		ByteArray daten;
 		String quelle = new String();
 		String zone;
+		// prepare MapInfoObject and get fileprefix
+		File dateiF = new File(datei); // change!!!
+		String tmp = dateiF.getName(); // contains the name and the extension
+		String name = tmp.substring(0, tmp.lastIndexOf("."));
+		float metersPerPixel = (float) (alti)*EXPEDIA_METERS_PER_PIXEL;
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, new CWPoint(lat,lon),  PixelWidth, PixelHeight, name);
+		String pref = cal.getFfPrefix();
+		cal.mapName = pref + cal.mapName;
+		cal.fileNameWFL = pref + cal.fileNameWFL;
+		datei = dateiF.getPath()+"/"+ pref + tmp;
+		// download image
 		if (lon <= -10) zone = "USA0409";
 		else zone = "EUR0809";
 
@@ -200,7 +211,7 @@
 		connImg.setRequestorProperty("Cookie", "jscript=1; path=/;");
 		connImg.documentIsEncoded = true;
 		try{
-			File dateiF = new File(datei);
+			dateiF = new File(datei);
 			if(!dateiF.exists()){
 				int i=0;
 				quelle = null;
@@ -232,13 +243,8 @@
 		}catch(IOException e){
 			(new MessageBox("Error", "Error while downloading or saving map:\n"+e.getMessage(), MessageBox.OKB)).exec();
 		}
-		File dateiF = new File(datei); // change!!!
-		String tmp = dateiF.getName(); // contains the name and the extension
-		String name = tmp.substring(0, tmp.lastIndexOf("."));
-		float metersPerPixel = (float) (alti)*EXPEDIA_METERS_PER_PIXEL;
-		MapInfoObject cal = new MapInfoObject(metersPerPixel, new CWPoint(lat,lon),  PixelWidth, PixelHeight, dateiF.getPath()+"/"+name);
 		try {
-		cal.saveWFL(dateiF.getDrivePath(), name);
+		cal.saveWFL(dateiF.getDrivePath(), cal.fileNameWFL);
 		} catch (IOException e) {
 			(new MessageBox("Error", "Error saving calibration file:\n"+e.getMessage(), MessageBox.OKB)).exec();
 		}

Modified: trunk/src/CacheWolf/navi/MapsList.java
===================================================================
--- trunk/src/CacheWolf/navi/MapsList.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/navi/MapsList.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -1,12 +1,19 @@
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
+import CacheWolf.Common;
+import CacheWolf.InfoBox;
 import utils.FileBugfix;
+import ewe.io.CompressedRandomStream;
 import ewe.io.File;
 import ewe.io.IOException;
 import ewe.sys.Double;
+import ewe.sys.Time;
 import ewe.ui.MessageBox;
+import ewe.util.Comparable;
+import ewe.util.Comparer;
 import ewe.util.Hashtable;
+import ewe.util.StandardComparer;
 import ewe.util.Vector;
 import ewe.fx.*;
 /**
@@ -18,7 +25,6 @@
  */
 public class MapsList extends Vector {
 	public static float scaleTolerance = 1.15f; // absolute deviations from this factor are seen to have the same scale
-	public Hashtable scales2Area;
 
 	/**
 	 * loads alle the maps in mapsPath in all subDirs but not recursive, only one level 
@@ -35,8 +41,11 @@
 		if (dirstmp != null) dirs = new Vector(dirstmp);
 		else dirs = new Vector();
 		dirs.add("."); // include the mapsPath itself
-		MapInfoObject tempMIO;
-		MessageBox f = null;
+		MapListEntry tempMIO;
+		MessageBox f = null; 
+		// sort(new StandardComparer(), false);
+
+		
 		for (int j = dirs.size()-1; j >= 0; j--) {
 			files = new FileBugfix(mapsPath+"/"+dirs.get(j));
 			//ewe.sys.Vm.debug("mapd-Dirs:"+files);
@@ -46,48 +55,57 @@
 				rawFileName = dateien[i].substring(0, dateien[i].lastIndexOf("."));
 				try {
 					if (dirs.get(j).equals(".")) // the notation dir/./filename doesn't work on all platforms anyhow
-						tempMIO = new MapInfoObject(mapsPath+"/", rawFileName);
-					else tempMIO = new MapInfoObject(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
+						tempMIO = new MapListEntry(mapsPath+"/", rawFileName);
+					else tempMIO = new MapListEntry(mapsPath+"/"+dirs.get(j)+"/", rawFileName);
 					add(tempMIO);
-			//		ewe.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
-				}catch(IOException ex){ 
+					//ewe.sys.Vm.debug(tempMIO.getEasyFindString() + tempMIO.mapName);
+				}catch(Exception ex){ // TODO exception ist, glaub ich evtl ?berfl?ssig 
 					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
-				}catch(ArithmeticException ex){ // affine contain not allowed values 
+				} /* catch(ArithmeticException ex){ // affine contain not allowed values 
 					if (f == null) (f=new MessageBox("Warning", "Ignoring error while \n reading calibration file \n"+ex.toString(), MessageBox.OKB)).exec();
-				} 
+				} */
 			}
 		}
+		if (MapListEntry.rename == 1) MapListEntry.loadingFinished();
 	}
 
 	public void addEmptyMaps(double lat) {
-		MapInfoObject tempMIO;
-		tempMIO = new MapInfoObject(1.0, lat);
+		MapListEntry tempMIO; 
+		tempMIO = new MapListEntry(1.0, lat);
 		add(tempMIO);
-		tempMIO = new MapInfoObject(5.0, lat);
+		tempMIO = new MapListEntry(5.0, lat);
 		add(tempMIO);
-		tempMIO = new MapInfoObject(50.0, lat);
+		tempMIO = new MapListEntry(50.0, lat);
 		add(tempMIO);
-		tempMIO = new MapInfoObject(250.0, lat);
+		tempMIO = new MapListEntry(250.0, lat);
 		add(tempMIO);
-		tempMIO = new MapInfoObject(1000.0, lat);
+		tempMIO = new MapListEntry(1000.0, lat);
 		add(tempMIO);
 	}
-
+     
+	/* diese Routine wird gegenw?rtig f?r 3 ZWecke verwendet:
+	 * a) normal - keep given resolution --> L?sung: ?bergebene scale nutzen f?r screen
+	 * b) highest res: Ziel: Karte mit h?chster Aufl?sung, die im screen ist und m?glichst nah an lat/lon -> ich muss aufl?sung noch in Dateinamen schreiben
+	 * c) gegenteil von b)
+	 */
 	/**
 	 * find the best map for lat/lon in the list of maps
-	 * currently the best map is the one, whose centre is nearest to lat/lon
+	 * @param lat a point to be inside the map
+	 * @param lon
+	 * @param screen: width, height of the screen. The map must overlap the screen. xy: where is lat/lon on screen
+	 * @param scale scale wanted
+	 * currently the best map is the one, whose center is nearest to lat/lon
 	 * and in Area with its scale nearest to scale.
-	 * it always returns a map (if the list is not empty) 
-	 * even if the map is not inbound
-	 * lat/lon
-	 * @param lat
-	 * @param lon
+	 * it always returns a map (if the list is not empty) as long as it overlaps the screen
 	 * @param forceScale: when true, return null if no map with specified scale could be found
-	 * @return
 	 */
 	public MapInfoObject getBestMap(double lat, double lon, Rect screen, float scale, boolean forceScale) {
 		if (size() == 0) return null;
-		if (scales2Area != null) scales2Area.clear();
+		long start = new Time().getTime();
+		InfoBox progressBox = null;
+		boolean showprogress = false;
+		String cmp = "FF1"+Area.getEasyFindString(new CWPoint(lat, lon), 30);
+		MapListEntry ml;
 		MapInfoObject mi;
 		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
 		double minDistLat = 1000000000000000000000000000000000000000000000.0;
@@ -96,9 +114,22 @@
 		boolean better = false;
 		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
 		float lastscale = -1;
-		for (int i=size()-1; i >= 0 ;i--) { 
+		int testkw = 0;
+		for (int i=size()-1; i >= 0 ;i--) {
+			if (!showprogress && ((i & 31) == 0) && (new Time().getTime()-start  > 100) ) { // reason for (i & 7 == 0): test time only after i is incremented 15 times
+				showprogress = true;      
+				progressBox = new InfoBox("Info", "Searching for best map");
+				progressBox.exec(); 
+				progressBox.waitUntilPainted(100);
+				ewe.sys.Vm.showWait(true);
+			}
+			ml = (MapListEntry)get(i);
+			try {
+				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+				else { mi = ml.getMap(); testkw++;}
+			} catch (IOException ex) {continue; } // could not read .wfl-file
 			better = false;
-			mi = (MapInfoObject)get(i);
+//			mi = (MapInfoObject)get(i);
 			if (screenArea == null || !scaleEquals(lastscale, mi) ) {
 				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
 				lastscale = mi.scale;
@@ -128,40 +159,60 @@
 				}
 			}
 		}
+		if (progressBox != null) {
+			progressBox.close(0);
+			ewe.sys.Vm.showWait(false);
+		}
 		if (bestMap == null) return null;
 		return new MapInfoObject(bestMap); // return a copy of the MapInfoObject so that zooming won't change the MapInfoObject in the list 
 	}
 	/*
-	public MapInfoObject getBestMapNotStrictScale(double lat, double lon, Area screen, float scale) {
+	public MapInfoObject getBestMapNotStrictSciale(double lat, double lon, Area screen, float scale) {
 		MapInfoObject ret = getBestMap(lat, lon, screen, scale, true);
 		if (ret == null) ret = getBestMap(lat, lon, screen, scale, false);
 		return ret;
 	}
-	 */
+	 */ 
 	/**
 	 * @return a map which includs topleft and bottomright, 
 	 * if no map includes both it returns null
 	 * @param if more than one map includes topleft and bottomright than the one will
-	 * be returned which has its centre nearest to topleft. If you have gps-pos and goto-pos
+	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
 	 * as topleft and buttomright use gps as topleft.
 	 * if topleft is really topleft or if it is buttomright is not relevant.  
 	 */
-	
+
 	public MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
+		long start = new Time().getTime();
+		InfoBox progressBox = null;
+		boolean showprogress = false;
+		MapListEntry ml;
 		MapInfoObject mi;
+		String cmp = "FF1"+(new Area(topleft, bottomright)).getEasyFindString();
 		MapInfoObject fittingmap = null;
 		boolean latNearer, lonNearer;
 		boolean better;
 		double minDistLat = 10000000000000000000000.0;
 		double minDistLon = 10000000000000000000000.0;
 		for (int i=size() -1; i>=0 ;i--) {
+			if (!showprogress && ((i & 31) == 0) && (new Time().getTime()-start  > 100) ) { // reason for (i & 7 == 0): test time only after i is incremented 15 times
+				showprogress = true;      
+				progressBox = new InfoBox("Info", "Searching for best map");
+				progressBox.exec(); 
+				progressBox.waitUntilPainted(100);
+				ewe.sys.Vm.showWait(true);
+			}
+			ml = (MapListEntry)get(i);
+			try {
+				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+				else { mi = ml.getMap();}
+			} catch (IOException ex) {continue; } // could not read .wfl-file
 			better = false;
-			mi = (MapInfoObject)get(i);
 			if (mi.isInBound(topleft) && mi.isInBound(bottomright)) { // both points are inside the map
 				if (fittingmap == null || fittingmap.scale > mi.scale * scaleTolerance) {
 					better = true; // mi map has a better (lower) scale than the last knwon good map
 				} else {
-					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its centre is nearer to the gps-point = topleft
+					if (fittingmap != null && scaleEquals(mi, fittingmap)) { // same scale as bestmap till now -> test if its center is nearer to the gps-point = topleft
 						latNearer = java.lang.Math.abs(topleft.latDec- mi.center.latDec)/mi.sizeKm < minDistLat ;
 						lonNearer = java.lang.Math.abs(topleft.lonDec - mi.center.lonDec)/mi.sizeKm < minDistLon;
 						if ( latNearer && lonNearer) better = true; // for faster processing: if lat and lon are nearer then the distancance doesn't need to be calculated
@@ -180,6 +231,10 @@
 				}
 			}
 		} // for
+		if (progressBox != null) {
+			progressBox.close(0);
+			ewe.sys.Vm.showWait(false);
+		}
 		if (fittingmap == null) return null;
 		return new MapInfoObject(fittingmap);
 	}
@@ -195,7 +250,10 @@
 	 */
 	public MapInfoObject getMapChangeResolution(double lat, double lon, Rect screen, float curScale, boolean moreDetails){
 		if (size() == 0) return null;
-		if (scales2Area != null) scales2Area.clear();
+		long start = new Time().getTime();
+		InfoBox progressBox = null;
+		boolean showprogress = false;
+		MapListEntry ml;
 		MapInfoObject mi;
 		MapInfoObject bestMap = null; // = (MapInfoObject)get(0);
 		double minDistLat = 1000000000000000000000000000000000000000000000.0;
@@ -204,9 +262,21 @@
 		boolean better = false;
 		Area screenArea = null; // getAreaForScreen(screen, lat, lon, bestMap.scale, bestMap);
 		float lastscale = -1;
+		String cmp = "FF1"+Area.getEasyFindString(new CWPoint(lat, lon), 30);
 		for (int i=size()-1; i >= 0 ;i--) { 
+			if (!showprogress && ((i & 31) == 0) && (new Time().getTime()-start  > 100) ) { // reason for (i & 7 == 0): test time only after i is incremented 15 times
+				showprogress = true;      
+				progressBox = new InfoBox("Info", "Searching for best map");
+				progressBox.exec(); 
+				progressBox.waitUntilPainted(100);
+				ewe.sys.Vm.showWait(true);
+			}
 			better = false;
-			mi = (MapInfoObject)get(i);
+			ml = (MapListEntry)get(i);
+			try {
+				if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+				else { mi = ml.getMap();}
+			} catch (IOException ex) {continue; } // could not read .wfl-file
 			if (mi.fileNameWFL == "") continue; // exclude "maps" without image // TODO make this a boolean in MapInfoObject
 			if (screenArea == null || !scaleEquals(lastscale, mi)) {
 				screenArea = getAreaForScreen(screen, lat, lon, mi.scale, mi);
@@ -236,6 +306,10 @@
 				}
 			}
 		}
+		if (progressBox != null) {
+			progressBox.close(0);
+			ewe.sys.Vm.showWait(false);
+		}
 		if (bestMap == null) return null;
 		return new MapInfoObject(bestMap);
 	}
@@ -250,14 +324,9 @@
 	 */
 	private Area getAreaForScreen(Rect a, double lat, double lon, float scale, MapInfoObject map) {
 		Area ret = null;
-/*		if (scales2Area == null) scales2Area = new Hashtable();
-		else ret = (Area)scales2Area.get(scale);
-		if (ret != null) return ret;
-	*/	// calculate screen Area
 		Point xy = map.calcMapXY(lat, lon);
 		Point topleft = new Point(xy.x - a.x, xy.y - a.y);
 		ret = new Area(map.calcLatLon(topleft), map.calcLatLon(topleft.x+a.width, topleft.y+a.height));
-		//scales2Area.put(new Float(scale), ret);
 		return ret; 
 	}
 	public static boolean scaleEquals(MapInfoObject a, MapInfoObject b) {
@@ -270,7 +339,7 @@
 		if (s > b.scale) return s / b.scale < scaleTolerance;
 		else return b.scale / s < scaleTolerance;
 	}
-	
+
 	/**
 	 * 
 	 * @param test
@@ -315,7 +384,21 @@
 		}
 		return testa/wanta < olda/wantb * scaleTolerance ; 
 	}
-
+	
+	/* may be the following code is used same time later to further enhance the speed of finding the best map
+	public int getQuickMap(String search){
+		boolean found = false; // TODO unfertig
+		int upperbound = 0;
+		int downbound = size();
+		int test;
+		while (!found) {
+			test = (upperbound + downbound)/2;
+			if ( ((Comparable)(get(test))).compareTo(search) < 0) downbound = test;
+			else upperbound = test;
+		}
+		return 1;
+	}
+*/
 	/** for determining if a new map should be downloaded
 	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
 		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
@@ -324,3 +407,91 @@
 	}
 	 */
 }
+
+class MapListEntry /*implements Comparable */ {
+	String sortEntryBBox;
+	//String sortEntry;
+	String filename;
+	String path;
+	MapInfoObject map;
+	static int rename = 0;
+	static int renameCounter = 0;
+	static InfoBox renameProgressInfoB = null;
+
+	public MapListEntry (String pathi, String filenamei) {
+		filename = new String(filenamei);
+		path = new String(pathi);
+		sortEntryBBox = null;
+		map = null;
+		/*
+		try {map = new MapInfoObject(path, filename); } catch (Exception e) {
+			// TODO: handle exception
+		}
+		
+		ewe.sys.Vm.debug("centerID: "+map.getCenterID());
+		ewe.sys.Vm.debug("PxID: "+map.getPxSizeID());
+		ewe.sys.Vm.debug("scaleID: "+map.getScaleID()+"scale: "+map.scale);
+		*/
+		try {
+			if (filenamei.startsWith("FF1")) sortEntryBBox = filenamei.substring(0, filenamei.indexOf("E-"));
+		} catch (IndexOutOfBoundsException ex) { }
+		if (sortEntryBBox == null ) { //|| sortEntryScaleCenterPx.length() < 16) {
+			try {
+				map = new MapInfoObject(path, filename);
+				sortEntryBBox = "FF1"+map.getEasyFindString();
+				ewe.sys.Vm.debug(sortEntryBBox + ": "+filename);
+				if (rename == 0) { // never asked before
+					if ( (new MessageBox("Optmisiation", "Cachewolf can make loading maps much faster by adding a identification mark to the filename. Do you want me to do this now?\n It can take several minutes", 
+							MessageBox.YESB | MessageBox.NOB)).execute() == MessageBox.IDYES)
+					{
+						renameProgressInfoB = new InfoBox("Info", "\nRenaming file:    \n");
+						renameProgressInfoB.exec();
+						renameProgressInfoB.waitUntilPainted(100);
+						rename = 1; // rename
+					} else rename = 2; // don't rename
+				}
+				if (rename == 1) {
+					renameCounter++;
+					renameProgressInfoB.setInfo("\nRenaming file: " + renameCounter+"\n");
+					String f = path+filename+".wfl";
+					String to = sortEntryBBox+"E-"+filename+".wfl";
+					if (!new File(f).rename(to))
+						(new MessageBox("Error", "Failed to rename:\n"+f+".wfl"+"\nto:\n"+to, MessageBox.OKB)).exec();
+					f = Common.getImageName(path+filename);
+					to = sortEntryBBox+"E-"+filename+Common.getFilenameExtension(f);
+					if (!new File(f).rename(to)) 
+						(new MessageBox("Error", "Failed to rename:\n"+f+".wfl"+"\nto:\n"+to, MessageBox.OKB)).exec();
+					filename = sortEntryBBox+"E-"+filename;
+					map.mapName = sortEntryBBox+"E-"+map.mapName;
+					map.fileNameWFL = path + filename + ".wfl";
+				}
+			} catch (IOException ioex) { // this should not happen
+				(new MessageBox("Error", "Error while reading: "+path+filename+": "+ ioex.getMessage(), MessageBox.OKB)).exec();
+			}
+		}
+	}
+	
+	public MapListEntry(double scale, double lat) {
+		map = new MapInfoObject(scale, lat);
+		filename = map.mapName;
+		sortEntryBBox = "FF1";
+	}
+	
+	public MapInfoObject getMap() throws IOException {
+		if (map == null) map = new MapInfoObject(path, filename);
+		return map;
+	}
+	
+	public static void loadingFinished() {
+		if (renameProgressInfoB != null) renameProgressInfoB.close(0);
+		renameProgressInfoB = null;
+	}
+	
+	/*
+	// this maybe needed some time later to further enhance the speed of finding the best map
+	public int compareTo(Object other) {
+		if (other == null) return 1;
+		return this.sortEntryBBox.compareTo(((MapListEntry)other).sortEntryBBox);
+	} */
+}
+

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-10-24 20:58:35 UTC (rev 989)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-10-25 12:05:23 UTC (rev 990)
@@ -1093,11 +1093,12 @@
 			String ImageFilename = currentMap.getImageFilename(); 
 			if (ImageFilename == null ) {
 				mmp.mapImage = new MapImage();
+				maps.remove(currentMap);
 				(new MessageBox("Error", "Could not find image associated with: \n"+currentMap.fileNameWFL, MessageBox.OKB)).execute();
 			}
 			else { 
 				if (ImageFilename.length() > 0) mmp.mapImage = new MapImage(ImageFilename); // attention: when running in native java-vm, no exception will be thrown, not even OutOfMemeoryError
-				else mmp.mapImage = new MapImage();
+				else mmp.mapImage = new MapImage(); // no image associated with the calibration info ("empty map")
 			}
 			mapImage1to1 = mmp.mapImage;
 			mmp.mapImage.properties = mmp.mapImage.properties | AniImage.IsMoveable;
@@ -1145,7 +1146,7 @@
 				mmp.mapImage = null; mapImage1to1 = mmp.mapImage;
 			}
 			addOverlaySet();
-			updateOnlyPosition(lat, lon, false);
+			updateOnlyPosition(lat, lon, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually 
 			inf.close(0);
 			Vm.showWait(false);
 			(new MessageBox("Error", "Not enough ressources to load map: "+ newmap.getImageFilename()+"\nYou can try to close\n all prgrams and \nrestart CacheWolf", MessageBox.OKB)).execute();
@@ -1755,6 +1756,8 @@
 		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
 		this.maps = maps;
 		MapInfoObject map;
+		MapListEntry ml;
+		String cmp;
 		ScrollBarPanel scb;
 		int oldmap = -1;
 		boolean curMapFound = false;
@@ -1764,8 +1767,13 @@
 		if (gotopos != null && Gps != null) {
 			list.addItem("--- Karten von akt. Position und Ziel ---");
 			row++;
+			cmp = "FF1"+(new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
 			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject((MapInfoObject)maps.get(i));
+				ml = (MapListEntry)maps.get(i);
+				try {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+					else { map = ml.getMap();}
+				} catch (IOException ex) {continue; } // could not read .wfl-file
 				if( map.isInBound(Gps.latDec, Gps.lonDec) && map.isInBound(gotopos) ) 
 				{
 					list.addItem(i + ": " + map.mapName);
@@ -1778,9 +1786,13 @@
 		if (Gps != null) {
 			list.addItem("--- Karten der aktuellen Position ---");
 			row++;
+			cmp = "FF1"+Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
 			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject((MapInfoObject)maps.get(i));
-				if (map.isInBound(Gps.latDec, Gps.lonDec) == true) 
+				ml = (MapListEntry)maps.get(i);
+				try {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+					else { map = ml.getMap();}
+				} catch (IOException ex) {continue; } // could not read .wfl-file
 				{
 					list.addItem(i + ": " + map.mapName);
 					row++;
@@ -1792,8 +1804,13 @@
 		if (gotopos != null) {
 			list.addItem("--- Karten des Ziels ---");
 			row++;
+			cmp = "FF1"+Area.getEasyFindString(gotopos, 30);
 			for(int i = 0; i<maps.size();i++){
-				map = new MapInfoObject((MapInfoObject)maps.get(i));
+				ml = (MapListEntry)maps.get(i);
+				try {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
+					else { map = ml.getMap();}
+				} catch (IOException ex) {continue; } // could not read .wfl-file
 				if(map.isInBound(gotopos)) {
 					list.addItem(i + ": " + map.mapName);
 					row++;
@@ -1805,11 +1822,11 @@
 		list.addItem("--- andere Karten ---");
 		row++;
 		for(int i = 0; i<maps.size();i++){
-			map = new MapInfoObject((MapInfoObject)maps.get(i));
+			ml = (MapListEntry)maps.get(i);
 			if(!inList[i]) {
-				list.addItem(i + ": " + map.mapName);
+				list.addItem(i + ": " + ml.filename);
 				row++;
-				if (!curMapFound  && map.mapName.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
+				if (!curMapFound && ml.filename.equals(curMap.mapName)) { oldmap = row; curMapFound = true; }
 			}
 		}
 		list.selectItem(oldmap, true);
@@ -1846,9 +1863,13 @@
 				it = it.substring(0,it.indexOf(':'));
 				mapNum = Convert.toInt(it);
 				//	Vm.debug("Kartennummer: " + mapNum);
-				selectedMap = (MapInfoObject)maps.get(mapNum);
+				try {
+				selectedMap = ((MapListEntry)maps.get(mapNum)).getMap();
 				selected = true;
 				this.close(FormBase.IDOK);
+				} catch (IOException e) {
+					(new MessageBox("Error", "Cannot load wfl-file: \n" + ((MapListEntry)maps.get(mapNum)).filename, MessageBox.OKB)).execute();
+				}
 			}
 			else {
 				selected = false;



From pfeffer at mail.berlios.de  Thu Oct 25 15:55:23 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Oct 2007 15:55:23 +0200
Subject: [Cachewolf-svn] r991 - in trunk/src/CacheWolf: . navi
Message-ID: <200710251355.l9PDtNR1002609@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-25 15:55:18 +0200 (Thu, 25 Oct 2007)
New Revision: 991

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/Profile.java
   trunk/src/CacheWolf/navi/GotoPanel.java
Log:
GotoPanel: "new Waypoint" creates automatically a new AddiWpt

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-10-25 12:05:23 UTC (rev 990)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-10-25 13:55:18 UTC (rev 991)
@@ -34,6 +34,7 @@
 	private boolean dirty_details = false;
 	private boolean blackStatus = false;
 	private boolean blackStatusChanged=false;
+	private boolean isNewWpt = false;
 	
 	Preferences pref; // Test
 	Profile profile;
@@ -138,8 +139,12 @@
 		
 	}
 	
+	public void setIsNew(boolean isnew) {
+		isNewWpt = isnew;
+	}
+	
 	public boolean isDirty() {
-		return dirty_notes || dirty_details;
+		return dirty_notes || dirty_details || isNewWpt;
 	}
 	public boolean hasBlackStatusChanged() {
 		return blackStatusChanged;
@@ -175,6 +180,7 @@
 		blackStatus=ch.is_black; 
 		blackStatusChanged=false;
 		btnBlack.repaintNow();
+		createWptName();
 		if(ch.has_bug == true) {
 			//btnShowBug.modify(Control.Disabled,1);
 			btnShowBug.image = imgShowBug;
@@ -298,7 +304,7 @@
 		}
 		if(ev instanceof ControlEvent && ev.type == ControlEvent.PRESSED){
 			if(ev.target == btnNotes){
-				dirty_notes=true;
+				dirty_notes=true; // TODO I think this is redundant, because the notes are saved seperately by the notes screen itself
 				NotesScreen nsc = new NotesScreen(thisCache.getCacheDetails(true));
 				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
 			}
@@ -496,6 +502,7 @@
 		  ch.setAttributesToAddiWpts();
 		  dirty_notes=false;
 		  dirty_details=false;
+		  setIsNew(false);
 		  
 		  // Global.mainTab.tbP.refreshTable(); this is done in mainTab.onLeavingPanel
 		  ////Vm.debug("New status updated!");

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-10-25 12:05:23 UTC (rev 990)
+++ trunk/src/CacheWolf/MainTab.java	2007-10-25 13:55:18 UTC (rev 991)
@@ -283,8 +283,12 @@
 		}
 		//if (detP.isDirty()) detP.saveDirtyWaypoint();
 		Global.getProfile().hasUnsavedChanges=true;
-		ch.wayPoint = profile.getNewWayPointName();
+		detP.setIsNew(true);
 		if (ch.type == null || ch.type == "") ch.type = "0";
+		if (CacheType.isAddiWpt(ch.type)) {
+			ch.wayPoint = profile.getNewAddiWayPointName(mainCache);
+			profile.setAddiRef(ch);
+		} else ch.wayPoint = profile.getNewWayPointName();
 		ch.CacheSize = "None";
 		chD = ch.getCacheDetails(true);
 		this.ch = ch;

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-10-25 12:05:23 UTC (rev 990)
+++ trunk/src/CacheWolf/Profile.java	2007-10-25 13:55:18 UTC (rev 991)
@@ -359,6 +359,11 @@
 		return strWp;
 	}
 	
+	/**
+	 * 
+	 * @param forcache maincache
+	 * @return
+	 */
 	public String getNewAddiWayPointName(String forcache) {
 		int wptNo=-1;
 		String waypoint;

Modified: trunk/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- trunk/src/CacheWolf/navi/GotoPanel.java	2007-10-25 12:05:23 UTC (rev 990)
+++ trunk/src/CacheWolf/navi/GotoPanel.java	2007-10-25 13:55:18 UTC (rev 991)
@@ -390,7 +390,7 @@
 				CacheHolder ch = new CacheHolder();
 				ch.LatLon = myNavigation.gpsPos.toString();
 				ch.pos = new CWPoint(myNavigation.gpsPos);
-			//	ch.type = "51"; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
+				ch.type = "51"; // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint



From pfeffer at mail.berlios.de  Thu Oct 25 16:00:08 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Oct 2007 16:00:08 +0200
Subject: [Cachewolf-svn] r992 - trunk/src/CacheWolf
Message-ID: <200710251400.l9PE085n002989@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-25 16:00:05 +0200 (Thu, 25 Oct 2007)
New Revision: 992

Modified:
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
Download from Opencaching: TODO Tags for proxy added

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-10-25 13:55:18 UTC (rev 991)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-10-25 14:00:05 UTC (rev 992)
@@ -639,7 +639,7 @@
 			conn.setRequestorProperty("USER_AGENT", "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0");
 			conn.setRequestorProperty("Connection", "close");
 			conn.documentIsEncoded = true;
-			sock = conn.connect();
+			sock = conn.connect(); // TODO I guess here an IOException ocurs when a proxy is used
 			address = conn.getRedirectTo();
 			if (address != null){
 				if (chD != null) fileName = chD.wayPoint + "_" + Common.ClearForFileName(address.substring(address.lastIndexOf("/")+1));



From mirabilos at mail.berlios.de  Thu Oct 25 18:33:57 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Thu, 25 Oct 2007 18:33:57 +0200
Subject: [Cachewolf-svn] r993 - in trunk: . docs lib lib/HTML lib/HTML/Tmpl
	lib/HTML/Tmpl/Element lib/HTML/Tmpl/Parsers lib/com
	lib/com/bbn lib/com/bbn/openmap lib/com/bbn/openmap/proj
	lib/com/bbn/openmap/proj/coords lib/com/bbn/openmap/util
	lib/com/stevesoft lib/com/stevesoft/ewe_pat
	lib/com/stevesoft/ewe_pat/wrap lib/ewesoft lib/ewesoft/xml
	lib/ewesoft/xml/sax
Message-ID: <200710251633.l9PGXvHL026714@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-25 18:32:52 +0200 (Thu, 25 Oct 2007)
New Revision: 993

Added:
   trunk/lib/HTML/
   trunk/lib/HTML/Template.class
   trunk/lib/HTML/Template.java
   trunk/lib/HTML/Tmpl/
   trunk/lib/HTML/Tmpl/Element/
   trunk/lib/HTML/Tmpl/Element/Conditional.class
   trunk/lib/HTML/Tmpl/Element/Conditional.java
   trunk/lib/HTML/Tmpl/Element/Element.class
   trunk/lib/HTML/Tmpl/Element/Element.java
   trunk/lib/HTML/Tmpl/Element/If.class
   trunk/lib/HTML/Tmpl/Element/If.java
   trunk/lib/HTML/Tmpl/Element/Loop.class
   trunk/lib/HTML/Tmpl/Element/Loop.java
   trunk/lib/HTML/Tmpl/Element/Unless.class
   trunk/lib/HTML/Tmpl/Element/Unless.java
   trunk/lib/HTML/Tmpl/Element/Var.class
   trunk/lib/HTML/Tmpl/Element/Var.java
   trunk/lib/HTML/Tmpl/Filter.class
   trunk/lib/HTML/Tmpl/Filter.java
   trunk/lib/HTML/Tmpl/Parsers/
   trunk/lib/HTML/Tmpl/Parsers/Parser.class
   trunk/lib/HTML/Tmpl/Parsers/Parser.java
   trunk/lib/HTML/Tmpl/Util.class
   trunk/lib/HTML/Tmpl/Util.java
   trunk/lib/com/
   trunk/lib/com/bbn/
   trunk/lib/com/bbn/openmap/
   trunk/lib/com/bbn/openmap/LatLonPoint.class
   trunk/lib/com/bbn/openmap/LatLonPoint.java
   trunk/lib/com/bbn/openmap/MoreMath.class
   trunk/lib/com/bbn/openmap/MoreMath.java
   trunk/lib/com/bbn/openmap/proj/
   trunk/lib/com/bbn/openmap/proj/AziDist.class
   trunk/lib/com/bbn/openmap/proj/AziDist.java
   trunk/lib/com/bbn/openmap/proj/Ellipsoid.class
   trunk/lib/com/bbn/openmap/proj/Ellipsoid.java
   trunk/lib/com/bbn/openmap/proj/GreatCircle.class
   trunk/lib/com/bbn/openmap/proj/GreatCircle.java
   trunk/lib/com/bbn/openmap/proj/Length.class
   trunk/lib/com/bbn/openmap/proj/Length.java
   trunk/lib/com/bbn/openmap/proj/Planet.class
   trunk/lib/com/bbn/openmap/proj/Planet.java
   trunk/lib/com/bbn/openmap/proj/ProjMath.class
   trunk/lib/com/bbn/openmap/proj/ProjMath.java
   trunk/lib/com/bbn/openmap/proj/coords/
   trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.class
   trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.java
   trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.class
   trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.java
   trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.class
   trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.java
   trunk/lib/com/bbn/openmap/util/
   trunk/lib/com/bbn/openmap/util/ArgParser$Arg.class
   trunk/lib/com/bbn/openmap/util/ArgParser$HelpArg.class
   trunk/lib/com/bbn/openmap/util/ArgParser.class
   trunk/lib/com/bbn/openmap/util/ArgParser.java
   trunk/lib/com/bbn/openmap/util/Assert.class
   trunk/lib/com/bbn/openmap/util/Assert.java
   trunk/lib/com/bbn/openmap/util/AssertionException.class
   trunk/lib/com/bbn/openmap/util/AssertionException.java
   trunk/lib/com/stevesoft/
   trunk/lib/com/stevesoft/ewe_pat/
   trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.class
   trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.java
   trunk/lib/com/stevesoft/ewe_pat/Any.class
   trunk/lib/com/stevesoft/ewe_pat/Any.java
   trunk/lib/com/stevesoft/ewe_pat/BackG.class
   trunk/lib/com/stevesoft/ewe_pat/BackG.java
   trunk/lib/com/stevesoft/ewe_pat/BackMatch.class
   trunk/lib/com/stevesoft/ewe_pat/BackMatch.java
   trunk/lib/com/stevesoft/ewe_pat/BackRefRule.class
   trunk/lib/com/stevesoft/ewe_pat/BackRefRule.java
   trunk/lib/com/stevesoft/ewe_pat/Backup.class
   trunk/lib/com/stevesoft/ewe_pat/Backup.java
   trunk/lib/com/stevesoft/ewe_pat/BadRangeArgs.class
   trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.class
   trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.java
   trunk/lib/com/stevesoft/ewe_pat/BitSet.class
   trunk/lib/com/stevesoft/ewe_pat/BitSet.java
   trunk/lib/com/stevesoft/ewe_pat/Bits.class
   trunk/lib/com/stevesoft/ewe_pat/Bits.java
   trunk/lib/com/stevesoft/ewe_pat/Boundary.class
   trunk/lib/com/stevesoft/ewe_pat/Boundary.java
   trunk/lib/com/stevesoft/ewe_pat/Bracket.class
   trunk/lib/com/stevesoft/ewe_pat/Bracket.java
   trunk/lib/com/stevesoft/ewe_pat/Branch.class
   trunk/lib/com/stevesoft/ewe_pat/CaseMgr.class
   trunk/lib/com/stevesoft/ewe_pat/CaseMgr.java
   trunk/lib/com/stevesoft/ewe_pat/ChangeRule.class
   trunk/lib/com/stevesoft/ewe_pat/ChangeRule.java
   trunk/lib/com/stevesoft/ewe_pat/CodeRule.class
   trunk/lib/com/stevesoft/ewe_pat/CodeRule.java
   trunk/lib/com/stevesoft/ewe_pat/CodeVal.class
   trunk/lib/com/stevesoft/ewe_pat/Ctrl.class
   trunk/lib/com/stevesoft/ewe_pat/Ctrl.java
   trunk/lib/com/stevesoft/ewe_pat/Custom.class
   trunk/lib/com/stevesoft/ewe_pat/Custom.java
   trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.class
   trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.java
   trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.class
   trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.java
   trunk/lib/com/stevesoft/ewe_pat/DotMulti.class
   trunk/lib/com/stevesoft/ewe_pat/DotMulti.java
   trunk/lib/com/stevesoft/ewe_pat/End.class
   trunk/lib/com/stevesoft/ewe_pat/End.java
   trunk/lib/com/stevesoft/ewe_pat/FastBracket.class
   trunk/lib/com/stevesoft/ewe_pat/FastBracket.java
   trunk/lib/com/stevesoft/ewe_pat/FastChar.class
   trunk/lib/com/stevesoft/ewe_pat/FastMulti.class
   trunk/lib/com/stevesoft/ewe_pat/FastMulti.java
   trunk/lib/com/stevesoft/ewe_pat/FileRegex.class
   trunk/lib/com/stevesoft/ewe_pat/FileRegex.java
   trunk/lib/com/stevesoft/ewe_pat/Group.class
   trunk/lib/com/stevesoft/ewe_pat/Group.java
   trunk/lib/com/stevesoft/ewe_pat/LeftRule.class
   trunk/lib/com/stevesoft/ewe_pat/LeftRule.java
   trunk/lib/com/stevesoft/ewe_pat/Multi.class
   trunk/lib/com/stevesoft/ewe_pat/Multi.java
   trunk/lib/com/stevesoft/ewe_pat/MultiMin.class
   trunk/lib/com/stevesoft/ewe_pat/MultiMin.java
   trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.class
   trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.java
   trunk/lib/com/stevesoft/ewe_pat/NUnicodeAlpha.class
   trunk/lib/com/stevesoft/ewe_pat/NUnicodeCurrency.class
   trunk/lib/com/stevesoft/ewe_pat/NUnicodeDigit.class
   trunk/lib/com/stevesoft/ewe_pat/NUnicodeMath.class
   trunk/lib/com/stevesoft/ewe_pat/NUnicodePunct.class
   trunk/lib/com/stevesoft/ewe_pat/NUnicodeW.class
   trunk/lib/com/stevesoft/ewe_pat/NUnicodeWhite.class
   trunk/lib/com/stevesoft/ewe_pat/NoPattern.class
   trunk/lib/com/stevesoft/ewe_pat/NoPattern.java
   trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.class
   trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.java
   trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.class
   trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.java
   trunk/lib/com/stevesoft/ewe_pat/NullPattern.class
   trunk/lib/com/stevesoft/ewe_pat/NullPattern.java
   trunk/lib/com/stevesoft/ewe_pat/NullRule.class
   trunk/lib/com/stevesoft/ewe_pat/NullRule.java
   trunk/lib/com/stevesoft/ewe_pat/Or.class
   trunk/lib/com/stevesoft/ewe_pat/Or.java
   trunk/lib/com/stevesoft/ewe_pat/OrMark.class
   trunk/lib/com/stevesoft/ewe_pat/OrMark.java
   trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.class
   trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.java
   trunk/lib/com/stevesoft/ewe_pat/Pattern.class
   trunk/lib/com/stevesoft/ewe_pat/Pattern.java
   trunk/lib/com/stevesoft/ewe_pat/PatternSub.class
   trunk/lib/com/stevesoft/ewe_pat/PatternSub.java
   trunk/lib/com/stevesoft/ewe_pat/PopRule.class
   trunk/lib/com/stevesoft/ewe_pat/PopRule.java
   trunk/lib/com/stevesoft/ewe_pat/Prop.class
   trunk/lib/com/stevesoft/ewe_pat/Prop.java
   trunk/lib/com/stevesoft/ewe_pat/Pthings.class
   trunk/lib/com/stevesoft/ewe_pat/Pthings.java
   trunk/lib/com/stevesoft/ewe_pat/PushRule.class
   trunk/lib/com/stevesoft/ewe_pat/PushRule.java
   trunk/lib/com/stevesoft/ewe_pat/RBuffer.class
   trunk/lib/com/stevesoft/ewe_pat/RBuffer.java
   trunk/lib/com/stevesoft/ewe_pat/Range.class
   trunk/lib/com/stevesoft/ewe_pat/Range.java
   trunk/lib/com/stevesoft/ewe_pat/RegHolder.class
   trunk/lib/com/stevesoft/ewe_pat/RegOpt.class
   trunk/lib/com/stevesoft/ewe_pat/RegOpt.java
   trunk/lib/com/stevesoft/ewe_pat/RegRes.class
   trunk/lib/com/stevesoft/ewe_pat/RegRes.java
   trunk/lib/com/stevesoft/ewe_pat/RegSyntax.class
   trunk/lib/com/stevesoft/ewe_pat/RegSyntax.java
   trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.class
   trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.java
   trunk/lib/com/stevesoft/ewe_pat/Regex.class
   trunk/lib/com/stevesoft/ewe_pat/Regex.java
   trunk/lib/com/stevesoft/ewe_pat/RegexReader.class
   trunk/lib/com/stevesoft/ewe_pat/RegexReader.java
   trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.class
   trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.java
   trunk/lib/com/stevesoft/ewe_pat/RegexWriter.class
   trunk/lib/com/stevesoft/ewe_pat/RegexWriter.java
   trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.class
   trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.java
   trunk/lib/com/stevesoft/ewe_pat/Replacer.class
   trunk/lib/com/stevesoft/ewe_pat/Replacer.java
   trunk/lib/com/stevesoft/ewe_pat/RightRule.class
   trunk/lib/com/stevesoft/ewe_pat/RightRule.java
   trunk/lib/com/stevesoft/ewe_pat/Rthings.class
   trunk/lib/com/stevesoft/ewe_pat/Rthings.java
   trunk/lib/com/stevesoft/ewe_pat/RuleHolder.class
   trunk/lib/com/stevesoft/ewe_pat/RuleHolder.java
   trunk/lib/com/stevesoft/ewe_pat/Skip.class
   trunk/lib/com/stevesoft/ewe_pat/Skip.java
   trunk/lib/com/stevesoft/ewe_pat/Skip2.class
   trunk/lib/com/stevesoft/ewe_pat/Skip2.java
   trunk/lib/com/stevesoft/ewe_pat/SkipBMH.class
   trunk/lib/com/stevesoft/ewe_pat/SkipBMH.java
   trunk/lib/com/stevesoft/ewe_pat/Skipped.class
   trunk/lib/com/stevesoft/ewe_pat/Skipped.java
   trunk/lib/com/stevesoft/ewe_pat/SpecialRule.class
   trunk/lib/com/stevesoft/ewe_pat/SpecialRule.java
   trunk/lib/com/stevesoft/ewe_pat/Start.class
   trunk/lib/com/stevesoft/ewe_pat/Start.java
   trunk/lib/com/stevesoft/ewe_pat/StrPos.class
   trunk/lib/com/stevesoft/ewe_pat/StrPos.java
   trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.class
   trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.java
   trunk/lib/com/stevesoft/ewe_pat/StringLike.class
   trunk/lib/com/stevesoft/ewe_pat/StringLike.java
   trunk/lib/com/stevesoft/ewe_pat/StringRule.class
   trunk/lib/com/stevesoft/ewe_pat/StringRule.java
   trunk/lib/com/stevesoft/ewe_pat/SubMark.class
   trunk/lib/com/stevesoft/ewe_pat/SubMark.java
   trunk/lib/com/stevesoft/ewe_pat/TransPat.class
   trunk/lib/com/stevesoft/ewe_pat/TransPat.java
   trunk/lib/com/stevesoft/ewe_pat/TransRepRule.class
   trunk/lib/com/stevesoft/ewe_pat/Transformer.class
   trunk/lib/com/stevesoft/ewe_pat/Transformer.java
   trunk/lib/com/stevesoft/ewe_pat/UniValidator.class
   trunk/lib/com/stevesoft/ewe_pat/UniValidator.java
   trunk/lib/com/stevesoft/ewe_pat/UnicodeAlpha.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodeCurrency.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodeDigit.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodeLower.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodeMath.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodePunct.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodeUpper.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodeW.class
   trunk/lib/com/stevesoft/ewe_pat/UnicodeWhite.class
   trunk/lib/com/stevesoft/ewe_pat/Validator.class
   trunk/lib/com/stevesoft/ewe_pat/Validator.java
   trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.class
   trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.java
   trunk/lib/com/stevesoft/ewe_pat/lookAhead.class
   trunk/lib/com/stevesoft/ewe_pat/lookAhead.java
   trunk/lib/com/stevesoft/ewe_pat/oneChar.class
   trunk/lib/com/stevesoft/ewe_pat/oneChar.java
   trunk/lib/com/stevesoft/ewe_pat/parsePerl.class
   trunk/lib/com/stevesoft/ewe_pat/parsePerl.java
   trunk/lib/com/stevesoft/ewe_pat/patInf.class
   trunk/lib/com/stevesoft/ewe_pat/patInf.java
   trunk/lib/com/stevesoft/ewe_pat/patInt.class
   trunk/lib/com/stevesoft/ewe_pat/patInt.java
   trunk/lib/com/stevesoft/ewe_pat/wrap/
   trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.class
   trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.java
   trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.class
   trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.java
   trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.class
   trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.java
   trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.class
   trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.java
   trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.class
   trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.java
   trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.class
   trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.java
   trunk/lib/ewesoft/
   trunk/lib/ewesoft/xml/
   trunk/lib/ewesoft/xml/DocumentHandler.class
   trunk/lib/ewesoft/xml/DocumentHandler.java
   trunk/lib/ewesoft/xml/MinML$1.class
   trunk/lib/ewesoft/xml/MinML$MinMLBuffer.class
   trunk/lib/ewesoft/xml/MinML.class
   trunk/lib/ewesoft/xml/MinML.java
   trunk/lib/ewesoft/xml/Parser.class
   trunk/lib/ewesoft/xml/Parser.java
   trunk/lib/ewesoft/xml/XMLDecoder.class
   trunk/lib/ewesoft/xml/XMLDecoder.java
   trunk/lib/ewesoft/xml/XMLElement.class
   trunk/lib/ewesoft/xml/XMLElement.java
   trunk/lib/ewesoft/xml/sax/
   trunk/lib/ewesoft/xml/sax/AttributeList.class
   trunk/lib/ewesoft/xml/sax/AttributeList.java
   trunk/lib/ewesoft/xml/sax/DTDHandler.class
   trunk/lib/ewesoft/xml/sax/DTDHandler.java
   trunk/lib/ewesoft/xml/sax/DocumentHandler.class
   trunk/lib/ewesoft/xml/sax/DocumentHandler.java
   trunk/lib/ewesoft/xml/sax/EntityResolver.class
   trunk/lib/ewesoft/xml/sax/EntityResolver.java
   trunk/lib/ewesoft/xml/sax/ErrorHandler.class
   trunk/lib/ewesoft/xml/sax/ErrorHandler.java
   trunk/lib/ewesoft/xml/sax/HandlerBase.java
   trunk/lib/ewesoft/xml/sax/InputSource.class
   trunk/lib/ewesoft/xml/sax/InputSource.java
   trunk/lib/ewesoft/xml/sax/Locator.class
   trunk/lib/ewesoft/xml/sax/Locator.java
   trunk/lib/ewesoft/xml/sax/Parser.class
   trunk/lib/ewesoft/xml/sax/Parser.java
   trunk/lib/ewesoft/xml/sax/SAXException.class
   trunk/lib/ewesoft/xml/sax/SAXException.java
   trunk/lib/ewesoft/xml/sax/SAXParseException.class
   trunk/lib/ewesoft/xml/sax/SAXParseException.java
Removed:
   trunk/lib/EwesoftRegex.zip
   trunk/lib/HTML.zip
   trunk/lib/ewesoft.zip
   trunk/lib/openmap.jar
Modified:
   trunk/.classpath
   trunk/compile.bat
   trunk/compile.sh
   trunk/docs/Readme.txt
   trunk/runconsole.bat
   trunk/runwolf.bat
   trunk/runwolf.sh
Log:
extract the *.zip and *.jar files (except ewe/CompileEwe) and convert them
to ?native? EOL style; this is because everyone who wants to make .ewe files
or BEs/releases, or wants to use the debug functions, must do that anyway

Dr. Pfeffer agreed to test this with his Eclipse later
works for me on BSD with gcj


Modified: trunk/.classpath
===================================================================
--- trunk/.classpath	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/.classpath	2007-10-25 16:32:52 UTC (rev 993)
@@ -1,11 +1,8 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="lib" path="lib/CompileEwe.zip"/>
-	<classpathentry kind="lib" path="lib/ewe.jar"/>
-	<classpathentry kind="lib" path="lib/ewesoft.zip"/>
-	<classpathentry kind="lib" path="lib/EwesoftRegex.zip"/>
-	<classpathentry kind="lib" path="lib/HTML.zip"/>
-	<classpathentry kind="lib" path="lib/openmap.jar"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="lib" path="lib/CompileEwe.zip"/>
+	<classpathentry kind="lib" path="lib/ewe.jar"/>
+	<classpathentry kind="lib" path="lib"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>


Property changes on: trunk/.classpath
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/compile.bat
===================================================================
--- trunk/compile.bat	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/compile.bat	2007-10-25 16:32:52 UTC (rev 993)
@@ -1,3 +1,3 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
 if not exist bin\exp mkdir bin\exp
-javac -classpath ./lib/CompileEwe.zip;./lib/ewesoft.zip;./lib/EwesoftRegex.zip;./lib/HTML.zip;./lib/openmap.jar  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/exp/*.java ./src/utils/*.java
+javac -classpath ./lib/CompileEwe.zip;./lib/  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/exp/*.java ./src/utils/*.java

Modified: trunk/compile.sh
===================================================================
--- trunk/compile.sh	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/compile.sh	2007-10-25 16:32:52 UTC (rev 993)
@@ -1,2 +1,2 @@
 #!/bin/sh
-javac -cp ./lib/CompileEwe.zip:./lib/ewesoft.zip:./lib/EwesoftRegex.zip:./lib/HTML.zip:./lib/openmap.jar  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
+javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java

Modified: trunk/docs/Readme.txt
===================================================================
--- trunk/docs/Readme.txt	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/docs/Readme.txt	2007-10-25 16:32:52 UTC (rev 993)
@@ -13,28 +13,19 @@
 - Checkout der aktuellen Sourcen aus dem Repository (z.B. http://svn.berlios.de/svnroot/repos/cachewolf/trunk)
 - Das Verzeichnis kann lokal umbenannt werden, z.B. in CacheWolf
 - Es sollte bereits ein Verzeichnis bin/CacheWolf geben, falls nicht, bitte anlegen
-- Die Linux-Scripte mit einem chmod 755 *.sh ausf?hrbar machen
 - Script compile.bat (WinXP) bzw. ./compile.sh (Linux) ausf?hren. Es gibt etwa 10 Warnings.
 - Script getRes.bat bzw. ./getRes.sh ausf?hren. Damit werden u.a. die Image-Dateien in das Work-Verzeichnis kopiert
 - Script runwolf.bat bzw. ./runwolf.sh ausf?hren. Damit wird der CacheWolf im Work-Verzeichnis gestartet. Das Datenverzeichnis sollte man irgendwo anders hinlegen, z.B. parallel zum CacheWolf-Verzeichnis.
 
 Ausf?hrbare Versionen erzeugen, z.B. f?r WinXP oder PPC
 - Parallel zum CacheWolf-Verzeichnis ein Verzeichnis Ewe/programs anlegen, die Dateien finden sich im Ewe-Developer-SDK. Da dieses Verzeichnis von den Scripten relativ (also per ../Ewe/programs) angesprochen wird, auf genaue Einhaltung der Namen achten.
-Der Inhalt des Verziechnisses ist bei mir unter Linux wie folgt:
--rw-r--r-- 1 kalle kalle      29 2006-07-28 20:43 Ewesoft-Jewel.cfg
--rw-r--r-- 1 kalle kalle 3830895 2005-12-19 19:27 JavaEwe.zip
--rw-r--r-- 1 kalle kalle 2748046 2005-12-19 16:52 JewelData.jar
--rw-r--r-- 1 kalle kalle  254444 2005-11-26 23:53 Jewel.ewe
--rw-r--r-- 1 kalle kalle      47 2005-01-20 18:44 RunJewel.bat
--rwxr-xr-x 1 kalle kalle      47 2006-07-24 21:30 runjewel.sh
-runjewel.sh habe ich mir selbst aus runJewel.bat erzeugt.
-
-- In dem Verzeichnis lib die folgenden Dateien rekursiv auspacken (.jar-Files sind zip-Dateien, falls der Entpacker muckt, einfach tempor?r in .zip umbenennen)
-  - ewesoft.zip
-  - EwesoftRegex.zip
-  - HTML.zip
-  - openmap.jar
-  Es gibt dann die Unterverzeichnisse com, ewesoft und HTML
+  Der Inhalt des Verziechnisses ist bei mir unter Linux wie folgt:
+  -rw-r--r-- 1 kalle kalle      29 2006-07-28 20:43 Ewesoft-Jewel.cfg
+  -rw-r--r-- 1 kalle kalle 3830895 2005-12-19 19:27 JavaEwe.zip
+  -rw-r--r-- 1 kalle kalle 2748046 2005-12-19 16:52 JewelData.jar
+  -rw-r--r-- 1 kalle kalle  254444 2005-11-26 23:53 Jewel.ewe
+  -rw-r--r-- 1 kalle kalle      47 2005-01-20 18:44 RunJewel.bat
+  -rwxr-xr-x 1 kalle kalle      47 2006-07-24 21:30 runjewel.sh
 - Script buildexe.bat bzw. ./buildexe.sh aufrufen, es wird ein Verzeichnis CacheWolf erzeugt mit Unterverzeichnissen f?r die unterschiedlichen Plattformen.
 - mit dem Script runjewel k?nnen ?nderungen an der Datei cwberlios.jnf vorgenommen werden.
 

Deleted: trunk/lib/EwesoftRegex.zip
===================================================================
(Binary files differ)

Added: trunk/lib/HTML/Template.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Template.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Template.java
===================================================================
--- trunk/lib/HTML/Template.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Template.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,1087 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML;
+import ewe.util.*;
+import ewe.io.*;
+import ewe.sys.*;
+import HTML.Tmpl.Element.*;
+import HTML.Tmpl.Parsers.*;
+import HTML.Tmpl.Util;
+import HTML.Tmpl.Filter;
+
+/**
+ * Use HTML Templates with ewe.
+ * <p>
+ * The HTML.Template class allows you to use HTML Templates from within
+ * your java programs.  It makes it possible to change the look of your
+ * servlets without having to recompile them.  Use HTML.Template to 
+ * separate code from presentation in your servlets.
+ * <p>
+ * <pre>
+ *	Hashtable args = new Hashtable();
+ *	args.put("filename", "my_template.tmpl");
+ *
+ *	Template t = new Template(args);
+ *
+ *	t.setParam("title", "The HTML Template package");
+ *	t.printTo(response.getWriter());
+ * </pre>
+ * <p>
+ * HTML.Template is based on the perl module HTML::Template by Sam Tregar
+ *
+ * @author	Philip S Tellis
+ * @version	0.1.2
+ */
+public class Template 
+{
+	private If __template__ = new If("__template__");
+	private Hashtable params = new Hashtable();
+
+	private boolean dirty = true;
+
+	private boolean strict = true;
+	private boolean die_on_bad_params = false;
+	private boolean global_vars = false;
+	private boolean case_sensitive = false;
+	private boolean loop_context_vars = false;
+	private boolean debug = false;
+	private boolean no_includes = false;
+	private boolean search_path_on_include = false;
+	private int max_includes = 11;
+	private String filename = null;
+	private String scalarref = null;
+	private String [] arrayref = null;
+	private String [] path = null;
+	private Reader filehandle = null;
+	private Filter [] filters = null;
+
+	private Stack elements = new Stack();
+	private Parser parser;
+
+	/**
+	 * Initialises a new HTML.Template object with the contents of
+	 * the given file.
+	 *
+	 * @param filename			a string containing the name of 
+	 *					the file to be used as a 
+	 *					template.  This may be an 
+	 *					absolute or relative path to a 
+	 *					template file.
+	 *
+	 * @throws FileNotFoundException	If the file specified does not 
+	 *					exist.
+	 * @throws IllegalStateException	If &lt;tmpl_include&gt; is
+	 *					used when no_includes is in
+	 *					effect.
+	 * @throws IOException			If an input or output Exception 
+	 *					occurred while reading the 
+	 *					template.
+	 *
+	 * @deprecated No replacement.  You should use either
+	 *				{@link #Template(Object [])} or
+	 *				{@link #Template(Hashtable)}
+	 */
+	public Template(String filename)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException
+	{
+		this.filename = filename;
+		init();
+	}
+
+	/**
+	 * Initialises a new Template object, using the name/value
+	 * pairs passed as default values.
+	 * <p>
+	 * The parameters passed may be any combination of filename, 
+	 * scalarref, arrayref, path, case_sensitive, loop_context_vars, 
+	 * strict, die_on_bad_params, global_vars, max_includes, 
+	 * no_includes, search_path_on_include and debug.
+	 * Each with its own value.  Any one of filename, scalarref or
+	 * arrayref must be passed.
+	 * <p>
+	 * Eg:
+	 * <pre>
+	 *	String [] template_init = {
+	 *		"filename",  "my_template.tmpl",
+	 *		"case_sensitive", "true",
+	 *		"max_includes",   "5"
+	 *	};
+	 *
+	 *      Template t = new Template(template_init);
+	 * </pre>
+	 * <p>
+	 * The above code creates a new Template object, initialising
+	 * its input file to my_template.tmpl, turning on case_sensitive
+	 * parameter matching, and restricting maximum depth of includes
+	 * to five.
+	 * <p>
+	 * Parameter values that take boolean values may either be a String
+	 * containing the words true/false, or the Boolean values Boolean.TRUE
+	 * and Boolean.FALSE.  Numeric values may be Strings, or Integers.
+	 *
+	 * @since 0.0.8
+	 *
+	 * @param args		an array of name/value pairs to initialise
+	 *			this template with.  Valid values for
+	 *			each element may be:
+	 * @param filename	[Required] a String containing the path to a 
+	 *			template file
+	 * @param scalarref	[Required] a String containing the entire 
+	 *			template as its contents
+	 * @param arrayref	[Required] an array of lines that make up
+	 *			the template
+	 * @param path		[Optional] an array of Strings specifying
+	 *			the directories in which to look for the
+	 *			template file.  If not specified, the current
+	 *			working directory is used.  If specified,
+	 *			only the directories in this array are used.
+	 *			If you want the current directory searched,
+	 *			include "." in the path.
+	 *			<p>
+	 *			If you have only a single path, it can be a
+	 *			plain String instead of a String array.
+	 *			<p>
+	 *			This is effective only for the template file,
+	 *			and not for included files, but see
+	 *			search_path_on_include for how to change that.
+	 * @param case_sensitive	[Optional] specifies whether parameter 
+	 *			matching is case sensitive or not.  A value 
+	 *			of "false", "0" or "" is considered false.  
+	 *			All other values are true.
+	 *			<p>
+	 *			Default: false
+	 * @param loop_context_vars	[Optional] when set to true four loop
+	 * 			context variables are made available inside a 
+	 *			loop: <code>__FIRST__, __LAST__, __INNER__, __ODD__, __COUNTER__</code>.
+	 *			They can be used with <code>&lt;TMPL_IF&gt;</code>, 
+	 *			<code>&lt;TMPL_UNLESS&gt;</code> and <code>&lt;TMPL_ELSE&gt;</code> to 
+	 *			control how a loop is output. Example:
+	 *			<pre>
+	 *	    &lt;TMPL_LOOP NAME="FOO"&gt;
+	 *	       &lt;TMPL_IF NAME="__FIRST__"&gt;
+	 *	         This only outputs on the first pass.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_IF NAME="__ODD__"&gt;
+	 *	         This outputs on the odd passes.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_UNLESS NAME="__ODD__"&gt;
+	 *	         This outputs on the even passes.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_IF NAME="__INNER__"&gt;
+	 *	         This outputs on passes that are 
+	 *		neither first nor last.
+	 *	       &lt;/TMPL_IF&gt;
+	 *
+	 *	       &lt;TMPL_IF NAME="__LAST__"&gt;
+	 *	         This only outputs on the last pass.
+	 *	       &lt;TMPL_IF&gt;
+	 *	    &lt;/TMPL_LOOP&gt;
+	 *			</pre>
+	 *			<p>
+	 *			NOTE: A loop with only a single pass will get 
+	 *			both <code>__FIRST__</code> and <code>__LAST__</code>
+	 *			set to true, but not <code>__INNER__</code>.
+	 *			<p>
+	 *			Default: false
+	 * @param strict	[Optional] if set to false the module will 
+	 *			allow things that look like they might be 
+	 *			TMPL_* tags to get by without throwing
+	 *			an exception.  Example:
+	 *			<pre>
+	 *          &lt;TMPL_HUH NAME=ZUH&gt;
+	 *			</pre>
+	 *			<p>
+	 *			Would normally cause an error, but if you 
+	 *			create the Template with strict == 0, 
+	 *			HTML.Template will ignore it.
+	 *			<p>
+	 *			Default: true
+	 * @param die_on_bad_params		[Optional] if set to true
+	 *			the module will complain if you try to set
+	 *			tmpl.setParam("param_name", "value") and
+	 *			param_name doesn't exist in the template.
+	 *			<p>
+	 *			This effect doesn't descend into loops. 
+	 *			<p>
+	 *			Default: false (may change in later versions)
+	 * @param global_vars	[Optional] normally variables declared outside
+	 *			a loop are not available inside a loop.  This
+	 *			option makes TMPL_VARs global throughout
+	 *			the template.  It also affects TMPL_IF and TMPL_UNLESS.
+	 *			<pre>
+	 *	    &lt;p&gt;This is a normal variable: &lt;TMPL_VAR NORMAL&gt;.&lt;/p&gt;
+	 *
+	 *	    &lt;TMPL_LOOP NAME="FROOT_LOOP&gt;
+	 *	       Here it is inside the loop: &lt;TMPL_VAR NORMAL&gt;
+	 *	    &lt;/TMPL_LOOP&gt;
+	 *			</pre>
+	 *			<p>
+	 *			Normally this wouldn't work as expected, since
+	 *			&lt;TMPL_VAR NORMAL&gt;'s value outside the loop
+	 *			isn't available inside the loop.
+	 *			<p>
+	 *			Default: false (may change in later versions)
+	 * @param max_includes	[Optional] specifies the maximum depth that
+	 *			includes can reach.  Including files to a 
+	 *			depth greater than this value causes an error 
+	 *			message to be displayed.  Set to 0 to disable 
+	 *			this protection.
+	 *			<p>
+	 *			Default: 10
+	 * @param no_includes	[Optional] If set to true, disallows the
+	 *			&lt;TMPL_INCLUDE&gt; tag in the template
+	 *			file.  This can be used to make opening 
+	 *			untrusted templates slightly less dangerous.
+	 *			<p>
+	 *			Default: false
+	 * @param search_path_on_include	[Optional] if set, then the
+	 *			path is searched for included files as well
+	 *			as the template file.  See the path parameter
+	 *			for more information.
+	 *			<p>
+	 *			Default: false
+	 * @param debug		[Optional] setting this option to true causes
+	 *			HTML.Template to print random error messages
+	 *			to STDERR.
+	 *			
+	 * @throws ArrayIndexOutOfBoundsException	If an odd number of
+	 *					parameters is passed.
+	 * @throws FileNotFoundException	If the file specified does not 
+	 *					exist or no filename is passed.
+	 * @throws IllegalArgumentException	If an unknown parameter is
+	 *					passed.
+	 * @throws IllegalStateException	If &lt;tmpl_include&gt; is
+	 *					used when no_includes is in
+	 *					effect.
+	 * @throws IOException			If an input or output Exception 
+	 *					occurred while reading the 
+	 *					template.
+	 */
+	public Template(Object [] args)
+			throws ArrayIndexOutOfBoundsException,
+				FileNotFoundException,
+				IllegalArgumentException,
+				IllegalStateException,
+				IOException
+				
+	{
+		if(args.length%2 != 0)
+			throw new ArrayIndexOutOfBoundsException("odd number " +
+					"of arguments passed");
+
+		for(int i=0; i<args.length; i+=2) {
+			parseParam((String)args[i], args[i+1]);
+		}
+
+		init();
+	}
+
+	/**
+	 * Initialises a new Template object, using the values in the
+	 * Hashtable args as defaults.
+	 * <p>
+	 * The parameters passed are the same as in the Template(Object [])
+	 * constructor. Each with its own value.  Any one of filename, 
+	 * scalarref or arrayref must be passed.
+	 * <p>
+	 * Eg:
+	 * <pre>
+	 *	Hashtable args = new Hashtable();
+	 *	args.put("filename", "my_template.tmpl");
+	 *	args.put("case_sensitive", "true");
+	 *	args.put("loop_context_vars", Boolean.TRUE);
+	 *	// args.put("max_includes", "5");
+	 *	args.put("max_includes", new Integer(5));
+	 *
+	 *	Template t = new Template(args);
+	 * </pre>
+	 * <p>
+	 * The above code creates a new Template object, initialising
+	 * its input file to my_template.tmpl, turning on case_sensitive
+	 * parameter matching, and the loop context variables __FIRST__,
+	 * __LAST__, __ODD__ and __INNER__, and restricting maximum depth of 
+	 * includes to five.
+	 * <p>
+	 * Parameter values that take boolean values may either be a String
+	 * containing the words true/false, or the Boolean values Boolean.TRUE
+	 * and Boolean.FALSE.  Numeric values may be Strings, or Integers.
+	 *
+	 * @since 0.0.10
+	 *
+	 * @param args		a Hashtable of name/value pairs to initialise
+	 *			this template with.  Valid values are the same
+	 *			as in the Template(Object []) constructor.
+	 *			
+	 * @throws FileNotFoundException	If the file specified does not 
+	 *					exist or no filename is passed.
+	 * @throws IllegalArgumentException	If an unknown parameter is
+	 *					passed.
+	 * @throws IllegalStateException	If &lt;tmpl_include&gt; is
+	 *					used when no_includes is in
+	 *					effect.
+	 * @throws IOException			If an input or output Exception 
+	 *					occurred while reading the 
+	 *					template.
+	 *
+	 * @see #Template(Object [])
+	 */
+	public Template(Hashtable args)
+			throws FileNotFoundException,
+				IllegalArgumentException,
+				IllegalStateException,
+				IOException
+				
+	{
+		Enumeration e = args.keys();
+		while(e.hasMoreElements()) {
+			String key = (String)e.nextElement();
+			Object value = args.get(key);
+
+			parseParam(key, value);
+		}
+
+		init();
+	}
+
+	/**
+	 * Prints the parsed template to the provided PrintWriter.
+	 *
+	 * @param out	the PrintWriter that this template will be printed
+	 *		to
+	 */
+	public void printTo(PrintWriter out) 
+	{
+		out.print(output());
+	}
+
+	/**
+	 * Returns the parsed template as a String.
+	 *
+	 * @return	a string containing the parsed template
+	 */
+	public String output()
+	{
+		return __template__.parse(params);
+	}
+
+	/**
+	 * Sets the values of parameters in this template from a Hashtable.
+	 *
+	 * @param params	a Hashtable containing name/value pairs for
+	 *			this template.  Keys in this hashtable must
+	 *			be Strings and values may be either Strings
+	 *			or Vectors.
+	 *			<p>
+	 *			Parameter names are currently not case
+	 *			sensitive.
+	 *			<p>
+	 *			Parameter names can contain only letters, 
+	 *			digits,	., /, +, - and _ characters.
+	 *			<p>
+	 *			Parameter names starting and ending with
+	 *			a double underscore are not permitted.
+	 *			eg: <code>__myparam__</code> is illegal.
+	 *
+	 * @return		the number of parameters actually set.
+	 *			Illegal parameters will not be set, but
+	 *			no error/exception will be thrown.
+	 */
+	public int setParams(Hashtable params) 
+	{
+		if(params == null || params.isEmpty())
+			return 0;
+		int count=0;
+		for(Enumeration e = params.keys(); e.hasMoreElements();) {
+			Object key = e.nextElement();
+			if(key.getClass().getName().endsWith(".String")) {
+				Object value = params.get(key);
+				try {
+					setParam((String)key, value);
+					count++;
+				} catch (Exception pe) {
+					// key was not a String or Vector
+					// or key was null
+					// don't increment count
+				}
+			}
+		}
+		if(count>0) {
+			dirty=true;
+			Util.debug_print("Now dirty: set params");
+		}
+
+		return count;
+	}
+
+	/**
+	 * Sets a single scalar parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	a String containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public String setParam(String name, String value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (String)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Sets a single Integer parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	an Integer containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public Integer setParam(String name, Integer value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (Integer)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Sets a single int parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	an int containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public int setParam(String name, int value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		return setParam(name, new Integer(value)).intValue();
+	}
+
+	/**
+	 * Sets a single boolean parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	a boolean containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public boolean setParam(String name, boolean value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		return setParam(name, new Boolean(value)).booleanValue();
+	}
+
+	/**
+	 * Sets a single Boolean parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are currently not case sensitive.
+	 * @param value	a Boolean containing the value of this parameter	
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public Boolean setParam(String name, Boolean value)
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (Boolean)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Sets a single list parameter in this template.
+	 *
+	 * @param name	a String containing the name of this parameter.
+	 *		Parameter names are not currently case sensitive.
+	 * @param value	a Vector containing a list of Hashtables of parameters
+	 *
+	 * @return				the value of the parameter set
+	 * @throws IllegalArgumentException 	if the parameter name contains
+	 *					illegal characters
+	 * @throws NullPointerException 	if the parameter name is null
+	 *
+	 * @see #setParams(Hashtable)
+	 */
+	public Vector setParam(String name, Vector value) 
+			throws IllegalArgumentException, NullPointerException
+	{
+		try {
+			return (Vector)setParam(name, (Object)value);
+		} catch(ClassCastException iae) {
+			return null;
+		}
+	}
+
+	/**
+	 * Returns a parameter from this template identified by the given name.
+	 *
+	 * @param name	a String containing the name of the parameter to be 
+	 *		returned.  Parameter names are not currently case
+	 *		sensitive.
+	 *
+	 * @return	the value of the requested parameter.  If the parameter
+	 *		is a scalar, the return value is a String, if the 
+	 *		parameter is a list, the return value is a Vector.
+	 *
+	 * @throws NoSuchElementException	if the parameter does not exist
+	 *					in the template
+	 * @throws NullPointerException		if the parameter name is null
+	 */
+	public Object getParam(String name) 
+			throws NoSuchElementException, NullPointerException
+	{
+		if(name == null)
+			throw new NullPointerException("name cannot be null");
+		if(!params.containsKey(name))
+			throw new NoSuchElementException(name + 
+				" is not a parameter in this template");
+
+		if(case_sensitive)
+			return params.get(name);
+		else
+			return params.get(name.toLowerCase());
+	}
+
+
+	private void parseParam(String key, Object value)
+			throws IllegalStateException
+	{
+		if(key.equals("case_sensitive"))
+		{
+			this.case_sensitive=boolify(value);
+			Util.debug_print("case_sensitive: "+value);
+		}
+		else if(key.equals("strict"))
+		{
+			this.strict=boolify(value);
+			Util.debug_print("strict: "+value);
+		}
+		else if(key.equals("global_vars"))
+		{
+			this.global_vars=boolify(value);
+			Util.debug_print("global_vars: "+value);
+		}
+		else if(key.equals("die_on_bad_params"))
+		{
+			this.die_on_bad_params=boolify(value);
+			Util.debug_print("die_obp: "+value);
+		}
+		else if(key.equals("max_includes"))
+		{
+			this.max_includes=intify(value)+1;
+			Util.debug_print("max_includes: "+value);
+		}
+		else if(key.equals("no_includes"))
+		{
+			this.no_includes=boolify(value);
+			Util.debug_print("no_includes: "+value);
+		}
+		else if(key.equals("search_path_on_include"))
+		{
+			this.search_path_on_include=boolify(value);
+			Util.debug_print("path_includes: "+value);
+		}
+		else if(key.equals("loop_context_vars"))
+		{
+			this.loop_context_vars=boolify(value);
+			Util.debug_print("loop_c_v: "+value);
+		}
+		else if(key.equals("debug"))
+		{
+			this.debug=boolify(value);
+			Util.debug=this.debug;
+			Util.debug_print("debug: "+value);
+		}
+		else if(key.equals("filename"))
+		{
+			this.filename = (String)value;
+			Util.debug_print("filename: "+value);
+		}
+		else if(key.equals("scalarref"))
+		{
+			this.scalarref = (String)value;
+			Util.debug_print("scalarref");
+		}
+		else if(key.equals("arrayref"))
+		{
+			this.arrayref = (String [])value;
+			Util.debug_print("arrayref");
+		}
+		else if(key.equals("path"))
+		{
+			if(value.getClass().getName().startsWith("["))
+				this.path = (String [])value;
+			else {
+				this.path = new String[1];
+				this.path[0] = (String)value;
+			}
+			Util.debug_print("path");
+			for(int j=0; j<this.path.length; j++)
+				Util.debug_print(this.path[j]);
+		}
+		else if(key.equals("filter"))
+		{
+			if(value.getClass().getName().startsWith("["))
+				this.filters = (Filter [])value;
+			else {
+				this.filters = new Filter[1];
+				this.filters[0] = (Filter)value;
+			}
+			Util.debug_print("filters set: " + filters.length);
+		}
+		else if(key.equals("filehandle"))
+		{
+			this.filehandle = (Reader)value;
+			Util.debug_print("filehandle");
+		}
+		else
+		{
+			throw new IllegalArgumentException(
+					(String)key);
+		}
+
+	}
+
+	private void init()
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException
+	{
+		if(this.filename == null && 
+				this.scalarref == null &&
+				this.arrayref == null &&
+				this.filehandle == null)
+			throw new FileNotFoundException("template filename required");
+		
+		Util.debug = this.debug;
+
+		params.put("__template__", "true");
+
+		String [] parser_params = {
+			"case_sensitive", 	stringify(case_sensitive),
+			"strict", 		stringify(strict),
+			"loop_context_vars", 	stringify(loop_context_vars),
+			"global_vars", 		stringify(global_vars)
+		};
+
+		parser = new Parser(parser_params);
+
+		if(this.filename != null)
+			read_file(filename);
+		else if(this.arrayref != null)
+			read_line_array(this.arrayref);
+		else if(this.scalarref != null)
+			read_line(this.scalarref);
+		else if(this.filehandle != null)
+			read_fh(this.filehandle);
+
+		if(!elements.empty())
+			//System.err.println("stack not empty");
+			Vm.debug("stack not empty");
+	}
+
+
+	private Element parseLine(String line, Element e)
+			throws FileNotFoundException,
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+		Vector parts;
+		//do filtering of one line
+		if ((filters != null) && (filters.length > 0)&& (filters[0].format()== Filter.SCALAR)){
+			line = filters[0].parse(line);
+			if ((line == null) || (line.length() == 0)) return e;
+		}
+		parts = parser.parseLine(line);
+		Util.debug_print("Items: " + parts.size());
+
+		for(Enumeration pt = parts.elements(); pt.hasMoreElements();) 
+		{
+			Object o = pt.nextElement();
+			
+			if(o.getClass().getName().endsWith(".String"))
+			{
+				if(((String)o).equals(""))
+					continue;
+
+				e.add((String)o);
+				Util.debug_print("added: " +(String)o);
+				continue;
+			}
+				
+			// if we come here, then it is an element
+
+			Properties p = (Properties)o;
+			String type=p.getProperty("type");
+			Util.debug_print("adding element: " + type);
+
+			if(type.equals("include")) 
+			{
+				if(no_includes)
+					throw new IllegalStateException(
+						"<tmpl_include> not " +
+						"allowed when " +
+						"no_includes in effect"
+					);
+				if(max_includes == 0) {
+					throw new IndexOutOfBoundsException(
+						"include too deep");
+				} else {
+					// come here if positive 
+					// or negative
+					elements.push(e);
+					read_file(p.getProperty("name"));
+				}
+			}
+			else if(type.equals("var"))
+			{
+				String name = p.getProperty("name");
+				String escape = p.getProperty("escape");
+				String def = p.getProperty("default");
+				Util.debug_print("name: " + name);
+				Util.debug_print("escape: " + escape);
+				Util.debug_print("default: " + def);
+				e.add(new Var(name, escape, def));
+			}
+			else if(type.equals("else")) 
+			{
+				Util.debug_print("adding branch");
+				((Conditional)e).addBranch();
+			}
+			else if(p.getProperty("close").equals("true")) 
+			{
+				Util.debug_print("closing tag");
+				if(!type.equals(e.Type()))
+					throw new EmptyStackException();
+
+				e = (Element)elements.pop();
+			} 
+			else
+			{
+				Element t = parser.getElement(p);
+				e.add(t);
+				elements.push(e);
+				e=t;
+			}
+		}
+		return e;
+	}
+
+	private void read_file(String filename)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+		BufferedReader br=openFile(filename);
+
+		String line;
+
+		Element e = null;
+		if(elements.empty())
+			e = __template__;
+		else
+			e = (Element)elements.pop();
+
+		max_includes--;
+		while((line=br.readLine()) != null) {
+			Util.debug_print("Line: " + line);
+			e = parseLine(line+"\n", e);
+		}
+		max_includes++;
+
+		br.close();
+		br=null;
+
+	}
+	
+	private void read_line_array(String [] lines)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+
+		Element e = __template__;
+
+		max_includes--;
+		for(int i=0; i<lines.length; i++) {
+			Util.debug_print(lines[i]);
+			e = parseLine(lines[i], e);
+		}
+		max_includes++;
+	}
+
+	private void read_line(String lines)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+
+		Element e = __template__;
+
+		max_includes--;
+		StringTokenizer st = new StringTokenizer(lines, "\n");
+		while(st.hasMoreTokens()) {
+			String line = st.nextToken();
+			Util.debug_print(line);
+			e = parseLine(line+"\n", e);
+		}
+		max_includes++;
+	}
+
+	private void read_fh(Reader handle)
+			throws FileNotFoundException, 
+				IllegalStateException,
+				IOException, 
+				EmptyStackException
+	{
+		BufferedReader br=new BufferedReader(handle);
+
+		String line;
+
+		Element e = null;
+		if(elements.empty())
+			e = __template__;
+		else
+			e = (Element)elements.pop();
+
+		max_includes--;
+		while((line=br.readLine()) != null) {
+			Util.debug_print("Line: " + line);
+			e = parseLine(line+"\n", e);
+		}
+		max_includes++;
+
+		br.close();
+		br=null;
+
+	}
+	
+	private Object setParam(String name, Object value)
+			throws ClassCastException,
+				NullPointerException, 
+				IllegalArgumentException
+	{
+		if(name==null)
+			throw new NullPointerException(
+					"parameter name cannot be null");
+
+
+		if(!Util.isNameChar(name)) {
+			throw new IllegalArgumentException("parameter name " +
+				"may only contain letters, digits, ., /, +, " +
+				"-, _");
+		}
+
+		if(name.startsWith("__") && name.endsWith("__"))
+			throw new IllegalArgumentException("parameter name " +
+				"may not start and end with a double " +
+				"underscore");
+
+		if(die_on_bad_params && !__template__.contains(name))
+			throw new IllegalArgumentException(name + 
+				"is not a valid template entity");
+
+		if(value==null)
+			value="";
+
+		String type = value.getClass().getName();
+		if(type.indexOf(".") > 0)
+			type = type.substring(type.lastIndexOf(".")+1);
+
+		String valid_types = ",String,Vector,Boolean,Integer,";
+
+		if(valid_types.indexOf(type) < 0)
+			throw new ClassCastException(
+					"value is neither scalar nor list");
+
+		name=case_sensitive?name:name.toLowerCase();
+
+		if(!case_sensitive && type.equals("Vector")) {
+			value = lowerCaseAll((Vector)value);
+		}
+			
+		Util.debug_print("setting: " + name);
+		params.put(name, value);
+
+		dirty=true;
+		return value;
+	}
+
+	private static Vector lowerCaseAll(Vector v)
+	{
+		Vector v2 = new Vector();
+		for(Enumeration e = v.elements(); e.hasMoreElements(); ) {
+			Hashtable h = (Hashtable)e.nextElement();
+			if(h == null) {
+				v2.addElement(h);
+				continue;
+			}
+			Hashtable h2 = new Hashtable();
+			for(Enumeration e2 = h.keys(); e2.hasMoreElements(); ) {
+				String key = (String)e2.nextElement();
+				Object value = h.get(key);
+				String value_type = value.getClass().getName();
+				Util.debug_print("to lower case: " + key + "(" + value_type + ")");
+				if(value_type.endsWith(".Vector"))
+					value = lowerCaseAll((Vector)value);
+				h2.put(key.toLowerCase(), value);
+			}
+			v2.addElement(h2);
+		}
+		return v2;
+	}
+
+	private static boolean boolify(Object o)
+	{
+		String s;
+		if(o.getClass().getName().endsWith(".Boolean"))
+			return ((Boolean)o).booleanValue();
+		else if(o.getClass().getName().endsWith(".String"))
+			s = (String)o;
+		else
+			s = o.toString();
+
+		if(s.equals("0") || s.equals("") || s.equals("false"))
+			return false;
+		return true;
+	}
+
+	private static int intify(Object o)
+	{
+		String s;
+		if(o.getClass().getName().endsWith(".Integer"))
+			return ((Integer)o).intValue();
+		else if(o.getClass().getName().endsWith(".String"))
+			s = (String)o;
+		else
+			s = o.toString();
+
+		try {
+			return Integer.parseInt(s);
+		} catch(NumberFormatException nfe) {
+			return 0;
+		}
+	}
+
+	private static String stringify(boolean b)
+	{
+		if(b)
+			return "1";
+		else
+			return "";
+	}
+	
+	private BufferedReader openFile(String filename)
+			throws FileNotFoundException
+	{
+		boolean add_path=true;
+
+		if(!elements.empty() && !search_path_on_include)
+			add_path=false;
+
+		if(filename.startsWith("/"))
+			add_path=false;
+
+		if(this.path == null)
+			add_path=false;
+
+		Util.debug_print("open " + filename);
+		if(!add_path)
+			return new BufferedReader(new FileReader(filename));
+
+		BufferedReader br=null;
+		
+		for(int i=0; i<this.path.length; i++) {
+			try {
+				Util.debug_print("trying " + this.path[i] +
+						"/" + filename);
+				br = new BufferedReader(
+					new FileReader(
+						this.path[i] + "/" + filename
+					)
+				);
+				break;
+			} catch (FileNotFoundException fnfe) {
+			}
+		}
+
+		if(br == null)
+			throw new FileNotFoundException(filename);
+
+		return br;
+	}
+}


Property changes on: trunk/lib/HTML/Template.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Element/Conditional.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Element/Conditional.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Element/Conditional.java
===================================================================
--- trunk/lib/HTML/Tmpl/Element/Conditional.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Element/Conditional.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,167 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+import ewe.util.Vector;
+import ewe.util.Hashtable;
+import ewe.util.Enumeration;
+import ewe.util.NoSuchElementException;
+
+public class Conditional extends Element
+{
+	private boolean control_val = false;
+	private Vector [] data;
+
+	public Conditional(String type, String name) 
+			throws IllegalArgumentException
+	{
+		if(type.equalsIgnoreCase("if"))
+			this.type="if";
+		else if(type.equalsIgnoreCase("unless"))
+			this.type="unless";
+		else
+			throw new IllegalArgumentException(
+				"Unrecognised type: " + type);
+
+		this.name = name;
+		this.data = new Vector[2];
+		this.data[0] = new Vector();
+	}
+
+	public void addBranch() throws IndexOutOfBoundsException
+	{
+		if(data[1] != null)
+			throw new IndexOutOfBoundsException("Already have two branches");
+
+		if(data[0] == null)
+			data[0] = new Vector();
+		else if(data[1] == null)
+			data[1] = new Vector();
+	}
+
+	public void add(String text)
+	{
+		if(data[1] != null)
+			data[1].addElement(text);
+		else
+			data[0].addElement(text);
+	}
+
+	public void add(Element node)
+	{
+		if(data[1] != null)
+			data[1].addElement(node);
+		else
+			data[0].addElement(node);
+	}
+
+	public void setControlValue(Object control_val)
+			throws IllegalArgumentException
+	{
+		this.control_val = process_var(control_val);
+	}
+
+	public String parse(Hashtable params)
+	{
+		if(!params.containsKey(this.name))
+			this.control_val = false;
+		else	
+			setControlValue(params.get(this.name));
+
+		StringBuffer output = new StringBuffer();
+
+		Enumeration de;
+		if(type.equals("if") && control_val ||
+			type.equals("unless") && !control_val)
+			de = data[0].elements();
+		else if(data[1] != null)
+			de = data[1].elements();
+		else
+			return "";
+
+		while(de.hasMoreElements()) {
+			Object e = de.nextElement();
+			if(e.getClass().getName().endsWith(".String"))
+				output.append((String)e);
+			else
+				output.append(((Element)e).parse(params));
+		}
+
+		return output.toString();
+	}
+
+	public String typeOfParam(String param)
+			throws NoSuchElementException
+	{
+		for(int i=0; i<data.length; i++)
+		{
+			if(data[i] == null)
+				continue;
+			for(Enumeration e = data[i].elements(); 
+				e.hasMoreElements();)
+			{
+				Object o = e.nextElement();
+				if(o.getClass().getName().endsWith(".String"))
+					continue;
+				if(((Element)o).Name().equals(param))
+					return ((Element)o).Type();
+			}
+		}
+		throw new NoSuchElementException(param);
+	}
+
+	private boolean process_var(Object control_val) 
+			throws IllegalArgumentException 
+	{
+		String control_class = "";
+
+		if(control_val == null)
+			return false;
+		
+		control_class=control_val.getClass().getName();
+		if(control_class.indexOf(".") > 0)
+			control_class = control_class.substring(
+					control_class.lastIndexOf(".")+1);
+
+		if(control_class.equals("String")) {
+			return !(((String)control_val).equals("") || 
+				((String)control_val).equals("0"));
+		} else if(control_class.equals("Vector")) {
+			return !((Vector)control_val).isEmpty();
+		} else if(control_class.equals("Boolean")) {
+			return ((Boolean)control_val).booleanValue();
+		} else if(control_class.equals("Integer")) {
+			return (((Integer)control_val).intValue() != 0);
+		} else {
+			throw new IllegalArgumentException("Unrecognised type");
+		}
+	}
+}
+


Property changes on: trunk/lib/HTML/Tmpl/Element/Conditional.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Element/Element.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Element/Element.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Element/Element.java
===================================================================
--- trunk/lib/HTML/Tmpl/Element/Element.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Element/Element.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,66 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+
+package HTML.Tmpl.Element;
+import ewe.util.Hashtable;
+import ewe.util.NoSuchElementException;
+
+public abstract class Element
+{
+	protected String type;
+	protected String name="";
+
+	public abstract String parse(Hashtable params);
+	public abstract String typeOfParam(String param)
+			throws NoSuchElementException;
+
+	public void add(String data){}
+	public void add(Element node){}
+
+	public boolean contains(String param)
+	{
+		try {
+			return (typeOfParam(param) != null?true:false);
+		} catch(NoSuchElementException nse) {
+			return false;
+		}
+	}
+
+	public final String Type()
+	{
+		return type;
+	}
+
+	public final String Name()
+	{
+		return name;
+	}
+}


Property changes on: trunk/lib/HTML/Tmpl/Element/Element.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Element/If.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Element/If.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Element/If.java
===================================================================
--- trunk/lib/HTML/Tmpl/Element/If.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Element/If.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,39 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+
+public class If extends Conditional
+{
+	public If(String control_var) throws IllegalArgumentException
+	{
+		super("if", control_var);
+	}
+}


Property changes on: trunk/lib/HTML/Tmpl/Element/If.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Element/Loop.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Element/Loop.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Element/Loop.java
===================================================================
--- trunk/lib/HTML/Tmpl/Element/Loop.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Element/Loop.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,183 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+import ewe.util.Vector;
+import ewe.util.Hashtable;
+import ewe.util.Enumeration;
+import ewe.util.NoSuchElementException;
+
+public class Loop extends Element
+{
+	private boolean loop_context_vars=false;
+	private boolean global_vars=false;
+
+	private Vector control_val = null;
+	private Vector data;
+
+	public Loop(String name)
+	{
+		this.type = "loop";
+		this.name = name;
+		this.data = new Vector();
+	}
+
+	public Loop(String name, boolean loop_context_vars)
+	{
+		this(name);
+		this.loop_context_vars=loop_context_vars;
+	}
+
+	public Loop(String name, boolean loop_context_vars, boolean global_vars)
+	{
+		this(name);
+		this.loop_context_vars=loop_context_vars;
+		this.global_vars=global_vars;
+	}
+
+	public void add(String text)
+	{
+		data.addElement(text);
+	}
+
+	public void add(Element node)
+	{
+		data.addElement(node);
+	}
+
+	public void setControlValue(Vector control_val)
+			throws IllegalArgumentException
+	{
+		this.control_val = process_var(control_val);
+	}
+
+	public String parse(Hashtable p)
+	{
+		if(!p.containsKey(this.name))
+			this.control_val = null;
+		else {
+			Object o = p.get(this.name);
+			if(!o.getClass().getName().endsWith(".Vector") &&
+					!o.getClass().getName().endsWith(".List"))
+				throw new ClassCastException(
+					"Attempt to set <tmpl_loop> with a non-list.  tmpl_loop=" + this.name);
+			setControlValue((Vector)p.get(this.name));
+		}
+
+		if(control_val == null)
+			return "";
+
+		StringBuffer output = new StringBuffer();
+		Enumeration iterator = control_val.elements();
+
+		boolean first=true;
+		boolean last=false;
+		boolean inner=false;
+		boolean odd=true;
+		int counter=1;
+
+		while(iterator.hasMoreElements()) {
+			Hashtable params = (Hashtable)iterator.nextElement();
+
+			if(params==null)
+				params = new Hashtable();
+
+			if(global_vars) {
+				for(Enumeration e = p.keys(); e.hasMoreElements();) {
+					Object key = e.nextElement();
+					if(!params.containsKey(key))
+						params.put(key, p.get(key));
+				}
+			}
+
+			if(loop_context_vars) {
+				if(!iterator.hasMoreElements())
+					last=true;
+				inner = !first && !last;
+
+				params.put("__FIRST__", first?"1":"");
+				params.put("__LAST__", last?"1":"");
+				params.put("__ODD__", odd?"1":"");
+				params.put("__INNER__", inner?"1":"");
+				params.put("__COUNTER__", "" + (counter++));
+			}
+				
+			Enumeration de = data.elements();
+			while(de.hasMoreElements()) {
+
+				Object e = de.nextElement();
+				if(e.getClass().getName().indexOf("String")>-1)
+					output.append((String)e);
+				else
+					output.append(((Element)e).parse(params));
+			}
+			first = false;
+			odd = !odd;
+		}
+
+		return output.toString();
+	}
+
+	public String typeOfParam(String param)
+			throws NoSuchElementException
+	{
+		for(Enumeration e = data.elements(); e.hasMoreElements();)
+		{
+			Object o = e.nextElement();
+			if(o.getClass().getName().endsWith(".String"))
+				continue;
+			if(((Element)o).Name().equals(param))
+				return ((Element)o).Type();
+		}
+		throw new NoSuchElementException(param);
+	}
+
+	private Vector process_var(Vector control_val) 
+			throws IllegalArgumentException 
+	{
+		String control_class = "";
+
+		if(control_val == null)
+			return null;
+		
+		control_class=control_val.getClass().getName();
+
+		if(control_class.indexOf("Vector") > -1) {
+			if(control_val.isEmpty())
+				return null;
+		} else {
+			throw new IllegalArgumentException("Unrecognised type");
+		}
+
+		return control_val;
+	}
+
+}
+


Property changes on: trunk/lib/HTML/Tmpl/Element/Loop.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Element/Unless.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Element/Unless.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Element/Unless.java
===================================================================
--- trunk/lib/HTML/Tmpl/Element/Unless.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Element/Unless.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,39 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+
+public class Unless extends Conditional
+{
+	public Unless(String control_var) throws IllegalArgumentException
+	{
+		super("unless", control_var);
+	}
+}


Property changes on: trunk/lib/HTML/Tmpl/Element/Unless.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Element/Var.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Element/Var.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Element/Var.java
===================================================================
--- trunk/lib/HTML/Tmpl/Element/Var.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Element/Var.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,137 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+package HTML.Tmpl.Element;
+import ewe.util.Hashtable;
+import ewe.util.NoSuchElementException;
+import HTML.Tmpl.Util;
+
+public class Var extends Element
+{
+	public static final int ESCAPE_NONE  = 0;
+	public static final int ESCAPE_URL   = 1;
+	public static final int ESCAPE_HTML  = 2;
+	public static final int ESCAPE_QUOTE = 4;
+	
+	public Var(String name, int escape, Object default_value)
+			throws IllegalArgumentException
+	{
+		this(name, escape);
+		this.default_value = stringify(default_value);
+	}
+
+	public Var(String name, int escape) 
+			throws IllegalArgumentException
+	{
+		if(name == null)
+			throw new IllegalArgumentException("tmpl_var must have a name");
+		this.type = "var";
+		this.name = name;
+		this.escape = escape;
+	}
+
+	public Var(String name, String escape)
+			throws IllegalArgumentException
+	{
+		this(name, escape, null);
+	}
+
+	public Var(String name, String escape, Object default_value) 
+			throws IllegalArgumentException
+	{
+		this(name, ESCAPE_NONE, default_value);
+
+		if(escape.equalsIgnoreCase("html"))
+			this.escape = ESCAPE_HTML;
+		else if(escape.equalsIgnoreCase("url"))
+			this.escape = ESCAPE_URL;
+		else if(escape.equalsIgnoreCase("quote"))
+			this.escape = ESCAPE_QUOTE;
+	}
+
+	public Var(String name, boolean escape) 
+			throws IllegalArgumentException
+	{
+		this(name, escape?ESCAPE_HTML:ESCAPE_NONE);
+	}
+
+	public String parse(Hashtable params)
+	{
+		String value = null;
+
+		if(params.containsKey(this.name))
+			value = stringify(params.get(this.name));
+		else
+			value = this.default_value;
+
+		if(value == null)
+			return "";
+
+		if(this.escape == ESCAPE_HTML)
+			return Util.escapeHTML(value);
+		else if(this.escape == ESCAPE_URL)
+			return Util.escapeURL(value);
+		else if(this.escape == ESCAPE_QUOTE)
+			return Util.escapeQuote(value);
+		else
+			return value;
+	}
+
+	public String typeOfParam(String param)
+			throws NoSuchElementException
+	{
+		throw new NoSuchElementException(param);
+	}
+
+	private String stringify(Object o)
+	{
+		if(o == null)
+			return null;
+
+		String cname = o.getClass().getName();
+		if(cname.endsWith(".String"))
+			return (String)o;
+		else if(cname.endsWith(".Integer"))
+			return ((Integer)o).toString();
+		else if(cname.endsWith(".Boolean"))
+			return ((Boolean)o).toString();
+		else if(cname.endsWith(".Date"))
+			return ((ewe.sys.Date)o).toString();
+		else if(cname.endsWith(".Vector"))
+			throw new ClassCastException("Attempt to set <tmpl_var> with a non-scalar. Var name=" + this.name);
+		else
+			throw new ClassCastException("Unknown object type: " + cname);
+	}
+
+	// Private data starts here
+	private int escape=ESCAPE_NONE;
+	private String default_value=null;
+
+}


Property changes on: trunk/lib/HTML/Tmpl/Element/Var.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Filter.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Filter.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Filter.java
===================================================================
--- trunk/lib/HTML/Tmpl/Filter.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Filter.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,145 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+
+package HTML.Tmpl;
+
+/**
+ * Pre-parse filters for HTML.Template templates.
+ * <p>
+ * The HTML.Tmpl.Filter interface allows you to write Filters
+ * for your templates.  The filter is called after the template
+ * is read and before it is parsed.
+ * <p>
+ * You can use a filter to make changes in the template file before
+ * it is parsed by HTML.Template, so for example, use it to replace
+ * constants, or to translate your own tags to HTML.Template tags.
+ * <p>
+ * A common usage would be to do what you think you're doing when you
+ * do <code>&lt;TMPL_INCLUDE file="&lt;TMPL_VAR name="the_file"&gt;"&gt;</code>:
+ * <p>
+ * myTemplate.tmpl:
+ * <pre>
+ *	&lt;TMPL_INCLUDE file="&lt;%the_file%&gt;"&gt;
+ * </pre>
+ * <p>
+ * myFilter.java:
+ * <pre>
+ *	class myFilter implements HTML.Tmpl.Filter
+ *	{
+ *		private String myFile;
+ *		private int type=SCALAR
+ *
+ *		public myFilter(String myFile) {
+ *			this.myFile = myFile;
+ *		}
+ *
+ *		public int format() {
+ *			return this.type;
+ *		}
+ *
+ *		public String parse(String t) {
+ *			// replace all &lt;%the_file%&gt; with myFile
+ *			return t;
+ *		}
+ *
+ *		public String [] parse(String [] t) {
+ *			throw new UnsupportedOperationException();
+ *		}
+ *	}
+ * </pre>
+ * <p>
+ * myClass.java:
+ * <pre>
+ *	Hashtable params = new Hashtable();
+ *	params.put("filename", "myTemplate.tmpl");
+ *	params.put("filter", new myFilter("myFile.tmpl"));
+ *	Template t = new Template(params);
+ * </pre>
+ *
+ * @author	Philip S Tellis
+ * @version	0.0.1
+ */
+public interface Filter
+{
+	/**
+	 * Tells HTML.Template to call the parse(String) method of this filter.
+	 */
+	public final static int SCALAR=1;
+
+	/**
+	 * Tells HTML.Template to call the parse(String []) method of this 
+	 * filter.
+	 */
+	public final static int ARRAY=2;
+
+	/**
+	 * Tells HTML.Template what kind of filter this is.
+	 * Should return either SCALAR or ARRAY to indicate which parse method
+	 * must be called.
+	 *
+	 * @return	the values SCALAR or ARRAY indicating which parse method
+	 *		is to be called
+	 */
+	public int format();
+
+	/**
+	 * parses the template as a single string, and returns the parsed 
+	 * template as a single string.
+	 * <p>
+	 * Should throw an UnsupportedOperationException if it isn't implemented
+	 *
+	 * @param t	a string containing the entire template
+	 *
+	 * @return	a string containing the template after you've parsed it
+	 *
+	 * @throws UnsupportedOperationException	if this method isn't 
+	 *						implemented
+	 */
+	public String parse(String t);
+
+	/**
+	 * parses the template as an array of strings, and returns the parsed 
+	 * template as an array of strings.
+	 * <p>
+	 * Should throw an UnsupportedOperationException if it isn't implemented
+	 *
+	 * @param t	an array of strings containing the template - one line 
+	 *		at a time
+	 *
+	 * @return	an array of strings containing the parsed template - 
+	 *		one line at a time
+	 *
+	 * @throws UnsupportedOperationException	if this method isn't 
+	 *						implemented
+	 */
+	public String [] parse(String [] t);
+}
+


Property changes on: trunk/lib/HTML/Tmpl/Filter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Parsers/Parser.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Parsers/Parser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Parsers/Parser.java
===================================================================
--- trunk/lib/HTML/Tmpl/Parsers/Parser.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Parsers/Parser.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,387 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+
+package HTML.Tmpl.Parsers;
+import ewe.util.*;
+import HTML.Tmpl.Element.*;
+import HTML.Tmpl.Util;
+
+public class Parser
+{
+	private boolean case_sensitive=false;
+	private boolean strict=true;
+	private boolean loop_context_vars=false;
+	private boolean global_vars=false;
+
+	public Parser()
+	{
+	}
+
+	public Parser(String [] args)
+			throws ArrayIndexOutOfBoundsException,
+				IllegalArgumentException
+	{
+		if(args.length%2 != 0)
+			throw new ArrayIndexOutOfBoundsException("odd number of arguments passed");
+
+		for(int i=0; i<args.length; i+=2) {
+			if(args[i].equals("case_sensitive")) {
+				String cs = args[i+1];
+				if(cs.equals("") || cs.equals("0"))
+					this.case_sensitive=false;
+				else
+					this.case_sensitive=true;
+			} else if(args[i].equals("strict")) {
+				String s = args[i+1];
+				if(s.equals("") || s.equals("0"))
+					this.strict=false;
+				else
+					this.strict=true;
+			} else if(args[i].equals("loop_context_vars")) {
+				String s = args[i+1];
+				if(s.equals("") || s.equals("0"))
+					this.loop_context_vars=false;
+				else
+					this.loop_context_vars=true;
+
+			} else if(args[i].equals("global_vars")) {
+				String s = args[i+1];
+				if(s.equals("") || s.equals("0"))
+					this.global_vars=false;
+				else
+					this.global_vars=true;
+			} else {
+				throw new IllegalArgumentException(args[i]);
+			}
+		}
+	}
+
+	public Element getElement(Properties p)
+			throws NoSuchElementException
+	{
+		String type = p.getProperty("type");
+
+		if(type.equals("if"))
+			return new If(p.getProperty("name"));
+		else if(type.equals("unless"))
+			return new Unless(p.getProperty("name"));
+		else if(type.equals("loop"))
+			return new Loop(p.getProperty("name"), 
+						loop_context_vars, global_vars);
+		else
+			throw new NoSuchElementException(type);
+	}
+
+	public Vector parseLine(String line)
+			throws IllegalArgumentException
+	{
+		//int pos=0, endpos;
+		Vector parts = new Vector();
+
+		char [] c = line.toCharArray();
+		int i=0;
+
+		StringBuffer temp = new StringBuffer();
+
+		for(i=0; i<c.length; i++) {
+			if(c[i] != '<') {
+				temp.append(c[i]);
+			} else {
+				// found a tag
+				Util.debug_print("line so far: " + temp);
+				StringBuffer tag = new StringBuffer();
+				for(; i<c.length && c[i] != '>';  i++) {
+					tag.append(c[i]);
+				}
+				// > is not allowed inside a template tag
+				// so we can be sure that if this is a 
+				// template tag, it ends with a >
+
+				// add the closing > as well
+				if(i<c.length)
+					tag.append(c[i]);
+
+				// if this contains more < inside it,
+				// then it could possibly be a template
+				// tag inside a html tag
+				// so remove external tag parts
+
+				while(tag.toString().substring(1).indexOf("<") 
+						> -1)
+				{
+					do {
+						temp.append(tag.charAt(0));
+						tag=new StringBuffer(
+							tag.toString().substring(1));
+					} while(tag.charAt(0) != '<');
+				}
+
+				Util.debug_print("tag: " + tag);
+
+				String test_tag = tag.toString().toLowerCase();
+				// if it doesn't contain tmpl_ it is not
+				// a template tag
+				if(test_tag.indexOf("tmpl_") < 0) {
+					String dummy = new String();
+					dummy = tag.toString();
+					temp.append(dummy);
+					continue;
+				}
+
+				// may be a template tag
+				// check if it starts with tmpl_
+				
+				test_tag = cleanTag(test_tag);
+
+				Util.debug_print("clean: " + test_tag);
+
+				// check if it is a closing tag
+				if(test_tag.startsWith("/"))
+					test_tag = test_tag.substring(1);
+
+				// if it still doesn't start with tmpl_
+				// then it is not a template tag
+				if(!test_tag.startsWith("tmpl_")) {
+					temp.append(tag);
+					continue;
+				}
+
+				// now it must be a template tag
+				String tag_type=getTagType(test_tag);
+
+				if(tag_type == null) {
+					if(strict)
+						throw new 
+						IllegalArgumentException(
+							tag.toString());
+					else
+						temp.append(tag);
+				}
+
+				Util.debug_print("type: " + tag_type);
+
+				// if this was an invalid key and we've
+				// reached so far, then next iteration
+				if(tag_type == null)
+					continue;
+				
+				// now, push the previous stuff
+				// into the Vector
+				if(temp.length()>0) {
+					parts.addElement(temp.toString());
+					temp = new StringBuffer();
+				}
+
+				// it is a valid template tag
+				// get its properties
+
+				Util.debug_print("Checking: " + tag);
+				Properties tag_props = 
+					getTagProps(tag.toString());
+
+				if(tag_props.containsKey("name"))
+					Util.debug_print("name: " + 
+						tag_props.getProperty("name"));
+				else
+					Util.debug_print("no name");
+
+				parts.addElement(tag_props);
+			}
+		}
+
+		if(temp.length()>0)
+			parts.addElement(temp.toString());
+
+		return parts;
+	}
+
+	private String cleanTag(String tag)
+			throws IllegalArgumentException
+	{
+		String test_tag = new String(tag);
+		// first remove < and >
+		if(test_tag.startsWith("<"))
+			test_tag = test_tag.substring(1);
+		if(test_tag.endsWith(">"))
+			test_tag = test_tag.substring(0, test_tag.length()-1);
+		else
+			throw new IllegalArgumentException("Tags must start " +
+					"and end on the same line");
+
+		// remove any leading !-- and trailing
+		// -- in case of comment style tags
+		if(test_tag.startsWith("!--")) {
+			test_tag=test_tag.substring(3);
+		}
+		if(test_tag.endsWith("--")) {
+			test_tag=test_tag.substring(0, test_tag.length()-2);
+		}
+		// then leading and trailing spaces
+		test_tag = test_tag.trim();
+
+		return test_tag;
+	}
+
+	private String getTagType(String tag)
+	{
+		int sp = tag.indexOf(" ");
+		String tag_type="";
+		if(sp < 0) {
+			tag_type = tag.toLowerCase();
+		} else {
+			tag_type = tag.substring(0, sp).toLowerCase();
+		}
+		if(tag_type.startsWith("tmpl_"))
+			tag_type=tag_type.substring(5);
+
+		Util.debug_print("tag_type: " + tag_type);
+
+		if(tag_type.equals("var") ||
+				tag_type.equals("if") ||
+				tag_type.equals("unless") ||
+				tag_type.equals("loop") ||
+				tag_type.equals("include") ||
+				tag_type.equals("else")) {
+			return tag_type;
+		} else {
+			return null;
+		}
+	}
+
+	private Properties getTagProps(String tag)
+			throws IllegalArgumentException,
+				NullPointerException
+	{
+		Properties p = new Properties();
+
+		tag = cleanTag(tag);
+
+		Util.debug_print("clean: " + tag);
+		
+		if(tag.startsWith("/")) {
+			p.put("close", "true");
+			tag=tag.substring(1);
+		} else {
+			p.put("close", "");
+		}
+
+		Util.debug_print("close: " + p.getProperty("close"));
+		
+		p.put("type", getTagType(tag));
+
+		Util.debug_print("type: " + p.getProperty("type"));
+
+		if(p.getProperty("type").equals("else") ||
+				p.getProperty("close").equals("true"))
+			return p;
+
+		if(p.getProperty("type").equals("var"))
+			p.put("escape", "");
+
+		int sp = tag.indexOf(" ");
+		// if we've got so far, this must succeed
+
+		tag = tag.substring(sp).trim();
+		Util.debug_print("checking params: " + tag);
+
+		// now, we should have either name=value pairs
+		// or name space escape in case of old style vars
+
+		if(tag.indexOf("=") < 0) {
+			// no = means old style
+			// first will be var name
+			// second if any will be escape
+
+			sp = tag.toLowerCase().indexOf(" escape");
+			if(sp < 0) {
+				// no escape
+				p.put("name", tag);
+				p.put("escape", "0");
+			} else {
+				tag = tag.substring(0, sp);
+				p.put("name", tag);
+				p.put("escape", "html");
+			}
+		} else {
+			// = means name=value pairs.
+			// use a StringTokenizer
+			StringTokenizer st = new StringTokenizer(tag, " =");
+			while(st.hasMoreTokens()) {
+				String key, value;
+				key = st.nextToken().toLowerCase();
+				if(st.hasMoreTokens())
+					value = st.nextToken();
+				else if(key.equals("escape"))
+					value = "html";
+				else
+					throw new NullPointerException(
+						"parameter " + key + " has no value");
+
+				if(value.startsWith("\"") && 
+						value.endsWith("\""))
+					value = value.substring(1,
+							value.length()-1);
+				else if(value.startsWith("'") && 
+						value.endsWith("'"))
+					value = value.substring(1,
+							value.length()-1);
+
+				if(value.length()==0)
+					throw new NullPointerException(
+						"parameter " + key + " has no value");
+
+				if(key.equals("escape"))
+					value=value.toLowerCase();
+
+				p.put(key, value);
+			}
+		}
+
+		String name = p.getProperty("name");
+		// if not case sensitive, and not special variable, flatten case
+		// never flatten case for includes
+		if(!case_sensitive && !p.getProperty("type").equals("include")
+			&& !( name.startsWith("__") && name.endsWith("__") ))
+		{
+			p.put("name", name.toLowerCase());
+		}
+
+		if(!Util.isNameChar(name))
+			throw new IllegalArgumentException(
+				"parameter name may only contain " +
+				"letters, digits, ., /, +, -, _");
+		// __var__ is allowed in the template, but not in the
+		// code.  this is so that people can reference __FIRST__,
+		// etc
+
+		return p;
+	}
+}


Property changes on: trunk/lib/HTML/Tmpl/Parsers/Parser.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/HTML/Tmpl/Util.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/HTML/Tmpl/Util.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/HTML/Tmpl/Util.java
===================================================================
--- trunk/lib/HTML/Tmpl/Util.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/HTML/Tmpl/Util.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,132 @@
+/*
+*      HTML.Template:  A module for using HTML Templates with java
+*
+*      Copyright (c) 2002 Philip S Tellis (philip.tellis at iname.com)
+*
+*      This module is free software; you can redistribute it
+*      and/or modify it under the terms of either:
+*
+*      a) the GNU General Public License as published by the Free
+*      Software Foundation; either version 1, or (at your option)
+*      any later version, or
+*
+*      b) the "Artistic License" which comes with this module.
+*
+*      This program is distributed in the hope that it will be
+*      useful, but WITHOUT ANY WARRANTY; without even the implied
+*      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+*      PURPOSE.  See either the GNU General Public License or the
+*      Artistic License for more details.
+*
+*      You should have received a copy of the Artistic License
+*      with this module, in the file ARTISTIC.  If not, I'll be
+*      glad to provide one.
+*
+*      You should have received a copy of the GNU General Public
+*      License along with this program; if not, write to the Free
+*      Software Foundation, Inc., 59 Temple Place, Suite 330,
+*      Boston, MA 02111-1307 USA
+*/
+
+
+package HTML.Tmpl;
+import ewe.sys.*;
+
+public class Util
+{
+	public static boolean debug=false;
+
+	public static String escapeHTML(String element)
+	{
+		String s = new String(element);	// don't change the original
+		String [] metas = {"&", "<", ">", "\""};
+		String [] repls = {"&amp;", "&lt;", "&gt;", "&quot;"};
+		for(int i = 0; i < metas.length; i++) {
+			int pos=0;
+			do {
+				pos = s.indexOf(metas[i], pos);
+				if(pos<0)
+					break;
+
+				s = s.substring(0, pos) + repls[i] + s.substring(pos+1);
+				pos++;
+			} while(pos >= 0);
+		}
+
+		return s;
+	}
+
+	public static String escapeURL(String url)
+	{
+		StringBuffer s = new StringBuffer();
+		String no_escape = "./-_";
+
+		for(int i=0; i<url.length(); i++)
+		{
+			char c = url.charAt(i);
+			if(!Character.isLetterOrDigit(c) &&
+					no_escape.indexOf(c)<0) 
+			{
+				String h = Integer.toHexString((int)c);
+				s.append("%");
+				if(h.length()<2)
+					s.append("0");
+				s.append(h);
+			} else {
+				s.append(c);
+			}
+		}
+
+		return s.toString();
+	}
+
+	public static String escapeQuote(String element)
+	{
+		String s = new String(element);	// don't change the original
+		String [] metas = {"\"", "'"};
+		String [] repls = {"\\\"", "\\'"};
+		for(int i = 0; i < metas.length; i++) {
+			int pos=0;
+			do {
+				pos = s.indexOf(metas[i], pos);
+				if(pos<0)
+					break;
+
+				s = s.substring(0, pos) + repls[i] + s.substring(pos+1);
+				pos++;
+			} while(pos >= 0);
+		}
+
+		return s;
+	}
+
+	public static boolean isNameChar(char c)
+	{
+		return true;
+	}
+
+	public static boolean isNameChar(String s)
+	{
+		String alt_valid = "./+-_";
+
+		for(int i=0; i<s.length(); i++)
+			if(!Character.isLetterOrDigit(s.charAt(i)) &&
+					alt_valid.indexOf(s.charAt(i))<0)
+				return false;
+		return true;
+	}
+
+	public static void debug_print(String msg)
+	{
+		if(!debug)
+			return;
+
+		//System.err.println(msg);
+		Vm.debug(msg);
+	}
+
+	public static void debug_print(Object o)
+	{
+		debug_print(o.toString());
+	}
+}


Property changes on: trunk/lib/HTML/Tmpl/Util.java
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: trunk/lib/HTML.zip
===================================================================
(Binary files differ)

Added: trunk/lib/com/bbn/openmap/LatLonPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/LatLonPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/LatLonPoint.java
===================================================================
--- trunk/lib/com/bbn/openmap/LatLonPoint.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/LatLonPoint.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,422 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/LatLonPoint.java,v $
+// $RCSfile: LatLonPoint.java,v $
+// $Revision: 1.2.2.2 $
+// $Date: 2004/10/14 18:26:37 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap;
+
+
+import com.bbn.openmap.proj.GreatCircle;
+import com.bbn.openmap.proj.ProjMath;
+import com.bbn.openmap.util.Assert;
+
+/**
+ * Encapsulates latitude and longitude coordinates in decimal degrees.
+ * Normalizes the internal representation of latitude and longitude.
+ * <p>
+ * <strong>Normalized Latitude: </strong> <br>
+ * &minus;90&deg; &lt;= &phi; &lt;= 90&deg;
+ * <p>
+ * <strong>Normalized Longitude: </strong> <br>
+ * &minus;180&deg; &le; &lambda; &le; 180&deg;
+ */
+public class LatLonPoint implements Cloneable {
+    // SOUTH_POLE <= phi <= NORTH_POLE
+    // -DATELINE <= lambda <= DATELINE
+    public final static float NORTH_POLE = 90.0f;
+    public final static float SOUTH_POLE = -NORTH_POLE;
+    public final static float DATELINE = 180.0f;
+    public final static float LON_RANGE = 360.0f;
+    // initialize to something sane
+    protected float lat_ = 0.0f;
+    protected float lon_ = 0.0f;
+
+    public final static float EQUIVALENT_TOLERANCE = 0.00001f;
+
+    /**
+     * Construct a default LatLonPoint.
+     */
+    public LatLonPoint() {}
+
+    /**
+     * Construct a LatLonPoint from raw float lat/lon in decimal
+     * degrees.
+     * 
+     * @param lat latitude in decimal degrees
+     * @param lon longitude in decimal degrees
+     */
+    public LatLonPoint(float lat, float lon) {
+        setLatLon(lat, lon);
+    }
+
+    /**
+     * Construct a LatLonPoint from raw float lat/lon in radians.
+     * 
+     * @param lat latitude in radians
+     * @param lon longitude in radians
+     * @param isRadian placeholder indicates radians
+     */
+    public LatLonPoint(float lat, float lon, boolean isRadian) {
+        setLatLon(lat, lon, isRadian);
+    }
+
+    /**
+     * Copy construct a LatLonPoint.
+     * 
+     * @param pt LatLonPoint
+     */
+    public LatLonPoint(LatLonPoint pt) {
+        lat_ = pt.lat_;
+        lon_ = pt.lon_;
+        radlat_ = pt.radlat_;
+        radlon_ = pt.radlon_;
+    }
+
+    /**
+     * Construct a LatLonPoint from raw double lat/lon.
+     * 
+     * @param lat latitude in decimal degrees
+     * @param lon longitude in decimal degrees
+     */
+    public LatLonPoint(double lat, double lon) {
+        this((float) lat, (float) lon);
+    }
+
+    /*
+     * uncomment to see how many are being used and thrown away...
+     * protected void finalize() { Debug.output("finalized " + this); }
+     */
+
+    /**
+     * Returns a string representation of the object.
+     * 
+     * @return String representation
+     */
+    public String toString() {
+        return "LatLonPoint[lat=" + lat_ + ",lon=" + lon_ + "]";
+    }
+
+    /**
+     * Clone the LatLonPoint.
+     * 
+     * @return clone
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            Assert.assertExp(false, "LatLonPoint: internal error!");
+            return null; // statement not reached
+        }
+    }
+
+    /**
+     * Set latitude.
+     * 
+     * @param lat latitude in decimal degrees
+     */
+    public void setLatitude(float lat) {
+        lat_ = normalize_latitude(lat);
+        radlat_ = ProjMath.degToRad(lat_);
+    }
+
+    /**
+     * Set longitude.
+     * 
+     * @param lon longitude in decimal degrees
+     */
+    public void setLongitude(float lon) {
+        lon_ = wrap_longitude(lon);
+        radlon_ = ProjMath.degToRad(lon_);
+    }
+
+    /**
+     * Set latitude and longitude.
+     * 
+     * @param lat latitude in decimal degrees
+     * @param lon longitude in decimal degrees
+     */
+    public void setLatLon(float lat, float lon) {
+        lat_ = normalize_latitude(lat);
+        lon_ = wrap_longitude(lon);
+        radlat_ = ProjMath.degToRad(lat_);
+        radlon_ = ProjMath.degToRad(lon_);
+    }
+
+    /**
+     * Set latitude and longitude.
+     * 
+     * @param lat latitude in radians
+     * @param lon longitude in radians
+     * @param isRadian placeholder indicates radians
+     */
+    public void setLatLon(float lat, float lon, boolean isRadian) {
+        if (isRadian) {
+            radlat_ = lat;
+            radlon_ = lon;
+            lat_ = normalize_latitude(ProjMath.radToDeg(radlat_));
+            lon_ = wrap_longitude(ProjMath.radToDeg(radlon_));
+        } else {
+            setLatLon(lat, lon);
+        }
+    }
+
+    /**
+     * Set LatLonPoint.
+     * 
+     * @param llpt LatLonPoint
+     */
+    public void setLatLon(LatLonPoint llpt) {
+        lat_ = llpt.lat_;
+        lon_ = llpt.lon_;
+        radlat_ = llpt.radlat_;
+        radlon_ = llpt.radlon_;
+    }
+
+    /**
+     * Get normalized latitude.
+     * 
+     * @return float latitude in decimal degrees (&minus;90&deg; &le;
+     *         &phi; &le; 90&deg;)
+     */
+    public float getLatitude() {
+        return lat_;
+    }
+
+    /**
+     * Get wrapped longitude.
+     * 
+     * @return float longitude in decimal degrees (&minus;180&deg;
+     *         &le; &lambda; &le; 180&deg;)
+     */
+    public float getLongitude() {
+        return lon_;
+    }
+
+    /**
+     * Determines whether two LatLonPoints are equal.
+     * 
+     * @param obj Object
+     * @return Whether the two points are equal up to a tolerance of
+     *         10 <sup>-5 </sup> degrees in latitude and longitude.
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof LatLonPoint) {
+            LatLonPoint pt = (LatLonPoint) obj;
+            return (MoreMath.approximately_equal(lat_,
+                    pt.lat_,
+                    EQUIVALENT_TOLERANCE) && MoreMath.approximately_equal(lon_,
+                    pt.lon_,
+                    EQUIVALENT_TOLERANCE));
+        }
+        return false;
+    }
+
+    /**
+     * Hash the lat/lon value.
+     * <p>
+     * 
+     * @return int hash value
+     */
+    public int hashCode() {
+        return ProjMath.hashLatLon(lat_, lon_);
+    }
+
+    /**
+     * Write object.
+     * 
+     * @param s DataOutputStream
+     */
+/*
+    public void write(DataOutputStream s) throws IOException {
+        // Write my information
+        s.writeFloat(lat_);
+        s.writeFloat(lon_);
+    }
+*/
+    /**
+     * Read object. Assumes that the floats read off the stream will
+     * be in decimal degrees. Latitude read off the stream first, then
+     * longitude.
+     * 
+     * @param s DataInputStream
+     */
+/*
+    public void read(DataInputStream s) throws IOException {
+        setLatLon(s.readFloat(), s.readFloat());
+    }
+*/
+    /**
+     * Read object. Latitude read off the stream first, then
+     * longitude.
+     * 
+     * @param s DataInputStream
+     * @param inRadians if true, the floats read off stream will be
+     *        considered to be radians. Otherwise, they will be
+     *        considered to be decimal degrees.
+     */
+/*
+    public void read(DataInputStream s, boolean inRadians) throws IOException {
+        if (inRadians) {
+            setLatLon(s.readFloat(), s.readFloat(), inRadians);
+        } else {
+            read(s);
+        }
+    }
+*/
+    /**
+     * Sets latitude to something sane.
+     * 
+     * @param lat latitude in decimal degrees
+     * @return float normalized latitude in decimal degrees
+     *         (&minus;90&deg; &le; &phi; &le; 90&deg;)
+     */
+    final public static float normalize_latitude(float lat) {
+        if (lat > NORTH_POLE) {
+            lat = NORTH_POLE;
+        }
+        if (lat < SOUTH_POLE) {
+            lat = SOUTH_POLE;
+        }
+        return lat;
+    }
+
+    /**
+     * Sets longitude to something sane.
+     * 
+     * @param lon longitude in decimal degrees
+     * @return float wrapped longitude in decimal degrees
+     *         (&minus;180&deg; &le; &lambda; &le; 180&deg;)
+     */
+    final public static float wrap_longitude(float lon) {
+        if ((lon < -DATELINE) || (lon > DATELINE)) {
+            //System.out.print("LatLonPoint: wrapping longitude " +
+            // lon);
+            lon += DATELINE;
+            lon = lon % LON_RANGE;
+            lon = (lon < 0) ? DATELINE + lon : -DATELINE + lon;
+            //Debug.output(" to " + lon);
+        }
+        return lon;
+    }
+
+    /**
+     * Check if latitude is bogus. Latitude is invalid if lat &gt;
+     * 90&deg; or if lat &lt; &minus;90&deg;.
+     * 
+     * @param lat latitude in decimal degrees
+     * @return boolean true if latitude is invalid
+     */
+    public static boolean isInvalidLatitude(float lat) {
+        return ((lat > NORTH_POLE) || (lat < SOUTH_POLE));
+    }
+
+    /**
+     * Check if longitude is bogus. Longitude is invalid if lon &gt;
+     * 180&deg; or if lon &lt; &minus;180&deg;.
+     * 
+     * @param lon longitude in decimal degrees
+     * @return boolean true if longitude is invalid
+     */
+    public static boolean isInvalidLongitude(float lon) {
+        return ((lon < -DATELINE) || (lon > DATELINE));
+    }
+
+    /**
+     * Calculate the <code>radlat_</code> and <code>radlon_</code>
+     * instance variables upon deserialization. Also, check
+     * <code>lat_</code> and <code>lon_</code> for safety; someone
+     * may have tampered with the stream.
+     * 
+     * @param stream Stream to read <code>lat_</code> and
+     *        <code>lon_</code> from.
+     */
+/*    
+    private void readObject(java.io.ObjectInputStream stream)
+            throws IOException, ClassNotFoundException {
+        stream.defaultReadObject();
+        lat_ = normalize_latitude(lat_);
+        lon_ = wrap_longitude(lon_);
+        radlat_ = ProjMath.degToRad(lat_);
+        radlon_ = ProjMath.degToRad(lon_);
+    }
+*/
+    /**
+     * Find a LatLonPoint a distance and direction away from this
+     * point, based on the sphercal earth model.
+     * 
+     * @param dist distance, in radians.
+     * @param az radians of azimuth (direction) east of north (-PI
+     *        &lt;= Az &lt; PI)
+     * @return LatLonPoint result
+     */
+    public LatLonPoint getPoint(float dist, float az) {
+        return GreatCircle.spherical_between(radlat_, radlon_, dist, az);
+    }
+
+    /**
+     * Find the distance to another LatLonPoint, based on a earth
+     * spherical model.
+     * 
+     * @param toPoint LatLonPoint
+     * @return distance, in radians. You can use an
+     *         com.bbn.openmap.proj.Length to convert the radians to
+     *         other units.
+     */
+    public float distance(LatLonPoint toPoint) {
+        return GreatCircle.spherical_distance(radlat_,
+                radlon_,
+                toPoint.radlat_,
+                toPoint.radlon_);
+    }
+
+    /**
+     * Find the azimuth to another point, based on the sphercal earth
+     * model.
+     * 
+     * @param toPoint LatLonPoint
+     * @return the azimuth `Az' east of north from this point bearing
+     *         toward the one provided as an argument.(-PI &lt;= Az
+     *         &lt;= PI).
+     *  
+     */
+    public float azimuth(LatLonPoint toPoint) {
+        return GreatCircle.spherical_azimuth(radlat_,
+                radlon_,
+                toPoint.radlat_,
+                toPoint.radlon_);
+    }
+    /**
+     * Used by the projection code for read-only quick access. This is
+     * meant for quick backdoor access by the projection library.
+     * Modify at your own risk!
+     * 
+     * @see #lat_
+     */
+    public transient float radlat_ = 0.0f;
+    /**
+     * Used by the projection code for read-only quick access. This is
+     * meant for quick backdoor access by the projection library.
+     * Modify at your own risk!
+     * 
+     * @see #lon_
+     */
+    public transient float radlon_ = 0.0f;
+}


Property changes on: trunk/lib/com/bbn/openmap/LatLonPoint.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/MoreMath.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/MoreMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/MoreMath.java
===================================================================
--- trunk/lib/com/bbn/openmap/MoreMath.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/MoreMath.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,547 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/MoreMath.java,v $
+// $RCSfile: MoreMath.java,v $
+// $Revision: 1.3.2.1 $
+// $Date: 2004/10/14 18:26:37 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap;
+
+/**
+ * MoreMath provides functions that are not part of the standard Math
+ * class.
+ * <p>
+ * 
+ * <pre>
+ * 
+ *  Functions:
+ *       asinh(float x) - hyperbolic arcsine
+ *       sinh(float x) - hyperbolic sine
+ * 
+ *  Need to Implement:
+ *  Function                Definition                              
+ *  Hyperbolic cosine       (e&circ;x+e&circ;-x)/2                            
+ *  Hyperbolic tangent      (e&circ;x-e&circ;-x)/(e&circ;x+e&circ;-x)                   
+ *  Hyperbolic arc cosine   2 log  (sqrt((x+1)/2) + sqrt((x-1)/2))  
+ *  Hyperbolic arc tangent  (log  (1+x) - log (1-x))/2
+ *  
+ * </pre>
+ */
+public class MoreMath {
+
+    /**
+     * 2*Math.PI
+     */
+    final public static transient float TWO_PI = (float) Math.PI * 2.0f;
+
+    /**
+     * 2*Math.PI
+     */
+    final public static transient double TWO_PI_D = Math.PI * 2.0d;
+
+    /**
+     * Math.PI/2
+     */
+    final public static transient float HALF_PI = (float) Math.PI / 2.0f;
+
+    /**
+     * Math.PI/2
+     */
+    final public static transient double HALF_PI_D = Math.PI / 2.0d;
+
+    // cannot construct
+    private MoreMath() {}
+
+    /**
+     * Checks if a ~= b. Use this to test equality of floating point
+     * numbers.
+     * <p>
+     * 
+     * @param a double
+     * @param b double
+     * @param epsilon the allowable error
+     * @return boolean
+     */
+    final public static boolean approximately_equal(double a, double b,
+                                                    double epsilon) {
+        return (Math.abs(a - b) <= epsilon);
+    }
+
+    /**
+     * Checks if a ~= b. Use this to test equality of floating point
+     * numbers.
+     * <p>
+     * 
+     * @param a float
+     * @param b float
+     * @param epsilon the allowable error
+     * @return boolean
+     */
+    final public static boolean approximately_equal(float a, float b,
+                                                    float epsilon) {
+        return (Math.abs(a - b) <= epsilon);
+    }
+
+    /**
+     * Hyperbolic arcsin.
+     * <p>
+     * Hyperbolic arc sine: log (x+sqrt(1+x^2))
+     * 
+     * @param x float
+     * @return float asinh(x)
+     */
+    public static final float asinh(float x) {
+        return (float) Math.log(x + Math.sqrt(x * x + 1));
+    }
+
+    /**
+     * Hyperbolic arcsin.
+     * <p>
+     * Hyperbolic arc sine: log (x+sqrt(1+x^2))
+     * 
+     * @param x double
+     * @return double asinh(x)
+     */
+    public static final double asinh(double x) {
+        return (double) Math.log(x + Math.sqrt(x * x + 1));
+    }
+
+    /**
+     * Hyperbolic sin.
+     * <p>
+     * Hyperbolic sine: (e^x-e^-x)/2
+     * 
+     * @param x float
+     * @return float sinh(x)
+     */
+    public static final float sinh(float x) {
+        return (float) (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2.0f;
+    }
+
+    /**
+     * Hyperbolic sin.
+     * <p>
+     * Hyperbolic sine: (e^x-e^-x)/2
+     * 
+     * @param x double
+     * @return double sinh(x)
+     */
+    public static final double sinh(double x) {
+        return (double) (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2.0d;
+    }
+
+    // HACK - are there functions that already exist?
+    /**
+     * Return sign of number.
+     * 
+     * @param x short
+     * @return int sign -1, 1
+     */
+    public static final int sign(short x) {
+        return (x < 0) ? -1 : 1;
+    }
+
+    /**
+     * Return sign of number.
+     * 
+     * @param x int
+     * @return int sign -1, 1
+     */
+    public static final int sign(int x) {
+        return (x < 0) ? -1 : 1;
+    }
+
+    /**
+     * Return sign of number.
+     * 
+     * @param x long
+     * @return int sign -1, 1
+     */
+    public static final int sign(long x) {
+        return (x < 0) ? -1 : 1;
+    }
+
+    /**
+     * Return sign of number.
+     * 
+     * @param x float
+     * @return int sign -1, 1
+     */
+    public static final int sign(float x) {
+        return (x < 0f) ? -1 : 1;
+    }
+
+    /**
+     * Return sign of number.
+     * 
+     * @param x double
+     * @return int sign -1, 1
+     */
+    public static final int sign(double x) {
+        return (x < 0d) ? -1 : 1;
+    }
+
+    /**
+     * Check if number is odd.
+     * 
+     * @param x short
+     * @return boolean
+     */
+    public static final boolean odd(short x) {
+        return !even(x);
+    }
+
+    /**
+     * Check if number is odd.
+     * 
+     * @param x int
+     * @return boolean
+     */
+    public static final boolean odd(int x) {
+        return !even(x);
+    }
+
+    /**
+     * Check if number is odd.
+     * 
+     * @param x long
+     * @return boolean
+     */
+    public static final boolean odd(long x) {
+        return !even(x);
+    }
+
+    /**
+     * Check if number is even.
+     * 
+     * @param x short
+     * @return boolean
+     */
+    public static final boolean even(short x) {
+        return ((x & 0x1) == 0);
+    }
+
+    /**
+     * Check if number is even.
+     * 
+     * @param x int
+     * @return boolean
+     */
+    public static final boolean even(int x) {
+        return ((x & 0x1) == 0);
+    }
+
+    /**
+     * Check if number is even.
+     * 
+     * @param x long
+     * @return boolean
+     */
+    public static final boolean even(long x) {
+        return ((x & 0x1) == 0);
+    }
+
+    /**
+     * Converts a byte in the range of -128 to 127 to an int in the
+     * range 0 - 255.
+     * 
+     * @param b (-128 &lt;= b &lt;= 127)
+     * @return int (0 &lt;= b &lt;= 255)
+     */
+    public static final int signedToInt(byte b) {
+        return ((int) b & 0xff);
+    }
+
+    /**
+     * Converts a short in the range of -32768 to 32767 to an int in
+     * the range 0 - 65535.
+     * 
+     * @param w (-32768 &lt;= b &lt;= 32767)
+     * @return int (0 &lt;= b &lt;= 65535)
+     */
+    public static final int signedToInt(short w) {
+        return ((int) w & 0xffff);
+    }
+
+    /**
+     * Convert an int in the range of -2147483648 to 2147483647 to a
+     * long in the range 0 to 4294967295.
+     * 
+     * @param x (-2147483648 &lt;= x &lt;= 2147483647)
+     * @return long (0 &lt;= x &lt;= 4294967295)
+     */
+    public static final long signedToLong(int x) {
+        return ((long) x & 0xFFFFFFFFL);
+    }
+
+    /**
+     * Converts an int in the range of 0 - 65535 to an int in the
+     * range of 0 - 255.
+     * 
+     * @param w int (0 &lt;= w &lt;= 65535)
+     * @return int (0 &lt;= w &lt;= 255)
+     */
+    public static final int wordToByte(int w) {
+        return w >> 8;
+    }
+
+    /**
+     * Build short out of bytes (in big endian order).
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @return short
+     */
+    public static final short BuildShortBE(byte bytevec[], int offset) {
+        return (short) (((int) (bytevec[0 + offset]) << 8) | (signedToInt(bytevec[1 + offset])));
+    }
+
+    /**
+     * Build short out of bytes (in little endian order).
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @return short
+     */
+    public static final short BuildShortLE(byte bytevec[], int offset) {
+        return (short) (((int) (bytevec[1 + offset]) << 8) | (signedToInt(bytevec[0 + offset])));
+    }
+
+    /**
+     * Build short out of bytes.
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @param MSBFirst BE or LE?
+     * @return short
+     */
+    public static final short BuildShort(byte bytevec[], int offset,
+                                         boolean MSBFirst) {
+        if (MSBFirst) {
+            return (BuildShortBE(bytevec, offset));
+        } else {
+            return (BuildShortLE(bytevec, offset));
+        }
+    }
+
+    /**
+     * Build short out of bytes (in big endian order).
+     * 
+     * @param bytevec bytes
+     * @param MSBFirst BE or LE?
+     * @return short
+     */
+
+    public static final short BuildShortBE(byte bytevec[], boolean MSBFirst) {
+        return BuildShortBE(bytevec, 0);
+    }
+
+    /**
+     * Build short out of bytes (in little endian order).
+     * 
+     * @param bytevec bytes
+     * @param MSBFirst BE or LE?
+     * @return short
+     */
+    public static final short BuildShortLE(byte bytevec[], boolean MSBFirst) {
+        return BuildShortLE(bytevec, 0);
+    }
+
+    /**
+     * Build short out of bytes.
+     * 
+     * @param bytevec bytes
+     * @param MSBFirst BE or LE?
+     * @return short
+     */
+    public static final short BuildShort(byte bytevec[], boolean MSBFirst) {
+        return BuildShort(bytevec, 0, MSBFirst);
+    }
+
+    /**
+     * Build int out of bytes (in big endian order).
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @return int
+     */
+    public static final int BuildIntegerBE(byte bytevec[], int offset) {
+        return (((int) (bytevec[0 + offset]) << 24)
+                | (signedToInt(bytevec[1 + offset]) << 16)
+                | (signedToInt(bytevec[2 + offset]) << 8) | (signedToInt(bytevec[3 + offset])));
+    }
+
+    /**
+     * Build int out of bytes (in little endian order).
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @return int
+     */
+    public static final int BuildIntegerLE(byte bytevec[], int offset) {
+        return (((int) (bytevec[3 + offset]) << 24)
+                | (signedToInt(bytevec[2 + offset]) << 16)
+                | (signedToInt(bytevec[1 + offset]) << 8) | (signedToInt(bytevec[0 + offset])));
+    }
+
+    /**
+     * Build int out of bytes.
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @param MSBFirst BE or LE?
+     * @return int
+     */
+    public static final int BuildInteger(byte bytevec[], int offset,
+                                         boolean MSBFirst) {
+        if (MSBFirst)
+            return BuildIntegerBE(bytevec, offset);
+        else
+            return BuildIntegerLE(bytevec, offset);
+    }
+
+    /**
+     * Build int out of bytes (in big endian order).
+     * 
+     * @param bytevec bytes
+     * @return int
+     */
+    public static final int BuildIntegerBE(byte bytevec[]) {
+        return BuildIntegerBE(bytevec, 0);
+    }
+
+    /**
+     * Build int out of bytes (in little endian order).
+     * 
+     * @param bytevec bytes
+     * @return int
+     */
+    public static final int BuildIntegerLE(byte bytevec[]) {
+        return BuildIntegerLE(bytevec, 0);
+    }
+
+    /**
+     * Build int out of bytes.
+     * 
+     * @param bytevec bytes
+     * @param MSBFirst BE or LE?
+     * @return int
+     */
+    public static final int BuildInteger(byte bytevec[], boolean MSBFirst) {
+        if (MSBFirst)
+            return BuildIntegerBE(bytevec, 0);
+        else
+            return BuildIntegerLE(bytevec, 0);
+    }
+
+    /**
+     * Build long out of bytes (in big endian order).
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @return long
+     */
+    public static final long BuildLongBE(byte bytevec[], int offset) {
+        return (((long) signedToInt(bytevec[0 + offset]) << 56)
+                | ((long) signedToInt(bytevec[1 + offset]) << 48)
+                | ((long) signedToInt(bytevec[2 + offset]) << 40)
+                | ((long) signedToInt(bytevec[3 + offset]) << 32)
+                | ((long) signedToInt(bytevec[4 + offset]) << 24)
+                | ((long) signedToInt(bytevec[5 + offset]) << 16)
+                | ((long) signedToInt(bytevec[6 + offset]) << 8) | ((long) signedToInt(bytevec[7 + offset])));
+    }
+
+    /**
+     * Build long out of bytes (in little endian order).
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @return long
+     */
+    public static final long BuildLongLE(byte bytevec[], int offset) {
+        return (((long) signedToInt(bytevec[7 + offset]) << 56)
+                | ((long) signedToInt(bytevec[6 + offset]) << 48)
+                | ((long) signedToInt(bytevec[5 + offset]) << 40)
+                | ((long) signedToInt(bytevec[4 + offset]) << 32)
+                | ((long) signedToInt(bytevec[3 + offset]) << 24)
+                | ((long) signedToInt(bytevec[2 + offset]) << 16)
+                | ((long) signedToInt(bytevec[1 + offset]) << 8) | ((long) signedToInt(bytevec[0 + offset])));
+    }
+
+    /**
+     * Build long out of bytes.
+     * 
+     * @param bytevec bytes
+     * @param offset byte offset
+     * @param MSBFirst BE or LE?
+     * @return long
+     */
+    public static final long BuildLong(byte bytevec[], int offset,
+                                       boolean MSBFirst) {
+        if (MSBFirst)
+            return BuildLongBE(bytevec, offset);
+        else
+            return BuildLongLE(bytevec, offset);
+    }
+
+    /**
+     * Build long out of bytes (in big endian order).
+     * 
+     * @param bytevec bytes
+     * @return long
+     */
+    public static final long BuildLongBE(byte bytevec[]) {
+        return BuildLongBE(bytevec, 0);
+    }
+
+    /**
+     * Build long out of bytes (in little endian order).
+     * 
+     * @param bytevec bytes
+     * @return long
+     */
+    public static final long BuildLongLE(byte bytevec[]) {
+        return BuildLongLE(bytevec, 0);
+    }
+
+    /**
+     * Build long out of bytes.
+     * 
+     * @param bytevec bytes
+     * @param MSBFirst BE or LE?
+     * @return long
+     */
+    public static final long BuildLong(byte bytevec[], boolean MSBFirst) {
+        if (MSBFirst)
+            return BuildLongBE(bytevec, 0);
+        else
+            return BuildLongLE(bytevec, 0);
+    }
+
+    /*
+     * public static final void main(String[] args) { byte[] b = new
+     * byte[4]; b[0] = (byte)0xff; b[1] = (byte)0x7f;
+     * com.bbn.openmap.util.Debug.output("32767="+BuildShortLE(b, 0));
+     * b[0] = (byte)0x7f; b[1] = (byte)0xff;
+     * com.bbn.openmap.util.Debug.output("32767="+BuildShortBE(b, 0));
+     * b[1] = (byte)0xff; b[2] = (byte)0xff; b[3] = (byte)0xff;
+     * com.bbn.openmap.util.Debug.output("2147483647="+BuildIntegerBE(b,
+     * 0));
+     * com.bbn.openmap.util.Debug.output("maxuint="+signedToLong(0xffffffff)); }
+     */
+}


Property changes on: trunk/lib/com/bbn/openmap/MoreMath.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/AziDist.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/AziDist.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/AziDist.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/AziDist.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/AziDist.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,35 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/AziDist.java,v $
+// $RCSfile: AziDist.java,v $
+// $Revision: 1.1.1.1.2.1 $
+// $Date: 2004/10/14 18:27:35 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj;
+
+/**
+ * Structure contains azimuth and distance values. Distance units are
+ * determined by the operation.
+ * 
+ * @see GreatCircle#ellipsoidalAziDist
+ */
+public class AziDist {
+    public double faz;// forward azimuth
+    public double baz;// backward azimuth
+    public double distance;// distance
+}


Property changes on: trunk/lib/com/bbn/openmap/proj/AziDist.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/Ellipsoid.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/Ellipsoid.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/Ellipsoid.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/Ellipsoid.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/Ellipsoid.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,137 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/Ellipsoid.java,v $
+// $RCSfile: Ellipsoid.java,v $
+// $Revision: 1.2.2.2 $
+// $Date: 2004/10/14 18:27:35 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj;
+
+/**
+ * A class representing a reference Ellipsoid for UTM calculations.
+ * <p>
+ * 
+ * Adapted to Java by Colin Mummery (colin_mummery at agilent.com) from
+ * C++ code by Chuck Gantz (chuck.gantz at globalstar.com).
+ */
+public class Ellipsoid {
+
+    //The ellipsoids defined for this implementation
+    /** "Airy" */
+    public final static Ellipsoid AIRY = new Ellipsoid("Airy", 6377563.0d, 0.00667054d);
+    /** "Australian National" */
+    public final static Ellipsoid AUSTRALIAN_NATIONAL = new Ellipsoid("Australian National", 6378160.0d, 0.006694542d);
+    /** "Bessel 1841" */
+    public final static Ellipsoid BESSEL_1841 = new Ellipsoid("Bessel 1841", 6377397.0d, 0.006674372d);
+    /** "Bessel 1841 (Nambia) " */
+    public final static Ellipsoid BESSEL_1841_NAMIBIA = new Ellipsoid("Bessel 1841 Namibia", 6377484.0d, 0.006674372d);
+    /** "Clarke 1866" */
+    public final static Ellipsoid CLARKE_1866 = new Ellipsoid("Clarke 1866", 6378206.0d, 0.006768658d);
+    /** "Clarke 1880" */
+    public final static Ellipsoid CLARKE_1880 = new Ellipsoid("Clarke 1880", 6378249.0d, 0.006803511d);
+    /** "Everest" */
+    public final static Ellipsoid EVEREST = new Ellipsoid("Everest", 6377276.0d, 0.006637847d);
+    /** "Fischer 1960 (Mercury) " */
+    public final static Ellipsoid FISHER_1960_MERCURY = new Ellipsoid("Fisher 1960 Mercury", 6378166.0d, 0.006693422d);
+    /** "Fischer 1968" */
+    public final static Ellipsoid FISHER_1968 = new Ellipsoid("Fisher 1968", 6378150.0d, 0.006693422d);
+    /** "GRS 1967" */
+    public final static Ellipsoid GRS_1967 = new Ellipsoid("GRS 1967", 6378160.0d, 0.006694605d);
+    /** "GRS 1980" */
+    public final static Ellipsoid GRS_1980 = new Ellipsoid("GRS 1980", 6378137.0d, 0.00669438d);
+    /** "Helmert 1906" */
+    public final static Ellipsoid HELMERT_1906 = new Ellipsoid("Helmert 1906", 6378200.0d, 0.006693422d);
+    /** "Hough" */
+    public final static Ellipsoid HOUGH = new Ellipsoid("Hough", 6378270.0d, 0.00672267d);
+    /** "International" */
+    public final static Ellipsoid INTERNATIONAL = new Ellipsoid("International", 6378388.0d, 0.00672267d);
+    /** "Krassovsky" */
+    public final static Ellipsoid KRASSOVSKY = new Ellipsoid("Krassovsky", 6378245.0d, 0.006693422d);
+    /** "Modified Airy" */
+    public final static Ellipsoid MODIFIED_AIRY = new Ellipsoid("Modified Airy", 6377340.0d, 0.00667054d);
+    /** "Modified Everest" */
+    public final static Ellipsoid MODIFIED_EVEREST = new Ellipsoid("Modified Everest", 6377304.0d, 0.006637847d);
+    /** "Modified Fischer 1960" */
+    public final static Ellipsoid MODIFIED_FISCHER_1960 = new Ellipsoid("Modified Fischer", 6378155.0d, 0.006693422d);
+    /** "South American 1969" */
+    public final static Ellipsoid SOUTH_AMERICAN_1969 = new Ellipsoid("South American 1969", 6378160.0d, 0.006694542d);
+    /** "WGS 60" */
+    public final static Ellipsoid WGS_60 = new Ellipsoid("WSG 60", 6378165.0d, 0.006693422d);
+    /** "WGS 66" */
+    public final static Ellipsoid WGS_66 = new Ellipsoid("WGS 66", 6378145.0d, 0.006694542d);
+    /** "WGS-72" */
+    public final static Ellipsoid WGS_72 = new Ellipsoid("WGS 72", 6378135.0d, 0.006694318d);
+    /** "WGS-84" */
+    public final static Ellipsoid WGS_84 = new Ellipsoid("WGS 84", 6378137.0d, 0.00669438d);
+
+    /**
+     * The display name for this ellipsoid.
+     */
+    public String name;
+
+    /**
+     * The equitorial radius for this ellipsoid.
+     */
+    public double radius;
+
+    /**
+     * The square of this ellipsoid's eccentricity.
+     */
+    public double eccsq;
+
+    /**
+     * Constructs a new Ellipsoid instance.
+     * 
+     * @param radius The earth radius for this ellipsoid.
+     * @param eccsq The square of the eccentricity for this ellipsoid.
+     */
+    public Ellipsoid(String name, double radius, double eccsq) {
+        this.name = name;
+        this.radius = radius;
+        this.eccsq = eccsq;
+    }
+
+    /**
+     * Returns an array of all available ellipsoids in alphabetical
+     * order by name.
+     * 
+     * @return An Ellipsoid[] array containing all the available
+     *         ellipsoids
+     */
+    public static Ellipsoid[] getAllEllipsoids() {
+
+        Ellipsoid[] all = { AIRY, AUSTRALIAN_NATIONAL, BESSEL_1841,
+                BESSEL_1841_NAMIBIA, CLARKE_1866, CLARKE_1880, EVEREST,
+                FISHER_1960_MERCURY, FISHER_1968, GRS_1967, GRS_1980,
+                HELMERT_1906, HOUGH, INTERNATIONAL, KRASSOVSKY, MODIFIED_AIRY,
+                MODIFIED_EVEREST, MODIFIED_FISCHER_1960, SOUTH_AMERICAN_1969,
+                WGS_60, WGS_66, WGS_72, WGS_84 };
+
+        return all;
+    }
+
+    /**
+     * Returns a string representation of the object.
+     * 
+     * @return String representation
+     */
+    public String toString() {
+        return "Ellipsoid[name=" + name + ", radius=" + radius + ", eccsq="
+                + eccsq + "]";
+    }
+}


Property changes on: trunk/lib/com/bbn/openmap/proj/Ellipsoid.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/GreatCircle.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/GreatCircle.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/GreatCircle.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/GreatCircle.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/GreatCircle.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,411 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/GreatCircle.java,v $
+// $RCSfile: GreatCircle.java,v $
+// $Revision: 1.5.2.2 $
+// $Date: 2005/01/10 17:06:45 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj;
+
+import com.bbn.openmap.LatLonPoint;
+import com.bbn.openmap.MoreMath;
+
+/**
+ * Methods for calculating great circle and other distances on the
+ * sphere and ellipsoid.
+ * <p>
+ * Spherical equations taken from John Synder's <i>Map Projections --A
+ * Working Manual </i>, pp29-31. <br>
+ * Latitude/longitude arguments must be in valid radians:
+ * -PI&lt;=lambda&lt;PI, -PI/2&lt;=phi&lt;=PI/2
+ */
+public class GreatCircle {
+
+    // cannot construct
+    private GreatCircle() {}
+
+    /**
+     * Determine azimuth and distance on the ellipsoid.
+     * 
+     * @param a Semi-major axis of ellipsoid
+     * @param finv flattening of the ellipsoid (WGS84 is 1/298.257)
+     * @param glat1 Latitude of from station
+     * @param glon1 Longitude of from station
+     * @param glat2 Latitude of to station
+     * @param glon2 Longitude of to station
+     * @param ret_val AziDist struct
+     * @return AziDist ret_val struct with azimuth and distance
+     * @deprecated this has been yanked until we have a more stable
+     *             and documented algorithm
+     */
+    public final static AziDist ellipsoidalAziDist(double a, double finv,
+                                                   double glat1, double glon1,
+                                                   double glat2, double glon2,
+                                                   AziDist ret_val) {
+        return null;
+    }
+
+    /**
+     * Calculate spherical arc distance between two points.
+     * <p>
+     * Computes arc distance `c' on the sphere. equation (5-3a). (0
+     * &lt;= c &lt;= PI)
+     * <p>
+     * 
+     * @param phi1 latitude in radians of start point
+     * @param lambda0 longitude in radians of start point
+     * @param phi latitude in radians of end point
+     * @param lambda longitude in radians of end point
+     * @return float arc distance `c'
+     *  
+     */
+    final public static float spherical_distance(float phi1, float lambda0,
+                                                 float phi, float lambda) {
+        float pdiff = (float) Math.sin(((phi - phi1) / 2f));
+        float ldiff = (float) Math.sin((lambda - lambda0) / 2f);
+        float rval = (float) Math.sqrt((pdiff * pdiff) + (float) Math.cos(phi1)
+                * (float) Math.cos(phi) * (ldiff * ldiff));
+
+        return 2.0f * (float) Math.asin(rval);
+    }
+
+    /**
+     * Calculate spherical azimuth between two points.
+     * <p>
+     * Computes the azimuth `Az' east of north from phi1, lambda0
+     * bearing toward phi and lambda. (5-4b). (-PI &lt;= Az &lt;= PI).
+     * <p>
+     * 
+     * @param phi1 latitude in radians of start point
+     * @param lambda0 longitude in radians of start point
+     * @param phi latitude in radians of end point
+     * @param lambda longitude in radians of end point
+     * @return float azimuth east of north `Az'
+     *  
+     */
+    final public static float spherical_azimuth(float phi1, float lambda0,
+                                                float phi, float lambda) {
+        float ldiff = lambda - lambda0;
+        float cosphi = (float) Math.cos(phi);
+
+        return (float) Math.atan2(cosphi * (float) Math.sin(ldiff),
+                ((float) Math.cos(phi1) * (float) Math.sin(phi) - (float) Math.sin(phi1)
+                        * cosphi * (float) Math.cos(ldiff)));
+    }
+
+    /**
+     * Calculate point at azimuth and distance from another point.
+     * <p>
+     * Returns a LatLonPoint at arc distance `c' in direction `Az'
+     * from start point.
+     * <p>
+     * 
+     * @param phi1 latitude in radians of start point
+     * @param lambda0 longitude in radians of start point
+     * @param c arc radius in radians (0 &lt; c &lt;= PI)
+     * @param Az azimuth (direction) east of north (-PI &lt;= Az &lt;
+     *        PI)
+     * @return LatLonPoint
+     *  
+     */
+    final public static LatLonPoint spherical_between(float phi1,
+                                                      float lambda0, float c,
+                                                      float Az) {
+        float cosphi1 = (float) Math.cos(phi1);
+        float sinphi1 = (float) Math.sin(phi1);
+        float cosAz = (float) Math.cos(Az);
+        float sinAz = (float) Math.sin(Az);
+        float sinc = (float) Math.sin(c);
+        float cosc = (float) Math.cos(c);
+
+        return new LatLonPoint(ProjMath.radToDeg((float) Math.asin(sinphi1
+                * cosc + cosphi1 * sinc * cosAz)), ProjMath.radToDeg((float) Math.atan2(sinc
+                * sinAz,
+                cosphi1 * cosc - sinphi1 * sinc * cosAz)
+                + lambda0));
+    }
+
+    /**
+     * Calculate point between two points.
+     * <p>
+     * Same as spherical_between() above except it calculates n equal
+     * segments along the length of c.
+     * <p>
+     * 
+     * @param phi1 latitude in radians of start point
+     * @param lambda0 longitude in radians of start point
+     * @param c arc radius in radians (0 &lt; c &lt;= PI)
+     * @param Az azimuth (direction) east of north (-PI &lt;= Az &lt;
+     *        PI)
+     * @param n number of points along great circle edge to calculate
+     * @return float[n+1] radian lat,lon pairs
+     *  
+     */
+    final public static float[] spherical_between(float phi1, float lambda0,
+                                                  float c, float Az, int n) {
+        // full constants for the computation
+        float cosphi1 = (float) Math.cos(phi1);
+        float sinphi1 = (float) Math.sin(phi1);
+        float cosAz = (float) Math.cos(Az);
+        float sinAz = (float) Math.sin(Az);
+        int end = n << 1;
+
+        // new radian points
+        float[] points = new float[end + 2];
+        points[0] = phi1;
+        points[1] = lambda0;
+
+        float inc = c / n;
+        c = inc;
+        for (int i = 2; i <= end; i += 2, c += inc) {
+
+            // partial constants
+            float sinc = (float) Math.sin(c);
+            float cosc = (float) Math.cos(c);
+
+            // generate new point
+            points[i] = (float) Math.asin(sinphi1 * cosc + cosphi1 * sinc
+                    * cosAz);
+
+            points[i + 1] = (float) Math.atan2(sinc * sinAz, cosphi1 * cosc
+                    - sinphi1 * sinc * cosAz)
+                    + lambda0;
+        }
+        return points;
+    }
+
+    /**
+     * Calculate great circle between two points on the sphere.
+     * <p>
+     * Folds all computation (distance, azimuth, points between) into
+     * one function for optimization. returns n or n+1 pairs of
+     * lat,lon on great circle between lat-lon pairs.
+     * <p>
+     * 
+     * @param phi1 latitude in radians of start point
+     * @param lambda0 longitude in radians of start point
+     * @param phi latitude in radians of end point
+     * @param lambda longitude in radians of end point
+     * @param n number of segments
+     * @param include_last return n or n+1 segments
+     * @return float[n] or float[n+1] radian lat,lon pairs
+     *  
+     */
+    final public static float[] great_circle(float phi1, float lambda0,
+                                             float phi, float lambda, int n,
+                                             boolean include_last) {
+        // number of points to generate
+        int end = include_last ? n + 1 : n;
+        end <<= 1;//*2 for pairs
+
+        // calculate a bunch of stuff for later use
+        float cosphi = (float) Math.cos(phi);
+        float cosphi1 = (float) Math.cos(phi1);
+        float sinphi1 = (float) Math.sin(phi1);
+        float ldiff = lambda - lambda0;
+        float p2diff = (float) Math.sin(((phi - phi1) / 2));
+        float l2diff = (float) Math.sin((ldiff) / 2);
+
+        // calculate spherical distance
+        float c = 2.0f * (float) Math.asin((float) Math.sqrt(p2diff * p2diff
+                + cosphi1 * cosphi * l2diff * l2diff));
+
+        // calculate spherical azimuth
+        float Az = (float) Math.atan2(cosphi * (float) Math.sin(ldiff),
+                (cosphi1 * (float) Math.sin(phi) - sinphi1 * cosphi
+                        * (float) Math.cos(ldiff)));
+        float cosAz = (float) Math.cos(Az);
+        float sinAz = (float) Math.sin(Az);
+
+        // generate the great circle line
+        float[] points = new float[end];
+        points[0] = phi1;
+        points[1] = lambda0;
+
+        float inc = c / n;
+        c = inc;
+        for (int i = 2; i < end; i += 2, c += inc) {
+
+            // partial constants
+            float sinc = (float) Math.sin(c);
+            float cosc = (float) Math.cos(c);
+
+            // generate new point
+            points[i] = (float) Math.asin(sinphi1 * cosc + cosphi1 * sinc
+                    * cosAz);
+
+            points[i + 1] = (float) Math.atan2(sinc * sinAz, cosphi1 * cosc
+                    - sinphi1 * sinc * cosAz)
+                    + lambda0;
+        }
+        //      Debug.output("Calculating GreatCircle: ");
+        //      for (int i = 0; i< points.length; i++) {
+        //          Debug.output("(" + ProjMath.radToDeg(points[i].lat) + "," +
+        //                             ProjMath.radToDeg(points[i].lon) + ") ");
+        //      }
+        return points;
+    }//great_circle()
+
+    /**
+     * Calculate partial earth circle on the sphere.
+     * <p>
+     * Returns n float lat,lon pairs at arc distance c from point at
+     * phi1,lambda0.
+     * <p>
+     * 
+     * @param phi1 latitude in radians of center point
+     * @param lambda0 longitude in radians of center point
+     * @param c arc radius in radians (0 &lt; c &lt; PI)
+     * @param s starting angle in radians. North up is zero.
+     * @param e angular extent in radians, clockwise right from
+     *        starting angle.
+     * @param n number of points along circle edge to calculate
+     * @return float[n] radian lat,lon pairs along earth circle
+     *  
+     */
+    final public static float[] earth_circle(float phi1, float lambda0,
+                                             float c, float s, float e, int n) {
+        return earth_circle(phi1, lambda0, c, s, e, n, new float[n << 1]);
+    }
+
+    /**
+     * Calculate earth circle on the sphere.
+     * <p>
+     * Returns n float lat,lon pairs at arc distance c from point at
+     * phi1,lambda0.
+     * <p>
+     * 
+     * @param phi1 latitude in radians of center point
+     * @param lambda0 longitude in radians of center point
+     * @param c arc radius in radians (0 &lt; c &lt; PI)
+     * @param n number of points along circle edge to calculate
+     * @return float[n] radian lat,lon pairs along earth circle
+     *  
+     */
+    final public static float[] earth_circle(float phi1, float lambda0,
+                                             float c, int n) {
+        return earth_circle(phi1,
+                lambda0,
+                c,
+                0.0f,
+                MoreMath.TWO_PI,
+                n,
+                new float[n << 1]);
+    }
+
+    /**
+     * Calculate earth circle in the sphere.
+     * <p>
+     * Returns n float lat,lon pairs at arc distance c from point at
+     * phi1,lambda0.
+     * <p>
+     * 
+     * @param phi1 latitude in radians of center point
+     * @param lambda0 longitude in radians of center point
+     * @param c arc radius in radians (0 &lt; c &lt; PI)
+     * @param n number of points along circle edge to calculate
+     * @param ret_val float[] ret_val array of n*2 number of points
+     *        along circle edge to calculate
+     * @return float[n] radian lat,lon pairs along earth circle
+     *  
+     */
+    final public static float[] earth_circle(float phi1, float lambda0,
+                                             float c, int n, float[] ret_val) {
+        return earth_circle(phi1, lambda0, c, 0.0f, MoreMath.TWO_PI, n, ret_val);
+    }
+
+    /**
+     * Calculate earth circle in the sphere.
+     * <p>
+     * Returns n float lat,lon pairs at arc distance c from point at
+     * phi1,lambda0.
+     * <p>
+     * 
+     * @param phi1 latitude in radians of center point.
+     * @param lambda0 longitude in radians of center point.
+     * @param c arc radius in radians (0 &lt; c &lt; PI).
+     * @param s starting angle in radians. North up is zero.
+     * @param e angular extent in radians, clockwise right from
+     *        starting angle.
+     * @param n number of points along circle edge to calculate.
+     * @param ret_val float[] ret_val array of n*2 number of points
+     *        along circle edge to calculate.
+     * @return float[n] radian lat,lon pairs along earth circle.
+     *  
+     */
+    final public static float[] earth_circle(float phi1, float lambda0,
+                                             float c, float s, float e, int n,
+                                             float[] ret_val) {
+        float Az, cosAz, sinAz;
+        float cosphi1 = (float) Math.cos(phi1);
+        float sinphi1 = (float) Math.sin(phi1);
+        float sinc = (float) Math.sin(c);
+        float cosc = (float) Math.cos(c);
+        if (n < 2) n = 2; // Safety to avoid / by zero later.
+        int end = n << 1;//*2
+
+        // Only want to create a new return float array if there was a
+        // null one passed in, or if the number of desired coordinates
+        // is bigger than what ret_val is currently allocated for.
+        if (ret_val == null || end > ret_val.length) {
+            ret_val = new float[end];
+        }
+
+        float inc = e / (n - 1);
+        Az = s;
+
+        // generate the points in clockwise order (conforming to
+        // internal standard!)
+        for (int i = 0; i < end; i += 2, Az += inc) {
+            cosAz = (float) Math.cos(Az);
+            sinAz = (float) Math.sin(Az);
+
+            ret_val[i] = (float) Math.asin(sinphi1 * cosc + cosphi1 * sinc
+                    * cosAz);
+            ret_val[i + 1] = (float) Math.atan2(sinc * sinAz, cosphi1 * cosc
+                    - sinphi1 * sinc * cosAz)
+                    + lambda0;
+        }
+
+        return ret_val;
+    }
+
+    /*
+     * testing public final static void main (String[] args) { double
+     * phi1 = 34.3; double lambda0 = 130.299; double phi = -24; double
+     * lambda = 33.23;
+     * 
+     * float dist_sphere = spherical_distance (
+     * ProjMath.degToRad((float)phi1),
+     * ProjMath.degToRad((float)lambda0),
+     * ProjMath.degToRad((float)phi), ProjMath.degToRad((float)lambda) ); //
+     * meters dist_sphere =
+     * Planet.wgs84_earthEquatorialCircumferenceMeters*(dist_sphere/MoreMath.TWO_PI);
+     * Debug.output("sphere distance="+dist_sphere/1000f+" km");
+     * 
+     * AziDist invVar = ellipsoidalAziDist (
+     * Planet.wgs84_earthEquatorialRadiusMeters,//major in meters
+     * Planet.wgs84_earthFlat, //
+     * Planet.international1974_earthEquatorialRadiusMeters,//major in
+     * meters // Planet.international1974_earthFlat,
+     * ProjMath.degToRad(phi1), ProjMath.degToRad(lambda0),
+     * ProjMath.degToRad(phi), ProjMath.degToRad(lambda), new
+     * AziDist() ); Debug.output("ellipsoid
+     * distance="+invVar.distance/1000d+" km"); }
+     */
+}


Property changes on: trunk/lib/com/bbn/openmap/proj/GreatCircle.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/Length.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/Length.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/Length.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/Length.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/Length.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,162 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/Length.java,v $
+// $RCSfile: Length.java,v $
+// $Revision: 1.5.2.1 $
+// $Date: 2004/10/14 18:27:37 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj;
+
+//import com.bbn.openmap.util.Debug;
+
+/**
+ * Length is a convenience class used for a couple of things. It can
+ * be used to specifiy unit type, and can be used for conversion from
+ * radians to/from whatever units are represented by the implemented
+ * class.
+ */
+public class Length {
+
+    /** Miles, in WGS 84 spherical earth model units. */
+    public final static Length MILE = new Length("mile", "miles", Planet.wgs84_earthEquatorialCircumferenceMiles_D);
+    /** Feet, in WGS 84 spherical earth model units. */
+    public final static Length FEET = new Length("feet", "feet", Planet.wgs84_earthEquatorialCircumferenceMiles_D * 5280.0);
+    /** Meters, in WGS 84 Spherical earth model units. */
+    public final static Length METER = new Length("meter", "m", Planet.wgs84_earthEquatorialCircumferenceMeters_D);
+    /** Kilometers, in WGS 84 Spherical earth model units. */
+    public final static Length KM = new Length("kilometer", "km", Planet.wgs84_earthEquatorialCircumferenceKM_D);
+    /** Nautical Miles, in WGS 84 Spherical earth model units. */
+    public final static Length NM = new Length("nautical mile", "nm", Planet.wgs84_earthEquatorialCircumferenceNMiles_D);
+    /** Decimal Degrees, in WGS 84 Spherical earth model units. */
+    public final static Length DECIMAL_DEGREE = new Length("decimal degree", "deg", 360.0);
+    /** Radians, in terms of a spherical earth. */
+    public final static Length RADIAN = new Length("radian", "rad", com.bbn.openmap.MoreMath.TWO_PI_D);
+    /** Data Mile, in WGS 84 spherical earth model units. */
+    public final static Length DM = new Length("datamile", "dm", Planet.wgs84_earthEquatorialCircumferenceMiles_D * 5280.0 / 6000.0);
+
+    /** Unit/radians */
+    protected final double constant;
+    protected final String name;
+    protected final String abbr;
+
+    /**
+     * Create a Length, with a name an the number of it's units that
+     * go around the earth at its equator. The name and abbreviation
+     * are converted to lower case for consistency.
+     */
+    public Length(String name, String abbr, double unitEquatorCircumference) {
+//        this.name = name.toLowerCase().intern();
+        this.name = name.toLowerCase();
+        constant = unitEquatorCircumference / com.bbn.openmap.MoreMath.TWO_PI_D;
+//        this.abbr = abbr.toLowerCase().intern();
+        this.abbr = abbr.toLowerCase();
+    }
+
+    /**
+     * Given a number of units provided by this Length, convert to a
+     * number of radians.
+     */
+    public float toRadians(float numUnits) {
+/*
+    	if (Debug.debugging("length")) {
+            Debug.output("Translating " + name + " from radians");
+        }
+*/
+
+        return numUnits / (float) constant;
+    }
+
+    public double toRadians(double numUnits) {
+/*
+       if (Debug.debugging("length")) {
+            Debug.output("Translating " + name + " from radians");
+        }
+*/
+
+        return numUnits / constant;
+    }
+
+    /**
+     * Given a number of radians, convert to the number of units
+     * represented by this length.
+     */
+    public float fromRadians(float numRadians) {
+/*
+    	if (Debug.debugging("length")) {
+            Debug.output("Translating radians from " + name);
+        }
+*/
+
+        return numRadians * (float) constant;
+    }
+
+    /**
+     * Given a number of radians, convert to the number of units
+     * represented by this length.
+     */
+    public double fromRadians(double numRadians) {
+/*
+    	if (Debug.debugging("length")) {
+            Debug.output("Translating radians from " + name);
+        }
+*/
+        return numRadians * constant;
+    }
+
+    /**
+     * Return the name for this length type.
+     */
+    public String toString() {
+        return name;
+    }
+
+    /**
+     * Return the abbreviation for this length type.
+     */
+    public String getAbbr() {
+        return abbr;
+    }
+
+    /**
+     * Get a list of the Lengths currently defined as static
+     * implementations of this class.
+     */
+    public static Length[] getAvailable() {
+        return new Length[] { METER, KM, FEET, MILE, DM, NM, DECIMAL_DEGREE };
+    }
+
+    /**
+     * Get the Length object with the given name or abbreviation. If
+     * nothing exists with that name, then return null. The lower case
+     * version of the name or abbreviation is checked against the
+     * available options.
+     */
+    public static Length get(String name) {
+        Length[] choices = getAvailable();
+
+        for (int i = 0; i < choices.length; i++) {
+//            if (name.toLowerCase().intern() == choices[i].toString()
+//            || name.toLowerCase().intern() == choices[i].getAbbr()) {
+        	if (name.toLowerCase() == choices[i].toString()
+                    || name.toLowerCase() == choices[i].getAbbr()) {
+                return choices[i];
+            }
+        }
+        return null;
+    }
+}


Property changes on: trunk/lib/com/bbn/openmap/proj/Length.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/Planet.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/Planet.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/Planet.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/Planet.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/Planet.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,115 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/Planet.java,v $
+// $RCSfile: Planet.java,v $
+// $Revision: 1.4.2.1 $
+// $Date: 2004/10/14 18:27:37 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj;
+
+import com.bbn.openmap.MoreMath;
+
+/**
+ * Planet datums and parameters. These values are taken from John
+ * Snyder's <i>Map Projections --A Working Manual </i> You should add
+ * datums as needed, consult the ellips.dat file.
+ */
+public class Planet {
+
+    // Solar system id's. Add new ones as needed.
+    final public static transient int Earth = 3;
+    final public static transient int Mars = 4;
+
+    // WGS84 / GRS80 datums
+    final public static transient float wgs84_earthPolarRadiusMeters = 6356752.3142f;
+    final public static transient double wgs84_earthPolarRadiusMeters_D = 6356752.3142;
+    final public static transient float wgs84_earthEquatorialRadiusMeters = 6378137.0f;
+    final public static transient double wgs84_earthEquatorialRadiusMeters_D = 6378137.0;
+    final public static transient float wgs84_earthFlat = 1 - (wgs84_earthPolarRadiusMeters / wgs84_earthEquatorialRadiusMeters);// 1 -
+                                                                                                                                 // (minor/major)
+                                                                                                                                 // =
+                                                                                                                                 // 1/298.257
+    final public static transient float wgs84_earthEccen = (float) Math.sqrt(2
+            * wgs84_earthFlat - (wgs84_earthFlat * wgs84_earthFlat));// sqrt(2*f
+                                                                     // -
+                                                                     // f^2)
+                                                                     // =
+                                                                     // 0.081819221f
+
+    final public static transient float wgs84_earthEquatorialCircumferenceMeters = MoreMath.TWO_PI
+            * wgs84_earthEquatorialRadiusMeters;
+    final public static transient float wgs84_earthEquatorialCircumferenceKM = wgs84_earthEquatorialCircumferenceMeters / 1000f;
+    final public static transient float wgs84_earthEquatorialCircumferenceMiles = wgs84_earthEquatorialCircumferenceKM * 0.62137119f;//HACK
+                                                                                                                                     // use
+                                                                                                                                     // UNIX
+                                                                                                                                     // units?
+    final public static transient float wgs84_earthEquatorialCircumferenceNMiles = 21600.0f; // 60.0f
+                                                                                             // *
+                                                                                             // 360.0f;
+                                                                                             // //
+                                                                                             // sixty
+                                                                                             // nm
+                                                                                             // per
+                                                                                             // degree
+
+    final public static transient double wgs84_earthEquatorialCircumferenceMeters_D = MoreMath.TWO_PI_D
+            * wgs84_earthEquatorialRadiusMeters_D;
+    final public static transient double wgs84_earthEquatorialCircumferenceKM_D = wgs84_earthEquatorialCircumferenceMeters_D / 1000;
+    final public static transient double wgs84_earthEquatorialCircumferenceMiles_D = wgs84_earthEquatorialCircumferenceKM_D * 0.62137119;//HACK
+                                                                                                                                         // use
+                                                                                                                                         // UNIX
+                                                                                                                                         // units?
+    final public static transient double wgs84_earthEquatorialCircumferenceNMiles_D = 21600.0; // 60.0f
+                                                                                               // *
+                                                                                               // 360.0f;
+                                                                                               // //
+                                                                                               // sixty
+                                                                                               // nm
+                                                                                               // per
+                                                                                               // degree
+
+    //      wgs84_earthEquatorialCircumferenceKM*0.5389892f; // calculated,
+    // same as line above.
+    //      wgs84_earthEquatorialCircumferenceKM*0.5399568f;//HACK use UNIX
+    // units? << This was wrong.
+
+    // Mars
+    final public static transient float marsEquatorialRadius = 3393400.0f;// meters
+    final public static transient float marsEccen = 0.101929f;// eccentricity
+                                                              // e
+    final public static transient float marsFlat = 0.005208324f;// 1-(1-e^2)^1/2
+
+    // International 1974
+    final public static transient float international1974_earthPolarRadiusMeters = 6356911.946f;
+    final public static transient float international1974_earthEquatorialRadiusMeters = 6378388f;
+    final public static transient float international1974_earthFlat = 1 - (international1974_earthPolarRadiusMeters / international1974_earthEquatorialRadiusMeters);// 1 -
+                                                                                                                                                                     // (minor/major)
+                                                                                                                                                                     // =
+                                                                                                                                                                     // 1/297
+
+    // Extra scale constant for better viewing of maps (do not use
+    // this to
+    // calculate anything but points to be viewed!)
+    public transient static int defaultPixelsPerMeter = 3272;// 3384:
+                                                             // mattserver/Map.C,
+                                                             // 3488:
+                                                             // dcw
+
+    // cannot construct
+    private Planet() {}
+}


Property changes on: trunk/lib/com/bbn/openmap/proj/Planet.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/ProjMath.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/ProjMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/ProjMath.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/ProjMath.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/ProjMath.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,479 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/ProjMath.java,v $
+// $RCSfile: ProjMath.java,v $
+// $Revision: 1.3.2.2 $
+// $Date: 2005/02/11 22:51:27 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj;
+
+import com.bbn.openmap.MoreMath;
+
+/**
+ * Math functions used by projection code.
+ */
+public final class ProjMath {
+
+    /**
+     * North pole latitude in radians.
+     */
+    public final static transient float NORTH_POLE_F = MoreMath.HALF_PI;
+
+    /**
+     * South pole latitude in radians.
+     */
+    public final static transient float SOUTH_POLE_F = -NORTH_POLE_F;
+
+    /**
+     * North pole latitude in radians.
+     */
+    public final static transient double NORTH_POLE_D = MoreMath.HALF_PI_D;
+
+    /**
+     * South pole latitude in radians.
+     */
+    public final static transient double SOUTH_POLE_D = -NORTH_POLE_D;
+
+    /**
+     * Dateline longitude in radians.
+     */
+    public final static transient float DATELINE_F = (float) Math.PI;
+
+    /**
+     * Dateline longitude in radians.
+     */
+    public final static transient double DATELINE_D = Math.PI;
+
+    /**
+     * Longitude range in radians.
+     */
+    public final static transient float LON_RANGE_F = (float) MoreMath.TWO_PI;
+
+    /**
+     * Longitude range in radians.
+     */
+    public final static transient double LON_RANGE_D = MoreMath.TWO_PI_D;
+
+    // cannot construct
+    private ProjMath() {}
+
+    /**
+     * rounds the quantity away from 0.
+     * 
+     * @param x in value
+     * @return double
+     * @see #qint(double)
+     */
+    public final static double roundAdjust(double x) {
+        return qint_old(x);
+    }
+
+    /**
+     * Rounds the quantity away from 0.
+     * 
+     * @param x value
+     * @return double
+     */
+    public final static double qint(double x) {
+        return qint_new(x);
+    }
+
+    final private static double qint_old(double x) {
+        return (((int) x) < 0) ? (x - 0.5) : (x + 0.5);
+    }
+
+    final private static double qint_new(double x) {
+        // -1 or +1 away from zero
+        return (x <= 0.0) ? (x - 1.0) : (x + 1.0);
+    }
+
+    /**
+     * Calculate the shortest arc distance between two lons.
+     * 
+     * @param lon1 radians
+     * @param lon2 radians
+     * @return float distance
+     */
+    public final static float lonDistance(float lon1, float lon2) {
+        return (float) Math.min(Math.abs(lon1 - lon2), ((lon1 < 0) ? lon1
+                + Math.PI : Math.PI - lon1)
+                + ((lon2 < 0) ? lon2 + Math.PI : Math.PI - lon2));
+    }
+
+    /**
+     * Convert between decimal degrees and scoords.
+     * 
+     * @param deg degrees
+     * @return long scoords
+     *  
+     */
+    public final static long DEG_TO_SC(double deg) {
+        return (long) (deg * 3600000);
+    }
+
+    /**
+     * Convert between decimal degrees and scoords.
+     * 
+     * @param sc scoords
+     * @return double decimal degrees
+     */
+    public final static double SC_TO_DEG(int sc) {
+        return ((double) (sc) / (60.0 * 60.0 * 1000.0));
+    }
+
+    /**
+     * Convert radians to degrees.
+     * 
+     * @param rad radians
+     * @return double decimal degrees
+     */
+    public final static double radToDeg(double rad) {
+        return (rad * (180.0d / Math.PI));
+    }
+
+    /**
+     * Convert radians to degrees.
+     * 
+     * @param rad radians
+     * @return float decimal degrees
+     */
+    public final static float radToDeg(float rad) {
+        return (float) radToDeg((double)rad);
+    }
+
+    /**
+     * Convert degrees to radians.
+     * 
+     * @param deg degrees
+     * @return double radians
+     */
+    public final static double degToRad(double deg) {
+        return (deg * (Math.PI / 180.0d));
+    }
+
+    /**
+     * Convert degrees to radians.
+     * 
+     * @param deg degrees
+     * @return float radians
+     */
+    public final static float degToRad(float deg) {
+        return (float) degToRad((double)deg);
+    }
+
+    /**
+     * Generate a hashCode value for a lat/lon pair.
+     * 
+     * @param lat latitude
+     * @param lon longitude
+     * @return int hashcode
+     *  
+     */
+    public final static int hashLatLon(float lat, float lon) {
+        if (lat == -0f)
+            lat = 0f;//handle negative zero (anything else?)
+        if (lon == -0f)
+            lon = 0f;
+        int tmp = Float.floatToIntBits(lat);
+        int hash = (tmp << 5) | (tmp >> 27);//rotate the lat bits
+        return hash ^ Float.floatToIntBits(lon);//XOR with lon
+    }
+
+    /**
+     * Converts an array of decimal degrees float lat/lons to float
+     * radians in place.
+     * 
+     * @param degs float[] lat/lons in decimal degrees
+     * @return float[] lat/lons in radians
+     */
+    public final static float[] arrayDegToRad(float[] degs) {
+        for (int i = 0; i < degs.length; i++) {
+            degs[i] = degToRad(degs[i]);
+        }
+        return degs;
+    }
+
+    /**
+     * Converts an array of radian float lat/lons to decimal degrees
+     * in place.
+     * 
+     * @param rads float[] lat/lons in radians
+     * @return float[] lat/lons in decimal degrees
+     */
+    public final static float[] arrayRadToDeg(float[] rads) {
+        for (int i = 0; i < rads.length; i++) {
+            rads[i] = radToDeg(rads[i]);
+        }
+        return rads;
+    }
+
+    /**
+     * Converts an array of decimal degrees double lat/lons to double
+     * radians in place.
+     * 
+     * @param degs double[] lat/lons in decimal degrees
+     * @return double[] lat/lons in radians
+     */
+    public final static double[] arrayDegToRad(double[] degs) {
+        for (int i = 0; i < degs.length; i++) {
+            degs[i] = degToRad(degs[i]);
+        }
+        return degs;
+    }
+
+    /**
+     * Converts an array of radian double lat/lons to decimal degrees
+     * in place.
+     * 
+     * @param rads double[] lat/lons in radians
+     * @return double[] lat/lons in decimal degrees
+     */
+    public final static double[] arrayRadToDeg(double[] rads) {
+        for (int i = 0; i < rads.length; i++) {
+            rads[i] = radToDeg(rads[i]);
+        }
+        return rads;
+    }
+
+    /**
+     * Normalizes radian latitude. Normalizes latitude if at or
+     * exceeds epsilon distance from a pole.
+     * 
+     * @param lat float latitude in radians
+     * @param epsilon epsilon (&gt;= 0) radians distance from pole
+     * @return float latitude (-PI/2 &lt;= phi &lt;= PI/2)
+     * @see Proj#normalize_latitude(float)
+     * @see com.bbn.openmap.LatLonPoint#normalize_latitude(float)
+     */
+    public final static float normalize_latitude(float lat, float epsilon) {
+        if (lat > NORTH_POLE_F - epsilon) {
+            return NORTH_POLE_F - epsilon;
+        } else if (lat < SOUTH_POLE_F + epsilon) {
+            return SOUTH_POLE_F + epsilon;
+        }
+        return lat;
+    }
+
+    /**
+     * Normalizes radian latitude. Normalizes latitude if at or
+     * exceeds epsilon distance from a pole.
+     * 
+     * @param lat double latitude in radians
+     * @param epsilon epsilon (&gt;= 0) radians distance from pole
+     * @return double latitude (-PI/2 &lt;= phi &lt;= PI/2)
+     * @see Proj#normalize_latitude(float)
+     * @see com.bbn.openmap.LatLonPoint#normalize_latitude(float)
+     */
+    public final static double normalize_latitude(double lat, double epsilon) {
+        if (lat > NORTH_POLE_D - epsilon) {
+            return NORTH_POLE_D - epsilon;
+        } else if (lat < SOUTH_POLE_D + epsilon) {
+            return SOUTH_POLE_D + epsilon;
+        }
+        return lat;
+    }
+
+    /**
+     * Sets radian longitude to something sane.
+     * 
+     * @param lon float longitude in radians
+     * @return float longitude (-PI &lt;= lambda &lt; PI)
+     * @see com.bbn.openmap.LatLonPoint#wrap_longitude(float)
+     */
+    public final static float wrap_longitude(float lon) {
+        if ((lon < -DATELINE_F) || (lon > DATELINE_F)) {
+            lon += DATELINE_F;
+            lon = (lon % LON_RANGE_F);
+            lon += (lon < 0) ? DATELINE_F : -DATELINE_F;
+        }
+        return lon;
+    }
+
+    /**
+     * Sets radian longitude to something sane.
+     * 
+     * @param lon double longitude in radians
+     * @return double longitude (-PI &lt;= lambda &lt; PI)
+     * @see #wrap_longitude(float)
+     */
+    public final static double wrap_longitude(double lon) {
+        if ((lon < -DATELINE_D) || (lon > DATELINE_D)) {
+            lon += DATELINE_D;
+            lon = (lon % LON_RANGE_D);
+            lon += (lon < 0) ? DATELINE_D : -DATELINE_D;
+        }
+        return lon;
+    }
+
+    /**
+     * Converts units (km, nm, miles, etc) to decimal degrees for a
+     * spherical planet. This does not check for arc distances &gt;
+     * 1/2 planet circumference, which are better represented as (2pi -
+     * calculated arc).
+     * 
+     * @param u units float value
+     * @param uCircumference units circumference of planet
+     * @return float decimal degrees
+     */
+    public final static float sphericalUnitsToDeg(float u, float uCircumference) {
+        return 360f * (u / uCircumference);
+    }
+
+    /**
+     * Converts units (km, nm, miles, etc) to arc radians for a
+     * spherical planet. This does not check for arc distances &gt;
+     * 1/2 planet circumference, which are better represented as (2pi -
+     * calculated arc).
+     * 
+     * @param u units float value
+     * @param uCircumference units circumference of planet
+     * @return float arc radians
+     */
+    public final static float sphericalUnitsToRad(float u, float uCircumference) {
+        return MoreMath.TWO_PI * (u / uCircumference);
+    }
+
+    /**
+     * Calculate the geocentric latitude given a geographic latitude.
+     * According to John Synder: <br>
+     * "The geographic or geodetic latitude is the angle which a line
+     * perpendicular to the surface of the ellipsoid at the given
+     * point makes with the plane of the equator. ...The geocentric
+     * latitude is the angle made by a line to the center of the
+     * ellipsoid with the equatorial plane". ( <i>Map Projections --A
+     * Working Manual </i>, p 13)
+     * <p>
+     * Translated from Ken Anderson's lisp code <i>Freeing the Essence
+     * of Computation </i>
+     * 
+     * @param lat float geographic latitude in radians
+     * @param flat float flatening factor
+     * @return float geocentric latitude in radians
+     * @see #geographic_latitude
+     */
+    public final static float geocentric_latitude(float lat, float flat) {
+        float f = 1.0f - flat;
+        return (float) Math.atan((f * f) * (float) Math.tan(lat));
+    }
+
+    /**
+     * Calculate the geographic latitude given a geocentric latitude.
+     * Translated from Ken Anderson's lisp code <i>Freeing the Essence
+     * of Computation </i>
+     * 
+     * @param lat float geocentric latitude in radians
+     * @param flat float flatening factor
+     * @return float geographic latitude in radians
+     * @see #geocentric_latitude
+     */
+    public final static float geographic_latitude(float lat, float flat) {
+        float f = 1.0f - flat;
+        return (float) Math.atan((float) Math.tan(lat) / (f * f));
+    }
+
+    /**
+     * Given a couple of points representing a bounding box, find out
+     * what the scale should be in order to make those points appear
+     * at the corners of the projection.
+     * 
+     * @param ll1 the upper left coordinates of the bounding box.
+     * @param ll2 the lower right coordinates of the bounding box.
+     * @param projection the projection to use for other projection
+     *        parameters, like map width and map height.
+     */
+    /*
+    public static float getScale(com.bbn.openmap.LatLonPoint ll1,
+                                 com.bbn.openmap.LatLonPoint ll2,
+                                 Projection projection) {
+        if (projection == null) {
+            return Float.MAX_VALUE;
+        }
+        java.awt.Point point1 = projection.forward(ll1);
+        java.awt.Point point2 = projection.forward(ll2);
+
+        return getScale(ll1, ll2, point1, point2, projection);
+    }
+*/
+    /**
+     * Given a couple of points representing a bounding box, find out
+     * what the scale should be in order to make those points appear
+     * at the corners of the projection.
+     * 
+     * @param point1 a java.awt.Point reflecting a pixel spot on the
+     *        projection, usually the upper left corner of the area of
+     *        interest.
+     * @param point2 a java.awt.Point reflecting a pixel spot on the
+     *        projection, usually the lower right corner of the area
+     *        of interest.
+     * @param projection the projection to use for other projection
+     *        parameters, like map width and map height.
+     */
+/*    
+public static float getScale(java.awt.Point point1, java.awt.Point point2,
+                                 Projection projection) {
+
+        if (projection == null) {
+            return Float.MAX_VALUE;
+        }
+        com.bbn.openmap.LatLonPoint ll1 = projection.inverse(point1);
+        com.bbn.openmap.LatLonPoint ll2 = projection.inverse(point2);
+
+        return getScale(ll1, ll2, point1, point2, projection);
+    }
+*/
+
+    /**
+     * Given a couple of points representing a bounding box, find out
+     * what the scale should be in order to make those points appear
+     * at the corners of the projection.
+     * 
+     * @param ll1 the upper left coordinates of the bounding box.
+     * @param ll2 the lower right coordinates of the bounding box.
+     * @param point1 a java.awt.Point reflecting a pixel spot on the
+     *        projection that matches the ll1 coordinate, the upper
+     *        left corner of the area of interest.
+     * @param point2 a java.awt.Point reflecting a pixel spot on the
+     *        projection that matches the ll2 coordinate, usually the
+     *        lower right corner of the area of interest.
+     * @param projection the projection to use to query to get the
+     *        scale for, for projection type and height and width.
+     */
+    /*
+    protected static float getScale(com.bbn.openmap.LatLonPoint ll1,
+                                    com.bbn.openmap.LatLonPoint ll2,
+                                    java.awt.Point point1,
+                                    java.awt.Point point2, Projection projection) {
+
+        return projection.getScale(ll1, ll2, point1, point2);
+    }
+    */
+
+    /*
+     * public static void main(String[] args) { float degs =
+     * sphericalUnitsToRad( Planet.earthEquatorialRadius/2,
+     * Planet.earthEquatorialRadius); Debug.output("degs = " + degs);
+     * float LAT_DEC_RANGE = 90.0f; float LON_DEC_RANGE = 360.0f;
+     * float lat, lon; for (int i = 0; i < 100; i++) { lat =
+     * com.bbn.openmap.LatLonPoint.normalize_latitude(
+     * (float)Math.random()*LAT_DEC_RANGE); lon =
+     * com.bbn.openmap.LatLonPoint.wrap_longitude(
+     * (float)Math.random()*LON_DEC_RANGE); Debug.output( "(" + lat +
+     * "," + lon + ") : (" + degToRad(lat) + "," + degToRad(lon) + ") : (" +
+     * radToDeg(degToRad(lat)) + "," + radToDeg(degToRad(lon)) + ")"); } }
+     */
+}


Property changes on: trunk/lib/com/bbn/openmap/proj/ProjMath.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,364 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/coords/DMSLatLonPoint.java,v $
+// $RCSfile: DMSLatLonPoint.java,v $
+// $Revision: 1.3.2.1 $
+// $Date: 2004/10/14 18:27:38 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.proj.coords;
+
+import com.bbn.openmap.LatLonPoint;
+import com.bbn.openmap.util.Assert;
+
+/**
+ * Encapsulates a latitude and longitude coordinate in degrees,
+ * minutes and seconds as well as the sign.
+ * <p>
+ * 
+ * Original code contributed by Colin Mummery
+ * (colin_mummery at yahoo.com)
+ */
+public class DMSLatLonPoint implements Cloneable {
+
+    private final static float MINUTE = 1 / 60.0f;
+    private final static float SECOND = 1 / 3600.0f;
+
+    /**
+     * Indicates if the latitude is negative, the actual int values
+     * are always positive.
+     */
+    public boolean lat_isnegative;
+    /**
+     * The number of degrees in the latitude.
+     */
+    public int lat_degrees;
+    /**
+     * The number of minutes in the latitude.
+     */
+    public int lat_minutes;
+    /**
+     * The number of seconds in the latitude.
+     */
+    public float lat_seconds;
+
+    /**
+     * Indicates if the longitude is negative, the actual int values
+     * are always positive.
+     */
+    public boolean lon_isnegative;
+    /**
+     * The number of degrees in the longitude.
+     */
+    public int lon_degrees;
+    /**
+     * The number of minutes in the longitude.
+     */
+    public int lon_minutes;
+    /**
+     * The number of seconds in the longitude.
+     */
+    public float lon_seconds;
+
+    /**
+     * Construct a default LatLonPoint with zero values.
+     */
+    public DMSLatLonPoint() {}
+
+    /**
+     * Construct a DMSLatLonPoint from raw int lat/lon. All parameters
+     * are checked for their validity.
+     * 
+     * @param lat_isnegative boolean value indicating the sign of the
+     *        latitude
+     * @param lat_degrees integer number of degrees in latitude
+     * @param lat_minutes integer number of minutes in latitude
+     * @param lat_seconds float number of seconds in latitude
+     * @param lon_isnegative boolean value indicating the sign of the
+     *        longitude
+     * @param lon_degrees integer number of degrees in longitude
+     * @param lon_minutes integer number of minutes in longitude
+     * @param lon_seconds float number of seconds in longitude
+     */
+    public DMSLatLonPoint(boolean lat_isnegative, int lat_degrees,
+            int lat_minutes, float lat_seconds, boolean lon_isnegative,
+            int lon_degrees, int lon_minutes, float lon_seconds) {
+
+        this.lat_isnegative = lat_isnegative;
+        this.lat_degrees = (int) LatLonPoint.normalize_latitude(lat_degrees);
+        if (this.lat_degrees < 0) {
+            //can't have a negative value
+            this.lat_degrees = -this.lat_degrees;
+        }
+        this.lat_minutes = normalize_value(lat_minutes);
+        this.lat_seconds = normalize_value(lat_seconds);
+
+        this.lon_isnegative = lon_isnegative;
+        this.lon_degrees = (int) LatLonPoint.wrap_longitude(lon_degrees);
+        if (this.lon_degrees < 0) {
+            //can't have a negative value
+            this.lon_degrees = -this.lon_degrees;
+        }
+        this.lon_minutes = normalize_value(lon_minutes);
+        this.lon_seconds = normalize_value(lon_seconds);
+    }
+
+    /**
+     * Constructs a new DMSLatLonPoint given a LatLonPoint instance
+     * 
+     * @param llp A LatLonPoint instance
+     */
+    public DMSLatLonPoint(LatLonPoint llp) {
+        getDMSLatLonPoint(llp, this);
+    }
+
+    /**
+     * A static method which takes an instance of a LatLongPoint and
+     * sets the correct values into an instance of DMSLatLonPoint.
+     * 
+     * @param llp A LatLonPoint instance.
+     * @param dllp A DMSLatLonPoint instance.
+     */
+    static void getDMSLatLonPoint(LatLonPoint llp, DMSLatLonPoint dllp) {
+
+        //set everything to zero
+        dllp.lat_degrees = 0;
+        dllp.lat_minutes = 0;
+        dllp.lat_seconds = 0f;
+        dllp.lat_isnegative = false;
+        dllp.lon_degrees = 0;
+        dllp.lon_minutes = 0;
+        dllp.lon_seconds = 0f;
+        dllp.lon_isnegative = false;
+
+        //First do the latitude
+        float val = llp.getLatitude();
+
+        if (val < 0) {
+            dllp.lat_isnegative = true;
+            val = -val;
+        } //remove the sign but remember it
+
+        dllp.lat_degrees = (int) Math.floor((double) val);
+
+        if (val >= SECOND) {
+            //If it's less then a second then we assume zero...I
+            // guess
+            //we could round up
+            int deg = (int) val;
+            //take out the whole degrees
+            float rem = val - deg;
+            //Do we have anything left to convert to a minute
+            if (rem >= MINUTE) { //get the minutes
+                int min = (int) (rem * 60);
+                dllp.lat_minutes = min;
+                rem = rem - (min * MINUTE);
+            }
+            //Any seconds left?
+            if (rem >= SECOND) { //get the seconds
+                float sec = (rem * 3600f);
+                dllp.lat_seconds = sec;
+                rem = rem - (sec * SECOND);
+            }
+        } else {
+            dllp.lat_isnegative = false; //we don't want a negative
+                                         // zero
+        }
+
+        //Next repeat the code for longitude, easiest just to repeat
+        //it
+        val = llp.getLongitude();
+        if (val < 0) {
+            dllp.lon_isnegative = true;
+            val = -val;
+        }
+
+        dllp.lon_degrees = (int) Math.floor((double) val);
+
+        if (val >= SECOND) {
+            int deg = (int) val;
+            float rem = val - deg;
+            if (rem >= MINUTE) {
+                int min = (int) (rem * 60);
+                dllp.lon_minutes = min;
+                rem = rem - (min * MINUTE);
+            }
+            if (rem >= SECOND) {
+                float sec = rem * 3600f;
+                dllp.lon_seconds = sec;
+                rem = rem - (sec * SECOND);
+            }
+        } else {
+            dllp.lon_isnegative = false;
+        }
+    }
+
+    /**
+     * Return a LatLonPoint from this DMSLatLonPoint. The LatLonPoint
+     * is allocated here.
+     * 
+     * @return LatLonPoint, full of decimal degrees.
+     */
+    public LatLonPoint getLatLonPoint() {
+        return getLatLonPoint(null);
+    }
+
+    /**
+     * Return a LatLonPoint from this DMSLatLonPoint. The LatLonPoint
+     * is allocated here if the llp is null. If it's not null, then
+     * the llp is loaded with the proper values.
+     * 
+     * @param llp the LatLonPoint to load up.
+     * @return LatLonPoint, full of decimal degrees.
+     */
+    public LatLonPoint getLatLonPoint(LatLonPoint llp) {
+        float lat = getDecimalLatitude();
+        float lon = getDecimalLongitude();
+        if (llp == null) {
+            return new LatLonPoint(lat, lon);
+        } else {
+            llp.setLatLon(lat, lon);
+            return llp;
+        }
+    }
+
+    /**
+     * Returns the latitude as decimal degrees.
+     * 
+     * @return A float value for the latitude
+     */
+    public float getDecimalLatitude() {
+        float val = (lat_degrees + (lat_minutes * MINUTE) + (lat_seconds * SECOND));
+        return (lat_isnegative) ? -val : val;
+    }
+
+    /**
+     * Returns the longitude as decimal degrees.
+     * 
+     * @return A float value for the longitude
+     */
+    public float getDecimalLongitude() {
+        float val = (lon_degrees + (lon_minutes * MINUTE) + (lon_seconds * SECOND));
+        return (lon_isnegative) ? -val : val;
+    }
+
+    /**
+     * Returns a string representation of the object.
+     * 
+     * @return String representation
+     */
+    public String toString() {
+        return "DMSLatLonPoint[lat_isnegative = " + lat_isnegative
+                + ", lat_degrees = " + lat_degrees + ", lat_minutes = "
+                + lat_minutes + ", lat_seconds = " + lat_seconds
+                + ", lon_isnegative = " + lon_isnegative + ", lon_degrees = "
+                + lon_degrees + ", lon_minutes = " + lon_minutes
+                + ", lon_seconds = " + lon_seconds + "]";
+    }
+
+    /**
+     * Set DMSLatLonPoint. Sets the current instance values to be the
+     * same as another DMSLatLonPoint instance.
+     * 
+     * @param llpt DMSLatLonPoint
+     */
+    public void setDMSLatLon(DMSLatLonPoint llpt) {
+        lat_isnegative = llpt.lat_isnegative;
+        lat_degrees = llpt.lat_degrees;
+        lat_minutes = llpt.lat_minutes;
+        lat_seconds = llpt.lat_seconds;
+        lon_isnegative = llpt.lon_isnegative;
+        lon_degrees = llpt.lon_degrees;
+        lon_minutes = llpt.lon_minutes;
+        lon_seconds = llpt.lon_seconds;
+    }
+
+    /**
+     * Clone the DMSLatLonPoint.
+     * 
+     * @return clone
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            Assert.assertExp(false, "DMSLatLonPoint: internal error!");
+            return null;// statement not reached
+        }
+    }
+
+    /**
+     * Determines whether two DMSLatLonPoints are exactly equal.
+     * 
+     * @param obj Object
+     * @return boolean
+     */
+    public boolean equals(Object obj) {
+        if (obj instanceof DMSLatLonPoint) {
+            DMSLatLonPoint pt = (DMSLatLonPoint) obj;
+            return (pt.lat_isnegative == lat_isnegative
+                    && pt.lat_degrees == lat_degrees
+                    && pt.lat_minutes == lat_degrees
+                    && pt.lat_seconds == pt.lat_seconds
+                    && pt.lon_isnegative == lon_isnegative
+                    && pt.lon_degrees == lon_degrees
+                    && pt.lon_minutes == pt.lon_minutes && pt.lon_seconds == lon_seconds);
+        }
+        return false;
+    }
+
+    /**
+     * Sets the minutes and seconds to something sane.
+     * 
+     * @param val an int value for the minutes or seconds
+     * @return int value normalized
+     */
+    final public static int normalize_value(int val) {
+        val = val % 60;
+        if (val < 0) {
+            val += 60;
+        }
+        return val;
+    }
+
+    /**
+     * Sets the minutes and seconds to something sane.
+     * 
+     * @param val an float value for the minutes or seconds
+     * @return float value normalized
+     */
+    final public static float normalize_value(float val) {
+        val = val % 60f;
+        if (val < 0f) {
+            val += 60f;
+        }
+        return val;
+    }
+
+    /**
+     * Generate a hash value for the point. Hash by spreading the
+     * values across a 32 bit int, ignoring the sign allow 8 bits (max
+     * 255) for degrees, 7 bits (max 127) for (minutes + seconds) so
+     * the total is 30 bits.
+     * 
+     * @return An int hash value representing the point.
+     */
+    public int hashCode() {
+        return (lat_degrees | lon_degrees << 8
+                | (lat_minutes + (int) lat_seconds) << 16 | (lon_minutes + (int) lon_seconds) << 23);
+    }
+}


Property changes on: trunk/lib/com/bbn/openmap/proj/coords/DMSLatLonPoint.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,1162 @@
+// **********************************************************************
+//
+// <copyright>
+//
+// BBN Technologies
+// 10 Moulton Street
+// Cambridge, MA 02138
+// (617) 873-8000
+//
+// Copyright (C) BBNT Solutions LLC. All rights reserved.
+//
+// </copyright>
+// **********************************************************************
+//
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/coords/MGRSPoint.java,v $
+// $RCSfile: MGRSPoint.java,v $
+// $Revision: 1.5.2.5 $
+// $Date: 2005/02/11 22:51:27 $
+// $Author: dietrick $
+//
+// **********************************************************************
+
+package com.bbn.openmap.proj.coords;
+/*
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.LineNumberReader;
+import java.io.PrintStream;
+*/
+import ewe.io.BufferedInputStream;
+import ewe.io.File;
+import ewe.io.FileInputStream;
+import ewe.io.FileOutputStream;
+import ewe.io.IOException;
+import ewe.io.InputStreamReader;
+import ewe.io.LineNumberReader;
+import ewe.sys.Vm;
+import ewe.io.PrintWriter;
+
+
+import com.bbn.openmap.LatLonPoint;
+import com.bbn.openmap.proj.Ellipsoid;
+import com.bbn.openmap.util.ArgParser;
+//import com.bbn.openmap.util.Debug;
+
+/**
+ * A class representing a MGRS coordinate that has the ability to
+ * provide the decimal degree lat/lon equivalent, as well as the UTM
+ * equivalent. This class does not do checks to see if the MGRS
+ * coordiantes provided actually make sense. It assumes that the
+ * values are valid.
+ */
+public class MGRSPoint extends UTMPoint {
+
+    /**
+     * UTM zones are grouped, and assigned to one of a group of 6
+     * sets.
+     */
+    protected final static int NUM_100K_SETS = 6;
+    /**
+     * The column letters (for easting) of the lower left value, per
+     * set.
+     */
+    public final static int[] SET_ORIGIN_COLUMN_LETTERS = { 'A', 'J', 'S', 'A',
+            'J', 'S' };
+    /**
+     * The row letters (for northing) of the lower left value, per
+     * set.
+     */
+    public final static int[] SET_ORIGIN_ROW_LETTERS = { 'A', 'F', 'A', 'F',
+            'A', 'F' };
+    /**
+     * The column letters (for easting) of the lower left value, per
+     * set,, for Bessel Ellipsoid.
+     */
+    public final static int[] BESSEL_SET_ORIGIN_COLUMN_LETTERS = { 'A', 'J',
+            'S', 'A', 'J', 'S' };
+    /**
+     * The row letters (for northing) of the lower left value, per
+     * set, for Bessel Ellipsoid.
+     */
+    public final static int[] BESSEL_SET_ORIGIN_ROW_LETTERS = { 'L', 'R', 'L',
+            'R', 'L', 'R' };
+
+    public final static int SET_NORTHING_ROLLOVER = 20000000;
+    /**
+     * Use 5 digits for northing and easting values, for 1 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_1_METER = 5;
+    /**
+     * Use 4 digits for northing and easting values, for 10 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_10_METER = 4;
+    /**
+     * Use 3 digits for northing and easting values, for 100 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_100_METER = 3;
+    /**
+     * Use 2 digits for northing and easting values, for 1000 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_1000_METER = 2;
+    /**
+     * Use 1 digits for northing and easting values, for 10000 meter
+     * accuracy of coordinate.
+     */
+    public final static int ACCURACY_10000_METER = 1;
+
+    /** The set origin column letters to use. */
+    protected int[] originColumnLetters = SET_ORIGIN_COLUMN_LETTERS;
+    /** The set origin row letters to use. */
+    protected int[] originRowLetters = SET_ORIGIN_ROW_LETTERS;
+
+    public final static int A = 'A';
+    public final static int I = 'I';
+    public final static int O = 'O';
+    public final static int V = 'V';
+    public final static int Z = 'Z';
+
+    protected boolean DEBUG = false;
+
+    /** The String holding the MGRS coordinate value. */
+    protected String mgrs;
+
+    /**
+     * Controls the number of digits that the MGRS coordinate will
+     * have, which directly affects the accuracy of the coordinate.
+     * Default is ACCURACY_1_METER, which indicates that MGRS
+     * coordinates will have 10 digits (5 easting, 5 northing) after
+     * the 100k two letter code, indicating 1 meter resolution.
+     */
+    protected int accuracy = ACCURACY_1_METER;
+
+    /**
+     * Point to create if you are going to use the static methods to
+     * fill the values in.
+     */
+    public MGRSPoint() {
+//        DEBUG = Debug.debugging("mgrs");
+    	//DEBUG = true;
+    }
+
+    /**
+     * Constructs a new MGRS instance from a MGRS String.
+     */
+    public MGRSPoint(String mgrsString) {
+        this();
+        setMGRS(mgrsString);
+    }
+
+    /**
+     * Contructs a new MGRSPoint instance from values in another
+     * MGRSPoint.
+     */
+    public MGRSPoint(MGRSPoint point) {
+        this();
+        mgrs = point.mgrs;
+        northing = point.northing;
+        easting = point.easting;
+        zone_number = point.zone_number;
+        zone_letter = point.zone_letter;
+        accuracy = point.accuracy;
+    }
+
+    /**
+     * Create a MGRSPoint from UTM values;
+     */
+    public MGRSPoint(float northing, float easting, int zoneNumber,
+            char zoneLetter) {
+        super(northing, easting, zoneNumber, zoneLetter);
+    }
+
+    /**
+     * Contruct a MGRSPoint from a LatLonPoint, assuming a WGS_84
+     * ellipsoid.
+     */
+    public MGRSPoint(LatLonPoint llpoint) {
+        this(llpoint, Ellipsoid.WGS_84);
+    }
+
+    /**
+     * Construct a MGRSPoint from a LatLonPoint and a particular
+     * ellipsoid.
+     */
+    public MGRSPoint(LatLonPoint llpoint, Ellipsoid ellip) {
+        this();
+        LLtoMGRS(llpoint, ellip, this);
+    }
+
+    /**
+     * Set the MGRS value for this Point. Will be decoded, and the UTM
+     * values figured out. You can call toLatLonPoint() to translate
+     * it to lat/lon decimal degrees.
+     */
+    public void setMGRS(String mgrsString) {
+        try {
+            mgrs = mgrsString.toUpperCase(); // Just to make sure.
+            decode(mgrs);
+        } catch (StringIndexOutOfBoundsException sioobe) {
+            throw new NumberFormatException("MGRSPoint has bad string: "
+                    + mgrsString);
+        } catch (NullPointerException npe) {
+            // Blow off
+        }
+    }
+
+    /**
+     * Get the MGRS string value - the honkin' coordinate value.
+     */
+    public String getMGRS() {
+        if (mgrs == null) {
+            resolve();
+        }
+        return mgrs;
+    }
+
+    /**
+     * Convert this MGRSPoint to a LatLonPoint, and assume a WGS_84
+     * ellisoid.
+     */
+    public LatLonPoint toLatLonPoint() {
+        return toLatLonPoint(Ellipsoid.WGS_84, new LatLonPoint());
+    }
+
+    /**
+     * Convert this MGRSPoint to a LatLonPoint, and use the given
+     * ellipsoid.
+     */
+    public LatLonPoint toLatLonPoint(Ellipsoid ellip) {
+        return toLatLonPoint(ellip, new LatLonPoint());
+    }
+
+    /**
+     * Fill in the given LatLonPoint with the converted values of this
+     * MGRSPoint, and use the given ellipsoid.
+     */
+    public LatLonPoint toLatLonPoint(Ellipsoid ellip, LatLonPoint llpoint) {
+        return MGRStoLL(this, ellip, llpoint);
+    }
+
+    /**
+     * Returns a string representation of the object.
+     * 
+     * @return String representation
+     */
+    public String toString() {
+        return "MGRSPoint[" + mgrs + "]";
+    }
+
+    /**
+     * Create a LatLonPoint from a MGRSPoint.
+     * 
+     * @param mgrsp to convert.
+     * @param ellip Ellipsoid for earth model.
+     * @param llp a LatLonPoint to fill in values for. If null, a new
+     *        LatLonPoint will be returned. If not null, the new
+     *        values will be set in this object, and it will be
+     *        returned.
+     * @return LatLonPoint with values converted from MGRS coordinate.
+     */
+    public static LatLonPoint MGRStoLL(MGRSPoint mgrsp, Ellipsoid ellip,
+                                       LatLonPoint llp) {
+        return UTMtoLL(mgrsp, ellip, llp);
+    }
+
+    /**
+     * Converts a LatLonPoint to a MGRS Point, assuming the WGS_84
+     * ellipsoid.
+     * 
+     * @return MGRSPoint, or null if something bad happened.
+     */
+    public static MGRSPoint LLtoMGRS(LatLonPoint llpoint) {
+        return LLtoMGRS(llpoint, Ellipsoid.WGS_84, new MGRSPoint());
+    }
+
+    /**
+     * Converts a LatLonPoint to a MGRS Point.
+     * 
+     * @param llpoint the LatLonPoint to convert.
+     * @param mgrsp a MGRSPoint to put the results in. If it's null, a
+     *        MGRSPoint will be allocated.
+     * @return MGRSPoint, or null if something bad happened. If a
+     *         MGRSPoint was passed in, it will also be returned on a
+     *         successful conversion.
+     */
+    public static MGRSPoint LLtoMGRS(LatLonPoint llpoint, MGRSPoint mgrsp) {
+        return LLtoMGRS(llpoint, Ellipsoid.WGS_84, mgrsp);
+    }
+
+    /**
+     * Create a MGRSPoint from a LatLonPoint.
+     * 
+     * @param llp LatLonPoint to convert.
+     * @param ellip Ellipsoid for earth model.
+     * @param mgrsp a MGRSPoint to fill in values for. If null, a new
+     *        MGRSPoint will be returned. If not null, the new values
+     *        will be set in this object, and it will be returned.
+     * @return MGRSPoint with values converted from lat/lon.
+     */
+    public static MGRSPoint LLtoMGRS(LatLonPoint llp, Ellipsoid ellip,
+                                     MGRSPoint mgrsp) {
+        mgrsp = (MGRSPoint) LLtoUTM(llp, ellip, mgrsp);
+        mgrsp.resolve();
+        return mgrsp;
+    }
+
+    /**
+     * Convert MGRS zone letter to UTM zone letter, N or S.
+     * @param mgrsZone
+     * @return N of given zone is equal or larger than N, S otherwise.
+     */
+    public static char MGRSZoneToUTMZone(char mgrsZone) {
+        if (Character.toUpperCase(mgrsZone) >= 'N') {
+            return 'N';
+        } else {
+            return 'S';
+        }
+    }
+
+    /**
+     * Method that provides a check for MGRS zone letters. Returns an
+     * uppercase version of any valid letter passed in.
+     */
+    protected char checkZone(char zone) {
+        zone = Character.toUpperCase(zone);
+
+        if (zone <= 'A' || zone == 'B' || zone == 'Y' || zone >= 'Z'
+                || zone == 'I' || zone == 'O') {
+            throw new NumberFormatException("Invalid MGRSPoint zone letter: "
+                    + zone);
+        }
+
+        return zone;
+    }
+
+    /**
+     * Determines the correct MGRS letter designator for the given
+     * latitude returns 'Z' if latitude is outside the MGRS limits of
+     * 84N to 80S.
+     * 
+     * @param Lat The float value of the latitude.
+     * 
+     * @return A char value which is the MGRS zone letter.
+     */
+    public  char getLetterDesignator(double lat) {
+
+        //This is here as an error flag to show that the Latitude is
+        //outside MGRS limits
+        char LetterDesignator = 'Z';
+
+        if ((84 >= lat) && (lat >= 72))
+            LetterDesignator = 'X';
+        else if ((72 > lat) && (lat >= 64))
+            LetterDesignator = 'W';
+        else if ((64 > lat) && (lat >= 56))
+            LetterDesignator = 'V';
+        else if ((56 > lat) && (lat >= 48))
+            LetterDesignator = 'U';
+        else if ((48 > lat) && (lat >= 40))
+            LetterDesignator = 'T';
+        else if ((40 > lat) && (lat >= 32))
+            LetterDesignator = 'S';
+        else if ((32 > lat) && (lat >= 24))
+            LetterDesignator = 'R';
+        else if ((24 > lat) && (lat >= 16))
+            LetterDesignator = 'Q';
+        else if ((16 > lat) && (lat >= 8))
+            LetterDesignator = 'P';
+        else if ((8 > lat) && (lat >= 0))
+            LetterDesignator = 'N';
+        else if ((0 > lat) && (lat >= -8))
+            LetterDesignator = 'M';
+        else if ((-8 > lat) && (lat >= -16))
+            LetterDesignator = 'L';
+        else if ((-16 > lat) && (lat >= -24))
+            LetterDesignator = 'K';
+        else if ((-24 > lat) && (lat >= -32))
+            LetterDesignator = 'J';
+        else if ((-32 > lat) && (lat >= -40))
+            LetterDesignator = 'H';
+        else if ((-40 > lat) && (lat >= -48))
+            LetterDesignator = 'G';
+        else if ((-48 > lat) && (lat >= -56))
+            LetterDesignator = 'F';
+        else if ((-56 > lat) && (lat >= -64))
+            LetterDesignator = 'E';
+        else if ((-64 > lat) && (lat >= -72))
+            LetterDesignator = 'D';
+        else if ((-72 > lat) && (lat >= -80))
+            LetterDesignator = 'C';
+        return LetterDesignator;
+    }
+
+    /**
+     * Set the number of digits to use for easting and northing
+     * numbers in the mgrs string, which reflects the accuracy of the
+     * corrdinate. From 5 (1 meter) to 1 (10,000 meter).
+     */
+    public void setAccuracy(int value) {
+        accuracy = value;
+        mgrs = null;
+    }
+
+    public int getAccuracy() {
+        return accuracy;
+    }
+
+    /**
+     * Set the UTM parameters from a MGRS string.
+     * 
+     * @param mgrsString an UPPERCASE coordinate string is expected.
+     */
+    protected void decode(String mgrsString) throws NumberFormatException {
+
+        if (mgrsString == null || mgrsString.length() == 0) {
+            throw new NumberFormatException("MGRSPoint coverting from nothing");
+        }
+
+        int length = mgrsString.length();
+
+        String hunK = null;
+        String seasting = null;
+        String snorthing = null;
+
+        StringBuffer sb = new StringBuffer();
+        char testChar;
+        int i = 0;
+
+        // get Zone number
+        while (!Character.isLetter(testChar = mgrsString.charAt(i))) {
+            if (i > 2) {
+                throw new NumberFormatException("MGRSPoint bad conversion from: "
+                        + mgrsString);
+            }
+            sb.append(testChar);
+            i++;
+        }
+
+        zone_number = Integer.parseInt(sb.toString());
+
+        if (i == 0 || i + 3 > length) {
+            // A good MGRS string has to be 4-5 digits long,
+            // ##AAA/#AAA at least.
+            throw new NumberFormatException("MGRSPoint bad conversion from: "
+                    + mgrsString);
+        }
+
+        zone_letter = mgrsString.charAt(i++);
+
+        // Should we check the zone letter here? Why not.
+        if (zone_letter <= 'A' || zone_letter == 'B' || zone_letter == 'Y'
+                || zone_letter >= 'Z' || zone_letter == 'I'
+                || zone_letter == 'O') {
+            throw new NumberFormatException("MGRSPoint zone letter "
+                    + (char) zone_letter + " not handled: " + mgrsString);
+        }
+
+        hunK = mgrsString.substring(i, i += 2);
+
+        int set = get100kSetForZone(zone_number);
+
+        float east100k = getEastingFromChar(hunK.charAt(0), set);
+        float north100k = getNorthingFromChar(hunK.charAt(1), set);
+
+        // We have a bug where the northing may be 2000000 too low.
+        // How
+        // do we know when to roll over?
+
+        while (north100k < getMinNorthing(zone_letter)) {
+            north100k += 2000000;
+        }
+
+        // calculate the char index for easting/northing separator
+        int remainder = length - i;
+
+        if (remainder % 2 != 0) {
+            throw new NumberFormatException("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"
+                    + mgrsString);
+        }
+
+        int sep = remainder / 2;
+
+        float sepEasting = 0f;
+        float sepNorthing = 0f;
+
+        if (sep > 0) {
+            if (DEBUG)
+                Vm.debug(" calculating e/n from " + mgrs.substring(i));
+            float accuracyBonus = 100000f / (float) Math.pow(10, sep);
+            if (DEBUG)
+                Vm.debug(" calculated accuracy bonus as  " + accuracyBonus);
+            String sepEastingString = mgrsString.substring(i, i + sep);
+            if (DEBUG)
+                Vm.debug(" parsed easting as " + sepEastingString);
+            sepEasting = Float.parseFloat(sepEastingString) * accuracyBonus;
+            String sepNorthingString = mgrsString.substring(i + sep);
+            if (DEBUG)
+                Vm.debug(" parsed northing as " + sepNorthingString);
+            sepNorthing = Float.parseFloat(sepNorthingString) * accuracyBonus;
+        }
+
+        easting = sepEasting + east100k;
+        northing = sepNorthing + north100k;
+
+        if (DEBUG) {
+            Vm.debug("Decoded " + mgrsString + " as zone number: "
+                    + zone_number + ", zone letter: " + zone_letter
+                    + ", easting: " + easting + ", northing: " + northing
+                    + ", 100k: " + hunK);
+        }
+    }
+
+    /**
+     * Create the mgrs string based on the internal UTM settings,
+     * using the accuracy set in the MGRSPoint.
+     */
+    protected void resolve() {
+        resolve(accuracy);
+    }
+
+    /**
+     * Create the mgrs string based on the internal UTM settings.
+     * 
+     * @param digitAccuracy The number of digits to use for the
+     *        northing and easting numbers. 5 digits reflect a 1 meter
+     *        accuracy, 4 - 10 meter, 3 - 100 meter, 2 - 1000 meter, 1 -
+     *        10,000 meter.
+     */
+    protected void resolve(int digitAccuracy) {
+        if (zone_letter == 'Z') {
+            mgrs = "Latitude limit exceeded";
+        } else {
+            StringBuffer sb = new StringBuffer(zone_number + ""
+                    + (char) zone_letter
+                    + get100kID(easting, northing, zone_number));
+            StringBuffer seasting = new StringBuffer(Integer.toString((int) easting));
+            StringBuffer snorthing = new StringBuffer(Integer.toString((int) northing));
+
+            if (DEBUG) {
+                Vm.debug(" Resolving MGRS from easting: " + seasting
+                        + " derived from " + easting + ", and northing: "
+                        + snorthing + " derived from " + northing);
+            }
+
+            while (digitAccuracy + 1 > seasting.length()) {
+                seasting.insert(0, '0');
+            }
+
+            // We have to be careful here, the 100k values shouldn't
+            // be
+            // used for calculating stuff here.
+
+            while (digitAccuracy + 1 > snorthing.length()) {
+                snorthing.insert(0, '0');
+            }
+
+            while (snorthing.length() > 6) {
+                snorthing.deleteCharAt(0);
+            }
+
+            if (DEBUG) {
+                Vm.debug(" -- modified easting: " + seasting
+                        + " and northing: " + snorthing);
+            }
+
+            try {
+                sb.append(seasting.substring(1, digitAccuracy + 1)
+                        + snorthing.substring(1, digitAccuracy + 1));
+
+                mgrs = sb.toString();
+            } catch (IndexOutOfBoundsException ioobe) {
+                mgrs = null;
+            }
+        }
+    }
+
+    /**
+     * Given a UTM zone number, figure out the MGRS 100K set it is in.
+     */
+    protected int get100kSetForZone(int i) {
+        int set = i % NUM_100K_SETS;
+        if (set == 0)
+            set = NUM_100K_SETS;
+        return set;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the first letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected int[] getOriginColumnLetters() {
+        return originColumnLetters;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the first letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected void setOriginColumnLetters(int[] letters) {
+        originColumnLetters = letters;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the second letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected int[] getOriginRowLetters() {
+        return originRowLetters;
+    }
+
+    /**
+     * Provided so that extensions to this class can provide different
+     * origin letters, in case of different ellipsoids. The int[]
+     * represents all of the second letters in the bottom left corner
+     * of each set box, as shown in an MGRS 100K box layout.
+     */
+    protected void setOriginRowLetters(int[] letters) {
+        originRowLetters = letters;
+    }
+
+    /**
+     * Get the two letter 100k designator for a given UTM easting,
+     * northing and zone number value.
+     */
+    protected String get100kID(float easting, float northing, int zone_number) {
+        int set = get100kSetForZone(zone_number);
+        int setColumn = ((int) easting / 100000);
+        int setRow = ((int) northing / 100000) % 20;
+        return get100kID(setColumn, setRow, set);
+    }
+
+    /**
+     * Given the first letter from a two-letter MGRS 100k zone, and
+     * given the MGRS table set for the zone number, figure out the
+     * easting value that should be added to the other, secondary
+     * easting value.
+     */
+    protected float getEastingFromChar(char e, int set) {
+        int baseCol[] = getOriginColumnLetters();
+        // colOrigin is the letter at the origin of the set for the
+        // column
+        int curCol = baseCol[set - 1];
+        float eastingValue = 100000f;
+        boolean rewindMarker = false;
+
+        while (curCol != e) {
+            curCol++;
+            if (curCol == I)
+                curCol++;
+            if (curCol == O)
+                curCol++;
+            if (curCol > Z) {
+                if (rewindMarker) {
+                    throw new NumberFormatException("Bad character: " + e);
+                }
+                curCol = A;
+                rewindMarker = true;
+            }
+            eastingValue += 100000f;
+        }
+
+        if (DEBUG) {
+            Vm.debug("Easting value for " + (char) e + " from set: " + set
+                    + ", col: " + curCol + " is " + eastingValue);
+        }
+        return eastingValue;
+    }
+
+    /**
+     * Given the second letter from a two-letter MGRS 100k zone, and
+     * given the MGRS table set for the zone number, figure out the
+     * northing value that should be added to the other, secondary
+     * northing value. You have to remember that Northings are
+     * determined from the equator, and the vertical cycle of letters
+     * mean a 2000000 additional northing meters. This happens approx.
+     * every 18 degrees of latitude. This method does *NOT* count any
+     * additional northings. You have to figure out how many 2000000
+     * meters need to be added for the zone letter of the MGRS
+     * coordinate.
+     * 
+     * @param n second letter of the MGRS 100k zone
+     * @param set the MGRS table set number, which is dependent on the
+     *        UTM zone number.
+     */
+    protected float getNorthingFromChar(char n, int set) {
+
+        if (n > 'V') {
+            throw new NumberFormatException("MGRSPoint given invalid Northing "
+                    + n);
+        }
+
+        int baseRow[] = getOriginRowLetters();
+        // rowOrigin is the letter at the origin of the set for the
+        // column
+        int curRow = baseRow[set - 1];
+        float northingValue = 0f;
+        boolean rewindMarker = false;
+
+        while (curRow != n) {
+            curRow++;
+            if (curRow == I)
+                curRow++;
+            if (curRow == O)
+                curRow++;
+            // fixing a bug making whole application hang in this loop
+            // when 'n' is a wrong character
+            if (curRow > V) {
+                if (rewindMarker) { //making sure that this loop ends
+                    throw new NumberFormatException("Bad character: " + n);
+                }
+                curRow = A;
+                rewindMarker = true;
+            }
+            northingValue += 100000f;
+        }
+
+        if (DEBUG) {
+            Vm.debug("Northing value for " + (char) n + " from set: " + set
+                    + ", row: " + curRow + " is " + northingValue);
+        }
+
+        return northingValue;
+    }
+
+    /**
+     * Get the two-letter MGRS 100k designator given information
+     * translated from the UTM northing, easting and zone number.
+     * 
+     * @param setColumn the column index as it relates to the MGRS
+     *        100k set spreadsheet, created from the UTM easting.
+     *        Values are 1-8.
+     * @param setRow the row index as it relates to the MGRS 100k set
+     *        spreadsheet, created from the UTM northing value. Values
+     *        are from 0-19.
+     * @param set the set block, as it relates to the MGRS 100k set
+     *        spreadsheet, created from the UTM zone. Values are from
+     *        1-60.
+     * @return two letter MGRS 100k code.
+     */
+    protected String get100kID(int setColumn, int setRow, int set) {
+
+        if (DEBUG) {
+        	
+            Vm.debug("set (" + set + ") column = " + setColumn
+                    + ", row = " + setRow);
+        }
+
+        int baseCol[] = getOriginColumnLetters();
+        int baseRow[] = getOriginRowLetters();
+
+        // colOrigin and rowOrigin are the letters at the origin of
+        // the set
+        int colOrigin = baseCol[set - 1];
+        int rowOrigin = baseRow[set - 1];
+
+        if (DEBUG) {
+        	Vm.debug("starting at = " + (char) colOrigin
+                    + (char) rowOrigin);
+        }
+
+        // colInt and rowInt are the letters to build to return
+        int colInt = colOrigin + setColumn - 1;
+        int rowInt = rowOrigin + setRow;
+        boolean rollover = false;
+
+        if (colInt > Z) {
+            colInt = colInt - Z + A - 1;
+            rollover = true;
+            if (DEBUG)
+                Vm.debug("rolling over col, new value: "
+                        + (char) colInt);
+        }
+
+        if (colInt == I || (colOrigin < I && colInt > I)
+                || ((colInt > I || colOrigin < I) && rollover)) {
+            colInt++;
+            if (DEBUG)
+                Vm.debug("skipping I in col, new value: "
+                        + (char) colInt);
+        }
+        if (colInt == O || (colOrigin < O && colInt > O)
+                || ((colInt > O || colOrigin < O) && rollover)) {
+            colInt++;
+            if (DEBUG)
+                Vm.debug("skipping O in col, new value: "
+                        + (char) colInt);
+            if (colInt == I) {
+                colInt++;
+                if (DEBUG)
+                    Vm.debug("  hit I, new value: " + (char) colInt);
+            }
+        }
+
+        if (colInt > Z) {
+            colInt = colInt - Z + A - 1;
+            if (DEBUG)
+                Vm.debug("rolling(2) col, new value: "
+                        + (char) rowInt);
+        }
+
+        if (rowInt > V) {
+            rowInt = rowInt - V + A - 1;
+            rollover = true;
+            if (DEBUG)
+                Vm.debug("rolling over row, new value: "
+                        + (char) rowInt);
+        } else {
+            rollover = false;
+        }
+
+        if (rowInt == I || (rowOrigin < I && rowInt > I)
+                || ((rowInt > I || rowOrigin < I) && rollover)) {
+            rowInt++;
+            if (DEBUG)
+                Vm.debug("skipping I in row, new value: "
+                        + (char) rowInt);
+        }
+
+        if (rowInt == O || (rowOrigin < O && rowInt > O)
+                || ((rowInt > O || rowOrigin < O) && rollover)) {
+            rowInt++;
+            if (DEBUG)
+                Vm.debug("skipping O in row, new value: "
+                        + (char) rowInt);
+            if (rowInt == I) {
+                rowInt++;
+                if (DEBUG)
+                    Vm.debug("  hit I, new value: " + (char) rowInt);
+            }
+        }
+
+        if (rowInt > V) {
+            rowInt = rowInt - V + A - 1;
+            if (DEBUG)
+                Vm.debug("rolling(2) row, new value: "
+                        + (char) rowInt);
+        }
+
+        String twoLetter = (char) colInt + "" + (char) rowInt;
+
+        if (DEBUG) {
+            Vm.debug("ending at = " + twoLetter);
+        }
+
+        return twoLetter;
+    }
+
+    /**
+     * Testing method, used to print out the MGRS 100k two letter set
+     * tables.
+     */
+    protected void print100kSets() {
+        StringBuffer sb = null;
+        for (int set = 1; set <= 6; set++) {
+            Vm.debug("-------------\nFor 100K Set " + set
+                    + ":\n-------------\n");
+            for (int i = 19; i >= 0; i -= 1) {
+                sb = new StringBuffer((i * 100000) + "\t| ");
+
+                for (int j = 1; j <= 8; j++) {
+                    sb.append(" " + get100kID(j, i, set));
+                }
+
+                sb.append(" |");
+                Vm.debug(sb.toString());
+            }
+        }
+    }
+
+    /**
+     * The function getMinNorthing returns the minimum northing value
+     * of a MGRS zone.
+     * 
+     * portted from Geotrans' c Lattitude_Band_Value strucure table.
+     * zoneLetter : MGRS zone (input)
+     */
+
+    protected float getMinNorthing(char zoneLetter)
+            throws NumberFormatException {
+        float northing;
+        switch (zoneLetter) {
+        case 'C':
+            northing = 1100000.0f;
+            break;
+        case 'D':
+            northing = 2000000.0f;
+            break;
+        case 'E':
+            northing = 2800000.0f;
+            break;
+        case 'F':
+            northing = 3700000.0f;
+            break;
+        case 'G':
+            northing = 4600000.0f;
+            break;
+        case 'H':
+            northing = 5500000.0f;
+            break;
+        case 'J':
+            northing = 6400000.0f;
+            break;
+        case 'K':
+            northing = 7300000.0f;
+            break;
+        case 'L':
+            northing = 8200000.0f;
+            break;
+        case 'M':
+            northing = 9100000.0f;
+            break;
+        case 'N':
+            northing = 0.0f;
+            break;
+        case 'P':
+            northing = 800000.0f;
+            break;
+        case 'Q':
+            northing = 1700000.0f;
+            break;
+        case 'R':
+            northing = 2600000.0f;
+            break;
+        case 'S':
+            northing = 3500000.0f;
+            break;
+        case 'T':
+            northing = 4400000.0f;
+            break;
+        case 'U':
+            northing = 5300000.0f;
+            break;
+        case 'V':
+            northing = 6200000.0f;
+            break;
+        case 'W':
+            northing = 7000000.0f;
+            break;
+        case 'X':
+            northing = 7900000.0f;
+            break;
+        default:
+            northing = -1.0f;
+        }
+        if (northing >= 0.0) {
+            return northing;
+        } else {
+            throw new NumberFormatException("Invalid zone letter: "
+                    + zone_letter);
+        }
+
+    }
+    private static void runTests(String fName, String inType) {
+
+        LineNumberReader lnr = null;
+        PrintWriter pos = null;
+//        PrintStream pos = null;
+        String record = null;
+        StringBuffer outStr1 = new StringBuffer();
+        StringBuffer outStr2 = new StringBuffer();
+
+        try {
+
+            /*
+             * File inFile = new File(fName + ".dat"); File outFile =
+             * new File(fName + ".out"); FileInputStream fis = new
+             * FileInputStream(inFile); FileOutputStream fos = new
+             * FileOutputStream(outFile); BufferedInputStream bis =
+             * new BufferedInputStream(fis);
+             */
+        	//pos = new PrintStream(new FileOutputStream(new File(fName + ".out")));
+        	pos = new PrintWriter(new FileOutputStream(new File(fName + ".out")));
+
+            lnr = new LineNumberReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(new File(fName)))));
+
+            if (inType.equalsIgnoreCase("MGRS")) {
+                outStr1.append("MGRS to LatLonPoint\n\tMGRS\t\tLatitude   Longitude\n");
+                outStr2.append("MGRS to UTM\n\tMGRS\t\tZone Easting Northing\n");
+            } else if (inType.equalsIgnoreCase("UTM")) {
+                outStr1.append("UTM to LatLonPoint\n\tUTM\t\tLatitude   Longitude\n");
+                outStr2.append("UTM to MGRS\n\tUTM\t\tMGRS\n");
+            } else if (inType.equalsIgnoreCase("LatLon")) {
+                outStr1.append("LatLonPoint to UTM\nLatitude   Longitude\t\tZone Easting Northing     \n");
+                outStr2.append("LatLonPoint to MGRS\nLatitude   Longitude\t\tMGRS\n");
+            }
+
+            while ((record = lnr.readLine()) != null) {
+                if (inType.equalsIgnoreCase("MGRS")) {
+                    try {
+                        MGRSPoint mgrsp = new MGRSPoint(record);
+                        record.trim();
+                        mgrsp.decode(record);
+
+                        outStr1.append(record + " is " + mgrsp.toLatLonPoint()
+                                + "\n");
+                        outStr2.append(record + " to UTM: " + mgrsp.zone_number
+                                + " " + mgrsp.easting + " " + mgrsp.northing
+                                + "\n");
+                    } catch (NumberFormatException nfe) {
+                        Vm.debug(nfe.getMessage());
+                    }
+
+                } else if (inType.equalsIgnoreCase("UTM")) {
+                    MGRSPoint mgrsp;
+                    UTMPoint utmp;
+                    float e, n;
+                    int z;
+                    char zl;
+                    String tmp;
+                    record.trim();
+                    tmp = record.substring(0, 2);
+                    z = Integer.parseInt(tmp);
+                    tmp = record.substring(5, 11);
+                    e = Float.parseFloat(tmp);
+                    tmp = record.substring(12, 19);
+                    n = Float.parseFloat(tmp);
+                    zl = record.charAt(3);
+                    utmp = new UTMPoint(n, e, z, zl);
+                    LatLonPoint llp = utmp.toLatLonPoint();
+                    mgrsp = LLtoMGRS(llp);
+                    outStr1.append(record + " is " + llp + " back to "
+                            + LLtoUTM(llp) + "\n");
+                    outStr2.append(record + " is " + mgrsp + "\n");
+                } else if (inType.equalsIgnoreCase("LatLon")) {
+                    MGRSPoint mgrsp;
+                    UTMPoint utmp;
+                    LatLonPoint llp;
+                    float lat, lon;
+                    int index;
+                    String tmp;
+                    record.trim();
+                    index = record.indexOf("\040");
+                    if (index < 0) {
+                        index = record.indexOf("\011");
+                    }
+                    tmp = record.substring(0, index);
+                    lat = Float.parseFloat(tmp);
+                    tmp = record.substring(index);
+                    lon = Float.parseFloat(tmp);
+                    llp = new LatLonPoint(lat, lon);
+                    utmp = LLtoUTM(llp);
+                    mgrsp = LLtoMGRS(llp);
+                    outStr1.append(record + " to UTM: " + mgrsp.zone_number
+                            + " " + mgrsp.easting + " " + mgrsp.northing + "\n");
+                    outStr2.append(record + "    ->    " + mgrsp.mgrs + "\n");
+                }
+
+            }
+
+        } catch (IOException e) {
+            // catch io errors from FileInputStream or readLine()
+            Vm.debug("IO error: " + e.getMessage());
+
+        } finally {
+            if (pos != null) {
+                pos.print(outStr1.toString());
+                pos.print("\n");
+                pos.print(outStr2.toString());
+                pos.close();
+            }
+            // if the file opened okay, make sure we close it
+            if (lnr != null) {
+                try {
+                    lnr.close();
+                } catch (IOException ioe) {
+                }
+            }
+
+        }
+
+    }
+
+    public static void main(String[] argv) {
+//        Debug.init();
+
+        ArgParser ap = new ArgParser("MGRSPoint");
+        ap.add("mgrs", "Print Latitude and Longitude for MGRS value", 1);
+        ap.add("latlon",
+                "Print MGRS for Latitude and Longitude values",
+                2,
+                true);
+        ap.add("sets", "Print the MGRS 100k table");
+        ap.add("altsets", "Print the MGRS 100k table for the Bessel ellipsoid");
+        ap.add("rtc",
+                "Run test case, with filename and input data type [MGRS | UTM | LatLon]",
+                2);
+
+        if (!ap.parse(argv)) {
+            ap.printUsage();
+            System.exit(0);
+        }
+
+        String arg[];
+        arg = ap.getArgValues("sets");
+        if (arg != null) {
+            new MGRSPoint().print100kSets();
+        }
+
+        arg = ap.getArgValues("altsets");
+        if (arg != null) {
+            MGRSPoint mgrsp = new MGRSPoint();
+            mgrsp.setOriginColumnLetters(BESSEL_SET_ORIGIN_COLUMN_LETTERS);
+            mgrsp.setOriginRowLetters(BESSEL_SET_ORIGIN_ROW_LETTERS);
+            mgrsp.print100kSets();
+        }
+
+        arg = ap.getArgValues("mgrs");
+        if (arg != null) {
+            try {
+                MGRSPoint mgrsp = new MGRSPoint(arg[0]);
+                Vm.debug(arg[0] + " is " + mgrsp.toLatLonPoint());
+            } catch (NumberFormatException nfe) {
+                Vm.debug(nfe.getMessage());
+            }
+        }
+
+        arg = ap.getArgValues("latlon");
+        if (arg != null) {
+            try {
+
+                float lat = Float.parseFloat(arg[0]);
+                float lon = Float.parseFloat(arg[1]);
+
+                LatLonPoint llp = new LatLonPoint(lat, lon);
+                MGRSPoint mgrsp = LLtoMGRS(llp);
+                UTMPoint utmp = LLtoUTM(llp);
+
+                if (utmp.zone_letter == 'Z') {
+                    Vm.debug(llp + "to UTM: latitude limit exceeded.");
+                } else {
+                    Vm.debug(llp + " is " + utmp);
+                }
+
+                Vm.debug(llp + " is " + mgrsp);
+
+            } catch (NumberFormatException nfe) {
+                Vm.debug("The numbers provided:  " + argv[0] + ", "
+                        + argv[1] + " aren't valid");
+            }
+        }
+
+        arg = ap.getArgValues("rtc");
+        if (arg != null) {
+            runTests(arg[0], arg[1]);
+        }
+
+    }
+}
+


Property changes on: trunk/lib/com/bbn/openmap/proj/coords/MGRSPoint.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.java
===================================================================
--- trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,548 @@
+// **********************************************************************
+//
+// <copyright>
+//
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+//
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+//
+// </copyright>
+// **********************************************************************
+//
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/proj/coords/UTMPoint.java,v $
+// $RCSfile: UTMPoint.java,v $
+// $Revision: 1.4.2.4 $
+// $Date: 2005/02/11 22:51:27 $
+// $Author: dietrick $
+//
+// **********************************************************************
+
+package com.bbn.openmap.proj.coords;
+
+import com.bbn.openmap.LatLonPoint;
+import com.bbn.openmap.proj.Ellipsoid;
+import com.bbn.openmap.proj.ProjMath;
+
+/**
+ * A class representing a UTM co-ordinate.
+ * <p>
+ * 
+ * Adapted to Java by Colin Mummery (colin_mummery at yahoo.com) from C++
+ * code by Chuck Gantz (chuck.gantz at globalstar.com)
+ */
+public class UTMPoint {
+
+    /**
+     * The northing component of the coordinate.
+     */
+    public float northing;
+    /**
+     * The easting component of the coordinate.
+     */
+    public float easting;
+    /**
+     * The zone number of the coordinate, must be between 1 and 60.
+     */
+    public int zone_number;
+    /**
+     * For UTM, 'N' or 'S', to designate the northern or southern
+     * hemisphere.
+     */
+    public char zone_letter;
+
+    /**
+     * Point to create if you are going to use the static methods to
+     * fill the values in.
+     */
+    public UTMPoint() {}
+
+    /**
+     * Constructs a new UTM instance.
+     * 
+     * @param northing The northing component.
+     * @param easting The easting component.
+     * @param zone_number The zone of the coordinate.
+     * @param zone_letter. For UTM, 'N' or 'S', to designate the
+     *        northern or southern hemisphere.
+     * @throws Number format exception of N or S isn't used.
+     */
+    public UTMPoint(float northing, float easting, int zone_number,
+            char zone_letter) {
+        this.northing = (float) Math.rint(northing);
+        this.easting = (float) Math.rint(easting);
+        this.zone_number = zone_number;
+        this.zone_letter = checkZone(zone_letter);
+    }
+
+    /**
+     * Contructs a new UTMPoint instance from values in another
+     * UTMPoint.
+     */
+    public UTMPoint(UTMPoint point) {
+        this(point.northing,
+             point.easting,
+             point.zone_number,
+             point.zone_letter);
+    }
+
+    /**
+     * Contruct a UTMPoint from a LatLonPoint, assuming a WGS_84
+     * ellipsoid.
+     */
+    public UTMPoint(LatLonPoint llpoint) {
+        this(llpoint, Ellipsoid.WGS_84);
+    }
+
+    /**
+     * Construct a UTMPoint from a LatLonPoint and a particular
+     * ellipsoid.
+     */
+    public UTMPoint(LatLonPoint llpoint, Ellipsoid ellip) {
+        this();
+        LLtoUTM(llpoint, ellip, this);
+    }
+
+    /**
+     * Method that provides a check for UTM zone letters. Returns an
+     * uppercase version of any valid letter passed in, 'N' or 'S'.
+     * 
+     * @throws NumberFormatException if zone letter is invalid.
+     */
+    protected char checkZone(char zone) {
+        zone = Character.toUpperCase(zone);
+
+        if (zone != 'N' && zone != 'S') {
+            throw new NumberFormatException("Invalid UTMPoint zone letter: "
+                    + zone);
+        }
+
+        return zone;
+    }
+
+    /**
+     * Convert this UTMPoint to a LatLonPoint, and assume a WGS_84
+     * ellisoid.
+     */
+    public LatLonPoint toLatLonPoint() {
+        return UTMtoLL(this, Ellipsoid.WGS_84, new LatLonPoint());
+    }
+
+    /**
+     * Convert this UTMPoint to a LatLonPoint, and use the given
+     * ellipsoid.
+     */
+    public LatLonPoint toLatLonPoint(Ellipsoid ellip) {
+        return UTMtoLL(this, ellip, new LatLonPoint());
+    }
+
+    /**
+     * Fill in the given LatLonPoint with the converted values of this
+     * UTMPoint, and use the given ellipsoid.
+     */
+    public LatLonPoint toLatLonPoint(Ellipsoid ellip, LatLonPoint llpoint) {
+        return UTMtoLL(this, ellip, llpoint);
+    }
+
+    /**
+     * Returns a string representation of the object.
+     * 
+     * @return String representation
+     */
+    public String toString() {
+        return "UTMPoint[zone_number=" + zone_number + ", easting=" + easting
+                + ", northing=" + northing + ", hemisphere=" + zone_letter
+                + "]";
+    }
+
+    /**
+     * Converts a LatLonPoint to a UTM Point, assuming the WGS_84
+     * ellipsoid.
+     * 
+     * @return UTMPoint, or null if something bad happened.
+     */
+    public static UTMPoint LLtoUTM(LatLonPoint llpoint) {
+        return LLtoUTM(llpoint, Ellipsoid.WGS_84, new UTMPoint());
+    }
+
+    /**
+     * Converts a LatLonPoint to a UTM Point.
+     * 
+     * @param llpoint the LatLonPoint to convert.
+     * @param utmpoint a UTMPoint to put the results in. If it's null,
+     *        a UTMPoint will be allocated.
+     * @return UTMPoint, or null if something bad happened. If a
+     *         UTMPoint was passed in, it will also be returned on a
+     *         successful conversion.
+     */
+    public static UTMPoint LLtoUTM(LatLonPoint llpoint, UTMPoint utmpoint) {
+        return LLtoUTM(llpoint, Ellipsoid.WGS_84, utmpoint);
+    }
+
+    /**
+     * Converts a set of Longitude and Latitude co-ordinates to UTM
+     * given an ellipsoid
+     * 
+     * @param ellip an ellipsoid definition.
+     * @param llpoint the coordinate to be converted
+     * @param utmpoint A UTMPoint instance to put the results in. If
+     *        null, a new UTMPoint will be allocated.
+     * @return A UTM class instance containing the value of
+     *         <code>null</code> if conversion failed. If you pass
+     *         in a UTMPoint, it will be returned as well if
+     *         successful.
+     */
+    public static UTMPoint LLtoUTM(LatLonPoint llpoint, Ellipsoid ellip,
+                                   UTMPoint utmpoint) {
+
+        double Lat = llpoint.getLatitude();
+        double Long = llpoint.getLongitude();
+        double a = ellip.radius;
+        double eccSquared = ellip.eccsq;
+        double k0 = 0.9996;
+
+        double LongOrigin;
+        double eccPrimeSquared;
+        double N, T, C, A, M;
+
+        double LatRad = llpoint.radlat_;
+        double LongRad = llpoint.radlon_;
+        double LongOriginRad;
+        int ZoneNumber;
+
+        ZoneNumber = (int) ((Long + 180) / 6) + 1;
+
+        //Make sure the longitude 180.00 is in Zone 60
+        if (Long == 180) {
+            ZoneNumber = 60;
+        }
+
+        // Special zone for Norway
+        if (Lat >= 56.0f && Lat < 64.0f && Long >= 3.0f && Long < 12.0f) {
+            ZoneNumber = 32;
+        }
+
+        // Special zones for Svalbard
+        if (Lat >= 72.0f && Lat < 84.0f) {
+            if (Long >= 0.0f && Long < 9.0f)
+                ZoneNumber = 31;
+            else if (Long >= 9.0f && Long < 21.0f)
+                ZoneNumber = 33;
+            else if (Long >= 21.0f && Long < 33.0f)
+                ZoneNumber = 35;
+            else if (Long >= 33.0f && Long < 42.0f)
+                ZoneNumber = 37;
+        }
+        LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
+                                                     // in middle of
+                                                     // zone
+        LongOriginRad = ProjMath.degToRad(LongOrigin);
+
+        eccPrimeSquared = (eccSquared) / (1 - eccSquared);
+
+        N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
+        T = Math.tan(LatRad) * Math.tan(LatRad);
+        C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
+        A = Math.cos(LatRad) * (LongRad - LongOriginRad);
+
+        M = a
+                * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5
+                        * eccSquared * eccSquared * eccSquared / 256)
+                        * LatRad
+                        - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared
+                                / 32 + 45 * eccSquared * eccSquared
+                                * eccSquared / 1024)
+                        * Math.sin(2 * LatRad)
+                        + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared
+                                * eccSquared * eccSquared / 1024)
+                        * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared
+                        * eccSquared / 3072)
+                        * Math.sin(6 * LatRad));
+
+        float UTMEasting = (float) (k0
+                * N
+                * (A + (1 - T + C) * A * A * A / 6.0d + (5 - 18 * T + T * T
+                        + 72 * C - 58 * eccPrimeSquared)
+                        * A * A * A * A * A / 120.0d) + 500000.0d);
+
+        float UTMNorthing = (float) (k0 * (M + N
+                * Math.tan(LatRad)
+                * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A
+                        / 24.0d + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared)
+                        * A * A * A * A * A * A / 720.0d)));
+        if (Lat < 0.0f) {
+            UTMNorthing += 10000000.0f; //10000000 meter offset for
+                                        // southern hemisphere
+        }
+
+        if (utmpoint == null) {
+            utmpoint = new UTMPoint();
+        }
+
+        utmpoint.northing = (float) Math.rint(UTMNorthing);
+        utmpoint.easting = (float) Math.rint(UTMEasting);
+        utmpoint.zone_number = ZoneNumber;
+        utmpoint.zone_letter = utmpoint.getLetterDesignator(Lat);
+
+        return utmpoint;
+    }
+
+    /**
+     * Returns 'N' if the latitude is equal to or above the equator,
+     * 'S' if it's below.
+     * 
+     * @param lat The float value of the latitude.
+     * 
+     * @return A char value
+     */
+    protected char getLetterDesignator(double lat) {
+        char letterDesignator = 'N';
+
+        if (lat < 0) {
+            letterDesignator = 'S';
+        }
+
+        return letterDesignator;
+    }
+
+    /**
+     * Converts UTM coords to lat/long given an ellipsoid given an
+     * instance of UTMPoint.
+     * 
+     * @param utm_point A UTMPoint instance.
+     * @param ellip a ellipsoid definition.
+     * @param llpoint a LatLonPoint, if you want it to be filled in
+     *        with the results. If null, a new LatLonPoint will be
+     *        allocated.
+     * @return A LatLonPoint class instance containing the lat/long
+     *         value, or <code>null</code> if conversion failed. If
+     *         you pass in a LatLonPoint, it will be returned as well,
+     *         if successful.
+     */
+    public static LatLonPoint UTMtoLL(UTMPoint utm_point, Ellipsoid ellip,
+                                      LatLonPoint llpoint) {
+        return UTMtoLL(ellip,
+                utm_point.northing,
+                utm_point.easting,
+                utm_point.zone_number,
+                utm_point.zone_letter,
+                llpoint);
+    }
+
+    /**
+     * Converts UTM coords to lat/long given an ellipsoid. This is a
+     * convenience class where the Zone can be specified as a single
+     * string eg."61N" which is then broken down into the ZoneNumber
+     * and ZoneLetter.
+     * 
+     * @param ellip an ellipsoid definition.
+     * @param UTMNorthing A float value for the northing to be
+     *        converted.
+     * @param UTMEasting A float value for the easting to be
+     *        converted.
+     * @param UTMZone A String value for the UTM zone eg."61N".
+     * @param llpoint a LatLonPoint, if you want it to be filled in
+     *        with the results. If null, a new LatLonPoint will be
+     *        allocated.
+     * @return A LatLonPoint class instance containing the lat/long
+     *         value, or <code>null</code> if conversion failed. If
+     *         you pass in a LatLonPoint, it will be returned as well,
+     *         if successful.
+     */
+    public static LatLonPoint UTMtoLL(Ellipsoid ellip, float UTMNorthing,
+                                      float UTMEasting, String UTMZone,
+                                      LatLonPoint llpoint) {
+
+        //without the zone we can't calculate the Lat and Long
+        if (UTMZone == null || UTMZone.equals("")) {
+            return null;
+        }
+
+        int ZoneNumber = 1;
+        char ZoneLetter = 'N'; //northern hemisphere by default if no
+                               // character is found
+
+        //Break out the Zone number and zone letter from the UTMZone
+        //string We assume the string is a valid zone with a number
+        //followed by a zone letter If there is no Letter we assume
+        //that it's the Northern hemisphere
+        int ln = UTMZone.length() - 1;
+        if (ln > 0) {
+            //If it's Zero then there is only one character and it
+            // must be the Zone number
+            ZoneLetter = UTMZone.charAt(ln);
+            if (!Character.isLetter(ZoneLetter)) {
+                //No letter so assume it's missing & default to 'N'
+                ZoneLetter = 'N';
+                ln++;
+            }
+        }
+
+        //convert the number but catch the exception if it's not
+        // valid
+        try {
+            ZoneNumber = Integer.parseInt(UTMZone.substring(0, ln));
+        } catch (NumberFormatException nfe) {
+            return null;
+        }
+
+        return UTMtoLL(ellip,
+                UTMNorthing,
+                UTMEasting,
+                ZoneNumber,
+                ZoneLetter,
+                llpoint);
+    }
+
+    /**
+     * Converts UTM coords to lat/long given an ellipsoid. This is a
+     * convenience class where the exact Zone letter is not known.
+     * Instead only the hemisphere needs to be indicated.
+     * 
+     * @param ellip an ellipsoid definition.
+     * @param UTMNorthing A float value for the northing to be
+     *        converted.
+     * @param UTMEasting A float value for the easting to be
+     *        converted.
+     * @param ZoneNumber An int value indicating the float number.
+     * @param isnorthern A boolean which is true for the northern
+     *        hemisphere otherwise false for the southern.
+     * @param llpoint a LatLonPoint, if you want it to be filled in
+     *        with the results. If null, a new LatLonPoint will be
+     *        allocated.
+     * @return A LatLonPoint class instance containing the lat/long
+     *         value, or <code>null</code> if conversion failed. If
+     *         you pass in a LatLonPoint, it will be returned as well,
+     *         if successful.
+     */
+    public static LatLonPoint UTMtoLL(Ellipsoid ellip, float UTMNorthing,
+                                      float UTMEasting, int ZoneNumber,
+                                      boolean isnorthern, LatLonPoint llpoint) {
+
+        return UTMtoLL(ellip,
+                UTMNorthing,
+                UTMEasting,
+                ZoneNumber,
+                (isnorthern) ? 'N' : 'M',
+                llpoint);
+    }
+
+    /**
+     * Converts UTM coords to lat/long given an ellipsoid.
+     * <p>
+     * Equations from USGS Bulletin 1532 <br>
+     * East Longitudes are positive, West longitudes are negative.
+     * <br>
+     * North latitudes are positive, South latitudes are negative.
+     * <br>
+     * 
+     * @param ellip an ellipsoid definition.
+     * @param UTMNorthing A float value for the northing to be
+     *        converted.
+     * @param UTMEasting A float value for the easting to be
+     *        converted.
+     * @param ZoneNumber An int value specifiying the UTM zone number.
+     * @param ZoneLetter A char value specifying the ZoneLetter within
+     *        the ZoneNumber.
+     * @param llpoint a LatLonPoint, if you want it to be filled in
+     *        with the results. If null, a new LatLonPoint will be
+     *        allocated.
+     * @return A LatLonPoint class instance containing the lat/long
+     *         value, or <code>null</code> if conversion failed. If
+     *         you pass in a LatLonPoint, it will be returned as well,
+     *         if successful.
+     */
+    public static LatLonPoint UTMtoLL(Ellipsoid ellip, float UTMNorthing,
+                                      float UTMEasting, int ZoneNumber,
+                                      char ZoneLetter, LatLonPoint llpoint) {
+
+        //check the ZoneNummber is valid
+        if (ZoneNumber < 0 || ZoneNumber > 60) {
+            return null;
+        }
+
+        double k0 = 0.9996;
+        double a = ellip.radius;
+        double eccSquared = ellip.eccsq;
+        double eccPrimeSquared;
+        double e1 = (1 - Math.sqrt(1 - eccSquared))
+                / (1 + Math.sqrt(1 - eccSquared));
+        double N1, T1, C1, R1, D, M;
+        double LongOrigin;
+        double mu, phi1, phi1Rad;
+        double x, y;
+        int NorthernHemisphere; //1 for northern hemispher, 0 for
+                                // southern
+
+        x = UTMEasting - 500000.0d; //remove 500,000 meter offset for
+                                    // longitude
+        y = UTMNorthing;
+
+        //We must know somehow if we are in the Northern or Southern
+        //hemisphere, this is the only time we use the letter So even
+        //if the Zone letter isn't exactly correct it should indicate
+        //the hemisphere correctly
+        if (ZoneLetter >= 'N') {
+            NorthernHemisphere = 1;//point is in northern hemisphere
+        } else {
+            NorthernHemisphere = 0;//point is in southern hemisphere
+            y -= 10000000.0d;//remove 10,000,000 meter offset used
+                             // for southern hemisphere
+        }
+
+        //There are 60 zones with zone 1 being at West -180 to -174
+        LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
+                                                     // in middle of
+                                                     // zone
+
+        eccPrimeSquared = (eccSquared) / (1 - eccSquared);
+
+        M = y / k0;
+        mu = M
+                / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5
+                        * eccSquared * eccSquared * eccSquared / 256));
+
+        phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu)
+                + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32)
+                * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96)
+                * Math.sin(6 * mu);
+        phi1 = ProjMath.radToDeg(phi1Rad);
+
+        N1 = a
+                / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad)
+                        * Math.sin(phi1Rad));
+        T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
+        C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
+        R1 = a
+                * (1 - eccSquared)
+                / Math.pow(1 - eccSquared * Math.sin(phi1Rad)
+                        * Math.sin(phi1Rad), 1.5);
+        D = x / (N1 * k0);
+
+        double Lat = phi1Rad
+                - (N1 * Math.tan(phi1Rad) / R1)
+                * (D
+                        * D
+                        / 2
+                        - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared)
+                        * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45
+                        * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1)
+                        * D * D * D * D * D * D / 720);
+        Lat = ProjMath.radToDeg(Lat);
+
+        double Long = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28
+                * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1)
+                * D * D * D * D * D / 120)
+                / Math.cos(phi1Rad);
+        Long = LongOrigin + ProjMath.radToDeg(Long);
+        if (llpoint != null) {
+            llpoint.setLatLon((float) Lat, (float) Long);
+            return llpoint;
+        } else {
+            return new LatLonPoint((float) Lat, (float) Long);
+        }
+    }
+}
+


Property changes on: trunk/lib/com/bbn/openmap/proj/coords/UTMPoint.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/util/ArgParser$Arg.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/util/ArgParser$Arg.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/util/ArgParser$HelpArg.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/util/ArgParser$HelpArg.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/util/ArgParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/util/ArgParser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/util/ArgParser.java
===================================================================
--- trunk/lib/com/bbn/openmap/util/ArgParser.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/util/ArgParser.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,455 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/util/ArgParser.java,v $
+// $RCSfile: ArgParser.java,v $
+// $Revision: 1.2.2.3 $
+// $Date: 2005/01/10 17:08:43 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.util;
+
+//import java.util.Vector;
+import java.lang.*;
+import ewe.util.Vector;
+import ewe.sys.Vm;
+/**
+ * A simple class to manage the line arguments of a program. Takes the
+ * String[] argv that is provided to the main method of a class, and
+ * separates them out, depending on the options given to the
+ * ArgParser. After you create the parser, add your options that you
+ * want.
+ */
+public class ArgParser {
+    /**
+     * The length to submit if you want a variable length list at the
+     * end of the command line, like all the arguments left over.
+     */
+    public final static int TO_END = -1;
+    /** The program name that's using the parser. */
+    protected String programName;
+    /** The Args that the parser is looking for. */
+    protected Vector args;
+    /** The String array that holds all of the leftover argvs. */
+    protected String[] rest = new String[0];
+    /** The character flag for an option. */
+    protected char option = '-';
+    /**
+     * Tells the Args to accept the first letter of their name for
+     * argv options specified with one letter.
+     */
+    protected boolean allowAbbr = true;
+
+    /**
+     * Create a parser for the named program. Automatically adds the
+     * -help option.
+     * 
+     * @param pName the program name.
+     */
+    public ArgParser(String pName) {
+        programName = pName;
+        args = new Vector();
+        args.add(new HelpArg());
+    }
+
+    /**
+     * Add a argument to the parser. Don't include the '-' in the
+     * argName, that's added automatically. Assumes that the option
+     * expects no arguments.
+     * 
+     * @param argName the command line option
+     * @param desc a help line description.
+     */
+    public void add(String argName, String desc) {
+        add(argName, desc, 0);
+    }
+
+    /**
+     * Add a argument to the parser. Don't include the '-' in the
+     * argName, that's added automatically.
+     * 
+     * @param argName the command line option
+     * @param desc a help line description.
+     * @param expectedNumberOfArguments the number of option
+     *        parameters expected for this option.
+     */
+    public void add(String argName, String desc, int expectedNumberOfArguments) {
+        add(argName, desc, expectedNumberOfArguments, false);
+    }
+
+    /**
+     * Add a argument to the parser. Don't include the '-' in the
+     * argName, that's added automatically.
+     * 
+     * @param argName the command line option
+     * @param desc a help line description.
+     * @param expectedNumberOfArguments the number of option
+     *        parameters expected for this option.
+     * @param expectDashedArguments tell the parser that this option
+     *        may have arguments that may start with dashes, for
+     *        instance, a negative number. False by default.
+     */
+    public void add(String argName, String desc, int expectedNumberOfArguments,
+                    boolean expectDashedArguments) {
+        Arg newArg = new Arg(argName, desc, expectedNumberOfArguments, expectDashedArguments);
+        args.add(newArg);
+//        if (Debug.debugging("parse")) {
+        if (true) {
+            Vm.debug("ArgParser: adding " + argName);
+        }
+    }
+
+    /**
+     * Parse and organize the array of Strings. If something goes
+     * wrong, bail() may be called.
+     * 
+     * @return true if everything goes well, false if not.
+     */
+    public boolean parse(String[] argv) {
+        try {
+            if (argv == null || argv.length == 0) {
+                return false;
+            }
+            for (int i = 0; i < argv.length; i++) {
+                boolean hit = false;
+                if (argv[i].charAt(0) == option) {
+                    String eval = argv[i].substring(1);
+                    for (int j = 0; j < args.size(); j++) {
+                        Arg curArg = (Arg) args.elementAt(j);
+                        if (curArg.is(eval, allowAbbr)) {
+//                            if (Debug.debugging("parse")) {
+                        	if (true) {
+                                Vm.debug("ArgParser: arg " + curArg.name
+                                        + " reading values.");
+                            }
+                            if (!curArg.readArgs(argv, ++i)) {
+                                // Something's wrong with the
+                                // arguments.
+                                bail("ArgParser: Unexpected arguments with option "
+                                        + curArg.name + ".",
+                                        true);
+                            }
+                            hit = true;
+                            if (curArg.numExpectedValues != TO_END) {
+                                i += (curArg.numExpectedValues - 1);
+                            } else {
+                                i = argv.length;
+                            }
+                        }
+                    }
+                    if (hit == false) {
+                        //option flagged, but option unknown.
+                        bail(programName + ": unknown option " + argv[i], false);
+                    }
+                }
+
+                if (hit == false) {
+                    if (i == 0) {
+                        rest = argv;
+                    } else {
+                        int diff = argv.length - i;
+                        rest = new String[diff];
+                        for (int k = 0; k < diff; k++) {
+                            rest[k] = argv[i + k];
+                            if (rest[k].charAt(0) == option) {
+                                bail("ArgParser: Not expecting option in list of arguments.",
+                                        true);
+                            }
+                        }
+                    }
+//                    if (Debug.debugging("parse")) {
+                    if (true) {
+                        Vm.debug("ArgParser: adding " + rest.length
+                                + " strings to the leftover list.");
+                    }
+
+                    return true;
+                }
+            }
+        } catch (ArrayIndexOutOfBoundsException aioobe) {
+            bail("Expecting more arguments for option", true);
+//        } catch (NegativeArraySizeException nase) {
+//            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Called if something is messed up. Prints a message, and the
+     * usage statement, if desired.
+     * 
+     * @param message a message to display.
+     * @param printUsageStatement true to display a list of available
+     *        options.
+     */
+    public void bail(String message, boolean printUsageStatement) {
+        Vm.debug(message);
+        if (printUsageStatement)
+            printUsage();
+        System.exit(0);
+    }
+
+    /**
+     * Tell the parser to accept first-letter representations of the
+     * options.
+     */
+    public void setAllowAbbr(boolean set) {
+        allowAbbr = set;
+    }
+
+    /**
+     * Tells whether the parser accepts first-letter representations
+     * of the options.
+     */
+    public boolean getAllowAbbr() {
+        return allowAbbr;
+    }
+
+    /**
+     * Returns a Vector of Arg objects.
+     */
+    public Vector getArgs() {
+        return args;
+    }
+
+    /**
+     * Return a Arg object with a particular name.
+     */
+    public Arg getArg(String name) {
+        for (int i = 0; i < args.size(); i++) {
+            ArgParser.Arg arg = (ArgParser.Arg) args.elementAt(i);
+            if (name.equalsIgnoreCase(arg.name)) {
+                return arg;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Given an Arg name, return the values. Returns a zero length
+     * array (non-null) value for options that don't require
+     * arguments. Returns null if the option name wasn't found in the
+     * list, or if the option wasn't chosen in the parsed array of
+     * Strings.
+     */
+    public String[] getArgValues(String name) {
+        for (int i = 0; i < args.size(); i++) {
+            ArgParser.Arg arg = (ArgParser.Arg) args.elementAt(i);
+            if (name.equalsIgnoreCase(arg.name)) {
+                if (arg.flagged) {
+                    return arg.values;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Get the String[] that makes up the trailing Strings after the
+     * options were parsed.
+     */
+    public String[] getRest() {
+        return rest;
+    }
+
+    /**
+     * Print a list of options added to the parser.
+     */
+    public void printUsage() {
+        Vm.debug(programName + " Arguments:");
+        for (int i = 0; i < args.size(); i++) {
+            ArgParser.Arg arg = (ArgParser.Arg) args.elementAt(i);
+            StringBuffer sb = new StringBuffer();
+            sb.append("  -" + arg.name + "  \t" + arg.description);
+            if (arg.numExpectedValues == TO_END) {
+                sb.append(" (Variable number of arguments expected)");
+            } else if (arg.numExpectedValues == 1) {
+                sb.append(" (1 argument expected)");
+            } else {
+                sb.append(" (" + arg.numExpectedValues + " arguments expected)");
+            }
+            Vm.debug(sb.toString());
+        }
+    }
+
+    public static void main(String[] argv) {
+//        Debug.init();
+        ArgParser ap = new ArgParser("ArgParser");
+        ap.add("first", "First test argument, no parameters expected");
+        ap.add("second", "Second test argument, two parameters expected", 2);
+        ap.add("third", "Third test argument, no parameters expected");
+        ap.add("fourth", "Fourth test argument, one parameter expected", 1);
+
+        if (!ap.parse(argv)) {
+            ap.printUsage();
+            System.exit(0);
+        }
+
+        int i;
+        Vector args = ap.getArgs();
+        for (i = 0; i < args.size(); i++) {
+            ArgParser.Arg a = (ArgParser.Arg) args.elementAt(i);
+            Vm.debug(a.toString());
+        }
+
+        String[] rest = ap.getRest();
+        Vm.debug("Rest:");
+        for (i = 0; i < rest.length; i++) {
+            Vm.debug(rest[i]);
+        }
+    }
+
+    /**
+     * A default version of the Arg class used to represent options
+     * for the ArgParser to use.
+     */
+    public class Arg {
+        public String name;
+        public String description;
+        public int numExpectedValues;
+        public String[] values = null;
+        public char c;
+        public boolean flagged = false;
+        public boolean dashedArguments = false;
+
+        /**
+         * Create an Arg with a name and help line description.
+         */
+        public Arg(String aName, String desc) {
+            this(aName, desc, 0);
+        }
+
+        /**
+         * Create an Arg with a name and help line description, along
+         * with a number of expected arguments to follow this option.
+         */
+        public Arg(String aName, String desc, int expectedNumberOfArguments) {
+            this(aName, desc, expectedNumberOfArguments, false);
+        }
+
+        /**
+         * Create an Arg with a name and help line description, along
+         * with a number of expected arguments to follow this option.
+         * Has an argument to not check for arguments that may start
+         * with dashes, in case one of the arguements may be a
+         * negative number.
+         */
+        public Arg(String aName, String desc, int expectedNumberOfArguments,
+                boolean expectDashedArguments) {
+            name = aName;
+            description = desc;
+            numExpectedValues = expectedNumberOfArguments;
+            c = name.charAt(0);
+            dashedArguments = expectDashedArguments;
+        }
+
+        /**
+         * Returns true if the atg string matches the name of the Arg,
+         * or, if allowAbbr is true, returns true if the arg length is
+         * one and it matches the first letter of the arg name.
+         */
+        public boolean is(String arg, boolean allowAbbr) {
+            if (name.equalsIgnoreCase(arg)) {
+                return true;
+            }
+
+            if (allowAbbr && arg.length() == 1) {
+                if (arg.charAt(0) == c) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /**
+         * Runs through the array of Strings, starting at the
+         * argIndex, and creates the values array from it. Uses the
+         * expected number of arguments to tell when it's done.
+         * Returns true if everything happens as expected.
+         * 
+         * @param argv the entire array passed to the parser.
+         * @param argIndex the index of the first option argument
+         *        value.
+         * @return true if what was read was what was expected.
+         */
+        public boolean readArgs(String[] argv, int argIndex)
+                throws ArrayIndexOutOfBoundsException
+//                ,NegativeArraySizeException 
+                {
+
+            if (numExpectedValues != TO_END) {
+                values = new String[numExpectedValues];
+            } else {
+                values = new String[argv.length - argIndex];
+            }
+
+            for (int i = 0; i < values.length; i++) {
+                values[i] = argv[argIndex + i];
+                if (values[i].charAt(0) == option && !dashedArguments) {
+                    if (numExpectedValues != TO_END) {
+                        Vm.debug("ArgParser: Option "
+                                + name
+                                + " expects "
+                                + numExpectedValues
+                                + (numExpectedValues == 1 ? " argument."
+                                        : " arguments."));
+
+                    } else {
+                        Vm.debug("ArgParser: Option " + name
+                                + " not expecting options after its values.");
+                    }
+                    return false; // Unexpected argument.
+                }
+            }
+            flagged = true;
+            return true;
+        }
+
+        public String toString() {
+            StringBuffer sb = new StringBuffer();
+            sb.append("Arg: " + name + " expects " + numExpectedValues
+                    + (numExpectedValues == 1 ? " value.\n" : " values.\n"));
+            if (values != null) {
+                sb.append("Values: ");
+                for (int i = 0; i < values.length; i++) {
+                    sb.append("[" + values[i] + "]");
+                }
+                sb.append("\n");
+            }
+            return sb.toString();
+        }
+    }
+
+    /**
+     * A Arg class to spur off help messages. Gets added automatically
+     * to the parser.
+     */
+    public class HelpArg extends ArgParser.Arg {
+
+        public HelpArg() {
+            super("help", "Print usage statement, with arguments.", 0);
+        }
+
+        public boolean is(String arg, boolean allowAbbr) {
+            boolean askingForHelp = super.is(arg, allowAbbr);
+            if (askingForHelp) {
+                ArgParser.this.bail("", true);
+            }
+            return false;
+        }
+    }
+
+}


Property changes on: trunk/lib/com/bbn/openmap/util/ArgParser.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/util/Assert.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/util/Assert.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/util/Assert.java
===================================================================
--- trunk/lib/com/bbn/openmap/util/Assert.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/util/Assert.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,108 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/util/Assert.java,v $
+// $RCSfile: Assert.java,v $
+// $Revision: 1.3.2.1 $
+// $Date: 2004/10/14 18:27:45 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.util;
+
+/**
+ * Assert provides an assertion facility in Java comparable to the
+ * assert macros in C/C++. This class was taken from the Java FAQ
+ * maintained by Perter Van Der Linden at <A
+ * HREF=http://www.afu.com/intro.html>http://www.afu.com/intro.html
+ * </A>, section 17, question 6. Here is the original entry in the
+ * FAQ:
+ * <p>
+ * 
+ * <pre>
+ * 
+ *  11.6 How can I write C/C++ style assertions in Java?
+ * 
+ *  A.  The two classes shown below provide an assertion facility in Java.
+ *      Set Assert.enabled to true to enable the assertions, and to false to
+ *      disable assertions in production code. The AssertionException is not
+ *      meant to be caught--instead, let it print a trace.
+ * 
+ *      With a good optimizing compiler there will be no run time overhead
+ *      for many uses of these assertions when Assert.enabled is set to false.
+ *      However, if the condition in the assertion may have side effects, the
+ *      condition code cannot be optimized away. For example, in the assertion
+ *       
+ * <code>
+ * Assert.assertExp(size() &lt;= maxSize, &quot;Maximum size exceeded&quot;);
+ * </code>
+ * 
+ *      the call to size() cannot be optimized away unless the compiler can
+ *      see that the call has no side effects. C and C++ use the preprocessor
+ *      to guarantee that assertions will never cause overhead in production
+ *      code. Without a preprocessor, it seems the best we can do in Java is
+ *      to write
+ *       
+ * <code>
+ * Assert.assertExp(Assert.enabled &amp;&amp; size() &lt;= maxSize, &quot;Too big&quot;);
+ * </code>
+ * 
+ *      In this case, when Assert.enabled is false, the method call can always
+ *      be optimized away, even if it has side effects.
+ *  
+ * </pre>
+ * 
+ * </p>
+ * 
+ * @author Peter Van Der Linden
+ * @author Maintained by: Tom Mitchell (tmitchell at bbn.com)
+ * @version $Revision: 1.3.2.1 $, $Date: 2004/10/14 18:27:45 $
+ */
+public final class Assert {
+
+    /**
+     * Don't allow construction, all methods are static.
+     */
+    private Assert() {}
+
+    /**
+     * Globally enable or disable assertions.
+     */
+    public static final boolean enabled = true;
+
+    /**
+     * Assert a condition to be true. If it is not true, an exception
+     * is thrown.
+     * 
+     * @param b An expression expected to be true
+     * @param s Exception string if expression is false
+     * @exception AssertionException if expression is false
+     */
+    public static final void assertExp(boolean b, String s) {
+        if (enabled && !b)
+            throw new AssertionException(s);
+    }
+
+    /**
+     * Assert a condition to be true. If it is not true, an exception
+     * is thrown.
+     * 
+     * @param b An expression expected to be true
+     * @exception AssertionException if expression is false
+     */
+    public static final void assertExp(boolean b) {
+        assertExp(b, "");
+    }
+}


Property changes on: trunk/lib/com/bbn/openmap/util/Assert.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/bbn/openmap/util/AssertionException.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/bbn/openmap/util/AssertionException.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/bbn/openmap/util/AssertionException.java
===================================================================
--- trunk/lib/com/bbn/openmap/util/AssertionException.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/bbn/openmap/util/AssertionException.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,50 @@
+// **********************************************************************
+// 
+// <copyright>
+// 
+//  BBN Technologies
+//  10 Moulton Street
+//  Cambridge, MA 02138
+//  (617) 873-8000
+// 
+//  Copyright (C) BBNT Solutions LLC. All rights reserved.
+// 
+// </copyright>
+// **********************************************************************
+// 
+// $Source: /cvs/distapps/openmap/src/openmap/com/bbn/openmap/util/AssertionException.java,v $
+// $RCSfile: AssertionException.java,v $
+// $Revision: 1.2.2.1 $
+// $Date: 2004/10/14 18:27:45 $
+// $Author: dietrick $
+// 
+// **********************************************************************
+
+package com.bbn.openmap.util;
+
+/**
+ * Signals that an assertion has failed.
+ * 
+ * @author unascribed
+ * @version $Revision: 1.2.2.1 $, $Date: 2004/10/14 18:27:45 $
+ * @see Assert
+ */
+public class AssertionException extends RuntimeException {
+
+    /**
+     * Constructs a default <code>AssertionException</code>.
+     */
+    public AssertionException() {
+        this("");
+    }
+
+    /**
+     * Constructs an <code>AssertionException</code> with the
+     * specified detail message.
+     * 
+     * @param s the detail message
+     */
+    public AssertionException(String s) {
+        super(s);
+    }
+}


Property changes on: trunk/lib/com/bbn/openmap/util/AssertionException.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,20 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This implements the $& element of the second argument to
+  * Regex.
+  * @see com.stevesoft.ewe_pat.ReplaceRule
+  */
+public final class AmpersandRule extends ReplaceRule {
+    public AmpersandRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(res.stringMatched());
+    }
+    public String toString1() { return "$&"; }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/AmpersandRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Any.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Any.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Any.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Any.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Any.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,28 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** This is the '.' character in a Pattern.  It
+ matches any character. */
+class Any extends Pattern {
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos < pt.src.length())
+            if(pt.dotDoesntMatchCR) {
+                if(pt.src.charAt(pos) != '\n')
+                    return nextMatch(pos+1,pt);
+            } else return nextMatch(pos+1,pt);
+        return -1;
+    }
+    public String toString() {
+        return "."+nextString();
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    public Pattern clone1(Hashtable h) { return new Any(); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Any.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/BackG.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BackG.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/BackG.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/BackG.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/BackG.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,26 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** This class represents the \G pattern element. */
+class BackG extends Pattern {
+    char c,altc,altc2;
+    int mask;
+    public BackG() {
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        return pos==pt.lastPos ? nextMatch(pos,pt) : -1;
+    }
+    public String toString() {
+        return "\\G"+nextString();
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    Pattern clone1(Hashtable h) { return new BackG(); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BackG.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/BackMatch.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BackMatch.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/BackMatch.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/BackMatch.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/BackMatch.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,33 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Provides the ability to match a backreference from within
+  * a Pattern.
+  */
+class BackMatch extends Pattern {
+    int id;
+    BackMatch(int id) { this.id = id; }
+    public String toString() { return "\\"+(id)+nextString(); }
+    public int matchInternal(int pos,Pthings p) {
+        int i1 = p.marks[id];
+        int i2 = p.marks[id+p.nMarks];
+        int imax = i2-i1;
+        if(i1<0||imax < 0||pos+imax>p.src.length()) return -1;
+        int ns = p.src.length()-pos;
+        if(imax < ns) ns = imax;
+        for(int i=0;i<ns;i++) {
+            if(p.src.charAt(i+i1) != p.src.charAt(pos+i))
+                return -1;
+        }
+        return nextMatch(pos+imax,p);
+    }
+    Pattern clone1(Hashtable h) { return new BackMatch(id); }
+}
+


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BackMatch.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/BackRefRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BackRefRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/BackRefRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/BackRefRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/BackRefRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,23 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This method implements the pattern elements $1, $2, etc in
+    a substitution rule. The apply(StringBufferLike sb,RegRes rr) method of this ReplaceRule
+    simply appends the contents of rr.stringMatched(n), where n is
+    the integer supplied to the constructor. */
+public class BackRefRule extends ReplaceRule {
+    int n;
+    public BackRefRule(int n) { this.n = n; }
+    public void apply(StringBufferLike sb,RegRes res) {
+        String x = res.stringMatched(n);
+        sb.append(x == null ? "" : x);
+    }
+    public String toString1() { return "$"+n; }
+    public Object clone1() { return new BackRefRule(n); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BackRefRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Backup.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Backup.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Backup.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Backup.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Backup.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,27 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Implements the (?&lt;number) Pattern, where number is
+ an integer telling us how far to back up in the Pattern.
+ Not in perl 5. It also allows (?&gt;number). */
+class Backup extends Pattern {
+    int bk;
+    Backup(int ii) { bk = ii; }
+    public String toString() {
+        return "(?" + (bk < 0 ? ">" + (-bk) : "<" + bk) + ")" + nextString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos < bk) return -1;
+        return nextMatch(pos-bk,pt);
+    }
+    public patInt minChars() { return new patInt(-bk); }
+    public patInt maxChars() { return new patInt(-bk); }
+    public Pattern clone1(Hashtable h) { return new Backup(bk); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Backup.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/BadRangeArgs.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BadRangeArgs.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,18 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat;
+
+/** An abstraction of the StringBuffer which only
+    implements a subset of StringBuffer's methods.
+    */
+public interface BasicStringBufferLike {
+  public void append(char c);
+  public void append(String s);
+  public StringLike toStringLike();
+  public Object unwrap();
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BasicStringBufferLike.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/BitSet.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BitSet.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/BitSet.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/BitSet.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/BitSet.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,744 @@
+/* BitSet.java -- A vector of bits.
+   Copyright (C) 1998, 1999, 2000, 2001, 2004  Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+02111-1307 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+package com.stevesoft.ewe_pat;
+
+/* Written using "Java Class Libraries", 2nd edition, ISBN 0-201-31002-3
+ * hashCode algorithm taken from JDK 1.2 docs.
+ */
+
+/**
+ * This class can be thought of in two ways.  You can see it as a
+ * vector of bits or as a set of non-negative integers.  The name
+ * <code>BitSet</code> is a bit misleading.
+ *
+ * It is implemented by a bit vector, but its equally possible to see
+ * it as set of non-negative integer; each integer in the set is
+ * represented by a set bit at the corresponding index.  The size of
+ * this structure is determined by the highest integer in the set.
+ *
+ * You can union, intersect and build (symmetric) remainders, by
+ * invoking the logical operations and, or, andNot, resp. xor.
+ *
+ * This implementation is NOT synchronized against concurrent access from
+ * multiple threads. Specifically, if one thread is reading from a bitset
+ * while another thread is simultaneously modifying it, the results are
+ * undefined.
+ *
+ * @author Jochen Hoenicke
+ * @author Tom Tromey <tromey at cygnus.com>
+ * @author Eric Blake <ebb9 at email.byu.edu>
+ * @status updated to 1.4
+ */
+public class BitSet implements Cloneable
+{
+  /**
+   * Compatible with JDK 1.0.
+   */
+  private static final long serialVersionUID = 7997698588986878753L;
+
+  /**
+   * A common mask.
+   */
+  private static final int LONG_MASK = 0x3f;
+
+  /**
+   * The actual bits.
+   * @serial the i'th bit is in bits[i/64] at position i%64 (where position
+   *         0 is the least significant).
+   */
+  private long[] bits;
+
+  /**
+   * Create a new empty bit set. All bits are initially false.
+   */
+  public BitSet()
+  {
+    this(64);
+  }
+
+  /**
+   * Create a new empty bit set, with a given size.  This
+   * constructor reserves enough space to represent the integers
+   * from <code>0</code> to <code>nbits-1</code>.
+   *
+   * @param nbits the initial size of the bit set
+   * @throws IllegalArgumentException if nbits &lt; 0
+   */
+  public BitSet(int nbits)
+  {
+    if (nbits < 0)
+      throw new IllegalArgumentException();
+    
+    int length = nbits >>> 6;
+    if ((nbits & LONG_MASK) != 0)
+      ++length;
+    bits = new long[length];
+  }
+
+  /**
+   * Performs the logical AND operation on this bit set and the
+   * given <code>set</code>.  This means it builds the intersection
+   * of the two sets.  The result is stored into this bit set.
+   *
+   * @param set the second bit set
+   * @throws NullPointerException if set is null
+   */
+  public void and(BitSet bs)
+  {
+    int max = Math.min(bits.length, bs.bits.length);
+    int i;
+    for (i = 0; i < max; ++i)
+      bits[i] &= bs.bits[i];
+    while (i < bits.length)
+      bits[i++] = 0;
+  }
+
+  /**
+   * Performs the logical AND operation on this bit set and the
+   * complement of the given <code>set</code>.  This means it
+   * selects every element in the first set, that isn't in the
+   * second set.  The result is stored into this bit set and is
+   * effectively the set difference of the two.
+   *
+   * @param set the second bit set
+   * @throws NullPointerException if set is null
+   * @since 1.2
+   */
+  public void andNot(BitSet bs)
+  {
+    int i = Math.min(bits.length, bs.bits.length);
+    while (--i >= 0)
+      bits[i] &= ~bs.bits[i];
+  }
+
+  /**
+   * Returns the number of bits set to true.
+   *
+   * @return the number of true bits
+   * @since 1.4
+   */
+  public int cardinality()
+  {
+    int card = 0;
+    for (int i = bits.length - 1; i >= 0; i--)
+      {
+        long a = bits[i];
+        // Take care of common cases.
+        if (a == 0)
+          continue;
+        if (a == -1)
+          {
+            card += 64;
+            continue;
+          }
+
+        // Successively collapse alternating bit groups into a sum.
+        a = ((a >> 1) & 0x5555555555555555L) + (a & 0x5555555555555555L);
+        a = ((a >> 2) & 0x3333333333333333L) + (a & 0x3333333333333333L);
+        int b = (int) ((a >>> 32) + a);
+        b = ((b >> 4) & 0x0f0f0f0f) + (b & 0x0f0f0f0f);
+        b = ((b >> 8) & 0x00ff00ff) + (b & 0x00ff00ff);
+        card += ((b >> 16) & 0x0000ffff) + (b & 0x0000ffff);
+      }
+    return card;
+  }
+
+  /**
+   * Sets all bits in the set to false.
+   *
+   * @since 1.4
+   */
+  /*
+  public void clear()
+  {
+    Arrays.fill(bits, 0);
+  }
+*/
+  /**
+   * Removes the integer <code>bitIndex</code> from this set. That is
+   * the corresponding bit is cleared.  If the index is not in the set,
+   * this method does nothing.
+   *
+   * @param bitIndex a non-negative integer
+   * @throws IndexOutOfBoundsException if bitIndex &lt; 0
+   */
+  public void clear(int pos)
+  {
+    int offset = pos >> 6;
+    ensure(offset);
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    bits[offset] &= ~(1L << pos);
+  }
+
+  /**
+   * Sets the bits between from (inclusive) and to (exclusive) to false.
+   *
+   * @param from the start range (inclusive)
+   * @param to the end range (exclusive)
+   * @throws IndexOutOfBoundsException if from &lt; 0 || to &lt; 0 ||
+   *         from &gt; to
+   * @since 1.4
+   */
+  public void clear(int from, int to)
+  {
+    if (from < 0 || from > to)
+      throw new IndexOutOfBoundsException();
+    if (from == to)
+      return;
+    int lo_offset = from >>> 6;
+    int hi_offset = to >>> 6;
+    ensure(hi_offset);
+    if (lo_offset == hi_offset)
+      {
+        bits[hi_offset] &= ((1L << from) - 1) | (-1L << to);
+        return;
+      }
+
+    bits[lo_offset] &= (1L << from) - 1;
+    bits[hi_offset] &= -1L << to;
+    for (int i = lo_offset + 1; i < hi_offset; i++)
+      bits[i] = 0;
+  }
+
+  /**
+   * Create a clone of this bit set, that is an instance of the same
+   * class and contains the same elements.  But it doesn't change when
+   * this bit set changes.
+   *
+   * @return the clone of this object.
+   */
+  public Object clone()
+  {
+    try
+      {
+        BitSet bs = (BitSet) super.clone();
+        bs.bits = (long[]) bits.clone();
+        return bs;
+      }
+    catch (CloneNotSupportedException e)
+      {
+        // Impossible to get here.
+        return null;
+      }
+  }
+
+  /**
+   * Returns true if the <code>obj</code> is a bit set that contains
+   * exactly the same elements as this bit set, otherwise false.
+   *
+   * @param obj the object to compare to
+   * @return true if obj equals this bit set
+   */
+  public boolean equals(Object obj)
+  {
+    if (!(obj instanceof BitSet))
+      return false;
+    BitSet bs = (BitSet) obj;
+    int max = Math.min(bits.length, bs.bits.length);
+    int i;
+    for (i = 0; i < max; ++i)
+      if (bits[i] != bs.bits[i])
+        return false;
+    // If one is larger, check to make sure all extra bits are 0.
+    for (int j = i; j < bits.length; ++j)
+      if (bits[j] != 0)
+        return false;
+    for (int j = i; j < bs.bits.length; ++j)
+      if (bs.bits[j] != 0)
+        return false;
+    return true;
+  }
+
+  /**
+   * Sets the bit at the index to the opposite value.
+   *
+   * @param index the index of the bit
+   * @throws IndexOutOfBoundsException if index is negative
+   * @since 1.4
+   */
+  public void flip(int index)
+  {
+    int offset = index >> 6;
+    ensure(offset);
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    bits[offset] ^= 1L << index;
+  }
+
+  /**
+   * Sets a range of bits to the opposite value.
+   *
+   * @param from the low index (inclusive)
+   * @param to the high index (exclusive)
+   * @throws IndexOutOfBoundsException if from &gt; to || from &lt; 0 ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public void flip(int from, int to)
+  {
+    if (from < 0 || from > to)
+      throw new IndexOutOfBoundsException();
+    if (from == to)
+      return;
+    int lo_offset = from >>> 6;
+    int hi_offset = to >>> 6;
+    ensure(hi_offset);
+    if (lo_offset == hi_offset)
+      {
+        bits[hi_offset] ^= (-1L << from) & ((1L << to) - 1);
+        return;
+      }
+
+    bits[lo_offset] ^= -1L << from;
+    bits[hi_offset] ^= (1L << to) - 1;
+    for (int i = lo_offset + 1; i < hi_offset; i++)
+      bits[i] ^= -1;
+  }
+
+  /**
+   * Returns true if the integer <code>bitIndex</code> is in this bit
+   * set, otherwise false.
+   *
+   * @param pos a non-negative integer
+   * @return the value of the bit at the specified index
+   * @throws IndexOutOfBoundsException if the index is negative
+   */
+  public boolean get(int pos)
+  {
+    int offset = pos >> 6;
+    if (offset >= bits.length)
+      return false;
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    return (bits[offset] & (1L << pos)) != 0;
+  }
+
+  /**
+   * Returns a new <code>BitSet</code> composed of a range of bits from
+   * this one.
+   *
+   * @param from the low index (inclusive)
+   * @param to the high index (exclusive)
+   * @throws IndexOutOfBoundsException if from &gt; to || from &lt; 0 ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public BitSet get(int from, int to)
+  {
+    if (from < 0 || from > to)
+      throw new IndexOutOfBoundsException();
+    BitSet bs = new BitSet(to - from);
+    int lo_offset = from >>> 6;
+    if (lo_offset >= bits.length)
+      return bs;
+
+    int lo_bit = from & LONG_MASK;
+    int hi_offset = to >>> 6;
+    if (lo_bit == 0)
+      {
+        int len = Math.min(hi_offset - lo_offset + 1, bits.length - lo_offset);
+        System.arraycopy(bits, lo_offset, bs.bits, 0, len);
+        if (hi_offset < bits.length)
+          bs.bits[hi_offset - lo_offset] &= (1L << to) - 1;
+        return bs;
+      }
+
+    int len = Math.min(hi_offset, bits.length - 1);
+    int reverse = ~lo_bit;
+    int i;
+    for (i = 0; lo_offset < len; lo_offset++, i++)
+      bs.bits[i] = ((bits[lo_offset] >>> lo_bit)
+                    | (bits[lo_offset + 1] << reverse));
+    if ((to & LONG_MASK) > lo_bit)
+      bs.bits[i++] = bits[lo_offset] >>> lo_bit;
+    if (hi_offset < bits.length)
+      bs.bits[i - 1] &= (1L << (to - from)) - 1;
+    return bs;
+  }
+
+  /**
+   * Returns a hash code value for this bit set.  The hash code of
+   * two bit sets containing the same integers is identical.  The algorithm
+   * used to compute it is as follows:
+   *
+   * Suppose the bits in the BitSet were to be stored in an array of
+   * long integers called <code>bits</code>, in such a manner that
+   * bit <code>k</code> is set in the BitSet (for non-negative values
+   * of <code>k</code>) if and only if
+   *
+   * <code>((k/64) &lt; bits.length)
+   * && ((bits[k/64] & (1L &lt;&lt; (bit % 64))) != 0)
+   * </code>
+   *
+   * Then the following definition of the hashCode method
+   * would be a correct implementation of the actual algorithm:
+   *
+   * 
+<pre>public int hashCode()
+{
+  long h = 1234;
+  for (int i = bits.length-1; i &gt;= 0; i--)
+  {
+    h ^= bits[i] * (i + 1);
+  }
+
+  return (int)((h >> 32) ^ h);
+}</pre>
+   *
+   * Note that the hash code values changes, if the set is changed.
+   *
+   * @return the hash code value for this bit set.
+   */
+  public int hashCode()
+  {
+    long h = 1234;
+    for (int i = bits.length; i > 0; )
+      h ^= i * bits[--i];
+    return (int) ((h >> 32) ^ h);
+  }
+
+  /**
+   * Returns true if the specified BitSet and this one share at least one
+   * common true bit.
+   *
+   * @param set the set to check for intersection
+   * @return true if the sets intersect
+   * @throws NullPointerException if set is null
+   * @since 1.4
+   */
+  public boolean intersects(BitSet set)
+  {
+    int i = Math.min(bits.length, set.bits.length);
+    while (--i >= 0)
+      if ((bits[i] & set.bits[i]) != 0)
+        return true;
+    return false;
+  }
+
+  /**
+   * Returns true if this set contains no true bits.
+   *
+   * @return true if all bits are false
+   * @since 1.4
+   */
+  public boolean isEmpty()
+  {
+    for (int i = bits.length - 1; i >= 0; i--)
+      if (bits[i] != 0)
+        return false;
+    return true;
+  }
+
+  /**
+   * Returns the logical number of bits actually used by this bit
+   * set.  It returns the index of the highest set bit plus one.
+   * Note that this method doesn't return the number of set bits.
+   *
+   * @return the index of the highest set bit plus one.
+   */
+  public int length()
+  {
+    // Set i to highest index that contains a non-zero value.
+    int i;
+    for (i = bits.length - 1; i >= 0 && bits[i] == 0; --i)
+      ;
+
+    // if i < 0 all bits are cleared.
+    if (i < 0)
+      return 0;
+
+    // Now determine the exact length.
+    long b = bits[i];
+    int len = (i + 1) * 64;
+    // b >= 0 checks if the highest bit is zero.
+    while (b >= 0)
+      {
+        --len;
+        b <<= 1;
+      }
+
+    return len;
+  }
+
+  /**
+   * Returns the index of the next false bit, from the specified bit
+   * (inclusive).
+   *
+   * @param from the start location
+   * @return the first false bit
+   * @throws IndexOutOfBoundsException if from is negative
+   * @since 1.4
+   */
+  public int nextClearBit(int from)
+  {
+    int offset = from >> 6;
+    long mask = 1L << from;
+    while (offset < bits.length)
+      {
+        // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+        // so we'll just let that be our exception.
+        long h = bits[offset];
+        do
+          {
+            if ((h & mask) == 0)
+              return from;
+            mask <<= 1;
+            from++;
+          }
+        while (mask != 0);
+        mask = 1;
+        offset++;
+      }
+    return from;
+  }
+
+  /**
+   * Returns the index of the next true bit, from the specified bit
+   * (inclusive). If there is none, -1 is returned. You can iterate over
+   * all true bits with this loop:<br>
+   * 
+<pre>for (int i = bs.nextSetBit(0); i &gt;= 0; i = bs.nextSetBit(i + 1))
+{
+  // operate on i here
+}</pre>
+   *
+   * @param from the start location
+   * @return the first true bit, or -1
+   * @throws IndexOutOfBoundsException if from is negative
+   * @since 1.4
+   */
+  public int nextSetBit(int from)
+  {
+    int offset = from >> 6;
+    long mask = 1L << from;
+    while (offset < bits.length)
+      {
+        // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+        // so we'll just let that be our exception.
+        long h = bits[offset];
+        do
+          {
+            if ((h & mask) != 0)
+              return from;
+            mask <<= 1;
+            from++;
+          }
+        while (mask != 0);
+        mask = 1;
+        offset++;
+      }
+    return -1;
+  }
+
+  /**
+   * Performs the logical OR operation on this bit set and the
+   * given <code>set</code>.  This means it builds the union
+   * of the two sets.  The result is stored into this bit set, which
+   * grows as necessary.
+   *
+   * @param bs the second bit set
+   * @throws NullPointerException if bs is null
+   */
+  public void or(BitSet bs)
+  {
+    ensure(bs.bits.length - 1);
+    for (int i = bs.bits.length - 1; i >= 0; i--)
+      bits[i] |= bs.bits[i];
+  }
+
+  /**
+   * Add the integer <code>bitIndex</code> to this set.  That is
+   * the corresponding bit is set to true.  If the index was already in
+   * the set, this method does nothing.  The size of this structure
+   * is automatically increased as necessary.
+   *
+   * @param pos a non-negative integer.
+   * @throws IndexOutOfBoundsException if pos is negative
+   */
+  public void set(int pos)
+  {
+    int offset = pos >> 6;
+    ensure(offset);
+    // ArrayIndexOutOfBoundsException subclasses IndexOutOfBoundsException,
+    // so we'll just let that be our exception.
+    bits[offset] |= 1L << pos;
+  }
+
+  /**
+   * Sets the bit at the given index to the specified value. The size of
+   * this structure is automatically increased as necessary.
+   *
+   * @param index the position to set
+   * @param value the value to set it to
+   * @throws IndexOutOfBoundsException if index is negative
+   * @since 1.4
+   */
+  public void set(int index, boolean value)
+  {
+    if (value)
+      set(index);
+    else
+      clear(index);
+  }
+
+  /**
+   * Sets the bits between from (inclusive) and to (exclusive) to true.
+   *
+   * @param from the start range (inclusive)
+   * @param to the end range (exclusive)
+   * @throws IndexOutOfBoundsException if from &lt; 0 || from &gt; to ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public void set(int from, int to)
+  {
+    if (from < 0 || from > to)
+      throw new IndexOutOfBoundsException();
+    if (from == to)
+      return;
+    int lo_offset = from >>> 6;
+    int hi_offset = to >>> 6;
+    ensure(hi_offset);
+    if (lo_offset == hi_offset)
+      {
+        bits[hi_offset] |= (-1L << from) & ((1L << to) - 1);
+        return;
+      }
+
+    bits[lo_offset] |= -1L << from;
+    bits[hi_offset] |= (1L << to) - 1;
+    for (int i = lo_offset + 1; i < hi_offset; i++)
+      bits[i] = -1;
+  }
+
+  /**
+   * Sets the bits between from (inclusive) and to (exclusive) to the
+   * specified value.
+   *
+   * @param from the start range (inclusive)
+   * @param to the end range (exclusive)
+   * @param value the value to set it to
+   * @throws IndexOutOfBoundsException if from &lt; 0 || from &gt; to ||
+   *         to &lt; 0
+   * @since 1.4
+   */
+  public void set(int from, int to, boolean value)
+  {
+    if (value)
+      set(from, to);
+    else
+      clear(from, to);
+  }
+
+  /**
+   * Returns the number of bits actually used by this bit set.  Note
+   * that this method doesn't return the number of set bits, and that
+   * future requests for larger bits will make this automatically grow.
+   *
+   * @return the number of bits currently used.
+   */
+  public int size()
+  {
+    return bits.length * 64;
+  }
+
+  /**
+   * Returns the string representation of this bit set.  This
+   * consists of a comma separated list of the integers in this set
+   * surrounded by curly braces.  There is a space after each comma.
+   * A sample string is thus "{1, 3, 53}".
+   * @return the string representation.
+   */
+  public String toString()
+  {
+    StringBuffer r = new StringBuffer("{");
+    boolean first = true;
+    for (int i = 0; i < bits.length; ++i)
+      {
+        long bit = 1;
+        long word = bits[i];
+        if (word == 0)
+          continue;
+        for (int j = 0; j < 64; ++j)
+          {
+            if ((word & bit) != 0)
+              {
+                if (! first)
+                  r.append(", ");
+                r.append(64 * i + j);
+                first = false;
+              }
+            bit <<= 1;
+          }
+      }
+    return r.append("}").toString();
+  }
+
+  /**
+   * Performs the logical XOR operation on this bit set and the
+   * given <code>set</code>.  This means it builds the symmetric
+   * remainder of the two sets (the elements that are in one set,
+   * but not in the other).  The result is stored into this bit set,
+   * which grows as necessary.
+   *
+   * @param bs the second bit set
+   * @throws NullPointerException if bs is null
+   */
+  public void xor(BitSet bs)
+  {
+    ensure(bs.bits.length - 1);
+    for (int i = bs.bits.length - 1; i >= 0; i--)
+      bits[i] ^= bs.bits[i];
+  }
+
+  /**
+   * Make sure the vector is big enough.
+   *
+   * @param lastElt the size needed for the bits array
+   */
+  private void ensure(int lastElt)
+  {
+    if (lastElt >= bits.length)
+      {
+        long[] nd = new long[lastElt + 1];
+        System.arraycopy(bits, 0, nd, 0, bits.length);
+        bits = nd;
+      }
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/BitSet.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Bits.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Bits.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Bits.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Bits.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Bits.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,3071 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat;
+
+
+public class Bits {
+  char[] carray;
+  Bits(char[] carray) {
+    this.carray = carray;
+  }
+  public boolean get(int i) {
+    return ((carray[i>>4]) & (1<<(i&15))) != 0;
+  }
+  public void set(int i,boolean b) {
+    if(b) {
+      carray[i>>4] |= (char) 1<<(i&15);
+    } else {
+      carray[i>>4] &= (char)~(1<<(i&15));
+    }
+  }
+
+  /*
+  public static String n4(char c) {
+    String s = Integer.toHexString(c);
+    while(s.length()<4)
+      s = "0"+s;
+    return s;
+  }
+  static abstract class Tester {
+    abstract boolean test(char c);
+  }
+  public static void main(String[] args) throws Exception {
+    //pw_s.println("  static {");
+    FileWriter fw = new FileWriter("x.out");
+    fw.close();
+    test("upper",new Tester() {
+      boolean test(char c) {
+        return Character.isUpperCase(c);
+      }
+    });
+    test("lower",new Tester() {
+      boolean test(char c) {
+        return Character.isLowerCase(c);
+      }
+    });
+    test("title",new Tester() {
+      boolean test(char c) {
+        return Character.isLowerCase(c);
+      }
+    });
+    test("currency",new Tester() {
+      boolean test(char c) {
+        return Character.getType(c)==Character.CURRENCY_SYMBOL;
+      }
+    });
+    test("decimal_digit",new Tester() {
+      boolean test(char c) {
+        return Character.getType(c)==Character.DECIMAL_DIGIT_NUMBER;
+      }
+    });
+    test("math",new Tester() {
+      boolean test(char c) {
+        return Character.getType(c)==Character.MATH_SYMBOL;
+      }
+    });
+    test("letter",new Tester() {
+      boolean test(char c) {
+        return Character.isLetter(c);
+      }
+    });
+    test("white",new Tester() {
+      boolean test(char c) {
+        return Character.isWhitespace(c);
+      }
+    });
+    test("punct",new Tester() {
+      boolean test(char c) {
+	boolean r = false;
+        switch(Character.getType(c)) {
+        case Character.DASH_PUNCTUATION:
+        case Character.START_PUNCTUATION:
+        case Character.END_PUNCTUATION:
+        case Character.CONNECTOR_PUNCTUATION:
+        case Character.OTHER_PUNCTUATION:
+	  r = true;
+	  break;
+	default:
+	  r = false;
+	  break;
+	}
+	return r;
+      }
+    });
+    //pw_s.println("  }");
+    fw = new FileWriter("x.out",true);
+    fw.write(sw.toString());
+    fw.close();
+  }
+  static StringWriter sw = new StringWriter();
+  static PrintWriter pw_s = new PrintWriter(sw,true);
+  public static void test(String var,Tester t) throws Exception {
+
+    char[] ca = new char[(66536 >> 4)+1];
+    Bits b = new Bits(ca);
+    FileWriter fw = new FileWriter("x.out",true);
+    PrintWriter pw = new PrintWriter(fw);
+
+    //pw_s.println("    "+var+"_f();");
+    pw.println("  public static Bits "+var+";");
+    pw.println("  static void "+var+"_f() {");
+    pw.println("    char[] data = new char["+ca.length+"];");
+    pw.println("    "+var+" = new Bits(data);");
+    for(int i=0;i<66536;i++) {
+      char c = (char)i;
+      //b.set(i,Character.getType(c)==Character.CURRENCY_SYMBOL);
+      b.set(i,t.test(c));
+    }
+    for(int i=0;i<ca.length;i++) {
+      if(ca[i] != 0) {
+        pw.println("    data["+i+"]=(char)0x"+n4(ca[i])+";");
+      }
+    }
+    pw.println();
+    pw.println("  }");
+
+    pw.close();
+  }
+  */
+  public static Bits upper;
+  static void upper_f() {
+    char[] data = new char[4159];
+    upper = new Bits(data);
+    data[4]=(char)0xfffe;
+    data[5]=(char)0x07ff;
+    data[12]=(char)0xffff;
+    data[13]=(char)0x7f7f;
+    data[16]=(char)0x5555;
+    data[17]=(char)0x5555;
+    data[18]=(char)0x5555;
+    data[19]=(char)0xaa55;
+    data[20]=(char)0x54aa;
+    data[21]=(char)0x5555;
+    data[22]=(char)0x5555;
+    data[23]=(char)0x2b55;
+    data[24]=(char)0xced6;
+    data[25]=(char)0xb1db;
+    data[26]=(char)0xd2d5;
+    data[27]=(char)0x11ae;
+    data[28]=(char)0xa490;
+    data[29]=(char)0x4aaa;
+    data[30]=(char)0x5555;
+    data[31]=(char)0x5412;
+    data[32]=(char)0x5555;
+    data[33]=(char)0x0055;
+    data[56]=(char)0xd740;
+    data[57]=(char)0xfffe;
+    data[58]=(char)0x0ffb;
+    data[61]=(char)0x541c;
+    data[62]=(char)0x5555;
+    data[64]=(char)0xdffe;
+    data[65]=(char)0xffff;
+    data[66]=(char)0xffff;
+    data[70]=(char)0x5555;
+    data[71]=(char)0x5555;
+    data[72]=(char)0x0001;
+    data[73]=(char)0x5555;
+    data[74]=(char)0x5555;
+    data[75]=(char)0x5555;
+    data[76]=(char)0x088a;
+    data[77]=(char)0x5555;
+    data[78]=(char)0x4555;
+    data[79]=(char)0x0115;
+    data[83]=(char)0xfffe;
+    data[84]=(char)0xffff;
+    data[85]=(char)0x007f;
+    data[266]=(char)0xffff;
+    data[267]=(char)0xffff;
+    data[268]=(char)0x003f;
+    data[480]=(char)0x5555;
+    data[481]=(char)0x5555;
+    data[482]=(char)0x5555;
+    data[483]=(char)0x5555;
+    data[484]=(char)0x5555;
+    data[485]=(char)0x5555;
+    data[486]=(char)0x5555;
+    data[487]=(char)0x5555;
+    data[488]=(char)0x5555;
+    data[489]=(char)0x0015;
+    data[490]=(char)0x5555;
+    data[491]=(char)0x5555;
+    data[492]=(char)0x5555;
+    data[493]=(char)0x5555;
+    data[494]=(char)0x5555;
+    data[495]=(char)0x0155;
+    data[496]=(char)0xff00;
+    data[497]=(char)0x3f00;
+    data[498]=(char)0xff00;
+    data[499]=(char)0xff00;
+    data[500]=(char)0x3f00;
+    data[501]=(char)0xaa00;
+    data[502]=(char)0xff00;
+    data[504]=(char)0xff00;
+    data[505]=(char)0xff00;
+    data[506]=(char)0xff00;
+    data[507]=(char)0x5f00;
+    data[508]=(char)0x1f00;
+    data[509]=(char)0x0f00;
+    data[510]=(char)0x1f00;
+    data[511]=(char)0x1f00;
+    data[528]=(char)0x3884;
+    data[529]=(char)0x3f27;
+    data[530]=(char)0x3d50;
+    data[531]=(char)0x000b;
+    data[4082]=(char)0xfffe;
+    data[4083]=(char)0x07ff;
+    data[4100]=(char)0xfffe;
+    data[4101]=(char)0x07ff;
+    data[4108]=(char)0xffff;
+    data[4109]=(char)0x7f7f;
+    data[4112]=(char)0x5555;
+    data[4113]=(char)0x5555;
+    data[4114]=(char)0x5555;
+    data[4115]=(char)0xaa55;
+    data[4116]=(char)0x54aa;
+    data[4117]=(char)0x5555;
+    data[4118]=(char)0x5555;
+    data[4119]=(char)0x2b55;
+    data[4120]=(char)0xced6;
+    data[4121]=(char)0xb1db;
+    data[4122]=(char)0xd2d5;
+    data[4123]=(char)0x11ae;
+    data[4124]=(char)0xa490;
+    data[4125]=(char)0x4aaa;
+    data[4126]=(char)0x5555;
+    data[4127]=(char)0x5412;
+    data[4128]=(char)0x5555;
+    data[4129]=(char)0x0055;
+    data[4152]=(char)0xd740;
+    data[4153]=(char)0xfffe;
+    data[4154]=(char)0x0ffb;
+    data[4157]=(char)0x541c;
+    data[4158]=(char)0x0055;
+
+  }
+  public static Bits lower;
+  static void lower_f() {
+    char[] data = new char[4159];
+    lower = new Bits(data);
+    data[6]=(char)0xfffe;
+    data[7]=(char)0x07ff;
+    data[10]=(char)0x0400;
+    data[11]=(char)0x0420;
+    data[13]=(char)0x8000;
+    data[14]=(char)0xffff;
+    data[15]=(char)0xff7f;
+    data[16]=(char)0xaaaa;
+    data[17]=(char)0xaaaa;
+    data[18]=(char)0xaaaa;
+    data[19]=(char)0x55aa;
+    data[20]=(char)0xab55;
+    data[21]=(char)0xaaaa;
+    data[22]=(char)0xaaaa;
+    data[23]=(char)0xd4aa;
+    data[24]=(char)0x3129;
+    data[25]=(char)0x4e24;
+    data[26]=(char)0x292a;
+    data[27]=(char)0x2651;
+    data[28]=(char)0x5240;
+    data[29]=(char)0xb555;
+    data[30]=(char)0xaaaa;
+    data[31]=(char)0xa829;
+    data[32]=(char)0xaaaa;
+    data[33]=(char)0x00aa;
+    data[37]=(char)0xffff;
+    data[38]=(char)0xffff;
+    data[39]=(char)0xffff;
+    data[40]=(char)0xffff;
+    data[41]=(char)0xffff;
+    data[42]=(char)0x01ff;
+    data[57]=(char)0x0001;
+    data[58]=(char)0xf000;
+    data[59]=(char)0xffff;
+    data[60]=(char)0x7fff;
+    data[61]=(char)0x0063;
+    data[62]=(char)0xaaa8;
+    data[63]=(char)0x0007;
+    data[67]=(char)0xffff;
+    data[68]=(char)0xffff;
+    data[69]=(char)0xdffe;
+    data[70]=(char)0xaaaa;
+    data[71]=(char)0xaaaa;
+    data[72]=(char)0x0002;
+    data[73]=(char)0xaaaa;
+    data[74]=(char)0xaaaa;
+    data[75]=(char)0xaaaa;
+    data[76]=(char)0x1114;
+    data[77]=(char)0xaaaa;
+    data[78]=(char)0x8aaa;
+    data[79]=(char)0x022a;
+    data[86]=(char)0xfffe;
+    data[87]=(char)0xffff;
+    data[88]=(char)0x00ff;
+    data[269]=(char)0xffff;
+    data[270]=(char)0xffff;
+    data[271]=(char)0x007f;
+    data[480]=(char)0xaaaa;
+    data[481]=(char)0xaaaa;
+    data[482]=(char)0xaaaa;
+    data[483]=(char)0xaaaa;
+    data[484]=(char)0xaaaa;
+    data[485]=(char)0xaaaa;
+    data[486]=(char)0xaaaa;
+    data[487]=(char)0xaaaa;
+    data[488]=(char)0xaaaa;
+    data[489]=(char)0x0fea;
+    data[490]=(char)0xaaaa;
+    data[491]=(char)0xaaaa;
+    data[492]=(char)0xaaaa;
+    data[493]=(char)0xaaaa;
+    data[494]=(char)0xaaaa;
+    data[495]=(char)0x02aa;
+    data[496]=(char)0x00ff;
+    data[497]=(char)0x003f;
+    data[498]=(char)0x00ff;
+    data[499]=(char)0x00ff;
+    data[500]=(char)0x003f;
+    data[501]=(char)0x00ff;
+    data[502]=(char)0x00ff;
+    data[503]=(char)0x3fff;
+    data[504]=(char)0x00ff;
+    data[505]=(char)0x00ff;
+    data[506]=(char)0x00ff;
+    data[507]=(char)0x00df;
+    data[508]=(char)0x00dc;
+    data[509]=(char)0x00cf;
+    data[510]=(char)0x00ff;
+    data[511]=(char)0x00dc;
+    data[519]=(char)0x8000;
+    data[528]=(char)0xc400;
+    data[529]=(char)0x0008;
+    data[530]=(char)0xc000;
+    data[531]=(char)0x0010;
+    data[4016]=(char)0x007f;
+    data[4017]=(char)0x00f8;
+    data[4084]=(char)0xfffe;
+    data[4085]=(char)0x07ff;
+    data[4102]=(char)0xfffe;
+    data[4103]=(char)0x07ff;
+    data[4106]=(char)0x0400;
+    data[4107]=(char)0x0420;
+    data[4109]=(char)0x8000;
+    data[4110]=(char)0xffff;
+    data[4111]=(char)0xff7f;
+    data[4112]=(char)0xaaaa;
+    data[4113]=(char)0xaaaa;
+    data[4114]=(char)0xaaaa;
+    data[4115]=(char)0x55aa;
+    data[4116]=(char)0xab55;
+    data[4117]=(char)0xaaaa;
+    data[4118]=(char)0xaaaa;
+    data[4119]=(char)0xd4aa;
+    data[4120]=(char)0x3129;
+    data[4121]=(char)0x4e24;
+    data[4122]=(char)0x292a;
+    data[4123]=(char)0x2651;
+    data[4124]=(char)0x5240;
+    data[4125]=(char)0xb555;
+    data[4126]=(char)0xaaaa;
+    data[4127]=(char)0xa829;
+    data[4128]=(char)0xaaaa;
+    data[4129]=(char)0x00aa;
+    data[4133]=(char)0xffff;
+    data[4134]=(char)0xffff;
+    data[4135]=(char)0xffff;
+    data[4136]=(char)0xffff;
+    data[4137]=(char)0xffff;
+    data[4138]=(char)0x01ff;
+    data[4153]=(char)0x0001;
+    data[4154]=(char)0xf000;
+    data[4155]=(char)0xffff;
+    data[4156]=(char)0x7fff;
+    data[4157]=(char)0x0063;
+    data[4158]=(char)0x00a8;
+
+  }
+  public static Bits title;
+  static void title_f() {
+    char[] data = new char[4159];
+    title = new Bits(data);
+    data[6]=(char)0xfffe;
+    data[7]=(char)0x07ff;
+    data[10]=(char)0x0400;
+    data[11]=(char)0x0420;
+    data[13]=(char)0x8000;
+    data[14]=(char)0xffff;
+    data[15]=(char)0xff7f;
+    data[16]=(char)0xaaaa;
+    data[17]=(char)0xaaaa;
+    data[18]=(char)0xaaaa;
+    data[19]=(char)0x55aa;
+    data[20]=(char)0xab55;
+    data[21]=(char)0xaaaa;
+    data[22]=(char)0xaaaa;
+    data[23]=(char)0xd4aa;
+    data[24]=(char)0x3129;
+    data[25]=(char)0x4e24;
+    data[26]=(char)0x292a;
+    data[27]=(char)0x2651;
+    data[28]=(char)0x5240;
+    data[29]=(char)0xb555;
+    data[30]=(char)0xaaaa;
+    data[31]=(char)0xa829;
+    data[32]=(char)0xaaaa;
+    data[33]=(char)0x00aa;
+    data[37]=(char)0xffff;
+    data[38]=(char)0xffff;
+    data[39]=(char)0xffff;
+    data[40]=(char)0xffff;
+    data[41]=(char)0xffff;
+    data[42]=(char)0x01ff;
+    data[57]=(char)0x0001;
+    data[58]=(char)0xf000;
+    data[59]=(char)0xffff;
+    data[60]=(char)0x7fff;
+    data[61]=(char)0x0063;
+    data[62]=(char)0xaaa8;
+    data[63]=(char)0x0007;
+    data[67]=(char)0xffff;
+    data[68]=(char)0xffff;
+    data[69]=(char)0xdffe;
+    data[70]=(char)0xaaaa;
+    data[71]=(char)0xaaaa;
+    data[72]=(char)0x0002;
+    data[73]=(char)0xaaaa;
+    data[74]=(char)0xaaaa;
+    data[75]=(char)0xaaaa;
+    data[76]=(char)0x1114;
+    data[77]=(char)0xaaaa;
+    data[78]=(char)0x8aaa;
+    data[79]=(char)0x022a;
+    data[86]=(char)0xfffe;
+    data[87]=(char)0xffff;
+    data[88]=(char)0x00ff;
+    data[269]=(char)0xffff;
+    data[270]=(char)0xffff;
+    data[271]=(char)0x007f;
+    data[480]=(char)0xaaaa;
+    data[481]=(char)0xaaaa;
+    data[482]=(char)0xaaaa;
+    data[483]=(char)0xaaaa;
+    data[484]=(char)0xaaaa;
+    data[485]=(char)0xaaaa;
+    data[486]=(char)0xaaaa;
+    data[487]=(char)0xaaaa;
+    data[488]=(char)0xaaaa;
+    data[489]=(char)0x0fea;
+    data[490]=(char)0xaaaa;
+    data[491]=(char)0xaaaa;
+    data[492]=(char)0xaaaa;
+    data[493]=(char)0xaaaa;
+    data[494]=(char)0xaaaa;
+    data[495]=(char)0x02aa;
+    data[496]=(char)0x00ff;
+    data[497]=(char)0x003f;
+    data[498]=(char)0x00ff;
+    data[499]=(char)0x00ff;
+    data[500]=(char)0x003f;
+    data[501]=(char)0x00ff;
+    data[502]=(char)0x00ff;
+    data[503]=(char)0x3fff;
+    data[504]=(char)0x00ff;
+    data[505]=(char)0x00ff;
+    data[506]=(char)0x00ff;
+    data[507]=(char)0x00df;
+    data[508]=(char)0x00dc;
+    data[509]=(char)0x00cf;
+    data[510]=(char)0x00ff;
+    data[511]=(char)0x00dc;
+    data[519]=(char)0x8000;
+    data[528]=(char)0xc400;
+    data[529]=(char)0x0008;
+    data[530]=(char)0xc000;
+    data[531]=(char)0x0010;
+    data[4016]=(char)0x007f;
+    data[4017]=(char)0x00f8;
+    data[4084]=(char)0xfffe;
+    data[4085]=(char)0x07ff;
+    data[4102]=(char)0xfffe;
+    data[4103]=(char)0x07ff;
+    data[4106]=(char)0x0400;
+    data[4107]=(char)0x0420;
+    data[4109]=(char)0x8000;
+    data[4110]=(char)0xffff;
+    data[4111]=(char)0xff7f;
+    data[4112]=(char)0xaaaa;
+    data[4113]=(char)0xaaaa;
+    data[4114]=(char)0xaaaa;
+    data[4115]=(char)0x55aa;
+    data[4116]=(char)0xab55;
+    data[4117]=(char)0xaaaa;
+    data[4118]=(char)0xaaaa;
+    data[4119]=(char)0xd4aa;
+    data[4120]=(char)0x3129;
+    data[4121]=(char)0x4e24;
+    data[4122]=(char)0x292a;
+    data[4123]=(char)0x2651;
+    data[4124]=(char)0x5240;
+    data[4125]=(char)0xb555;
+    data[4126]=(char)0xaaaa;
+    data[4127]=(char)0xa829;
+    data[4128]=(char)0xaaaa;
+    data[4129]=(char)0x00aa;
+    data[4133]=(char)0xffff;
+    data[4134]=(char)0xffff;
+    data[4135]=(char)0xffff;
+    data[4136]=(char)0xffff;
+    data[4137]=(char)0xffff;
+    data[4138]=(char)0x01ff;
+    data[4153]=(char)0x0001;
+    data[4154]=(char)0xf000;
+    data[4155]=(char)0xffff;
+    data[4156]=(char)0x7fff;
+    data[4157]=(char)0x0063;
+    data[4158]=(char)0x00a8;
+
+  }
+  public static Bits currency;
+  static void currency_f() {
+    char[] data = new char[4159];
+    currency = new Bits(data);
+    data[2]=(char)0x0010;
+    data[10]=(char)0x003c;
+    data[159]=(char)0x000c;
+    data[227]=(char)0x8000;
+    data[522]=(char)0x1fff;
+    data[4070]=(char)0x0200;
+    data[4080]=(char)0x0010;
+    data[4094]=(char)0x0063;
+    data[4098]=(char)0x0010;
+    data[4106]=(char)0x003c;
+
+  }
+  public static Bits decimal_digit;
+  static void decimal_digit_f() {
+    char[] data = new char[4159];
+    decimal_digit = new Bits(data);
+    data[3]=(char)0x03ff;
+    data[102]=(char)0x03ff;
+    data[111]=(char)0x03ff;
+    data[150]=(char)0xffc0;
+    data[158]=(char)0xffc0;
+    data[166]=(char)0xffc0;
+    data[174]=(char)0xffc0;
+    data[182]=(char)0xffc0;
+    data[190]=(char)0xff80;
+    data[198]=(char)0xffc0;
+    data[206]=(char)0xffc0;
+    data[214]=(char)0xffc0;
+    data[229]=(char)0x03ff;
+    data[237]=(char)0x03ff;
+    data[242]=(char)0x03ff;
+    data[4081]=(char)0x03ff;
+    data[4099]=(char)0x03ff;
+
+  }
+  public static Bits math;
+  static void math_f() {
+    char[] data = new char[4159];
+    math = new Bits(data);
+    data[2]=(char)0x0800;
+    data[3]=(char)0x7000;
+    data[7]=(char)0x5000;
+    data[10]=(char)0x1000;
+    data[11]=(char)0x0002;
+    data[13]=(char)0x0080;
+    data[15]=(char)0x0080;
+    data[516]=(char)0x0010;
+    data[519]=(char)0x1c00;
+    data[520]=(char)0x1c00;
+    data[537]=(char)0x001f;
+    data[541]=(char)0x0014;
+    data[544]=(char)0xffff;
+    data[545]=(char)0xffff;
+    data[546]=(char)0xffff;
+    data[547]=(char)0xffff;
+    data[548]=(char)0xffff;
+    data[549]=(char)0xffff;
+    data[550]=(char)0xffff;
+    data[551]=(char)0xffff;
+    data[552]=(char)0xffff;
+    data[553]=(char)0xffff;
+    data[554]=(char)0xffff;
+    data[555]=(char)0xffff;
+    data[556]=(char)0xffff;
+    data[557]=(char)0xffff;
+    data[558]=(char)0xffff;
+    data[559]=(char)0x0003;
+    data[560]=(char)0x0f00;
+    data[562]=(char)0x0003;
+    data[4018]=(char)0x0200;
+    data[4070]=(char)0x0074;
+    data[4080]=(char)0x0800;
+    data[4081]=(char)0x7000;
+    data[4085]=(char)0x5000;
+    data[4094]=(char)0x1f04;
+    data[4098]=(char)0x0800;
+    data[4099]=(char)0x7000;
+    data[4103]=(char)0x5000;
+    data[4106]=(char)0x1000;
+    data[4107]=(char)0x0002;
+    data[4109]=(char)0x0080;
+    data[4111]=(char)0x0080;
+
+  }
+  public static Bits letter;
+  static void letter_f() {
+    char[] data = new char[4159];
+    letter = new Bits(data);
+    data[4]=(char)0xfffe;
+    data[5]=(char)0x07ff;
+    data[6]=(char)0xfffe;
+    data[7]=(char)0x07ff;
+    data[10]=(char)0x0400;
+    data[11]=(char)0x0420;
+    data[12]=(char)0xffff;
+    data[13]=(char)0xff7f;
+    data[14]=(char)0xffff;
+    data[15]=(char)0xff7f;
+    data[16]=(char)0xffff;
+    data[17]=(char)0xffff;
+    data[18]=(char)0xffff;
+    data[19]=(char)0xffff;
+    data[20]=(char)0xffff;
+    data[21]=(char)0xffff;
+    data[22]=(char)0xffff;
+    data[23]=(char)0xffff;
+    data[24]=(char)0xffff;
+    data[25]=(char)0xffff;
+    data[26]=(char)0xffff;
+    data[27]=(char)0xffff;
+    data[28]=(char)0xffff;
+    data[29]=(char)0xffff;
+    data[30]=(char)0xffff;
+    data[31]=(char)0xfc3f;
+    data[32]=(char)0xffff;
+    data[33]=(char)0x00ff;
+    data[37]=(char)0xffff;
+    data[38]=(char)0xffff;
+    data[39]=(char)0xffff;
+    data[40]=(char)0xffff;
+    data[41]=(char)0xffff;
+    data[42]=(char)0x01ff;
+    data[43]=(char)0xf9ff;
+    data[44]=(char)0x0003;
+    data[45]=(char)0x0003;
+    data[46]=(char)0x001f;
+    data[55]=(char)0x0400;
+    data[56]=(char)0xd740;
+    data[57]=(char)0xffff;
+    data[58]=(char)0xfffb;
+    data[59]=(char)0xffff;
+    data[60]=(char)0x7fff;
+    data[61]=(char)0x547f;
+    data[62]=(char)0xfffd;
+    data[63]=(char)0x000f;
+    data[64]=(char)0xdffe;
+    data[65]=(char)0xffff;
+    data[66]=(char)0xffff;
+    data[67]=(char)0xffff;
+    data[68]=(char)0xffff;
+    data[69]=(char)0xdffe;
+    data[70]=(char)0xffff;
+    data[71]=(char)0xffff;
+    data[72]=(char)0x0003;
+    data[73]=(char)0xffff;
+    data[74]=(char)0xffff;
+    data[75]=(char)0xffff;
+    data[76]=(char)0x199f;
+    data[77]=(char)0xffff;
+    data[78]=(char)0xcfff;
+    data[79]=(char)0x033f;
+    data[83]=(char)0xfffe;
+    data[84]=(char)0xffff;
+    data[85]=(char)0x027f;
+    data[86]=(char)0xfffe;
+    data[87]=(char)0xffff;
+    data[88]=(char)0x00ff;
+    data[93]=(char)0xffff;
+    data[94]=(char)0x07ff;
+    data[95]=(char)0x0007;
+    data[98]=(char)0xfffe;
+    data[99]=(char)0x07ff;
+    data[100]=(char)0x07ff;
+    data[103]=(char)0xfffe;
+    data[104]=(char)0xffff;
+    data[105]=(char)0xffff;
+    data[106]=(char)0xffff;
+    data[107]=(char)0x7cff;
+    data[108]=(char)0x7fff;
+    data[109]=(char)0x002f;
+    data[110]=(char)0x0060;
+    data[144]=(char)0xffe0;
+    data[145]=(char)0xffff;
+    data[146]=(char)0xffff;
+    data[147]=(char)0x23ff;
+    data[149]=(char)0xff00;
+    data[150]=(char)0x0003;
+    data[152]=(char)0x9fe0;
+    data[153]=(char)0xfff9;
+    data[154]=(char)0xfdff;
+    data[155]=(char)0x03c5;
+    data[157]=(char)0xb000;
+    data[158]=(char)0x0003;
+    data[159]=(char)0x0003;
+    data[160]=(char)0x87e0;
+    data[161]=(char)0xfff9;
+    data[162]=(char)0xfdff;
+    data[163]=(char)0x036d;
+    data[165]=(char)0x5e00;
+    data[167]=(char)0x001c;
+    data[168]=(char)0xafe0;
+    data[169]=(char)0xfffb;
+    data[170]=(char)0xfdff;
+    data[171]=(char)0x23ed;
+    data[174]=(char)0x0001;
+    data[176]=(char)0x9fe0;
+    data[177]=(char)0xfff9;
+    data[178]=(char)0xfdff;
+    data[179]=(char)0x23cd;
+    data[181]=(char)0xb000;
+    data[182]=(char)0x0003;
+    data[184]=(char)0xc7e0;
+    data[185]=(char)0xd63d;
+    data[186]=(char)0xc718;
+    data[187]=(char)0x03bf;
+    data[192]=(char)0xdfe0;
+    data[193]=(char)0xfffd;
+    data[194]=(char)0xfdff;
+    data[195]=(char)0x03ef;
+    data[198]=(char)0x0003;
+    data[200]=(char)0xdfe0;
+    data[201]=(char)0xfffd;
+    data[202]=(char)0xfdff;
+    data[203]=(char)0x03ef;
+    data[205]=(char)0x4000;
+    data[206]=(char)0x0003;
+    data[208]=(char)0xdfe0;
+    data[209]=(char)0xfffd;
+    data[210]=(char)0xfdff;
+    data[211]=(char)0x03ff;
+    data[214]=(char)0x0003;
+    data[224]=(char)0xfffe;
+    data[225]=(char)0xffff;
+    data[226]=(char)0x7fff;
+    data[227]=(char)0x000d;
+    data[228]=(char)0x007f;
+    data[232]=(char)0x2596;
+    data[233]=(char)0xfef0;
+    data[234]=(char)0x6cae;
+    data[235]=(char)0x200d;
+    data[236]=(char)0x005f;
+    data[237]=(char)0x3000;
+    data[244]=(char)0xfeff;
+    data[245]=(char)0xffff;
+    data[246]=(char)0x03ff;
+    data[266]=(char)0xffff;
+    data[267]=(char)0xffff;
+    data[268]=(char)0x003f;
+    data[269]=(char)0xffff;
+    data[270]=(char)0xffff;
+    data[271]=(char)0x007f;
+    data[272]=(char)0xffff;
+    data[273]=(char)0xffff;
+    data[274]=(char)0xffff;
+    data[275]=(char)0xffff;
+    data[276]=(char)0xffff;
+    data[277]=(char)0x83ff;
+    data[278]=(char)0xffff;
+    data[279]=(char)0xffff;
+    data[280]=(char)0xffff;
+    data[281]=(char)0xffff;
+    data[282]=(char)0xff07;
+    data[283]=(char)0xffff;
+    data[284]=(char)0xffff;
+    data[285]=(char)0xffff;
+    data[286]=(char)0xffff;
+    data[287]=(char)0x03ff;
+    data[480]=(char)0xffff;
+    data[481]=(char)0xffff;
+    data[482]=(char)0xffff;
+    data[483]=(char)0xffff;
+    data[484]=(char)0xffff;
+    data[485]=(char)0xffff;
+    data[486]=(char)0xffff;
+    data[487]=(char)0xffff;
+    data[488]=(char)0xffff;
+    data[489]=(char)0x0fff;
+    data[490]=(char)0xffff;
+    data[491]=(char)0xffff;
+    data[492]=(char)0xffff;
+    data[493]=(char)0xffff;
+    data[494]=(char)0xffff;
+    data[495]=(char)0x03ff;
+    data[496]=(char)0xffff;
+    data[497]=(char)0x3f3f;
+    data[498]=(char)0xffff;
+    data[499]=(char)0xffff;
+    data[500]=(char)0x3f3f;
+    data[501]=(char)0xaaff;
+    data[502]=(char)0xffff;
+    data[503]=(char)0x3fff;
+    data[504]=(char)0xffff;
+    data[505]=(char)0xffff;
+    data[506]=(char)0xffff;
+    data[507]=(char)0x5fdf;
+    data[508]=(char)0x1fdc;
+    data[509]=(char)0x0fcf;
+    data[510]=(char)0x1fff;
+    data[511]=(char)0x1fdc;
+    data[519]=(char)0x8000;
+    data[528]=(char)0xfc84;
+    data[529]=(char)0x3f2f;
+    data[530]=(char)0xfd50;
+    data[531]=(char)0x01fb;
+    data[768]=(char)0x0020;
+    data[771]=(char)0x003e;
+    data[772]=(char)0xfffe;
+    data[773]=(char)0xffff;
+    data[774]=(char)0xffff;
+    data[775]=(char)0xffff;
+    data[776]=(char)0xffff;
+    data[777]=(char)0x781f;
+    data[778]=(char)0xfffe;
+    data[779]=(char)0xffff;
+    data[780]=(char)0xffff;
+    data[781]=(char)0xffff;
+    data[782]=(char)0xffff;
+    data[783]=(char)0x77ff;
+    data[784]=(char)0xffe0;
+    data[785]=(char)0xffff;
+    data[786]=(char)0x1fff;
+    data[787]=(char)0xfffe;
+    data[788]=(char)0xffff;
+    data[789]=(char)0xffff;
+    data[790]=(char)0xffff;
+    data[791]=(char)0xffff;
+    data[792]=(char)0x7fff;
+    data[1248]=(char)0xffff;
+    data[1249]=(char)0xffff;
+    data[1250]=(char)0xffff;
+    data[1251]=(char)0xffff;
+    data[1252]=(char)0xffff;
+    data[1253]=(char)0xffff;
+    data[1254]=(char)0xffff;
+    data[1255]=(char)0xffff;
+    data[1256]=(char)0xffff;
+    data[1257]=(char)0xffff;
+    data[1258]=(char)0xffff;
+    data[1259]=(char)0xffff;
+    data[1260]=(char)0xffff;
+    data[1261]=(char)0xffff;
+    data[1262]=(char)0xffff;
+    data[1263]=(char)0xffff;
+    data[1264]=(char)0xffff;
+    data[1265]=(char)0xffff;
+    data[1266]=(char)0xffff;
+    data[1267]=(char)0xffff;
+    data[1268]=(char)0xffff;
+    data[1269]=(char)0xffff;
+    data[1270]=(char)0xffff;
+    data[1271]=(char)0xffff;
+    data[1272]=(char)0xffff;
+    data[1273]=(char)0xffff;
+    data[1274]=(char)0xffff;
+    data[1275]=(char)0xffff;
+    data[1276]=(char)0xffff;
+    data[1277]=(char)0xffff;
+    data[1278]=(char)0xffff;
+    data[1279]=(char)0xffff;
+    data[1280]=(char)0xffff;
+    data[1281]=(char)0xffff;
+    data[1282]=(char)0xffff;
+    data[1283]=(char)0xffff;
+    data[1284]=(char)0xffff;
+    data[1285]=(char)0xffff;
+    data[1286]=(char)0xffff;
+    data[1287]=(char)0xffff;
+    data[1288]=(char)0xffff;
+    data[1289]=(char)0xffff;
+    data[1290]=(char)0xffff;
+    data[1291]=(char)0xffff;
+    data[1292]=(char)0xffff;
+    data[1293]=(char)0xffff;
+    data[1294]=(char)0xffff;
+    data[1295]=(char)0xffff;
+    data[1296]=(char)0xffff;
+    data[1297]=(char)0xffff;
+    data[1298]=(char)0xffff;
+    data[1299]=(char)0xffff;
+    data[1300]=(char)0xffff;
+    data[1301]=(char)0xffff;
+    data[1302]=(char)0xffff;
+    data[1303]=(char)0xffff;
+    data[1304]=(char)0xffff;
+    data[1305]=(char)0xffff;
+    data[1306]=(char)0xffff;
+    data[1307]=(char)0xffff;
+    data[1308]=(char)0xffff;
+    data[1309]=(char)0xffff;
+    data[1310]=(char)0xffff;
+    data[1311]=(char)0xffff;
+    data[1312]=(char)0xffff;
+    data[1313]=(char)0xffff;
+    data[1314]=(char)0xffff;
+    data[1315]=(char)0xffff;
+    data[1316]=(char)0xffff;
+    data[1317]=(char)0xffff;
+    data[1318]=(char)0xffff;
+    data[1319]=(char)0xffff;
+    data[1320]=(char)0xffff;
+    data[1321]=(char)0xffff;
+    data[1322]=(char)0xffff;
+    data[1323]=(char)0xffff;
+    data[1324]=(char)0xffff;
+    data[1325]=(char)0xffff;
+    data[1326]=(char)0xffff;
+    data[1327]=(char)0xffff;
+    data[1328]=(char)0xffff;
+    data[1329]=(char)0xffff;
+    data[1330]=(char)0xffff;
+    data[1331]=(char)0xffff;
+    data[1332]=(char)0xffff;
+    data[1333]=(char)0xffff;
+    data[1334]=(char)0xffff;
+    data[1335]=(char)0xffff;
+    data[1336]=(char)0xffff;
+    data[1337]=(char)0xffff;
+    data[1338]=(char)0xffff;
+    data[1339]=(char)0xffff;
+    data[1340]=(char)0xffff;
+    data[1341]=(char)0xffff;
+    data[1342]=(char)0xffff;
+    data[1343]=(char)0xffff;
+    data[1344]=(char)0xffff;
+    data[1345]=(char)0xffff;
+    data[1346]=(char)0xffff;
+    data[1347]=(char)0xffff;
+    data[1348]=(char)0xffff;
+    data[1349]=(char)0xffff;
+    data[1350]=(char)0xffff;
+    data[1351]=(char)0xffff;
+    data[1352]=(char)0xffff;
+    data[1353]=(char)0xffff;
+    data[1354]=(char)0xffff;
+    data[1355]=(char)0xffff;
+    data[1356]=(char)0xffff;
+    data[1357]=(char)0xffff;
+    data[1358]=(char)0xffff;
+    data[1359]=(char)0xffff;
+    data[1360]=(char)0xffff;
+    data[1361]=(char)0xffff;
+    data[1362]=(char)0xffff;
+    data[1363]=(char)0xffff;
+    data[1364]=(char)0xffff;
+    data[1365]=(char)0xffff;
+    data[1366]=(char)0xffff;
+    data[1367]=(char)0xffff;
+    data[1368]=(char)0xffff;
+    data[1369]=(char)0xffff;
+    data[1370]=(char)0xffff;
+    data[1371]=(char)0xffff;
+    data[1372]=(char)0xffff;
+    data[1373]=(char)0xffff;
+    data[1374]=(char)0xffff;
+    data[1375]=(char)0xffff;
+    data[1376]=(char)0xffff;
+    data[1377]=(char)0xffff;
+    data[1378]=(char)0xffff;
+    data[1379]=(char)0xffff;
+    data[1380]=(char)0xffff;
+    data[1381]=(char)0xffff;
+    data[1382]=(char)0xffff;
+    data[1383]=(char)0xffff;
+    data[1384]=(char)0xffff;
+    data[1385]=(char)0xffff;
+    data[1386]=(char)0xffff;
+    data[1387]=(char)0xffff;
+    data[1388]=(char)0xffff;
+    data[1389]=(char)0xffff;
+    data[1390]=(char)0xffff;
+    data[1391]=(char)0xffff;
+    data[1392]=(char)0xffff;
+    data[1393]=(char)0xffff;
+    data[1394]=(char)0xffff;
+    data[1395]=(char)0xffff;
+    data[1396]=(char)0xffff;
+    data[1397]=(char)0xffff;
+    data[1398]=(char)0xffff;
+    data[1399]=(char)0xffff;
+    data[1400]=(char)0xffff;
+    data[1401]=(char)0xffff;
+    data[1402]=(char)0xffff;
+    data[1403]=(char)0xffff;
+    data[1404]=(char)0xffff;
+    data[1405]=(char)0xffff;
+    data[1406]=(char)0xffff;
+    data[1407]=(char)0xffff;
+    data[1408]=(char)0xffff;
+    data[1409]=(char)0xffff;
+    data[1410]=(char)0xffff;
+    data[1411]=(char)0xffff;
+    data[1412]=(char)0xffff;
+    data[1413]=(char)0xffff;
+    data[1414]=(char)0xffff;
+    data[1415]=(char)0xffff;
+    data[1416]=(char)0xffff;
+    data[1417]=(char)0xffff;
+    data[1418]=(char)0xffff;
+    data[1419]=(char)0xffff;
+    data[1420]=(char)0xffff;
+    data[1421]=(char)0xffff;
+    data[1422]=(char)0xffff;
+    data[1423]=(char)0xffff;
+    data[1424]=(char)0xffff;
+    data[1425]=(char)0xffff;
+    data[1426]=(char)0xffff;
+    data[1427]=(char)0xffff;
+    data[1428]=(char)0xffff;
+    data[1429]=(char)0xffff;
+    data[1430]=(char)0xffff;
+    data[1431]=(char)0xffff;
+    data[1432]=(char)0xffff;
+    data[1433]=(char)0xffff;
+    data[1434]=(char)0xffff;
+    data[1435]=(char)0xffff;
+    data[1436]=(char)0xffff;
+    data[1437]=(char)0xffff;
+    data[1438]=(char)0xffff;
+    data[1439]=(char)0xffff;
+    data[1440]=(char)0xffff;
+    data[1441]=(char)0xffff;
+    data[1442]=(char)0xffff;
+    data[1443]=(char)0xffff;
+    data[1444]=(char)0xffff;
+    data[1445]=(char)0xffff;
+    data[1446]=(char)0xffff;
+    data[1447]=(char)0xffff;
+    data[1448]=(char)0xffff;
+    data[1449]=(char)0xffff;
+    data[1450]=(char)0xffff;
+    data[1451]=(char)0xffff;
+    data[1452]=(char)0xffff;
+    data[1453]=(char)0xffff;
+    data[1454]=(char)0xffff;
+    data[1455]=(char)0xffff;
+    data[1456]=(char)0xffff;
+    data[1457]=(char)0xffff;
+    data[1458]=(char)0xffff;
+    data[1459]=(char)0xffff;
+    data[1460]=(char)0xffff;
+    data[1461]=(char)0xffff;
+    data[1462]=(char)0xffff;
+    data[1463]=(char)0xffff;
+    data[1464]=(char)0xffff;
+    data[1465]=(char)0xffff;
+    data[1466]=(char)0xffff;
+    data[1467]=(char)0xffff;
+    data[1468]=(char)0xffff;
+    data[1469]=(char)0xffff;
+    data[1470]=(char)0xffff;
+    data[1471]=(char)0xffff;
+    data[1472]=(char)0xffff;
+    data[1473]=(char)0xffff;
+    data[1474]=(char)0xffff;
+    data[1475]=(char)0xffff;
+    data[1476]=(char)0xffff;
+    data[1477]=(char)0xffff;
+    data[1478]=(char)0xffff;
+    data[1479]=(char)0xffff;
+    data[1480]=(char)0xffff;
+    data[1481]=(char)0xffff;
+    data[1482]=(char)0xffff;
+    data[1483]=(char)0xffff;
+    data[1484]=(char)0xffff;
+    data[1485]=(char)0xffff;
+    data[1486]=(char)0xffff;
+    data[1487]=(char)0xffff;
+    data[1488]=(char)0xffff;
+    data[1489]=(char)0xffff;
+    data[1490]=(char)0xffff;
+    data[1491]=(char)0xffff;
+    data[1492]=(char)0xffff;
+    data[1493]=(char)0xffff;
+    data[1494]=(char)0xffff;
+    data[1495]=(char)0xffff;
+    data[1496]=(char)0xffff;
+    data[1497]=(char)0xffff;
+    data[1498]=(char)0xffff;
+    data[1499]=(char)0xffff;
+    data[1500]=(char)0xffff;
+    data[1501]=(char)0xffff;
+    data[1502]=(char)0xffff;
+    data[1503]=(char)0xffff;
+    data[1504]=(char)0xffff;
+    data[1505]=(char)0xffff;
+    data[1506]=(char)0xffff;
+    data[1507]=(char)0xffff;
+    data[1508]=(char)0xffff;
+    data[1509]=(char)0xffff;
+    data[1510]=(char)0xffff;
+    data[1511]=(char)0xffff;
+    data[1512]=(char)0xffff;
+    data[1513]=(char)0xffff;
+    data[1514]=(char)0xffff;
+    data[1515]=(char)0xffff;
+    data[1516]=(char)0xffff;
+    data[1517]=(char)0xffff;
+    data[1518]=(char)0xffff;
+    data[1519]=(char)0xffff;
+    data[1520]=(char)0xffff;
+    data[1521]=(char)0xffff;
+    data[1522]=(char)0xffff;
+    data[1523]=(char)0xffff;
+    data[1524]=(char)0xffff;
+    data[1525]=(char)0xffff;
+    data[1526]=(char)0xffff;
+    data[1527]=(char)0xffff;
+    data[1528]=(char)0xffff;
+    data[1529]=(char)0xffff;
+    data[1530]=(char)0xffff;
+    data[1531]=(char)0xffff;
+    data[1532]=(char)0xffff;
+    data[1533]=(char)0xffff;
+    data[1534]=(char)0xffff;
+    data[1535]=(char)0xffff;
+    data[1536]=(char)0xffff;
+    data[1537]=(char)0xffff;
+    data[1538]=(char)0xffff;
+    data[1539]=(char)0xffff;
+    data[1540]=(char)0xffff;
+    data[1541]=(char)0xffff;
+    data[1542]=(char)0xffff;
+    data[1543]=(char)0xffff;
+    data[1544]=(char)0xffff;
+    data[1545]=(char)0xffff;
+    data[1546]=(char)0xffff;
+    data[1547]=(char)0xffff;
+    data[1548]=(char)0xffff;
+    data[1549]=(char)0xffff;
+    data[1550]=(char)0xffff;
+    data[1551]=(char)0xffff;
+    data[1552]=(char)0xffff;
+    data[1553]=(char)0xffff;
+    data[1554]=(char)0xffff;
+    data[1555]=(char)0xffff;
+    data[1556]=(char)0xffff;
+    data[1557]=(char)0xffff;
+    data[1558]=(char)0xffff;
+    data[1559]=(char)0xffff;
+    data[1560]=(char)0xffff;
+    data[1561]=(char)0xffff;
+    data[1562]=(char)0xffff;
+    data[1563]=(char)0xffff;
+    data[1564]=(char)0xffff;
+    data[1565]=(char)0xffff;
+    data[1566]=(char)0xffff;
+    data[1567]=(char)0xffff;
+    data[1568]=(char)0xffff;
+    data[1569]=(char)0xffff;
+    data[1570]=(char)0xffff;
+    data[1571]=(char)0xffff;
+    data[1572]=(char)0xffff;
+    data[1573]=(char)0xffff;
+    data[1574]=(char)0xffff;
+    data[1575]=(char)0xffff;
+    data[1576]=(char)0xffff;
+    data[1577]=(char)0xffff;
+    data[1578]=(char)0xffff;
+    data[1579]=(char)0xffff;
+    data[1580]=(char)0xffff;
+    data[1581]=(char)0xffff;
+    data[1582]=(char)0xffff;
+    data[1583]=(char)0xffff;
+    data[1584]=(char)0xffff;
+    data[1585]=(char)0xffff;
+    data[1586]=(char)0xffff;
+    data[1587]=(char)0xffff;
+    data[1588]=(char)0xffff;
+    data[1589]=(char)0xffff;
+    data[1590]=(char)0xffff;
+    data[1591]=(char)0xffff;
+    data[1592]=(char)0xffff;
+    data[1593]=(char)0xffff;
+    data[1594]=(char)0xffff;
+    data[1595]=(char)0xffff;
+    data[1596]=(char)0xffff;
+    data[1597]=(char)0xffff;
+    data[1598]=(char)0xffff;
+    data[1599]=(char)0xffff;
+    data[1600]=(char)0xffff;
+    data[1601]=(char)0xffff;
+    data[1602]=(char)0xffff;
+    data[1603]=(char)0xffff;
+    data[1604]=(char)0xffff;
+    data[1605]=(char)0xffff;
+    data[1606]=(char)0xffff;
+    data[1607]=(char)0xffff;
+    data[1608]=(char)0xffff;
+    data[1609]=(char)0xffff;
+    data[1610]=(char)0xffff;
+    data[1611]=(char)0xffff;
+    data[1612]=(char)0xffff;
+    data[1613]=(char)0xffff;
+    data[1614]=(char)0xffff;
+    data[1615]=(char)0xffff;
+    data[1616]=(char)0xffff;
+    data[1617]=(char)0xffff;
+    data[1618]=(char)0xffff;
+    data[1619]=(char)0xffff;
+    data[1620]=(char)0xffff;
+    data[1621]=(char)0xffff;
+    data[1622]=(char)0xffff;
+    data[1623]=(char)0xffff;
+    data[1624]=(char)0xffff;
+    data[1625]=(char)0xffff;
+    data[1626]=(char)0xffff;
+    data[1627]=(char)0xffff;
+    data[1628]=(char)0xffff;
+    data[1629]=(char)0xffff;
+    data[1630]=(char)0xffff;
+    data[1631]=(char)0xffff;
+    data[1632]=(char)0xffff;
+    data[1633]=(char)0xffff;
+    data[1634]=(char)0xffff;
+    data[1635]=(char)0xffff;
+    data[1636]=(char)0xffff;
+    data[1637]=(char)0xffff;
+    data[1638]=(char)0xffff;
+    data[1639]=(char)0xffff;
+    data[1640]=(char)0xffff;
+    data[1641]=(char)0xffff;
+    data[1642]=(char)0xffff;
+    data[1643]=(char)0xffff;
+    data[1644]=(char)0xffff;
+    data[1645]=(char)0xffff;
+    data[1646]=(char)0xffff;
+    data[1647]=(char)0xffff;
+    data[1648]=(char)0xffff;
+    data[1649]=(char)0xffff;
+    data[1650]=(char)0xffff;
+    data[1651]=(char)0xffff;
+    data[1652]=(char)0xffff;
+    data[1653]=(char)0xffff;
+    data[1654]=(char)0xffff;
+    data[1655]=(char)0xffff;
+    data[1656]=(char)0xffff;
+    data[1657]=(char)0xffff;
+    data[1658]=(char)0xffff;
+    data[1659]=(char)0xffff;
+    data[1660]=(char)0xffff;
+    data[1661]=(char)0xffff;
+    data[1662]=(char)0xffff;
+    data[1663]=(char)0xffff;
+    data[1664]=(char)0xffff;
+    data[1665]=(char)0xffff;
+    data[1666]=(char)0xffff;
+    data[1667]=(char)0xffff;
+    data[1668]=(char)0xffff;
+    data[1669]=(char)0xffff;
+    data[1670]=(char)0xffff;
+    data[1671]=(char)0xffff;
+    data[1672]=(char)0xffff;
+    data[1673]=(char)0xffff;
+    data[1674]=(char)0xffff;
+    data[1675]=(char)0xffff;
+    data[1676]=(char)0xffff;
+    data[1677]=(char)0xffff;
+    data[1678]=(char)0xffff;
+    data[1679]=(char)0xffff;
+    data[1680]=(char)0xffff;
+    data[1681]=(char)0xffff;
+    data[1682]=(char)0xffff;
+    data[1683]=(char)0xffff;
+    data[1684]=(char)0xffff;
+    data[1685]=(char)0xffff;
+    data[1686]=(char)0xffff;
+    data[1687]=(char)0xffff;
+    data[1688]=(char)0xffff;
+    data[1689]=(char)0xffff;
+    data[1690]=(char)0xffff;
+    data[1691]=(char)0xffff;
+    data[1692]=(char)0xffff;
+    data[1693]=(char)0xffff;
+    data[1694]=(char)0xffff;
+    data[1695]=(char)0xffff;
+    data[1696]=(char)0xffff;
+    data[1697]=(char)0xffff;
+    data[1698]=(char)0xffff;
+    data[1699]=(char)0xffff;
+    data[1700]=(char)0xffff;
+    data[1701]=(char)0xffff;
+    data[1702]=(char)0xffff;
+    data[1703]=(char)0xffff;
+    data[1704]=(char)0xffff;
+    data[1705]=(char)0xffff;
+    data[1706]=(char)0xffff;
+    data[1707]=(char)0xffff;
+    data[1708]=(char)0xffff;
+    data[1709]=(char)0xffff;
+    data[1710]=(char)0xffff;
+    data[1711]=(char)0xffff;
+    data[1712]=(char)0xffff;
+    data[1713]=(char)0xffff;
+    data[1714]=(char)0xffff;
+    data[1715]=(char)0xffff;
+    data[1716]=(char)0xffff;
+    data[1717]=(char)0xffff;
+    data[1718]=(char)0xffff;
+    data[1719]=(char)0xffff;
+    data[1720]=(char)0xffff;
+    data[1721]=(char)0xffff;
+    data[1722]=(char)0xffff;
+    data[1723]=(char)0xffff;
+    data[1724]=(char)0xffff;
+    data[1725]=(char)0xffff;
+    data[1726]=(char)0xffff;
+    data[1727]=(char)0xffff;
+    data[1728]=(char)0xffff;
+    data[1729]=(char)0xffff;
+    data[1730]=(char)0xffff;
+    data[1731]=(char)0xffff;
+    data[1732]=(char)0xffff;
+    data[1733]=(char)0xffff;
+    data[1734]=(char)0xffff;
+    data[1735]=(char)0xffff;
+    data[1736]=(char)0xffff;
+    data[1737]=(char)0xffff;
+    data[1738]=(char)0xffff;
+    data[1739]=(char)0xffff;
+    data[1740]=(char)0xffff;
+    data[1741]=(char)0xffff;
+    data[1742]=(char)0xffff;
+    data[1743]=(char)0xffff;
+    data[1744]=(char)0xffff;
+    data[1745]=(char)0xffff;
+    data[1746]=(char)0xffff;
+    data[1747]=(char)0xffff;
+    data[1748]=(char)0xffff;
+    data[1749]=(char)0xffff;
+    data[1750]=(char)0xffff;
+    data[1751]=(char)0xffff;
+    data[1752]=(char)0xffff;
+    data[1753]=(char)0xffff;
+    data[1754]=(char)0xffff;
+    data[1755]=(char)0xffff;
+    data[1756]=(char)0xffff;
+    data[1757]=(char)0xffff;
+    data[1758]=(char)0xffff;
+    data[1759]=(char)0xffff;
+    data[1760]=(char)0xffff;
+    data[1761]=(char)0xffff;
+    data[1762]=(char)0xffff;
+    data[1763]=(char)0xffff;
+    data[1764]=(char)0xffff;
+    data[1765]=(char)0xffff;
+    data[1766]=(char)0xffff;
+    data[1767]=(char)0xffff;
+    data[1768]=(char)0xffff;
+    data[1769]=(char)0xffff;
+    data[1770]=(char)0xffff;
+    data[1771]=(char)0xffff;
+    data[1772]=(char)0xffff;
+    data[1773]=(char)0xffff;
+    data[1774]=(char)0xffff;
+    data[1775]=(char)0xffff;
+    data[1776]=(char)0xffff;
+    data[1777]=(char)0xffff;
+    data[1778]=(char)0xffff;
+    data[1779]=(char)0xffff;
+    data[1780]=(char)0xffff;
+    data[1781]=(char)0xffff;
+    data[1782]=(char)0xffff;
+    data[1783]=(char)0xffff;
+    data[1784]=(char)0xffff;
+    data[1785]=(char)0xffff;
+    data[1786]=(char)0xffff;
+    data[1787]=(char)0xffff;
+    data[1788]=(char)0xffff;
+    data[1789]=(char)0xffff;
+    data[1790]=(char)0xffff;
+    data[1791]=(char)0xffff;
+    data[1792]=(char)0xffff;
+    data[1793]=(char)0xffff;
+    data[1794]=(char)0xffff;
+    data[1795]=(char)0xffff;
+    data[1796]=(char)0xffff;
+    data[1797]=(char)0xffff;
+    data[1798]=(char)0xffff;
+    data[1799]=(char)0xffff;
+    data[1800]=(char)0xffff;
+    data[1801]=(char)0xffff;
+    data[1802]=(char)0xffff;
+    data[1803]=(char)0xffff;
+    data[1804]=(char)0xffff;
+    data[1805]=(char)0xffff;
+    data[1806]=(char)0xffff;
+    data[1807]=(char)0xffff;
+    data[1808]=(char)0xffff;
+    data[1809]=(char)0xffff;
+    data[1810]=(char)0xffff;
+    data[1811]=(char)0xffff;
+    data[1812]=(char)0xffff;
+    data[1813]=(char)0xffff;
+    data[1814]=(char)0xffff;
+    data[1815]=(char)0xffff;
+    data[1816]=(char)0xffff;
+    data[1817]=(char)0xffff;
+    data[1818]=(char)0xffff;
+    data[1819]=(char)0xffff;
+    data[1820]=(char)0xffff;
+    data[1821]=(char)0xffff;
+    data[1822]=(char)0xffff;
+    data[1823]=(char)0xffff;
+    data[1824]=(char)0xffff;
+    data[1825]=(char)0xffff;
+    data[1826]=(char)0xffff;
+    data[1827]=(char)0xffff;
+    data[1828]=(char)0xffff;
+    data[1829]=(char)0xffff;
+    data[1830]=(char)0xffff;
+    data[1831]=(char)0xffff;
+    data[1832]=(char)0xffff;
+    data[1833]=(char)0xffff;
+    data[1834]=(char)0xffff;
+    data[1835]=(char)0xffff;
+    data[1836]=(char)0xffff;
+    data[1837]=(char)0xffff;
+    data[1838]=(char)0xffff;
+    data[1839]=(char)0xffff;
+    data[1840]=(char)0xffff;
+    data[1841]=(char)0xffff;
+    data[1842]=(char)0xffff;
+    data[1843]=(char)0xffff;
+    data[1844]=(char)0xffff;
+    data[1845]=(char)0xffff;
+    data[1846]=(char)0xffff;
+    data[1847]=(char)0xffff;
+    data[1848]=(char)0xffff;
+    data[1849]=(char)0xffff;
+    data[1850]=(char)0xffff;
+    data[1851]=(char)0xffff;
+    data[1852]=(char)0xffff;
+    data[1853]=(char)0xffff;
+    data[1854]=(char)0xffff;
+    data[1855]=(char)0xffff;
+    data[1856]=(char)0xffff;
+    data[1857]=(char)0xffff;
+    data[1858]=(char)0xffff;
+    data[1859]=(char)0xffff;
+    data[1860]=(char)0xffff;
+    data[1861]=(char)0xffff;
+    data[1862]=(char)0xffff;
+    data[1863]=(char)0xffff;
+    data[1864]=(char)0xffff;
+    data[1865]=(char)0xffff;
+    data[1866]=(char)0xffff;
+    data[1867]=(char)0xffff;
+    data[1868]=(char)0xffff;
+    data[1869]=(char)0xffff;
+    data[1870]=(char)0xffff;
+    data[1871]=(char)0xffff;
+    data[1872]=(char)0xffff;
+    data[1873]=(char)0xffff;
+    data[1874]=(char)0xffff;
+    data[1875]=(char)0xffff;
+    data[1876]=(char)0xffff;
+    data[1877]=(char)0xffff;
+    data[1878]=(char)0xffff;
+    data[1879]=(char)0xffff;
+    data[1880]=(char)0xffff;
+    data[1881]=(char)0xffff;
+    data[1882]=(char)0xffff;
+    data[1883]=(char)0xffff;
+    data[1884]=(char)0xffff;
+    data[1885]=(char)0xffff;
+    data[1886]=(char)0xffff;
+    data[1887]=(char)0xffff;
+    data[1888]=(char)0xffff;
+    data[1889]=(char)0xffff;
+    data[1890]=(char)0xffff;
+    data[1891]=(char)0xffff;
+    data[1892]=(char)0xffff;
+    data[1893]=(char)0xffff;
+    data[1894]=(char)0xffff;
+    data[1895]=(char)0xffff;
+    data[1896]=(char)0xffff;
+    data[1897]=(char)0xffff;
+    data[1898]=(char)0xffff;
+    data[1899]=(char)0xffff;
+    data[1900]=(char)0xffff;
+    data[1901]=(char)0xffff;
+    data[1902]=(char)0xffff;
+    data[1903]=(char)0xffff;
+    data[1904]=(char)0xffff;
+    data[1905]=(char)0xffff;
+    data[1906]=(char)0xffff;
+    data[1907]=(char)0xffff;
+    data[1908]=(char)0xffff;
+    data[1909]=(char)0xffff;
+    data[1910]=(char)0xffff;
+    data[1911]=(char)0xffff;
+    data[1912]=(char)0xffff;
+    data[1913]=(char)0xffff;
+    data[1914]=(char)0xffff;
+    data[1915]=(char)0xffff;
+    data[1916]=(char)0xffff;
+    data[1917]=(char)0xffff;
+    data[1918]=(char)0xffff;
+    data[1919]=(char)0xffff;
+    data[1920]=(char)0xffff;
+    data[1921]=(char)0xffff;
+    data[1922]=(char)0xffff;
+    data[1923]=(char)0xffff;
+    data[1924]=(char)0xffff;
+    data[1925]=(char)0xffff;
+    data[1926]=(char)0xffff;
+    data[1927]=(char)0xffff;
+    data[1928]=(char)0xffff;
+    data[1929]=(char)0xffff;
+    data[1930]=(char)0xffff;
+    data[1931]=(char)0xffff;
+    data[1932]=(char)0xffff;
+    data[1933]=(char)0xffff;
+    data[1934]=(char)0xffff;
+    data[1935]=(char)0xffff;
+    data[1936]=(char)0xffff;
+    data[1937]=(char)0xffff;
+    data[1938]=(char)0xffff;
+    data[1939]=(char)0xffff;
+    data[1940]=(char)0xffff;
+    data[1941]=(char)0xffff;
+    data[1942]=(char)0xffff;
+    data[1943]=(char)0xffff;
+    data[1944]=(char)0xffff;
+    data[1945]=(char)0xffff;
+    data[1946]=(char)0xffff;
+    data[1947]=(char)0xffff;
+    data[1948]=(char)0xffff;
+    data[1949]=(char)0xffff;
+    data[1950]=(char)0xffff;
+    data[1951]=(char)0xffff;
+    data[1952]=(char)0xffff;
+    data[1953]=(char)0xffff;
+    data[1954]=(char)0xffff;
+    data[1955]=(char)0xffff;
+    data[1956]=(char)0xffff;
+    data[1957]=(char)0xffff;
+    data[1958]=(char)0xffff;
+    data[1959]=(char)0xffff;
+    data[1960]=(char)0xffff;
+    data[1961]=(char)0xffff;
+    data[1962]=(char)0xffff;
+    data[1963]=(char)0xffff;
+    data[1964]=(char)0xffff;
+    data[1965]=(char)0xffff;
+    data[1966]=(char)0xffff;
+    data[1967]=(char)0xffff;
+    data[1968]=(char)0xffff;
+    data[1969]=(char)0xffff;
+    data[1970]=(char)0xffff;
+    data[1971]=(char)0xffff;
+    data[1972]=(char)0xffff;
+    data[1973]=(char)0xffff;
+    data[1974]=(char)0xffff;
+    data[1975]=(char)0xffff;
+    data[1976]=(char)0xffff;
+    data[1977]=(char)0xffff;
+    data[1978]=(char)0xffff;
+    data[1979]=(char)0xffff;
+    data[1980]=(char)0xffff;
+    data[1981]=(char)0xffff;
+    data[1982]=(char)0xffff;
+    data[1983]=(char)0xffff;
+    data[1984]=(char)0xffff;
+    data[1985]=(char)0xffff;
+    data[1986]=(char)0xffff;
+    data[1987]=(char)0xffff;
+    data[1988]=(char)0xffff;
+    data[1989]=(char)0xffff;
+    data[1990]=(char)0xffff;
+    data[1991]=(char)0xffff;
+    data[1992]=(char)0xffff;
+    data[1993]=(char)0xffff;
+    data[1994]=(char)0xffff;
+    data[1995]=(char)0xffff;
+    data[1996]=(char)0xffff;
+    data[1997]=(char)0xffff;
+    data[1998]=(char)0xffff;
+    data[1999]=(char)0xffff;
+    data[2000]=(char)0xffff;
+    data[2001]=(char)0xffff;
+    data[2002]=(char)0xffff;
+    data[2003]=(char)0xffff;
+    data[2004]=(char)0xffff;
+    data[2005]=(char)0xffff;
+    data[2006]=(char)0xffff;
+    data[2007]=(char)0xffff;
+    data[2008]=(char)0xffff;
+    data[2009]=(char)0xffff;
+    data[2010]=(char)0xffff;
+    data[2011]=(char)0xffff;
+    data[2012]=(char)0xffff;
+    data[2013]=(char)0xffff;
+    data[2014]=(char)0xffff;
+    data[2015]=(char)0xffff;
+    data[2016]=(char)0xffff;
+    data[2017]=(char)0xffff;
+    data[2018]=(char)0xffff;
+    data[2019]=(char)0xffff;
+    data[2020]=(char)0xffff;
+    data[2021]=(char)0xffff;
+    data[2022]=(char)0xffff;
+    data[2023]=(char)0xffff;
+    data[2024]=(char)0xffff;
+    data[2025]=(char)0xffff;
+    data[2026]=(char)0xffff;
+    data[2027]=(char)0xffff;
+    data[2028]=(char)0xffff;
+    data[2029]=(char)0xffff;
+    data[2030]=(char)0xffff;
+    data[2031]=(char)0xffff;
+    data[2032]=(char)0xffff;
+    data[2033]=(char)0xffff;
+    data[2034]=(char)0xffff;
+    data[2035]=(char)0xffff;
+    data[2036]=(char)0xffff;
+    data[2037]=(char)0xffff;
+    data[2038]=(char)0xffff;
+    data[2039]=(char)0xffff;
+    data[2040]=(char)0xffff;
+    data[2041]=(char)0xffff;
+    data[2042]=(char)0xffff;
+    data[2043]=(char)0xffff;
+    data[2044]=(char)0xffff;
+    data[2045]=(char)0xffff;
+    data[2046]=(char)0xffff;
+    data[2047]=(char)0xffff;
+    data[2048]=(char)0xffff;
+    data[2049]=(char)0xffff;
+    data[2050]=(char)0xffff;
+    data[2051]=(char)0xffff;
+    data[2052]=(char)0xffff;
+    data[2053]=(char)0xffff;
+    data[2054]=(char)0xffff;
+    data[2055]=(char)0xffff;
+    data[2056]=(char)0xffff;
+    data[2057]=(char)0xffff;
+    data[2058]=(char)0xffff;
+    data[2059]=(char)0xffff;
+    data[2060]=(char)0xffff;
+    data[2061]=(char)0xffff;
+    data[2062]=(char)0xffff;
+    data[2063]=(char)0xffff;
+    data[2064]=(char)0xffff;
+    data[2065]=(char)0xffff;
+    data[2066]=(char)0xffff;
+    data[2067]=(char)0xffff;
+    data[2068]=(char)0xffff;
+    data[2069]=(char)0xffff;
+    data[2070]=(char)0xffff;
+    data[2071]=(char)0xffff;
+    data[2072]=(char)0xffff;
+    data[2073]=(char)0xffff;
+    data[2074]=(char)0xffff;
+    data[2075]=(char)0xffff;
+    data[2076]=(char)0xffff;
+    data[2077]=(char)0xffff;
+    data[2078]=(char)0xffff;
+    data[2079]=(char)0xffff;
+    data[2080]=(char)0xffff;
+    data[2081]=(char)0xffff;
+    data[2082]=(char)0xffff;
+    data[2083]=(char)0xffff;
+    data[2084]=(char)0xffff;
+    data[2085]=(char)0xffff;
+    data[2086]=(char)0xffff;
+    data[2087]=(char)0xffff;
+    data[2088]=(char)0xffff;
+    data[2089]=(char)0xffff;
+    data[2090]=(char)0xffff;
+    data[2091]=(char)0xffff;
+    data[2092]=(char)0xffff;
+    data[2093]=(char)0xffff;
+    data[2094]=(char)0xffff;
+    data[2095]=(char)0xffff;
+    data[2096]=(char)0xffff;
+    data[2097]=(char)0xffff;
+    data[2098]=(char)0xffff;
+    data[2099]=(char)0xffff;
+    data[2100]=(char)0xffff;
+    data[2101]=(char)0xffff;
+    data[2102]=(char)0xffff;
+    data[2103]=(char)0xffff;
+    data[2104]=(char)0xffff;
+    data[2105]=(char)0xffff;
+    data[2106]=(char)0xffff;
+    data[2107]=(char)0xffff;
+    data[2108]=(char)0xffff;
+    data[2109]=(char)0xffff;
+    data[2110]=(char)0xffff;
+    data[2111]=(char)0xffff;
+    data[2112]=(char)0xffff;
+    data[2113]=(char)0xffff;
+    data[2114]=(char)0xffff;
+    data[2115]=(char)0xffff;
+    data[2116]=(char)0xffff;
+    data[2117]=(char)0xffff;
+    data[2118]=(char)0xffff;
+    data[2119]=(char)0xffff;
+    data[2120]=(char)0xffff;
+    data[2121]=(char)0xffff;
+    data[2122]=(char)0xffff;
+    data[2123]=(char)0xffff;
+    data[2124]=(char)0xffff;
+    data[2125]=(char)0xffff;
+    data[2126]=(char)0xffff;
+    data[2127]=(char)0xffff;
+    data[2128]=(char)0xffff;
+    data[2129]=(char)0xffff;
+    data[2130]=(char)0xffff;
+    data[2131]=(char)0xffff;
+    data[2132]=(char)0xffff;
+    data[2133]=(char)0xffff;
+    data[2134]=(char)0xffff;
+    data[2135]=(char)0xffff;
+    data[2136]=(char)0xffff;
+    data[2137]=(char)0xffff;
+    data[2138]=(char)0xffff;
+    data[2139]=(char)0xffff;
+    data[2140]=(char)0xffff;
+    data[2141]=(char)0xffff;
+    data[2142]=(char)0xffff;
+    data[2143]=(char)0xffff;
+    data[2144]=(char)0xffff;
+    data[2145]=(char)0xffff;
+    data[2146]=(char)0xffff;
+    data[2147]=(char)0xffff;
+    data[2148]=(char)0xffff;
+    data[2149]=(char)0xffff;
+    data[2150]=(char)0xffff;
+    data[2151]=(char)0xffff;
+    data[2152]=(char)0xffff;
+    data[2153]=(char)0xffff;
+    data[2154]=(char)0xffff;
+    data[2155]=(char)0xffff;
+    data[2156]=(char)0xffff;
+    data[2157]=(char)0xffff;
+    data[2158]=(char)0xffff;
+    data[2159]=(char)0xffff;
+    data[2160]=(char)0xffff;
+    data[2161]=(char)0xffff;
+    data[2162]=(char)0xffff;
+    data[2163]=(char)0xffff;
+    data[2164]=(char)0xffff;
+    data[2165]=(char)0xffff;
+    data[2166]=(char)0xffff;
+    data[2167]=(char)0xffff;
+    data[2168]=(char)0xffff;
+    data[2169]=(char)0xffff;
+    data[2170]=(char)0xffff;
+    data[2171]=(char)0xffff;
+    data[2172]=(char)0xffff;
+    data[2173]=(char)0xffff;
+    data[2174]=(char)0xffff;
+    data[2175]=(char)0xffff;
+    data[2176]=(char)0xffff;
+    data[2177]=(char)0xffff;
+    data[2178]=(char)0xffff;
+    data[2179]=(char)0xffff;
+    data[2180]=(char)0xffff;
+    data[2181]=(char)0xffff;
+    data[2182]=(char)0xffff;
+    data[2183]=(char)0xffff;
+    data[2184]=(char)0xffff;
+    data[2185]=(char)0xffff;
+    data[2186]=(char)0xffff;
+    data[2187]=(char)0xffff;
+    data[2188]=(char)0xffff;
+    data[2189]=(char)0xffff;
+    data[2190]=(char)0xffff;
+    data[2191]=(char)0xffff;
+    data[2192]=(char)0xffff;
+    data[2193]=(char)0xffff;
+    data[2194]=(char)0xffff;
+    data[2195]=(char)0xffff;
+    data[2196]=(char)0xffff;
+    data[2197]=(char)0xffff;
+    data[2198]=(char)0xffff;
+    data[2199]=(char)0xffff;
+    data[2200]=(char)0xffff;
+    data[2201]=(char)0xffff;
+    data[2202]=(char)0xffff;
+    data[2203]=(char)0xffff;
+    data[2204]=(char)0xffff;
+    data[2205]=(char)0xffff;
+    data[2206]=(char)0xffff;
+    data[2207]=(char)0xffff;
+    data[2208]=(char)0xffff;
+    data[2209]=(char)0xffff;
+    data[2210]=(char)0xffff;
+    data[2211]=(char)0xffff;
+    data[2212]=(char)0xffff;
+    data[2213]=(char)0xffff;
+    data[2214]=(char)0xffff;
+    data[2215]=(char)0xffff;
+    data[2216]=(char)0xffff;
+    data[2217]=(char)0xffff;
+    data[2218]=(char)0xffff;
+    data[2219]=(char)0xffff;
+    data[2220]=(char)0xffff;
+    data[2221]=(char)0xffff;
+    data[2222]=(char)0xffff;
+    data[2223]=(char)0xffff;
+    data[2224]=(char)0xffff;
+    data[2225]=(char)0xffff;
+    data[2226]=(char)0xffff;
+    data[2227]=(char)0xffff;
+    data[2228]=(char)0xffff;
+    data[2229]=(char)0xffff;
+    data[2230]=(char)0xffff;
+    data[2231]=(char)0xffff;
+    data[2232]=(char)0xffff;
+    data[2233]=(char)0xffff;
+    data[2234]=(char)0xffff;
+    data[2235]=(char)0xffff;
+    data[2236]=(char)0xffff;
+    data[2237]=(char)0xffff;
+    data[2238]=(char)0xffff;
+    data[2239]=(char)0xffff;
+    data[2240]=(char)0xffff;
+    data[2241]=(char)0xffff;
+    data[2242]=(char)0xffff;
+    data[2243]=(char)0xffff;
+    data[2244]=(char)0xffff;
+    data[2245]=(char)0xffff;
+    data[2246]=(char)0xffff;
+    data[2247]=(char)0xffff;
+    data[2248]=(char)0xffff;
+    data[2249]=(char)0xffff;
+    data[2250]=(char)0xffff;
+    data[2251]=(char)0xffff;
+    data[2252]=(char)0xffff;
+    data[2253]=(char)0xffff;
+    data[2254]=(char)0xffff;
+    data[2255]=(char)0xffff;
+    data[2256]=(char)0xffff;
+    data[2257]=(char)0xffff;
+    data[2258]=(char)0xffff;
+    data[2259]=(char)0xffff;
+    data[2260]=(char)0xffff;
+    data[2261]=(char)0xffff;
+    data[2262]=(char)0xffff;
+    data[2263]=(char)0xffff;
+    data[2264]=(char)0xffff;
+    data[2265]=(char)0xffff;
+    data[2266]=(char)0xffff;
+    data[2267]=(char)0xffff;
+    data[2268]=(char)0xffff;
+    data[2269]=(char)0xffff;
+    data[2270]=(char)0xffff;
+    data[2271]=(char)0xffff;
+    data[2272]=(char)0xffff;
+    data[2273]=(char)0xffff;
+    data[2274]=(char)0xffff;
+    data[2275]=(char)0xffff;
+    data[2276]=(char)0xffff;
+    data[2277]=(char)0xffff;
+    data[2278]=(char)0xffff;
+    data[2279]=(char)0xffff;
+    data[2280]=(char)0xffff;
+    data[2281]=(char)0xffff;
+    data[2282]=(char)0xffff;
+    data[2283]=(char)0xffff;
+    data[2284]=(char)0xffff;
+    data[2285]=(char)0xffff;
+    data[2286]=(char)0xffff;
+    data[2287]=(char)0xffff;
+    data[2288]=(char)0xffff;
+    data[2289]=(char)0xffff;
+    data[2290]=(char)0xffff;
+    data[2291]=(char)0xffff;
+    data[2292]=(char)0xffff;
+    data[2293]=(char)0xffff;
+    data[2294]=(char)0xffff;
+    data[2295]=(char)0xffff;
+    data[2296]=(char)0xffff;
+    data[2297]=(char)0xffff;
+    data[2298]=(char)0xffff;
+    data[2299]=(char)0xffff;
+    data[2300]=(char)0xffff;
+    data[2301]=(char)0xffff;
+    data[2302]=(char)0xffff;
+    data[2303]=(char)0xffff;
+    data[2304]=(char)0xffff;
+    data[2305]=(char)0xffff;
+    data[2306]=(char)0xffff;
+    data[2307]=(char)0xffff;
+    data[2308]=(char)0xffff;
+    data[2309]=(char)0xffff;
+    data[2310]=(char)0xffff;
+    data[2311]=(char)0xffff;
+    data[2312]=(char)0xffff;
+    data[2313]=(char)0xffff;
+    data[2314]=(char)0xffff;
+    data[2315]=(char)0xffff;
+    data[2316]=(char)0xffff;
+    data[2317]=(char)0xffff;
+    data[2318]=(char)0xffff;
+    data[2319]=(char)0xffff;
+    data[2320]=(char)0xffff;
+    data[2321]=(char)0xffff;
+    data[2322]=(char)0xffff;
+    data[2323]=(char)0xffff;
+    data[2324]=(char)0xffff;
+    data[2325]=(char)0xffff;
+    data[2326]=(char)0xffff;
+    data[2327]=(char)0xffff;
+    data[2328]=(char)0xffff;
+    data[2329]=(char)0xffff;
+    data[2330]=(char)0xffff;
+    data[2331]=(char)0xffff;
+    data[2332]=(char)0xffff;
+    data[2333]=(char)0xffff;
+    data[2334]=(char)0xffff;
+    data[2335]=(char)0xffff;
+    data[2336]=(char)0xffff;
+    data[2337]=(char)0xffff;
+    data[2338]=(char)0xffff;
+    data[2339]=(char)0xffff;
+    data[2340]=(char)0xffff;
+    data[2341]=(char)0xffff;
+    data[2342]=(char)0xffff;
+    data[2343]=(char)0xffff;
+    data[2344]=(char)0xffff;
+    data[2345]=(char)0xffff;
+    data[2346]=(char)0xffff;
+    data[2347]=(char)0xffff;
+    data[2348]=(char)0xffff;
+    data[2349]=(char)0xffff;
+    data[2350]=(char)0xffff;
+    data[2351]=(char)0xffff;
+    data[2352]=(char)0xffff;
+    data[2353]=(char)0xffff;
+    data[2354]=(char)0xffff;
+    data[2355]=(char)0xffff;
+    data[2356]=(char)0xffff;
+    data[2357]=(char)0xffff;
+    data[2358]=(char)0xffff;
+    data[2359]=(char)0xffff;
+    data[2360]=(char)0xffff;
+    data[2361]=(char)0xffff;
+    data[2362]=(char)0xffff;
+    data[2363]=(char)0xffff;
+    data[2364]=(char)0xffff;
+    data[2365]=(char)0xffff;
+    data[2366]=(char)0xffff;
+    data[2367]=(char)0xffff;
+    data[2368]=(char)0xffff;
+    data[2369]=(char)0xffff;
+    data[2370]=(char)0xffff;
+    data[2371]=(char)0xffff;
+    data[2372]=(char)0xffff;
+    data[2373]=(char)0xffff;
+    data[2374]=(char)0xffff;
+    data[2375]=(char)0xffff;
+    data[2376]=(char)0xffff;
+    data[2377]=(char)0xffff;
+    data[2378]=(char)0xffff;
+    data[2379]=(char)0xffff;
+    data[2380]=(char)0xffff;
+    data[2381]=(char)0xffff;
+    data[2382]=(char)0xffff;
+    data[2383]=(char)0xffff;
+    data[2384]=(char)0xffff;
+    data[2385]=(char)0xffff;
+    data[2386]=(char)0xffff;
+    data[2387]=(char)0xffff;
+    data[2388]=(char)0xffff;
+    data[2389]=(char)0xffff;
+    data[2390]=(char)0xffff;
+    data[2391]=(char)0xffff;
+    data[2392]=(char)0xffff;
+    data[2393]=(char)0xffff;
+    data[2394]=(char)0xffff;
+    data[2395]=(char)0xffff;
+    data[2396]=(char)0xffff;
+    data[2397]=(char)0xffff;
+    data[2398]=(char)0xffff;
+    data[2399]=(char)0xffff;
+    data[2400]=(char)0xffff;
+    data[2401]=(char)0xffff;
+    data[2402]=(char)0xffff;
+    data[2403]=(char)0xffff;
+    data[2404]=(char)0xffff;
+    data[2405]=(char)0xffff;
+    data[2406]=(char)0xffff;
+    data[2407]=(char)0xffff;
+    data[2408]=(char)0xffff;
+    data[2409]=(char)0xffff;
+    data[2410]=(char)0xffff;
+    data[2411]=(char)0xffff;
+    data[2412]=(char)0xffff;
+    data[2413]=(char)0xffff;
+    data[2414]=(char)0xffff;
+    data[2415]=(char)0xffff;
+    data[2416]=(char)0xffff;
+    data[2417]=(char)0xffff;
+    data[2418]=(char)0xffff;
+    data[2419]=(char)0xffff;
+    data[2420]=(char)0xffff;
+    data[2421]=(char)0xffff;
+    data[2422]=(char)0xffff;
+    data[2423]=(char)0xffff;
+    data[2424]=(char)0xffff;
+    data[2425]=(char)0xffff;
+    data[2426]=(char)0xffff;
+    data[2427]=(char)0xffff;
+    data[2428]=(char)0xffff;
+    data[2429]=(char)0xffff;
+    data[2430]=(char)0xffff;
+    data[2431]=(char)0xffff;
+    data[2432]=(char)0xffff;
+    data[2433]=(char)0xffff;
+    data[2434]=(char)0xffff;
+    data[2435]=(char)0xffff;
+    data[2436]=(char)0xffff;
+    data[2437]=(char)0xffff;
+    data[2438]=(char)0xffff;
+    data[2439]=(char)0xffff;
+    data[2440]=(char)0xffff;
+    data[2441]=(char)0xffff;
+    data[2442]=(char)0xffff;
+    data[2443]=(char)0xffff;
+    data[2444]=(char)0xffff;
+    data[2445]=(char)0xffff;
+    data[2446]=(char)0xffff;
+    data[2447]=(char)0xffff;
+    data[2448]=(char)0xffff;
+    data[2449]=(char)0xffff;
+    data[2450]=(char)0xffff;
+    data[2451]=(char)0xffff;
+    data[2452]=(char)0xffff;
+    data[2453]=(char)0xffff;
+    data[2454]=(char)0xffff;
+    data[2455]=(char)0xffff;
+    data[2456]=(char)0xffff;
+    data[2457]=(char)0xffff;
+    data[2458]=(char)0xffff;
+    data[2459]=(char)0xffff;
+    data[2460]=(char)0xffff;
+    data[2461]=(char)0xffff;
+    data[2462]=(char)0xffff;
+    data[2463]=(char)0xffff;
+    data[2464]=(char)0xffff;
+    data[2465]=(char)0xffff;
+    data[2466]=(char)0xffff;
+    data[2467]=(char)0xffff;
+    data[2468]=(char)0xffff;
+    data[2469]=(char)0xffff;
+    data[2470]=(char)0xffff;
+    data[2471]=(char)0xffff;
+    data[2472]=(char)0xffff;
+    data[2473]=(char)0xffff;
+    data[2474]=(char)0xffff;
+    data[2475]=(char)0xffff;
+    data[2476]=(char)0xffff;
+    data[2477]=(char)0xffff;
+    data[2478]=(char)0xffff;
+    data[2479]=(char)0xffff;
+    data[2480]=(char)0xffff;
+    data[2481]=(char)0xffff;
+    data[2482]=(char)0xffff;
+    data[2483]=(char)0xffff;
+    data[2484]=(char)0xffff;
+    data[2485]=(char)0xffff;
+    data[2486]=(char)0xffff;
+    data[2487]=(char)0xffff;
+    data[2488]=(char)0xffff;
+    data[2489]=(char)0xffff;
+    data[2490]=(char)0xffff;
+    data[2491]=(char)0xffff;
+    data[2492]=(char)0xffff;
+    data[2493]=(char)0xffff;
+    data[2494]=(char)0xffff;
+    data[2495]=(char)0xffff;
+    data[2496]=(char)0xffff;
+    data[2497]=(char)0xffff;
+    data[2498]=(char)0xffff;
+    data[2499]=(char)0xffff;
+    data[2500]=(char)0xffff;
+    data[2501]=(char)0xffff;
+    data[2502]=(char)0xffff;
+    data[2503]=(char)0xffff;
+    data[2504]=(char)0xffff;
+    data[2505]=(char)0xffff;
+    data[2506]=(char)0xffff;
+    data[2507]=(char)0xffff;
+    data[2508]=(char)0xffff;
+    data[2509]=(char)0xffff;
+    data[2510]=(char)0xffff;
+    data[2511]=(char)0xffff;
+    data[2512]=(char)0xffff;
+    data[2513]=(char)0xffff;
+    data[2514]=(char)0xffff;
+    data[2515]=(char)0xffff;
+    data[2516]=(char)0xffff;
+    data[2517]=(char)0xffff;
+    data[2518]=(char)0xffff;
+    data[2519]=(char)0xffff;
+    data[2520]=(char)0xffff;
+    data[2521]=(char)0xffff;
+    data[2522]=(char)0xffff;
+    data[2523]=(char)0xffff;
+    data[2524]=(char)0xffff;
+    data[2525]=(char)0xffff;
+    data[2526]=(char)0xffff;
+    data[2527]=(char)0xffff;
+    data[2528]=(char)0xffff;
+    data[2529]=(char)0xffff;
+    data[2530]=(char)0xffff;
+    data[2531]=(char)0xffff;
+    data[2532]=(char)0xffff;
+    data[2533]=(char)0xffff;
+    data[2534]=(char)0xffff;
+    data[2535]=(char)0xffff;
+    data[2536]=(char)0xffff;
+    data[2537]=(char)0xffff;
+    data[2538]=(char)0xffff;
+    data[2539]=(char)0xffff;
+    data[2540]=(char)0xffff;
+    data[2541]=(char)0xffff;
+    data[2542]=(char)0xffff;
+    data[2543]=(char)0xffff;
+    data[2544]=(char)0xffff;
+    data[2545]=(char)0xffff;
+    data[2546]=(char)0xffff;
+    data[2547]=(char)0xffff;
+    data[2548]=(char)0xffff;
+    data[2549]=(char)0xffff;
+    data[2550]=(char)0xffff;
+    data[2551]=(char)0xffff;
+    data[2552]=(char)0xffff;
+    data[2553]=(char)0xffff;
+    data[2554]=(char)0x003f;
+    data[2752]=(char)0xffff;
+    data[2753]=(char)0xffff;
+    data[2754]=(char)0xffff;
+    data[2755]=(char)0xffff;
+    data[2756]=(char)0xffff;
+    data[2757]=(char)0xffff;
+    data[2758]=(char)0xffff;
+    data[2759]=(char)0xffff;
+    data[2760]=(char)0xffff;
+    data[2761]=(char)0xffff;
+    data[2762]=(char)0xffff;
+    data[2763]=(char)0xffff;
+    data[2764]=(char)0xffff;
+    data[2765]=(char)0xffff;
+    data[2766]=(char)0xffff;
+    data[2767]=(char)0xffff;
+    data[2768]=(char)0xffff;
+    data[2769]=(char)0xffff;
+    data[2770]=(char)0xffff;
+    data[2771]=(char)0xffff;
+    data[2772]=(char)0xffff;
+    data[2773]=(char)0xffff;
+    data[2774]=(char)0xffff;
+    data[2775]=(char)0xffff;
+    data[2776]=(char)0xffff;
+    data[2777]=(char)0xffff;
+    data[2778]=(char)0xffff;
+    data[2779]=(char)0xffff;
+    data[2780]=(char)0xffff;
+    data[2781]=(char)0xffff;
+    data[2782]=(char)0xffff;
+    data[2783]=(char)0xffff;
+    data[2784]=(char)0xffff;
+    data[2785]=(char)0xffff;
+    data[2786]=(char)0xffff;
+    data[2787]=(char)0xffff;
+    data[2788]=(char)0xffff;
+    data[2789]=(char)0xffff;
+    data[2790]=(char)0xffff;
+    data[2791]=(char)0xffff;
+    data[2792]=(char)0xffff;
+    data[2793]=(char)0xffff;
+    data[2794]=(char)0xffff;
+    data[2795]=(char)0xffff;
+    data[2796]=(char)0xffff;
+    data[2797]=(char)0xffff;
+    data[2798]=(char)0xffff;
+    data[2799]=(char)0xffff;
+    data[2800]=(char)0xffff;
+    data[2801]=(char)0xffff;
+    data[2802]=(char)0xffff;
+    data[2803]=(char)0xffff;
+    data[2804]=(char)0xffff;
+    data[2805]=(char)0xffff;
+    data[2806]=(char)0xffff;
+    data[2807]=(char)0xffff;
+    data[2808]=(char)0xffff;
+    data[2809]=(char)0xffff;
+    data[2810]=(char)0xffff;
+    data[2811]=(char)0xffff;
+    data[2812]=(char)0xffff;
+    data[2813]=(char)0xffff;
+    data[2814]=(char)0xffff;
+    data[2815]=(char)0xffff;
+    data[2816]=(char)0xffff;
+    data[2817]=(char)0xffff;
+    data[2818]=(char)0xffff;
+    data[2819]=(char)0xffff;
+    data[2820]=(char)0xffff;
+    data[2821]=(char)0xffff;
+    data[2822]=(char)0xffff;
+    data[2823]=(char)0xffff;
+    data[2824]=(char)0xffff;
+    data[2825]=(char)0xffff;
+    data[2826]=(char)0xffff;
+    data[2827]=(char)0xffff;
+    data[2828]=(char)0xffff;
+    data[2829]=(char)0xffff;
+    data[2830]=(char)0xffff;
+    data[2831]=(char)0xffff;
+    data[2832]=(char)0xffff;
+    data[2833]=(char)0xffff;
+    data[2834]=(char)0xffff;
+    data[2835]=(char)0xffff;
+    data[2836]=(char)0xffff;
+    data[2837]=(char)0xffff;
+    data[2838]=(char)0xffff;
+    data[2839]=(char)0xffff;
+    data[2840]=(char)0xffff;
+    data[2841]=(char)0xffff;
+    data[2842]=(char)0xffff;
+    data[2843]=(char)0xffff;
+    data[2844]=(char)0xffff;
+    data[2845]=(char)0xffff;
+    data[2846]=(char)0xffff;
+    data[2847]=(char)0xffff;
+    data[2848]=(char)0xffff;
+    data[2849]=(char)0xffff;
+    data[2850]=(char)0xffff;
+    data[2851]=(char)0xffff;
+    data[2852]=(char)0xffff;
+    data[2853]=(char)0xffff;
+    data[2854]=(char)0xffff;
+    data[2855]=(char)0xffff;
+    data[2856]=(char)0xffff;
+    data[2857]=(char)0xffff;
+    data[2858]=(char)0xffff;
+    data[2859]=(char)0xffff;
+    data[2860]=(char)0xffff;
+    data[2861]=(char)0xffff;
+    data[2862]=(char)0xffff;
+    data[2863]=(char)0xffff;
+    data[2864]=(char)0xffff;
+    data[2865]=(char)0xffff;
+    data[2866]=(char)0xffff;
+    data[2867]=(char)0xffff;
+    data[2868]=(char)0xffff;
+    data[2869]=(char)0xffff;
+    data[2870]=(char)0xffff;
+    data[2871]=(char)0xffff;
+    data[2872]=(char)0xffff;
+    data[2873]=(char)0xffff;
+    data[2874]=(char)0xffff;
+    data[2875]=(char)0xffff;
+    data[2876]=(char)0xffff;
+    data[2877]=(char)0xffff;
+    data[2878]=(char)0xffff;
+    data[2879]=(char)0xffff;
+    data[2880]=(char)0xffff;
+    data[2881]=(char)0xffff;
+    data[2882]=(char)0xffff;
+    data[2883]=(char)0xffff;
+    data[2884]=(char)0xffff;
+    data[2885]=(char)0xffff;
+    data[2886]=(char)0xffff;
+    data[2887]=(char)0xffff;
+    data[2888]=(char)0xffff;
+    data[2889]=(char)0xffff;
+    data[2890]=(char)0xffff;
+    data[2891]=(char)0xffff;
+    data[2892]=(char)0xffff;
+    data[2893]=(char)0xffff;
+    data[2894]=(char)0xffff;
+    data[2895]=(char)0xffff;
+    data[2896]=(char)0xffff;
+    data[2897]=(char)0xffff;
+    data[2898]=(char)0xffff;
+    data[2899]=(char)0xffff;
+    data[2900]=(char)0xffff;
+    data[2901]=(char)0xffff;
+    data[2902]=(char)0xffff;
+    data[2903]=(char)0xffff;
+    data[2904]=(char)0xffff;
+    data[2905]=(char)0xffff;
+    data[2906]=(char)0xffff;
+    data[2907]=(char)0xffff;
+    data[2908]=(char)0xffff;
+    data[2909]=(char)0xffff;
+    data[2910]=(char)0xffff;
+    data[2911]=(char)0xffff;
+    data[2912]=(char)0xffff;
+    data[2913]=(char)0xffff;
+    data[2914]=(char)0xffff;
+    data[2915]=(char)0xffff;
+    data[2916]=(char)0xffff;
+    data[2917]=(char)0xffff;
+    data[2918]=(char)0xffff;
+    data[2919]=(char)0xffff;
+    data[2920]=(char)0xffff;
+    data[2921]=(char)0xffff;
+    data[2922]=(char)0xffff;
+    data[2923]=(char)0xffff;
+    data[2924]=(char)0xffff;
+    data[2925]=(char)0xffff;
+    data[2926]=(char)0xffff;
+    data[2927]=(char)0xffff;
+    data[2928]=(char)0xffff;
+    data[2929]=(char)0xffff;
+    data[2930]=(char)0xffff;
+    data[2931]=(char)0xffff;
+    data[2932]=(char)0xffff;
+    data[2933]=(char)0xffff;
+    data[2934]=(char)0xffff;
+    data[2935]=(char)0xffff;
+    data[2936]=(char)0xffff;
+    data[2937]=(char)0xffff;
+    data[2938]=(char)0xffff;
+    data[2939]=(char)0xffff;
+    data[2940]=(char)0xffff;
+    data[2941]=(char)0xffff;
+    data[2942]=(char)0xffff;
+    data[2943]=(char)0xffff;
+    data[2944]=(char)0xffff;
+    data[2945]=(char)0xffff;
+    data[2946]=(char)0xffff;
+    data[2947]=(char)0xffff;
+    data[2948]=(char)0xffff;
+    data[2949]=(char)0xffff;
+    data[2950]=(char)0xffff;
+    data[2951]=(char)0xffff;
+    data[2952]=(char)0xffff;
+    data[2953]=(char)0xffff;
+    data[2954]=(char)0xffff;
+    data[2955]=(char)0xffff;
+    data[2956]=(char)0xffff;
+    data[2957]=(char)0xffff;
+    data[2958]=(char)0xffff;
+    data[2959]=(char)0xffff;
+    data[2960]=(char)0xffff;
+    data[2961]=(char)0xffff;
+    data[2962]=(char)0xffff;
+    data[2963]=(char)0xffff;
+    data[2964]=(char)0xffff;
+    data[2965]=(char)0xffff;
+    data[2966]=(char)0xffff;
+    data[2967]=(char)0xffff;
+    data[2968]=(char)0xffff;
+    data[2969]=(char)0xffff;
+    data[2970]=(char)0xffff;
+    data[2971]=(char)0xffff;
+    data[2972]=(char)0xffff;
+    data[2973]=(char)0xffff;
+    data[2974]=(char)0xffff;
+    data[2975]=(char)0xffff;
+    data[2976]=(char)0xffff;
+    data[2977]=(char)0xffff;
+    data[2978]=(char)0xffff;
+    data[2979]=(char)0xffff;
+    data[2980]=(char)0xffff;
+    data[2981]=(char)0xffff;
+    data[2982]=(char)0xffff;
+    data[2983]=(char)0xffff;
+    data[2984]=(char)0xffff;
+    data[2985]=(char)0xffff;
+    data[2986]=(char)0xffff;
+    data[2987]=(char)0xffff;
+    data[2988]=(char)0xffff;
+    data[2989]=(char)0xffff;
+    data[2990]=(char)0xffff;
+    data[2991]=(char)0xffff;
+    data[2992]=(char)0xffff;
+    data[2993]=(char)0xffff;
+    data[2994]=(char)0xffff;
+    data[2995]=(char)0xffff;
+    data[2996]=(char)0xffff;
+    data[2997]=(char)0xffff;
+    data[2998]=(char)0xffff;
+    data[2999]=(char)0xffff;
+    data[3000]=(char)0xffff;
+    data[3001]=(char)0xffff;
+    data[3002]=(char)0xffff;
+    data[3003]=(char)0xffff;
+    data[3004]=(char)0xffff;
+    data[3005]=(char)0xffff;
+    data[3006]=(char)0xffff;
+    data[3007]=(char)0xffff;
+    data[3008]=(char)0xffff;
+    data[3009]=(char)0xffff;
+    data[3010]=(char)0xffff;
+    data[3011]=(char)0xffff;
+    data[3012]=(char)0xffff;
+    data[3013]=(char)0xffff;
+    data[3014]=(char)0xffff;
+    data[3015]=(char)0xffff;
+    data[3016]=(char)0xffff;
+    data[3017]=(char)0xffff;
+    data[3018]=(char)0xffff;
+    data[3019]=(char)0xffff;
+    data[3020]=(char)0xffff;
+    data[3021]=(char)0xffff;
+    data[3022]=(char)0xffff;
+    data[3023]=(char)0xffff;
+    data[3024]=(char)0xffff;
+    data[3025]=(char)0xffff;
+    data[3026]=(char)0xffff;
+    data[3027]=(char)0xffff;
+    data[3028]=(char)0xffff;
+    data[3029]=(char)0xffff;
+    data[3030]=(char)0xffff;
+    data[3031]=(char)0xffff;
+    data[3032]=(char)0xffff;
+    data[3033]=(char)0xffff;
+    data[3034]=(char)0xffff;
+    data[3035]=(char)0xffff;
+    data[3036]=(char)0xffff;
+    data[3037]=(char)0xffff;
+    data[3038]=(char)0xffff;
+    data[3039]=(char)0xffff;
+    data[3040]=(char)0xffff;
+    data[3041]=(char)0xffff;
+    data[3042]=(char)0xffff;
+    data[3043]=(char)0xffff;
+    data[3044]=(char)0xffff;
+    data[3045]=(char)0xffff;
+    data[3046]=(char)0xffff;
+    data[3047]=(char)0xffff;
+    data[3048]=(char)0xffff;
+    data[3049]=(char)0xffff;
+    data[3050]=(char)0xffff;
+    data[3051]=(char)0xffff;
+    data[3052]=(char)0xffff;
+    data[3053]=(char)0xffff;
+    data[3054]=(char)0xffff;
+    data[3055]=(char)0xffff;
+    data[3056]=(char)0xffff;
+    data[3057]=(char)0xffff;
+    data[3058]=(char)0xffff;
+    data[3059]=(char)0xffff;
+    data[3060]=(char)0xffff;
+    data[3061]=(char)0xffff;
+    data[3062]=(char)0xffff;
+    data[3063]=(char)0xffff;
+    data[3064]=(char)0xffff;
+    data[3065]=(char)0xffff;
+    data[3066]=(char)0xffff;
+    data[3067]=(char)0xffff;
+    data[3068]=(char)0xffff;
+    data[3069]=(char)0xffff;
+    data[3070]=(char)0xffff;
+    data[3071]=(char)0xffff;
+    data[3072]=(char)0xffff;
+    data[3073]=(char)0xffff;
+    data[3074]=(char)0xffff;
+    data[3075]=(char)0xffff;
+    data[3076]=(char)0xffff;
+    data[3077]=(char)0xffff;
+    data[3078]=(char)0xffff;
+    data[3079]=(char)0xffff;
+    data[3080]=(char)0xffff;
+    data[3081]=(char)0xffff;
+    data[3082]=(char)0xffff;
+    data[3083]=(char)0xffff;
+    data[3084]=(char)0xffff;
+    data[3085]=(char)0xffff;
+    data[3086]=(char)0xffff;
+    data[3087]=(char)0xffff;
+    data[3088]=(char)0xffff;
+    data[3089]=(char)0xffff;
+    data[3090]=(char)0xffff;
+    data[3091]=(char)0xffff;
+    data[3092]=(char)0xffff;
+    data[3093]=(char)0xffff;
+    data[3094]=(char)0xffff;
+    data[3095]=(char)0xffff;
+    data[3096]=(char)0xffff;
+    data[3097]=(char)0xffff;
+    data[3098]=(char)0xffff;
+    data[3099]=(char)0xffff;
+    data[3100]=(char)0xffff;
+    data[3101]=(char)0xffff;
+    data[3102]=(char)0xffff;
+    data[3103]=(char)0xffff;
+    data[3104]=(char)0xffff;
+    data[3105]=(char)0xffff;
+    data[3106]=(char)0xffff;
+    data[3107]=(char)0xffff;
+    data[3108]=(char)0xffff;
+    data[3109]=(char)0xffff;
+    data[3110]=(char)0xffff;
+    data[3111]=(char)0xffff;
+    data[3112]=(char)0xffff;
+    data[3113]=(char)0xffff;
+    data[3114]=(char)0xffff;
+    data[3115]=(char)0xffff;
+    data[3116]=(char)0xffff;
+    data[3117]=(char)0xffff;
+    data[3118]=(char)0xffff;
+    data[3119]=(char)0xffff;
+    data[3120]=(char)0xffff;
+    data[3121]=(char)0xffff;
+    data[3122]=(char)0xffff;
+    data[3123]=(char)0xffff;
+    data[3124]=(char)0xffff;
+    data[3125]=(char)0xffff;
+    data[3126]=(char)0xffff;
+    data[3127]=(char)0xffff;
+    data[3128]=(char)0xffff;
+    data[3129]=(char)0xffff;
+    data[3130]=(char)0xffff;
+    data[3131]=(char)0xffff;
+    data[3132]=(char)0xffff;
+    data[3133]=(char)0xffff;
+    data[3134]=(char)0xffff;
+    data[3135]=(char)0xffff;
+    data[3136]=(char)0xffff;
+    data[3137]=(char)0xffff;
+    data[3138]=(char)0xffff;
+    data[3139]=(char)0xffff;
+    data[3140]=(char)0xffff;
+    data[3141]=(char)0xffff;
+    data[3142]=(char)0xffff;
+    data[3143]=(char)0xffff;
+    data[3144]=(char)0xffff;
+    data[3145]=(char)0xffff;
+    data[3146]=(char)0xffff;
+    data[3147]=(char)0xffff;
+    data[3148]=(char)0xffff;
+    data[3149]=(char)0xffff;
+    data[3150]=(char)0xffff;
+    data[3151]=(char)0xffff;
+    data[3152]=(char)0xffff;
+    data[3153]=(char)0xffff;
+    data[3154]=(char)0xffff;
+    data[3155]=(char)0xffff;
+    data[3156]=(char)0xffff;
+    data[3157]=(char)0xffff;
+    data[3158]=(char)0xffff;
+    data[3159]=(char)0xffff;
+    data[3160]=(char)0xffff;
+    data[3161]=(char)0xffff;
+    data[3162]=(char)0xffff;
+    data[3163]=(char)0xffff;
+    data[3164]=(char)0xffff;
+    data[3165]=(char)0xffff;
+    data[3166]=(char)0xffff;
+    data[3167]=(char)0xffff;
+    data[3168]=(char)0xffff;
+    data[3169]=(char)0xffff;
+    data[3170]=(char)0xffff;
+    data[3171]=(char)0xffff;
+    data[3172]=(char)0xffff;
+    data[3173]=(char)0xffff;
+    data[3174]=(char)0xffff;
+    data[3175]=(char)0xffff;
+    data[3176]=(char)0xffff;
+    data[3177]=(char)0xffff;
+    data[3178]=(char)0xffff;
+    data[3179]=(char)0xffff;
+    data[3180]=(char)0xffff;
+    data[3181]=(char)0xffff;
+    data[3182]=(char)0xffff;
+    data[3183]=(char)0xffff;
+    data[3184]=(char)0xffff;
+    data[3185]=(char)0xffff;
+    data[3186]=(char)0xffff;
+    data[3187]=(char)0xffff;
+    data[3188]=(char)0xffff;
+    data[3189]=(char)0xffff;
+    data[3190]=(char)0xffff;
+    data[3191]=(char)0xffff;
+    data[3192]=(char)0xffff;
+    data[3193]=(char)0xffff;
+    data[3194]=(char)0xffff;
+    data[3195]=(char)0xffff;
+    data[3196]=(char)0xffff;
+    data[3197]=(char)0xffff;
+    data[3198]=(char)0xffff;
+    data[3199]=(char)0xffff;
+    data[3200]=(char)0xffff;
+    data[3201]=(char)0xffff;
+    data[3202]=(char)0xffff;
+    data[3203]=(char)0xffff;
+    data[3204]=(char)0xffff;
+    data[3205]=(char)0xffff;
+    data[3206]=(char)0xffff;
+    data[3207]=(char)0xffff;
+    data[3208]=(char)0xffff;
+    data[3209]=(char)0xffff;
+    data[3210]=(char)0xffff;
+    data[3211]=(char)0xffff;
+    data[3212]=(char)0xffff;
+    data[3213]=(char)0xffff;
+    data[3214]=(char)0xffff;
+    data[3215]=(char)0xffff;
+    data[3216]=(char)0xffff;
+    data[3217]=(char)0xffff;
+    data[3218]=(char)0xffff;
+    data[3219]=(char)0xffff;
+    data[3220]=(char)0xffff;
+    data[3221]=(char)0xffff;
+    data[3222]=(char)0xffff;
+    data[3223]=(char)0xffff;
+    data[3224]=(char)0xffff;
+    data[3225]=(char)0xffff;
+    data[3226]=(char)0xffff;
+    data[3227]=(char)0xffff;
+    data[3228]=(char)0xffff;
+    data[3229]=(char)0xffff;
+    data[3230]=(char)0xffff;
+    data[3231]=(char)0xffff;
+    data[3232]=(char)0xffff;
+    data[3233]=(char)0xffff;
+    data[3234]=(char)0xffff;
+    data[3235]=(char)0xffff;
+    data[3236]=(char)0xffff;
+    data[3237]=(char)0xffff;
+    data[3238]=(char)0xffff;
+    data[3239]=(char)0xffff;
+    data[3240]=(char)0xffff;
+    data[3241]=(char)0xffff;
+    data[3242]=(char)0xffff;
+    data[3243]=(char)0xffff;
+    data[3244]=(char)0xffff;
+    data[3245]=(char)0xffff;
+    data[3246]=(char)0xffff;
+    data[3247]=(char)0xffff;
+    data[3248]=(char)0xffff;
+    data[3249]=(char)0xffff;
+    data[3250]=(char)0xffff;
+    data[3251]=(char)0xffff;
+    data[3252]=(char)0xffff;
+    data[3253]=(char)0xffff;
+    data[3254]=(char)0xffff;
+    data[3255]=(char)0xffff;
+    data[3256]=(char)0xffff;
+    data[3257]=(char)0xffff;
+    data[3258]=(char)0xffff;
+    data[3259]=(char)0xffff;
+    data[3260]=(char)0xffff;
+    data[3261]=(char)0xffff;
+    data[3262]=(char)0xffff;
+    data[3263]=(char)0xffff;
+    data[3264]=(char)0xffff;
+    data[3265]=(char)0xffff;
+    data[3266]=(char)0xffff;
+    data[3267]=(char)0xffff;
+    data[3268]=(char)0xffff;
+    data[3269]=(char)0xffff;
+    data[3270]=(char)0xffff;
+    data[3271]=(char)0xffff;
+    data[3272]=(char)0xffff;
+    data[3273]=(char)0xffff;
+    data[3274]=(char)0xffff;
+    data[3275]=(char)0xffff;
+    data[3276]=(char)0xffff;
+    data[3277]=(char)0xffff;
+    data[3278]=(char)0xffff;
+    data[3279]=(char)0xffff;
+    data[3280]=(char)0xffff;
+    data[3281]=(char)0xffff;
+    data[3282]=(char)0xffff;
+    data[3283]=(char)0xffff;
+    data[3284]=(char)0xffff;
+    data[3285]=(char)0xffff;
+    data[3286]=(char)0xffff;
+    data[3287]=(char)0xffff;
+    data[3288]=(char)0xffff;
+    data[3289]=(char)0xffff;
+    data[3290]=(char)0xffff;
+    data[3291]=(char)0xffff;
+    data[3292]=(char)0xffff;
+    data[3293]=(char)0xffff;
+    data[3294]=(char)0xffff;
+    data[3295]=(char)0xffff;
+    data[3296]=(char)0xffff;
+    data[3297]=(char)0xffff;
+    data[3298]=(char)0xffff;
+    data[3299]=(char)0xffff;
+    data[3300]=(char)0xffff;
+    data[3301]=(char)0xffff;
+    data[3302]=(char)0xffff;
+    data[3303]=(char)0xffff;
+    data[3304]=(char)0xffff;
+    data[3305]=(char)0xffff;
+    data[3306]=(char)0xffff;
+    data[3307]=(char)0xffff;
+    data[3308]=(char)0xffff;
+    data[3309]=(char)0xffff;
+    data[3310]=(char)0xffff;
+    data[3311]=(char)0xffff;
+    data[3312]=(char)0xffff;
+    data[3313]=(char)0xffff;
+    data[3314]=(char)0xffff;
+    data[3315]=(char)0xffff;
+    data[3316]=(char)0xffff;
+    data[3317]=(char)0xffff;
+    data[3318]=(char)0xffff;
+    data[3319]=(char)0xffff;
+    data[3320]=(char)0xffff;
+    data[3321]=(char)0xffff;
+    data[3322]=(char)0xffff;
+    data[3323]=(char)0xffff;
+    data[3324]=(char)0xffff;
+    data[3325]=(char)0xffff;
+    data[3326]=(char)0xffff;
+    data[3327]=(char)0xffff;
+    data[3328]=(char)0xffff;
+    data[3329]=(char)0xffff;
+    data[3330]=(char)0xffff;
+    data[3331]=(char)0xffff;
+    data[3332]=(char)0xffff;
+    data[3333]=(char)0xffff;
+    data[3334]=(char)0xffff;
+    data[3335]=(char)0xffff;
+    data[3336]=(char)0xffff;
+    data[3337]=(char)0xffff;
+    data[3338]=(char)0xffff;
+    data[3339]=(char)0xffff;
+    data[3340]=(char)0xffff;
+    data[3341]=(char)0xffff;
+    data[3342]=(char)0xffff;
+    data[3343]=(char)0xffff;
+    data[3344]=(char)0xffff;
+    data[3345]=(char)0xffff;
+    data[3346]=(char)0xffff;
+    data[3347]=(char)0xffff;
+    data[3348]=(char)0xffff;
+    data[3349]=(char)0xffff;
+    data[3350]=(char)0xffff;
+    data[3351]=(char)0xffff;
+    data[3352]=(char)0xffff;
+    data[3353]=(char)0xffff;
+    data[3354]=(char)0xffff;
+    data[3355]=(char)0xffff;
+    data[3356]=(char)0xffff;
+    data[3357]=(char)0xffff;
+    data[3358]=(char)0xffff;
+    data[3359]=(char)0xffff;
+    data[3360]=(char)0xffff;
+    data[3361]=(char)0xffff;
+    data[3362]=(char)0xffff;
+    data[3363]=(char)0xffff;
+    data[3364]=(char)0xffff;
+    data[3365]=(char)0xffff;
+    data[3366]=(char)0xffff;
+    data[3367]=(char)0xffff;
+    data[3368]=(char)0xffff;
+    data[3369]=(char)0xffff;
+    data[3370]=(char)0xffff;
+    data[3371]=(char)0xffff;
+    data[3372]=(char)0xffff;
+    data[3373]=(char)0xffff;
+    data[3374]=(char)0xffff;
+    data[3375]=(char)0xffff;
+    data[3376]=(char)0xffff;
+    data[3377]=(char)0xffff;
+    data[3378]=(char)0xffff;
+    data[3379]=(char)0xffff;
+    data[3380]=(char)0xffff;
+    data[3381]=(char)0xffff;
+    data[3382]=(char)0xffff;
+    data[3383]=(char)0xffff;
+    data[3384]=(char)0xffff;
+    data[3385]=(char)0xffff;
+    data[3386]=(char)0xffff;
+    data[3387]=(char)0xffff;
+    data[3388]=(char)0xffff;
+    data[3389]=(char)0xffff;
+    data[3390]=(char)0xffff;
+    data[3391]=(char)0xffff;
+    data[3392]=(char)0xffff;
+    data[3393]=(char)0xffff;
+    data[3394]=(char)0xffff;
+    data[3395]=(char)0xffff;
+    data[3396]=(char)0xffff;
+    data[3397]=(char)0xffff;
+    data[3398]=(char)0xffff;
+    data[3399]=(char)0xffff;
+    data[3400]=(char)0xffff;
+    data[3401]=(char)0xffff;
+    data[3402]=(char)0xffff;
+    data[3403]=(char)0xffff;
+    data[3404]=(char)0xffff;
+    data[3405]=(char)0xffff;
+    data[3406]=(char)0xffff;
+    data[3407]=(char)0xffff;
+    data[3408]=(char)0xffff;
+    data[3409]=(char)0xffff;
+    data[3410]=(char)0xffff;
+    data[3411]=(char)0xffff;
+    data[3412]=(char)0xffff;
+    data[3413]=(char)0xffff;
+    data[3414]=(char)0xffff;
+    data[3415]=(char)0xffff;
+    data[3416]=(char)0xffff;
+    data[3417]=(char)0xffff;
+    data[3418]=(char)0xffff;
+    data[3419]=(char)0xffff;
+    data[3420]=(char)0xffff;
+    data[3421]=(char)0xffff;
+    data[3422]=(char)0xffff;
+    data[3423]=(char)0xffff;
+    data[3424]=(char)0xffff;
+    data[3425]=(char)0xffff;
+    data[3426]=(char)0xffff;
+    data[3427]=(char)0xffff;
+    data[3428]=(char)0xffff;
+    data[3429]=(char)0xffff;
+    data[3430]=(char)0xffff;
+    data[3431]=(char)0xffff;
+    data[3432]=(char)0xffff;
+    data[3433]=(char)0xffff;
+    data[3434]=(char)0xffff;
+    data[3435]=(char)0xffff;
+    data[3436]=(char)0xffff;
+    data[3437]=(char)0xffff;
+    data[3438]=(char)0xffff;
+    data[3439]=(char)0xffff;
+    data[3440]=(char)0xffff;
+    data[3441]=(char)0xffff;
+    data[3442]=(char)0xffff;
+    data[3443]=(char)0xffff;
+    data[3444]=(char)0xffff;
+    data[3445]=(char)0xffff;
+    data[3446]=(char)0xffff;
+    data[3447]=(char)0xffff;
+    data[3448]=(char)0xffff;
+    data[3449]=(char)0xffff;
+    data[3450]=(char)0x000f;
+    data[3984]=(char)0xffff;
+    data[3985]=(char)0xffff;
+    data[3986]=(char)0xffff;
+    data[3987]=(char)0xffff;
+    data[3988]=(char)0xffff;
+    data[3989]=(char)0xffff;
+    data[3990]=(char)0xffff;
+    data[3991]=(char)0xffff;
+    data[3992]=(char)0xffff;
+    data[3993]=(char)0xffff;
+    data[3994]=(char)0xffff;
+    data[3995]=(char)0xffff;
+    data[3996]=(char)0xffff;
+    data[3997]=(char)0xffff;
+    data[3998]=(char)0xffff;
+    data[3999]=(char)0xffff;
+    data[4000]=(char)0xffff;
+    data[4001]=(char)0xffff;
+    data[4002]=(char)0x3fff;
+    data[4016]=(char)0x007f;
+    data[4017]=(char)0x80f8;
+    data[4018]=(char)0xfdff;
+    data[4019]=(char)0x5f7f;
+    data[4020]=(char)0xffdb;
+    data[4021]=(char)0xffff;
+    data[4022]=(char)0xffff;
+    data[4023]=(char)0xffff;
+    data[4024]=(char)0xffff;
+    data[4025]=(char)0xffff;
+    data[4026]=(char)0xffff;
+    data[4027]=(char)0x0003;
+    data[4029]=(char)0xfff8;
+    data[4030]=(char)0xffff;
+    data[4031]=(char)0xffff;
+    data[4032]=(char)0xffff;
+    data[4033]=(char)0xffff;
+    data[4034]=(char)0xffff;
+    data[4035]=(char)0xffff;
+    data[4036]=(char)0xffff;
+    data[4037]=(char)0xffff;
+    data[4038]=(char)0xffff;
+    data[4039]=(char)0xffff;
+    data[4040]=(char)0xffff;
+    data[4041]=(char)0xffff;
+    data[4042]=(char)0xffff;
+    data[4043]=(char)0xffff;
+    data[4044]=(char)0xffff;
+    data[4045]=(char)0xffff;
+    data[4046]=(char)0xffff;
+    data[4047]=(char)0xffff;
+    data[4048]=(char)0xffff;
+    data[4049]=(char)0xffff;
+    data[4050]=(char)0xffff;
+    data[4051]=(char)0x3fff;
+    data[4053]=(char)0xffff;
+    data[4054]=(char)0xffff;
+    data[4055]=(char)0xffff;
+    data[4056]=(char)0xffff;
+    data[4057]=(char)0xfffc;
+    data[4058]=(char)0xffff;
+    data[4059]=(char)0xffff;
+    data[4060]=(char)0x00ff;
+    data[4063]=(char)0x0fff;
+    data[4071]=(char)0xffd7;
+    data[4072]=(char)0xffff;
+    data[4073]=(char)0xffff;
+    data[4074]=(char)0xffff;
+    data[4075]=(char)0xffff;
+    data[4076]=(char)0xffff;
+    data[4077]=(char)0xffff;
+    data[4078]=(char)0xffff;
+    data[4079]=(char)0x1fff;
+    data[4082]=(char)0xfffe;
+    data[4083]=(char)0x07ff;
+    data[4084]=(char)0xfffe;
+    data[4085]=(char)0x07ff;
+    data[4086]=(char)0xffc0;
+    data[4087]=(char)0xffff;
+    data[4088]=(char)0xffff;
+    data[4089]=(char)0xffff;
+    data[4090]=(char)0xffff;
+    data[4091]=(char)0x7fff;
+    data[4092]=(char)0xfcfc;
+    data[4093]=(char)0x1cfc;
+    data[4100]=(char)0xfffe;
+    data[4101]=(char)0x07ff;
+    data[4102]=(char)0xfffe;
+    data[4103]=(char)0x07ff;
+    data[4106]=(char)0x0400;
+    data[4107]=(char)0x0420;
+    data[4108]=(char)0xffff;
+    data[4109]=(char)0xff7f;
+    data[4110]=(char)0xffff;
+    data[4111]=(char)0xff7f;
+    data[4112]=(char)0xffff;
+    data[4113]=(char)0xffff;
+    data[4114]=(char)0xffff;
+    data[4115]=(char)0xffff;
+    data[4116]=(char)0xffff;
+    data[4117]=(char)0xffff;
+    data[4118]=(char)0xffff;
+    data[4119]=(char)0xffff;
+    data[4120]=(char)0xffff;
+    data[4121]=(char)0xffff;
+    data[4122]=(char)0xffff;
+    data[4123]=(char)0xffff;
+    data[4124]=(char)0xffff;
+    data[4125]=(char)0xffff;
+    data[4126]=(char)0xffff;
+    data[4127]=(char)0xfc3f;
+    data[4128]=(char)0xffff;
+    data[4129]=(char)0x00ff;
+    data[4133]=(char)0xffff;
+    data[4134]=(char)0xffff;
+    data[4135]=(char)0xffff;
+    data[4136]=(char)0xffff;
+    data[4137]=(char)0xffff;
+    data[4138]=(char)0x01ff;
+    data[4139]=(char)0xf9ff;
+    data[4140]=(char)0x0003;
+    data[4141]=(char)0x0003;
+    data[4142]=(char)0x001f;
+    data[4151]=(char)0x0400;
+    data[4152]=(char)0xd740;
+    data[4153]=(char)0xffff;
+    data[4154]=(char)0xfffb;
+    data[4155]=(char)0xffff;
+    data[4156]=(char)0x7fff;
+    data[4157]=(char)0x547f;
+    data[4158]=(char)0x00fd;
+
+  }
+  public static Bits white;
+  static void white_f() {
+    char[] data = new char[4159];
+    white = new Bits(data);
+    data[0]=(char)0x3e00;
+    data[1]=(char)0xf000;
+    data[2]=(char)0x0001;
+    data[512]=(char)0x0fff;
+    data[514]=(char)0x0300;
+    data[768]=(char)0x0001;
+    data[4096]=(char)0x3e00;
+    data[4097]=(char)0xf000;
+    data[4098]=(char)0x0001;
+
+  }
+  public static Bits punct;
+  static void punct_f() {
+    char[] data = new char[4159];
+    punct = new Bits(data);
+    data[2]=(char)0xf7ee;
+    data[3]=(char)0x8c00;
+    data[4]=(char)0x0001;
+    data[5]=(char)0xb800;
+    data[7]=(char)0x2800;
+    data[10]=(char)0x2802;
+    data[11]=(char)0x8880;
+    data[55]=(char)0x4030;
+    data[56]=(char)0x0080;
+    data[85]=(char)0xfc00;
+    data[88]=(char)0x0200;
+    data[91]=(char)0x4000;
+    data[92]=(char)0x0009;
+    data[95]=(char)0x0018;
+    data[96]=(char)0x1000;
+    data[97]=(char)0x8800;
+    data[102]=(char)0x3c00;
+    data[109]=(char)0x0010;
+    data[150]=(char)0x0030;
+    data[151]=(char)0x0001;
+    data[226]=(char)0x8000;
+    data[229]=(char)0x0c00;
+    data[234]=(char)0x8000;
+    data[240]=(char)0xfff0;
+    data[241]=(char)0x0007;
+    data[243]=(char)0x3c00;
+    data[248]=(char)0x0020;
+    data[271]=(char)0x0800;
+    data[513]=(char)0xffff;
+    data[514]=(char)0x00ff;
+    data[515]=(char)0xffff;
+    data[516]=(char)0x006f;
+    data[519]=(char)0x6000;
+    data[520]=(char)0x6000;
+    data[562]=(char)0x0600;
+    data[768]=(char)0xff4e;
+    data[769]=(char)0xfff3;
+    data[771]=(char)0x0001;
+    data[783]=(char)0x0800;
+    data[4051]=(char)0xc000;
+    data[4067]=(char)0xffff;
+    data[4068]=(char)0xfe1f;
+    data[4069]=(char)0xfff7;
+    data[4070]=(char)0x0d0b;
+    data[4080]=(char)0xf7ee;
+    data[4081]=(char)0x8c00;
+    data[4082]=(char)0x0001;
+    data[4083]=(char)0xb800;
+    data[4085]=(char)0x2800;
+    data[4086]=(char)0x003e;
+    data[4098]=(char)0xf7ee;
+    data[4099]=(char)0x8c00;
+    data[4100]=(char)0x0001;
+    data[4101]=(char)0xb800;
+    data[4103]=(char)0x2800;
+    data[4106]=(char)0x2802;
+    data[4107]=(char)0x8880;
+    data[4151]=(char)0x4030;
+    data[4152]=(char)0x0080;
+
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Bits.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Boundary.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Boundary.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Boundary.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Boundary.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Boundary.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,51 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** This class implements the word boundary pattern element: \b. */
+class Boundary extends Pattern {
+    public String toString() {
+        return "\\b"+nextString();
+    }
+    boolean isAChar(char c) {
+        if(c >= 'a' && c <= 'z')
+            return true;
+        if(c >= 'A' && c <= 'Z')
+            return true;
+        if(c >= '0' && c <= '9')
+            return true;
+        if(c == '_')
+            return true;
+        return false;
+    }
+    boolean matchLeft(int pos,Pthings pt) {
+        if(pos <= 0)
+            return true;
+        if(isAChar(pt.src.charAt(pos))
+                && isAChar(pt.src.charAt(pos-1)))
+            return false;
+        return true;
+    }
+    boolean matchRight(int pos,Pthings pt) {
+        if(pos < 0) return false;
+        if(pos+1 >= pt.src.length())
+            return true;
+        if(isAChar(pt.src.charAt(pos))
+                && isAChar(pt.src.charAt(pos+1)))
+            return false;
+        return true;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(matchRight(pos-1,pt) || matchLeft(pos,pt))
+            return nextMatch(pos,pt);
+        return -1;
+    }
+    public patInt maxChars() { return new patInt(0); }
+    public Pattern clone1(Hashtable h) { return new Boundary(); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Boundary.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Bracket.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Bracket.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Bracket.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Bracket.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Bracket.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,48 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Vector;
+import ewe.util.Hashtable;
+
+/** The Bracket is a form of the Or class,
+ implements the pattern element [  ]. */
+class Bracket extends Or {
+    boolean neg;
+    Bracket(boolean n) { neg = n; }
+    String leftForm() {
+        if(neg)
+            return "[^";
+        else
+            return "[";
+    }
+    String rightForm() { return "]"; }
+    String sepForm() { return ""; }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos >= pt.src.length()) return -1;
+        int r = super.matchInternal(pos,pt);
+        if((neg && r<0)||(!neg && r>=0))
+            return nextMatch(pos+1,pt);
+        return -1;
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+
+    public Or addOr(Pattern p) {
+        pv = null;
+        v.addElement(p);
+        p.setParent(null);
+        return this;
+    }
+    public Pattern clone1(Hashtable h) {
+        Bracket b = new Bracket(neg);
+        b.v = new Vector();
+        for(int i=0;i<v.size();i++)
+            b.v.addElement( ((Pattern)v.elementAt(i)).clone1(h) );
+        return b;
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Bracket.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Branch.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Branch.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/CaseMgr.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/CaseMgr.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/CaseMgr.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/CaseMgr.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/CaseMgr.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,1537 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** Encapsulates the Unicode definitions of Upper,
+    Lower, and Title case as defined by <a href="http://www.unicode.org">
+    unicode.org</a>.
+    <p>
+    The performance of the methods found in String
+    and Character is better, but these methods work
+    both in java 1.0 and 1.1.  If it is desirable,
+    either to gain a slight performance increase or
+    to accomodate application specific modifications
+    to the definitions of upper, lower, and title case
+    then it should be a straightforward task to substitute
+    your own methods for these.
+    */
+final public class CaseMgr {
+    final static boolean java_1_0 = false;
+    /** Convert a character to upper case .*/
+    public static char toUpperCase(char c) {
+      if(java_1_0) {
+        int ret = (int)c;
+        switch(c) {
+        case 97: ret=65; break;
+        case 98: ret=66; break;
+        case 99: ret=67; break;
+        case 100: ret=68; break;
+        case 101: ret=69; break;
+        case 102: ret=70; break;
+        case 103: ret=71; break;
+        case 104: ret=72; break;
+        case 105: ret=73; break;
+        case 106: ret=74; break;
+        case 107: ret=75; break;
+        case 108: ret=76; break;
+        case 109: ret=77; break;
+        case 110: ret=78; break;
+        case 111: ret=79; break;
+        case 112: ret=80; break;
+        case 113: ret=81; break;
+        case 114: ret=82; break;
+        case 115: ret=83; break;
+        case 116: ret=84; break;
+        case 117: ret=85; break;
+        case 118: ret=86; break;
+        case 119: ret=87; break;
+        case 120: ret=88; break;
+        case 121: ret=89; break;
+        case 122: ret=90; break;
+        case 224: ret=192; break;
+        case 225: ret=193; break;
+        case 226: ret=194; break;
+        case 227: ret=195; break;
+        case 228: ret=196; break;
+        case 229: ret=197; break;
+        case 230: ret=198; break;
+        case 231: ret=199; break;
+        case 232: ret=200; break;
+        case 233: ret=201; break;
+        case 234: ret=202; break;
+        case 235: ret=203; break;
+        case 236: ret=204; break;
+        case 237: ret=205; break;
+        case 238: ret=206; break;
+        case 239: ret=207; break;
+        case 240: ret=208; break;
+        case 241: ret=209; break;
+        case 242: ret=210; break;
+        case 243: ret=211; break;
+        case 244: ret=212; break;
+        case 245: ret=213; break;
+        case 246: ret=214; break;
+        case 248: ret=216; break;
+        case 249: ret=217; break;
+        case 250: ret=218; break;
+        case 251: ret=219; break;
+        case 252: ret=220; break;
+        case 253: ret=221; break;
+        case 254: ret=222; break;
+        case 255: ret=376; break;
+        case 257: ret=256; break;
+        case 259: ret=258; break;
+        case 261: ret=260; break;
+        case 263: ret=262; break;
+        case 265: ret=264; break;
+        case 267: ret=266; break;
+        case 269: ret=268; break;
+        case 271: ret=270; break;
+        case 273: ret=272; break;
+        case 275: ret=274; break;
+        case 277: ret=276; break;
+        case 279: ret=278; break;
+        case 281: ret=280; break;
+        case 283: ret=282; break;
+        case 285: ret=284; break;
+        case 287: ret=286; break;
+        case 289: ret=288; break;
+        case 291: ret=290; break;
+        case 293: ret=292; break;
+        case 295: ret=294; break;
+        case 297: ret=296; break;
+        case 299: ret=298; break;
+        case 301: ret=300; break;
+        case 303: ret=302; break;
+        case 305: ret=73; break;
+        case 307: ret=306; break;
+        case 309: ret=308; break;
+        case 311: ret=310; break;
+        case 314: ret=313; break;
+        case 316: ret=315; break;
+        case 318: ret=317; break;
+        case 320: ret=319; break;
+        case 322: ret=321; break;
+        case 324: ret=323; break;
+        case 326: ret=325; break;
+        case 328: ret=327; break;
+        case 331: ret=330; break;
+        case 333: ret=332; break;
+        case 335: ret=334; break;
+        case 337: ret=336; break;
+        case 339: ret=338; break;
+        case 341: ret=340; break;
+        case 343: ret=342; break;
+        case 345: ret=344; break;
+        case 347: ret=346; break;
+        case 349: ret=348; break;
+        case 351: ret=350; break;
+        case 353: ret=352; break;
+        case 355: ret=354; break;
+        case 357: ret=356; break;
+        case 359: ret=358; break;
+        case 361: ret=360; break;
+        case 363: ret=362; break;
+        case 365: ret=364; break;
+        case 367: ret=366; break;
+        case 369: ret=368; break;
+        case 371: ret=370; break;
+        case 373: ret=372; break;
+        case 375: ret=374; break;
+        case 378: ret=377; break;
+        case 380: ret=379; break;
+        case 382: ret=381; break;
+        case 383: ret=83; break;
+        case 387: ret=386; break;
+        case 389: ret=388; break;
+        case 392: ret=391; break;
+        case 396: ret=395; break;
+        case 402: ret=401; break;
+        case 409: ret=408; break;
+        case 417: ret=416; break;
+        case 419: ret=418; break;
+        case 421: ret=420; break;
+        case 424: ret=423; break;
+        case 429: ret=428; break;
+        case 432: ret=431; break;
+        case 436: ret=435; break;
+        case 438: ret=437; break;
+        case 441: ret=440; break;
+        case 445: ret=444; break;
+        case 453: ret=452; break;
+        case 454: ret=452; break;
+        case 456: ret=455; break;
+        case 457: ret=455; break;
+        case 459: ret=458; break;
+        case 460: ret=458; break;
+        case 462: ret=461; break;
+        case 464: ret=463; break;
+        case 466: ret=465; break;
+        case 468: ret=467; break;
+        case 470: ret=469; break;
+        case 472: ret=471; break;
+        case 474: ret=473; break;
+        case 476: ret=475; break;
+        case 479: ret=478; break;
+        case 481: ret=480; break;
+        case 483: ret=482; break;
+        case 485: ret=484; break;
+        case 487: ret=486; break;
+        case 489: ret=488; break;
+        case 491: ret=490; break;
+        case 493: ret=492; break;
+        case 495: ret=494; break;
+        case 498: ret=497; break;
+        case 499: ret=497; break;
+        case 501: ret=500; break;
+        case 507: ret=506; break;
+        case 509: ret=508; break;
+        case 511: ret=510; break;
+        case 513: ret=512; break;
+        case 515: ret=514; break;
+        case 517: ret=516; break;
+        case 519: ret=518; break;
+        case 521: ret=520; break;
+        case 523: ret=522; break;
+        case 525: ret=524; break;
+        case 527: ret=526; break;
+        case 529: ret=528; break;
+        case 531: ret=530; break;
+        case 533: ret=532; break;
+        case 535: ret=534; break;
+        case 595: ret=385; break;
+        case 596: ret=390; break;
+        case 598: ret=393; break;
+        case 599: ret=394; break;
+        case 600: ret=398; break;
+        case 601: ret=399; break;
+        case 603: ret=400; break;
+        case 608: ret=403; break;
+        case 611: ret=404; break;
+        case 616: ret=407; break;
+        case 617: ret=406; break;
+        case 623: ret=412; break;
+        case 626: ret=413; break;
+        case 643: ret=425; break;
+        case 648: ret=430; break;
+        case 650: ret=433; break;
+        case 651: ret=434; break;
+        case 658: ret=439; break;
+        case 940: ret=902; break;
+        case 941: ret=904; break;
+        case 942: ret=905; break;
+        case 943: ret=906; break;
+        case 945: ret=913; break;
+        case 946: ret=914; break;
+        case 947: ret=915; break;
+        case 948: ret=916; break;
+        case 949: ret=917; break;
+        case 950: ret=918; break;
+        case 951: ret=919; break;
+        case 952: ret=920; break;
+        case 953: ret=921; break;
+        case 954: ret=922; break;
+        case 955: ret=923; break;
+        case 956: ret=924; break;
+        case 957: ret=925; break;
+        case 958: ret=926; break;
+        case 959: ret=927; break;
+        case 960: ret=928; break;
+        case 961: ret=929; break;
+        case 963: ret=931; break;
+        case 964: ret=932; break;
+        case 965: ret=933; break;
+        case 966: ret=934; break;
+        case 967: ret=935; break;
+        case 968: ret=936; break;
+        case 969: ret=937; break;
+        case 970: ret=938; break;
+        case 971: ret=939; break;
+        case 972: ret=908; break;
+        case 973: ret=910; break;
+        case 974: ret=911; break;
+        case 976: ret=914; break;
+        case 977: ret=920; break;
+        case 981: ret=934; break;
+        case 982: ret=928; break;
+        case 995: ret=994; break;
+        case 997: ret=996; break;
+        case 999: ret=998; break;
+        case 1001: ret=1000; break;
+        case 1003: ret=1002; break;
+        case 1005: ret=1004; break;
+        case 1007: ret=1006; break;
+        case 1008: ret=922; break;
+        case 1009: ret=929; break;
+        case 1072: ret=1040; break;
+        case 1073: ret=1041; break;
+        case 1074: ret=1042; break;
+        case 1075: ret=1043; break;
+        case 1076: ret=1044; break;
+        case 1077: ret=1045; break;
+        case 1078: ret=1046; break;
+        case 1079: ret=1047; break;
+        case 1080: ret=1048; break;
+        case 1081: ret=1049; break;
+        case 1082: ret=1050; break;
+        case 1083: ret=1051; break;
+        case 1084: ret=1052; break;
+        case 1085: ret=1053; break;
+        case 1086: ret=1054; break;
+        case 1087: ret=1055; break;
+        case 1088: ret=1056; break;
+        case 1089: ret=1057; break;
+        case 1090: ret=1058; break;
+        case 1091: ret=1059; break;
+        case 1092: ret=1060; break;
+        case 1093: ret=1061; break;
+        case 1094: ret=1062; break;
+        case 1095: ret=1063; break;
+        case 1096: ret=1064; break;
+        case 1097: ret=1065; break;
+        case 1098: ret=1066; break;
+        case 1099: ret=1067; break;
+        case 1100: ret=1068; break;
+        case 1101: ret=1069; break;
+        case 1102: ret=1070; break;
+        case 1103: ret=1071; break;
+        case 1105: ret=1025; break;
+        case 1106: ret=1026; break;
+        case 1107: ret=1027; break;
+        case 1108: ret=1028; break;
+        case 1109: ret=1029; break;
+        case 1110: ret=1030; break;
+        case 1111: ret=1031; break;
+        case 1112: ret=1032; break;
+        case 1113: ret=1033; break;
+        case 1114: ret=1034; break;
+        case 1115: ret=1035; break;
+        case 1116: ret=1036; break;
+        case 1118: ret=1038; break;
+        case 1119: ret=1039; break;
+        case 1121: ret=1120; break;
+        case 1123: ret=1122; break;
+        case 1125: ret=1124; break;
+        case 1127: ret=1126; break;
+        case 1129: ret=1128; break;
+        case 1131: ret=1130; break;
+        case 1133: ret=1132; break;
+        case 1135: ret=1134; break;
+        case 1137: ret=1136; break;
+        case 1139: ret=1138; break;
+        case 1141: ret=1140; break;
+        case 1143: ret=1142; break;
+        case 1145: ret=1144; break;
+        case 1147: ret=1146; break;
+        case 1149: ret=1148; break;
+        case 1151: ret=1150; break;
+        case 1153: ret=1152; break;
+        case 1169: ret=1168; break;
+        case 1171: ret=1170; break;
+        case 1173: ret=1172; break;
+        case 1175: ret=1174; break;
+        case 1177: ret=1176; break;
+        case 1179: ret=1178; break;
+        case 1181: ret=1180; break;
+        case 1183: ret=1182; break;
+        case 1185: ret=1184; break;
+        case 1187: ret=1186; break;
+        case 1189: ret=1188; break;
+        case 1191: ret=1190; break;
+        case 1193: ret=1192; break;
+        case 1195: ret=1194; break;
+        case 1197: ret=1196; break;
+        case 1199: ret=1198; break;
+        case 1201: ret=1200; break;
+        case 1203: ret=1202; break;
+        case 1205: ret=1204; break;
+        case 1207: ret=1206; break;
+        case 1209: ret=1208; break;
+        case 1211: ret=1210; break;
+        case 1213: ret=1212; break;
+        case 1215: ret=1214; break;
+        case 1218: ret=1217; break;
+        case 1220: ret=1219; break;
+        case 1224: ret=1223; break;
+        case 1228: ret=1227; break;
+        case 1233: ret=1232; break;
+        case 1235: ret=1234; break;
+        case 1237: ret=1236; break;
+        case 1239: ret=1238; break;
+        case 1241: ret=1240; break;
+        case 1243: ret=1242; break;
+        case 1245: ret=1244; break;
+        case 1247: ret=1246; break;
+        case 1249: ret=1248; break;
+        case 1251: ret=1250; break;
+        case 1253: ret=1252; break;
+        case 1255: ret=1254; break;
+        case 1257: ret=1256; break;
+        case 1259: ret=1258; break;
+        case 1263: ret=1262; break;
+        case 1265: ret=1264; break;
+        case 1267: ret=1266; break;
+        case 1269: ret=1268; break;
+        case 1273: ret=1272; break;
+        case 1377: ret=1329; break;
+        case 1378: ret=1330; break;
+        case 1379: ret=1331; break;
+        case 1380: ret=1332; break;
+        case 1381: ret=1333; break;
+        case 1382: ret=1334; break;
+        case 1383: ret=1335; break;
+        case 1384: ret=1336; break;
+        case 1385: ret=1337; break;
+        case 1386: ret=1338; break;
+        case 1387: ret=1339; break;
+        case 1388: ret=1340; break;
+        case 1389: ret=1341; break;
+        case 1390: ret=1342; break;
+        case 1391: ret=1343; break;
+        case 1392: ret=1344; break;
+        case 1393: ret=1345; break;
+        case 1394: ret=1346; break;
+        case 1395: ret=1347; break;
+        case 1396: ret=1348; break;
+        case 1397: ret=1349; break;
+        case 1398: ret=1350; break;
+        case 1399: ret=1351; break;
+        case 1400: ret=1352; break;
+        case 1401: ret=1353; break;
+        case 1402: ret=1354; break;
+        case 1403: ret=1355; break;
+        case 1404: ret=1356; break;
+        case 1405: ret=1357; break;
+        case 1406: ret=1358; break;
+        case 1407: ret=1359; break;
+        case 1408: ret=1360; break;
+        case 1409: ret=1361; break;
+        case 1410: ret=1362; break;
+        case 1411: ret=1363; break;
+        case 1412: ret=1364; break;
+        case 1413: ret=1365; break;
+        case 1414: ret=1366; break;
+        case 7681: ret=7680; break;
+        case 7683: ret=7682; break;
+        case 7685: ret=7684; break;
+        case 7687: ret=7686; break;
+        case 7689: ret=7688; break;
+        case 7691: ret=7690; break;
+        case 7693: ret=7692; break;
+        case 7695: ret=7694; break;
+        case 7697: ret=7696; break;
+        case 7699: ret=7698; break;
+        case 7701: ret=7700; break;
+        case 7703: ret=7702; break;
+        case 7705: ret=7704; break;
+        case 7707: ret=7706; break;
+        case 7709: ret=7708; break;
+        case 7711: ret=7710; break;
+        case 7713: ret=7712; break;
+        case 7715: ret=7714; break;
+        case 7717: ret=7716; break;
+        case 7719: ret=7718; break;
+        case 7721: ret=7720; break;
+        case 7723: ret=7722; break;
+        case 7725: ret=7724; break;
+        case 7727: ret=7726; break;
+        case 7729: ret=7728; break;
+        case 7731: ret=7730; break;
+        case 7733: ret=7732; break;
+        case 7735: ret=7734; break;
+        case 7737: ret=7736; break;
+        case 7739: ret=7738; break;
+        case 7741: ret=7740; break;
+        case 7743: ret=7742; break;
+        case 7745: ret=7744; break;
+        case 7747: ret=7746; break;
+        case 7749: ret=7748; break;
+        case 7751: ret=7750; break;
+        case 7753: ret=7752; break;
+        case 7755: ret=7754; break;
+        case 7757: ret=7756; break;
+        case 7759: ret=7758; break;
+        case 7761: ret=7760; break;
+        case 7763: ret=7762; break;
+        case 7765: ret=7764; break;
+        case 7767: ret=7766; break;
+        case 7769: ret=7768; break;
+        case 7771: ret=7770; break;
+        case 7773: ret=7772; break;
+        case 7775: ret=7774; break;
+        case 7777: ret=7776; break;
+        case 7779: ret=7778; break;
+        case 7781: ret=7780; break;
+        case 7783: ret=7782; break;
+        case 7785: ret=7784; break;
+        case 7787: ret=7786; break;
+        case 7789: ret=7788; break;
+        case 7791: ret=7790; break;
+        case 7793: ret=7792; break;
+        case 7795: ret=7794; break;
+        case 7797: ret=7796; break;
+        case 7799: ret=7798; break;
+        case 7801: ret=7800; break;
+        case 7803: ret=7802; break;
+        case 7805: ret=7804; break;
+        case 7807: ret=7806; break;
+        case 7809: ret=7808; break;
+        case 7811: ret=7810; break;
+        case 7813: ret=7812; break;
+        case 7815: ret=7814; break;
+        case 7817: ret=7816; break;
+        case 7819: ret=7818; break;
+        case 7821: ret=7820; break;
+        case 7823: ret=7822; break;
+        case 7825: ret=7824; break;
+        case 7827: ret=7826; break;
+        case 7829: ret=7828; break;
+        case 7841: ret=7840; break;
+        case 7843: ret=7842; break;
+        case 7845: ret=7844; break;
+        case 7847: ret=7846; break;
+        case 7849: ret=7848; break;
+        case 7851: ret=7850; break;
+        case 7853: ret=7852; break;
+        case 7855: ret=7854; break;
+        case 7857: ret=7856; break;
+        case 7859: ret=7858; break;
+        case 7861: ret=7860; break;
+        case 7863: ret=7862; break;
+        case 7865: ret=7864; break;
+        case 7867: ret=7866; break;
+        case 7869: ret=7868; break;
+        case 7871: ret=7870; break;
+        case 7873: ret=7872; break;
+        case 7875: ret=7874; break;
+        case 7877: ret=7876; break;
+        case 7879: ret=7878; break;
+        case 7881: ret=7880; break;
+        case 7883: ret=7882; break;
+        case 7885: ret=7884; break;
+        case 7887: ret=7886; break;
+        case 7889: ret=7888; break;
+        case 7891: ret=7890; break;
+        case 7893: ret=7892; break;
+        case 7895: ret=7894; break;
+        case 7897: ret=7896; break;
+        case 7899: ret=7898; break;
+        case 7901: ret=7900; break;
+        case 7903: ret=7902; break;
+        case 7905: ret=7904; break;
+        case 7907: ret=7906; break;
+        case 7909: ret=7908; break;
+        case 7911: ret=7910; break;
+        case 7913: ret=7912; break;
+        case 7915: ret=7914; break;
+        case 7917: ret=7916; break;
+        case 7919: ret=7918; break;
+        case 7921: ret=7920; break;
+        case 7923: ret=7922; break;
+        case 7925: ret=7924; break;
+        case 7927: ret=7926; break;
+        case 7929: ret=7928; break;
+        case 7936: ret=7944; break;
+        case 7937: ret=7945; break;
+        case 7938: ret=7946; break;
+        case 7939: ret=7947; break;
+        case 7940: ret=7948; break;
+        case 7941: ret=7949; break;
+        case 7942: ret=7950; break;
+        case 7943: ret=7951; break;
+        case 7952: ret=7960; break;
+        case 7953: ret=7961; break;
+        case 7954: ret=7962; break;
+        case 7955: ret=7963; break;
+        case 7956: ret=7964; break;
+        case 7957: ret=7965; break;
+        case 7968: ret=7976; break;
+        case 7969: ret=7977; break;
+        case 7970: ret=7978; break;
+        case 7971: ret=7979; break;
+        case 7972: ret=7980; break;
+        case 7973: ret=7981; break;
+        case 7974: ret=7982; break;
+        case 7975: ret=7983; break;
+        case 7984: ret=7992; break;
+        case 7985: ret=7993; break;
+        case 7986: ret=7994; break;
+        case 7987: ret=7995; break;
+        case 7988: ret=7996; break;
+        case 7989: ret=7997; break;
+        case 7990: ret=7998; break;
+        case 7991: ret=7999; break;
+        case 8000: ret=8008; break;
+        case 8001: ret=8009; break;
+        case 8002: ret=8010; break;
+        case 8003: ret=8011; break;
+        case 8004: ret=8012; break;
+        case 8005: ret=8013; break;
+        case 8017: ret=8025; break;
+        case 8019: ret=8027; break;
+        case 8021: ret=8029; break;
+        case 8023: ret=8031; break;
+        case 8032: ret=8040; break;
+        case 8033: ret=8041; break;
+        case 8034: ret=8042; break;
+        case 8035: ret=8043; break;
+        case 8036: ret=8044; break;
+        case 8037: ret=8045; break;
+        case 8038: ret=8046; break;
+        case 8039: ret=8047; break;
+        case 8048: ret=8122; break;
+        case 8049: ret=8123; break;
+        case 8050: ret=8136; break;
+        case 8051: ret=8137; break;
+        case 8052: ret=8138; break;
+        case 8053: ret=8139; break;
+        case 8054: ret=8154; break;
+        case 8055: ret=8155; break;
+        case 8056: ret=8184; break;
+        case 8057: ret=8185; break;
+        case 8058: ret=8170; break;
+        case 8059: ret=8171; break;
+        case 8060: ret=8186; break;
+        case 8061: ret=8187; break;
+        case 8064: ret=8072; break;
+        case 8065: ret=8073; break;
+        case 8066: ret=8074; break;
+        case 8067: ret=8075; break;
+        case 8068: ret=8076; break;
+        case 8069: ret=8077; break;
+        case 8070: ret=8078; break;
+        case 8071: ret=8079; break;
+        case 8080: ret=8088; break;
+        case 8081: ret=8089; break;
+        case 8082: ret=8090; break;
+        case 8083: ret=8091; break;
+        case 8084: ret=8092; break;
+        case 8085: ret=8093; break;
+        case 8086: ret=8094; break;
+        case 8087: ret=8095; break;
+        case 8096: ret=8104; break;
+        case 8097: ret=8105; break;
+        case 8098: ret=8106; break;
+        case 8099: ret=8107; break;
+        case 8100: ret=8108; break;
+        case 8101: ret=8109; break;
+        case 8102: ret=8110; break;
+        case 8103: ret=8111; break;
+        case 8112: ret=8120; break;
+        case 8113: ret=8121; break;
+        case 8115: ret=8124; break;
+        case 8131: ret=8140; break;
+        case 8144: ret=8152; break;
+        case 8145: ret=8153; break;
+        case 8160: ret=8168; break;
+        case 8161: ret=8169; break;
+        case 8165: ret=8172; break;
+        case 8179: ret=8188; break;
+        case 8560: ret=8544; break;
+        case 8561: ret=8545; break;
+        case 8562: ret=8546; break;
+        case 8563: ret=8547; break;
+        case 8564: ret=8548; break;
+        case 8565: ret=8549; break;
+        case 8566: ret=8550; break;
+        case 8567: ret=8551; break;
+        case 8568: ret=8552; break;
+        case 8569: ret=8553; break;
+        case 8570: ret=8554; break;
+        case 8571: ret=8555; break;
+        case 8572: ret=8556; break;
+        case 8573: ret=8557; break;
+        case 8574: ret=8558; break;
+        case 8575: ret=8559; break;
+        case 9424: ret=9398; break;
+        case 9425: ret=9399; break;
+        case 9426: ret=9400; break;
+        case 9427: ret=9401; break;
+        case 9428: ret=9402; break;
+        case 9429: ret=9403; break;
+        case 9430: ret=9404; break;
+        case 9431: ret=9405; break;
+        case 9432: ret=9406; break;
+        case 9433: ret=9407; break;
+        case 9434: ret=9408; break;
+        case 9435: ret=9409; break;
+        case 9436: ret=9410; break;
+        case 9437: ret=9411; break;
+        case 9438: ret=9412; break;
+        case 9439: ret=9413; break;
+        case 9440: ret=9414; break;
+        case 9441: ret=9415; break;
+        case 9442: ret=9416; break;
+        case 9443: ret=9417; break;
+        case 9444: ret=9418; break;
+        case 9445: ret=9419; break;
+        case 9446: ret=9420; break;
+        case 9447: ret=9421; break;
+        case 9448: ret=9422; break;
+        case 9449: ret=9423; break;
+        case 65345: ret=65313; break;
+        case 65346: ret=65314; break;
+        case 65347: ret=65315; break;
+        case 65348: ret=65316; break;
+        case 65349: ret=65317; break;
+        case 65350: ret=65318; break;
+        case 65351: ret=65319; break;
+        case 65352: ret=65320; break;
+        case 65353: ret=65321; break;
+        case 65354: ret=65322; break;
+        case 65355: ret=65323; break;
+        case 65356: ret=65324; break;
+        case 65357: ret=65325; break;
+        case 65358: ret=65326; break;
+        case 65359: ret=65327; break;
+        case 65360: ret=65328; break;
+        case 65361: ret=65329; break;
+        case 65362: ret=65330; break;
+        case 65363: ret=65331; break;
+        case 65364: ret=65332; break;
+        case 65365: ret=65333; break;
+        case 65366: ret=65334; break;
+        case 65367: ret=65335; break;
+        case 65368: ret=65336; break;
+        case 65369: ret=65337; break;
+        case 65370: ret=65338; break;
+        }
+        return (char)ret;
+      }
+      return Character.toUpperCase(c);
+    }
+    /** Convert a character to lower case. */
+    public static char toLowerCase(char c) {
+      if(java_1_0) {
+        int ret = (int)c;
+        switch(c) {
+        case 65: ret=97; break;
+        case 66: ret=98; break;
+        case 67: ret=99; break;
+        case 68: ret=100; break;
+        case 69: ret=101; break;
+        case 70: ret=102; break;
+        case 71: ret=103; break;
+        case 72: ret=104; break;
+        case 73: ret=105; break;
+        case 74: ret=106; break;
+        case 75: ret=107; break;
+        case 76: ret=108; break;
+        case 77: ret=109; break;
+        case 78: ret=110; break;
+        case 79: ret=111; break;
+        case 80: ret=112; break;
+        case 81: ret=113; break;
+        case 82: ret=114; break;
+        case 83: ret=115; break;
+        case 84: ret=116; break;
+        case 85: ret=117; break;
+        case 86: ret=118; break;
+        case 87: ret=119; break;
+        case 88: ret=120; break;
+        case 89: ret=121; break;
+        case 90: ret=122; break;
+        case 192: ret=224; break;
+        case 193: ret=225; break;
+        case 194: ret=226; break;
+        case 195: ret=227; break;
+        case 196: ret=228; break;
+        case 197: ret=229; break;
+        case 198: ret=230; break;
+        case 199: ret=231; break;
+        case 200: ret=232; break;
+        case 201: ret=233; break;
+        case 202: ret=234; break;
+        case 203: ret=235; break;
+        case 204: ret=236; break;
+        case 205: ret=237; break;
+        case 206: ret=238; break;
+        case 207: ret=239; break;
+        case 208: ret=240; break;
+        case 209: ret=241; break;
+        case 210: ret=242; break;
+        case 211: ret=243; break;
+        case 212: ret=244; break;
+        case 213: ret=245; break;
+        case 214: ret=246; break;
+        case 216: ret=248; break;
+        case 217: ret=249; break;
+        case 218: ret=250; break;
+        case 219: ret=251; break;
+        case 220: ret=252; break;
+        case 221: ret=253; break;
+        case 222: ret=254; break;
+        case 256: ret=257; break;
+        case 258: ret=259; break;
+        case 260: ret=261; break;
+        case 262: ret=263; break;
+        case 264: ret=265; break;
+        case 266: ret=267; break;
+        case 268: ret=269; break;
+        case 270: ret=271; break;
+        case 272: ret=273; break;
+        case 274: ret=275; break;
+        case 276: ret=277; break;
+        case 278: ret=279; break;
+        case 280: ret=281; break;
+        case 282: ret=283; break;
+        case 284: ret=285; break;
+        case 286: ret=287; break;
+        case 288: ret=289; break;
+        case 290: ret=291; break;
+        case 292: ret=293; break;
+        case 294: ret=295; break;
+        case 296: ret=297; break;
+        case 298: ret=299; break;
+        case 300: ret=301; break;
+        case 302: ret=303; break;
+        case 304: ret=105; break;
+        case 306: ret=307; break;
+        case 308: ret=309; break;
+        case 310: ret=311; break;
+        case 313: ret=314; break;
+        case 315: ret=316; break;
+        case 317: ret=318; break;
+        case 319: ret=320; break;
+        case 321: ret=322; break;
+        case 323: ret=324; break;
+        case 325: ret=326; break;
+        case 327: ret=328; break;
+        case 330: ret=331; break;
+        case 332: ret=333; break;
+        case 334: ret=335; break;
+        case 336: ret=337; break;
+        case 338: ret=339; break;
+        case 340: ret=341; break;
+        case 342: ret=343; break;
+        case 344: ret=345; break;
+        case 346: ret=347; break;
+        case 348: ret=349; break;
+        case 350: ret=351; break;
+        case 352: ret=353; break;
+        case 354: ret=355; break;
+        case 356: ret=357; break;
+        case 358: ret=359; break;
+        case 360: ret=361; break;
+        case 362: ret=363; break;
+        case 364: ret=365; break;
+        case 366: ret=367; break;
+        case 368: ret=369; break;
+        case 370: ret=371; break;
+        case 372: ret=373; break;
+        case 374: ret=375; break;
+        case 376: ret=255; break;
+        case 377: ret=378; break;
+        case 379: ret=380; break;
+        case 381: ret=382; break;
+        case 385: ret=595; break;
+        case 386: ret=387; break;
+        case 388: ret=389; break;
+        case 390: ret=596; break;
+        case 391: ret=392; break;
+        case 393: ret=598; break;
+        case 394: ret=599; break;
+        case 395: ret=396; break;
+        case 398: ret=600; break;
+        case 399: ret=601; break;
+        case 400: ret=603; break;
+        case 401: ret=402; break;
+        case 403: ret=608; break;
+        case 404: ret=611; break;
+        case 406: ret=617; break;
+        case 407: ret=616; break;
+        case 408: ret=409; break;
+        case 412: ret=623; break;
+        case 413: ret=626; break;
+        case 416: ret=417; break;
+        case 418: ret=419; break;
+        case 420: ret=421; break;
+        case 423: ret=424; break;
+        case 425: ret=643; break;
+        case 428: ret=429; break;
+        case 430: ret=648; break;
+        case 431: ret=432; break;
+        case 433: ret=650; break;
+        case 434: ret=651; break;
+        case 435: ret=436; break;
+        case 437: ret=438; break;
+        case 439: ret=658; break;
+        case 440: ret=441; break;
+        case 444: ret=445; break;
+        case 452: ret=454; break;
+        case 453: ret=454; break;
+        case 455: ret=457; break;
+        case 456: ret=457; break;
+        case 458: ret=460; break;
+        case 459: ret=460; break;
+        case 461: ret=462; break;
+        case 463: ret=464; break;
+        case 465: ret=466; break;
+        case 467: ret=468; break;
+        case 469: ret=470; break;
+        case 471: ret=472; break;
+        case 473: ret=474; break;
+        case 475: ret=476; break;
+        case 478: ret=479; break;
+        case 480: ret=481; break;
+        case 482: ret=483; break;
+        case 484: ret=485; break;
+        case 486: ret=487; break;
+        case 488: ret=489; break;
+        case 490: ret=491; break;
+        case 492: ret=493; break;
+        case 494: ret=495; break;
+        case 497: ret=499; break;
+        case 498: ret=499; break;
+        case 500: ret=501; break;
+        case 506: ret=507; break;
+        case 508: ret=509; break;
+        case 510: ret=511; break;
+        case 512: ret=513; break;
+        case 514: ret=515; break;
+        case 516: ret=517; break;
+        case 518: ret=519; break;
+        case 520: ret=521; break;
+        case 522: ret=523; break;
+        case 524: ret=525; break;
+        case 526: ret=527; break;
+        case 528: ret=529; break;
+        case 530: ret=531; break;
+        case 532: ret=533; break;
+        case 534: ret=535; break;
+        case 902: ret=940; break;
+        case 904: ret=941; break;
+        case 905: ret=942; break;
+        case 906: ret=943; break;
+        case 908: ret=972; break;
+        case 910: ret=973; break;
+        case 911: ret=974; break;
+        case 913: ret=945; break;
+        case 914: ret=946; break;
+        case 915: ret=947; break;
+        case 916: ret=948; break;
+        case 917: ret=949; break;
+        case 918: ret=950; break;
+        case 919: ret=951; break;
+        case 920: ret=952; break;
+        case 921: ret=953; break;
+        case 922: ret=954; break;
+        case 923: ret=955; break;
+        case 924: ret=956; break;
+        case 925: ret=957; break;
+        case 926: ret=958; break;
+        case 927: ret=959; break;
+        case 928: ret=960; break;
+        case 929: ret=961; break;
+        case 931: ret=963; break;
+        case 932: ret=964; break;
+        case 933: ret=965; break;
+        case 934: ret=966; break;
+        case 935: ret=967; break;
+        case 936: ret=968; break;
+        case 937: ret=969; break;
+        case 938: ret=970; break;
+        case 939: ret=971; break;
+        case 994: ret=995; break;
+        case 996: ret=997; break;
+        case 998: ret=999; break;
+        case 1000: ret=1001; break;
+        case 1002: ret=1003; break;
+        case 1004: ret=1005; break;
+        case 1006: ret=1007; break;
+        case 1025: ret=1105; break;
+        case 1026: ret=1106; break;
+        case 1027: ret=1107; break;
+        case 1028: ret=1108; break;
+        case 1029: ret=1109; break;
+        case 1030: ret=1110; break;
+        case 1031: ret=1111; break;
+        case 1032: ret=1112; break;
+        case 1033: ret=1113; break;
+        case 1034: ret=1114; break;
+        case 1035: ret=1115; break;
+        case 1036: ret=1116; break;
+        case 1038: ret=1118; break;
+        case 1039: ret=1119; break;
+        case 1040: ret=1072; break;
+        case 1041: ret=1073; break;
+        case 1042: ret=1074; break;
+        case 1043: ret=1075; break;
+        case 1044: ret=1076; break;
+        case 1045: ret=1077; break;
+        case 1046: ret=1078; break;
+        case 1047: ret=1079; break;
+        case 1048: ret=1080; break;
+        case 1049: ret=1081; break;
+        case 1050: ret=1082; break;
+        case 1051: ret=1083; break;
+        case 1052: ret=1084; break;
+        case 1053: ret=1085; break;
+        case 1054: ret=1086; break;
+        case 1055: ret=1087; break;
+        case 1056: ret=1088; break;
+        case 1057: ret=1089; break;
+        case 1058: ret=1090; break;
+        case 1059: ret=1091; break;
+        case 1060: ret=1092; break;
+        case 1061: ret=1093; break;
+        case 1062: ret=1094; break;
+        case 1063: ret=1095; break;
+        case 1064: ret=1096; break;
+        case 1065: ret=1097; break;
+        case 1066: ret=1098; break;
+        case 1067: ret=1099; break;
+        case 1068: ret=1100; break;
+        case 1069: ret=1101; break;
+        case 1070: ret=1102; break;
+        case 1071: ret=1103; break;
+        case 1120: ret=1121; break;
+        case 1122: ret=1123; break;
+        case 1124: ret=1125; break;
+        case 1126: ret=1127; break;
+        case 1128: ret=1129; break;
+        case 1130: ret=1131; break;
+        case 1132: ret=1133; break;
+        case 1134: ret=1135; break;
+        case 1136: ret=1137; break;
+        case 1138: ret=1139; break;
+        case 1140: ret=1141; break;
+        case 1142: ret=1143; break;
+        case 1144: ret=1145; break;
+        case 1146: ret=1147; break;
+        case 1148: ret=1149; break;
+        case 1150: ret=1151; break;
+        case 1152: ret=1153; break;
+        case 1168: ret=1169; break;
+        case 1170: ret=1171; break;
+        case 1172: ret=1173; break;
+        case 1174: ret=1175; break;
+        case 1176: ret=1177; break;
+        case 1178: ret=1179; break;
+        case 1180: ret=1181; break;
+        case 1182: ret=1183; break;
+        case 1184: ret=1185; break;
+        case 1186: ret=1187; break;
+        case 1188: ret=1189; break;
+        case 1190: ret=1191; break;
+        case 1192: ret=1193; break;
+        case 1194: ret=1195; break;
+        case 1196: ret=1197; break;
+        case 1198: ret=1199; break;
+        case 1200: ret=1201; break;
+        case 1202: ret=1203; break;
+        case 1204: ret=1205; break;
+        case 1206: ret=1207; break;
+        case 1208: ret=1209; break;
+        case 1210: ret=1211; break;
+        case 1212: ret=1213; break;
+        case 1214: ret=1215; break;
+        case 1217: ret=1218; break;
+        case 1219: ret=1220; break;
+        case 1223: ret=1224; break;
+        case 1227: ret=1228; break;
+        case 1232: ret=1233; break;
+        case 1234: ret=1235; break;
+        case 1236: ret=1237; break;
+        case 1238: ret=1239; break;
+        case 1240: ret=1241; break;
+        case 1242: ret=1243; break;
+        case 1244: ret=1245; break;
+        case 1246: ret=1247; break;
+        case 1248: ret=1249; break;
+        case 1250: ret=1251; break;
+        case 1252: ret=1253; break;
+        case 1254: ret=1255; break;
+        case 1256: ret=1257; break;
+        case 1258: ret=1259; break;
+        case 1262: ret=1263; break;
+        case 1264: ret=1265; break;
+        case 1266: ret=1267; break;
+        case 1268: ret=1269; break;
+        case 1272: ret=1273; break;
+        case 1329: ret=1377; break;
+        case 1330: ret=1378; break;
+        case 1331: ret=1379; break;
+        case 1332: ret=1380; break;
+        case 1333: ret=1381; break;
+        case 1334: ret=1382; break;
+        case 1335: ret=1383; break;
+        case 1336: ret=1384; break;
+        case 1337: ret=1385; break;
+        case 1338: ret=1386; break;
+        case 1339: ret=1387; break;
+        case 1340: ret=1388; break;
+        case 1341: ret=1389; break;
+        case 1342: ret=1390; break;
+        case 1343: ret=1391; break;
+        case 1344: ret=1392; break;
+        case 1345: ret=1393; break;
+        case 1346: ret=1394; break;
+        case 1347: ret=1395; break;
+        case 1348: ret=1396; break;
+        case 1349: ret=1397; break;
+        case 1350: ret=1398; break;
+        case 1351: ret=1399; break;
+        case 1352: ret=1400; break;
+        case 1353: ret=1401; break;
+        case 1354: ret=1402; break;
+        case 1355: ret=1403; break;
+        case 1356: ret=1404; break;
+        case 1357: ret=1405; break;
+        case 1358: ret=1406; break;
+        case 1359: ret=1407; break;
+        case 1360: ret=1408; break;
+        case 1361: ret=1409; break;
+        case 1362: ret=1410; break;
+        case 1363: ret=1411; break;
+        case 1364: ret=1412; break;
+        case 1365: ret=1413; break;
+        case 1366: ret=1414; break;
+        case 4256: ret=4304; break;
+        case 4257: ret=4305; break;
+        case 4258: ret=4306; break;
+        case 4259: ret=4307; break;
+        case 4260: ret=4308; break;
+        case 4261: ret=4309; break;
+        case 4262: ret=4310; break;
+        case 4263: ret=4311; break;
+        case 4264: ret=4312; break;
+        case 4265: ret=4313; break;
+        case 4266: ret=4314; break;
+        case 4267: ret=4315; break;
+        case 4268: ret=4316; break;
+        case 4269: ret=4317; break;
+        case 4270: ret=4318; break;
+        case 4271: ret=4319; break;
+        case 4272: ret=4320; break;
+        case 4273: ret=4321; break;
+        case 4274: ret=4322; break;
+        case 4275: ret=4323; break;
+        case 4276: ret=4324; break;
+        case 4277: ret=4325; break;
+        case 4278: ret=4326; break;
+        case 4279: ret=4327; break;
+        case 4280: ret=4328; break;
+        case 4281: ret=4329; break;
+        case 4282: ret=4330; break;
+        case 4283: ret=4331; break;
+        case 4284: ret=4332; break;
+        case 4285: ret=4333; break;
+        case 4286: ret=4334; break;
+        case 4287: ret=4335; break;
+        case 4288: ret=4336; break;
+        case 4289: ret=4337; break;
+        case 4290: ret=4338; break;
+        case 4291: ret=4339; break;
+        case 4292: ret=4340; break;
+        case 4293: ret=4341; break;
+        case 7680: ret=7681; break;
+        case 7682: ret=7683; break;
+        case 7684: ret=7685; break;
+        case 7686: ret=7687; break;
+        case 7688: ret=7689; break;
+        case 7690: ret=7691; break;
+        case 7692: ret=7693; break;
+        case 7694: ret=7695; break;
+        case 7696: ret=7697; break;
+        case 7698: ret=7699; break;
+        case 7700: ret=7701; break;
+        case 7702: ret=7703; break;
+        case 7704: ret=7705; break;
+        case 7706: ret=7707; break;
+        case 7708: ret=7709; break;
+        case 7710: ret=7711; break;
+        case 7712: ret=7713; break;
+        case 7714: ret=7715; break;
+        case 7716: ret=7717; break;
+        case 7718: ret=7719; break;
+        case 7720: ret=7721; break;
+        case 7722: ret=7723; break;
+        case 7724: ret=7725; break;
+        case 7726: ret=7727; break;
+        case 7728: ret=7729; break;
+        case 7730: ret=7731; break;
+        case 7732: ret=7733; break;
+        case 7734: ret=7735; break;
+        case 7736: ret=7737; break;
+        case 7738: ret=7739; break;
+        case 7740: ret=7741; break;
+        case 7742: ret=7743; break;
+        case 7744: ret=7745; break;
+        case 7746: ret=7747; break;
+        case 7748: ret=7749; break;
+        case 7750: ret=7751; break;
+        case 7752: ret=7753; break;
+        case 7754: ret=7755; break;
+        case 7756: ret=7757; break;
+        case 7758: ret=7759; break;
+        case 7760: ret=7761; break;
+        case 7762: ret=7763; break;
+        case 7764: ret=7765; break;
+        case 7766: ret=7767; break;
+        case 7768: ret=7769; break;
+        case 7770: ret=7771; break;
+        case 7772: ret=7773; break;
+        case 7774: ret=7775; break;
+        case 7776: ret=7777; break;
+        case 7778: ret=7779; break;
+        case 7780: ret=7781; break;
+        case 7782: ret=7783; break;
+        case 7784: ret=7785; break;
+        case 7786: ret=7787; break;
+        case 7788: ret=7789; break;
+        case 7790: ret=7791; break;
+        case 7792: ret=7793; break;
+        case 7794: ret=7795; break;
+        case 7796: ret=7797; break;
+        case 7798: ret=7799; break;
+        case 7800: ret=7801; break;
+        case 7802: ret=7803; break;
+        case 7804: ret=7805; break;
+        case 7806: ret=7807; break;
+        case 7808: ret=7809; break;
+        case 7810: ret=7811; break;
+        case 7812: ret=7813; break;
+        case 7814: ret=7815; break;
+        case 7816: ret=7817; break;
+        case 7818: ret=7819; break;
+        case 7820: ret=7821; break;
+        case 7822: ret=7823; break;
+        case 7824: ret=7825; break;
+        case 7826: ret=7827; break;
+        case 7828: ret=7829; break;
+        case 7840: ret=7841; break;
+        case 7842: ret=7843; break;
+        case 7844: ret=7845; break;
+        case 7846: ret=7847; break;
+        case 7848: ret=7849; break;
+        case 7850: ret=7851; break;
+        case 7852: ret=7853; break;
+        case 7854: ret=7855; break;
+        case 7856: ret=7857; break;
+        case 7858: ret=7859; break;
+        case 7860: ret=7861; break;
+        case 7862: ret=7863; break;
+        case 7864: ret=7865; break;
+        case 7866: ret=7867; break;
+        case 7868: ret=7869; break;
+        case 7870: ret=7871; break;
+        case 7872: ret=7873; break;
+        case 7874: ret=7875; break;
+        case 7876: ret=7877; break;
+        case 7878: ret=7879; break;
+        case 7880: ret=7881; break;
+        case 7882: ret=7883; break;
+        case 7884: ret=7885; break;
+        case 7886: ret=7887; break;
+        case 7888: ret=7889; break;
+        case 7890: ret=7891; break;
+        case 7892: ret=7893; break;
+        case 7894: ret=7895; break;
+        case 7896: ret=7897; break;
+        case 7898: ret=7899; break;
+        case 7900: ret=7901; break;
+        case 7902: ret=7903; break;
+        case 7904: ret=7905; break;
+        case 7906: ret=7907; break;
+        case 7908: ret=7909; break;
+        case 7910: ret=7911; break;
+        case 7912: ret=7913; break;
+        case 7914: ret=7915; break;
+        case 7916: ret=7917; break;
+        case 7918: ret=7919; break;
+        case 7920: ret=7921; break;
+        case 7922: ret=7923; break;
+        case 7924: ret=7925; break;
+        case 7926: ret=7927; break;
+        case 7928: ret=7929; break;
+        case 7944: ret=7936; break;
+        case 7945: ret=7937; break;
+        case 7946: ret=7938; break;
+        case 7947: ret=7939; break;
+        case 7948: ret=7940; break;
+        case 7949: ret=7941; break;
+        case 7950: ret=7942; break;
+        case 7951: ret=7943; break;
+        case 7960: ret=7952; break;
+        case 7961: ret=7953; break;
+        case 7962: ret=7954; break;
+        case 7963: ret=7955; break;
+        case 7964: ret=7956; break;
+        case 7965: ret=7957; break;
+        case 7976: ret=7968; break;
+        case 7977: ret=7969; break;
+        case 7978: ret=7970; break;
+        case 7979: ret=7971; break;
+        case 7980: ret=7972; break;
+        case 7981: ret=7973; break;
+        case 7982: ret=7974; break;
+        case 7983: ret=7975; break;
+        case 7992: ret=7984; break;
+        case 7993: ret=7985; break;
+        case 7994: ret=7986; break;
+        case 7995: ret=7987; break;
+        case 7996: ret=7988; break;
+        case 7997: ret=7989; break;
+        case 7998: ret=7990; break;
+        case 7999: ret=7991; break;
+        case 8008: ret=8000; break;
+        case 8009: ret=8001; break;
+        case 8010: ret=8002; break;
+        case 8011: ret=8003; break;
+        case 8012: ret=8004; break;
+        case 8013: ret=8005; break;
+        case 8025: ret=8017; break;
+        case 8027: ret=8019; break;
+        case 8029: ret=8021; break;
+        case 8031: ret=8023; break;
+        case 8040: ret=8032; break;
+        case 8041: ret=8033; break;
+        case 8042: ret=8034; break;
+        case 8043: ret=8035; break;
+        case 8044: ret=8036; break;
+        case 8045: ret=8037; break;
+        case 8046: ret=8038; break;
+        case 8047: ret=8039; break;
+        case 8072: ret=8064; break;
+        case 8073: ret=8065; break;
+        case 8074: ret=8066; break;
+        case 8075: ret=8067; break;
+        case 8076: ret=8068; break;
+        case 8077: ret=8069; break;
+        case 8078: ret=8070; break;
+        case 8079: ret=8071; break;
+        case 8088: ret=8080; break;
+        case 8089: ret=8081; break;
+        case 8090: ret=8082; break;
+        case 8091: ret=8083; break;
+        case 8092: ret=8084; break;
+        case 8093: ret=8085; break;
+        case 8094: ret=8086; break;
+        case 8095: ret=8087; break;
+        case 8104: ret=8096; break;
+        case 8105: ret=8097; break;
+        case 8106: ret=8098; break;
+        case 8107: ret=8099; break;
+        case 8108: ret=8100; break;
+        case 8109: ret=8101; break;
+        case 8110: ret=8102; break;
+        case 8111: ret=8103; break;
+        case 8120: ret=8112; break;
+        case 8121: ret=8113; break;
+        case 8122: ret=8048; break;
+        case 8123: ret=8049; break;
+        case 8124: ret=8115; break;
+        case 8136: ret=8050; break;
+        case 8137: ret=8051; break;
+        case 8138: ret=8052; break;
+        case 8139: ret=8053; break;
+        case 8140: ret=8131; break;
+        case 8152: ret=8144; break;
+        case 8153: ret=8145; break;
+        case 8154: ret=8054; break;
+        case 8155: ret=8055; break;
+        case 8168: ret=8160; break;
+        case 8169: ret=8161; break;
+        case 8170: ret=8058; break;
+        case 8171: ret=8059; break;
+        case 8172: ret=8165; break;
+        case 8184: ret=8056; break;
+        case 8185: ret=8057; break;
+        case 8186: ret=8060; break;
+        case 8187: ret=8061; break;
+        case 8188: ret=8179; break;
+        case 8544: ret=8560; break;
+        case 8545: ret=8561; break;
+        case 8546: ret=8562; break;
+        case 8547: ret=8563; break;
+        case 8548: ret=8564; break;
+        case 8549: ret=8565; break;
+        case 8550: ret=8566; break;
+        case 8551: ret=8567; break;
+        case 8552: ret=8568; break;
+        case 8553: ret=8569; break;
+        case 8554: ret=8570; break;
+        case 8555: ret=8571; break;
+        case 8556: ret=8572; break;
+        case 8557: ret=8573; break;
+        case 8558: ret=8574; break;
+        case 8559: ret=8575; break;
+        case 9398: ret=9424; break;
+        case 9399: ret=9425; break;
+        case 9400: ret=9426; break;
+        case 9401: ret=9427; break;
+        case 9402: ret=9428; break;
+        case 9403: ret=9429; break;
+        case 9404: ret=9430; break;
+        case 9405: ret=9431; break;
+        case 9406: ret=9432; break;
+        case 9407: ret=9433; break;
+        case 9408: ret=9434; break;
+        case 9409: ret=9435; break;
+        case 9410: ret=9436; break;
+        case 9411: ret=9437; break;
+        case 9412: ret=9438; break;
+        case 9413: ret=9439; break;
+        case 9414: ret=9440; break;
+        case 9415: ret=9441; break;
+        case 9416: ret=9442; break;
+        case 9417: ret=9443; break;
+        case 9418: ret=9444; break;
+        case 9419: ret=9445; break;
+        case 9420: ret=9446; break;
+        case 9421: ret=9447; break;
+        case 9422: ret=9448; break;
+        case 9423: ret=9449; break;
+        case 65313: ret=65345; break;
+        case 65314: ret=65346; break;
+        case 65315: ret=65347; break;
+        case 65316: ret=65348; break;
+        case 65317: ret=65349; break;
+        case 65318: ret=65350; break;
+        case 65319: ret=65351; break;
+        case 65320: ret=65352; break;
+        case 65321: ret=65353; break;
+        case 65322: ret=65354; break;
+        case 65323: ret=65355; break;
+        case 65324: ret=65356; break;
+        case 65325: ret=65357; break;
+        case 65326: ret=65358; break;
+        case 65327: ret=65359; break;
+        case 65328: ret=65360; break;
+        case 65329: ret=65361; break;
+        case 65330: ret=65362; break;
+        case 65331: ret=65363; break;
+        case 65332: ret=65364; break;
+        case 65333: ret=65365; break;
+        case 65334: ret=65366; break;
+        case 65335: ret=65367; break;
+        case 65336: ret=65368; break;
+        case 65337: ret=65369; break;
+        case 65338: ret=65370; break;
+        }
+        return (char)ret;
+      }
+      return Character.toLowerCase(c);
+    }
+    /** Convert a String to title case. */
+    public static String toTitleCase(String s) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=0;i<s.length();i++)
+            sb.append(CaseMgr.toTitleCase(s.charAt(i)));
+        return sb.toString();
+    }
+    /** Convert a String to upper case. */
+    public static String toUpperCase(String s) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=0;i<s.length();i++)
+            sb.append(CaseMgr.toUpperCase(s.charAt(i)));
+        return sb.toString();
+    }
+    /** Convert a String to lower case. */
+    public static String toLowerCase(String s) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=0;i<s.length();i++)
+            sb.append(CaseMgr.toLowerCase(s.charAt(i)));
+        return sb.toString();
+    }
+    /** Convert a character to title case.*/
+    public static char toTitleCase(char c) {
+      if(java_1_0) {
+        int ret = (int)toUpperCase(c);
+        switch(c) {
+        case 452: ret=453; break;
+        case 453: ret=453; break;
+        case 454: ret=453; break;
+        case 455: ret=456; break;
+        case 456: ret=456; break;
+        case 457: ret=456; break;
+        case 458: ret=459; break;
+        case 459: ret=459; break;
+        case 460: ret=459; break;
+        case 497: ret=498; break;
+        case 498: ret=498; break;
+        case 499: ret=498; break;
+        }
+        return (char)ret;
+      }
+      return Character.toTitleCase(c);
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( StringLike s1,
+        boolean ign,int i1,StringLike s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot>s2.length()||i1+i3>s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i<itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i<itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( String s1,
+        boolean ign,int i1,StringLike s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot>s2.length()||i1+i3>s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i<itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i<itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( StringLike s1,
+        boolean ign,int i1,String s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot>s2.length()||i1+i3>s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i<itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i<itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+    /** Duplicates the regionMatches routine of String -- but
+        makes use of the definitions of upper, lower, and title
+        case in this class when ignoreCase is set. */
+    public static boolean regionMatches( String s1,
+        boolean ign,int i1,String s2,int i2,int i3) {
+        int itot=i2+i3;
+        if(itot>s2.length()||i1+i3>s1.length()) return false;
+        if(!ign) {
+            for(int i=i2;i<itot;i++)
+                if(s2.charAt(i) != s1.charAt(i1++))
+                    return false;
+        } else {
+            for(int i=i2;i<itot;i++)
+                if(toLowerCase(s2.charAt(i)) != toLowerCase(s1.charAt(i1++)))
+                    return false;
+        }
+        return true;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/CaseMgr.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/ChangeRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/ChangeRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/ChangeRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/ChangeRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/ChangeRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class implements user defined special replacement rules
+  * of the form ${=name}. See <a href="http://javaregex.com/code/trans2.java.html">trans2.java</a>
+  * and <a href="http://javaregex.com/code/trans2a.java.html">trans2a.java</a>.
+  */
+public class ChangeRule extends SpecialRule {
+    Regex NewRule;
+    public ChangeRule(ChangeRule c) { NewRule=c.NewRule; }
+    public ChangeRule(String nm,Regex rr) { name=nm; NewRule = rr; }
+    public ChangeRule(String nm,Transformer tr) { name=nm; NewRule = tr.rp; }
+    public Object clone1() { return new ChangeRule(this); }
+    public String toString1() { return "${="+name+"}"; }
+    public void apply(StringBufferLike sb,RegRes rr) {}
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/ChangeRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/CodeRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/CodeRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/CodeRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/CodeRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/CodeRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,21 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** Implements the rules for \U, \L, \E, \Q in substitutions. */
+public final class CodeRule extends SpecialRule {
+    char c = 'E';
+    public CodeRule() {}
+    public CodeRule(char c) {
+        this.c = c;
+    }
+    public void apply(StringBufferLike sb,RegRes res) {
+      sb.setMode(c);
+    }
+    public String toString1() { return "\\"+c; }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/CodeRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/CodeVal.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/CodeVal.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Ctrl.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Ctrl.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Ctrl.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Ctrl.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Ctrl.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,269 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat;
+
+public class Ctrl {
+  public final static char[] cmap = {
+    (char)64,
+    (char)65,
+    (char)66,
+    (char)67,
+    (char)68,
+    (char)69,
+    (char)70,
+    (char)71,
+    (char)72,
+    (char)73,
+    (char)74,
+    (char)75,
+    (char)76,
+    (char)77,
+    (char)78,
+    (char)79,
+    (char)80,
+    (char)81,
+    (char)82,
+    (char)83,
+    (char)84,
+    (char)85,
+    (char)86,
+    (char)87,
+    (char)88,
+    (char)89,
+    (char)90,
+    (char)91,
+    (char)92,
+    (char)93,
+    (char)94,
+    (char)95,
+    (char)96,
+    (char)97,
+    (char)97,
+    (char)99,
+    (char)100,
+    (char)101,
+    (char)102,
+    (char)103,
+    (char)104,
+    (char)105,
+    (char)106,
+    (char)107,
+    (char)108,
+    (char)109,
+    (char)110,
+    (char)111,
+    (char)112,
+    (char)113,
+    (char)114,
+    (char)115,
+    (char)116,
+    (char)117,
+    (char)118,
+    (char)119,
+    (char)120,
+    (char)121,
+    (char)122,
+    (char)123,
+    (char)124,
+    (char)125,
+    (char)126,
+    (char)127,
+    (char)0,
+    (char)1,
+    (char)2,
+    (char)3,
+    (char)4,
+    (char)5,
+    (char)6,
+    (char)7,
+    (char)8,
+    (char)9,
+    (char)10,
+    (char)11,
+    (char)12,
+    (char)13,
+    (char)14,
+    (char)15,
+    (char)16,
+    (char)17,
+    (char)18,
+    (char)19,
+    (char)20,
+    (char)21,
+    (char)22,
+    (char)23,
+    (char)24,
+    (char)25,
+    (char)26,
+    (char)27,
+    (char)27,
+    (char)29,
+    (char)30,
+    (char)31,
+    (char)32,
+    (char)1,
+    (char)2,
+    (char)3,
+    (char)4,
+    (char)5,
+    (char)6,
+    (char)7,
+    (char)8,
+    (char)9,
+    (char)10,
+    (char)11,
+    (char)12,
+    (char)13,
+    (char)14,
+    (char)15,
+    (char)16,
+    (char)17,
+    (char)18,
+    (char)19,
+    (char)20,
+    (char)21,
+    (char)22,
+    (char)23,
+    (char)24,
+    (char)25,
+    (char)26,
+    (char)59,
+    (char)60,
+    (char)61,
+    (char)62,
+    (char)63,
+    (char)192,
+    (char)193,
+    (char)194,
+    (char)195,
+    (char)196,
+    (char)197,
+    (char)198,
+    (char)199,
+    (char)200,
+    (char)201,
+    (char)202,
+    (char)203,
+    (char)204,
+    (char)205,
+    (char)206,
+    (char)207,
+    (char)208,
+    (char)209,
+    (char)210,
+    (char)211,
+    (char)212,
+    (char)213,
+    (char)214,
+    (char)215,
+    (char)216,
+    (char)217,
+    (char)218,
+    (char)219,
+    (char)220,
+    (char)221,
+    (char)222,
+    (char)223,
+    (char)224,
+    (char)225,
+    (char)226,
+    (char)227,
+    (char)228,
+    (char)229,
+    (char)230,
+    (char)231,
+    (char)232,
+    (char)233,
+    (char)234,
+    (char)235,
+    (char)236,
+    (char)237,
+    (char)238,
+    (char)239,
+    (char)240,
+    (char)241,
+    (char)242,
+    (char)243,
+    (char)244,
+    (char)245,
+    (char)246,
+    (char)247,
+    (char)248,
+    (char)249,
+    (char)250,
+    (char)251,
+    (char)252,
+    (char)253,
+    (char)254,
+    (char)255,
+    (char)128,
+    (char)129,
+    (char)130,
+    (char)131,
+    (char)132,
+    (char)133,
+    (char)134,
+    (char)135,
+    (char)136,
+    (char)137,
+    (char)138,
+    (char)139,
+    (char)140,
+    (char)141,
+    (char)142,
+    (char)143,
+    (char)144,
+    (char)145,
+    (char)146,
+    (char)147,
+    (char)148,
+    (char)149,
+    (char)150,
+    (char)151,
+    (char)152,
+    (char)153,
+    (char)154,
+    (char)155,
+    (char)156,
+    (char)157,
+    (char)158,
+    (char)159,
+    (char)160,
+    (char)161,
+    (char)162,
+    (char)163,
+    (char)164,
+    (char)165,
+    (char)166,
+    (char)167,
+    (char)168,
+    (char)169,
+    (char)170,
+    (char)171,
+    (char)172,
+    (char)173,
+    (char)174,
+    (char)175,
+    (char)176,
+    (char)177,
+    (char)178,
+    (char)179,
+    (char)180,
+    (char)181,
+    (char)182,
+    (char)183,
+    (char)184,
+    (char)185,
+    (char)186,
+    (char)187,
+    (char)188,
+    (char)189,
+    (char)190,
+    (char)191
+  };
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Ctrl.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Custom.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Custom.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Custom.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Custom.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Custom.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,42 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Simple custom patterns.  See
+    <a href="http://javaregex.com/code/deriv2.java.html">deriv2.java</a>
+    and <a href="http://javaregex.com/code/deriv3.java.html">deriv3.java</a>
+    in the test directory.
+    @see com.stevesoft.ewe_pat.CustomEndpoint
+ */
+class Custom extends PatternSub {
+    String select;
+    Validator v;
+    int start;
+    Custom(String s) {
+        select = s;
+        v = (Validator)Regex.validators.get(s);
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        start = pos;
+        return sub.matchInternal(pos,pt);
+    }
+    public String toString() {
+        String a = v.argsave == null ? "" : ":"+v.argsave;
+        return "(??"+select+a+")"+nextString();
+    }
+    public patInt minChars() { return v.minChars(); }
+    public patInt maxChars() { return v.maxChars(); }
+    Pattern clone1(Hashtable h) {
+        Custom c = new Custom(select);
+        h.put(c,c);
+        h.put(this,c);
+        c.sub = sub.clone(h);
+        return c;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Custom.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,27 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** This class is needed internally to make backtracking work
+  * correctly in user-defined patterns.
+  */
+class CustomEndpoint extends Pattern {
+    Custom c;
+    CustomEndpoint(Custom cm) { c = cm; }
+    public int matchInternal(int pos,Pthings pt) {
+        int npos = c.v.validate(pt.src,c.start,pos);
+        if(npos >= 0) 
+            return nextMatch(npos,pt);
+        return -1;
+    }
+    public String toString() { return ""; }
+    Pattern clone1(Hashtable h) {
+        return new CustomEndpoint((Custom)c.clone(h));
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/CustomEndpoint.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,18 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class is just like FileRegex, except that its accept method
+ only returns true if the file matching the pattern is a directory.*/
+public class DirFileRegex extends FileRegex {
+    public DirFileRegex() { dirflag = DIR; }
+    public DirFileRegex(String fp) { super(fp); dirflag = DIR; }
+    public static String[] list(String f) {
+        return list(f,DIR);
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/DirFileRegex.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/DotMulti.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/DotMulti.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/DotMulti.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/DotMulti.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/DotMulti.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,125 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** A special optimization of multi that is used when the
+  * common subpattern ".*" is encountered.
+  */
+class DotMulti extends PatternSub {
+    patInt fewestMatches,mostMatches;
+    public patInt minChars() {
+        return fewestMatches;
+    }
+    public patInt maxChars() {
+        return mostMatches;
+    }
+    public boolean matchFewest = false;
+
+    StringLike src=null;
+    int srclength=0;
+    boolean dotDoesntMatchCR=true;
+    DotMulti(patInt a,patInt b) {
+        fewestMatches = a;
+        mostMatches = b;
+    }
+    public String toString() {
+        return ".{"
+            +fewestMatches+","+mostMatches+"}"+
+            (matchFewest ? "?" : "")+"(?# <= dot multi)"+
+            nextString();
+    }
+    final int submatchInternal(int pos,Pthings pt) {
+        if(pos < srclength) {
+            if(dotDoesntMatchCR) {
+                if(src.charAt(pos) != '\n')
+                    return 1+pos;
+            } else return 1+pos;
+        }
+        return -1;
+    }
+    final static int step = 1;
+    static int idcount = 1;
+    public int matchInternal(int pos,Pthings pt) {
+        int m=-1;
+        int i=pos;
+        src = pt.src;
+        srclength = src.length();
+        dotDoesntMatchCR = pt.dotDoesntMatchCR;
+        if(matchFewest) {
+            int nMatches = 0;
+            while(fewestMatches.intValue() > nMatches) {
+                i=submatchInternal(i,pt);
+                if(i<0) return -1;
+                nMatches++;
+            }
+            if(i<0) return -1;
+            int ii = nextMatch(i,pt);
+            if(ii >= 0) return ii;
+            if(!mostMatches.finite()) {
+                while(i >= 0) {
+                    i = submatchInternal(i,pt);
+                    if(i < 0) return -1;
+                    ii = nextMatch(i,pt);
+                    if(ii >= 0) return ii;
+                }
+            } else {
+                while(i > 0) {
+                    i = submatchInternal(i,pt);
+                    if(i < 0) return -1;
+                    nMatches++;
+                    if(nMatches > mostMatches.intValue())
+                        return -1;
+                    ii = nextMatch(i,pt);
+                    if(ii >= 0) return ii;
+                }
+            }
+            return -1;
+        }
+        int nMatches = 0;
+        while(fewestMatches.intValue() > nMatches) {
+            i=submatchInternal(i,pt);
+            if(i >= 0)
+                nMatches++;
+            else
+                return -1;
+        }
+        m=i;
+        if(mostMatches.finite()) {
+            while(nMatches < mostMatches.intValue()) {
+                i = submatchInternal(i,pt);
+                if(i>=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        } else {
+            while(true) {
+                i = submatchInternal(i,pt);
+                if(i>=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        }
+        while(m >= pos) {
+            int r=nextMatch(m,pt);
+            if(r >= 0) return r;
+            m -= step;
+            nMatches--;
+            if(nMatches < fewestMatches.intValue())
+                return -1;
+        }
+        return -1;
+    }
+    Pattern clone1(Hashtable h) {
+        DotMulti dm = new DotMulti(fewestMatches,mostMatches);
+        dm.matchFewest = matchFewest;
+        return dm;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/DotMulti.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/End.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/End.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/End.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/End.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/End.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,42 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+//class AddToEnd extends RegSyntax {};
+
+/** Compiles the '$' or the '\Z' Pattern.  It is
+ an error to have further Pattern elements after
+ '\Z'.  It is the end of the String. */
+class End extends Pattern {
+    boolean retIsEnd;
+    End(boolean b) { retIsEnd = b; }
+    public int matchInternal(int pos,Pthings pt) {
+        if(retIsEnd && pt.mFlag && pos < pt.src.length()) {
+            if(pt.src.charAt(pos)=='\n') {
+                return nextMatch(pos,pt);
+	    }
+	}
+        if(pt.src.length() == pos)
+            return nextMatch(pos,pt);
+	else if(pos<pt.src.length())
+	    // Access the next character...
+	    // this is crucial to making 
+	    // RegexReader work.
+	    pt.src.charAt(pos);
+        return -1;
+    }
+    public String toString() {
+        if(retIsEnd)
+            return "$";
+        else
+            return "\\Z";
+    }
+    public patInt maxChars() { return new patInt(1); }
+    public Pattern clone1(Hashtable h) { return new End(retIsEnd); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/End.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/FastBracket.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/FastBracket.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/FastBracket.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/FastBracket.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/FastBracket.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,191 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import ewe.util.*;
+
+/** Uses table lookup to match [] type constructs, but
+    only if it can use a lookup table 256 bits in size.
+    It is impractical to make a table if it is too large.
+    */
+public class FastBracket extends Bracket {
+    int min, max;
+    BitSet bs;
+    FastBracket(boolean n) { super(n); }
+    // This routine can optimize a bracket, possibly
+    // it will replace it with a FastBracket.
+    static Bracket process(Bracket b,boolean ignc) {
+        Vector v = b.v;
+        b.pv = null;
+        try {
+
+            // Expand out the vector to make separate
+            // entries for other cases if ignoreCase is
+            // turned on.
+            Vector nv = v;
+            if(ignc) {
+                nv = new Vector();
+                for(int i=0;i<v.size();i++) {
+                    Pattern p = (Pattern)v.elementAt(i);
+                    nv.addElement(p);
+                    if(p instanceof oneChar) {
+                        oneChar oc = (oneChar)p;
+                        nv.addElement(new oneChar(oc.altc));
+                    } else if(p instanceof Range) {
+                        Range ra = (Range)p;
+                        nv.addElement(new Range(ra.altlo,ra.althi));
+                    }
+                }
+            }
+            v = nv;
+
+            // Bubble sort, make sure elements
+            // are in order.  This will allow us
+            // to merge them.
+            for(int i=0;i<v.size()-1;i++) {
+                for(int j=0;j<v.size()-1;j++) {
+                    char c1 = getl(v.elementAt(j));
+                    char c2 = getl(v.elementAt(j+1));
+                    if(c2 < c1) {
+                        Object o = v.elementAt(j);
+                        v.setElementAt(v.elementAt(j+1),j);
+                        v.setElementAt(o,j+1);
+                    }
+                }
+            }
+
+            nv = new Vector();
+            // merge -- remove overlaps
+            Pattern p = (Pattern)v.elementAt(0);
+            nv.addElement(p);
+            for(int i=1;i<v.size();i++) {
+                if(geth(p)+1 >= getl(v.elementAt(i))) {
+                    Pattern p2 = (Pattern)v.elementAt(i);
+                    char lo = min(getl(p),getl(p2));
+                    char hi = max(geth(p),geth(p2));
+                    nv.setElementAt(p=mkelem(lo,hi),nv.size()-1);
+                } else {
+                    p = (Pattern)v.elementAt(i);
+                    nv.addElement(p);
+                }
+            }
+
+            b.v = v = nv;
+        } catch(RegSyntax e) {
+            e.printStackTrace();
+        }
+
+        // We don't want these things to be empty.
+        Vector negv = neg(v);
+        if(v.size()==1) return b;
+        if(negv.size()==1) {
+            b.v = negv;
+            b.neg = !b.neg;
+            return b;
+        }
+
+        // Now consider if we can make a FastBracket.
+        // Uses a BitSet to do a lookup.
+        FastBracket fb = newbrack(v,b.neg);
+        if(fb == null)
+            fb = newbrack(negv,!b.neg);
+        if(fb != null) {
+            fb.parent = b.parent;
+            fb.next = b.next;
+            return fb;
+        }
+
+        // return the normal Bracket.
+        return b;
+    }
+
+    // Build a FastBracket and set bits.  If this can't
+    // be done, return null.
+    final static FastBracket newbrack(Vector v,boolean neg) {
+        FastBracket fb = new FastBracket(neg);
+        fb.v = v;
+        if(v.size()==0) return null;
+        fb.min = getl(v.elementAt(0));
+        fb.max = geth(v.elementAt(v.size()-1));
+        if(fb.max-fb.min <= 256) {
+            fb.bs = new BitSet(fb.max-fb.min+1);
+            for(int i=0;i<v.size();i++) {
+                Object o = v.elementAt(i);
+                int min0 = getl(o)-fb.min;
+                int max0 = geth(o)-fb.min;
+                for(int j=min0;j<=max0;j++)
+                    fb.bs.set(j);
+            }
+            return fb;
+        }
+        return null;
+    }
+
+    // Negate a sorted Vector.  Applying this
+    // operation twice should yield the same Vector
+    // back.
+    final static Vector neg(Vector v) {
+        try {
+            Vector nv = new Vector();
+            if(v.size()==0) {
+                nv.addElement(new Range((char)0,(char)65535));
+                return nv;
+            }
+            int p0 = getl(v.elementAt(0));
+            if(p0!=0)
+                nv.addElement(mkelem((char)0,(char)(p0-1) ));
+            for(int i=0;i<v.size()-1;i++) {
+                int hi = getl(v.elementAt(i+1))-1;
+                int lo = geth(v.elementAt(i))+1;
+                nv.addElement(mkelem((char)lo,(char)hi));
+            }
+            int pN = geth(v.get(v.size()-1));
+            if(pN != 65535)
+                nv.addElement(mkelem((char)(pN+1),(char)65535));
+            return nv;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+    // Make either a Range or oneChar Object, depending on which
+    // is appropriate.
+    final static Pattern mkelem(char lo,char hi) throws RegSyntax {
+        return lo==hi ? (Pattern)(new oneChar(lo)) : (Pattern)(new Range(lo,hi));
+    }
+    static final char min(char a,char b) {
+        return a<b ? a : b;
+    }
+    static final char max(char a,char b) {
+        return a>b ? a : b;
+    }
+
+    // getl -- get lower value of Range object,
+    // or get value of oneChar object.
+    final static char getl(Object o) {
+        Pattern p = (Pattern)o;
+        if(p instanceof Range)
+            return ((Range)p).lo;
+        return ((oneChar)p).c;
+    }
+    // geth -- get higher value of Range object,
+    // or get value of oneChar object.
+    final static char geth(Object o) {
+        Pattern p = (Pattern)o;
+        if(p instanceof Range)
+            return ((Range)p).hi;
+        return ((oneChar)p).c;
+    }
+
+    // This is the easy part!
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos >= pt.src.length() || Masked(pos,pt)) return -1;
+        char c = pt.src.charAt(pos);
+        return (neg ^ (c >= min && c <= max && bs.get(c-min)) ) ?
+            nextMatch(pos+1,pt) : -1;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/FastBracket.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/FastChar.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/FastChar.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/FastMulti.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/FastMulti.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/FastMulti.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/FastMulti.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/FastMulti.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,111 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** A special case of Multi, implemented when minChars().equals(maxChars()),
+  * and some other conditions spelled out in RegOpt.safe4fm "Safe for
+  * FastMulti."  It avoids stack growth problems as well as being slightly
+  * faster.
+  */
+class FastMulti extends PatternSub {
+    patInt fewestMatches,mostMatches;
+    public patInt minChars() {
+        return sub.countMinChars().mul(fewestMatches);
+    }
+    public patInt maxChars() {
+        return sub.countMaxChars().mul(mostMatches);
+    }
+    public boolean matchFewest = false;
+
+    FastMulti(patInt a,patInt b,Pattern p) throws RegSyntax {
+        if(p == null) RegSyntaxError.endItAll("Null length pattern "+
+                "followed by *, +, or other Multi.");
+        fewestMatches = a;
+        mostMatches = b;
+        sub = p;
+        step = p.countMinChars().intValue();
+        sub.setParent(null);
+    }
+    public String toString() {
+        return sub.toString()+"{"
+            +fewestMatches+","+mostMatches+"}"+
+            (matchFewest ? "?" : "")+"(?# <= fast multi)"+
+            nextString();
+    }
+    int step = -1;
+    public int matchInternal(int pos,Pthings pt) {
+        int m=-1;
+        int i=pos;
+        int endstr = pt.src.length()-step;
+        patInt matches = new patInt(0);
+        if(matchFewest) {
+            if(fewestMatches.lessEq(matches)) {
+                int ii = nextMatch(i,pt);
+                if(ii >= 0) return ii;
+            }
+            while(i >= 0 && i <= endstr) {
+                i=sub.matchInternal(i,pt);
+                if(i >= 0) {
+                    matches.inc();
+                    if(fewestMatches.lessEq(matches)) {
+                        int ii = nextMatch(i,pt);
+                        if(ii >= 0) return ii;
+                    }
+                    if(matches.equals(mostMatches))
+                        return -1;
+                }
+            }
+            return -1;
+        }
+        int nMatches = 0;
+        while(fewestMatches.intValue() > nMatches) {
+            i=sub.matchInternal(i,pt);
+            if(i >= 0)
+                nMatches++;
+            else
+                return -1;
+        }
+        m=i;
+        if(mostMatches.finite()) {
+            while(nMatches < mostMatches.intValue()) {
+                i = sub.matchInternal(i,pt);
+                if(i>=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        } else {
+            while(true) {
+                i = sub.matchInternal(i,pt);
+                if(i>=0) {
+                    m=i;
+                    nMatches++;
+                } else break;
+            }
+        }
+        while(m >= pos) {
+            int r=nextMatch(m,pt);
+            if(r >= 0) return r;
+            m -= step;
+            nMatches--;
+            if(nMatches < fewestMatches.intValue())
+                return -1;
+        }
+        return -1;
+    }
+    public Pattern clone1(Hashtable h) {
+        try {
+            FastMulti fm = new FastMulti(fewestMatches,mostMatches,sub.clone(h));
+            fm.matchFewest = matchFewest;
+            return fm;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/FastMulti.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/FileRegex.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/FileRegex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/FileRegex.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/FileRegex.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/FileRegex.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,216 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import ewe.io.*;
+import ewe.util.*;
+
+/** This class is a different form of Regex designed to work more
+ like the file matching utility of a Unix shell.  It is implemented
+ by some simple string transformations:
+ <center>
+ <table border=1>
+ <tr> <td> FileRegex </td> <td> Regex </td>
+ <tr> <td> * </td><td> .* </td>
+ <tr> <td> . </td><td> \. </td>
+ <tr> <td> { </td><td> (?: </td>
+ <tr> <td> {?! </td><td> (?! </td>
+ <tr> <td> {?= </td><td> (?= </td>
+ <tr> <td> {?? </td><td> (?? </td>
+ <tr> <td> } </td><td> ) </td>
+ <tr> <td> ? </td><td> . </td>
+ <tr> <td> {,} </td><td> (|) </td>
+ </table>
+ </center>
+ Note that a FileRegex pattern always ends with the Regex
+ pattern element "$".  If you like to experiment, try making
+ FileRegex's and then printing them out.  The toString() method
+ does a decompile of the pattern to a standard Regex.  Here are
+ some more complete examples:
+ <center>
+ <table border=3>
+ <tr> <td> FileRegex </td><td> Regex </td>
+ <tr> <td>*.java </td><td> .*\.java$ </td>
+ <tr> <td>*.{java,html} </td><td> .*\.(java|html)$ </td>
+ <tr> <td> foo.[chC] </td><td> foo.[chC]$ </td>
+ </table>
+ </center>
+ */
+public class FileRegex extends Regex {
+    /** Build an unitialized FileRegex. */
+    public FileRegex() { dirflag=EITHER; }
+    /** Build a FileRegex form String s. */
+    public FileRegex(String s) {
+        super(s);
+        dirflag = EITHER;
+    }
+    /** Compile a new pattern.
+        Throws @exception com.stevesoft.pat.RegSyntax for
+        nonsensical patterns like "[9-0]+" just as Regex does.
+        @see com.stevesoft.pat#compile(java.lang.String)
+        */
+    public void compile(String s) throws RegSyntax {
+	String npat = toFileRegex(s);
+        super.compile(npat);
+        if(File.separatorChar == '\\') // MS-DOS
+            ignoreCase = true;
+    }
+    /** This is the method required by FileNameFilter.
+       To get a listing of files in the current directory
+         ending in .java, do this:
+        <pre>
+        File dot = new File(".");
+        FileRegex java_files = new FileRegex("*.java");
+        String[] file_list = dot.list(java_files);
+        </pre>
+        */
+    public boolean accept(File dir,String s) {
+        if(dirflag != EITHER) {
+            File f = new File(s);
+            if(f.isDirectory() && dirflag == NONDIR)
+                return false;
+            if(!f.isDirectory() && dirflag == DIR)
+                return false;
+        }
+        return matchAt(s,0);
+    }
+    int dirflag = 0;
+    final static int EITHER=0,DIR=1,NONDIR=2;
+
+    /** Provides an alternative to File.list -- this
+        separates its argument according to File.pathSeparator.
+        To each path, it splits off a directory -- all characters
+        up to and including the first instance of File.separator --
+        and a file pattern -- the part that comes after the directory.
+        It then produces a list of all the pattern matches on all
+        the paths.  Thus "*.java:../*.java" would produce a list of
+        all the java files in this directory and in the ".." directory
+        on a Unix machine.  "*.java;..\\*.java" would do the same thing
+        on a Dos machine. */
+    public static String[] list(String f) {
+        return list(f,EITHER);
+    }
+    static String[] list(String f,int df) {
+        //return list_(f,new FileRegex());
+        StringTokenizer st = new StringTokenizer(f,File.pathSeparator);
+        Vector v = new Vector();
+        while(st.hasMoreTokens()) {
+            String path = st.nextToken();
+            list1(path,v,df,true);
+        }
+        String[] sa = new String[v.size()];
+        v.copyInto(sa);
+        return sa;
+    }
+    final static Regex root=new Regex(File.separatorChar=='/' ?
+        "/$" : "(?:.:|)\\\\$");
+    static void list1(String path,Vector v,int df,boolean rec) {
+	// if path looks like a/b/c/ or d:\ then add .
+        if(root.matchAt(path,0)) {
+            v.addElement(path+".");
+            return;
+        }
+        File f = new File(path);
+        if(f.getParent() != null && rec) {
+            Vector v2 = new Vector();
+            list1(f.getParent(),v2,DIR,true);
+            for(int i=0;i<v2.size();i++) {
+                String path2 = ((String)v2.elementAt(i))+
+                    File.separator+f.getName();
+                list1(path2,v,df,false);
+            }
+        } else {
+            File base = new File(path);
+
+            String dir_s = base.getParent();
+            if(dir_s==null) dir_s=".";
+            File dir = new File(dir_s);
+
+            FileRegex fr = new FileRegex(base.getName());
+            if(fr.isLiteral()) {
+                v.addElement(dir_s+File.separator+base.getName());
+                return;
+            }
+            fr.dirflag = df;
+            String[] sa = dir.list(fr);
+            if(sa == null) return;
+            for(int i=0;i<sa.length;i++) {
+                v.addElement(dir_s+File.separator+sa[i]);
+            }
+        }
+    }
+
+    /** This method takes a file regular expression, and translates it
+            into the type of pattern used by a normal Regex. */
+    public static String toFileRegex(String s) {
+        StrPos sp = new StrPos(s,0);
+        StringBuffer sb = new StringBuffer();
+        if(sp.incMatch("{?e=")) {
+            char e = sp.thisChar();
+            sp.inc();
+            if(sp.incMatch("}")) {
+                sb.append("(?e="+e+")^");
+            } else {
+                sb.append("^(?e=");
+            }
+            sp.esc = e;
+        }
+        int ParenLvl = 0;
+        while(!sp.eos()) {
+	    if(File.separatorChar == '\\') {
+	      if(sp.escaped())
+	        sb.append("\\\\");
+	      sp.dontMatch = false;
+	    }
+            if(sp.incMatch("?"))
+                sb.append(".");
+            else if(sp.incMatch(".")) {
+                sb.append(sp.esc);
+                sb.append('.');
+            } else if(sp.incMatch("{??")) {
+                sb.append("(??");
+                ParenLvl++;
+                // allow negative lookahead to work
+            } else if(sp.incMatch("{?!")) {
+                sb.append("(?!");
+                ParenLvl++;
+                // allow positive lookahead to work
+            } else if(sp.incMatch("{?=")) {
+                sb.append("(?=");
+                ParenLvl++;
+            } else if(sp.incMatch("{")) {
+                sb.append("(?:");
+                ParenLvl++;
+            } else if(sp.incMatch("}")) {
+                sb.append(')');
+                ParenLvl--;
+            } else if(ParenLvl != 0 && sp.incMatch(","))
+                sb.append('|');
+            else if(sp.incMatch("*"))
+                sb.append(".*");
+            else {
+                sb.append(sp.thisChar());
+                sp.inc();
+            }
+        }
+        sb.append("$");
+        return sb.toString();
+    }
+    public boolean isLiteral() {
+        Pattern x = thePattern;
+        while(x != null && !(x instanceof End)) {
+            if(x instanceof oneChar)
+                ;
+            else if(x instanceof Skipped)
+                ;
+            else return false;
+            x = x.next;
+        }
+        return true;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/FileRegex.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Group.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Group.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Group.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Group.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Group.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,42 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** This class implements the (?@<>) syntax that matches
+ a balanced parenthesis.  Not in perl 5. */
+class Group extends Pattern {
+    char op,cl;
+    Group(char opi,char cli) {
+        op = opi;
+        cl = cli;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        int i,count=1;
+        if(pos < pt.src.length())
+            if(!Masked(pos,pt) && pt.src.charAt(pos) != op)
+                return -1;
+        for(i=pos+1;i<pt.src.length();i++) {
+            char c = pt.src.charAt(i);
+            boolean b = !Masked(i,pt);
+            if(b && c == ESC) {
+                i++;
+            } else {
+                if(b && c == cl) count--;
+                if(count == 0) return nextMatch(i+1,pt);
+                if(b && c == op) count++;
+            }
+        }
+        return -1;
+    }
+    public String toString() {
+        return "(?@"+op+cl+")"+nextString();
+    }
+    public patInt minChars() { return new patInt(2); }
+    Pattern clone1(Hashtable h) { return new Group(op,cl); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Group.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/LeftRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/LeftRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/LeftRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/LeftRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/LeftRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,21 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** The apply(StringBufferLike sb,RegRes res) method of this derivation
+    of ReplaceRule appends the contents of res.left() to the StringBuffer
+    sb.
+    @see com.stevesoft.ewe_pat.ReplaceRule
+    */
+public class LeftRule extends ReplaceRule {
+    public LeftRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(res.left());
+    }
+    public String toString1() { return "$`"; }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/LeftRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Multi.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Multi.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Multi.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Multi.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Multi.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,60 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Matches any number of instances of sub Pattern
+ this was the hardest method to write.  It implements
+ '+', '*', '?', "{0,10}", "{5,}", "{5}", etc.
+ @see pat.Multi_stage2
+ @see pat.MultiMin
+ */
+class Multi extends PatternSub {
+    patInt a,b;
+    public patInt minChars() { return a.mul(p.countMinChars()); }
+    public patInt maxChars() { return b.mul(p.countMaxChars()); }
+    Pattern p;
+    Multi_stage2 st2;
+    public boolean matchFewest = false;
+    /**
+        @param a The fewest number of times the sub pattern can match.
+        @param b The maximum number of times the sub pattern can match.
+        @param p The sub pattern.
+        @see Multi_stage2
+        @see MultiMin
+        */
+    public Multi(patInt a,patInt b,Pattern p) throws RegSyntax {
+        this.a = a;
+        this.b = b;
+        this.p = p;
+        st2 = new Multi_stage2(a,b,p);
+        st2.parent = this;
+        sub = st2.sub;
+    }
+    public String toString() {
+        st2.matchFewest = matchFewest;
+        return st2.toString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        try {
+            st2 = new Multi_stage2(a,b,p);
+        } catch(RegSyntax r__) {}
+        st2.matchFewest = matchFewest;
+        st2.parent = this;
+        return st2.matchInternal(pos,pt);
+    }
+    public Pattern clone1(Hashtable h) {
+        try {
+            Multi m = new Multi(a,b,((Pattern)p).clone(h));
+            m.matchFewest = matchFewest;
+            return m;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Multi.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/MultiMin.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/MultiMin.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/MultiMin.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/MultiMin.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/MultiMin.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,18 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This extension of multi is the version of multi
+ which wants to match the fewest number of characters.
+ It implements the *? type of syntax. */
+class MultiMin extends Multi {
+    MultiMin(patInt i1,patInt i2,Pattern p) throws RegSyntax {
+        super(i1,i2,p);
+        matchFewest = true;
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/MultiMin.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,103 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** If Multi were not split into a second stage, then
+ a nested Multi would try to re-use the same count
+ variable and the whole thing would break. */
+class Multi_stage2 extends PatternSub {
+    Pattern nextRet;
+    patInt count;
+    patInt matchMin,matchMax;
+    public boolean matchFewest = false;
+    public String toString() {
+        String ret = "";
+        ret += sub.toString();
+        ret += "{"+matchMin+","+matchMax+"}";
+        if(matchFewest) ret += "?";
+        ret += parent.nextString();
+        return ret;
+    }
+    Multi_stage2(patInt a,patInt b,Pattern p) throws RegSyntax {
+        if(p == null) RegSyntaxError.endItAll(
+                "Multiple match of Null pattern requested.");
+        sub = p;
+        nextRet = this;
+        sub.setParent(this);
+        matchMin = a;
+        matchMax = b;
+        count = new patInt(0);
+        // we must have b > a > -1 for this
+        // to make sense.
+        if(!a.lessEq(b))
+            //throw new BadMultiArgs();
+            RegSyntaxError.endItAll("Bad Multi Args: "+a+">"+b);
+        patInt i = new patInt(-1);
+        if(a.lessEq(i))
+            //throw new BadMultiArgs();
+            RegSyntaxError.endItAll("Bad Multi Args: "+a+"< 0");
+    }
+    public Pattern getNext() {
+        return nextRet;
+    }
+    int pos_old = -1;
+    public int matchInternal(int pos,Pthings pt) {
+        sub.setParent(this);
+
+        int canUse = -1;
+
+        // check for some forms of infinite recursion...
+        if(pos_old >= 0 && pos == pos_old) {
+            return -1;
+        }
+        pos_old = pos;
+
+        if(matchMin.lessEq(count))
+            canUse = pos;
+        if(!count.lessEq(matchMax) || pos > pt.src.length())
+            return -1;
+
+        if((matchFewest||count.equals(matchMax)) && canUse >= 0) {
+            Pattern n = super.getNext();
+            if(n == null)
+                return canUse;
+            int ret = testMatch(n,pos,pt);
+            if(ret >= 0) {
+               return ret;
+            }
+            else canUse = -1;
+        }
+
+        count.inc();
+        try {
+            if(count.lessEq(matchMax)) {
+                int r = testMatch(sub,pos,pt);
+                if(r >= 0)
+                    return r;
+            }
+        } finally { count.dec(); }
+
+        if(!matchFewest && canUse >= 0) {
+            Pattern n = super.getNext();
+            if(n == null)
+                return canUse;
+            int ret = testMatch(n,pos,pt);
+            return ret;
+        } else return canUse;
+    }
+    public Pattern clone1(Hashtable h) {
+        try {
+            Multi_stage2 m = new Multi_stage2(matchMin,matchMax,sub.clone(h));
+            m.matchFewest = matchFewest;
+            return m;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Multi_stage2.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/NUnicodeAlpha.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NUnicodeAlpha.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NUnicodeCurrency.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NUnicodeCurrency.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NUnicodeDigit.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NUnicodeDigit.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NUnicodeMath.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NUnicodeMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NUnicodePunct.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NUnicodePunct.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NUnicodeW.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NUnicodeW.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NUnicodeWhite.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NUnicodeWhite.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NoPattern.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NoPattern.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NoPattern.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/NoPattern.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/NoPattern.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,19 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat;
+import ewe.util.*;
+
+/** The idea behind this class is simply to eliminate the need for
+  * testing to see if Regex.thePattern is null.  Every instruction
+  * we can eliminate from _search will help.
+  */
+public class NoPattern extends Pattern {
+    public String toString() { return "(?e=#)[^#d#D]"; }
+    public int matchInternal(int i,Pthings p) { return -1; }
+    Pattern clone1(Hashtable h) { return new NoPattern(); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NoPattern.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,18 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class is just like FileRegex, except that its accept method
+ only returns true if the file matching the pattern is not a directory.*/
+public class NonDirFileRegex extends FileRegex {
+    public NonDirFileRegex() { dirflag = NONDIR; }
+    public NonDirFileRegex(String fp) { super(fp); dirflag = NONDIR; }
+    public static String[] list(String f) {
+        return list(f,NONDIR);
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NonDirFileRegex.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,14 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat;
+
+public class NotImplementedError extends Error {
+  public NotImplementedError(String s) {
+    super(s);
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NotImplementedError.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/NullPattern.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NullPattern.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NullPattern.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/NullPattern.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/NullPattern.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,21 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** This pattern matches nothing -- it is found in patterns
+  * like (hello|world|) where a zero-length subelement occurs.
+  */
+class NullPattern extends Pattern {
+    public String toString() { return nextString(); }
+    public int matchInternal(int p,Pthings pt) {
+        return nextMatch(p,pt);
+    }
+    public patInt maxChars() { return new patInt(0); }
+    Pattern clone1(Hashtable h) { return new NullPattern(); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NullPattern.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/NullRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NullRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/NullRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/NullRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/NullRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,19 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** The apply(StringBufferLike sb,RegRes res) method of this derivation
+    of ReplaceRule appends nothing to the contents of the StringBuffer sb.
+    @see com.stevesoft.ewe_pat.ReplaceRule
+    */
+public class NullRule extends ReplaceRule {
+    public NullRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+    }
+    public String toString1() { return ""; }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/NullRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Or.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Or.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Or.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Or.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Or.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,81 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import ewe.util.*;
+
+/** This class implements the (?: ... ) extended Pattern.
+ It provides a base class from which we derive the
+ [ ... ], ( ... ), (?! ... ), and (?= ... ) patterns. */
+class Or extends Pattern {
+    Vector v;
+    Pattern[] pv = null;
+    Or() { v = new Vector(); }
+    String leftForm() { return "(?:"; }
+    String rightForm() { return ")"; }
+    String sepForm() { return "|"; }
+    public Or addOr(Pattern p) {
+        pv = null;
+        v.addElement(p);
+        p.setParent(this);
+        return this;
+    }
+    public String toString() {
+        int i;
+        StringBuffer sb = new StringBuffer();
+        sb.append(leftForm());
+        if(v.size()>0)
+            sb.append( ((Pattern)v.elementAt(0)).toString() );
+        for(i=1;i<v.size();i++) {
+            sb.append(sepForm());
+            sb.append( ((Pattern)v.elementAt(i)).toString() );
+        }
+        sb.append(rightForm());
+        sb.append(nextString());
+        return sb.toString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pv == null) {
+            pv = new Pattern[v.size()];
+            v.copyInto(pv);
+        }
+        for(int i=0;i<v.size();i++) {
+            Pattern p = pv[i];//(Pattern)v.elementAt(i);
+            int r = p.matchInternal(pos,pt);
+            if(r >= 0)
+                return r;
+        }
+        return -1;
+    }
+    public patInt minChars() {
+        if(v.size()==0) return new patInt(0);
+        patInt m = ((Pattern)v.elementAt(0)).countMinChars();
+        for(int i=1;i<v.size();i++) {
+            Pattern p = (Pattern)v.elementAt(i);
+            m.mineq(p.countMinChars());
+        }
+        return m;
+    }
+    public patInt maxChars() {
+        if(v.size()==0) return new patInt(0);
+        patInt m = ((Pattern)v.elementAt(0)).countMaxChars();
+        for(int i=1;i<v.size();i++) {
+            Pattern p = (Pattern)v.elementAt(i);
+            m.maxeq(p.countMaxChars());
+        }
+        return m;
+    }
+    Pattern clone1(Hashtable h) {
+        Or o=new Or();
+        h.put(this,o);
+        h.put(o,o);
+        for(int i=0;i<v.size();i++)
+            o.v.addElement( ((Pattern)v.elementAt(i)).clone(h) );
+        return o;
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Or.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/OrMark.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/OrMark.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/OrMark.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/OrMark.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/OrMark.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,50 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Implements the parenthesis pattern subelement.*/
+class OrMark extends Or {
+    SubMark sm = new SubMark();
+    int id;
+    OrMark(int i) {
+        sm.om = this;
+        id = i;
+    }
+    String leftForm() { return "("; }
+    public Pattern getNext() {
+        return sm;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        sm.next = super.getNext();
+        if(pt.marks == null) {
+            int n2 = 2 * pt.nMarks+2;
+            pt.marks = new int[n2];
+            for(int i=0;i<n2;i++)
+                pt.marks[i] = -1;
+        }
+        pt.marks[id] = pos;
+        int ret = super.matchInternal(pos,pt);
+        if(ret < 0)
+            pt.marks[id] = -1;
+        else if(pt.marks[id] > pt.marks[id+pt.nMarks]) {
+            int swap = pt.marks[id];
+            pt.marks[id] = pt.marks[id+pt.nMarks]+1;
+            pt.marks[id+pt.nMarks] = swap+1;
+        }
+        return ret;
+    }
+    public Pattern clone1(Hashtable h) {
+        OrMark om = new OrMark(id);
+        h.put(om,om);
+        h.put(this,om);
+        for(int i=0;i<v.size();i++)
+            om.v.addElement( ((Pattern)v.elementAt(i)).clone(h) );
+        return om;
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/OrMark.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,82 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class allows you to match on a partial string.
+    If the allowOverRun flag is true, then the
+    length() method returns a number 1 larger than
+    is actually contained by the class.
+    <p>
+    If one attempts to access the last character as
+    follows:
+    <pre>
+    StringBuffer sb = ...;
+    ...
+    PartialBuffer pb = new PartialBuffer(sb);
+    char c = pb.charAt(pb.length()-1);
+    </pre>
+    then two things happen.  First, a zero is returned
+    into the variable c.  Second, the overRun flag is
+    set to "true."  Accessing data beyond the end of
+    the buffer is considered an "overRun" of the data.
+    <p>
+    This can be helpful in determining whether more
+    characters are required for a match to occur, as
+    the pseudo-code below illustrates.
+    <pre>
+    int i = ...;
+    Regex r = new Regex("some pattern");
+    pb.allowOverRun = true;
+    pb.overRun = true;
+    boolean result = r.matchAt(pb,i);
+    if(pb.overRun) {
+      // The result of the match is not relevant, regardless
+      // of whether result is true or false.  We need to
+      // append more data to the buffer and try again.
+      ....
+      sb.append(more data);
+    }
+    </pre>
+    */
+class PartialBuffer implements StringLike {
+  int off;
+  public boolean allowOverRun = true;
+  public boolean overRun = false;
+  StringBuffer sb;
+  PartialBuffer(StringBuffer sb) {
+    this.sb = sb;
+  }
+  public char charAt(int n) {
+    n += off;
+    if(n == sb.length()) {
+      overRun = true;
+      return 0;
+    }
+    return sb.charAt(n);
+  }
+  public int length() {
+    return allowOverRun ? sb.length()+1 : sb.length();
+  }
+  public int indexOf(char c) {
+    for(int i=0;i<sb.length();i++)
+      if(sb.charAt(i)==c)
+        return i;
+    return -1;
+  }
+  public Object unwrap() { return sb; }
+  public String substring(int i1,int i2) {
+    StringBuffer sb = new StringBuffer(i2-i1);
+    for(int i=i1;i<i2;i++)
+      sb.append(charAt(i));
+    return sb.toString();
+  }
+  /** Just returns null. */
+  public BasicStringBufferLike newStringBufferLike() {
+    return null;
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PartialBuffer.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Pattern.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Pattern.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Pattern.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Pattern.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Pattern.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,193 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.*;
+/**
+        Shareware: package pat
+   <a href="copyright.html">Copyright 2001, Steven R. Brandt</a>
+*/ /**
+Class Pattern is the base class on which all the other pattern
+elements are built. */
+
+public abstract class Pattern {
+    /** The ESC character, the user can provide his own value
+            for the escape character through regex.esc */
+    public final static char ESC = '\\';
+    final static String PROTECT_THESE = "[]{}(),$,-\"^.";
+
+    /** The interal match function, it must be provided by any
+        class which wishes to extend Pattern. */
+    public abstract int matchInternal(int i,Pthings p);
+    public abstract String toString();
+
+    // Class Pattern is a singly linked list
+    // chained together by member next.  The member
+    // parent is used so that sub patterns can access
+    // the chain they are branching from.
+    Pattern next=null,parent=null;
+
+    /** This gets the next element of a Pattern that
+            we wish to match.  If we are at the end of a
+            subchain of patterns, it will return us to the
+            parent chain. */
+    public Pattern getNext() {
+        return next != null ? next :
+        (parent == null ? null : parent.getNext());
+    }
+    /** Call this method if you have a pattern element that
+            takes a sub pattern (such as Or), and
+            after you have added a sub pattern to the current
+            pattern element. */
+    public void setParent(Pattern p) {
+        if(next != null) next.setParent(p);
+        else parent = p;
+    }
+    /** This determines if the remainder of a Pattern
+            matches.  Type "return nextMatch" from within
+            matchInternal if the current
+            Pattern matches.  Otherwise, return a -1.*/
+    public int nextMatch(int i,Pthings pt) {
+        Pattern p = getNext();
+        /*if(p == null) return i;
+                return p.matchInternal(i,pt);*/
+        return p==null ? i : p.matchInternal(i,pt);
+    }
+    /** This is a toString() for the remainder
+            of the Pattern elements after this one.
+            use this when overriding toString(). Called from
+            within toString(). */
+    public String nextString() {
+        if(next == null) return "";
+        return next.toString();
+    }
+
+    /** a method to detect whether char c is in String s */
+    final static boolean inString(char c,String s) {
+        int i;
+        for(i=0;i<s.length();i++)
+            if(s.charAt(i)==c)
+                return true;
+        return false;
+    }
+
+    /** A method to create a string that protects the characters
+            listed in PROTECT_THESE by prepending the esc character.
+            The esc character itself is automatically protected. */
+    final static
+        String protect(String s,String PROTECT_THESE,char esc) {
+        int i;
+        StringBuffer sb = new StringBuffer();
+        String p = PROTECT_THESE+esc;
+        for(i=0;i<s.length();i++) {
+            char c = s.charAt(i);
+            if(inString(c,p))
+                sb.append(esc);
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+
+    /** This can be used to perform a match test from
+            within class Pattern. */
+    public int match(StringLike s,Pthings pt) {
+        return matchAt(s,0,pt);
+    }
+    /** This can be used to perform a match test from
+            within class Pattern. */
+    public int matchAt(StringLike s,int i,Pthings pt) {
+        pt.src = s;
+        int r = matchInternal(i,pt);
+        if(r < 0) return -1;
+        mfrom = r<i ? r+1 : i;
+        return r<i ? i-r-1 : r-i;
+    }
+    int mfrom=0;
+
+    // Detect masked characters
+    final boolean Masked(int i,Pthings pt) {
+        return pt.cbits == null ? false : pt.cbits.get(i);
+    }
+
+    /** add a Pattern to the singly-linked Pattern chain. */
+    public Pattern add(Pattern p) {
+        if(next == null) {
+            if(p==null) return this;
+            next = p;
+            p.parent = parent;
+            parent = null;
+        } else next.add(p);
+        return this;
+    }
+    /** The minimum number of characters which
+        this pattern element can match. */
+    public patInt minChars() { return new patInt(0); }
+    /** The maximum number of characters which
+        this pattern element can match. */
+    public patInt maxChars() { return new patInf(); }
+    /** return minimum number of characters in pattern */
+    public final patInt countMinChars() {
+        Pattern p = this;
+        patInt sum = new patInt(0);
+        while(p != null) {
+            sum.pluseq(p.minChars());
+            p = p.next;
+        }
+        return sum;
+    }
+    /** return maximum number of characters in pattern */
+    public final patInt countMaxChars() {
+        Pattern p = this;
+        patInt sum = new patInt(0);
+        while(p != null) {
+            sum.pluseq(p.maxChars());
+            p = p.next;
+        }
+        return sum;
+    }
+
+    // This method is only needed by Multi_stage2 so far...
+    // the reason is that it may try something else after a
+    // match succeeds.  OrMark will only record the last thing
+    // tried in marks, so we need to backup the result of the
+    // last successful match and restore it if the next one
+    // does not succeed.
+    final int testMatch(Pattern p,int pos,Pthings pt) {
+        int[] tab = null;
+        if(pt.marks != null) try {
+                tab = new int[pt.marks.length];
+                for(int i=0;i<tab.length;i++)
+                    tab[i] = pt.marks[i];
+            } catch(Throwable t) {}
+        int ret = p.matchInternal(pos,pt);
+        if(ret < 0) pt.marks = tab;
+        return ret;
+    }
+
+    /** Clones this pattern elements without cloning others in the
+        linked list. */
+    Pattern clone1(Hashtable h) {
+        throw new Error("No such method as clone1 for "+getClass().getName());
+    }
+    Pattern clone(Hashtable h) {
+        Pattern p = (Pattern)h.get(this);
+        if(p != null) {
+            return p;
+        }
+        p=clone1(h);
+        if(p==null)throw new Error("Null from clone1!");
+        h.put(this,p);
+        h.put(p,p);
+        if(next != null) p.next = next.clone(h);
+        if(parent != null) p.parent = parent.clone(h);
+        return p;
+    }
+    public boolean equals(Object o) {
+        return o == this;
+    }
+};
+


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Pattern.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/PatternSub.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PatternSub.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/PatternSub.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/PatternSub.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/PatternSub.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,15 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This is simply a subclass of pattern that
+  * contains a sub pattern.
+  */
+abstract class PatternSub extends Pattern {
+    Pattern sub;
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PatternSub.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/PopRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PopRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/PopRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/PopRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/PopRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,16 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** Implements substitution rule $POP. See the example
+  * file <a href="http://javaregex.com/code/trans3.java.html">trans3.html</a>.
+  */
+public class PopRule extends SpecialRule {
+    public PopRule() {}
+    public String toString1() { return "${POP}"; }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PopRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Prop.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Prop.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Prop.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Prop.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Prop.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,52 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** Get Unicode properties for a character.  See
+<a href="http://unicode.org">http://unicode.org</a>. */
+public class Prop {
+    /** Is this a "Decimal Digit" according to Unicode? */
+    public final static boolean isDecimalDigit(char c) {
+      if(Bits.decimal_digit == null)
+        Bits.decimal_digit_f();
+      return Bits.decimal_digit.get(c);
+    }
+    /** Is this a "Alphabetic" according to Unicode? */
+    public final static boolean isAlphabetic(char c) {
+      if(Bits.letter == null)
+        Bits.letter_f();
+      return Bits.letter.get(c);
+    }
+    /** Is this a "Math" according to Unicode? */
+    public final static boolean isMath(char c) {
+      if(Bits.math == null)
+        Bits.math_f();
+      return Bits.math.get(c);
+    }
+
+    /** Is this a "Currency" according to Unicode? */
+    public final static boolean isCurrency(char c) {
+      if(Bits.currency == null)
+        Bits.currency_f();
+      return Bits.currency.get(c);
+    }
+
+    /** Is c a white space character according to Unicode? */
+    public final static boolean isWhite(char c) {
+      if(Bits.white == null)
+        Bits.white_f();
+      return Bits.white.get(c);
+    }
+
+    /** Is c a punctuation character according to Unicode? */
+    public final static boolean isPunct(char c) {
+      if(Bits.punct == null)
+        Bits.punct_f();
+      return Bits.punct.get(c);
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Prop.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Pthings.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Pthings.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Pthings.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Pthings.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Pthings.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,32 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** 
+Things that need to be kept track of during a
+ match.  Passed along with Pattern.matchInternal. */
+public class Pthings {
+    /** The current text we are attempting to match. */
+    public StringLike src;
+    /** Whether we should ignore the case of letters in
+        this match. */
+    public boolean ignoreCase;
+    public boolean mFlag;
+    /** The mask to use when dontMatchInQuotes is set. */
+    public BitSet cbits;
+    /** Used to keep track of backreferences. */
+    //public Hashtable marks;
+    public int[] marks;
+    public int nMarks;
+    /** Used to set the behavior of "."  By default, it
+        now fails to match the '\n' character. */
+    public boolean dotDoesntMatchCR;
+    /** Determine if Skipped strings need to be checked. */
+    public boolean no_check;
+    int lastPos;
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Pthings.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/PushRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PushRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/PushRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/PushRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/PushRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** See the example file
+    <a href="http://javaregex.com/code/trans3.java.html">trans3.java</a> for
+    further examples of how this is used.  You will probably not
+    want to call it directly. */
+public class PushRule extends SpecialRule {
+    Regex NewRule;
+    public PushRule(PushRule p) { NewRule = p.NewRule; }
+    public PushRule(String nm,Regex rr) { name=nm; NewRule = rr; }
+    public PushRule(String nm,Transformer tr) { name = nm; NewRule = tr.rp; }
+    public Object clone1() { return new PushRule(this); }
+    public String String1() { return "${+"+name+"}"; }
+    public void apply(StringBufferLike sbl,RegRes rr) {}
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/PushRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RBuffer.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RBuffer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RBuffer.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RBuffer.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RBuffer.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,33 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class is used internally by RegexReader to
+    store blocks of data. */
+class RBuffer {
+  boolean done = false;
+  StringBuffer sb;
+  int pos,epos;
+  RBuffer next;
+  RBuffer() {}
+  RBuffer(StringBuffer sb) { this.sb = sb; }
+  public String toString() {
+    return "sb="+sb.toString().replace('\n',' ')+
+      " pos="+pos+" epos="+epos+
+      " sb.length()="+sb.length()+
+      "\n"+sp(pos+3)+"^"+sp(epos-pos-1)+"^";
+  }
+  String sp(int n) {
+    if(n<=0)
+      return "";
+    StringBuffer sb = new StringBuffer(n);
+    for(int i=0;i<n;i++)
+      sb.append(' ');
+    return sb.toString();
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RBuffer.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Range.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Range.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Range.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Range.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Range.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,61 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Thrown when one encounters things like [z-a] */
+class BadRangeArgs extends RegSyntax {};
+
+/** Implments a subelement (ranges) of the [] pattern element.
+For example, [a-z023] is implemented using a range and tree oneChar
+classes.
+ at see Bracket
+ at see oneChar
+*/
+class Range extends Pattern {
+    char lo,hi,altlo,althi;
+    boolean printBrackets = false;
+    public String toString() {
+        String s=protect(""+lo,PROTECT_THESE,ESC)+"-"
+            +protect(""+hi,PROTECT_THESE,ESC);
+        if(!printBrackets)
+            return s;
+        return "["+s+"]";
+    }
+    Range(char loi,char hii) throws RegSyntax {
+        lo = loi; hi = hii;
+        oneChar o = null;
+        if(lo >= hi)
+            //throw new BadRangeArgs();
+            RegSyntaxError.endItAll("Badly formed []'s : "+lo+" >= "+hi);
+        o = new oneChar(lo);
+        altlo = o.altc;
+        o = new oneChar(hi);
+        althi = o.altc;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos >= pt.src.length()) return -1;
+        if(Masked(pos,pt)) return -1;
+        char c = pt.src.charAt(pos);
+        if(lo <= c && c <= hi ||
+                (pt.ignoreCase && (altlo <= c && c <= althi)))
+            return nextMatch(pos+1,pt);
+        return -1;
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    public Pattern clone1(Hashtable h) {
+        try {
+            Range r = new Range(lo,hi);
+            r.printBrackets = printBrackets;
+            return r;
+        } catch(RegSyntax rs) {
+            return null;
+        }
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Range.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RegHolder.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegHolder.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegOpt.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegOpt.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegOpt.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RegOpt.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RegOpt.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,337 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+/** This class is just like oneChar, but doesn't worry about case. */
+class FastChar extends oneChar {
+    FastChar(char c) { super(c); }
+    public int matchInternal(int p,Pthings pt) {
+        return (p < pt.src.length()
+            && pt.src.charAt(p)==c) ?
+            nextMatch(p+1,pt) : -1;
+    }
+    Pattern clone1(Hashtable h) {
+        return new FastChar(c);
+    }
+}
+
+/** This class is a hashtable keyed by Character
+  * Objects.  It is used to match things of the
+  * form (?:a..|b..|c..|..) match with greater efficiency --
+  * by using a Hashtable that indexes into the group
+  * of patterns.
+  */
+class Branch extends Pattern {
+    Hashtable h = new Hashtable();
+    // We need to keep track of the order
+    // of the keys -- if we don't then
+    // recompiling the output of toString
+    // may produce errors by re-ordering
+    // ()'s and changing the id number of
+    // the backreference associated with
+    // a subpattern.
+    Vector keys = new Vector();
+    Branch() {}
+    Pattern clone1(Hashtable x) {
+        Branch b = new Branch();
+        b.keys = (Vector)keys.getCopy();
+        x.put(this,b);
+        x.put(b,b);
+
+        for(int i=0;i<keys.size();i++) {
+            Pattern p = (Pattern)h.get(keys.elementAt(i));
+            b.h.put(keys.elementAt(i),p.clone(x));
+        }
+        return b;
+    }
+
+    // this function eliminates Branches with 0 or 1 elements.
+    final Pattern reduce(boolean ignoreCase,boolean dontMinQ) {
+        if(h.size()==1) {
+            Enumeration e = h.keys();
+            Character c = (Character)e.nextElement();
+            Pattern oc;
+            if(ignoreCase||dontMinQ)
+                oc=new oneChar(c.charValue());
+            else oc=new FastChar(c.charValue());
+            oc.next = (Pattern)h.get(c);
+            oc.add(next);
+            return oc;
+        } else if(h.size()==0) return null;
+        return this;
+    }
+    public patInt maxChars() {
+        Enumeration e = h.keys();
+        patInt count = new patInt(0);
+        while(e.hasMoreElements()) {
+            Object key = e.nextElement();
+            Pattern pa = (Pattern)h.get(key);
+            patInt pi = pa.maxChars();
+            pi.inc();
+            count.maxeq(pi);
+        }
+        return count;
+    }
+    public patInt minChars() {
+        Enumeration e = h.keys();
+        patInt count = new patInt(0);
+        while(e.hasMoreElements()) {
+            Object key = e.nextElement();
+            Pattern pa = (Pattern)h.get(key);
+            patInt pi = pa.minChars();
+            pi.inc();
+            count.mineq(pi);
+        }
+        return count;
+    }
+
+    // adds a oneChar object to this Branch
+    void addc(oneChar o,boolean ignoreCase,boolean dontMinQ) {
+        Pattern n = o.next;
+        if(n == null)
+            n = new NullPattern();
+        else
+            n = RegOpt.opt(n,ignoreCase,dontMinQ);
+        n.setParent(this);
+        set(new Character(o.c),n,ignoreCase,dontMinQ);
+        if(ignoreCase) {
+            if(o.c != o.altc)
+                set(new Character(o.altc),n,ignoreCase,dontMinQ);
+            if(o.c != o.altc2 && o.altc != o.altc2)
+                set(new Character(o.altc2),n,ignoreCase,dontMinQ);
+        }
+    }
+    void set(Character c,Pattern n,boolean igc,boolean dontMinQ) {
+        Pattern p = (Pattern)h.get(c);
+        next = null;
+        // This letter is not yet used in the Branch object.
+        // We need to add it.
+        if(p==null) {
+            if(n instanceof Or) {
+                // A NullPattern is prepended to an Or
+                // to prevent confusing this object.
+                // For example: (boo|bug) => (b(?:oo|ug))
+                // during this process.  However, we
+                // want (b(?:oo|ell)|bug)
+                NullPattern np = new NullPattern();
+                np.add(n);
+                h.put(c,np);
+            } else {
+                h.put(c,n);
+            }
+            // Make sure we remember the order things were
+            // added into the Branch object so that we can
+            // properly convert it to a String.
+            keys.addElement(c);
+        } else if(p instanceof Or) {
+            ((Or)p).addOr(n);
+        } else if(p instanceof oneChar && n instanceof oneChar
+                && ((oneChar)p).c != ((oneChar)n).c) {
+            Branch b = new Branch();
+            b.addc((oneChar)p,igc,dontMinQ);
+            b.addc((oneChar)n,igc,dontMinQ);
+            h.put(c,b);
+            b.setParent(this);
+        } else if(p instanceof Branch && n instanceof oneChar) {
+            ((Branch)p).addc((oneChar)n,igc,dontMinQ);
+            n.setParent(p);
+        } else {
+            // Create an Or object to receive the variety
+            // of branches in the pattern if the current letter
+            // is matched.  We do not attempt to make these
+            // sub-branches into a Branch object yet.
+            Or o = new Or();
+            o.setParent(this);
+
+            // Remove NullPattern from p -- it's no longer needed.
+            if(p instanceof NullPattern
+                    && p.parent == null && p.next != null) {
+                o.addOr(p.next);
+            } else {
+                o.addOr(p);
+            }
+            o.addOr(n);
+
+            Pattern optpat = RegOpt.opt(o,igc,dontMinQ);
+            h.put(c,optpat);
+            optpat.setParent(this);
+        }
+    }
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        // should protect this...
+        sb.append("(?:(?#branch)");// Hashtable)");
+        for(int i=0;i<keys.size();i++) {
+            Character c = (Character)keys.elementAt(i);
+            sb.append(c);
+            sb.append(h.get(c));
+            if(i+1<keys.size())
+                sb.append("|");
+        }
+        sb.append(")");
+        sb.append(nextString());
+        return sb.toString();
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(pos >= pt.src.length()) return -1;
+        Pattern n = (Pattern)h.get(new Character(pt.src.charAt(pos)));
+        if(n == null) return -1;
+        if(pt.cbits != null && pt.cbits.get(pos)) return -1;
+        return n.matchInternal(pos+1,pt);
+    }
+}
+
+/** This is just a place to put the optimizing function.
+    It is never instantiated as an Object.  It just sorts
+    through the RegOpt looking for things it can change
+    and make faster. */
+public class RegOpt {
+    static Pattern opt(Pattern p,boolean ignoreCase,
+        boolean dontMinQ) {
+        if(p == null) return p;
+        if(p instanceof Bracket) {
+            Bracket b = (Bracket)p;
+            // FastBracket is the only special
+            // optimized class to have its own
+            // source file.
+            p = FastBracket.process(b,ignoreCase);
+            //if(!(p instanceof FastBracket)
+            //p = Switch.process(b,ignoreCase);
+            p.next = b.next;
+            p.parent = b.parent;
+        } else if(p instanceof oneChar && !ignoreCase
+                && !dontMinQ) {
+            oneChar o = (oneChar)p;
+            p = new FastChar(o.c);
+            p.next = o.next;
+            p.parent = o.parent;
+        } else if(p instanceof Or
+                && ((Or)p).leftForm().equals("(?:")
+                && ((Or)p).v.size()==1) { // Eliminate this Or Object.
+            Or o = (Or)p;
+            p = (Pattern)o.v.elementAt(0);
+            p.setParent(null);
+            p = RegOpt.opt(p,ignoreCase,dontMinQ);
+            p.add(o.next);
+        } else if(p instanceof Or) {
+            Or o = (Or)p;
+            o.pv = null;
+            Vector v = o.v;
+            o.v = new Vector();
+            Branch b = new Branch();
+            b.parent = o.parent;
+            for(int i=0;i<v.size();i++) {
+                Pattern pp = (Pattern)v.elementAt(i);
+                // We want to have at least two oneChar's in
+                // the Or Object to consider making a Branch.
+                if(pp instanceof oneChar && (b.h.size()>=1 ||
+                        (i+1<v.size() && v.elementAt(i+1) instanceof oneChar)))
+                    b.addc((oneChar)pp,ignoreCase,dontMinQ);
+                else {
+                    if(b.keys.size() > 0) {
+                        Pattern p2 = (Pattern)b.reduce(ignoreCase,dontMinQ);
+                        if(p2 != null) {
+                            o.addOr(p2);
+                            b = new Branch();
+                            b.parent = o.parent;
+                        }
+                    }
+                    o.addOr(opt(pp,ignoreCase,dontMinQ));
+                }
+            }
+            if(b.keys.size()>0) {
+                Pattern p2=(Pattern)b.reduce(ignoreCase,dontMinQ);
+                if(p2 != null)
+                    o.addOr(p2);
+            }
+            if(o.v.size()==1
+                    && o.leftForm().equals("(?:")) { // Eliminate Or Object
+                p = (Pattern)o.v.elementAt(0);
+                p.setParent(null);
+                p = RegOpt.opt(p,ignoreCase,dontMinQ);
+                p.add(o.next);
+            }
+        } else if(p instanceof FastMulti) {
+            PatternSub ps = (PatternSub)p;
+            ps.sub = RegOpt.opt(ps.sub,ignoreCase,dontMinQ);
+        } else if(p instanceof Multi && safe4fm( ((PatternSub)p).sub )) {
+            Multi m = (Multi)p;
+            FastMulti fm = null;
+            try {
+                fm = new FastMulti(m.a,m.b,
+                    opt(m.sub,ignoreCase,dontMinQ));
+            } catch(RegSyntax rs) {}
+            fm.parent = m.parent;
+            fm.matchFewest = m.matchFewest;
+            fm.next = m.next;
+            p = fm;
+        }
+        if(p.next != null)
+            p.next = opt(p.next,ignoreCase,dontMinQ);
+        return p;
+    }
+    final static boolean safe4fm(Pattern x) {
+        while(x != null) {
+            if(x instanceof Bracket)
+                ;
+            else if(x instanceof Range)
+                ;
+            else if(x instanceof oneChar)
+                ;
+            else if(x instanceof Any)
+                ;
+            else if(x instanceof Custom
+                    && ((Custom)x).v instanceof UniValidator)
+                ;
+            else if(x instanceof Or) {
+                Or o = (Or)x;
+                if(!o.leftForm().equals("(?:"))
+                    return false;
+                patInt lo = o.countMinChars();
+                patInt hi = o.countMaxChars();
+                if(!lo.equals(hi))
+                    return false;
+                for(int i=0;i<o.v.size();i++)
+                    if(!safe4fm((Pattern)o.v.elementAt(i)) )
+                        return false;
+            } else return false;
+            x = x.next;
+        }
+        return true;
+    }
+    /*
+    public static void setParents(Regex r) {
+      setParents(r.thePattern,null);
+    }
+    static void setParents(Pattern p,Pattern x) {
+      if(p instanceof PatternSub && !(p instanceof FastMulti)
+      && !(p instanceof DotMulti))
+        RegOpt.setParents( ((PatternSub)p).sub, p);
+      else if(p instanceof Or && !(p instanceof Bracket)) {
+        Or o = (Or)p;
+        for(int i=0;i<o.v.size();i++)
+          RegOpt.setParents((Pattern)o.v.elementAt(i),o);
+      } else if(p instanceof Branch) {
+        Branch b = (Branch)p;
+        Enumeration e = b.h.keys();
+        while(e.hasMoreElements()) {
+          Object o = e.nextElement();
+          RegOpt.setParents( (Pattern)b.h.get(o), b);
+        }
+      }
+      if(p.next == null)
+        p.parent = x;
+      else {
+        p.parent = null;
+        RegOpt.setParents(p.next,x);
+      }
+    }*/
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegOpt.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RegRes.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegRes.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegRes.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RegRes.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RegRes.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,165 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** 
+        Shareware: package pat
+   <a href="copyright.html">Copyright 2001, Steven R. Brandt</a>
+*/ /**
+This class is used to store a result from Regex */
+public class RegRes implements Cloneable {
+    protected int[] marks = null;
+    protected boolean didMatch_ = false;
+    protected StringLike src=null;
+
+    /** Obtain the text String that was matched against. */
+    public String getString() { return src.toString(); }
+    /** Obtain the source StringLike object. */
+    public StringLike getStringLike() { return src; }
+    protected int charsMatched_=0,matchFrom_=0,numSubs_=0;
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append("match="+matchedFrom()+":"+charsMatched());
+        if(!didMatch()) return sb.toString();
+        for(int i=0;i<numSubs();i++) {
+            int n = i + 1;
+            sb.append(" sub("+n+")="+matchedFrom(n)+
+                ":"+charsMatched(n));
+        }
+        return sb.toString();
+    }
+    public RegRes() {}
+    public RegRes(RegRes r) {
+      copyOutOf(r);
+    }
+    public void copyOutOf(RegRes r) {
+        if(r.marks == null)
+            marks = null;
+        else try {
+                //marks = (Hashtable)r.marks.clone();
+                marks = new int[r.marks.length];
+                for(int i=0;i<marks.length;i++)
+                    marks[i]=r.marks[i];
+                //marks = (int[])r.marks.clone();
+            } catch (Throwable t) {}
+        didMatch_ = r.didMatch_;
+        src = r.src;
+        charsMatched_ = r.charsMatched_;
+        matchFrom_ = r.matchFrom_;
+        numSubs_ = r.numSubs_;
+    }
+    public Object clone() { return new RegRes(this); }
+    public boolean equals(RegRes r) {
+        if(charsMatched_!=r.charsMatched_
+                || matchFrom_   !=r.matchFrom_
+                || didMatch_    !=r.didMatch_
+                || numSubs_     !=r.numSubs_
+                || !src.unwrap().equals(r.src.unwrap()))
+            return false;
+        if(marks==null && r.marks!=null)
+            return false;
+        if(marks!=null && r.marks==null)
+            return false;
+        for(int i=1;i<=numSubs_;i++) {
+            if(matchedFrom(i) != r.matchedFrom(i))
+                return false;
+            else if(charsMatched(i) != r.charsMatched(i))
+                return false;
+        }
+        return true;
+    }
+    /** Obtains the match if successful, null otherwise.*/
+    public String stringMatched() {
+        int mf=matchedFrom(), cm = charsMatched();
+        return !didMatch_ || mf<0 || cm<0 ? null :
+        src.substring(mf,mf+cm);
+    }
+    /** Obtains the position backreference number i begins to match, or
+         -1 if backreference i was not matched. */
+    public int matchedFrom(int i) {
+        if(marks==null||i>numSubs_) return -1;
+        //Integer in=(Integer)marks.get("left"+i);
+        //return in == null ? -1 : in.intValue();
+        return marks[i];
+    }
+    /** Obtains the number of characters matched by backreference i, or
+         -1 if backreference i was not matched. */
+    public int charsMatched(int i) {
+        if(marks==null||i>numSubs_||!didMatch_) return -1;
+        //Integer in = (Integer)marks.get("right"+i);
+        //int i2 = in==null ? -1 : in.intValue();
+        int mf = matchedFrom(i);
+        return mf < 0 ? -1 : marks[i+numSubs_]-matchedFrom(i);
+    }
+    /** This is either equal to matchedFrom(i)+charsMatched(i) if the match
+        was successful, or -1 if it was not. */
+    public int matchedTo(int i) {
+        if(marks==null||i>numSubs_||!didMatch_) return -1;
+        return marks[i+numSubs_];
+    }
+    /** Obtains a substring matching the nth set
+                of parenthesis from the pattern. See
+                numSubs(void), or null if the nth backrefence did
+                not match. */
+    public String stringMatched(int i) {
+        int mf = matchedFrom(i), cm = charsMatched(i);
+        return !didMatch_ || mf<0 || cm<0 ? null :
+        src.substring(mf,mf+cm);
+    }
+    /** This returns the part of the string that preceeds the match,
+         or null if the match failed.*/
+    public String left() {
+        int mf = matchedFrom();
+        return !didMatch_ || (mf<0) ? null : src.substring(0,mf);
+    }
+    /** This returns the part of the string that follows the ith
+                backreference, or null if the backreference did not match. */
+    public String left(int i) {
+        int mf = matchedFrom(i);
+        return !didMatch_ || (mf<0) ? null : src.substring(0,mf);
+    }
+    /** This returns the part of the string that follows the match,
+         or null if the backreference did not match.*/
+    public String right() {
+        int mf = matchedFrom(), cm = charsMatched();
+        return !didMatch_ || mf<0 || cm<0 ? null : src.substring(mf+
+            cm,src.length());
+    }
+    /** This returns the string to the right of the ith backreference,
+         or null if the backreference did not match. */
+    public String right(int i) {
+        int mf = matchedFrom(i), cm = charsMatched(i);
+        return !didMatch_ || mf<0 || cm<0 ? null :
+        src.substring(mf+cm,src.length());
+    }
+    /** After a successful match, this returns the location of
+                the first matching character, or -1 if the match failed.*/
+    public int matchedFrom() { return !didMatch_ ? -1 : matchFrom_; }
+    /** After a successful match, this returns the number of
+                characters in the match, or -1 if the match failed. */
+    public int charsMatched() { return !didMatch_||matchFrom_<0 ? -1 : charsMatched_; }
+    /** This is matchedFrom()+charsMatched() after a successful match,
+        or -1 otherwise. */
+    public int matchedTo() { return !didMatch_ ? -1 : matchFrom_+charsMatched_;}
+    /** This returns the number of
+                backreferences (parenthesis) in the pattern,
+                i.e. the pattern "(ab)" has
+                one, the pattern "(a)(b)" has two, etc. */
+    public int numSubs() { return numSubs_; }
+    /** Contains true if the last match was successful. */
+    public boolean didMatch() { return didMatch_; }
+
+    /** An older name for matchedFrom. */
+    public int matchFrom() { return matchedFrom(); }
+    /** An older name for stringMatched(). */
+    public String substring() { return stringMatched(); }
+    /** An older name for matchedFrom. */
+    public int matchFrom(int i) { return matchedFrom(i); }
+    /** An older name for stringMatched. */
+    public String substring(int i) { return stringMatched(i); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegRes.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RegSyntax.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegSyntax.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegSyntax.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RegSyntax.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RegSyntax.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,24 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/*
+        Shareware: package pat
+   <a href="copyright.html">Copyright 2001, Steven R. Brandt</a>
+*/
+/**
+This type of syntax error is thrown whenever a syntax error
+ is encountered in the pattern. It may not be caught directly, as
+ it is not in the throws clause of any method.  To detect it, catch
+ Throwable, and use instanceof to see if it is a RegSyntax. */
+public class RegSyntax extends Exception {
+    RegSyntax() {}
+    RegSyntax(String msg) {
+        super(msg);
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegSyntax.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,29 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** When enabled, this class is thrown instead of
+    the normal RegSyntax.  Thus, enabling of this
+    class will make your debugging easier -- but
+    if you leave it on and forget to catch RegSyntaxError
+    a user-supplied pattern could generate a
+    RegSyntaxError that will kill your application.
+
+    I strongly recommend turning this flag on, however,
+    as I think it is more likely to help than to hurt
+    your programming efforts.
+    */
+public class RegSyntaxError extends Error {
+    public static boolean RegSyntaxErrorEnabled = false;
+    public RegSyntaxError() {}
+    public RegSyntaxError(String s) { super(s); }
+    final static void endItAll(String s) throws RegSyntax {
+        if(RegSyntaxErrorEnabled) throw new RegSyntaxError(s);
+        throw new RegSyntax(s);
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegSyntaxError.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Regex.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Regex.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Regex.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Regex.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Regex.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,1430 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.*;
+import ewe.io.*;
+
+import com.stevesoft.ewe_pat.wrap.StringWrap;
+
+
+/** Matches a Unicode punctuation character. */
+class UnicodePunct extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && Prop.isPunct(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode white space character. */
+class UnicodeWhite extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && Prop.isWhite(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a character that is not a Unicode punctuation
+  * character.
+  */
+class NUnicodePunct extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && !Prop.isPunct(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a character that is not a
+  * Unicode white space character.
+  */
+class NUnicodeWhite extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && !Prop.isWhite(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode word character: an alphanumeric or underscore. */
+class UnicodeW extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        if(from >= s.length()) return -1;
+        char c = s.charAt(from);
+        return (Prop.isAlphabetic(c)||Prop.isDecimalDigit(c)||c=='_') ? to : -1;
+    }
+}
+
+/** Matches a character that is not a Unicode alphanumeric or underscore. */
+class NUnicodeW extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        if(from >= s.length()) return -1;
+        char c = s.charAt(from);
+        return !(Prop.isAlphabetic(c)||Prop.isDecimalDigit(c)||c=='_') ? to : -1;
+    }
+}
+
+/** Matches a Unicode decimal digit. */
+class UnicodeDigit extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && Prop.isDecimalDigit(s.charAt(from)) ? to : -1;
+    }
+}
+/** Matches a character that is not a Unicode digit.*/
+class NUnicodeDigit extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && !Prop.isDecimalDigit(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode math character. */
+class UnicodeMath extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && Prop.isMath(s.charAt(from)) ? to : -1;
+    }
+}
+/** Matches a non-math Unicode character. */
+class NUnicodeMath extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && !Prop.isMath(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode currency symbol. */
+class UnicodeCurrency extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && Prop.isCurrency(s.charAt(from)) ? to : -1;
+    }
+}
+/** Matches a non-currency symbol Unicode character. */
+class NUnicodeCurrency extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && !Prop.isCurrency(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a Unicode alphabetic character. */
+class UnicodeAlpha extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && Prop.isAlphabetic(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches a non-alphabetic Unicode character. */
+class NUnicodeAlpha extends UniValidator {
+    public int validate(StringLike s,int from,int to) {
+        return from<s.length() && !Prop.isAlphabetic(s.charAt(from)) ? to : -1;
+    }
+}
+
+/** Matches an upper case Unicode character. */
+class UnicodeUpper extends UniValidator {
+  public int validate(StringLike s,int from,int to) {
+    return from<s.length() && isUpper(s.charAt(from)) ? to : -1;
+  }
+  final boolean isUpper(char c) {
+    return c == CaseMgr.toUpperCase(c) && c != CaseMgr.toLowerCase(c);
+  }
+}
+
+/** Matches an upper case Unicode character. */
+class UnicodeLower extends UniValidator {
+  public int validate(StringLike s,int from,int to) {
+    return from<s.length() && isLower(s.charAt(from)) ? to : -1;
+  }
+  final boolean isLower(char c) {
+    return c != CaseMgr.toUpperCase(c) && c == CaseMgr.toLowerCase(c);
+  }
+}
+
+/**
+Regex provides the parser which constructs the linked list of
+Pattern classes from a String.
+<p>
+For the purpose of this documentation, the fact that java interprets the
+backslash will be ignored.  In practice, however, you will need a
+double backslash to obtain a string that contains a single backslash
+character.  Thus, the example pattern "\b" should really be typed
+as "\\b" inside java code.
+<p>
+Note that Regex is part of package "com.stevesoft.pat".
+To use it, simply import
+com.stevesoft.pat.Regex at the top of your file.
+<p>
+Regex is made with a constructor that takes a String that defines
+the regular expression.  Thus, for example
+<pre>
+      Regex r = new Regex("[a-c]*");
+</pre>
+matches any number of characters so long as the are 'a', 'b', or 'c').
+<p>
+To attempt to match the Pattern to a given string, you can use either
+the search(String) member function, or the matchAt(String,int position)
+member function.  These functions return a boolean which tells you
+whether or not the thing worked, and sets the methods "charsMatched()"
+and "matchedFrom()" in the Regex object appropriately.
+<p>
+The portion of the string before the match can be obtained by the
+left() member, and the portion after the match can be obtained
+by the right() member.
+<p>
+Essentially, this package implements a syntax that is very much
+like the perl 5 regular expression syntax.
+
+Longer example:
+<pre>
+        Regex r = new Regex("x(a|b)y");
+        r.matchAt("xay",0);
+        ewe.sys.Vm.out().println("sub = "+r.stringMatched(1));
+</pre>
+The above would print "sub = a".
+<pre>
+        r.left() // would return "x"
+        r.right() // would return "y"
+</pre>
+<p>
+Differences between this package and perl5:<br>
+The extended Pattern for setting flags, is now supported,
+but the flags are different.  "(?i)" tells the pattern to
+ignore case, "(?Q)" sets the "dontMatchInQuotes" flag, and
+"(?iQ)" sets them both.  You can change the escape character.
+The pattern <pre>(?e=#)#d+</pre> is the same as <pre>\d+</pre>,
+but note that the sequence <pre>(?e=#)</pre> <b>must</b> occur
+at the very beginning of the pattern.  There may be other small
+differences as well.  I will either make my package conform
+or note them as I become aware of them.
+<p>
+This package supports additional patterns not in perl5:
+<center>
+<table border=1>
+<tr><td>(?@())</td><td>Group</td><td>This matches all characters between
+the '(' character and the balancing ')' character.  Thus, it will
+match "()" as well as "(())".  The balancing characters are
+arbitrary, thus (?@{}) matches on "{}" and "{{}}".</td>
+<tr><td>(?&lt1)</td><td>Backup</td><td>Moves the pointer backwards within the text.
+This allows you to make a "look behind."  It fails if it
+attempts to move to a position before the beginning of the string.
+"x(?&lt1)" is equivalent to "(?=x)".  The number, 1 in this example,
+is the number of characters to move backwards.</td>
+</table>
+</center>
+</dl>
+ at author Steven R. Brandt
+ at version package com.stevesoft.pat, release 1.5.3
+ at see Pattern
+*/
+public class Regex extends RegRes implements FilenameFilter {
+    /** BackRefOffset gives the identity number of the first
+        pattern.  Version 1.0 used zero, version 1.1 uses 1 to be
+        more compatible with perl. */
+    static int BackRefOffset = 1;
+    private static Pattern none = new NoPattern();
+    Pattern thePattern = none;
+    patInt minMatch = new patInt(0);
+
+    static Hashtable validators = new Hashtable();
+    static {
+        define("p","(?>1)",new UnicodePunct());
+        define("P","(?>1)",new NUnicodePunct());
+        define("s","(?>1)",new UnicodeWhite());
+        define("S","(?>1)",new NUnicodeWhite());
+        define("w","(?>1)",new UnicodeW());
+        define("W","(?>1)",new NUnicodeW());
+        define("d","(?>1)",new UnicodeDigit());
+        define("D","(?>1)",new NUnicodeDigit());
+        define("m","(?>1)",new UnicodeMath());
+        define("M","(?>1)",new NUnicodeMath());
+        define("c","(?>1)",new UnicodeCurrency());
+        define("C","(?>1)",new NUnicodeCurrency());
+        define("a","(?>1)",new UnicodeAlpha());
+        define("A","(?>1)",new NUnicodeAlpha());
+        define("uc","(?>1)",new UnicodeUpper());
+        define("lc","(?>1)",new UnicodeLower());
+    }
+
+    /** Set the dontMatch in quotes flag. */
+    public void setDontMatchInQuotes(boolean b) {
+      dontMatchInQuotes = b;
+    }
+    /** Find out if the dontMatchInQuotes flag is enabled. */
+    public boolean getDontMatchInQuotes() {
+      return dontMatchInQuotes;
+    }
+    boolean dontMatchInQuotes = false;
+
+    /** Set the state of the ignoreCase flag.  If set to true, then
+        the pattern matcher will ignore case when searching for a
+        match. */
+    public void setIgnoreCase(boolean b) {
+        ignoreCase = b;
+    }
+    /** Get the state of the ignoreCase flag.  Returns true if we
+        are ignoring the case of the pattern, false otherwise. */
+    public boolean getIgnoreCase() {
+        return ignoreCase;
+    }
+    boolean ignoreCase = false;
+    
+    static boolean defaultMFlag = false;
+    /** Set the default value of the m flag.  If it
+        is set to true, then the MFlag will be on
+	for any regex search executed. */
+    public static void setDefaultMFlag(boolean mFlag) {
+      defaultMFlag = mFlag;
+    }
+    /** Get the default value of the m flag.  If it
+        is set to true, then the MFlag will be on
+	for any regex search executed. */
+    public static boolean getDefaultMFlag() {
+      return defaultMFlag;
+    }
+
+    /** Initializes the object without a Pattern. To supply a Pattern
+        use compile(String s).
+         @see com.stevesoft.ewe_pat.Regex#compile(java.lang.String)
+                 */
+    public Regex() {}
+    /** Create and compile a Regex, but do not throw any exceptions.
+        If you wish to have exceptions thrown for syntax errors,
+        you must use the Regex(void) constructor to create the
+        Regex object, and then call the compile method.  Therefore, you
+        should only call this method when you know your pattern is right.
+        I will probably become more like
+         @see com.stevesoft.ewe_pat.Regex#search(java.lang.String)
+         @see com.stevesoft.ewe_pat.Regex#compile(java.lang.String)
+         */
+    public Regex(String s) {
+        try {
+            compile(s);
+        } catch(RegSyntax rs) {}
+    }
+
+    ReplaceRule rep = null;
+    /** Create and compile both a Regex and a ReplaceRule.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+	@see com.stevesoft.ewe_pat.Regex#compile(java.lang.String)
+        */
+    public Regex(String s,String rp) {
+        this(s);
+        rep = ReplaceRule.perlCode(rp);
+    }
+    /** Create and compile a Regex, but give it the ReplaceRule
+        specified.  This allows the user finer control of the
+        Replacement process, if that is desired.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+	@see com.stevesoft.ewe_pat.Regex#compile(java.lang.String)
+        */
+    public Regex(String s,ReplaceRule rp) {
+        this(s);
+        rep = rp;
+    }
+
+    /** Change the ReplaceRule of this Regex by compiling
+        a new one using String rp. */
+    public void setReplaceRule(String rp) {
+        rep = ReplaceRule.perlCode(rp);
+        repr = null; // Clear Replacer history
+    }
+
+    /** Change the ReplaceRule of this Regex to rp. */
+    public void setReplaceRule(ReplaceRule rp) {
+        rep = rp;
+    }
+    /** Test to see if a custom defined rule exists.
+        @see com.stevesoft.pat#define(java.lang.String,java.lang.String,Validator)
+        */
+    public static boolean isDefined(String nm) {
+        return validators.get(nm) != null;
+    }
+    /** Removes a custom defined rule.
+        @see com.stevesoft.pat#define(java.lang.String,java.lang.String,Validator)
+        */
+    public static void undefine(String nm) {
+        validators.remove(nm);
+    }
+    /** Defines a method to create a new rule.  See test/deriv2.java
+        and test/deriv3.java for examples of how to use it. */
+    public static void define(String nm,String pat,Validator v) {
+        v.pattern = pat;
+        validators.put(nm,v);
+    }
+    /** Defines a shorthand for a pattern.  The pattern will be
+        invoked by a string that has the form "(??"+nm+")".
+        */
+    public static void define(String nm,String pat) {
+        validators.put(nm,pat);
+    }
+
+    /** Get the current ReplaceRule. */
+    public ReplaceRule getReplaceRule() { return rep; }
+
+    Replacer repr = null;
+    final Replacer _getReplacer() {
+        return repr==null ? repr=new Replacer() : repr;
+    }
+    public Replacer getReplacer() {
+        if(repr == null)
+            repr = new Replacer();
+        repr.rh.me = this;
+        repr.rh.prev = null;
+        return repr;
+    }
+    /** Replace the first occurence of this pattern in String s
+        according to the ReplaceRule.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+        @see com.stevesoft.ewe_pat.Regex#getReplaceRule()
+        */
+    public String replaceFirst(String s) {
+        return _getReplacer().replaceFirstRegion(s,this,0,s.length()).toString();
+    }
+    /** Replace the first occurence of this pattern in String s
+        beginning with position pos according to the ReplaceRule.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+        @see com.stevesoft.ewe_pat.Regex#getReplaceRule()
+        */
+    public String replaceFirstFrom(String s,int pos) {
+        return _getReplacer().replaceFirstRegion(s,this,pos,s.length()).toString();
+    }
+    /** Replace the first occurence of this pattern in String s
+        beginning with position start and ending with end
+        according to the ReplaceRule.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+        @see com.stevesoft.ewe_pat.Regex#getReplaceRule()
+        */
+    public String replaceFirstRegion(String s,int start,int end) {
+        return _getReplacer().replaceFirstRegion(s,this,start,end).toString();
+    }
+
+    /** Replace all occurences of this pattern in String s
+        according to the ReplaceRule.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+        @see com.stevesoft.ewe_pat.Regex#getReplaceRule()
+        */
+    public String replaceAll(String s) {
+        return _getReplacer().replaceAllRegion(s,this,0,s.length()).toString();
+    }
+    public StringLike replaceAll(StringLike s) {
+        return _getReplacer().replaceAllRegion(s,this,0,s.length());
+    }
+    /** Replace all occurences of this pattern in String s
+        beginning with position pos according to the ReplaceRule.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+        @see com.stevesoft.ewe_pat.Regex#getReplaceRule()
+        */
+    public String replaceAllFrom(String s,int pos) {
+        return _getReplacer().replaceAllRegion(s,this,pos,s.length()).toString();
+    }
+    /** Replace all occurences of this pattern in String s
+        beginning with position start and ending with end
+        according to the ReplaceRule.
+        @see com.stevesoft.ewe_pat.ReplaceRule
+        @see com.stevesoft.ewe_pat.Regex#getReplaceRule()
+        */
+    public String replaceAllRegion(String s,int start,int end) {
+        return _getReplacer().replaceAllRegion(s,this,start,end).toString();
+    }
+
+
+    /** Essentially clones the Regex object */
+    public Regex(Regex r) {
+        super((RegRes)r);
+        dontMatchInQuotes = r.dontMatchInQuotes;
+        esc = r.esc;
+        ignoreCase = r.ignoreCase;
+        gFlag = r.gFlag;
+        if(r.rep==null)
+            rep = null;
+        else
+            rep = (ReplaceRule)r.rep.clone();
+        /* try {
+            compile(r.toString());
+        } catch(RegSyntax r_) {} */
+        thePattern = r.thePattern.clone(new Hashtable());
+        minMatch = r.minMatch;
+        skipper = r.skipper;
+    }
+
+    /** By default,
+                the escape character is the backslash, but you can
+                make it anything you want by setting this variable. */
+    public char esc = Pattern.ESC;
+    /** This method compiles a regular expression, making it
+         possible to call the search or matchAt methods.
+                @exception com.stevesoft.ewe_pat.RegSyntax
+                is thrown if a syntax error is encountered
+		in the pattern.
+                 For example, "x{3,1}" or "*a" are not valid
+		 patterns.
+                @see com.stevesoft.ewe_pat.Regex#search
+                @see com.stevesoft.ewe_pat.Regex#matchAt
+                */
+    public void compile(String prepat) throws RegSyntax {
+        String postpat = parsePerl.codify(prepat,true);
+        String pat = postpat==null ? prepat : postpat;
+        minMatch = null;
+        ignoreCase = false;
+        dontMatchInQuotes = false;
+        Rthings mk = new Rthings(this);
+        int offset = mk.val;
+        String newpat = pat;
+        thePattern = none;
+        p = null;
+        or = null;
+        minMatch = new patInt(0);
+        StrPos sp = new StrPos(pat,0);
+        if(sp.incMatch("(?e=")) {
+            char newEsc = sp.c;
+            sp.inc();
+            if(sp.match(')'))
+                newpat = reEscape(pat.substring(6),
+                    newEsc,Pattern.ESC);
+        } else if(esc != Pattern.ESC)
+            newpat = reEscape(pat,esc,Pattern.ESC);
+        thePattern = _compile(newpat,mk);
+        numSubs_ = mk.val-offset;
+        mk.set(this);
+    }
+
+    /*  If a Regex is compared against a Regex, a check is
+        done to see that the patterns are equal as well as
+        the most recent match.  If a Regex is compare with
+        a RegRes, only the result of the most recent match
+        is compared. */
+    public boolean equals(Object o) {
+        if(o instanceof Regex) {
+            if(toString().equals(o.toString()))
+                return super.equals(o);
+            else
+                return false;
+        } else return super.equals(o);
+    }
+
+    /** A clone by any other name would smell as sweet. */
+    public Object clone() {
+        return new Regex(this);
+    }
+    /** Return a clone of the underlying RegRes object. */
+    public RegRes result() {
+      return (RegRes)super.clone();
+    }
+
+    // prep sets global variables of class
+    // Pattern so that it can access them
+    // during an attempt at a match
+    Pthings pt = new Pthings();
+    final Pthings prep(StringLike s) {
+	//if(gFlag)
+          pt.lastPos = matchedTo();
+        if(pt.lastPos < 0) pt.lastPos = 0;
+        if( (s==null ? null : s.unwrap()) != (src==null ? null : s.unwrap()) )
+          pt.lastPos = 0;
+        src = s;
+        pt.dotDoesntMatchCR=dotDoesntMatchCR && (!sFlag);
+	pt.mFlag = (mFlag | defaultMFlag);
+        pt.ignoreCase = ignoreCase;
+        pt.no_check = false;
+        if(pt.marks != null)
+            for(int i=0;i<pt.marks.length;i++)
+                pt.marks[i]=-1;
+	pt.marks = null;
+        pt.nMarks = numSubs_;
+        pt.src = s;
+        if(dontMatchInQuotes)
+            setCbits(s,pt);
+        else
+            pt.cbits = null;
+        return pt;
+    }
+    /** Attempt to match a Pattern beginning
+        at a specified location within the string.
+        @see com.stevesoft.ewe_pat.Regex#search
+        */
+    public boolean matchAt(String s,int start_pos) {
+        return _search(s,start_pos,start_pos);
+    }
+    /** Attempt to match a Pattern beginning
+        at a specified location within the StringLike.
+        @see com.stevesoft.ewe_pat.Regex#search
+        */
+    public boolean matchAt(StringLike s,int start_pos) {
+        return _search(s,start_pos,start_pos);
+    }
+
+
+    /** Search through a String for the first
+        occurrence of a match.
+        @see com.stevesoft.ewe_pat.Regex#searchFrom
+        @see com.stevesoft.ewe_pat.Regex#matchAt
+        */
+    public boolean search(String s) {
+        if(s==null)
+            throw new NullPointerException("Null String Given to Regex.search");
+        return _search(s,0,s.length());
+    }
+    public boolean search(StringLike sl) {
+        if(sl==null)
+            throw new NullPointerException("Null StringLike Given to Regex.search");
+        return _search(sl,0,sl.length());
+    }
+    public boolean reverseSearch(String s) {
+        if(s==null)
+            throw new NullPointerException("Null String Given to Regex.reverseSearch");
+        return _reverseSearch(s,0,s.length());
+    }
+    public boolean reverseSearch(StringLike sl) {
+        if(sl==null)
+            throw new NullPointerException("Null StringLike Given to Regex.reverseSearch");
+        return _reverseSearch(sl,0,sl.length());
+    }
+    /** Search through a String for the first
+                occurence of a match, but start at position <pre>start</pre>*/
+    public boolean searchFrom(String s,int start) {
+        if(s==null)
+            throw new NullPointerException("Null String Given to Regex.searchFrom");
+        return _search(s,start,s.length());
+    }
+    public boolean searchFrom(StringLike s,int start) {
+        if(s==null)
+            throw new NullPointerException("Null String Given to Regex.searchFrom");
+        return _search(s,start,s.length());
+    }
+    /** Search through a region of a String
+        for the first occurence of a match. */
+    public boolean searchRegion(String s,int start,int end) {
+        if(s==null)
+            throw new NullPointerException("Null String Given to Regex.searchRegion");
+        return _search(s,start,end);
+    }
+    /** Set this to change the default behavior of the "." pattern.
+                By default it now matches perl's behavior and fails to
+                match the '\n' character. */
+    public static boolean dotDoesntMatchCR = true;
+    StringLike gFlags;
+    int gFlagto = 0;
+    boolean gFlag = false;
+    /** Set the 'g' flag */
+    public void setGFlag(boolean b) {
+      gFlag = b;
+    }
+    /** Get the state of the 'g' flag. */
+    public boolean getGFlag() {
+      return gFlag;
+    }
+    boolean sFlag = false;
+    /** Get the state of the sFlag */
+    public boolean getSFlag() {
+      return sFlag;
+    }
+    boolean mFlag = false;
+    /** Get the state of the sFlag */
+    public boolean getMFlag() {
+      return mFlag;
+    }
+
+    final boolean _search(String s,int start,int end) {
+        return _search(new StringWrap(s),start,end);
+    }
+    final boolean _search(StringLike s,int start,int end) {
+        if(gFlag && gFlagto > 0 && gFlags!=null && s.unwrap()==gFlags.unwrap())
+            start = gFlagto;
+        gFlags = null;
+
+        Pthings pt=prep(s);
+
+        int up = (minMatch == null ? end : end-minMatch.i);
+
+        if(up < start && end >= start) up = start;
+
+        if(skipper == null) {
+            for(int i=start;i<=up;i++) {
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ >= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    gFlags = s;
+                    return didMatch_=true;
+                }
+            }
+        } else {
+            pt.no_check = true;
+            for(int i=start;i<=up;i++) {
+                i = skipper.find(src,i,up);
+                if(i<0) {
+                    charsMatched_ = matchFrom_ = -1;
+                    return didMatch_ = false;
+                }
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ >= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    gFlags = s;
+                    return didMatch_=true;
+                }
+            }
+        }
+        return didMatch_=false;
+    }
+    /*final boolean _search(LongStringLike s,long start,long end) {
+        if(gFlag && gFlagto > 0 && s==gFlags)
+            start = gFlagto;
+        gFlags = null;
+
+        Pthings pt=prep(s);
+
+        int up = end;//(minMatch == null ? end : end-minMatch.i);
+
+        if(up < start && end >= start) up = start;
+
+        if(skipper == null) {
+            for(long i=start;i<=up;i++) {
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ >= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    return didMatch_=true;
+                }
+            }
+        } else {
+            pt.no_check = true;
+            for(long i=start;i<=up;i++) {
+                i = skipper.find(src,i,up);
+                if(i<0) {
+                    charsMatched_ = matchFrom_ = -1;
+                    return didMatch_ = false;
+                }
+                charsMatched_ = thePattern.matchAt(s,i,pt);
+                if(charsMatched_ >= 0) {
+                    matchFrom_ = thePattern.mfrom;
+                    marks = pt.marks;
+                    gFlagto = matchFrom_+charsMatched_;
+                    gFlags = s;
+                    return didMatch_=true;
+                } else {
+                  i = s.adjustIndex(i);
+                  up = s.adjustEnd(i);
+                }
+            }
+        }
+        return didMatch_=false;
+    }*/
+
+    boolean _reverseSearch(String s,int start,int end) {
+        return _reverseSearch(new StringWrap(s),start,end);
+    }
+    boolean _reverseSearch(StringLike s,int start,int end) {
+        if(gFlag && gFlagto > 0 && s.unwrap()==gFlags.unwrap())
+            end = gFlagto;
+        gFlags = null;
+        Pthings pt=prep(s);
+        for(int i=end;i>=start;i--) {
+            charsMatched_ = thePattern.matchAt(s,i,pt);
+            if(charsMatched_ >= 0) {
+                matchFrom_ = thePattern.mfrom;
+                marks = pt.marks;
+                gFlagto = matchFrom_-1;
+                gFlags = s;
+                return didMatch_=true;
+            }
+        }
+        return didMatch_=false;
+    }
+
+    // This routine sets the cbits variable
+    // of class Pattern.  Cbits is true for
+    // the bit corresponding to a character inside
+    // a set of quotes.
+    static StringLike lasts=null;
+    static BitSet lastbs=null;
+    static void setCbits(StringLike s,Pthings pt) {
+        if(s == lasts) {
+            pt.cbits = lastbs;
+            return;
+        }
+        BitSet bs = new BitSet(s.length());
+        char qc = ' ';
+        boolean setBit = false;
+        for(int i=0;i<s.length();i++) {
+            if(setBit) bs.set(i);
+            char c = s.charAt(i);
+            if(!setBit && c == '"') {
+                qc = c;
+                setBit = true;
+                bs.set(i);
+            } else if(!setBit && c == '\'') {
+                qc = c;
+                setBit = true;
+                bs.set(i);
+            } else if(setBit && c == qc) {
+                setBit = false;
+            } else if(setBit && c == '\\' && i+1<s.length()) {
+                i++;
+                if(setBit) bs.set(i);
+            }
+        }
+        pt.cbits = lastbs = bs;
+        lasts = s;
+    }
+
+    // Wanted user to over-ride this in alpha version,
+    // but it wasn't really necessary because of this trick:
+    Regex newRegex() {
+        try {
+            return (Regex)getClass().newInstance();
+        } catch(InstantiationException ie) {
+            return null;
+        } catch(IllegalAccessException iae) {
+            return null;
+        }
+    }
+    /** Only needed for creating your own extensions of
+         Regex.  This method adds the next Pattern in the chain
+         of patterns or sets the Pattern if it is the first call. */
+    protected void add(Pattern p2) {
+        if(p == null)
+            p = p2;
+        else {
+            p.add(p2);
+            p2 = p;
+        }
+    }
+
+    /** You only need to use this method if you are creating
+        your own extentions to Regex.
+        compile1 compiles one Pattern element, it can be
+        over-ridden to allow the Regex compiler to understand
+        new syntax.  See deriv.java for an example.  This routine
+        is the heart of class Regex. Rthings has one integer
+        member called intValue, it is used to keep track of the number
+        of ()'s in the Pattern.
+        @exception com.stevesoft.ewe_pat.RegSyntax is thrown when a nonsensensical
+        pattern is supplied.  For example, a pattern beginning
+        with *. */
+    protected void compile1(StrPos sp,Rthings mk) throws RegSyntax {
+        if(sp.match('[')) {
+            sp.inc();
+            add(matchBracket(sp));
+        } else if(sp.match('|')) {
+            if(or == null)
+                or = new Or();
+            if(p == null) p=new NullPattern();
+            or.addOr(p);
+            p = null;
+        } else if(sp.incMatch("(?<")) {
+            patInt i = sp.getPatInt();
+            if(i==null) RegSyntaxError.endItAll("No int after (?<");
+            add(new Backup(i.intValue()));
+            if(!sp.match(')')) RegSyntaxError.endItAll("No ) after (?<");
+        } else if(sp.incMatch("(?>")) {
+            patInt i = sp.getPatInt();
+            if(i==null) RegSyntaxError.endItAll("No int after (?>");
+            add(new Backup(-i.intValue()));
+            if(!sp.match(')')) RegSyntaxError.endItAll("No ) after (?<");
+        } else if(sp.incMatch("(?@")) {
+            char op = sp.c;
+            sp.inc();
+            char cl = sp.c;
+            sp.inc();
+            if(!sp.match(')'))
+                RegSyntaxError.endItAll(
+                    "(?@ does not have closing paren");
+            add(new Group(op,cl));
+        } else if(sp.incMatch("(?#")) {
+            while(!sp.match(')'))
+                sp.inc();
+        } else if(sp.dontMatch && sp.c == 'w') {
+            Regex r = new Regex();
+            //r._compile("[a-zA-Z0-9_]",mk);
+            //add(new Goop("\\w",r.thePattern));
+            Bracket b = new Bracket(false);
+            b.addOr(new Range('a','z'));
+            b.addOr(new Range('A','Z'));
+            b.addOr(new Range('0','9'));
+            b.addOr(new oneChar('_'));
+            add(b);
+        } else if(sp.dontMatch && sp.c == 'G') {
+            add(new BackG());
+        } else if(sp.dontMatch && sp.c == 's') {
+            //Regex r = new Regex();
+            //r._compile("[ \t\n\r\b]",mk);
+            //add(new Goop("\\s",r.thePattern));
+            Bracket b = new Bracket(false);
+            b.addOr(new oneChar((char)32));
+            b.addOr(new Range((char)8,(char)10));
+            b.addOr(new oneChar((char)13));
+            add(b);
+        } else if(sp.dontMatch && sp.c == 'd') {
+            Regex r = new Regex();
+            //r._compile("[0-9]",mk);
+            //add(new Goop("\\d",r.thePattern));
+            Range digit = new Range('0','9');
+            digit.printBrackets = true;
+            add(digit);
+        } else if(sp.dontMatch && sp.c == 'W') {
+            Regex r = new Regex();
+            //r._compile("[^a-zA-Z0-9_]",mk);
+            //add(new Goop("\\W",r.thePattern));
+            Bracket b = new Bracket(true);
+            b.addOr(new Range('a','z'));
+            b.addOr(new Range('A','Z'));
+            b.addOr(new Range('0','9'));
+            b.addOr(new oneChar('_'));
+            add(b);
+        } else if(sp.dontMatch && sp.c == 'S') {
+            //Regex r = new Regex();
+            //r._compile("[^ \t\n\r\b]",mk);
+            //add(new Goop("\\S",r.thePattern));
+            Bracket b = new Bracket(true);
+            b.addOr(new oneChar((char)32));
+            b.addOr(new Range((char)8,(char)10));
+            b.addOr(new oneChar((char)13));
+            add(b);
+        } else if(sp.dontMatch && sp.c == 'D') {
+            //Regex r = new Regex();
+            //r._compile("[^0-9]",mk);
+            //add(new Goop("\\D",r.thePattern));
+            Bracket b = new Bracket(true);
+            b.addOr(new Range('0','9'));
+            add(b);
+        } else if(sp.dontMatch && sp.c == 'B') {
+            Regex r = new Regex();
+            r._compile("(?!"+back_slash+"b)",mk);
+            add(r.thePattern);
+	} else if(isOctalString(sp)) {
+	    int d = sp.c - '0';
+	    sp.inc();
+	    d = 8*d + sp.c - '0';
+	    StrPos sp2 = new StrPos(sp);
+	    sp2.inc();
+	    if(isOctalDigit(sp2,false)) {
+	      sp.inc();
+	      d = 8*d + sp.c - '0';
+	    }
+	    add(new oneChar((char)d));
+        } else if(sp.dontMatch && sp.c >= '1' && sp.c <= '9') {
+            int iv = sp.c-'0';
+            StrPos s2 = new StrPos(sp);
+            s2.inc();
+            if(!s2.dontMatch && s2.c >= '0' && s2.c <= '9') {
+                iv = 10*iv+(s2.c-'0');
+                sp.inc();
+            }
+            add(new BackMatch(iv));
+        } else if(sp.dontMatch && sp.c == 'b') {
+            add(new Boundary());
+        } else if(sp.match('\b')) {
+            add(new Boundary());
+        } else if(sp.match('$')) {
+            add(new End(true));
+        } else if(sp.dontMatch && sp.c == 'Z') {
+            add(new End(false));
+        } else if(sp.match('.')) {
+            add(new Any());
+        } else if(sp.incMatch("(??")) {
+            StringBuffer sb = new StringBuffer();
+            StringBuffer sb2 = new StringBuffer();
+            while(!sp.match(')') && !sp.match(':')) {
+                sb.append(sp.c);
+                sp.inc();
+            }
+            if(sp.incMatch(":")) {
+                while(!sp.match(')')) {
+                    sb2.append(sp.c);
+                    sp.inc();
+                }
+            }
+            String sbs = sb.toString();
+            if(validators.get(sbs) instanceof String) {
+                String pat = (String)validators.get(sbs);
+                Regex r = newRegex();
+		Rthings rth = new Rthings(this);
+		rth.noBackRefs = true;
+                r._compile(pat,rth);
+                add(r.thePattern);
+            } else {
+                Custom cm = new Custom(sb.toString());
+                if(cm.v != null) {
+                    Validator v2 = cm.v.arg(sb2.toString());
+                    if(v2 != null) {
+                        v2.argsave = sb2.toString();
+                        String p = cm.v.pattern;
+                        cm.v = v2;
+                        v2.pattern = p;
+                    }
+                    Regex r = newRegex();
+		    Rthings rth = new Rthings(this);
+		    rth.noBackRefs = true;
+                    r._compile(cm.v.pattern,rth);
+                    cm.sub = r.thePattern;
+                    cm.sub.add(new CustomEndpoint(cm));
+                    cm.sub.setParent(cm);
+                    add(cm);
+                }
+            }
+        } else if(sp.match('(')) {
+            mk.parenLevel++;
+            Regex r = newRegex();
+            // r.or = new Or();
+            sp.inc();
+            if(sp.incMatch("?:")) {
+                r.or = new Or();
+            } else if(sp.incMatch("?=")) {
+                r.or = new lookAhead(false);
+            } else if(sp.incMatch("?!")) {
+                r.or = new lookAhead(true);
+            } else if(sp.match('?')) {
+                sp.inc();
+                do {
+                    if(sp.c=='i')mk.ignoreCase = true;
+                    if(sp.c=='Q')mk.dontMatchInQuotes = true;
+                    if(sp.c=='o')mk.optimizeMe = true;
+                    if(sp.c=='g')mk.gFlag = true;
+                    if(sp.c=='s')mk.sFlag = true;
+		    if(sp.c=='m')mk.mFlag = true;
+                    sp.inc();
+                } while(!sp.match(')') && !sp.eos);
+                r = null;
+                mk.parenLevel--;
+                if(sp.eos) //throw new RegSyntax
+                    RegSyntaxError.endItAll("Unclosed ()");
+            } else { // just ordinary parenthesis
+                r.or = mk.noBackRefs ? new Or() : new OrMark(mk.val++);
+            }
+            if(r != null) add(r._compile(sp,mk));
+        } else if(sp.match('^')) {
+            add(new Start(true));
+        } else if(sp.dontMatch && sp.c=='A') {
+            add(new Start(false));
+        } else if(sp.match('*')) {
+            addMulti(new patInt(0),new patInf());
+        } else if(sp.match('+')) {
+            addMulti(new patInt(1),new patInf());
+        } else if(sp.match('?')) {
+            addMulti(new patInt(0),new patInt(1));
+        } else if(sp.match('{')) {
+            boolean bad = false;
+            StrPos sp2 = new StrPos(sp);
+            StringBuffer sb = new StringBuffer();
+            sp.inc();
+            patInt i1 = sp.getPatInt();
+            patInt i2 = null;
+            if(sp.match('}')) {
+                i2 = i1;
+            } else {
+                if(!sp.match(','))/*
+                    RegSyntaxError.endItAll(
+                       "String \"{"+i2+
+                       "\" should be followed with , or }");*/
+                    bad = true;
+                sp.inc();
+                if(sp.match('}'))
+                    i2 = new patInf();
+                else
+                    i2 = sp.getPatInt();
+            }
+            if(i1 == null || i2 == null) /*
+                                throw new RegSyntax("Badly formatted Multi: "
+                                +"{"+i1+","+i2+"}"); */ bad = true;
+            if(bad) {
+                sp.dup(sp2);
+                add(new oneChar(sp.c));
+            } else
+                addMulti(i1,i2);
+	} else if(sp.escMatch('x') && next2Hex(sp)) { 
+	    sp.inc();
+	    int d = getHexDigit(sp);
+	    sp.inc();
+            d = 16*d + getHexDigit(sp);
+	    add(new oneChar((char)d));
+	} else if(sp.escMatch('c')) {
+	    sp.inc();
+	    if(sp.c < Ctrl.cmap.length)
+	      add(new oneChar(Ctrl.cmap[sp.c]));
+	    else
+	      add(new oneChar(sp.c));
+	} else if(sp.escMatch('f')) {
+	    add(new oneChar((char)12));
+	} else if(sp.escMatch('a')) {
+	    add(new oneChar((char)7));
+	} else if(sp.escMatch('t')) {
+	    add(new oneChar('\t'));
+        } else if(sp.escMatch('n')) {
+            add(new oneChar('\n'));
+        } else if(sp.escMatch('r')) {
+            add(new oneChar('\r'));
+        } else if(sp.escMatch('b')) {
+            add(new oneChar('\b'));
+        } else if(sp.escMatch('e')) {
+            add(new oneChar((char)27));
+        } else {
+            add(new oneChar(sp.c));
+            if(sp.match(')'))
+                RegSyntaxError.endItAll("Unmatched right paren in pattern");
+        }
+    }
+
+    // compiles all Pattern elements, internal method
+    private Pattern _compile(String pat,Rthings mk) throws RegSyntax {
+        minMatch = null;
+        sFlag = mFlag = ignoreCase = gFlag = false;
+        StrPos sp = new StrPos(pat,0);
+        thePattern = _compile(sp,mk);
+        pt.marks = null;
+        return thePattern;
+    }
+
+    Pattern p = null;
+    Or or = null;
+    Pattern _compile(StrPos sp,Rthings mk) throws RegSyntax {
+        while(!(sp.eos || (or != null && sp.match(')')) )) {
+            compile1(sp,mk);
+            sp.inc();
+        }
+        if(sp.match(')')) mk.parenLevel--;
+        else if(sp.eos && mk.parenLevel != 0) {
+            RegSyntaxError.endItAll("Unclosed Parenthesis! lvl="+mk.parenLevel);
+        } if(or != null) {
+            if(p == null) p = new NullPattern();
+            or.addOr(p);
+            return or;
+        }
+        return p==null ? new NullPattern() : p;
+    }
+
+    // add a multi object to the end of the chain
+    // which applies to the last object
+    void addMulti(patInt i1,patInt i2) throws RegSyntax {
+        Pattern last,last2;
+        for(last = p;last != null && last.next != null;last=last.next)
+            ;
+        if(last == null || last == p)
+            last2 = null;
+        else
+            for(last2 = p;last2.next != last;last2=last2.next)
+                ;
+        if(last instanceof Multi && i1.intValue()==0 &&
+                i2.intValue()==1)
+            ((Multi)last).matchFewest = true;
+        else if(last instanceof FastMulti && i1.intValue()==0 &&
+                i2.intValue()==1)
+            ((FastMulti)last).matchFewest = true;
+        else if(last instanceof DotMulti && i1.intValue()==0 &&
+                i2.intValue()==1)
+            ((DotMulti)last).matchFewest = true;
+	else if(last instanceof Multi
+	     || last instanceof DotMulti
+	     || last instanceof FastMulti)
+	    throw new RegSyntax("Syntax error.");
+        else if(last2 == null)
+            p = mkMulti(i1,i2,p);
+        else
+            last2.next = mkMulti(i1,i2,last);
+    }
+    final static Pattern mkMulti(patInt lo,patInt hi,Pattern p) throws RegSyntax {
+        if(p instanceof Any && p.next == null)
+            return (Pattern)new DotMulti(lo,hi);
+        return RegOpt.safe4fm(p) ? (Pattern)new FastMulti(lo,hi,p) :
+        (Pattern)new Multi(lo,hi,p);
+    }
+    // process the bracket operator
+    Pattern matchBracket(StrPos sp) throws RegSyntax {
+        Bracket ret;
+        if(sp.match('^')) {
+            ret = new Bracket(true);
+            sp.inc();
+        } else
+            ret = new Bracket(false);
+        if(sp.match(']'))
+            //throw new RegSyntax
+            RegSyntaxError.endItAll("Unmatched []");
+
+        while(!sp.eos && !sp.match(']')) {
+            StrPos s1 = new StrPos(sp);
+            s1.inc();
+            StrPos s1_ = new StrPos(s1);
+            s1_.inc();
+            if(s1.match('-') && !s1_.match(']')) {
+                StrPos s2 = new StrPos(s1);
+                s2.inc();
+                if(!s2.eos)
+                    ret.addOr(new Range(sp.c,s2.c));
+                sp.inc();
+                sp.inc();
+            } else if(sp.escMatch('Q')) {
+                sp.inc();
+                while(!sp.escMatch('E')) {
+                    ret.addOr(new oneChar(sp.c));
+                    sp.inc();
+                }
+            } else if(sp.escMatch('d')) {
+                ret.addOr(new Range('0','9'));
+            } else if(sp.escMatch('s')) {
+                ret.addOr(new oneChar((char)32));
+                ret.addOr(new Range((char)8,(char)10));
+                ret.addOr(new oneChar((char)13));
+            } else if(sp.escMatch('w')) {
+                ret.addOr(new Range('a','z'));
+                ret.addOr(new Range('A','Z'));
+                ret.addOr(new Range('0','9'));
+                ret.addOr(new oneChar('_'));
+            } else if(sp.escMatch('D')) {
+                ret.addOr(new Range((char)0,(char)47));
+                ret.addOr(new Range((char)58,(char)65535));
+            } else if(sp.escMatch('S')) {
+                ret.addOr(new Range((char)0,(char)7));
+                ret.addOr(new Range((char)11,(char)12));
+                ret.addOr(new Range((char)14,(char)31));
+                ret.addOr(new Range((char)33,(char)65535));
+            } else if(sp.escMatch('W')) {
+                ret.addOr(new Range((char)0,(char)64));
+                ret.addOr(new Range((char)91,(char)94));
+                ret.addOr(new oneChar((char)96));
+                ret.addOr(new Range((char)123,(char)65535));
+	    } else if(sp.escMatch('x') && next2Hex(sp)) { 
+	        sp.inc();
+	        int d = getHexDigit(sp);
+	        sp.inc();
+                d = 16*d + getHexDigit(sp);
+	        ret.addOr(new oneChar((char)d));
+	    } else if(sp.escMatch('a')) {
+	        ret.addOr(new oneChar((char)7));
+	    } else if(sp.escMatch('f')) {
+	        ret.addOr(new oneChar((char)12));
+	    } else if(sp.escMatch('e')) {
+	        ret.addOr(new oneChar((char)27));
+	    } else if(sp.escMatch('n')) {
+	        ret.addOr(new oneChar('\n'));
+	    } else if(sp.escMatch('t')) {
+	        ret.addOr(new oneChar('\t'));
+	    } else if(sp.escMatch('r')) {
+	        ret.addOr(new oneChar('\r'));
+	    } else if(sp.escMatch('c')) {
+	        sp.inc();
+	        if(sp.c < Ctrl.cmap.length)
+	          ret.addOr(new oneChar(Ctrl.cmap[sp.c]));
+	        else
+	          ret.addOr(new oneChar(sp.c));
+	    } else if(isOctalString(sp)) {
+	        int d = sp.c - '0';
+	        sp.inc();
+	        d = 8*d + sp.c - '0';
+	        StrPos sp2 = new StrPos(sp);
+	        sp2.inc();
+	        if(isOctalDigit(sp2,false)) {
+	          sp.inc();
+	          d = 8*d + sp.c - '0';
+	        }
+	        ret.addOr(new oneChar((char)d));
+            } else
+                ret.addOr(new oneChar(sp.c));
+            sp.inc();
+        }
+        return ret;
+    }
+
+    /** Converts the stored Pattern to a String -- this is a
+          decompile.  Note that \t and \n will really print out here,
+          Not just the two character representations.
+          Also be prepared to see some strange output if your characters
+          are not printable. */
+    public String toString() {
+        if( false && thePattern == null )
+            return "";
+        else {
+            StringBuffer sb = new StringBuffer();
+            if(esc != Pattern.ESC) {
+                sb.append("(?e=");
+                sb.append(esc);
+                sb.append(")");
+            }
+            if(gFlag
+	    ||mFlag
+	    ||!dotDoesntMatchCR
+	    ||sFlag
+	    ||ignoreCase
+	    ||dontMatchInQuotes
+	    ||optimized()) {
+                sb.append("(?");
+                if(ignoreCase)sb.append("i");
+		if(mFlag)sb.append("m");
+		if(sFlag||!dotDoesntMatchCR)sb.append("s");
+                if(dontMatchInQuotes)sb.append("Q");
+                if(optimized())sb.append("o");
+                if(gFlag)sb.append("g");
+                sb.append(")");
+            }
+            String patstr = thePattern.toString();
+            if(esc != Pattern.ESC)
+                patstr = reEscape(patstr,Pattern.ESC,esc);
+            sb.append(patstr);
+            return sb.toString();
+        }
+    }
+    // Re-escape Pattern, allows us to use a different escape
+    // character.
+    static String reEscape(String s,char oldEsc,char newEsc) {
+        if(oldEsc == newEsc) return s;
+        int i;
+        StringBuffer sb = new StringBuffer();
+        for(i=0;i<s.length();i++) {
+            if(s.charAt(i)==oldEsc && i+1 < s.length()) {
+                if(s.charAt(i+1)==oldEsc) {
+                    sb.append(oldEsc);
+                } else {
+                    sb.append(newEsc);
+                    sb.append(s.charAt(i+1));
+                }
+                i++;
+            } else if(s.charAt(i)==newEsc) {
+                sb.append(newEsc);
+                sb.append(newEsc);
+            } else {
+                sb.append(s.charAt(i));
+            }
+        }
+        return sb.toString();
+    }
+    /** This method implements FilenameFilter, allowing one
+         to use a Regex to search through a directory using File.list.
+         There is a FileRegex now that does this better.
+         @see com.stevesoft.ewe_pat.FileRegex
+        */
+    public boolean accept(File dir,String s) {
+        return search(s);
+    }
+    /** The version of this package */
+    final static public String version() {
+        return "lgpl release 1.5.3";
+    }
+    /** Once this method is called, the state of variables
+        ignoreCase and dontMatchInQuotes should not be changed as the
+        results will be unpredictable.  However,
+        search and matchAt will run more quickly.  Note that you
+        can check to see if the pattern has been optimized by calling
+        the optimized() method.<p>This method will attempt to rewrite
+        your pattern in a way that makes it faster (not all patterns
+        execute at the same speed).  In general, "(?: ... )" will be
+        faster than "( ... )" so if you don't need the backreference,
+        you should group using the former pattern.<p>It will also
+        introduce new pattern elements that you can't get to otherwise,
+        for example if you have a large table of strings, i.e. the
+        months of the year "(January|February|...)" optimize() will make
+        a Hashtable that takes it to the next appropriate pattern
+        element -- eliminating the need for a linear search.
+        @see com.stevesoft.ewe_pat.Regex#optimized
+        @see com.stevesoft.ewe_pat.Regex#ignoreCase
+        @see com.stevesoft.ewe_pat.Regex#dontMatchInQuotes
+        @see com.stevesoft.ewe_pat.Regex#matchAt
+        @see com.stevesoft.ewe_pat.Regex#search
+        */
+    public void optimize() {
+        if(optimized()||thePattern==null) return;
+        minMatch = new patInt(0);//thePattern.countMinChars();
+        thePattern = RegOpt.opt(thePattern,ignoreCase,
+            dontMatchInQuotes);
+        skipper = Skip.findSkip(this);
+        //RegOpt.setParents(this);
+        return;
+    }
+    Skip skipper;
+    /** This function returns true if the optimize method has
+         been called. */
+    public boolean optimized() {
+        return minMatch != null;
+    }
+
+    /** A bit of syntactic surgar for those who want to make
+        their code look more perl-like.  To use this initialize
+        your Regex object by saying:
+        <pre>
+        Regex r1 = Regex.perlCode("s/hello/goodbye/");
+        Regex r2 = Regex.perlCode("s'fish'frog'i");
+        Regex r3 = Regex.perlCode("m'hello');
+        </pre>
+        The i for ignoreCase is supported in
+        this syntax, as well as m, s, and x.  The g flat
+	is a bit of a special case.<p>
+	If you wish to replace all occurences of a pattern, you
+        do not put a 'g' in the perlCode, but call Regex's
+        replaceAll method.<p>
+	If you wish to simply
+        and only do a search for r2's pattern, you can do this
+        by calling the searchFrom method method repeatedly, or
+	by calling search repeatedly if the g flag is set.
+        <p>
+        Note: Currently perlCode does <em>not</em>
+	support the (?e=#) syntax for
+        changing the escape character.
+    */
+
+    public static Regex perlCode(String s) {
+        // this file is big enough, see parsePerl.java
+        // for this function.
+        return parsePerl.parse(s);
+    }
+    static final char back_slash = '\\';
+
+    /** Checks to see if there are only literal and no special
+        pattern elements in this Regex. */
+    public boolean isLiteral() {
+        Pattern x = thePattern;
+        while(x != null) {
+            if(x instanceof oneChar)
+                ;
+            else if(x instanceof Skipped)
+                ;
+            else
+                return false;
+            x = x.next;
+        }
+        return true;
+    }
+
+    /** You only need to know about this if you are inventing
+        your own pattern elements. */
+    public patInt countMinChars() { return thePattern.countMinChars(); }
+    /** You only need to know about this if you are inventing
+        your own pattern elements. */
+    public patInt countMaxChars() { return thePattern.countMaxChars(); }
+
+    boolean isHexDigit(StrPos sp) {
+      boolean r =
+        !sp.eos && !sp.dontMatch
+        && ((sp.c>='0'&&sp.c<='9')
+	  ||(sp.c>='a'&&sp.c<='f')
+	  ||(sp.c>='A'&&sp.c<='F'));
+      return r;
+    }
+    boolean isOctalDigit(StrPos sp,boolean first) {
+      boolean r =
+        !sp.eos && !(first^sp.dontMatch)
+        && sp.c>='0'&&sp.c<='7';
+      return r;
+    }
+    int getHexDigit(StrPos sp) {
+      if(sp.c >= '0' && sp.c <= '9')
+        return sp.c - '0';
+      if(sp.c >= 'a' && sp.c <= 'f')
+        return sp.c - 'a' + 10;
+      return sp.c - 'A' + 10;
+    }
+    boolean next2Hex(StrPos sp) {
+      StrPos sp2 = new StrPos(sp);
+      sp2.inc();
+      if(!isHexDigit(sp2))
+        return false;
+      sp2.inc();
+      if(!isHexDigit(sp2))
+        return false;
+      return true;
+    }
+    boolean isOctalString(StrPos sp) {
+      if(!isOctalDigit(sp,true))
+        return false;
+      StrPos sp2 = new StrPos(sp);
+      sp2.inc();
+      if(!isOctalDigit(sp2,false))
+        return false;
+      return true;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Regex.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RegexReader.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegexReader.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegexReader.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RegexReader.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RegexReader.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,249 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import ewe.io.*;
+
+import com.stevesoft.ewe_pat.wrap.*;
+
+/** This class allows you to replace the text in strings
+    as you read them in.  Be careful what you do with
+    this freedom... using Regex.perlCode("s{.*}{x}s")
+    as your pattern will result in loading the entire
+    contents of the Reader into memory.
+    */
+public class RegexReader extends Reader {
+  RBuffer rb = new RBuffer(new StringBuffer());
+  PartialBuffer wrap = new PartialBuffer(rb.sb);
+  boolean moreToRead = true;
+  Reader r;
+  Replacer rp;
+
+  // the buffer size
+  int nmax = 2*1024;
+
+  public RegexReader(Regex rex,Reader r) {
+    this.r = r;
+    rp = rex.getReplacer();
+  }
+  public RegexReader(Transformer tex,Reader r) {
+    this.r = r;
+    rp = tex.getReplacer();
+  }
+  public void reset() throws IOException {
+    r.reset();
+    rb = new RBuffer(new StringBuffer());
+    wrap = new PartialBuffer(rb.sb);
+    moreToRead = true;
+  }
+  void readData() throws IOException {
+    int c;
+    int n = 0;
+    while( (c = r.read()) != -1) {
+      rb.sb.append((char)c);
+      if(n++ > nmax)
+        break;
+    }
+    if(c == -1 && n == 0) {
+      moreToRead = false;
+      wrap.allowOverRun = false;
+    }
+  }
+  void getMoreData() throws IOException {
+    while(rb.pos >= rb.epos) {
+      wrap.overRun = false;
+      if(rb.next != null) {
+	rb = rb.next;
+      } else if(rb.done) {
+        break;
+      } else if(rb.epos >= rb.sb.length()
+	     && rb.epos > nmax) {
+	rb.pos = 1;
+	rb.epos = 1;
+	rb.sb.setLength(1);
+	readData();
+      } else if(rb.epos >= rb.sb.length()
+	     && moreToRead) {
+        readData();
+      } else if(rp.getRegex().matchAt(wrap,rb.epos)) {
+	if(wrap.overRun) {
+	  readData();
+	} else {
+	  StringBufferWrap sbw = new StringBufferWrap();
+	  StringBufferLike sbl = new StringBufferLike(sbw);
+	  /*
+          ReplaceRule rr = rex.getReplaceRule();
+	  while(rr != null) {
+	    rr.apply(sbl,rex);
+	    rr = rr.next;
+	  }
+	  */
+	  Regex rex = rp.getRegex();
+	  int npos = rex.matchedTo();
+	  rp.setBuffer(sbl);
+	  rp.setSource(wrap);
+	  rp.setPos(npos);
+	  rp.apply(rex,rex.getReplaceRule());
+	  int opos = rb.epos;
+	  RBuffer rb2 = new RBuffer((StringBuffer)sbw.unwrap());
+	  rb2.epos = rb2.sb.length();
+	  RBuffer rb3 = new RBuffer(rb.sb);
+
+	  rb.next = rb2;
+	  rb2.next = rb3;
+
+	  if(npos == opos) {
+	    rb3.epos = npos+1;
+	    if(rb3.epos > rb3.sb.length()) {
+	      if(rb.pos >= rb.epos)
+	        rb = rb.next;
+	      rb3.pos = rb3.epos = 0;
+	      rb3.done = true;
+	      //break;
+	    }
+            rb3.pos = npos;
+	  } else {
+	    rb3.pos = rb3.epos = npos;
+	  }
+
+        }
+      } else {
+	if(wrap.overRun) {
+	  readData();
+        } else if(rb.epos<rb.sb.length()) {
+	  rb.epos++;
+        } else {
+	  break;
+	}
+      }
+    }
+  }
+  public int read() throws IOException {
+    if(rb.pos >= rb.epos) {
+      getMoreData();
+      if(rb.pos >= rb.epos)
+        return -1;
+    }
+    //ewe.sys.Vm.out().println(rb);
+    return rb.sb.charAt(rb.pos++);
+  }
+  public int read(char[] buf,int off,int len)
+    throws IOException
+  {
+    int c = -1;
+    int end = off+len;
+    for(int i=off;i<end;i++) {
+      c = read();
+      if(c < 0) {
+	if(i == off)
+	  return -1;
+        return i-off;
+      }
+      buf[i] = (char)c;
+    }
+    return len;
+  }
+  public void close()
+    throws IOException
+  {
+    r.close();
+  }
+
+  public boolean markSupported() { return false; }
+
+  /** Get the size of the working buffer.
+      The current buffer may be larger if
+      the pattern demands it. */
+  public int getBufferSize() {
+    return nmax;
+  }
+  /** Set the size of the working buffer.
+      The current buffer may be larger if
+      the pattern demands it. */
+  public void setBufferSize(int n) {
+    nmax = n;
+  }
+
+  int max_lines = 2;
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public int getMaxLines() { return max_lines; }
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public void setMaxLines(int ml) { max_lines = ml; }
+
+  char EOLchar = '\n';
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public char getEOLchar() {
+    return EOLchar;
+  }
+  /** This function no longer serves any purpose.
+      @deprecated
+      */
+  public void setEOLchar(char c) {
+    EOLchar = c;
+  }
+
+  public long skip(long d) throws IOException {
+    // This is probably inefficient, I just did it
+    // this way to avoid possible bugs.
+    long n = 0;
+    while(n<d && read() != -1)
+      n++;
+    return n;
+  }
+
+  /*
+  static void test(String re,String inp,int n) throws Exception {
+    Reader r = new StringReader(inp);
+    r = new BufferedReader(r);
+    Regex rex = Regex.perlCode(re);
+    String res1 = rex.replaceAll(inp);
+    int c = -1;
+    StringBuffer sb = new StringBuffer();
+    RegexReader rr = new RegexReader(rex,r);
+    rr.setBufferSize(n);
+    while( (c = rr.read()) != -1)
+      sb.append((char)c);
+    String res2 = sb.toString();
+    if(!res1.equals(res2)) {
+      ewe.sys.Vm.out().println("nmax="+n);
+      ewe.sys.Vm.out().println("re="+re);
+      ewe.sys.Vm.out().println("inp="+inp);
+      ewe.sys.Vm.out().println("res1="+res1);
+      ewe.sys.Vm.out().println("res2="+res2);
+      System.exit(255);
+    }
+  }
+  public static void main(String[] args) throws Exception {
+    for(int n=6;n<15;n++) {
+      test("s/x/y/","-----x123456789",n);
+      test("s/x/y/","x123456789",n);
+      test("s/x/y/","-----x",n);
+      test("s/x.*?x/y/",".xx..x..x...x...x....x....x",n);
+      test("s/x.*x/[$&]/","--x........x--xx",n);
+      test("s/x.*x/[$&]/","--x........x------",n);
+      test("s/.$/a/m","bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbbbbbbbbbbbb",n);
+      test("s/.$/a/","123",n);
+      test("s/.$/a/","bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb",n);
+      test("s/^./a/","bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb",n);
+      test("s/$/a/","bbb",n);
+      test("s/^/a/","bbb",n);
+      test("s/^/a/","",n);
+      test("s{.*}{N}","xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",n);
+      test("s/.{0,7}/y/","AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",n);
+      test("s/x/$&/","xxx",n);
+    }
+    ewe.sys.Vm.out().println("Success!!!");
+  }
+  */
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegexReader.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,110 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.*;
+/** 
+        Shareware: package pat
+   <a href="copyright.html">Copyright 2001, Steven R. Brandt</a>
+*/ /**
+The RegexTokenizer is similar to the StringTokenizer class
+provided with java, but allows one to tokenize using
+regular expressions, rather than a simple list of characters.
+Tokens are any strings between the supplied regular expression,
+as well as any backreferences (things in parenthesis)
+contained within the regular expression. */
+public class RegexTokenizer implements Enumeration {
+    String toParse;
+    Regex r;
+    int count = 0;
+    Vector v = new Vector();
+    Vector vi = new Vector();
+    int pos=0;
+
+    int offset = 1;
+    void getMore() {
+        String s = r.right();
+        if(r.searchFrom(toParse,pos)) {
+            v.addElement(r.left().substring(pos));
+            vi.addElement(new Integer(r.matchFrom()+
+                r.charsMatched()));
+            for(int i=0;i<r.numSubs();i++)
+                if(r.substring() != null) {
+                    v.addElement(r.substring(i+offset));
+                    vi.addElement(
+                        new Integer(r.matchFrom(i+offset)+
+                        r.charsMatched(i+offset)));
+                }
+            pos = r.matchFrom()+r.charsMatched();
+        } else if(s != null) v.addElement(s);
+    }
+
+    /** Initialize the tokenizer with a string of text and a pattern */
+    public RegexTokenizer(String txt,String ptrn) {
+        toParse = txt;
+        r = new Regex(ptrn);
+        offset = r.BackRefOffset;
+        getMore();
+    }
+    /** Initialize the tokenizer with a Regex object. */
+    public RegexTokenizer(String txt,Regex r) {
+        toParse = txt;
+        this.r = r;
+        offset = r.BackRefOffset;
+        getMore();
+    }
+    /** This should always be cast to a String, as in StringTokenizer,
+         and as in StringTokenizer one can do this by calling
+         nextString(). */
+    public Object nextElement() {
+        if(count >= v.size()) getMore();
+        return v.elementAt(count++);
+    }
+    /** This is the equivalent (String)nextElement(). */
+    public String nextToken() { return (String)nextElement(); }
+    /** This asks for the next token, and changes the pattern
+         being used at the same time. */
+    public String nextToken(String newpat) {
+        try { r.compile(newpat); } catch (RegSyntax r_) {}
+        return nextToken(r);
+    }
+    /** This asks for the next token, and changes the pattern
+         being used at the same time. */
+    public String nextToken(Regex nr) {
+        r = nr;
+        if(vi.size() > count) {
+            pos = ((Integer)vi.elementAt(count)).intValue();
+            v.setSize(count);
+            vi.setSize(count);
+        }
+        getMore();
+        return nextToken();
+    }
+    /** Tells whether there are more tokens in the pattern. */
+    public boolean hasMoreElements() {
+        if(count >= v.size()) getMore();
+        return count < v.size();
+    }
+    /** Tells whether there are more tokens in the pattern, but
+         in the fashion of StringTokenizer. */
+    public boolean hasMoreTokens() { return hasMoreElements(); }
+    /** Determines the # of remaining tokens */
+    public int countTokens() {
+        int old_pos=pos,_count=count;
+        while(hasMoreTokens())
+            nextToken();
+        count=_count;
+        return v.size()-count;
+    }
+    /** Returns all tokens in the String */
+    public String[] allTokens() {
+        countTokens();
+        String[] ret = new String[v.size()];
+        v.copyInto(ret);
+        return ret;
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegexTokenizer.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RegexWriter.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegexWriter.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RegexWriter.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RegexWriter.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RegexWriter.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,206 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import ewe.io.*;
+
+import com.stevesoft.ewe_pat.wrap.*;
+
+/** A basic extension of FilterWriter that uses Transformer
+ to make replacements in data as it is written out.  It attempts
+ to transform a string whenever the End-of-Line (EOL) character
+ is written (which is, by default, the carriage return '\n').
+ Only the transformed portion of the line is written out, allowing
+ the RegexWriter to wait until a complete pattern is present before
+ attempting to write out info.  Until a pattern completes, data is
+ stored in a StringBuffer -- which can be accessed through the
+ length() and charAt() methods of this class.
+ <p>
+ Note a subtlety here -- while a Transformer normally matches
+ at higher priority against the pattern added to it first, this
+ will not necessarily be true when a multi-line match is in progress
+ because one of the complete multi-line patterns may not be completely
+ loaded in RegexWriter's buffer.  For this reason, the Transformer
+ class is equipped with a way to add a pattern and replacement rule
+ in three pieces -- a beginning (once this matches, nothing else in
+ the Transformer can match until the whole pattern matches), an
+ ending (the whole pattern is a String formed by adding the beginning
+ and ending), and a ReplaceRule.
+ <p>
+ An illustration of this is given in the this
+ <a href="../test/trans.java">example.</a>
+ */
+public class RegexWriter extends Writer {
+    Replacer repr;
+    Writer w;
+    WriterWrap ww;
+    StringBuffer sb = new StringBuffer();
+    PartialBuffer wrap = new PartialBuffer(sb);
+    int pos, epos;
+    int interval = 128;
+    int bufferSize = 2*1024;
+
+    public RegexWriter(Transformer t,Writer w) {
+	this.w = w;
+        ww = new WriterWrap(w);
+        repr = t.getReplacer();
+	repr.setBuffer(new StringBufferLike(ww));
+	repr.setSource(wrap);
+    }
+    public RegexWriter(Regex r,Writer w) {
+	this.w = w;
+        ww = new WriterWrap(w);
+        repr = r.getReplacer();
+	repr.setBuffer(new StringBufferLike(ww));
+	repr.setSource(wrap);
+    }
+
+    char EOLchar = '\n';
+    /** This method no longer serves any purpose.
+        @deprecated
+      */
+    public char getEOLchar() {
+        return EOLchar;
+    }
+    /** This method no longer serves any purpose.
+     @deprecated
+     */
+    public void setEOLchar(char c) {
+        EOLchar = c;
+    }
+
+    int max_lines=2;
+    /** This method no longer serves any purpose.
+     @deprecated
+     */
+    public int getMaxLines() { return max_lines; }
+    /** This method no longer serves any purpose.
+     @deprecated
+     */
+    public void setMaxLines(int ml) { max_lines = ml; }
+
+    void write() throws IOException {
+      Regex rex = repr.getRegex();
+      int eposOld = epos;
+      if(rex.matchAt(wrap,epos) && !wrap.overRun) {
+        while(pos < epos)
+          w.write(sb.charAt(pos++));
+        int to = rex.matchedTo();
+	repr.setPos(to);
+	repr.apply(rex,rex.getReplaceRule());
+	epos = pos = to;
+	if(epos == eposOld && epos < sb.length())
+	  epos++;
+      } else if(!wrap.overRun && epos < sb.length()) {
+        epos++;
+      }
+      while(pos < epos)
+        w.write(sb.charAt(pos++));
+      if(epos == sb.length()) {
+	sb.setLength(1);
+	pos = epos = 1;
+      } else if(pos > bufferSize) {
+        for(int i=bufferSize;i<sb.length();i++)
+	  sb.setCharAt(i-bufferSize,sb.charAt(i));
+        pos -= bufferSize;
+	epos -= bufferSize;
+	sb.setLength(sb.length()-bufferSize);
+      }
+    }
+
+    public void write(char[] ca,int b,int n) throws IOException {
+      int m = b+n;
+      for(int i=b;i<m;i++) {
+        sb.append(ca[i]);
+	if(sb.length() % interval == interval - 1) {
+	  wrap.overRun = false;
+          while(epos+interval < sb.length() && !wrap.overRun) {
+            write();
+	  }
+        }
+      }
+    }
+
+    public void flush() throws IOException {
+    }
+
+    public void close() throws IOException {
+	wrap.allowOverRun = false;
+	wrap.overRun = false;
+	while(epos < sb.length())
+	  write();
+	write();
+	w.close();
+    }
+
+    /** The current size of the StringBuffer in use by RegexWriter. */
+    public int length() { return sb.length(); }
+
+    /** The character at location i in the StringBuffer. */
+    public char charAt(int i) { return sb.charAt(i); }
+
+    /** Set the interval at which regex patterns are checked. */
+    public void setInterval(int i) {
+      interval = i;
+    }
+
+    /** Get the interval at which regex matches are checked. */
+    public int getInterval() {
+      return interval;
+    }
+
+    /** Get the buffer size. */
+    public int getBufferSize() {
+      return bufferSize;
+    }
+
+    /** Set the buffer size. */
+    public void setBufferSize(int i) {
+      bufferSize = i;
+    }
+
+  static void test(String re,String inp,int n) throws Exception {
+    StringWriter sw = new StringWriter();
+    Regex rex = Regex.perlCode(re);
+    String res1 = rex.replaceAll(inp);
+    RegexWriter rw = new RegexWriter(rex,sw);
+    for(int i=0;i<inp.length();i++)
+      rw.write(inp.charAt(i));
+    rw.close();
+    String res2 = sw.toString();
+    if(!res1.equals(res2)) {
+      ewe.sys.Vm.out().println("nmax="+n);
+      ewe.sys.Vm.out().println("re="+re);
+      ewe.sys.Vm.out().println("inp="+inp);
+      ewe.sys.Vm.out().println("res1="+res1);
+      ewe.sys.Vm.out().println("res2="+res2);
+      System.exit(255);
+    }
+  }
+  public static void main(String[] args) throws Exception {
+    for(int n=1;n<=1;n++) {
+      test("s/x/y/","-----x123456789",n);
+      test("s/x/y/","x123456789",n);
+      test("s/x/y/","-----x",n);
+      test("s/x.*?x/y/",".xx..x..x...x...x....x....x",n);
+      test("s/x.*x/[$&]/","--x........x--xx",n);
+      test("s/x.*x/[$&]/","--x........x------",n);
+      test("s/.$/a/m","bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbbbbbbbbbbbb",n);
+      test("s/.$/a/","123",n);
+      test("s/.$/a/","bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb",n);
+      test("s/^./a/","bb\nbbb\nbbbb\nbbbbb\nbbbbbb\nbb",n);
+      test("s/$/a/","bbb",n);
+      test("s/^/a/","bbb",n);
+      test("s/^/a/","",n);
+      test("s{.*}{N}","xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",n);
+      test("s/.{0,7}/y/","AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",n);
+      test("s/x/$&/","xxx",n);
+    }
+    ewe.sys.Vm.out().println("Success!!!");
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RegexWriter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,255 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import ewe.util.*;
+
+/** ReplaceRule is a singly linked list of Objects which describe how
+    to replace the matched portion of a String.  The only member method
+    that you absolutely need to define to use this class is apply(StringBuffer,RegRes) --
+    although you may want define toString1() and clone1() (if you are
+    unhappy with the default methods) that are needed by
+    the clone() or toString() methods on this class.
+    During the replacement process, each ReplaceRule tells the replacer
+    what to add to StringBuffer and uses the contents of the Regular
+    expression result to get the information it needs to
+    do this.  Here is an <a href="http://javaregex.com/code/fancy.java.html">example</a>
+
+    @see com.stevesoft.ewe_pat.NullRule
+    @see com.stevesoft.ewe_pat.AmpersandRule
+    @see com.stevesoft.ewe_pat.BackRefRule
+    @see com.stevesoft.ewe_pat.LeftRule
+    @see com.stevesoft.ewe_pat.RightRule
+    @see com.stevesoft.ewe_pat.StringRule
+    */
+public abstract class ReplaceRule {
+    /** points to the next ReplaceRule in the linked list. */
+    protected ReplaceRule next = null;
+    /** This function appends to the StringBufferLike the text you want
+        to replaced the portion of the String last matched. */
+    public abstract void apply(StringBufferLike sb,RegRes r);
+
+    /** A rule describing how to clone only the current ReplaceRule,
+        and none of the others in this linked list.  It is called by
+        clone() for each item in the list. */
+    public Object clone1() {
+        return new RuleHolder(this);
+    }
+    public final Object clone() {
+        ReplaceRule x = (ReplaceRule)clone1();
+        ReplaceRule xsav = x;
+        ReplaceRule y = this;
+        while(y.next != null) {
+            x.next = (ReplaceRule)y.next.clone1();
+            x.name = y.name;
+            x = x.next;
+            y = y.next;
+        }
+        return xsav;
+    }
+    static ReplaceRule add(ReplaceRule head,ReplaceRule adding) {
+        if(head == null)
+            return head = adding;
+        head.addRule(adding);
+        return head;
+    }
+    public ReplaceRule add(ReplaceRule adding) {
+        return add(this,adding);
+    }
+    /** Add another ReplaceRule to the linked list. */
+    public void addRule(ReplaceRule r) {
+        if(next == null) next = r;
+        else next.addRule(r);
+    }
+    static Regex getvar = null;
+    final static Regex getv() {
+        // Thanks to Michael Jimenez for pointing out the need
+        // to clone getvar rather than simply returning it.
+        // Previously this was not thread safe.
+        //if(getvar != null) return getvar;
+        if(getvar != null) return (Regex)getvar.clone();
+        getvar=
+            new Regex(
+	    "(?:\\\\(\\d+)|"+ // ref 1
+	    "\\$(?:"+
+	      "(\\d+)|"+ // ref 2
+	      "(\\w+)|"+ // ref 3
+              "([&'`])|"+ // ref 4
+	      "\\{(?:(\\d+)|"+ // ref 5
+	        "([^\n}\\\\]+))}"+ // ref 6
+	      ")|"+ 
+	    "\\\\([nrbtaef])|"+ // ref 7
+	    "\\\\c([\u0000-\uFFFF])|"+ // ref 8
+	    "\\\\x([A-Fa-f0-9]{2})|"+ // ref 9
+	    "\\\\([\u0000-\uFFFF])"+ // ref 10
+	    ")");
+        getvar.optimize();
+        return getvar;
+    }
+    /** Compile a ReplaceRule using the text that would go between
+        the second and third /'s in a typical substitution pattern
+        in Perl: s/ ... / <i>The argument to ReplaceRule.perlCode</i> /.
+        */
+    public static ReplaceRule perlCode(String s) {
+        //String sav_backGs = Regex.backGs;
+        //int sav_backGto = Regex.backGto;
+        try {
+            int mf = 0, mt = 0;
+            Regex gv = getv();
+            ReplaceRule head = null;
+            Object tmp = null;
+            while(gv.searchFrom(s,mt)) {
+                int off=Regex.BackRefOffset-1;
+                mf = gv.matchedFrom();
+                if(mf > mt)
+                    head=add(head,
+                        new StringRule(s.substring(mt,mf)));
+                String var = null;
+                if((var=gv.stringMatched(1+off)) != null
+                        || (var=gv.stringMatched(2+off)) != null
+                        || (var=gv.stringMatched(5+off)) != null) {
+                    int d=0;
+                    for(int i=0;i<var.length();i++)
+                        d = 8*d+( var.charAt(i)-'0' );
+		    if(var.length() == 1)
+                      head=add(head,new BackRefRule(d));
+		    else
+		      head=new StringRule(""+(char)d);
+                } else if(
+                        (var=gv.stringMatched(10+off)) != null) {
+                    if("QELlUu".indexOf(var) >= 0)
+                        head=add(head,new CodeRule(var.charAt(0)) );
+                    else
+                        head=add(head,new StringRule(var) );
+                } else if(
+                        (var=gv.stringMatched(3+off)) != null
+                        || (var=gv.stringMatched(4+off)) != null
+                        || (var=gv.stringMatched(6+off)) != null) {
+                    String arg = "";
+                    int pc;
+                    if((pc=var.indexOf(':')) > 0) {
+                        arg = var.substring(pc+1);
+                        var = var.substring(0,pc);
+                    }
+                    if(var.equals("&")||var.equals("MATCH")) {
+                        head=add(head,new AmpersandRule());
+                    } else if(var.equals("`")||var.equals("PREMATCH")) {
+                        head=add(head,new LeftRule());
+                    } else if(var.equals("'")||var.equals("POSTMATCH")) {
+                        head=add(head,new RightRule());
+                    } else if(var.equals("WANT_MORE_TEXT")) {
+                        head=add(head,new WantMoreTextReplaceRule());
+                    } else if(var.equals("POP")) {
+                        head=add(head,new PopRule());
+                    } else if(var.startsWith("+") && (tmp=defs.get(var.substring(1))) != null) {
+                        if(tmp instanceof Regex)
+                            head=add(head,new PushRule(var.substring(1),(Regex)tmp));
+                        else if(tmp instanceof Transformer)
+                            head=add(head,new PushRule(var.substring(1),(Transformer)tmp));
+                        else head=add(head,new StringRule("${"+var+"}"));
+                    } else if(var.startsWith("=") && (tmp=defs.get(var.substring(1))) != null) {
+                        if(tmp instanceof Regex)
+                            head=add(head,new ChangeRule(var.substring(1),(Regex)tmp));
+                        else if(tmp instanceof Transformer)
+                            head=add(head,new ChangeRule(var.substring(1),(Transformer)tmp));
+                        else head=add(head,new StringRule("${"+var+"}"));
+                    } else if( (tmp=defs.get(var)) != null) {
+                        if(tmp instanceof ReplaceRule) {
+                            ReplaceRule alt = ((ReplaceRule)tmp).arg(arg);
+                            if(alt == null) alt = ((ReplaceRule)tmp);
+                            head=add(head,(ReplaceRule)(alt.clone()));
+                        }
+                    } else // can't figure out how to transform this thing...
+                        head=add(head,new StringRule("${"+var+"}"));
+                } else if(
+		  (var = gv.stringMatched(7+off)) != null) {
+		  char c = var.charAt(0);
+		  if(c == 'n')
+		    head=add(head,new StringRule("\n"));
+		  else if(c == 't')
+		    head=add(head,new StringRule("\t"));
+		  else if(c == 'r')
+		    head=add(head,new StringRule("\r"));
+		  else if(c == 'b')
+		    head=add(head,new StringRule("\r"));
+		  else if(c == 'a')
+		    head=add(head,new StringRule(""+(char)7));
+		  else if(c == 'e')
+		    head=add(head,new StringRule(""+(char)27));
+		  else if(c == 'f')
+		    head=add(head,new StringRule(""+(char)12));
+		} else if(
+		  (var = gv.stringMatched(8+off)) != null) {
+		  char c = var.charAt(0);
+		  if(c < Ctrl.cmap.length)
+		    c = Ctrl.cmap[c];
+		  head=add(head,new StringRule(""+c));
+		} else if(
+		  (var = gv.stringMatched(9+off)) != null) {
+		  int d =
+		    16*getHexDigit(var.charAt(0))+
+		    getHexDigit(var.charAt(1));
+		  head=add(head,new StringRule(""+(char)d));
+		}
+                mt = gv.matchedTo();
+            }
+            if(mt <= s.length())
+                head=add(head,new StringRule(s.substring(mt)));
+            return head;
+        } finally {
+            //Regex.backGs = sav_backGs;
+            //Regex.backGto = sav_backGto;
+        }
+    }
+    static Hashtable defs = new Hashtable();
+    public static boolean isDefined(String s) { return defs.get(s) != null; }
+    public static void define(String s,Regex r) { defs.put(s,r); }
+    public static void define(String s,ReplaceRule r) {
+        defs.put(s,r);
+        r.name = s;
+    }
+    String name = getClass().getName();
+    public static void define(String s,Transformer t) { defs.put(s,t); }
+    public static void undefine(String s) { defs.remove(s); }
+    /** This tells how to convert just the current element (and none
+        of the other items in the linked list) to a String. This
+        method is called by toString() for each item in the linked
+        list. */
+    public String toString1() {
+        return "${"+name+"}";
+    }
+    /** Convert to a String. */
+    public final String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(toString1());
+        ReplaceRule rr = this.next;
+        while(rr != null) {
+            sb.append(rr.toString1());
+            rr = rr.next;
+        }
+        return sb.toString();
+    }
+    /** Modified the behavior of a ReplaceRule by supplying
+        an argument.  If a ReplaceRule named "foo" is defined
+        and the pattern "s/x/${foo:5}/" is given to Regex.perlCode,
+        then the "foo" the definition of "foo" will be retrieved
+        and arg("5") will be called.  If the result is non-null,
+        that is the ReplaceRule that will be used.  If the result
+        is null, then the pattern works just as if it were
+        "s/x/${foo}/".
+        @see com.stevesoft.ewe_pat.Validator#arg(java.lang.String)
+        */
+    public ReplaceRule arg(String s) { return null; }
+    static int getHexDigit(char c) {
+      if(c >= '0' && c <= '9')
+        return c - '0';
+      if(c >= 'a' && c <= 'f')
+        return c - 'a'+10;
+      return c - 'A'+10;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/ReplaceRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Replacer.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Replacer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Replacer.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Replacer.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Replacer.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,262 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import ewe.util.*;
+
+import com.stevesoft.ewe_pat.wrap.StringWrap;
+
+/** Internally used class. */
+class RegHolder {
+    Regex me = null;
+    RegHolder prev = null;
+}
+
+/** Internally used class.
+  * @see CodeRule
+  */
+class CodeVal {
+    int pos;
+    char code;
+    CodeVal(int p,char c) {
+        pos = p;
+        code = c;
+    }
+    public String toString() {
+        return "("+pos+","+code+")";
+    }
+}
+
+/**
+  To use this class, first use either the getReplacer() method from
+  Transformer or Regex.  You can then use replaceAll, replaceFirst,
+  etc. methods on the Replacer in the same way that you can from
+  either of those two classes.
+  <p>
+  The only potential difference between using the methods of
+  Replacer to do the replacing is that Replacer remembers changes
+  to the replacing object between calls to replaceAll, replaceFirst
+  etc.  For details, see the example file
+  <a href="http://javaregex.com/code/trans3.java.html">trans3.java</a>.
+  @see com.stevesoft.ewe_pat.Transformer
+  @see com.stevesoft.ewe_pat.Regex
+*/
+public class Replacer {
+    boolean first;
+
+    /** Instantiate a new Replacer. */
+    public Replacer() {}
+
+    public StringLike replaceFirstRegion(String s,Regex r,
+        int start,int end) {
+        return replaceFirstRegion(new StringWrap(s),r,start,end);
+    }
+    /** This method replaces the first occurence of the Regex in the
+        String starting with position pos
+        according to the Replacer rule of this object. */
+    public StringLike replaceFirstRegion(StringLike s,Regex r,
+        int start,int end) {
+        first = true;
+        rh.me = r;
+        rh.prev = null;
+        return dorep(s,start,end);
+    }
+    public StringLike replaceFirst(StringLike s) {
+        return replaceFirstRegion(s,0,s.length());
+    }
+    public StringLike replaceFirstFrom(StringLike s,int start) {
+        return replaceFirstRegion(s,start,s.length());
+    }
+    public StringLike replaceFirstRegion(StringLike s,int start,int end) {
+        first = true;
+        return dorep(s,start,end);
+    }
+
+    RegHolder rh = new RegHolder();
+
+    public StringLike replaceAllRegion(String s,Regex r,
+        int start, int end) {
+        return replaceAllRegion(new StringWrap(s),r,start,end);
+    }
+    /** This method replaces all occurences of the Regex in the
+        String starting with postition pos
+        according to the Replacer rule of this object. */
+    public StringLike replaceAllRegion(StringLike s,Regex r,
+        int start,int end) {
+        first = false;
+        // reset
+        rh.me = r;
+        rh.prev = null;
+        return dorep(s,start,end);
+    }
+    public StringLike replaceAll(StringLike s) {
+        return replaceAllRegion(s,0,s.length());
+    }
+    public StringLike replaceAllFrom(StringLike s,int start) {
+        return replaceAllRegion(s,start,s.length());
+    }
+    public StringLike replaceAllRegion(StringLike s,int start,int end) {
+        first = false;
+        return dorep(s,start,end);
+    }
+
+    public String replaceAll(String s) {
+        return replaceAllRegion(new StringWrap(s),0,s.length()).toString();
+    }
+    public String replaceAllFrom(String s,int start) {
+        return replaceAllRegion(new StringWrap(s),start,s.length()).toString();
+    }
+    public String replaceAllRegion(String s,int start,int end) {
+        first = false;
+        return dorep(new StringWrap(s),start,end).toString();
+    }
+
+    final public boolean isSpecial(ReplaceRule x) {
+        while(x != null) {
+            if(x instanceof SpecialRule
+                    || (x instanceof RuleHolder && ((RuleHolder)x).held instanceof SpecialRule))
+                return true;
+            x = x.next;
+        }
+        return false;
+    }
+    final public void apply1(RegRes rr) {
+        rr.charsMatched_++;
+        apply(rr,null);
+        rr.charsMatched_--;
+    }
+
+    final StringLike dorep(StringLike s,int start,int end) {
+        StringLike ret = s;
+        want_more_text = false;
+        lastMatchedTo = 0;
+        if(rh.me == null)
+            throw new NullPointerException("Replacer has null Regex pointer");
+        if(rh.me._search(s,start,end)) {
+            int rmn = rh.me.matchedTo();
+            if(rh.me.charsMatched()==0 && !isSpecial(rh.me.getReplaceRule())) {
+                apply1(rh.me);
+                rmn++;
+            }
+            apply(rh.me);
+            if(!first)
+                for(int i=rmn;
+                        !want_more_text && rh.me._search(s,i,end);i=rmn) {
+                    rmn = rh.me.matchedTo();
+                    if(rh.me.charsMatched()==0) {
+                        if(!isSpecial(rh.me.getReplaceRule()))
+                            apply1(rh.me);
+                        rmn++;
+                    }
+                    apply(rh.me);
+                }
+            ret = finish();
+            ret = ret == null ? s : ret;
+        }
+        return ret;
+    }
+
+    StringBufferLike sb = null;
+    StringLike src = null;
+    int pos = 0;
+    /** This method allows you to apply the results of several
+        matches in a sequence to modify a String of text.  Each
+        call in the sequence must operate on the same piece of
+        text and the matchedFrom() of each RegRes given to this
+        method must be greater in value than the preceeding
+        RegRes's matchedTo() value.
+        */
+    public void apply(RegRes r,ReplaceRule rp) {
+        if(rp==null ||(rp.next == null && rp instanceof AmpersandRule))
+            return;
+        if(r.didMatch()) {
+            if(src == null)
+                src = r.getStringLike();
+	    if(sb == null)
+                sb = new StringBufferLike(src.newStringBufferLike());
+            int rmf = r.matchedFrom();
+            for(int ii=pos;ii<rmf;ii++)
+              sb.append(src.charAt(ii));
+
+            Vector v = new Vector();
+            for(ReplaceRule x=rp;x != null;x=x.next) {
+                x.apply(sb,r);
+                if(x instanceof SpecialRule) {
+                    if(x instanceof WantMoreTextReplaceRule
+                            && want_more_text_enable)
+                        want_more_text = true;
+                    else if(x instanceof PushRule) {
+                        RegHolder rh2 = new RegHolder();
+                        rh2.me = ( (PushRule)x ).NewRule;
+                        rh2.prev = rh;
+                        rh = rh2;
+                    } else if(x instanceof PopRule) {
+                        if(rh.prev != null)
+                            rh = rh.prev;
+                    } else if(x instanceof ChangeRule) {
+                        rh.me = ( (ChangeRule) x).NewRule;
+                    }
+                }
+            }
+            if(!want_more_text)
+                pos = r.matchedTo();
+        }
+    }
+    boolean want_more_text = false, want_more_text_enable = false;
+    public boolean WantMoreText() { return want_more_text; }
+    /** Another form of apply, it is the same as
+        apply(r,r.getReplaceRule()). */
+    public void apply(Regex r) { apply(r,r.getReplaceRule()); }
+
+    /** This finishes the replacement, appending the right() part of
+        the last RegRes given to substitute(RegRes).  After this method
+        is called, the Replace object is reset to perform another
+        substitution. If no RegRes objects with a true didMatch are
+        applied, this returns null. */
+    public StringLike finish() {
+        if(src==null)
+            return null;
+        //sb.append(src.substring(pos,src.length()));
+        int s_end = src.length();
+        for(int ii=pos;ii<s_end;ii++)
+          sb.append(src.charAt(ii));
+        src = null;
+        lastMatchedTo = pos;
+        pos = 0;
+        StringLike retstr = sb.toStringLike();
+        sb = null;
+        return retstr;
+    }
+    int lastMatchedTo = 0;
+    public Object clone() {
+        Replacer r = new Replacer();
+        r.first = first;
+        r.src = src;
+        r.sb = sb;
+        r.pos = pos;
+        r.lastMatchedTo = lastMatchedTo;
+        r.want_more_text = want_more_text;
+        r.want_more_text_enable = want_more_text_enable;
+        r.rh.me = rh.me;
+        r.rh.prev = rh.prev;
+        return r;
+    }
+    public int lastMatchedTo() { return lastMatchedTo; }
+    public Regex getRegex() {
+      return rh.me;
+    }
+    public void setSource(StringLike sl) {
+      src = sl;
+    }
+    public void setBuffer(StringBufferLike sbl) {
+      sb = sbl;
+    }
+    public void setPos(int pos) {
+      this.pos = pos;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Replacer.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RightRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RightRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RightRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RightRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RightRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** The apply(StringBufferLike sb,RegRes res) method of this derivation
+    of ReplaceRule appends the contents of res.right() to the     StringBufferLike sb.
+    @see com.stevesoft.ewe_pat.ReplaceRule
+    */
+public class RightRule extends ReplaceRule {
+    public RightRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(res.right());
+    }
+    public String toString1() {
+        return "$'";
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RightRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Rthings.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Rthings.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Rthings.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Rthings.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Rthings.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,44 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** 
+        Shareware: package pat
+   <a href="copyright.html">Copyright 2001, Steven R. Brandt</a>
+*/ /**
+This class only exists to store data needed during the
+compilation of a regular expression. */
+public class Rthings {
+    /** The numeric identity of the next () to be encountered
+         while compiling the pattern. */
+    public int val=Regex.BackRefOffset;
+    /** Needed in case (?i) is encountered, to pass back the
+         message that ignoreCase should be set. */
+    public boolean ignoreCase;
+    /** Needed in case (?Q) is encountered, to pass back the
+         message that dontMatchInQuotes should be set. */
+    public boolean dontMatchInQuotes;
+    public boolean optimizeMe = false;
+    public boolean noBackRefs = false;
+    public int parenLevel = 0;
+    boolean gFlag = false, mFlag = false, sFlag = false;
+    Pattern p;
+    Or o;
+    Rthings(Regex r) {
+        ignoreCase = r.ignoreCase;
+        dontMatchInQuotes = r.dontMatchInQuotes;
+    }
+    void set(Regex r) {
+        r.gFlag = gFlag;
+	r.mFlag = mFlag;
+	r.sFlag = sFlag;
+        r.ignoreCase = ignoreCase;
+        r.dontMatchInQuotes = dontMatchInQuotes;
+        if(optimizeMe) r.optimize();
+    }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Rthings.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/RuleHolder.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RuleHolder.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/RuleHolder.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/RuleHolder.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/RuleHolder.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,20 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+/** This class is used internally. */
+class RuleHolder extends ReplaceRule {
+    ReplaceRule held = null;
+    RuleHolder() {}
+    RuleHolder(ReplaceRule h) { held = h; }
+    public Object clone1() { return new RuleHolder(held); }
+    public String toString1() { return held.toString1(); }
+    public void apply(StringBufferLike sb,RegRes rr) {
+        held.apply(sb,rr);
+    }
+    public ReplaceRule arg(String s) { return new RuleHolder(held.arg(s)); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/RuleHolder.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Skip.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Skip.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Skip.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Skip.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Skip.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,127 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class is used internally to search ahead for some
+    optimized Regex objects.  It searches within a String
+    for occrences of a given String -- like a more flexible
+    version of String.indexOf.
+    @see com.stevesoft.ewe_pat.Skip2
+    @see com.stevesoft.ewe_pat.SkipBMH
+    */
+public class Skip {
+    static int mkmask(int c) {
+        char x = (char)c;
+        return ~( CaseMgr.toUpperCase(x) |
+            CaseMgr.toLowerCase(x) |
+            CaseMgr.toTitleCase(x));
+    }
+    static { int x = Regex.BackRefOffset; }
+    String src;
+    int c,mask;
+    int offset;
+    boolean ign,m1;
+    /** Examine a Regex to determine what String it will
+        attempt to skip to when searching for patterns.
+        Return -1 if we aren't doing this. */
+    public static String string(Regex r) {
+        return r.skipper == null ? null : r.skipper.src;
+    }
+    /** Determine the offset of the String within the pattern
+        that we are skipping to. Return -1 if we aren't doing
+        this.  */
+    public static int offset(Regex r) {
+        return r.skipper == null ? -1 : r.skipper.offset;
+    }
+    /** Initialize, give it a String to search for, tell it
+        whether or not to ignoreCase, and what the offset is
+        of the String within the String to be searched. */
+    public Skip(String s,boolean ign,int o) {
+        src = s;
+        c = s.charAt(0);
+        if(ign) {
+            mask = mkmask(c);
+        } else mask = 0;
+        offset = o;
+        this.ign = ign;
+        m1 = (s.length()==1);
+    }
+    /** The same as find(s,0,s.length()) */
+    public final int find(StringLike s) {
+        return find(s,0,s.length());
+    }
+    static final int min(int a,int b) { return a<b ? a : b; }
+    /** Searches a given region of text beginning at position start
+        and ending at position end for the skip object. */
+    public int find(StringLike s,int start,int end) {
+        if(start > end) return -1;
+        start += offset;
+        int vend = min(s.length()-1,end+offset);
+        if(mask != c) {
+            for(int i=start;i<=vend;i++)
+                if(0 == (s.charAt(i) & mask))
+                    //if(m1||s.regionMatches(ign,i,src,0,src.length()) )
+                    if(m1||CaseMgr.regionMatches(s,ign,i,src,0,src.length()) )
+                        return i-offset;
+        } else {
+            for(int i=start;i<=vend;i++)
+                if(c == s.charAt(i))
+                    //if(m1||s.regionMatches(ign,i,src,0,src.length()) )
+                    if(m1||CaseMgr.regionMatches(s,ign,i,src,0,src.length()) )
+                        return i-offset;
+        }
+        return -1;
+    }
+    static Skip findSkip(Regex r) {
+        return findSkip(r.thePattern,r.ignoreCase,!r.dontMatchInQuotes);
+    }
+    // look for things that can be skipped
+    static Skip findSkip(Pattern p,boolean ignoreCase,boolean trnc) {
+        StringBuffer sb = new StringBuffer();
+        Skip subsk = null;
+        int offset = 0;
+        int skipc = -1,skipoff=0;
+        for(;p != null;p = p.next) {
+            if(p instanceof oneChar) {
+                skipc = ((oneChar)p).c;
+                skipoff = offset;
+            }
+            if(p instanceof oneChar && p.next instanceof oneChar) {
+                Pattern psav = p;
+                sb.append(((oneChar)p).c);
+                while(p.next instanceof oneChar) {
+                    sb.append(((oneChar)p.next).c);
+                    p = p.next;
+                }
+                String st = sb.toString();
+                char c0 = st.charAt(0), c1 = st.charAt(1);
+                Skip sk=null;
+                if(st.length()>2)
+                    sk = new SkipBMH(st,ignoreCase,offset);
+                else
+                    sk = new Skip2(st,ignoreCase,offset);
+                if(trnc && st.length()>2) { // chop out a whole string...
+                    psav.next = new Skipped(st.substring(1));
+                    psav.next.next = p.next;
+                    psav.next.parent = p.parent;
+                }
+                return sk;
+            } else if(p instanceof Or && ((Or)p).v.size()==1
+                    && !((Or)p).leftForm().equals("(?!")
+                    && null != (subsk=
+                    findSkip( (Pattern)((Or)p).v.elementAt(0),ignoreCase,trnc) )) {
+                subsk.offset += offset;
+                return subsk;
+            } else if(p.minChars().equals(p.maxChars())) {
+                offset += p.minChars().intValue();
+            } else return skipc < 0 ? null :
+                new Skip(""+(char)skipc,ignoreCase,skipoff);
+        }
+        return null;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Skip.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Skip2.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Skip2.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Skip2.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Skip2.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Skip2.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,38 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This is the same as Skip, except it needs a minimum
+    of two characters in the initializing String.
+    @see com.stevesoft.ewe_pat.Skip
+    @see com.stevesoft.ewe_pat.SkipBMH
+    */
+public class Skip2 extends Skip {
+    int c1,mask1;
+    public Skip2(String s,boolean ign,int offset) {
+        super(s,ign,offset);
+        c1 = s.charAt(1);
+        m1 = 2==s.length();
+        if(ign) {
+            mask1=mkmask(c1);
+        } else
+            mask1 = 0;
+    }
+    public int find(StringLike s,int start,int end) {
+        if(start > end) return -1;
+        start += offset;
+        int vend = min(s.length()-2,end+offset);
+        for(int i=start;i<=vend;i++)
+            if(0 == (s.charAt(i)&mask) && 0 == (s.charAt(i+1)&mask1)) {
+                //if(m1||s.regionMatches(ign,i,src,0,src.length()) )
+                if(m1||CaseMgr.regionMatches(s,ign,i,src,0,src.length()) )
+                    return i-offset;
+            }
+        return -1;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Skip2.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/SkipBMH.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/SkipBMH.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/SkipBMH.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/SkipBMH.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/SkipBMH.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,183 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import com.stevesoft.ewe_pat.wrap.StringWrap;
+
+/** Like Skip, but implements a
+    <a href="http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/713b.srch.p.html">
+    Boyer-Moore-Horspool</a> type search
+    method that has been modified to be more like a "T-search" (see
+    the Michael Tamm''s article in <i>C'T, magazin fuer computer und technic</i>, August 97
+    p 292).  Yet another important source of information for me was
+    the <a href="http://www.go2net.com/people/paulp/deep/1997/05/14/">
+    Deep Magic</a> article on string searching.  As of this writing, I can
+    beat String's indexOf method in many cases.
+    @see com.stevesoft.ewe_pat.Skip
+    @see com.stevesoft.ewe_pat.Skip2
+    */
+public class SkipBMH extends Skip {
+    // This number could be 256, but I think it's
+    // big enough.  Note, it must be a power of 2.
+    final int MAX_CHAR = 64;
+    final char[] skip = new char[MAX_CHAR];
+    int sm1;
+    int jump_ahead = 0;
+    char uc,lc,tc,x;
+    final boolean exact(char c) {
+        return (ign && anyc(c))||c==x;
+    }
+    final boolean anyc(char c) {
+        return c==uc||c==lc||c==tc;
+    }
+    public SkipBMH(String pt,boolean ign) { this(pt,ign,0); }
+    public SkipBMH(String pt) { this(pt,false,0); }
+    public SkipBMH(String pt,boolean ign,int offset) {
+        super(pt,ign,offset);
+        for(int k=0;k<MAX_CHAR;k++)
+            skip[k] = (char)src.length();
+
+        sm1 = src.length()-1;
+        x = src.charAt(sm1);
+        uc=CaseMgr.toUpperCase(x);
+        lc=CaseMgr.toLowerCase(x);
+        tc=CaseMgr.toTitleCase(x);
+
+        // We don't really want 65536 long arrays in skip[],
+        // so we mask of the higher bits.  This can be combined
+        // with ignore case, so accounting for upper
+        // case costs us nothing extra.
+        for(int k=0;k<src.length()-1;k++) {
+            char x_ = src.charAt(k);
+            if(ign) {
+                char uc_ = CaseMgr.toUpperCase(x_);
+                char lc_ = CaseMgr.toLowerCase(x_);
+                char tc_ = CaseMgr.toTitleCase(x_);
+                skip[uc_ & (MAX_CHAR-1)]=(char)(src.length()-k-1);
+                skip[lc_ & (MAX_CHAR-1)]=(char)(src.length()-k-1);
+                skip[tc_ & (MAX_CHAR-1)]=(char)(src.length()-k-1);
+            } else
+                skip[x_ & (MAX_CHAR-1)] = (char)(src.length()-k-1);
+        }
+
+        // This trick can be found in the July issue of
+        // C-T magazine.  This makes the method a type of
+        // "T-search."
+        jump_ahead = src.length()-1;
+        for(int k=0;k<src.length()-1;k++) {
+            char y=src.charAt(sm1-k-1);
+            if(exact(y)) {
+                jump_ahead = k;
+                break;
+            }
+        }
+    }
+    /** Set to true if you only want to compare two of the
+        characters in the String. */
+    final public int searchRegion(String s,int start,int end) {
+        return find(s,start,end);
+    }
+    final public int searchFrom(String s,int start) {
+        return find(s,start,s.length());
+    }
+    final public int search(String s) { return find(s,0,s.length()); }
+    public int find(String s,int start,int end) {
+        start += offset+sm1;
+        int vend = min(s.length()-1,end+sm1+offset),k;
+        int vend1 = vend-jump_ahead;
+        if(ign) {
+            for(k=start; k <= vend1;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k <= vend;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k > vend) return -1;
+                }
+            }
+        } else {
+            for(k=start; k <= vend1;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k <= vend;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k > vend) return -1;
+                }
+            }
+        }
+
+        return -1;
+    }
+    public int find(StringLike s,int start,int end) {
+        if(s instanceof StringWrap)
+          return find(s.toString(),start,end);
+        start += offset+sm1;
+        int vend = min(s.length()-1,end+sm1+offset),k;
+        int vend1 = vend-jump_ahead;
+        if(ign) {
+            for(k=start; k <= vend1;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k <= vend;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( anyc(s.charAt(k)) ) {
+                    if(CaseMgr.regionMatches(src,ign,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k > vend) return -1;
+                }
+            }
+        } else {
+            for(k=start; k <= vend1;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                }
+            }
+            for(; k <= vend;k += skip[s.charAt(k) & (MAX_CHAR-1)] ) {
+                // table look-up is expensive, avoid it if possible
+                if( x==s.charAt(k) ) {
+                    //if(src.regionMatches(0,s,k-sm1,sm1))
+                    if(CaseMgr.regionMatches(src,false,0,s,k-sm1,sm1))
+                        return k-sm1-offset;
+                    k += jump_ahead;
+                    if(k > vend) return -1;
+                }
+            }
+        }
+
+        return -1;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/SkipBMH.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Skipped.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Skipped.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Skipped.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Skipped.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Skipped.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,27 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Implements the (?&lt;number) Pattern, where number is
+ an integer telling us how far to back up in the Pattern.
+ Not in perl 5. */
+class Skipped extends Pattern {
+    String s;
+    Skipped(String s) { this.s = s; }
+    public String toString() { return s+nextString(); }
+    public int matchInternal(int pos,Pthings pt) {
+        //if(pt.no_check || s.regionMatches(pt.ignoreCase,0,pt.src,pos,s.length()))
+        if(pt.no_check || CaseMgr.regionMatches(s,pt.ignoreCase,0,pt.src,pos,s.length()))
+            return nextMatch(pos+s.length(),pt);
+        return -1;
+    }
+    public patInt minChars() { return new patInt(s.length()); }
+    public patInt maxChars() { return new patInt(s.length()); }
+    Pattern clone1(Hashtable h) { return new Skipped(s); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Skipped.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/SpecialRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/SpecialRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/SpecialRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/SpecialRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/SpecialRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,13 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+public class SpecialRule extends ReplaceRule {
+    public SpecialRule() {}
+    public void apply(StringBufferLike sb,RegRes rr) {}
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/SpecialRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/Start.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Start.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Start.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Start.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Start.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,31 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** The '^' or the '\A' Pattern, matches the start of a string. */
+class Start extends Pattern {
+    boolean retIsStart;
+    Start(boolean b) { retIsStart = b; }
+    public int matchInternal(int pos,Pthings pt) {
+        if(retIsStart
+	&& pt.mFlag
+	&& pos > 0 && pt.src.charAt(pos-1)=='\n')
+            return nextMatch(pos,pt);
+        if(pos == 0) return nextMatch(pos,pt);
+        return -1;
+    }
+    public String toString() {
+        if(retIsStart)
+            return "^"+nextString();
+        else
+            return "\\A"+nextString();
+    }
+    public patInt maxChars() { return new patInt(0); }
+    Pattern clone1(Hashtable h) { return new Start(retIsStart); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Start.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/StrPos.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StrPos.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/StrPos.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/StrPos.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/StrPos.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,117 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+/** 
+        Shareware: package pat
+   <a href="copyright.html">Copyright 2001, Steven R. Brandt</a>
+*/ /**
+StrPos is used internally by regex to parse the regular expression. */
+public class StrPos {
+    String s;
+    int pos;
+    /** Return the position in the string pointed to */
+    public int pos() { return pos; }
+
+    /** This contains the escape character, which is \ by default. */
+    public char esc=Pattern.ESC;
+    char c;
+    /** Returns the current, possibly escaped, character. */
+    public char thisChar() { return c; }
+
+    boolean dontMatch,eos;
+
+    /** tell whether we are at end of string */
+    public boolean eos() { return eos; }
+    /** initialize a StrPos from another StrPos. */
+    public StrPos(StrPos sp) {
+        dup(sp);
+    }
+    /** copy a StrPos from sp to this. */
+    public void dup(StrPos sp) {
+        s = sp.s;
+        pos = sp.pos;
+        c = sp.c;
+        dontMatch = sp.dontMatch;
+        eos = sp.eos;
+    }
+    /** Initialize a StrPos by giving it a String, and a
+         position within the String. */
+    public StrPos(String s,int pos) {
+        this.s=s;
+        this.pos=pos-1;
+        inc();
+    }
+    /** Advance the place where StrPos points within the String.
+         Counts a backslash as part of the next character. */
+    public StrPos inc() {
+        pos++;
+        if(pos >= s.length()) {
+            eos = true;
+            return this;
+        }
+        eos = false;
+        c = s.charAt(pos);
+        if(c == esc && pos+1<s.length()) {
+            pos++;
+            c = s.charAt(pos);
+            if(c != esc)
+                dontMatch = true;
+            else
+                dontMatch = false;
+        } else
+            dontMatch = false;
+        return this;
+    }
+    /** Compare the (possibly escaped) character
+         pointed to by StrPos.  Return true if they are the
+         same, but lways return if character pointed to is escaped. */
+    public boolean match(char ch) {
+        if(dontMatch || eos) return false;
+        return c == ch;
+    }
+    /** As match, but only matches if the character is escaped. */
+    public boolean escMatch(char ch) {
+        if(!dontMatch || eos) return false;
+        return c == ch;
+    }
+
+    /** Returns true if the current
+        character is escaped (preceeded by "\"). */
+    public boolean escaped() { return dontMatch; }
+    /** Increment the string pointer by each character in
+         <pre>st</pre> that matches a non-escaped
+         character. */
+    public boolean incMatch(String st) {
+        StrPos sp = new StrPos(this);
+        int i;
+        for(i=0;i<st.length();i++) {
+            if(!sp.match(st.charAt(i)) )
+                return false;
+            sp.inc();
+        }
+        dup(sp);
+        return true;
+    }
+    /** Read in an integer. */
+    public patInt getPatInt() {
+        patInt pi = null;
+        if(incMatch("inf"))
+            return new patInf();
+        int i,cnt=0;
+        StrPos sp = new StrPos(this);
+        for(i=0;!sp.eos && sp.c >= '0' && sp.c <= '9';i++) {
+            cnt = 10*cnt+sp.c-'0';
+            sp.inc();
+        }
+        if(i==0) return null;
+        dup(sp);
+        return new patInt(cnt);
+    }
+    /** get the string that we are processing. */
+    public String getString() { return s; }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StrPos.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,63 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat;
+
+/** A tool that is used to make the \E, \U, \L, and \Q
+    elements of a substitution. */
+public class StringBufferLike implements BasicStringBufferLike {
+  BasicStringBufferLike sbl;
+  public StringBufferLike(BasicStringBufferLike sbl) {
+    this.sbl = sbl;
+  }
+  char mode = 'E', altMode = ' ';
+  public StringLike toStringLike() {
+    return sbl.toStringLike();
+  }
+  public String toString() {
+    return sbl.toString();
+  }
+  public void append(char c) {
+    
+    switch(mode) {
+    case 'u':
+      mode = altMode;
+      altMode = ' ';
+    case 'U':
+      sbl.append(CaseMgr.toUpperCase(c));
+      break;
+    case 'l':
+      mode = altMode;
+      altMode = ' ';
+    case 'L':
+      sbl.append(CaseMgr.toLowerCase(c));
+      break;
+    case 'Q':
+      if((c >= 'a' && c <= 'z')
+      || (c >= 'A' && c <= 'Z')
+      || (c >= '0' && c <= '9'))
+        ;
+      else
+        sbl.append('\\');
+    default:
+      sbl.append(c);
+      break;
+    }
+  }
+  public void append(String s) {
+    for(int i=0;i<s.length();i++)
+      append(s.charAt(i));
+  }
+  public void setMode(char c) {
+    if(c == 'u' || c == 'l')
+      if(altMode == ' ') altMode = mode;
+    mode = c;
+  }
+  public Object unwrap() {
+    return sbl.unwrap();
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StringBufferLike.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/StringLike.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StringLike.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/StringLike.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/StringLike.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/StringLike.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,37 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat;
+
+/** Package pat can search anything that implements this
+    interface.  Package pat assumes the following:
+    <ul>
+    <li>The StringLike object will not change.  Calls to
+        charAt(int) will not vary with time.
+    <li>The length of the object being searched is known
+        before the search begins and does not vary with time.
+    </ul>
+    Note that searching String is probably faster than searching
+    other objects, so searching String is still preferred if
+    possible.
+*/
+public interface StringLike {
+    public char charAt(int i);
+    public String toString();
+    public int length();
+    public String substring(int i1,int i2);
+    /** Obtain the underlying object, be it a String, char[],
+        RandomAccessFile, whatever. */
+    public Object unwrap();
+    /** By default, the result is put in a String or char[]
+        when a replace is done.  If you wish to save the result
+        in some other StringBufferLike then you can do this
+        by implementing this method, or over-riding it's behavior
+        from an existing class. */
+    public BasicStringBufferLike newStringBufferLike();
+    public int indexOf(char c);
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StringLike.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/StringRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StringRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/StringRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/StringRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/StringRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** The apply method of this ReplaceRule simply appends the text
+    it was initialized with to the StringBufferLike.
+    @see com.stevesoft.ewe_pat.ReplaceRule
+    */
+public class StringRule extends ReplaceRule {
+    String s;
+    public StringRule(String s) { this.s = s; }
+    public void apply(StringBufferLike sb,RegRes res) {
+        sb.append(s);
+    }
+    public String toString1() { return s; }
+    public Object clone1() { return new StringRule(s); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/StringRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/SubMark.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/SubMark.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/SubMark.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/SubMark.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/SubMark.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,22 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** OrMark and SubMark together implement ( ... ) */
+class SubMark extends Pattern {
+    int end_pos,start_pos;
+    OrMark om;
+    public String toString() { return ""; }
+    public int matchInternal(int i,Pthings pt) {
+        pt.marks[om.id+pt.nMarks] = i;
+        int ret=nextMatch(i,pt);
+        if(ret < 0)
+            pt.marks[om.id+pt.nMarks] = -1;
+        return ret;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/SubMark.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/TransPat.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/TransPat.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/TransPat.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/TransPat.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/TransPat.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,39 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+
+/** This class is used to implement the Transformer
+    @see com.stevesoft.ewe_pat.Transform
+    */
+class TransPat extends Pattern {
+    Regex[] ra = new Regex[10];
+    int ra_len = 0;
+    int pn = -1;
+    public String toString() {
+        return "(?#TransPat)";
+    }
+
+    TransPat() {}
+
+    int lastMatchedTo = -1;
+    public int matchInternal(int pos,Pthings pt) {
+        for(int i=0;i<ra_len;i++) {
+            pt.ignoreCase = ra[i].ignoreCase;
+            pt.mFlag = ra[i].mFlag;
+            pt.dotDoesntMatchCR = ra[i].dotDoesntMatchCR;
+            int r = ra[i].thePattern.matchInternal(pos,pt);
+            if(r >= 0) {
+                pn = i;
+                return r;
+            }
+        }
+        pn = -1;
+        return -1;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/TransPat.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/TransRepRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/TransRepRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Transformer.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Transformer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Transformer.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Transformer.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Transformer.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,154 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+import com.stevesoft.ewe_pat.wrap.StringWrap;
+
+/** Replacement rule used by the Transformer.
+    @see com.stevesoft.ewe_pat.Transformer
+    */
+class TransRepRule extends ReplaceRule {
+    Transformer t;
+    TransRepRule(Transformer t) { this.t = t; }
+    public String toString1() { return ""; }
+    public Object clone1() { return new TransRepRule(t); }
+    public void apply(StringBufferLike sb,RegRes rr) {
+        // get the ReplaceRule of the Regex that matched.
+        next = t.tp.ra[t.tp.pn].getReplaceRule();
+    }
+}
+
+/** Sometimes you want to replace a whole bunch of things
+  that might occur within a single line of text.  One efficient
+  way to do this, both in terms of performance and programming
+  ease, is with Transformer. The Transformer contains an array
+  of Regex's and uses the Regex that matches earliest within the
+  text to do the replacing, if two Regex's match at the same
+  time it uses the one put in the Transformer first.
+  <p>
+  This feature can be used to prevent transformations from
+  occurring in certain regions. For example, if I add the rule
+  s'//.*'$&' and then add the
+  rule s/hello/goodbye/ the Transformer will replace "hello"
+  with "goodbye" except when it occurs inside a double-slash
+  style of comment.   The transformation on the comment goes first,
+  does nothing, and precludes transformation on the same region
+  of text as the s/hello/goodbye/ rule.
+  <p>
+  So far, at least, this class does not have the capability of
+  turning into a giant robot :-)
+  */
+public class Transformer {
+    TransPat tp;
+    Regex rp = new Regex();
+    boolean auto_optimize;
+
+    /** Get a replacer to that works with the current Regex.
+     @see com.stevesoft.ewe_pat.Replacer
+     */
+    public Replacer getReplacer() { return rp.getReplacer(); }
+
+    /** Instantiate a new Transformer object. */
+    public Transformer(boolean auto) {
+        auto_optimize = auto;
+        tp = new TransPat();
+        rp.setReplaceRule(new TransRepRule(this));
+        rp.thePattern = tp;
+    }
+
+    /** Add a new Regex to the set of Regex's. */
+    public void add(Regex r) {
+        if(auto_optimize) r.optimize();
+        tp.ra[tp.ra_len++] = r;
+        if(tp.ra.length==tp.ra_len) {
+            Regex[] ra2 = new Regex[tp.ra_len+10];
+            for(int i=0;i<tp.ra_len;i++)
+                ra2[i] = tp.ra[i];
+            tp.ra = ra2;
+        }
+        rp.numSubs_ = r.numSubs_ > rp.numSubs_ ? r.numSubs_ : rp.numSubs_;
+    }
+
+    /** Returns the number of Regex's in this Transformer. */
+    public int patterns() { return tp.ra_len; }
+
+    /** Get the Regex at position i in this Transformer. */
+    public Regex getRegexAt(int i) {
+        if(i >= tp.ra_len)
+            throw new ArrayIndexOutOfBoundsException("i="+i+">="+patterns());
+        if(i < 0)
+            throw new ArrayIndexOutOfBoundsException("i="+i+"< 0");
+        return tp.ra[i];
+    }
+    /** Set the Regex at position i in this Transformer. */
+    public void setRegexAt(Regex rx,int i) {
+        if(i >= tp.ra_len)
+            throw new ArrayIndexOutOfBoundsException("i="+i+">="+patterns());
+        if(i < 0)
+            throw new ArrayIndexOutOfBoundsException("i="+i+"< 0");
+        tp.ra[i] = rx;
+    }
+
+    /** Add a new Regex by calling Regex.perlCode
+        @see com.stevesoft.ewe_pat.Regex#perlCode(java.lang.String)
+        */
+    public void add(String rs) {
+        Regex r = Regex.perlCode(rs);
+        if(r == null) throw new NullPointerException("bad pattern to Regex.perlCode: "+rs);
+        add(r);
+    }
+    /** Add an array of Strings (which will be converted to
+        Regex's via the Regex.perlCode method.
+        @see com.stevesoft.ewe_pat.Regex#perlCode(java.lang.String)
+        */
+    public void add(String[] array) {
+        for(int i=0;i<array.length;i++)
+            add(array[i]);
+    }
+    /** Replace all matches in the current String. */
+    public String replaceAll(String s) {
+        return dorep(s,0,s.length());
+    }
+    public StringLike replaceAll(StringLike s) {
+        return dorep(s,0,s.length());
+    }
+    /** Replace all matching patterns beginning at position start. */
+    public String replaceAllFrom(String s,int start) {
+        return dorep(s,start,s.length());
+    }
+    /** Replace all matching patterns beginning between the positions
+        start and end inclusive. */
+    public String replaceAllRegion(String s,int start,int end) {
+        return dorep(s,start,end);
+    }
+
+    Replacer repr = new Replacer();
+    final StringLike dorep(StringLike s,int start,int end) {
+        StringLike tfmd = repr.replaceAllRegion(s,rp,start,end);
+        tp.lastMatchedTo = repr.lastMatchedTo;
+        return tfmd;
+    }
+    final String dorep(String s,int start,int end) {
+        return dorep(new StringWrap(s),start,end).toString();
+    }
+
+    /** Replace the first matching pattern in String s. */
+    public String replaceFirst(String s) {
+        return dorep(s,0,s.length());
+    }
+    /** Replace the first matching pattern after position start in
+        String s. */
+    public String replaceFirstFrom(String s,int start) {
+        return dorep(s,start,s.length());
+    }
+    /** Replace the first matching pattern that begins between
+        start and end inclusive. */
+    public String replaceFirstRegion(String s,int start,int end) {
+        return dorep(s,start,end);
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Transformer.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/UniValidator.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UniValidator.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UniValidator.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/UniValidator.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/UniValidator.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,16 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This provides a base class for all the Unicode character
+  * matching rules.
+  */
+class UniValidator extends Validator {
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UniValidator.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeAlpha.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeAlpha.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeCurrency.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeCurrency.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeDigit.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeDigit.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeLower.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeLower.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeMath.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeMath.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodePunct.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodePunct.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeUpper.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeUpper.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeW.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeW.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/UnicodeWhite.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/UnicodeWhite.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Validator.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Validator.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/Validator.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/Validator.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/Validator.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,58 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class makes it easy to create your own patterns
+and integrate them into Regex.  For more detail, see the
+example file <a href="http://javaregex.com/code/deriv2.java.html">deriv2.java</a> or
+<a href="http://javaregex.com/code/deriv3.java.html">deriv3.java</a>. */
+
+public class Validator {
+    String argsave = null;
+    String pattern = ".";
+    /**
+    This method does extra checking on a matched section of
+    a String beginning at position start and ending at end.
+    The idea is that you can do extra checking with this
+    that you don't know how to do with a standard Regex.
+
+    If this method is successful, it returns the location
+    of the end of this pattern element -- that may be the
+    value end provided or some other value.  A negative
+    value signifies that a match failure.
+    
+    By default, this method just returns end and thus
+    does nothing.
+    @see com.stevesoft.ewe_pat.Regex#define(java.lang.String,java.lang.String,com.stevesoft.pat.Validator)
+    */
+    public int validate(StringLike src,int start,int end) {
+        return end;
+    }
+    /* This method allows you to modify the behavior of this
+    validator by making a new Validator object.  If a Validator
+    named "foo" is defined, then the pattern "{??foo:bar}" will
+    cause Regex to first get the Validator given to Regex.define
+    and then to call its arg method with the string "bar".
+    If this method returns a null (the default) you get the same
+    behavior as the pattern "{??foo}" would supply. */
+    public Validator arg(String s) { return null; }
+
+    /** For optimization it is helpful, but not necessary, that
+    you define the minimum number of characters this validator
+    will allow to match.  To do this 
+    return new patInt(number) where number is the smallest
+    number of characters that can match. */
+    public patInt minChars() { return new patInt(0); }
+
+    /** For optimization it is helpful, but not necessary, that
+    you define the maximum number of characters this validator
+    will allow to match.  To do this either
+    return new patInt(number), or new patInf() if an infinite
+    number of characters may match. */
+    public patInt maxChars() { return new patInf(); }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/Validator.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,19 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** Triggers the reading of another line of text, allowing a longer
+    pattern to match -- for details see
+    <a href="http://javaregex.com/code/WantMore.java.html">WantMore.java</a>.
+    */
+public class WantMoreTextReplaceRule extends SpecialRule {
+    public WantMoreTextReplaceRule() {}
+    public void apply(StringBufferLike sb,RegRes res) {
+    }
+    public String toString1() { return "${WANT_MORE_TEXT}"; }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/WantMoreTextReplaceRule.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/lookAhead.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/lookAhead.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/lookAhead.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/lookAhead.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/lookAhead.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,46 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** Implements "(?=  )" and "(?! )" */
+class lookAhead extends Or {
+    boolean reverse;
+    lookAhead(boolean b) { reverse = b; }
+    public Pattern getNext() { return null; }
+    public int nextMatch(int pos,Pthings pt) {
+        Pattern p = super.getNext();
+        if(p != null) return p.matchInternal(pos,pt);
+        else return pos;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        if(super.matchInternal(pos,pt) >= 0) {
+            if(reverse) return -1;
+            else return nextMatch(pos,pt);
+        } else {
+            if(reverse) return nextMatch(pos,pt);
+            else return -1;
+        }
+    }
+    String leftForm() {
+        if(reverse)
+            return "(?!";
+        else
+            return "(?=";
+    }
+    public patInt minChars() { return new patInt(0); }
+    public patInt maxChars() { return new patInt(0); }
+    Pattern clone1(Hashtable h) {
+        lookAhead la=new lookAhead(reverse);
+        h.put(this,la);
+        h.put(la,la);
+        for(int i=0;i<v.size();i++)
+            la.v.addElement( ((Pattern)v.elementAt(i)).clone(h) );
+        return la;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/lookAhead.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/oneChar.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/oneChar.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/oneChar.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/oneChar.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/oneChar.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,48 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+import ewe.util.Hashtable;
+
+/** This class matches a single character. */
+class oneChar extends Pattern {
+    char c,altc,altc2;
+    int mask;
+    public oneChar(char ci) {
+        c = ci;
+        char cu,cl,ct;
+        cu = CaseMgr.toUpperCase(c);
+        cl = CaseMgr.toLowerCase(c);
+        ct = CaseMgr.toTitleCase(c);
+        if(c == cu) {
+            altc = cl;
+            altc2 = ct;
+        } else if(c == cl) {
+            altc = cu;
+            altc2 = ct;
+        } else {
+            altc = cl;
+            altc2 = cu;
+        }
+        mask = c & altc & altc2;
+    }
+    public int matchInternal(int pos,Pthings pt) {
+        char p;
+        int ret=-1;
+        if (pos < pt.src.length() && !Masked(pos,pt)
+                && ((p=pt.src.charAt(pos))==c ||
+                (pt.ignoreCase&& (p==altc||p==altc2) ) ))
+            ret = nextMatch(pos+1,pt);
+        return ret;
+    }
+    public String toString() {
+        return protect(""+c,PROTECT_THESE,ESC)+nextString();
+    }
+    public patInt minChars() { return new patInt(1); }
+    public patInt maxChars() { return new patInt(1); }
+    Pattern clone1(Hashtable h) { return new oneChar(c); }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/oneChar.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/parsePerl.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/parsePerl.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/parsePerl.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/parsePerl.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/parsePerl.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,266 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This class provides a method for parsing the "s/.../.../" constructs
+of Regex.perlCode.
+ at see Regex#perlCode
+*/
+class parsePerl {
+    final static char close(char c) {
+        // This switch statement does not behave
+        // properly when compiled with jdk1.1.5
+        // and the -O flag.
+        /*
+        switch(c) {
+        case '[':
+          return ']';
+        case '(':
+          return ')';
+        case '{':
+          return '}';
+        }
+        return c;*/
+	if(c == '<')
+	    return '>';
+        if(c == '[')
+            return ']';
+        if(c == '(')
+            return ')';
+        if(c == '{')
+            return '}';
+        return c;
+    }
+
+    final public static String codify(String s,boolean keepbs) {
+        return codify(s,0,s.length(),keepbs);
+    }
+    final public static String codify(String s,int i0,int iN,boolean keepbs) {
+        StringBuffer sb = new StringBuffer();
+        boolean ucmode = false, lcmode = false, litmode = false;
+        boolean uc1 = false, lc1 = false;
+        boolean modified = false;
+        for(int i=i0;i<iN;i++) {
+            char c = s.charAt(i);
+            boolean mf = true, app=true;
+            if(c=='\\') {
+                app=false;
+                i++;
+                if(i<s.length()) {
+                    char c2 = s.charAt(i);
+                    switch(c2) {
+                    case 'Q':
+                        litmode = true;
+                        break;
+                    case 'U':
+                        ucmode = true;
+                        break;
+                    case 'L':
+                        lcmode = true;
+                        break;
+                    case 'u':
+                        uc1 = true;
+                        break;
+                    case 'l':
+                        lc1 = true;
+                        break;
+                    case 'E':
+                        uc1=lc1=ucmode=lcmode=litmode=false;
+                        break;
+                    default:
+                        if(keepbs)
+                            sb.append('\\');
+                        c=c2;
+                        if(keepbs) mf = false;
+                        app = true;
+                        break;
+                    }
+                    modified |= mf;
+                }
+            }
+            if(app) {
+                if(lc1) {
+                    c=lc(c);
+                    lc1=false;
+                } else if(uc1) {
+                    c=uc(c);
+                    uc1=false;
+                } else if(ucmode) {
+                    c=uc(c);
+                } else if(lcmode) {
+                    c=lc(c);
+                }
+                if(litmode && needbs(c))
+                    sb.append('\\');
+                sb.append(c);
+            }
+        }
+        return modified ? sb.toString() : s;
+    }
+    final static char uc(char c) {
+        return CaseMgr.toUpperCase(c);
+    }
+    final static char lc(char c) {
+        return CaseMgr.toLowerCase(c);
+    }
+    final static boolean needbs(char c) {
+        if(c >= 'a' && c <= 'z')
+            return false;
+        if(c >= 'A' && c <= 'Z')
+            return false;
+        if(c >= '0' && c <= '9')
+            return false;
+        if(c == '_')
+            return false;
+        return true;
+    }
+    final static Regex parse(String s) {
+        boolean igncase = false, optim = false, gFlag = false;
+        boolean sFlag = false, mFlag = false, xFlag = false;
+
+        StringBuffer s1 = new StringBuffer();
+        StringBuffer s2 = new StringBuffer();
+        int i=0,count=0;
+        char mode,delim='/',cdelim='/';
+        if(s.length() >= 3 && s.charAt(0)=='s') {
+            mode = 's';
+            delim = s.charAt(1);
+            cdelim = close(delim);
+            i=2;
+        } else if(s.length() >= 2 && s.charAt(0)=='m') {
+            mode = 'm';
+            delim = s.charAt(1);
+            cdelim = close(delim);
+            i=2;
+        } else if(s.length() >= 1 && s.charAt(0)=='/') {
+            mode = 'm';
+            i=1;
+        } else {
+            try {
+                RegSyntaxError.endItAll(
+		    "Regex.perlCode should be of the "+
+                    "form s/// or m// or //");
+            } catch(RegSyntax rs) {}
+            return null;
+        }
+        for(;i<s.length();i++) {
+            if(s.charAt(i)=='\\') {
+                s1.append('\\');
+                i++;
+            } else if(s.charAt(i)==cdelim && count==0) {
+                i++;
+                break;
+            } else if(s.charAt(i)==delim && cdelim != delim) {
+                count++;
+            } else if(s.charAt(i)==cdelim && cdelim != delim) {
+                count--;
+            }
+            s1.append(s.charAt(i));
+        }
+        if(mode=='s' && cdelim != delim) {
+            while(i<s.length() && Prop.isWhite(s.charAt(i)) )
+                i++;
+            if(i>=s.length()) {
+                try {
+                    RegSyntaxError.endItAll(""+mode+delim+" needs "+cdelim);
+                } catch(RegSyntax rs) {}
+                return null;
+            }
+            cdelim = close(delim = s.charAt(i));
+            i++;
+        }
+        count=0;
+        if(mode=='s') {
+            for(;i<s.length();i++) {
+                if(s.charAt(i)=='\\') {
+                    s2.append('\\');
+                    i++;
+                } else if(s.charAt(i)==cdelim && count==0) {
+                    i++;
+                    break;
+                } else if(s.charAt(i)==delim && cdelim != delim) {
+                    count++;
+                } else if(s.charAt(i)==cdelim && cdelim != delim) {
+                    count--;
+                }
+                s2.append(s.charAt(i));
+            }
+        }
+        for(;i<s.length();i++) {
+            char c = s.charAt(i);
+            switch(c) {
+	    case 'x':
+	        xFlag = true;
+		break;
+            case 'i':
+                igncase = true;
+                break;
+            case 'o':
+                optim = true;
+                break;
+            case 's':
+                sFlag = true;
+                break;
+            case 'm':
+		mFlag = true;
+                break;
+            case 'g':
+                gFlag = true;
+                break;
+            default:
+                // syntax error!
+                try {
+                    RegSyntaxError.endItAll("Illegal flag to pattern: "+c);
+                } catch(RegSyntax rs) {}
+                return null;
+            }
+        }
+        Regex r = new Regex();
+        try {
+            String pat=s1.toString(),reprul=s2.toString();
+	    if(xFlag) {
+	      pat = strip(pat);
+	      reprul = strip(reprul);
+	    }
+            r.compile(pat);
+            r.ignoreCase |= igncase;
+            r.gFlag |= gFlag;
+            r.sFlag |= sFlag;
+	    r.mFlag |= mFlag;
+            if(optim) r.optimize();
+	    if(delim=='\'')
+              r.setReplaceRule(new StringRule(reprul));
+	    else
+              r.setReplaceRule(ReplaceRule.perlCode(reprul));
+        } catch(RegSyntax rs) {
+            r = null;
+        }
+        return r;
+    }
+    static String strip(String s) {
+      StringBuffer sb = new StringBuffer();
+      for(int i=0;i<s.length();i++) {
+        char c = s.charAt(i);
+	if(Prop.isWhite(c)) {
+	  ;
+	} else if(c == '#') {
+	  i++;
+	  while(i<s.length()) {
+	    if(s.charAt(i) == '\n')
+	      break;
+	    i++;
+	  }
+        } else if(c == '\\') {
+	  sb.append(c);
+	  sb.append(s.charAt(++i));
+	} else
+	  sb.append(c);
+      }
+      return sb.toString();
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/parsePerl.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/patInf.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/patInf.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/patInf.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/patInf.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/patInf.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,12 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+final class patInf extends patInt {
+    patInf() { inf = true; }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/patInf.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/patInt.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/patInt.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/patInt.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/patInt.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/patInt.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,88 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat;
+
+/** This is just an integer that can have infinite value.
+    It is used internally to implement the *, and + parts
+    of regular expressions.
+*/
+public class patInt {
+    int i;
+    boolean inf;
+    /** Initialize to zero. */
+    public patInt() { i = 0; inf = false; }
+    /** Initialize to the value of init. */
+    public patInt(int init) { i = init; inf = false; }
+    /** Initialize to the value of p. */
+    public patInt(patInt p) { i = p.i; inf = p.inf; }
+    /** set this int to infinity. */
+    public void setInf(boolean b) {
+        inf = b;
+        if(b) i = Integer.MAX_VALUE;
+    }
+    /** Increment the value of this by 1. */
+    public final void inc() {
+        if(!inf) i++;
+    }
+    /** Decrement the value of this by 1. */
+    public final void dec() {
+        if(!inf) i--;
+    }
+    /** Test to see if this is less than or equal to j. */
+    public final boolean lessEq(patInt j) { /*
+                if(inf) return false;
+                if(j.inf) return true;
+                return i <= j.i; */
+        return !inf && (j.inf || i <= j.i);
+    }
+    /** Test to see if two patterns are equal. */
+    public final boolean equals(patInt j) {
+        return !j.inf && !inf && i==j.i;
+    }
+    /** Formats the pattern as a String.  Contrary to
+         what you might expect, infinity is formatted as "" */
+    final public String toString() {
+        if(inf) return "";
+        else return ""+i;
+    }
+    /** This would be operator+=(patInt) if I were programming
+         in C++. */
+    public final patInt pluseq(patInt p) {
+        if(inf||p.inf) setInf(true);
+        else i += p.i;
+        return this;
+    }
+    /** Returns a patInt with value equal to the product
+         of the value of p and this. */
+    public final patInt mul(patInt p) {
+        if(inf||p.inf) return new patInf();
+        return new patInt(i*p.i);
+    }
+    /** If the argument p has a smaller value than this,
+         then set this Object equal to p. */
+    public final patInt mineq(patInt p) {
+        if(p.inf) return this;
+        if(inf) i = p.i;
+        else if(p.i < i) i = p.i;
+        setInf(false);
+        return this;
+    }
+    /** If the argument p has a greater than this,
+         then set this object equal to p. */
+    public final patInt maxeq(patInt p) {
+        if(inf || p.inf) { setInf(true); return this; }
+        if(p.i > i) i = p.i;
+        return this;
+    }
+    /** Tests to see if this represents an infinite quantity. */
+    public boolean finite() { return !inf; }
+    /** Converts to a patInt to an int.  Infinity is
+         mapped Integer.MAX_VALUE;
+        */
+    public int intValue() { return inf ? Integer.MAX_VALUE : i; }
+};


Property changes on: trunk/lib/com/stevesoft/ewe_pat/patInt.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,38 @@
+package//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+com.stevesoft.ewe_pat.wrap;
+
+import com.stevesoft.ewe_pat.*;
+
+/** Allows the outcome of a replaceAll() or replaceFirst()
+    to be an array of characters rather than a String.
+    */
+public class CharArrayBufferWrap
+  implements BasicStringBufferLike
+  {
+  StringBuffer sb = new StringBuffer();
+  public void append(char c) {
+    sb.append(c);
+  }
+  public void append(String s) {
+    sb.append(s);
+  }
+  public StringLike toStringLike() {
+    char[] ca = new char[sb.length()];
+    for(int i=0;i<ca.length;i++)
+      ca[i] = sb.charAt(i);
+    return new CharArrayWrap(ca);
+  }
+  public int length() { return sb.length(); }
+  public String toString() {
+    return sb.toString();
+  }
+  public Object unwrap() {
+    return sb;
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayBufferWrap.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,39 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat.wrap;
+
+import com.stevesoft.ewe_pat.*;
+
+/** This provides a wrapper for a char array so that
+    it can be searched by Regex. */
+public class CharArrayWrap implements StringLike {
+    char[] ca;
+    public char[] getCharArray() { return ca; }
+    public CharArrayWrap(char[] ca) { this.ca = ca; }
+    public String toString() {
+      return new String(ca);
+    }
+    public char charAt(int i) { return ca[i]; }
+    public int length() { return ca.length; }
+    public String substring(int i1,int i2) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=i1;i<i2;i++)
+            sb.append(ca[i]);
+        return sb.toString();
+    }
+    public Object unwrap() { return ca; }
+    public BasicStringBufferLike newStringBufferLike() {
+      return new CharArrayBufferWrap();
+    }
+    public int indexOf(char c) {
+      for(int i=0;i<ca.length;i++)
+        if(ca[i] == c)
+          return i;
+      return -1;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/CharArrayWrap.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,117 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat.wrap;
+
+import com.stevesoft.ewe_pat.*;
+
+import ewe.io.*;
+
+/** Provides a wrapper for a RandomAccessFile so that it
+    can be searched by Regex. */
+public class RandomAccessFileWrap implements StringLike {
+
+    long offset = 0;
+    public void setOffset(long o) {
+      offset = o;
+      i0 = iend = 0;
+    }
+    public long getOffset() {
+      return offset;
+    }
+    RandomAccessFile raf;
+    int i0=0,iend=0;
+    byte[] buf = new byte[1024];
+
+    public int getBufferSize() {
+      return buf.length;
+    }
+
+    public void setBufferSize(int bs) {
+      buf = new byte[bs];
+      i0 = iend = 0;
+    }
+
+    public RandomAccessFileWrap(String file) throws IOException {
+        this.raf = new RandomAccessFile(file,"r");
+    }
+    public RandomAccessFileWrap(RandomAccessFile raf) {
+        this.raf = raf;
+    }
+
+    public char charAt(int i) {
+        if(i >= i0 && i < iend)
+            return (char)buf[i-i0];
+
+        try {
+            i0 = i-5;
+            //if(i0+offset<0) i0=(int)(-offset);
+            if(i0<0) i0=0;
+            raf.seek(i0+offset);
+            iend = i0+raf.read(buf,0,buf.length);
+
+            if(i >= i0 && i < iend)
+                return (char)buf[i-i0];
+        } catch(Throwable t) {}
+
+        throw new ArrayIndexOutOfBoundsException("Out of bounds for file:"+
+          " i="+i+
+          ", Final Buffer: i0="+i0+
+          " iend="+iend);
+    }
+
+    public String toString() { throw new Error("Not implemented"); }
+    public int length() {
+      try {
+        long len = raf.length()-offset;
+        if(len > Integer.MAX_VALUE)
+          return Integer.MAX_VALUE;
+        return (int)len;
+      } catch(IOException ioe) {
+        return 0;
+      }
+    }
+    public String substring(int i1,int i2) {
+        StringBuffer sb = new StringBuffer();
+        for(int i=i1;i<i2;i++)
+            sb.append(charAt(i));
+        return sb.toString();
+    }
+    public Object unwrap() { return raf; }
+
+    public static void main(String[] files) throws IOException {
+      for(int i=0;i<files.length;i++) {
+        RandomAccessFileWrap fw =
+          new RandomAccessFileWrap(new RandomAccessFile(files[i],"r"));
+        Regex r = new Regex("toString\\(\\) *(?@{})");
+        r.setGFlag(true);
+        r.optimize();
+        ewe.sys.Vm.out().print(files[i]+" ");
+        int j=0;
+        do {
+          if(r.searchFrom(fw,j)) {
+            ewe.sys.Vm.out().println("Matched at index: "+
+             r.matchedFrom());
+            j=r.matchedTo();
+          } else
+            ewe.sys.Vm.out().println("not found");
+          ewe.sys.Vm.out().println(r.stringMatched());
+        } while(r.didMatch());
+      }
+    }
+
+    public BasicStringBufferLike newStringBufferLike() {
+      return new StringBufferWrap();
+    }
+
+    public int indexOf(char c) {
+      for(int i=0;i<length();i++)
+        if(charAt(i)==c)
+          return i;
+      return -1;
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/RandomAccessFileWrap.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,36 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat.wrap;
+
+import com.stevesoft.ewe_pat.*;
+
+/** This provides a wrapper for StringBuffer to
+    capture the output of a replacement. */
+public class StringBufferWrap
+    implements BasicStringBufferLike
+  {
+  StringBuffer sb = new StringBuffer();
+  public void append(char c) {
+    sb.append(c);
+  }
+  public void append(String s) {
+    sb.append(s);
+  }
+  public int length() {
+    return sb.length();
+  }
+  public String toString() {
+    return sb.toString();
+  }
+  public StringLike toStringLike() {
+    return new StringWrap(sb.toString());
+  }
+  public Object unwrap() {
+    return sb;
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/StringBufferWrap.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,33 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat.wrap;
+
+import com.stevesoft.ewe_pat.*;
+
+/** A basic wrapper for the String object. Regex does
+    not search String directly any longer, it searches StringLike. */
+public class StringWrap implements StringLike {
+    String s;
+    public StringWrap(String s) {
+      this.s = s;
+    }
+    public String toString() { return s; }
+    public char charAt(int i) { return s.charAt(i); }
+    public int length() { return s.length(); }
+    public String substring(int i1,int i2) {
+        return s.substring(i1,i2);
+    }
+    public Object unwrap() { return s; }
+    public BasicStringBufferLike newStringBufferLike() {
+      return new StringBufferWrap();
+    }
+
+    public int indexOf(char c) {
+      return s.indexOf(c);
+    }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/StringWrap.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.java
===================================================================
--- trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,46 @@
+//
+// This software is now distributed according to
+// the Lesser Gnu Public License.  Please see
+// http://www.gnu.org/copyleft/lesser.txt for
+// the details.
+//    -- Happy Computing!
+//
+package com.stevesoft.ewe_pat.wrap;
+
+import com.stevesoft.ewe_pat.*;
+
+import ewe.io.*;
+
+/** Allows the outcome of a replaceAll() or replaceFirst()
+    to be directed to a Writer rather than a String.
+    <p>
+    The method toStringLike() cannot work, however.
+    This means that the return value of replaceAll() will
+    be null if this Object is used as the StringBufferLike.*/
+public class WriterWrap
+  implements BasicStringBufferLike
+  {
+  Writer w;
+  public WriterWrap(Writer w) {
+    this.w = w;
+  }
+  public void append(char c) {
+    try {
+      w.write((int)c);
+    } catch(IOException ioe) {}
+  }
+  public void append(String s) {
+    try {
+      w.write(s);
+    } catch(IOException ioe) {}
+  }
+
+  /** This operation can't really be done. */
+  public StringLike toStringLike() {
+    return null;
+  }
+
+  public Object unwrap() {
+    return w;
+  }
+}


Property changes on: trunk/lib/com/stevesoft/ewe_pat/wrap/WriterWrap.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/DocumentHandler.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/DocumentHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/DocumentHandler.java
===================================================================
--- trunk/lib/ewesoft/xml/DocumentHandler.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/DocumentHandler.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,12 @@
+//package org.minml;
+package ewesoft.xml;
+
+import ewe.io.Writer;
+import ewesoft.xml.sax.SAXException;
+import ewesoft.xml.sax.AttributeList;
+
+public interface DocumentHandler extends ewesoft.xml.sax.DocumentHandler {
+  Writer startDocument(final Writer writer) throws SAXException;
+  Writer startElement(final String name, final AttributeList attributes, final Writer writer)
+        throws SAXException;
+}


Property changes on: trunk/lib/ewesoft/xml/DocumentHandler.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/MinML$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/MinML$1.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/MinML$MinMLBuffer.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/MinML$MinMLBuffer.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/MinML.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/MinML.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/MinML.java
===================================================================
--- trunk/lib/ewesoft/xml/MinML.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/MinML.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,777 @@
+// Copyright (c) 2000, 2001 The Wilson Partnership.
+// All Rights Reserved.
+// @(#)MinML.java, 1.7, 18th November 2001
+// Author: John Wilson - tug at wilson.co.uk
+
+//package org.minml;
+package ewesoft.xml;
+
+/*
+Copyright (c) 2000, 2001 John Wilson (tug at wilson.co.uk).
+All rights reserved.
+Redistribution and use in source and binary forms,
+with or without modification, are permitted provided
+that the following conditions are met:
+
+Redistributions of source code must retain the above
+copyright notice, this list of conditions and the
+following disclaimer.
+
+Redistributions in binary form must reproduce the
+above copyright notice, this list of conditions and
+the following disclaimer in the documentation and/or
+other materials provided with the distribution.
+
+All advertising materials mentioning features or use
+of this software must display the following acknowledgement:
+
+This product includes software developed by John Wilson.
+The name of John Wilson may not be used to endorse or promote
+products derived from this software without specific prior
+written permission.
+
+THIS SOFTWARE IS PROVIDED BY JOHN WILSON ``AS IS'' AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JOHN WILSON
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+OF THE POSSIBILITY OF SUCH DAMAGE
+*/
+
+import ewe.io.Reader;
+import ewe.io.Writer;
+import ewe.io.InputStreamReader;
+import ewe.io.IOException;
+
+
+import ewe.sys.Locale;
+import ewe.util.Vector;
+import ewe.util.Stack;
+import ewe.util.EmptyStackException;
+import ewesoft.xml.sax.EntityResolver;
+import ewesoft.xml.sax.DTDHandler;
+import ewesoft.xml.sax.ErrorHandler;
+import ewesoft.xml.sax.Locator;
+import ewesoft.xml.sax.InputSource;
+import ewesoft.xml.sax.AttributeList;
+import ewesoft.xml.sax.SAXException;
+import ewesoft.xml.sax.SAXParseException;
+
+public class MinML implements Parser, Locator, DocumentHandler, ErrorHandler {
+  public static final int endStartName = 0;
+  public static final int emitStartElement = 1;
+  public static final int emitEndElement = 2;
+  public static final int possiblyEmitCharacters = 3;
+  public static final int emitCharacters = 4;
+  public static final int emitCharactersSave = 5;
+  public static final int saveAttributeName = 6;
+  public static final int saveAttributeValue = 7;
+  public static final int startComment = 8;
+  public static final int endComment = 9;
+  public static final int incLevel = 10;
+  public static final int decLevel = 11;
+  public static final int startCDATA = 12;
+  public static final int endCDATA = 13;
+  public static final int processCharRef = 14;
+  public static final int writeCdata = 15;
+  public static final int exitParser = 16;
+  public static final int parseError = 17;
+  public static final int discardAndChange = 18;
+  public static final int discardSaveAndChange = 19;
+  public static final int saveAndChange = 20;
+  public static final int change = 21;
+
+  public static final int inSkipping = 0;
+  public static final int inSTag = 1;
+  public static final int inPossiblyAttribute = 2;
+  public static final int inNextAttribute = 3;
+  public static final int inAttribute = 4;
+  public static final int inAttribute1 = 5;
+  public static final int inAttributeValue = 6;
+  public static final int inAttributeQuoteValue = 7;
+  public static final int inAttributeQuotesValue = 8;
+  public static final int inETag = 9;
+  public static final int inETag1 = 10;
+  public static final int inMTTag = 11;
+  public static final int inTag = 12;
+  public static final int inTag1 = 13;
+  public static final int inPI = 14;
+  public static final int inPI1 = 15;
+  public static final int inPossiblySkipping = 16;
+  public static final int inCharData = 17;
+  public static final int inCDATA = 18;
+  public static final int inCDATA1 = 19;
+  public static final int inComment =20;
+  public static final int inDTD = 21;
+
+  public MinML(final int initialBufferSize, final int bufferIncrement) {
+    this.initialBufferSize = initialBufferSize;
+    this.bufferIncrement = bufferIncrement;
+  }
+
+  public MinML() {
+    this(256, 128);
+  }
+
+  public void parse(final Reader in) throws SAXException, IOException {
+  final Vector attributeNames = new Vector();
+  final Vector attributeValues = new Vector();
+
+  final AttributeList attrs = new AttributeList() {
+    public int getLength() {
+      return attributeNames.size();
+    }
+
+    public String getName(final int i) {
+      return (String)attributeNames.elementAt(i);
+    }
+
+    public String getType(final int i) {
+      return "CDATA";
+    }
+
+    public String getValue(final int i) {
+      return (String)attributeValues.elementAt(i);
+    }
+
+    public String getType(final String name) {
+      return "CDATA";
+    }
+
+    public String getValue(final String name) {
+    final int index = attributeNames.find(name);
+
+      return (index == -1) ? null : (String)attributeValues.elementAt(index);
+    }
+    public String toString()
+    {
+    	StringBuffer sb = new StringBuffer();
+    	sb.append("{");
+    	int len = getLength();
+    	for (int i = 0; i<len; i++){
+    		if (i != 0) sb.append(", ");
+    		sb.append(getName(i)+"="+getValue(i));
+    	}
+    	sb.append("}");
+    	return sb.toString();
+    }
+  };
+
+  final MinMLBuffer buffer = new MinMLBuffer(in);
+  int currentChar = 0, charCount = 0;
+  int level = 0;
+  int mixedContentLevel = -1;
+  String elementName = null;
+  String state = operands[inSkipping];
+
+    this.lineNumber = 1;
+    this.columnNumber = 0;
+
+    try {
+      while(true) {
+        charCount++;
+
+        //
+        // this is to try and make the loop a bit faster
+        // currentChar = buffer.read(); is simpler but is a bit slower.
+        //
+        currentChar = (buffer.nextIn == buffer.lastIn) ? buffer.read() : buffer.chars[buffer.nextIn++];
+
+        final int transition;
+
+        if (currentChar > ']') {
+          transition = state.charAt(14);
+        } else {
+        final int charClass = charClasses[currentChar + 1];
+
+          if (charClass == -1) fatalError("Document contains illegal control character with value " + currentChar, this.lineNumber, this.columnNumber);
+
+          if (charClass == 12) {
+            if (currentChar == '\r') {
+              currentChar = '\n';
+              charCount = -1;
+            }
+
+            if (currentChar == '\n') {
+              if (charCount == 0) continue;  // preceeded by '\r' so ignore
+
+              if (charCount != -1) charCount = 0;
+
+              this.lineNumber++;
+              this.columnNumber = 0;
+            }
+          }
+
+          transition = state.charAt(charClass);
+       }
+
+        this.columnNumber++;
+
+        final String operand = operands[transition >>> 8];
+
+        switch (transition & 0XFF) {
+          case endStartName:
+          // end of start element name
+            elementName = buffer.getString();
+            if (currentChar != '>' && currentChar != '/') break;  // change state to operand
+            // drop through to emit start element (we have no attributes)
+
+          case emitStartElement:
+          // emit start element
+
+          final Writer newWriter = this.extDocumentHandler.startElement(elementName, attrs,
+                                                                        (this.tags.empty()) ?
+                                                                          this.extDocumentHandler.startDocument(buffer)
+                                                                        :
+                                                                          buffer.getWriter());
+
+            buffer.pushWriter(newWriter);
+            this.tags.push(elementName);
+
+            attributeValues.removeAllElements();
+            attributeNames.removeAllElements();
+
+            if (mixedContentLevel != -1) mixedContentLevel++;
+
+            if (currentChar != '/') break;  // change state to operand
+
+            // <element/> drop through
+
+          case emitEndElement:
+          // emit end element
+
+            try {
+            final String begin = (String)this.tags.pop();
+
+              buffer.popWriter();
+              elementName = buffer.getString();
+
+              if (currentChar != '/' && !elementName.equals(begin)) {
+               fatalError("end tag </" + elementName + "> does not match begin tag <" + begin + ">",
+                           this.lineNumber, this.columnNumber);
+              } else {
+                this.documentHandler.endElement(begin);
+
+                if (this.tags.empty()) {
+                  this.documentHandler.endDocument();
+                  return;
+                }
+              }
+            }
+            catch (final EmptyStackException e) {
+              fatalError("end tag at begining of document", this.lineNumber, this.columnNumber);
+            }
+
+            if (mixedContentLevel != -1) --mixedContentLevel;
+
+            break;  // change state to operand
+
+          case emitCharacters:
+          // emit characters
+
+            buffer.flush();
+            break;  // change state to operand
+
+          case emitCharactersSave:
+          // emit characters and save current character
+
+            if (mixedContentLevel == -1) mixedContentLevel = 0;
+
+            buffer.flush();
+
+            buffer.saveChar((char)currentChar);
+
+            break;  // change state to operand
+
+          case possiblyEmitCharacters:
+          // write any skipped whitespace if in mixed content
+
+            if (mixedContentLevel != -1) buffer.flush();
+            break;  // change state to operand
+
+          case saveAttributeName:
+          // save attribute name
+
+            attributeNames.addElement(buffer.getString());
+            break;  // change state to operand
+
+          case saveAttributeValue:
+          // save attribute value
+
+            attributeValues.addElement(buffer.getString());
+            break;  // change state to operand
+
+          case startComment:
+          // change state if we have found "<!--"
+
+            if (buffer.read() != '-') continue; // not "<!--"
+
+            break;  // change state to operand
+
+          case endComment:
+          // change state if we find "-->"
+
+            if ((currentChar = buffer.read()) == '-') {
+              // deal with the case where we might have "------->"
+              while ((currentChar = buffer.read()) == '-');
+
+              if (currentChar == '>') break;  // end of comment, change state to operand
+            }
+
+            continue;   // not end of comment, don't change state
+
+          case incLevel:
+
+            level++;
+
+            break;
+
+          case decLevel:
+
+            if (level == 0) break; // outer level <> change state
+
+            level--;
+
+            continue; // in nested <>, don't change state
+
+          case startCDATA:
+          // change state if we have found "<![CDATA["
+
+            if (buffer.read() != 'C') continue;   // don't change state
+            if (buffer.read() != 'D') continue;   // don't change state
+            if (buffer.read() != 'A') continue;   // don't change state
+            if (buffer.read() != 'T') continue;   // don't change state
+            if (buffer.read() != 'A') continue;   // don't change state
+            if (buffer.read() != '[') continue;   // don't change state
+            break;  // change state to operand
+
+          case endCDATA:
+          // change state if we find "]]>"
+
+            if ((currentChar = buffer.read()) == ']') {
+              // deal with the case where we might have "]]]]]]]>"
+              while ((currentChar = buffer.read()) == ']') buffer.write(']');
+
+              if (currentChar == '>') break;  // end of CDATA section, change state to operand
+
+              buffer.write(']');
+            }
+
+            buffer.write(']');
+            buffer.write(currentChar);
+            continue;   // not end of CDATA section, don't change state
+
+          case processCharRef:
+          // process character entity
+
+            int crefState = 0;
+
+            currentChar = buffer.read();
+
+            while (true) {
+              if ("#amp;&pos;'quot;\"gt;>lt;<".charAt(crefState) == currentChar) {
+                crefState++;
+
+                if (currentChar == ';') {
+                  buffer.write("#amp;&pos;'quot;\"gt;>lt;<".charAt(crefState));
+                  break;
+
+                } else if (currentChar == '#') {
+                final int radix;
+
+                  currentChar = buffer.read();
+
+                  if (currentChar == 'x') {
+                    radix = 16;
+                    currentChar = buffer.read();
+                  } else {
+                    radix = 10;
+                  }
+
+                  int charRef = Character.digit((char)currentChar, radix);
+
+                  while (true) {
+                    currentChar = buffer.read();
+
+                    final int digit = Character.digit((char)currentChar, radix);
+
+                    if (digit == -1) break;
+
+                    charRef = (char)((charRef * radix) + digit);
+                  }
+
+                  if (currentChar == ';' && charRef != -1) {
+                    buffer.write(charRef);
+                    break;
+                  }
+
+                  fatalError("invalid Character Entitiy", this.lineNumber, this.columnNumber);
+                } else {
+                  currentChar = buffer.read();
+                }
+              } else {
+                crefState = ("\u0001\u000b\u0006\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff" +
+//                               #     a     m     p     ;     &     p     o     s     ;     '
+//                               0     1     2     3     4     5     6     7     8     9     a
+                             "\u0011\u00ff\u00ff\u00ff\u00ff\u00ff\u0015\u00ff\u00ff\u00ff" +
+//                               q     u     o     t     ;     "     g     t     ;     >
+//                               b     b     d     e     f     10    11    12    13    14
+                             "\u00ff\u00ff\u00ff").charAt(crefState);
+//                               l     t     ;
+//                               15    16    17
+
+                if (crefState == 255) fatalError("invalid Character Entitiy", this.lineNumber, this.columnNumber);
+              }
+            }
+
+            break;
+
+          case parseError:
+          // report fatal error
+
+            fatalError(operand, this.lineNumber, this.columnNumber);
+            // drop through to exit parser
+
+          case exitParser:
+          // exit parser
+
+            return;
+
+          case writeCdata:
+          // write character data
+          // this will also write any skipped whitespace
+
+            buffer.write(currentChar);
+            break;  // change state to operand
+
+          case discardAndChange:
+          // throw saved characters away and change state
+
+            buffer.reset();
+            break;  // change state to operand
+
+          case discardSaveAndChange:
+          // throw saved characters away, save character and change state
+
+            buffer.reset();
+            // drop through to save character and change state
+
+          case saveAndChange:
+          // save character and change state
+
+            buffer.saveChar((char)currentChar);
+            break;  // change state to operand
+
+          case change:
+          // change state to operand
+
+            break;  // change state to operand
+        }
+
+        state = operand;
+      }
+    }
+    catch (final IOException e) {
+      this.errorHandler.fatalError(new SAXParseException(e.toString(), null, null, this.lineNumber, this.columnNumber, e));
+    }
+    finally {
+      this.errorHandler = this;
+      this.documentHandler = this.extDocumentHandler = this;
+      this.tags.clear();
+    }
+  }
+  public void parse(final InputSource source) throws SAXException, IOException {
+    if (source.getCharacterStream() != null)
+      parse(source.getCharacterStream());
+    else if (source.getByteStream() != null)
+      parse(new InputStreamReader(source.getByteStream()));
+		else
+			throw new SAXException("Input source not supported.");
+		/*
+    else
+     parse(new InputStreamReader(new URL(source.getSystemId()).openStream()));
+		*/
+  }
+  public void parse(final String systemId) throws SAXException, IOException {
+    parse(new InputSource(systemId));
+  }
+
+  public void setLocale(final Locale locale) throws SAXException {
+    throw new SAXException("Not supported");
+  }
+
+  public void setEntityResolver(final EntityResolver resolver) {
+    // not supported
+  }
+
+  public void setDTDHandler(final DTDHandler handler) {
+    // not supported
+  }
+
+  public void setDocumentHandler(final ewesoft.xml.sax.DocumentHandler handler) {
+   this.documentHandler = (handler == null) ? this : handler;
+   this.extDocumentHandler = this;
+  }
+
+  public void setDocumentHandler(final DocumentHandler handler) {
+   this.documentHandler = this.extDocumentHandler = (handler == null) ? this : handler;
+   this.documentHandler.setDocumentLocator(this);
+  }
+
+  public void setErrorHandler(final ErrorHandler handler) {
+   this.errorHandler = (handler == null) ? this : handler;
+  }
+
+  public void setDocumentLocator(final Locator locator) {
+  }
+
+  public void startDocument() throws SAXException {
+  }
+
+  public Writer startDocument(final Writer writer) throws SAXException {
+    this.documentHandler.startDocument();
+    return writer;
+  }
+
+  public void endDocument() throws SAXException {
+  }
+
+  public void startElement(final String name, final AttributeList attributes) throws SAXException {
+  }
+
+  public Writer startElement(final String name, final AttributeList attributes, final Writer writer)
+        throws SAXException
+  {
+    this.documentHandler.startElement(name, attributes);
+    return writer;
+  }
+
+  public void endElement(final String name) throws SAXException {
+  }
+
+  public void characters(final char ch[], final int start, final int length) throws SAXException {
+  }
+
+  public void ignorableWhitespace(final char ch[], final int start, final int length) throws SAXException {
+  }
+
+  public void processingInstruction(final String target, final String data) throws SAXException {
+  }
+
+  public void warning(final SAXParseException e) throws SAXException {
+  }
+
+  public void error(final SAXParseException e) throws SAXException {
+  }
+
+  public void fatalError(final SAXParseException e) throws SAXException {
+    throw e;
+  }
+
+  public String getPublicId() {
+    return "";
+  }
+
+
+  public String getSystemId() {
+    return "";
+  }
+
+  public int getLineNumber () {
+    return this.lineNumber;
+  }
+
+  public int getColumnNumber () {
+    return this.columnNumber;
+  }
+
+  private void fatalError(final String msg, final int lineNumber, final int columnNumber) throws SAXException {
+    this.errorHandler.fatalError(new SAXParseException(msg, null, null, lineNumber, columnNumber));
+  }
+
+  private class MinMLBuffer extends Writer {
+    public MinMLBuffer(final Reader in) {
+      this.in = in;
+    }
+
+    public void close() throws IOException {
+      flush();
+    }
+
+    public void flush() throws IOException {
+      try {
+        _flush();
+        if (writer != this) writer.flush();
+      }
+      finally {
+        flushed = true;
+      }
+    }
+
+    public void write(final int c) throws IOException {
+      written = true;
+      chars[count++] = (char)c;
+    }
+
+    public void write(final char[] cbuf, final int off, final int len) throws IOException {
+      written = true;
+      System.arraycopy(cbuf, off, chars, count, len);
+      count += len;
+    }
+
+    public void saveChar(final char c) {
+      written = false;
+      chars[count++] = c;
+    }
+
+    public void pushWriter(final Writer writer) {
+      MinML.this.tags.push(this.writer);
+
+      this.writer = (writer == null) ? this : writer;
+
+      flushed = written = false;
+    }
+
+    public Writer getWriter() {
+      return writer;
+    }
+
+    public void popWriter() throws IOException {
+      try {
+        if (!flushed && writer != this) writer.flush();
+      }
+      finally {
+        writer = (Writer)MinML.this.tags.pop();
+        flushed = written = false;
+      }
+    }
+
+    public String getString() {
+    final String result = new String(chars, 0, count);
+
+      count = 0;
+      return result;
+    }
+
+    public void reset() {
+      count = 0;
+    }
+
+    public int read() throws IOException {
+      if (nextIn == lastIn) {
+        if (count != 0) {
+          if (written) {
+            _flush();
+          } else if (count >= (chars.length - MinML.this.bufferIncrement)) {
+          final char[] newChars = new char[chars.length + MinML.this.bufferIncrement];
+
+            System.arraycopy(chars, 0, newChars, 0, count);
+            chars = newChars;
+          }
+        }
+
+        final int numRead = in.read(chars, count, chars.length - count);
+
+        if (numRead == -1) return -1;
+
+        nextIn = count;
+        lastIn = count + numRead;
+      }
+
+      return chars[nextIn++];
+    }
+
+    private void _flush() throws IOException {
+      if (count != 0) {
+        try {
+          if (writer == this) {
+            try {
+              MinML.this.documentHandler.characters(chars, 0, count);
+            }
+            catch (final SAXException e) {
+              throw new IOException(e.toString());
+            }
+          } else {
+            writer.write(chars, 0, count);
+          }
+        }
+        finally {
+          count = 0;
+        }
+      }
+    }
+
+    private int nextIn = 0, lastIn = 0;
+    private char[] chars = new char[MinML.this.initialBufferSize];
+    private final Reader in;
+    private int count = 0;
+    private Writer writer = this;
+    private boolean flushed = false;
+    private boolean written = false;
+  }
+
+  private DocumentHandler extDocumentHandler = this;
+  private ewesoft.xml.sax.DocumentHandler documentHandler = this;
+  private ErrorHandler errorHandler = this;
+  private final Stack tags = new Stack();
+  private int lineNumber = 1;
+  private int columnNumber = 0;
+  private final int initialBufferSize;
+  private final int bufferIncrement;
+
+  private static final byte[] charClasses = {
+  //  EOF
+      13,
+  //                                      \t  \n          \r
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, -1, -1, 12, -1, -1,
+  //
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+  //  SP   !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
+      12,  8,  7, 14, 14, 14,  3,  6, 14, 14, 14, 14, 14, 11, 14,  2,
+  //   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  0,  5,  1,  4,
+  //
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+  //                                               [   \   ]
+      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  9, 14, 10
+  };
+
+  private static final String[] operands = {
+    "\u0d15\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u1611\u0015\u0010\u1611",
+    "\u1711\u1000\u0b00\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0114\u0200\u1811\u0114",
+    "\u1711\u1001\u0b01\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0215\u1811\u0414",
+    "\u1711\u1001\u0b01\u1711\u1911\u1911\u1911\u1911\u1911\u1911\u1911\u1911\u0315\u1811\u0414",
+    "\u1911\u1911\u1911\u1911\u1911\u0606\u1911\u1911\u1911\u1911\u1911\u0414\u0515\u1811\u0414",
+    "\u1911\u1911\u1911\u1911\u1911\u0606\u1911\u1911\u1911\u1911\u1911\u1911\u0515\u1811\u1911",
+    "\u1a11\u1a11\u1a11\u1a11\u1a11\u1a11\u0715\u0815\u1a11\u1a11\u1a11\u1a11\u0615\u1811\u1a11",
+    "\u0714\u0714\u0714\u070e\u0714\u0714\u0307\u0714\u0714\u0714\u0714\u0714\u0714\u1811\u0714",
+    "\u0814\u0814\u0814\u080e\u0814\u0814\u0814\u0307\u0814\u0814\u0814\u0814\u0814\u1811\u0814",
+    "\u1711\u1002\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u0914\u0915\u1811\u0914",
+    "\u1b11\u1b11\u0904\u1b11\u1b11\u1b11\u1b11\u1b11\u1215\u1b11\u1b11\u1b11\u1b11\u1811\u0105",
+    "\u1711\u1012\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1711\u1811\u1711",
+    "\u1711\u1c11\u0912\u1711\u0e12\u1711\u1711\u1711\u1212\u1711\u1711\u1711\u1711\u1811\u0113",
+    "\u1711\u1c11\u0912\u1711\u0e12\u1711\u1711\u1711\u1212\u1711\u1711\u1711\u1711\u1811\u0113",
+    "\u0e15\u0e15\u0e15\u0e15\u0f15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u1811\u0e15",
+    "\u0e15\u0015\u0e15\u0e15\u0f15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u0e15\u1811\u0e15",
+    "\u0c03\u110f\u110f\u110e\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u1014\u1811\u110f",
+    "\u0a15\u110f\u110f\u110e\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u110f\u1811\u110f",
+    "\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u1d11\u130c\u1d11\u1408\u1d11\u1811\u1515",
+    "\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u130f\u110d\u130f\u130f\u1811\u130f",
+    "\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u1415\u0009\u1415\u1811\u1415",
+    "\u150a\u000b\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1515\u1811\u1515",
+    "expected Element",
+    "unexpected character in tag",
+    "unexpected end of file found",
+    "attribute name not followed by '='",
+    "invalid attribute value",
+    "expecting end tag",
+    "empty tag",
+    "unexpected character after <!"
+  };
+}


Property changes on: trunk/lib/ewesoft/xml/MinML.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/Parser.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/Parser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/Parser.java
===================================================================
--- trunk/lib/ewesoft/xml/Parser.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/Parser.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,6 @@
+//package org.minml;
+package ewesoft.xml;
+
+public interface Parser extends ewesoft.xml.sax.Parser {
+  void setDocumentHandler(DocumentHandler handler);
+}


Property changes on: trunk/lib/ewesoft/xml/Parser.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/XMLDecoder.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/XMLDecoder.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/XMLDecoder.java
===================================================================
--- trunk/lib/ewesoft/xml/XMLDecoder.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/XMLDecoder.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,91 @@
+/*
+ * Created on Jan 20, 2005
+ *
+ */
+package ewesoft.xml;
+
+import ewesoft.xml.sax.AttributeList;
+import ewesoft.xml.sax.SAXException;
+import ewe.util.Vector;
+import ewe.data.PropertyList;
+
+/**
+ * This class will fully decode an XML document from a Reader.
+ * It parses the XML document and creates a tree of XMLElement
+ * objects, with the root of the tree being the <b>document</b>
+ * element of the XMLDecoder.
+ * <p>
+ * To use simply create a Reader to provide the characters of the
+ * XML document and then call parse() on that reader. 
+ * @author Michael Brereton, Ewesoft.com.
+ */
+public class XMLDecoder extends MinML {
+
+	/**
+	 * This is the XMLElement that represents the entire document.
+	 * It will be valid only after the parse() method has completed
+	 * successfully.
+	 */
+	public XMLElement document;
+	
+	private XMLElement current;
+
+	/* (non-Javadoc)
+	 * @see ewesoft.xml.sax.DocumentHandler#startElement(java.lang.String, ewesoft.xml.sax.AttributeList)
+	 */
+	public void startElement(String name, AttributeList atts)
+			throws SAXException {
+		if (current == null){
+			current = document = new XMLElement();
+		}else{
+			XMLElement xe = new XMLElement();
+			current.subElements = Vector.add(current.subElements,xe);
+			xe.parent = current;
+			current = xe;
+		}
+		current.tag = name;
+		if (atts != null && atts.getLength() == 0)
+			atts = null;
+		if (atts != null){
+			current.attributes = new PropertyList();
+			int max = atts.getLength();
+			for (int i = 0; i<max; i++)
+				current.attributes.add(atts.getName(i),atts.getValue(i));
+		}
+	}
+
+	/* (non-Javadoc)
+	 * @see ewesoft.xml.sax.DocumentHandler#endElement(java.lang.String)
+	 */
+	public void endElement(String name) throws SAXException {
+		current = current.parent;
+	}
+
+	/* (non-Javadoc)
+	 * @see ewesoft.xml.sax.DocumentHandler#characters(char[], int, int)
+	 */
+	public void characters(char[] ch, int start, int length)
+			throws SAXException {
+		current.text += new String(ch,start,length);
+	}
+/**
+ * This main() method takes the argument from the command line
+ * as the name of an XMLFile. It then attempts to open and parse
+ * the file. If successful, it will then call format() on the
+ * document XMLElement produced and then display this on the
+ * console.
+ * @param args
+ * @throws ewe.io.IOException
+ * @throws SAXException
+ */
+	public static void main(String[] args) throws ewe.io.IOException, SAXException
+	{
+		ewe.sys.Vm.startEwe(args);
+		ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(args[0]));
+		XMLDecoder xd = new XMLDecoder();
+		xd.parse(r);
+		r.close();
+		ewe.sys.Vm.debug(xd.document.format());
+		//ewe.sys.Vm.exit(0);
+	}
+}


Property changes on: trunk/lib/ewesoft/xml/XMLDecoder.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/XMLElement.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/XMLElement.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/XMLElement.java
===================================================================
--- trunk/lib/ewesoft/xml/XMLElement.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/XMLElement.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,69 @@
+/*
+ * Created on Jan 20, 2005
+ */
+package ewesoft.xml;
+import ewe.util.Vector;
+import ewe.data.PropertyList;
+/**
+ * This class represents the data within the open and close tags
+ * of an XML entry. It holds the name of the entry (the <b>tag</b>)
+ * and either the text for the entry, or the sub-elements within
+ * that entry.
+ * @author Michael L Brereton, Ewesoft.com.
+ */
+public class XMLElement {
+	/**
+	 * This is the tag for this XMLElement.
+	 */
+	public String tag;
+	/**
+	 * If there is any text within the XML tags, then this value
+	 * will be set to be that text, otherwise it will be an empty String. 
+	 */
+	public String text = "";
+	/**
+	 * If there are any sub-elements within this element, then
+	 * they are stored in this Vector. Otherwise this Vector will
+	 * be null.
+	 */
+	public Vector subElements;
+	/**
+	 * If there are any attributes for the XML element, they
+	 * will be placed here.
+	 */
+	public PropertyList attributes;
+	/**
+	 * This holds the parent XMLElement as determined during
+	 * parsing. The root element will have no parent.
+	 */
+	public XMLElement parent;
+	/**
+	 * Format the XMLElement and its children into a String.
+	 * @param prefix tabs or spaces to put in front of the format. 
+	 * @return the XMLElement and its children into a String.
+	 */
+	public String format(String prefix)
+	{
+		String ret = new String();
+		ret += prefix+"<"+tag+">";
+		if (prefix.length() == 0) prefix += " ";
+		else prefix += prefix.charAt(0);
+		if (attributes != null) ret += attributes;
+		ret += "\n";
+		if (text.length() != 0) ret += prefix+"\""+text+"\""+"\n";
+		if (subElements != null){
+			for (int i = 0; i<subElements.size(); i++)
+				ret += ((XMLElement)subElements.get(i)).format(prefix);
+		}
+		return ret;
+	}
+	/**
+	 * Format the XMLElement and its children into a String, with
+	 * each sub-element prefixed by increasing numbers of spaces.
+	 * @return the XMLElement and its children into a String.
+	 */
+	public String format()
+	{
+		return format("");
+	}
+}


Property changes on: trunk/lib/ewesoft/xml/XMLElement.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/AttributeList.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/AttributeList.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/AttributeList.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/AttributeList.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/AttributeList.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,165 @@
+// SAX Attribute List Interface.
+// No warranty; no copyright -- use this as you will.
+// $Id: AttributeList.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+/**
+  * Interface for an element's attribute specifications.
+  *
+  * <p>The SAX parser implements this interface and passes an instance
+  * to the SAX application as the second argument of each startElement
+  * event.</p>
+  *
+  * <p>The instance provided will return valid results only during the
+  * scope of the startElement invocation (to save it for future
+  * use, the application must make a copy: the AttributeListImpl
+  * helper class provides a convenient constructor for doing so).</p>
+  *
+  * <p>An AttributeList includes only attributes that have been
+  * specified or defaulted: #IMPLIED attributes will not be included.</p>
+  *
+  * <p>There are two ways for the SAX application to obtain information
+  * from the AttributeList.  First, it can iterate through the entire
+  * list:</p>
+  *
+  * <pre>
+  * public void startElement (String name, AttributeList atts) {
+  *   for (int i = 0; i < atts.getLength(); i++) {
+  *     String name = atts.getName(i);
+  *     String type = atts.getType(i);
+  *     String value = atts.getValue(i);
+  *     [...]
+  *   }
+  * }
+  * </pre>
+  *
+  * <p>(Note that the result of getLength() will be zero if there
+  * are no attributes.)
+  *
+  * <p>As an alternative, the application can request the value or
+  * type of specific attributes:</p>
+  *
+  * <pre>
+  * public void startElement (String name, AttributeList atts) {
+  *   String identifier = atts.getValue("id");
+  *   String label = atts.getValue("label");
+  *   [...]
+  * }
+  * </pre>
+  *
+  * <p>The AttributeListImpl helper class provides a convenience 
+  * implementation for use by parser or application writers.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.DocumentHandler#startElement 
+  */
+public interface AttributeList {
+
+  /**
+    * Return the number of attributes in this list.
+    *
+    * <p>The SAX parser may provide attributes in any
+    * arbitrary order, regardless of the order in which they were
+    * declared or specified.  The number of attributes may be
+    * zero.</p>
+    *
+    * @return The number of attributes in the list.  
+    */
+  public abstract int getLength ();
+
+
+  /**
+    * Return the name of an attribute in this list (by position).
+    *
+    * <p>The names must be unique: the SAX parser shall not include the
+    * same attribute twice.  Attributes without values (those declared
+    * #IMPLIED without a value specified in the start tag) will be
+    * omitted from the list.</p>
+    *
+    * <p>If the attribute name has a namespace prefix, the prefix
+    * will still be attached.</p>
+    *
+    * @param i The index of the attribute in the list (starting at 0).
+    * @return The name of the indexed attribute, or null
+    *         if the index is out of range.
+    * @see #getLength 
+    */
+  public abstract String getName (int i);
+
+
+  /**
+    * Return the type of an attribute in the list (by position).
+    *
+    * <p>The attribute type is one of the strings "CDATA", "ID",
+    * "IDREF", "IDREFS", "NMTOKEN", "NMTOKENS", "ENTITY", "ENTITIES",
+    * or "NOTATION" (always in upper case).</p>
+    *
+    * <p>If the parser has not read a declaration for the attribute,
+    * or if the parser does not report attribute types, then it must
+    * return the value "CDATA" as stated in the XML 1.0 Recommentation
+    * (clause 3.3.3, "Attribute-Value Normalization").</p>
+    *
+    * <p>For an enumerated attribute that is not a notation, the
+    * parser will report the type as "NMTOKEN".</p>
+    *
+    * @param i The index of the attribute in the list (starting at 0).
+    * @return The attribute type as a string, or
+    *         null if the index is out of range.
+    * @see #getLength 
+    * @see #getType(java.lang.String)
+    */
+  public abstract String getType (int i);
+
+
+  /**
+    * Return the value of an attribute in the list (by position).
+    *
+    * <p>If the attribute value is a list of tokens (IDREFS,
+    * ENTITIES, or NMTOKENS), the tokens will be concatenated
+    * into a single string separated by whitespace.</p>
+    *
+    * @param i The index of the attribute in the list (starting at 0).
+    * @return The attribute value as a string, or
+    *         null if the index is out of range.
+    * @see #getLength
+    * @see #getValue(java.lang.String)
+    */
+  public abstract String getValue (int i);
+
+
+  /**
+    * Return the type of an attribute in the list (by name).
+    *
+    * <p>The return value is the same as the return value for
+    * getType(int).</p>
+    *
+    * <p>If the attribute name has a namespace prefix in the document,
+    * the application must include the prefix here.</p>
+    *
+    * @param name The name of the attribute.
+    * @return The attribute type as a string, or null if no
+    *         such attribute exists.
+    * @see #getType(int)
+    */
+  public abstract String getType (String name);
+
+
+  /**
+    * Return the value of an attribute in the list (by name).
+    *
+    * <p>The return value is the same as the return value for
+    * getValue(int).</p>
+    *
+    * <p>If the attribute name has a namespace prefix in the document,
+    * the application must include the prefix here.</p>
+    *
+    * @param name The name of the attribute.
+    * @return The attribute value as a string, or null if
+    *         no such attribute exists.
+    * @see #getValue(int)
+    */
+  public abstract String getValue (String name);
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/AttributeList.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/DTDHandler.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/DTDHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/DTDHandler.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/DTDHandler.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/DTDHandler.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,95 @@
+// SAX DTD handler.
+// No warranty; no copyright -- use this as you will.
+// $Id: DTDHandler.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+/**
+  * Receive notification of basic DTD-related events.
+  *
+  * <p>If a SAX application needs information about notations and
+  * unparsed entities, then the application implements this 
+  * interface and registers an instance with the SAX parser using 
+  * the parser's setDTDHandler method.  The parser uses the 
+  * instance to report notation and unparsed entity declarations to 
+  * the application.</p>
+  *
+  * <p>The SAX parser may report these events in any order, regardless
+  * of the order in which the notations and unparsed entities were
+  * declared; however, all DTD events must be reported after the
+  * document handler's startDocument event, and before the first
+  * startElement event.</p>
+  *
+  * <p>It is up to the application to store the information for 
+  * future use (perhaps in a hash table or object tree).
+  * If the application encounters attributes of type "NOTATION",
+  * "ENTITY", or "ENTITIES", it can use the information that it
+  * obtained through this interface to find the entity and/or
+  * notation corresponding with the attribute value.</p>
+  *
+  * <p>The HandlerBase class provides a default implementation
+  * of this interface, which simply ignores the events.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.Parser#setDTDHandler
+  * @see ewesoft.xml.sax.HandlerBase 
+  */
+public interface DTDHandler {
+
+
+  /**
+    * Receive notification of a notation declaration event.
+    *
+    * <p>It is up to the application to record the notation for later
+    * reference, if necessary.</p>
+    *
+    * <p>If a system identifier is present, and it is a URL, the SAX
+    * parser must resolve it fully before passing it to the
+    * application.</p>
+    *
+    * @param name The notation name.
+    * @param publicId The notation's public identifier, or null if
+    *        none was given.
+    * @param systemId The notation's system identifier, or null if
+    *        none was given.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #unparsedEntityDecl
+    * @see ewesoft.xml.sax.AttributeList
+    */
+  public abstract void notationDecl (String name,
+				     String publicId,
+				     String systemId)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of an unparsed entity declaration event.
+    *
+    * <p>Note that the notation name corresponds to a notation
+    * reported by the notationDecl() event.  It is up to the
+    * application to record the entity for later reference, if
+    * necessary.</p>
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before passing it to the application.</p>
+    *
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @param name The unparsed entity's name.
+    * @param publicId The entity's public identifier, or null if none
+    *        was given.
+    * @param systemId The entity's system identifier (it must always
+    *        have one).
+    * @param notationName The name of the associated notation.
+    * @see #notationDecl
+    * @see ewesoft.xml.sax.AttributeList
+    */
+  public abstract void unparsedEntityDecl (String name,
+					   String publicId,
+					   String systemId,
+					   String notationName)
+    throws SAXException;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/DTDHandler.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/DocumentHandler.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/DocumentHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/DocumentHandler.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/DocumentHandler.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/DocumentHandler.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,219 @@
+// SAX document handler.
+// No warranty; no copyright -- use this as you will.
+// $Id: DocumentHandler.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+/**
+  * Receive notification of general document events.
+  *
+  * <p>This is the main interface that most SAX applications
+  * implement: if the application needs to be informed of basic parsing 
+  * events, it implements this interface and registers an instance with 
+  * the SAX parser using the setDocumentHandler method.  The parser 
+  * uses the instance to report basic document-related events like
+  * the start and end of elements and character data.</p>
+  *
+  * <p>The order of events in this interface is very important, and
+  * mirrors the order of information in the document itself.  For
+  * example, all of an element's content (character data, processing
+  * instructions, and/or subelements) will appear, in order, between
+  * the startElement event and the corresponding endElement event.</p>
+  *
+  * <p>Application writers who do not want to implement the entire
+  * interface can derive a class from HandlerBase, which implements
+  * the default functionality; parser writers can instantiate
+  * HandlerBase to obtain a default handler.  The application can find
+  * the location of any document event using the Locator interface
+  * supplied by the Parser through the setDocumentLocator method.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.Parser#setDocumentHandler
+  * @see ewesoft.xml.sax.Locator
+  * @see ewesoft.xml.sax.HandlerBase
+  */
+public interface DocumentHandler {
+
+
+  /**
+    * Receive an object for locating the origin of SAX document events.
+    *
+    * <p>SAX parsers are strongly encouraged (though not absolutely
+    * required) to supply a locator: if it does so, it must supply
+    * the locator to the application by invoking this method before
+    * invoking any of the other methods in the DocumentHandler
+    * interface.</p>
+    *
+    * <p>The locator allows the application to determine the end
+    * position of any document-related event, even if the parser is
+    * not reporting an error.  Typically, the application will
+    * use this information for reporting its own errors (such as
+    * character content that does not match an application's
+    * business rules).  The information returned by the locator
+    * is probably not sufficient for use with a search engine.</p>
+    *
+    * <p>Note that the locator will return correct information only
+    * during the invocation of the events in this interface.  The
+    * application should not attempt to use it at any other time.</p>
+    *
+    * @param locator An object that can return the location of
+    *                any SAX document event.
+    * @see ewesoft.xml.sax.Locator
+    */
+  public abstract void setDocumentLocator (Locator locator);
+
+
+  /**
+    * Receive notification of the beginning of a document.
+    *
+    * <p>The SAX parser will invoke this method only once, before any
+    * other methods in this interface or in DTDHandler (except for
+    * setDocumentLocator).</p>
+    *
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void startDocument ()
+    throws SAXException;
+
+
+  /**
+    * Receive notification of the end of a document.
+    *
+    * <p>The SAX parser will invoke this method only once, and it will
+    * be the last method invoked during the parse.  The parser shall
+    * not invoke this method until it has either abandoned parsing
+    * (because of an unrecoverable error) or reached the end of
+    * input.</p>
+    *
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void endDocument ()
+    throws SAXException;
+
+
+  /**
+    * Receive notification of the beginning of an element.
+    *
+    * <p>The Parser will invoke this method at the beginning of every
+    * element in the XML document; there will be a corresponding
+    * endElement() event for every startElement() event (even when the
+    * element is empty). All of the element's content will be
+    * reported, in order, before the corresponding endElement()
+    * event.</p>
+    *
+    * <p>If the element name has a namespace prefix, the prefix will
+    * still be attached.  Note that the attribute list provided will
+    * contain only attributes with explicit values (specified or
+    * defaulted): #IMPLIED attributes will be omitted.</p>
+    *
+    * @param name The element type name.
+    * @param atts The attributes attached to the element, if any.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #endElement
+    * @see ewesoft.xml.sax.AttributeList 
+    */
+  public abstract void startElement (String name, AttributeList atts)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of the end of an element.
+    *
+    * <p>The SAX parser will invoke this method at the end of every
+    * element in the XML document; there will be a corresponding
+    * startElement() event for every endElement() event (even when the
+    * element is empty).</p>
+    *
+    * <p>If the element name has a namespace prefix, the prefix will
+    * still be attached to the name.</p>
+    *
+    * @param name The element type name
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void endElement (String name)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of character data.
+    *
+    * <p>The Parser will call this method to report each chunk of
+    * character data.  SAX parsers may return all contiguous character
+    * data in a single chunk, or they may split it into several
+    * chunks; however, all of the characters in any single event
+    * must come from the same external entity, so that the Locator
+    * provides useful information.</p>
+    *
+    * <p>The application must not attempt to read from the array
+    * outside of the specified range.</p>
+    *
+    * <p>Note that some parsers will report whitespace using the
+    * ignorableWhitespace() method rather than this one (validating
+    * parsers must do so).</p>
+    *
+    * @param ch The characters from the XML document.
+    * @param start The start position in the array.
+    * @param length The number of characters to read from the array.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #ignorableWhitespace 
+    * @see ewesoft.xml.sax.Locator
+    */
+  public abstract void characters (char ch[], int start, int length)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of ignorable whitespace in element content.
+    *
+    * <p>Validating Parsers must use this method to report each chunk
+    * of ignorable whitespace (see the W3C XML 1.0 recommendation,
+    * section 2.10): non-validating parsers may also use this method
+    * if they are capable of parsing and using content models.</p>
+    *
+    * <p>SAX parsers may return all contiguous whitespace in a single
+    * chunk, or they may split it into several chunks; however, all of
+    * the characters in any single event must come from the same
+    * external entity, so that the Locator provides useful
+    * information.</p>
+    *
+    * <p>The application must not attempt to read from the array
+    * outside of the specified range.</p>
+    *
+    * @param ch The characters from the XML document.
+    * @param start The start position in the array.
+    * @param length The number of characters to read from the array.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see #characters
+    */
+  public abstract void ignorableWhitespace (char ch[], int start, int length)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of a processing instruction.
+    *
+    * <p>The Parser will invoke this method once for each processing
+    * instruction found: note that processing instructions may occur
+    * before or after the main document element.</p>
+    *
+    * <p>A SAX parser should never report an XML declaration (XML 1.0,
+    * section 2.8) or a text declaration (XML 1.0, section 4.3.1)
+    * using this method.</p>
+    *
+    * @param target The processing instruction target.
+    * @param data The processing instruction data, or null if
+    *        none was supplied.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    */
+  public abstract void processingInstruction (String target, String data)
+    throws SAXException;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/DocumentHandler.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/EntityResolver.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/EntityResolver.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/EntityResolver.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/EntityResolver.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/EntityResolver.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,105 @@
+// SAX entity resolver.
+// No warranty; no copyright -- use this as you will.
+// $Id: EntityResolver.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+import ewe.io.IOException;
+
+
+/**
+  * Basic interface for resolving entities.
+  *
+  * <p>If a SAX application needs to implement customized handling
+  * for external entities, it must implement this interface and
+  * register an instance with the SAX parser using the parser's
+  * setEntityResolver method.</p>
+  *
+  * <p>The parser will then allow the application to intercept any
+  * external entities (including the external DTD subset and external
+  * parameter entities, if any) before including them.</p>
+  *
+  * <p>Many SAX applications will not need to implement this interface,
+  * but it will be especially useful for applications that build
+  * XML documents from databases or other specialised input sources,
+  * or for applications that use URI types other than URLs.</p>
+  *
+  * <p>The following resolver would provide the application
+  * with a special character stream for the entity with the system
+  * identifier "http://www.myhost.com/today":</p>
+  *
+  * <pre>
+  * import ewesoft.xml.sax.EntityResolver;
+  * import ewesoft.xml.sax.InputSource;
+  *
+  * public class MyResolver implements EntityResolver {
+  *   public InputSource resolveEntity (String publicId, String systemId)
+  *   {
+  *     if (systemId.equals("http://www.myhost.com/today")) {
+  *              // return a special input source
+  *       MyReader reader = new MyReader();
+  *       return new InputSource(reader);
+  *     } else {
+  *              // use the default behaviour
+  *       return null;
+  *     }
+  *   }
+  * }
+  * </pre>
+  *
+  * <p>The application can also use this interface to redirect system
+  * identifiers to local URIs or to look up replacements in a catalog
+  * (possibly by using the public identifier).</p>
+  *
+  * <p>The HandlerBase class implements the default behaviour for
+  * this interface, which is simply always to return null (to request
+  * that the parser use the default system identifier).</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.Parser#setEntityResolver
+  * @see ewesoft.xml.sax.InputSource
+  * @see ewesoft.xml.sax.HandlerBase 
+  */
+public interface EntityResolver {
+
+
+  /**
+    * Allow the application to resolve external entities.
+    *
+    * <p>The Parser will call this method before opening any external
+    * entity except the top-level document entity (including the
+    * external DTD subset, external entities referenced within the
+    * DTD, and external entities referenced within the document
+    * element): the application may request that the parser resolve
+    * the entity itself, that it use an alternative URI, or that it
+    * use an entirely different input source.</p>
+    *
+    * <p>Application writers can use this method to redirect external
+    * system identifiers to secure and/or local URIs, to look up
+    * public identifiers in a catalogue, or to read an entity from a
+    * database or other input source (including, for example, a dialog
+    * box).</p>
+    *
+    * <p>If the system identifier is a URL, the SAX parser must
+    * resolve it fully before reporting it to the application.</p>
+    *
+    * @param publicId The public identifier of the external entity
+    *        being referenced, or null if none was supplied.
+    * @param systemId The system identifier of the external entity
+    *        being referenced.
+    * @return An InputSource object describing the new input source,
+    *         or null to request that the parser open a regular
+    *         URI connection to the system identifier.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException A Java-specific IO exception,
+    *            possibly the result of creating a new InputStream
+    *            or Reader for the InputSource.
+    * @see ewesoft.xml.sax.InputSource
+    */
+  public abstract InputSource resolveEntity (String publicId,
+					     String systemId)
+    throws SAXException, IOException;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/EntityResolver.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/ErrorHandler.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/ErrorHandler.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/ErrorHandler.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/ErrorHandler.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/ErrorHandler.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,110 @@
+// SAX error handler.
+// No warranty; no copyright -- use this as you will.
+// $Id: ErrorHandler.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+
+/**
+  * Basic interface for SAX error handlers.
+  *
+  * <p>If a SAX application needs to implement customized error
+  * handling, it must implement this interface and then register an
+  * instance with the SAX parser using the parser's setErrorHandler
+  * method.  The parser will then report all errors and warnings
+  * through this interface.</p>
+  *
+  * <p> The parser shall use this interface instead of throwing an
+  * exception: it is up to the application whether to throw an
+  * exception for different types of errors and warnings.  Note,
+  * however, that there is no requirement that the parser continue to
+  * provide useful information after a call to fatalError (in other
+  * words, a SAX driver class could catch an exception and report a
+  * fatalError).</p>
+  *
+  * <p>The HandlerBase class provides a default implementation of this
+  * interface, ignoring warnings and recoverable errors and throwing a
+  * SAXParseException for fatal errors.  An application may extend
+  * that class rather than implementing the complete interface
+  * itself.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.Parser#setErrorHandler
+  * @see ewesoft.xml.sax.SAXParseException 
+  * @see ewesoft.xml.sax.HandlerBase
+  */
+public interface ErrorHandler {
+
+
+  /**
+    * Receive notification of a warning.
+    *
+    * <p>SAX parsers will use this method to report conditions that
+    * are not errors or fatal errors as defined by the XML 1.0
+    * recommendation.  The default behaviour is to take no action.</p>
+    *
+    * <p>The SAX parser must continue to provide normal parsing events
+    * after invoking this method: it should still be possible for the
+    * application to process the document through to the end.</p>
+    *
+    * @param exception The warning information encapsulated in a
+    *                  SAX parse exception.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.SAXParseException 
+    */
+  public abstract void warning (SAXParseException exception)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of a recoverable error.
+    *
+    * <p>This corresponds to the definition of "error" in section 1.2
+    * of the W3C XML 1.0 Recommendation.  For example, a validating
+    * parser would use this callback to report the violation of a
+    * validity constraint.  The default behaviour is to take no
+    * action.</p>
+    *
+    * <p>The SAX parser must continue to provide normal parsing events
+    * after invoking this method: it should still be possible for the
+    * application to process the document through to the end.  If the
+    * application cannot do so, then the parser should report a fatal
+    * error even if the XML 1.0 recommendation does not require it to
+    * do so.</p>
+    *
+    * @param exception The error information encapsulated in a
+    *                  SAX parse exception.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.SAXParseException 
+    */
+  public abstract void error (SAXParseException exception)
+    throws SAXException;
+
+
+  /**
+    * Receive notification of a non-recoverable error.
+    *
+    * <p>This corresponds to the definition of "fatal error" in
+    * section 1.2 of the W3C XML 1.0 Recommendation.  For example, a
+    * parser would use this callback to report the violation of a
+    * well-formedness constraint.</p>
+    *
+    * <p>The application must assume that the document is unusable
+    * after the parser has invoked this method, and should continue
+    * (if at all) only for the sake of collecting addition error
+    * messages: in fact, SAX parsers are free to stop reporting any
+    * other events once this method has been invoked.</p>
+    *
+    * @param exception The error information encapsulated in a
+    *                  SAX parse exception.  
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.SAXParseException
+    */
+  public abstract void fatalError (SAXParseException exception)
+    throws SAXException;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/ErrorHandler.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/HandlerBase.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/HandlerBase.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/HandlerBase.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,351 @@
+// SAX default handler base class.
+// No warranty; no copyright -- use this as you will.
+// $Id: HandlerBase.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+/**
+  * Default base class for handlers.
+  *
+  * <p>This class implements the default behaviour for four SAX
+  * interfaces: EntityResolver, DTDHandler, DocumentHandler,
+  * and ErrorHandler.</p>
+  *
+  * <p>Application writers can extend this class when they need to
+  * implement only part of an interface; parser writers can
+  * instantiate this class to provide default handlers when the
+  * application has not supplied its own.</p>
+  *
+  * <p>Note that the use of this class is optional.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.EntityResolver
+  * @see ewesoft.xml.sax.DTDHandler
+  * @see ewesoft.xml.sax.DocumentHandler
+  * @see ewesoft.xml.sax.ErrorHandler
+  */
+public class HandlerBase
+  implements EntityResolver, DTDHandler,
+	     DocumentHandler, ErrorHandler
+{
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of the EntityResolver interface.
+  //////////////////////////////////////////////////////////////////////
+
+  /**
+    * Resolve an external entity.
+    *
+    * <p>Always return null, so that the parser will use the system
+    * identifier provided in the XML document.  This method implements
+    * the SAX default behaviour: application writers can override it
+    * in a subclass to do special translations such as catalog lookups
+    * or URI redirection.</p>
+    *
+    * @param publicId The public identifer, or null if none is
+    *                 available.
+    * @param systemId The system identifier provided in the XML 
+    *                 document.
+    * @return The new input source, or null to require the
+    *         default behaviour.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.EntityResolver#resolveEntity
+    */
+  public InputSource resolveEntity (String publicId, String systemId)
+    throws SAXException
+  {
+    return null;
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of DTDHandler interface.
+  //////////////////////////////////////////////////////////////////////
+
+
+  /**
+    * Receive notification of a notation declaration.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass if they wish to keep track of the notations
+    * declared in a document.</p>
+    *
+    * @param name The notation name.
+    * @param publicId The notation public identifier, or null if not
+    *                 available.
+    * @param systemId The notation system identifier.
+    * @see ewesoft.xml.sax.DTDHandler#notationDecl
+    */
+  public void notationDecl (String name, String publicId, String systemId)
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of an unparsed entity declaration.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to keep track of the unparsed entities
+    * declared in a document.</p>
+    *
+    * @param name The entity name.
+    * @param publicId The entity public identifier, or null if not
+    *                 available.
+    * @param systemId The entity system identifier.
+    * @param notationName The name of the associated notation.
+    * @see ewesoft.xml.sax.DTDHandler#unparsedEntityDecl
+    */
+  public void unparsedEntityDecl (String name, String publicId,
+				  String systemId, String notationName)
+  {
+    // no op
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of DocumentHandler interface.
+  //////////////////////////////////////////////////////////////////////
+
+
+  /**
+    * Receive a Locator object for document events.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass if they wish to store the locator for use
+    * with other document events.</p>
+    *
+    * @param locator A locator for all SAX document events.
+    * @see ewesoft.xml.sax.DocumentHandler#setDocumentLocator
+    * @see ewesoft.xml.sax.Locator
+    */
+  public void setDocumentLocator (Locator locator)
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the beginning of the document.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the beginning
+    * of a document (such as allocating the root node of a tree or
+    * creating an output file).</p>
+    *
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.DocumentHandler#startDocument
+    */
+  public void startDocument ()
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the end of the document.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the beginning
+    * of a document (such as finalising a tree or closing an output
+    * file).</p>
+    *
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.DocumentHandler#endDocument
+    */
+  public void endDocument ()
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the start of an element.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the start of
+    * each element (such as allocating a new tree node or writing
+    * output to a file).</p>
+    *
+    * @param name The element type name.
+    * @param attributes The specified or defaulted attributes.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.DocumentHandler#startElement
+    */
+  public void startElement (String name, AttributeList attributes)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of the end of an element.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions at the end of
+    * each element (such as finalising a tree node or writing
+    * output to a file).</p>
+    *
+    * @param name The element type name.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.DocumentHandler#endElement
+    */
+  public void endElement (String name)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of character data inside an element.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method to take specific actions for each chunk of character data
+    * (such as adding the data to a node or buffer, or printing it to
+    * a file).</p>
+    *
+    * @param ch The characters.
+    * @param start The start position in the character array.
+    * @param length The number of characters to use from the
+    *               character array.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.DocumentHandler#characters
+    */
+  public void characters (char ch[], int start, int length)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of ignorable whitespace in element content.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method to take specific actions for each chunk of ignorable
+    * whitespace (such as adding data to a node or buffer, or printing
+    * it to a file).</p>
+    *
+    * @param ch The whitespace characters.
+    * @param start The start position in the character array.
+    * @param length The number of characters to use from the
+    *               character array.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.DocumentHandler#ignorableWhitespace
+    */
+  public void ignorableWhitespace (char ch[], int start, int length)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of a processing instruction.
+    *
+    * <p>By default, do nothing.  Application writers may override this
+    * method in a subclass to take specific actions for each
+    * processing instruction, such as setting status variables or
+    * invoking other methods.</p>
+    *
+    * @param target The processing instruction target.
+    * @param data The processing instruction data, or null if
+    *             none is supplied.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.DocumentHandler#processingInstruction
+    */
+  public void processingInstruction (String target, String data)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Default implementation of the ErrorHandler interface.
+  //////////////////////////////////////////////////////////////////////
+
+
+  /**
+    * Receive notification of a parser warning.
+    *
+    * <p>The default implementation does nothing.  Application writers
+    * may override this method in a subclass to take specific actions
+    * for each warning, such as inserting the message in a log file or
+    * printing it to the console.</p>
+    *
+    * @param e The warning information encoded as an exception.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.ErrorHandler#warning
+    * @see ewesoft.xml.sax.SAXParseException
+    */
+  public void warning (SAXParseException e)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Receive notification of a recoverable parser error.
+    *
+    * <p>The default implementation does nothing.  Application writers
+    * may override this method in a subclass to take specific actions
+    * for each error, such as inserting the message in a log file or
+    * printing it to the console.</p>
+    *
+    * @param e The warning information encoded as an exception.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.ErrorHandler#warning
+    * @see ewesoft.xml.sax.SAXParseException
+    */
+  public void error (SAXParseException e)
+    throws SAXException
+  {
+    // no op
+  }
+
+
+  /**
+    * Report a fatal XML parsing error.
+    *
+    * <p>The default implementation throws a SAXParseException.
+    * Application writers may override this method in a subclass if
+    * they need to take specific actions for each fatal error (such as
+    * collecting all of the errors into a single report): in any case,
+    * the application must stop all regular processing when this
+    * method is invoked, since the document is no longer reliable, and
+    * the parser may no longer report parsing events.</p>
+    *
+    * @param e The error information encoded as an exception.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @see ewesoft.xml.sax.ErrorHandler#fatalError
+    * @see ewesoft.xml.sax.SAXParseException
+    */
+  public void fatalError (SAXParseException e)
+    throws SAXException
+  {
+    throw e;
+  }
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/HandlerBase.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/InputSource.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/InputSource.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/InputSource.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/InputSource.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/InputSource.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,311 @@
+// SAX input source.
+// No warranty; no copyright -- use this as you will.
+// $Id: InputSource.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+import ewe.io.Reader;
+import ewe.io.InputStream;
+
+/**
+  * A single input source for an XML entity.
+  *
+  * <p>This class allows a SAX application to encapsulate information
+  * about an input source in a single object, which may include
+  * a public identifier, a system identifier, a byte stream (possibly
+  * with a specified encoding), and/or a character stream.</p>
+  *
+  * <p>There are two places that the application will deliver this
+  * input source to the parser: as the argument to the Parser.parse
+  * method, or as the return value of the EntityResolver.resolveEntity
+  * method.</p>
+  *
+  * <p>The SAX parser will use the InputSource object to determine how
+  * to read XML input.  If there is a character stream available, the
+  * parser will read that stream directly; if not, the parser will use
+  * a byte stream, if available; if neither a character stream nor a
+  * byte stream is available, the parser will attempt to open a URI
+  * connection to the resource identified by the system
+  * identifier.</p>
+  *
+  * <p>An InputSource object belongs to the application: the SAX parser
+  * shall never modify it in any way (it may modify a copy if 
+  * necessary).</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.Parser#parse
+  * @see ewesoft.xml.sax.EntityResolver#resolveEntity
+  * @see java.io.InputStream
+  * @see java.io.Reader
+  */
+public class InputSource {
+
+  /**
+    * Zero-argument default constructor.
+    *
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setCharacterStream
+    * @see #setEncoding
+    */
+  public InputSource ()
+  {
+  }
+
+
+  /**
+    * Create a new input source with a system identifier.
+    *
+    * <p>Applications may use setPublicId to include a 
+    * public identifier as well, or setEncoding to specify
+    * the character encoding, if known.</p>
+    *
+    * <p>If the system identifier is a URL, it must be full resolved.</p>
+    *
+    * @param systemId The system identifier (URI).
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setEncoding
+    * @see #setCharacterStream
+    */
+  public InputSource (String systemId)
+  {
+    setSystemId(systemId);
+  }
+
+
+  /**
+    * Create a new input source with a byte stream.
+    *
+    * <p>Application writers may use setSystemId to provide a base 
+    * for resolving relative URIs, setPublicId to include a 
+    * public identifier, and/or setEncoding to specify the object's
+    * character encoding.</p>
+    *
+    * @param byteStream The raw byte stream containing the document.
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setEncoding
+    * @see #setByteStream
+    * @see #setCharacterStream
+    */
+  public InputSource (InputStream byteStream)
+  {
+    setByteStream(byteStream);
+  }
+
+
+  /**
+    * Create a new input source with a character stream.
+    *
+    * <p>Application writers may use setSystemId() to provide a base 
+    * for resolving relative URIs, and setPublicId to include a 
+    * public identifier.</p>
+    *
+    * <p>The character stream shall not include a byte order mark.</p>
+    *
+    * @see #setPublicId
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #setCharacterStream
+    */
+  public InputSource (Reader characterStream)
+  {
+    setCharacterStream(characterStream);
+  }
+
+
+  /**
+    * Set the public identifier for this input source.
+    *
+    * <p>The public identifier is always optional: if the application
+    * writer includes one, it will be provided as part of the
+    * location information.</p>
+    *
+    * @param publicId The public identifier as a string.
+    * @see #getPublicId
+    * @see ewesoft.xml.sax.Locator#getPublicId
+    * @see ewesoft.xml.sax.SAXParseException#getPublicId
+    */
+  public void setPublicId (String publicId)
+  {
+    this.publicId = publicId;
+  }
+
+
+  /**
+    * Get the public identifier for this input source.
+    *
+    * @return The public identifier, or null if none was supplied.
+    * @see #setPublicId
+    */
+  public String getPublicId ()
+  {
+    return publicId;
+  }
+
+
+  /**
+    * Set the system identifier for this input source.
+    *
+    * <p>The system identifier is optional if there is a byte stream
+    * or a character stream, but it is still useful to provide one,
+    * since the application can use it to resolve relative URIs
+    * and can include it in error messages and warnings (the parser
+    * will attempt to open a connection to the URI only if
+    * there is no byte stream or character stream specified).</p>
+    *
+    * <p>If the application knows the character encoding of the
+    * object pointed to by the system identifier, it can register
+    * the encoding using the setEncoding method.</p>
+    *
+    * <p>If the system ID is a URL, it must be fully resolved.</p>
+    *
+    * @param systemId The system identifier as a string.
+    * @see #setEncoding
+    * @see #getSystemId
+    * @see ewesoft.xml.sax.Locator#getSystemId
+    * @see ewesoft.xml.sax.SAXParseException#getSystemId
+    */
+  public void setSystemId (String systemId)
+  {
+    this.systemId = systemId;
+  }
+
+
+  /**
+    * Get the system identifier for this input source.
+    *
+    * <p>The getEncoding method will return the character encoding
+    * of the object pointed to, or null if unknown.</p>
+    *
+    * <p>If the system ID is a URL, it will be fully resolved.</p>
+    *
+    * @return The system identifier.
+    * @see #setSystemId
+    * @see #getEncoding
+    */
+  public String getSystemId ()
+  {
+    return systemId;
+  }
+
+
+  /**
+    * Set the byte stream for this input source.
+    *
+    * <p>The SAX parser will ignore this if there is also a character
+    * stream specified, but it will use a byte stream in preference
+    * to opening a URI connection itself.</p>
+    *
+    * <p>If the application knows the character encoding of the
+    * byte stream, it should set it with the setEncoding method.</p>
+    *
+    * @param byteStream A byte stream containing an XML document or
+    *        other entity.
+    * @see #setEncoding
+    * @see #getByteStream
+    * @see #getEncoding
+    * @see java.io.InputStream
+    */
+  public void setByteStream (InputStream byteStream)
+  {
+    this.byteStream = byteStream;
+  }
+
+
+  /**
+    * Get the byte stream for this input source.
+    *
+    * <p>The getEncoding method will return the character
+    * encoding for this byte stream, or null if unknown.</p>
+    *
+    * @return The byte stream, or null if none was supplied.
+    * @see #getEncoding
+    * @see #setByteStream
+    */
+  public InputStream getByteStream ()
+  {
+    return byteStream;
+  }
+
+
+  /** 
+    * Set the character encoding, if known.
+    *
+    * <p>The encoding must be a string acceptable for an
+    * XML encoding declaration (see section 4.3.3 of the XML 1.0
+    * recommendation).</p>
+    *
+    * <p>This method has no effect when the application provides a
+    * character stream.</p>
+    *
+    * @param encoding A string describing the character encoding.
+    * @see #setSystemId
+    * @see #setByteStream
+    * @see #getEncoding
+    */
+  public void setEncoding (String encoding)
+  {
+    this.encoding = encoding;
+  }
+
+
+  /**
+    * Get the character encoding for a byte stream or URI.
+    *
+    * @return The encoding, or null if none was supplied.
+    * @see #setByteStream
+    * @see #getSystemId
+    * @see #getByteStream
+    */
+  public String getEncoding ()
+  {
+    return encoding;
+  }
+
+
+  /**
+    * Set the character stream for this input source.
+    *
+    * <p>If there is a character stream specified, the SAX parser
+    * will ignore any byte stream and will not attempt to open
+    * a URI connection to the system identifier.</p>
+    *
+    * @param characterStream The character stream containing the
+    *        XML document or other entity.
+    * @see #getCharacterStream
+    * @see java.io.Reader
+    */
+  public void setCharacterStream (Reader characterStream)
+  {
+    this.characterStream = characterStream;
+  }
+
+
+  /**
+    * Get the character stream for this input source.
+    *
+    * @return The character stream, or null if none was supplied.
+    * @see #setCharacterStream
+    */
+  public Reader getCharacterStream ()
+  {
+    return characterStream;
+  }
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String publicId;
+  private String systemId;
+  private InputStream byteStream;
+  private String encoding;
+  private Reader characterStream;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/InputSource.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/Locator.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/Locator.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/Locator.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/Locator.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/Locator.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,80 @@
+// SAX locator interface for document events.
+// No warranty; no copyright -- use this as you will.
+// $Id: Locator.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+
+/**
+  * Interface for associating a SAX event with a document location.
+  *
+  * <p>If a SAX parser provides location information to the SAX
+  * application, it does so by implementing this interface and then
+  * passing an instance to the application using the document
+  * handler's setDocumentLocator method.  The application can use the
+  * object to obtain the location of any other document handler event
+  * in the XML source document.</p>
+  *
+  * <p>Note that the results returned by the object will be valid only
+  * during the scope of each document handler method: the application
+  * will receive unpredictable results if it attempts to use the
+  * locator at any other time.</p>
+  *
+  * <p>SAX parsers are not required to supply a locator, but they are
+  * very strong encouraged to do so.  If the parser supplies a
+  * locator, it must do so before reporting any other document events.
+  * If no locator has been set by the time the application receives
+  * the startDocument event, the application should assume that a
+  * locator is not available.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.DocumentHandler#setDocumentLocator 
+  */
+public interface Locator {
+
+
+  /**
+    * Return the public identifier for the current document event.
+    * <p>This will be the public identifier
+    * @return A string containing the public identifier, or
+    *         null if none is available.
+    * @see #getSystemId
+    */
+  public abstract String getPublicId ();
+
+
+  /**
+    * Return the system identifier for the current document event.
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before passing it to the application.</p>
+    *
+    * @return A string containing the system identifier, or null
+    *         if none is available.
+    * @see #getPublicId
+    */
+  public abstract String getSystemId ();
+
+
+  /**
+    * Return the line number where the current document event ends.
+    * Note that this is the line position of the first character
+    * after the text associated with the document event.
+    * @return The line number, or -1 if none is available.
+    * @see #getColumnNumber
+    */
+  public abstract int getLineNumber ();
+
+
+  /**
+    * Return the column number where the current document event ends.
+    * Note that this is the column number of the first
+    * character after the text associated with the document
+    * event.  The first column in a line is position 1.
+    * @return The column number, or -1 if none is available.
+    * @see #getLineNumber
+    */
+  public abstract int getColumnNumber ();
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/Locator.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/Parser.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/Parser.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/Parser.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/Parser.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/Parser.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,190 @@
+// SAX parser interface.
+// No warranty; no copyright -- use this as you will.
+// $Id: Parser.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+import ewe.io.IOException;
+import ewe.sys.Locale;
+
+
+/**
+  * Basic interface for SAX (Simple API for XML) parsers.
+  *
+  * <p>All SAX parsers must implement this basic interface: it allows
+  * applications to register handlers for different types of events
+  * and to initiate a parse from a URI, or a character stream.</p>
+  *
+  * <p>All SAX parsers must also implement a zero-argument constructor
+  * (though other constructors are also allowed).</p>
+  *
+  * <p>SAX parsers are reusable but not re-entrant: the application
+  * may reuse a parser object (possibly with a different input source)
+  * once the first parse has completed successfully, but it may not
+  * invoke the parse() methods recursively within a parse.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.EntityResolver
+  * @see ewesoft.xml.sax.DTDHandler
+  * @see ewesoft.xml.sax.DocumentHandler
+  * @see ewesoft.xml.sax.ErrorHandler
+  * @see ewesoft.xml.sax.HandlerBase
+  * @see ewesoft.xml.sax.InputSource
+  */
+public interface Parser 
+{
+
+  /**
+    * Allow an application to request a locale for errors and warnings.
+    *
+    * <p>SAX parsers are not required to provide localisation for errors
+    * and warnings; if they cannot support the requested locale,
+    * however, they must throw a SAX exception.  Applications may
+    * not request a locale change in the middle of a parse.</p>
+    *
+    * @param locale A Java Locale object.
+    * @exception ewesoft.xml.sax.SAXException Throws an exception
+    *            (using the previous or default locale) if the 
+    *            requested locale is not supported.
+    * @see ewesoft.xml.sax.SAXException
+    * @see ewesoft.xml.sax.SAXParseException
+    */
+  public abstract void setLocale (Locale locale)
+    throws SAXException;
+
+
+  /**
+    * Allow an application to register a custom entity resolver.
+    *
+    * <p>If the application does not register an entity resolver, the
+    * SAX parser will resolve system identifiers and open connections
+    * to entities itself (this is the default behaviour implemented in
+    * HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different entity resolver
+    * in the middle of a parse, and the SAX parser must begin using
+    * the new resolver immediately.</p>
+    *
+    * @param resolver The object for resolving entities.
+    * @see EntityResolver
+    * @see HandlerBase
+    */
+  public abstract void setEntityResolver (EntityResolver resolver);
+
+
+  /**
+    * Allow an application to register a DTD event handler.
+    *
+    * <p>If the application does not register a DTD handler, all DTD
+    * events reported by the SAX parser will be silently
+    * ignored (this is the default behaviour implemented by
+    * HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different
+    * handler in the middle of a parse, and the SAX parser must
+    * begin using the new handler immediately.</p>
+    *
+    * @param handler The DTD handler.
+    * @see DTDHandler
+    * @see HandlerBase
+    */
+  public abstract void setDTDHandler (DTDHandler handler);
+
+
+  /**
+    * Allow an application to register a document event handler.
+    *
+    * <p>If the application does not register a document handler, all
+    * document events reported by the SAX parser will be silently
+    * ignored (this is the default behaviour implemented by
+    * HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different handler in the
+    * middle of a parse, and the SAX parser must begin using the new
+    * handler immediately.</p>
+    *
+    * @param handler The document handler.
+    * @see DocumentHandler
+    * @see HandlerBase
+    */
+  public abstract void setDocumentHandler (DocumentHandler handler);
+
+
+  /**
+    * Allow an application to register an error event handler.
+    *
+    * <p>If the application does not register an error event handler,
+    * all error events reported by the SAX parser will be silently
+    * ignored, except for fatalError, which will throw a SAXException
+    * (this is the default behaviour implemented by HandlerBase).</p>
+    *
+    * <p>Applications may register a new or different handler in the
+    * middle of a parse, and the SAX parser must begin using the new
+    * handler immediately.</p>
+    *
+    * @param handler The error handler.
+    * @see ErrorHandler
+    * @see SAXException
+    * @see HandlerBase
+    */
+  public abstract void setErrorHandler (ErrorHandler handler);
+
+
+  /**
+    * Parse an XML document.
+    *
+    * <p>The application can use this method to instruct the SAX parser
+    * to begin parsing an XML document from any valid input
+    * source (a character stream, a byte stream, or a URI).</p>
+    *
+    * <p>Applications may not invoke this method while a parse is in
+    * progress (they should create a new Parser instead for each
+    * additional XML document).  Once a parse is complete, an
+    * application may reuse the same Parser object, possibly with a
+    * different input source.</p>
+    *
+    * @param source The input source for the top-level of the
+    *        XML document.
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException An IO exception from the parser,
+    *            possibly from a byte stream or character stream
+    *            supplied by the application.
+    * @see ewesoft.xml.sax.InputSource
+    * @see #parse(java.lang.String)
+    * @see #setEntityResolver
+    * @see #setDTDHandler
+    * @see #setDocumentHandler
+    * @see #setErrorHandler
+    */
+  public abstract void parse (InputSource source)
+    throws SAXException, IOException;
+
+
+  /**
+    * Parse an XML document from a system identifier (URI).
+    *
+    * <p>This method is a shortcut for the common case of reading a
+    * document from a system identifier.  It is the exact
+    * equivalent of the following:</p>
+    *
+    * <pre>
+    * parse(new InputSource(systemId));
+    * </pre>
+    *
+    * <p>If the system identifier is a URL, it must be fully resolved
+    * by the application before it is passed to the parser.</p>
+    *
+    * @param systemId The system identifier (URI).
+    * @exception ewesoft.xml.sax.SAXException Any SAX exception, possibly
+    *            wrapping another exception.
+    * @exception java.io.IOException An IO exception from the parser,
+    *            possibly from a byte stream or character stream
+    *            supplied by the application.
+    * @see #parse(ewesoft.xml.sax.InputSource)
+    */
+  public abstract void parse (String systemId)
+    throws SAXException, IOException;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/Parser.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/SAXException.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/SAXException.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/SAXException.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/SAXException.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/SAXException.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,128 @@
+// SAX exception class.
+// No warranty; no copyright -- use this as you will.
+// $Id: SAXException.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+/**
+  * Encapsulate a general SAX error or warning.
+  *
+  * <p>This class can contain basic error or warning information from
+  * either the XML parser or the application: a parser writer or
+  * application writer can subclass it to provide additional
+  * functionality.  SAX handlers may throw this exception or
+  * any exception subclassed from it.</p>
+  *
+  * <p>If the application needs to pass through other types of
+  * exceptions, it must wrap those exceptions in a SAXException
+  * or an exception derived from a SAXException.</p>
+  *
+  * <p>If the parser or application needs to include information about a
+  * specific location in an XML document, it should use the
+  * SAXParseException subclass.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.SAXParseException
+  */
+public class SAXException extends Exception {
+
+
+  /**
+    * Create a new SAXException.
+    *
+    * @param message The error or warning message.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public SAXException (String message) {
+    super();
+    this.message = message;
+    this.exception = null;
+  }
+
+
+  /**
+    * Create a new SAXException wrapping an existing exception.
+    *
+    * <p>The existing exception will be embedded in the new
+    * one, and its message will become the default message for
+    * the SAXException.</p>
+    *
+    * @param e The exception to be wrapped in a SAXException.
+    */
+  public SAXException (Exception e)
+  {
+    super();
+    this.message = null;
+    this.exception = e;
+  }
+
+
+  /**
+    * Create a new SAXException from an existing exception.
+    *
+    * <p>The existing exception will be embedded in the new
+    * one, but the new exception will have its own message.</p>
+    *
+    * @param message The detail message.
+    * @param e The exception to be wrapped in a SAXException.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public SAXException (String message, Exception e)
+  {
+    super();
+    this.message = message;
+    this.exception = e;
+  }
+
+
+  /**
+    * Return a detail message for this exception.
+    *
+    * <p>If there is a embedded exception, and if the SAXException
+    * has no detail message of its own, this method will return
+    * the detail message from the embedded exception.</p>
+    *
+    * @return The error or warning message.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public String getMessage ()
+  {
+    if (message == null && exception != null) {
+      return exception.getMessage();
+    } else {
+      return this.message;
+    }
+  }
+
+
+  /**
+    * Return the embedded exception, if any.
+    *
+    * @return The embedded exception, or null if there is none.
+    */
+  public Exception getException ()
+  {
+    return exception;
+  }
+
+
+  /**
+    * Convert this exception to a string.
+    *
+    * @return A string version of this exception.
+    */
+  public String toString ()
+  {
+    return getMessage();
+  }
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String message;
+  private Exception exception;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/SAXException.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/lib/ewesoft/xml/sax/SAXParseException.class
===================================================================
(Binary files differ)


Property changes on: trunk/lib/ewesoft/xml/sax/SAXParseException.class
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/lib/ewesoft/xml/sax/SAXParseException.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/SAXParseException.java	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/lib/ewesoft/xml/sax/SAXParseException.java	2007-10-25 16:32:52 UTC (rev 993)
@@ -0,0 +1,210 @@
+// SAX exception class.
+// No warranty; no copyright -- use this as you will.
+// $Id: SAXParseException.java,v 1.2 2004/09/13 21:00:18 damon Exp $
+
+package ewesoft.xml.sax;
+
+/**
+  * Encapsulate an XML parse error or warning.
+  *
+  * <p>This exception will include information for locating the error
+  * in the original XML document.  Note that although the application
+  * will receive a SAXParseException as the argument to the handlers
+  * in the ErrorHandler interface, the application is not actually
+  * required to throw the exception; instead, it can simply read the
+  * information in it and take a different action.</p>
+  *
+  * <p>Since this exception is a subclass of SAXException, it
+  * inherits the ability to wrap another exception.</p>
+  *
+  * @author David Megginson (ak117 at freenet.carleton.ca)
+  * @version 1.0
+  * @see ewesoft.xml.sax.SAXException
+  * @see ewesoft.xml.sax.Locator
+  * @see ewesoft.xml.sax.ErrorHandler
+  */
+public class SAXParseException extends SAXException {
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Constructors.
+  //////////////////////////////////////////////////////////////////////
+
+  /**
+    * Create a new SAXParseException from a message and a Locator.
+    *
+    * <p>This constructor is especially useful when an application is
+    * creating its own exception from within a DocumentHandler
+    * callback.</p>
+    *
+    * @param message The error or warning message.
+    * @param locator The locator object for the error or warning.
+    * @see ewesoft.xml.sax.Locator
+    * @see ewesoft.xml.sax.Parser#setLocale 
+    */
+  public SAXParseException (String message, Locator locator) {
+    super(message);
+    this.publicId = locator.getPublicId();
+    this.systemId = locator.getSystemId();
+    this.lineNumber = locator.getLineNumber();
+    this.columnNumber = locator.getColumnNumber();
+  }
+
+
+  /**
+    * Wrap an existing exception in a SAXParseException.
+    *
+    * <p>This constructor is especially useful when an application is
+    * creating its own exception from within a DocumentHandler
+    * callback, and needs to wrap an existing exception that is not a
+    * subclass of SAXException.</p>
+    *
+    * @param message The error or warning message, or null to
+    *                use the message from the embedded exception.
+    * @param locator The locator object for the error or warning.
+    * @param e Any exception
+    * @see ewesoft.xml.sax.Locator
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public SAXParseException (String message, Locator locator,
+			    Exception e) {
+    super(message, e);
+    this.publicId = locator.getPublicId();
+    this.systemId = locator.getSystemId();
+    this.lineNumber = locator.getLineNumber();
+    this.columnNumber = locator.getColumnNumber();
+  }
+
+
+  /**
+    * Create a new SAXParseException.
+    *
+    * <p>This constructor is most useful for parser writers.</p>
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before creating the exception.</p>
+    *
+    * @param message The error or warning message.
+    * @param publicId The public identifer of the entity that generated
+    *                 the error or warning.
+    * @param systemId The system identifer of the entity that generated
+    *                 the error or warning.
+    * @param lineNumber The line number of the end of the text that
+    *                   caused the error or warning.
+    * @param columnNumber The column number of the end of the text that
+    *                     cause the error or warning.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public SAXParseException (String message, String publicId, String systemId,
+			    int lineNumber, int columnNumber)
+  {
+    super(message);
+    this.publicId = publicId;
+    this.systemId = systemId;
+    this.lineNumber = lineNumber;
+    this.columnNumber = columnNumber;
+  }
+
+
+  /**
+    * Create a new SAXParseException with an embedded exception.
+    *
+    * <p>This constructor is most useful for parser writers who
+    * need to wrap an exception that is not a subclass of
+    * SAXException.</p>
+    *
+    * <p>If the system identifier is a URL, the parser must resolve it
+    * fully before creating the exception.</p>
+    *
+    * @param message The error or warning message, or null to use
+    *                the message from the embedded exception.
+    * @param publicId The public identifer of the entity that generated
+    *                 the error or warning.
+    * @param systemId The system identifer of the entity that generated
+    *                 the error or warning.
+    * @param lineNumber The line number of the end of the text that
+    *                   caused the error or warning.
+    * @param columnNumber The column number of the end of the text that
+    *                     cause the error or warning.
+    * @param e Another exception to embed in this one.
+    * @see ewesoft.xml.sax.Parser#setLocale
+    */
+  public SAXParseException (String message, String publicId, String systemId,
+			    int lineNumber, int columnNumber, Exception e)
+  {
+    super(message, e);
+    this.publicId = publicId;
+    this.systemId = systemId;
+    this.lineNumber = lineNumber;
+    this.columnNumber = columnNumber;
+  }
+
+
+  /**
+    * Get the public identifier of the entity where the exception occurred.
+    *
+    * @return A string containing the public identifier, or null
+    *         if none is available.
+    * @see ewesoft.xml.sax.Locator#getPublicId
+    */
+  public String getPublicId ()
+  {
+    return this.publicId;
+  }
+
+
+  /**
+    * Get the system identifier of the entity where the exception occurred.
+    *
+    * <p>If the system identifier is a URL, it will be resolved
+    * fully.</p>
+    *
+    * @return A string containing the system identifier, or null
+    *         if none is available.
+    * @see ewesoft.xml.sax.Locator#getSystemId
+    */
+  public String getSystemId ()
+  {
+    return this.systemId;
+  }
+
+
+  /**
+    * The line number of the end of the text where the exception occurred.
+    *
+    * @return An integer representing the line number, or -1
+    *         if none is available.
+    * @see ewesoft.xml.sax.Locator#getLineNumber
+    */
+  public int getLineNumber ()
+  {
+    return this.lineNumber;
+  }
+
+
+  /**
+    * The column number of the end of the text where the exception occurred.
+    *
+    * <p>The first column in a line is position 1.</p>
+    *
+    * @return An integer representing the column number, or -1
+    *         if none is available.
+    * @see ewesoft.xml.sax.Locator#getColumnNumber
+    */
+  public int getColumnNumber ()
+  {
+    return this.columnNumber;
+  }
+
+
+
+  //////////////////////////////////////////////////////////////////////
+  // Internal state.
+  //////////////////////////////////////////////////////////////////////
+
+  private String publicId;
+  private String systemId;
+  private int lineNumber;
+  private int columnNumber;
+
+}


Property changes on: trunk/lib/ewesoft/xml/sax/SAXParseException.java
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: trunk/lib/ewesoft.zip
===================================================================
(Binary files differ)

Deleted: trunk/lib/openmap.jar
===================================================================
(Binary files differ)

Modified: trunk/runconsole.bat
===================================================================
--- trunk/runconsole.bat	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/runconsole.bat	2007-10-25 16:32:52 UTC (rev 993)
@@ -1,3 +1,3 @@
 cd work
-java -Dcom.sun.management.jmxremote -cp ../lib/ewe.jar;../lib/ewesoft.zip;../lib/EwesoftRegex.zip;../lib/HTML.zip;../lib/openmap.jar;../bin Ewe CacheWolf.CacheWolf
+java -Dcom.sun.management.jmxremote -cp ../lib/ewe.jar;../lib;../bin Ewe CacheWolf.CacheWolf
 cd ..

Modified: trunk/runwolf.bat
===================================================================
--- trunk/runwolf.bat	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/runwolf.bat	2007-10-25 16:32:52 UTC (rev 993)
@@ -1,3 +1,3 @@
 cd work
-java -cp ../lib/ewe.jar;../lib/ewesoft.zip;../lib/EwesoftRegex.zip;../lib/HTML.zip;../lib/openmap.jar;../bin Ewe CacheWolf.CacheWolf
+java -cp ../lib/ewe.jar;../lib;../bin Ewe CacheWolf.CacheWolf
 cd ..

Modified: trunk/runwolf.sh
===================================================================
--- trunk/runwolf.sh	2007-10-25 14:00:05 UTC (rev 992)
+++ trunk/runwolf.sh	2007-10-25 16:32:52 UTC (rev 993)
@@ -1,4 +1,4 @@
 #!/bin/sh
 cd work
-java -cp ../lib/ewe.jar:../lib/ewesoft.zip:../lib/EwesoftRegex.zip:../lib/HTML.zip:../lib/openmap.jar:../bin Ewe CacheWolf.CacheWolf
+java -cp ../lib/ewe.jar:../lib:../bin Ewe CacheWolf.CacheWolf
 cd ..



From mirabilos at mail.berlios.de  Thu Oct 25 18:41:12 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Thu, 25 Oct 2007 18:41:12 +0200
Subject: [Cachewolf-svn] r994 - trunk/src/CacheWolf
Message-ID: <200710251641.l9PGfC6j012074@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-25 18:41:12 +0200 (Thu, 25 Oct 2007)
New Revision: 994

Modified:
   trunk/src/CacheWolf/myTableControl.java
Log:
src/CacheWolf/myTableControl.java: In class `CacheWolf.myTableControl':
src/CacheWolf/myTableControl.java: In method `CacheWolf.myTableControl.popupMenuEvent(java.lang.Object)':
src/CacheWolf/myTableControl.java:197: error: Incompatible type for declaration. Can't convert `java.lang.Integer' to `int'.
                                int i = (Integer)cachesToUpdate.get(j);
                                       ^
1 error


Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-10-25 16:32:52 UTC (rev 993)
+++ trunk/src/CacheWolf/myTableControl.java	2007-10-25 16:41:12 UTC (rev 994)
@@ -194,7 +194,7 @@
 			}
 
 			for(int j = 0; j <	cachesToUpdate.size(); j++){
-				int i = (Integer)cachesToUpdate.get(j);
+				int i = ((Integer)cachesToUpdate.get(j)).intValue();
 				ch = (CacheHolder)cacheDB.get(i);
 				infB.setInfo("Loading: " + ch.wayPoint);
 				infB.setInfo(MyLocale.getMsg(5513,"Loading: ") + ch.wayPoint +" (" + (j+1) + " / " + cachesToUpdate.size() + ")");



From pfeffer at mail.berlios.de  Thu Oct 25 21:34:19 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Oct 2007 21:34:19 +0200
Subject: [Cachewolf-svn] r995 - trunk
Message-ID: <200710251934.l9PJYJpu023827@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-25 21:34:16 +0200 (Thu, 25 Oct 2007)
New Revision: 995

Modified:
   trunk/.classpath
Log:
added sourceattachment for eclipse

Modified: trunk/.classpath
===================================================================
--- trunk/.classpath	2007-10-25 16:41:12 UTC (rev 994)
+++ trunk/.classpath	2007-10-25 19:34:16 UTC (rev 995)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="lib" path="lib/CompileEwe.zip"/>
+	<classpathentry kind="lib" path="lib/CompileEwe.zip" sourcepath="lib/JavaEwe.zip"/>
 	<classpathentry kind="lib" path="lib/ewe.jar"/>
 	<classpathentry kind="lib" path="lib"/>
 	<classpathentry kind="output" path="bin"/>



From pfeffer at mail.berlios.de  Thu Oct 25 21:56:47 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Oct 2007 21:56:47 +0200
Subject: [Cachewolf-svn] r996 - trunk/lib
Message-ID: <200710251956.l9PJult3025292@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-25 21:51:33 +0200 (Thu, 25 Oct 2007)
New Revision: 996

Added:
   trunk/lib/JavaEwe.zip
Log:
for easy debugging

Added: trunk/lib/JavaEwe.zip
===================================================================
(Binary files differ)


Property changes on: trunk/lib/JavaEwe.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From pfeffer at mail.berlios.de  Thu Oct 25 21:59:38 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Thu, 25 Oct 2007 21:59:38 +0200
Subject: [Cachewolf-svn] r997 - trunk/src/CacheWolf/navi
Message-ID: <200710251959.l9PJxc8k025377@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-25 21:59:36 +0200 (Thu, 25 Oct 2007)
New Revision: 997

Modified:
   trunk/src/CacheWolf/navi/MovingMap.java
Log:
MovingMap: small Bugfix found by Mik when selecting a map manually

Modified: trunk/src/CacheWolf/navi/MovingMap.java
===================================================================
--- trunk/src/CacheWolf/navi/MovingMap.java	2007-10-25 19:51:33 UTC (rev 996)
+++ trunk/src/CacheWolf/navi/MovingMap.java	2007-10-25 19:59:36 UTC (rev 997)
@@ -1793,6 +1793,7 @@
 					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
 					else { map = ml.getMap();}
 				} catch (IOException ex) {continue; } // could not read .wfl-file
+				if( map.isInBound(Gps.latDec, Gps.lonDec) ) 
 				{
 					list.addItem(i + ": " + map.mapName);
 					row++;



From salzkammergut at mail.berlios.de  Fri Oct 26 16:44:42 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 26 Oct 2007 16:44:42 +0200
Subject: [Cachewolf-svn] r998 - trunk/src/CacheWolf
Message-ID: <200710261444.l9QEigs8021707@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-26 16:44:33 +0200 (Fri, 26 Oct 2007)
New Revision: 998

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
Profile: Fix for setAddiRef. Did not work correctly with 7 character waypoint names that are now used by GC (Older 6 character waypoint names were OK).

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-10-25 19:59:36 UTC (rev 997)
+++ trunk/src/CacheWolf/Profile.java	2007-10-26 14:44:33 UTC (rev 998)
@@ -378,7 +378,7 @@
 	 * @param ch
 	 */
 	public void setAddiRef(CacheHolder ch) {
-		String mainwpt = ch.wayPoint.substring(ch.wayPoint.length()-4);
+		String mainwpt = ch.wayPoint.substring(2);
 		int mainindex = getCacheIndex("GC"+mainwpt);
 		if (mainindex < 0) mainindex = getCacheIndex("OC"+mainwpt);
 		if (mainindex < 0) mainindex = getCacheIndex("CW"+mainwpt);



From mirabilos at mail.berlios.de  Fri Oct 26 17:48:01 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 26 Oct 2007 17:48:01 +0200
Subject: [Cachewolf-svn] r999 - in trunk: . programs
Message-ID: <200710261548.l9QFm1mD027258@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-26 17:43:54 +0200 (Fri, 26 Oct 2007)
New Revision: 999

Added:
   trunk/fwrtsnapshot.sh
   trunk/programs/
   trunk/programs/Jewel.ewe
   trunk/programs/JewelData.jar
Modified:
   trunk/
Log:
add BE-autobuild-infrastructure


Property changes on: trunk
___________________________________________________________________
Name: svn:ignore
   + published


Added: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-26 14:44:33 UTC (rev 998)
+++ trunk/fwrtsnapshot.sh	2007-10-26 15:43:54 UTC (rev 999)
@@ -0,0 +1,24 @@
+#!/bin/sh
+# $Id$
+
+v=$(svn info | sed -n '/Revision: /s///p')
+echo '/VER_SVN =/s/\$.*\$/$LastChangedRevision: '$v' $/\nwq' | \
+    ed -s src/CacheWolf/Version.java
+javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
+java -cp lib/ewe.jar Ewe programs/Jewel.ewe -c cwberlios.jnf
+-rm -rf published
+mkdir -p published/attributes
+cd programs/CacheWolf && mv * ../../published/
+chmod 755 published/*
+chmod 644 published/*/*
+install -c -m 644 work/CacheWolf.ewe published/
+install -c -m 644 resources/*.{def,html,tpl,zip} published/
+install -c -m 644 resources/attributes-big/*.gif published/attributes/
+mkdir -p ~/public_html/CacheWolf-BE/r$v
+cd published && \
+    find *.{def,html,tpl,zip} attributes/*.gif -type f | sort | \
+    cpio -oC512 -Hustar -Mdist | gzip -n9 >datfiles.tgz && \
+    rm -rf *.{def,html,tpl,zip} attributes && \
+    chmod 644 datfiles.tgz && \
+    mv * ~/public_html/CacheWolf-BE/r$v/
+rm -rf published


Property changes on: trunk/fwrtsnapshot.sh
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native


Property changes on: trunk/programs
___________________________________________________________________
Name: svn:ignore
   + CacheWolf


Added: trunk/programs/Jewel.ewe
===================================================================
(Binary files differ)


Property changes on: trunk/programs/Jewel.ewe
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/programs/JewelData.jar
===================================================================
(Binary files differ)


Property changes on: trunk/programs/JewelData.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From salzkammergut at mail.berlios.de  Fri Oct 26 17:50:36 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 26 Oct 2007 17:50:36 +0200
Subject: [Cachewolf-svn] r1000 - trunk/resources
Message-ID: <200710261550.l9QFoaJ0027427@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-26 17:50:33 +0200 (Fri, 26 Oct 2007)
New Revision: 1000

Modified:
   trunk/resources/info.html
   trunk/resources/wolflang.html
Log:
Update of the Wolflang help screen and the info screen.

Modified: trunk/resources/info.html
===================================================================
--- trunk/resources/info.html	2007-10-26 15:43:54 UTC (rev 999)
+++ trunk/resources/info.html	2007-10-26 15:50:33 UTC (rev 1000)
@@ -3,7 +3,7 @@
 <font face="Tahoma" size = "3">
 <strong>A geocaching programm</strong><br>
 <font face="Tahoma" size = "2"><em>
-from Bilbowolf, Kalli, Pfeffer, Reini, MiK, Blackeye501, mirabilos<br>
+from Bilbowolf, Kalli, Pfeffer, salzkammergut, MiK, Blackeye501, mirabilos<br>
 for Windows, Linux and Pocket PC</em><br>
 <br>
 CacheWolf was created sometime 2003 to enable paperless caching with a Sharp Zaurus.

Modified: trunk/resources/wolflang.html
===================================================================
--- trunk/resources/wolflang.html	2007-10-26 15:43:54 UTC (rev 999)
+++ trunk/resources/wolflang.html	2007-10-26 15:50:33 UTC (rev 1000)
@@ -12,6 +12,7 @@
 $a is global variable.<br>
 Format numerical expression:<br>
 Example: 3.14159:000.00:<br>
+<i>Format chars:</i> 0 . # where # stands for any number of decimal chars<br> 
 <br>
 <u><b> Showing values</b></u><br>
  "some text" " more text":<br>
@@ -30,6 +31,9 @@
 <i> Example: a = cos(1);<br>
  or a = atan(b);</i><br>
 <br>
+<b><u>Numeric functions</u></b><br>
+ct(number) # crosstotal<br>
+q(number) # Quersumme/crosstotal<br><br>
 <b><u>Text functions</u></b>[s is a string]<br>
 length(s)<br>
 mid(s,startpos,length)<br> 
@@ -45,13 +49,18 @@
 sval(s)<i> # A=1, B=2, ... Z=26</i><br>
 rot13(s)<br><br>
 <b><u>Coordinate</u></b><br>
+bearing(coordinate1,coordinate2)<br>
+center() # get current center<br>
+center(coordinate)<br>
+cp() # get current GPS position<br>
+distance(coordinate1,coordinate2)<br>  
 format(coordinate,fmt) <br>
   <i>where fmt="CW" or "UTM" or "DMS" or "DD"</i><br>
-project(coordinate,angle,distance)<br>
 goto(coordinate)<br>
-goto(coordinate,waypointname)<br><br>
+goto(coordinate,waypointname)<br>
+project(coordinate,angle,distance)<br><br>
 <b><u>Generate program for Multis (with/without addi Wpts)</u></b><br>
-skeleton(waypointname)   also<br><br>
+skeleton() # current cache   also<br>
 skeleton(numberOfStages)<br><br>
 <b><u>IF THEN ENDIF</u></b><br>
 IF condition THEN statement; statement .... ENDIF<br><br>



From mirabilos at mail.berlios.de  Fri Oct 26 18:39:29 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 26 Oct 2007 18:39:29 +0200
Subject: [Cachewolf-svn] r1001 - trunk
Message-ID: <200710261639.l9QGdTMi023339@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-26 18:39:27 +0200 (Fri, 26 Oct 2007)
New Revision: 1001

Modified:
   trunk/fwrtsnapshot.sh
Log:
? need ?ewecl?, because normal Ewe needs X-Window running to work,
  even for command-line Jewel or HelloWorld applications
? remove artifact dash from Makefile


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-26 15:50:33 UTC (rev 1000)
+++ trunk/fwrtsnapshot.sh	2007-10-26 16:39:27 UTC (rev 1001)
@@ -5,8 +5,8 @@
 echo '/VER_SVN =/s/\$.*\$/$LastChangedRevision: '$v' $/\nwq' | \
     ed -s src/CacheWolf/Version.java
 javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
-java -cp lib/ewe.jar Ewe programs/Jewel.ewe -c cwberlios.jnf
--rm -rf published
+/usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
+rm -rf published
 mkdir -p published/attributes
 cd programs/CacheWolf && mv * ../../published/
 chmod 755 published/*



From mirabilos at mail.berlios.de  Fri Oct 26 18:44:51 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 26 Oct 2007 18:44:51 +0200
Subject: [Cachewolf-svn] r1002 - trunk
Message-ID: <200710261644.l9QGipCp029869@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-26 18:44:49 +0200 (Fri, 26 Oct 2007)
New Revision: 1002

Modified:
   trunk/fwrtsnapshot.sh
Log:
next round of fixes

Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-26 16:39:27 UTC (rev 1001)
+++ trunk/fwrtsnapshot.sh	2007-10-26 16:44:49 UTC (rev 1002)
@@ -8,17 +8,17 @@
 /usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
 rm -rf published
 mkdir -p published/attributes
-cd programs/CacheWolf && mv * ../../published/
+mv programs/CacheWolf/* published/
 chmod 755 published/*
 chmod 644 published/*/*
 install -c -m 644 work/CacheWolf.ewe published/
 install -c -m 644 resources/*.{def,html,tpl,zip} published/
 install -c -m 644 resources/attributes-big/*.gif published/attributes/
-mkdir -p ~/public_html/CacheWolf-BE/r$v
-cd published && \
+(cd published && \
     find *.{def,html,tpl,zip} attributes/*.gif -type f | sort | \
-    cpio -oC512 -Hustar -Mdist | gzip -n9 >datfiles.tgz && \
+    /usr/local/bin/cpio -oC512 -Hustar -Mdist | gzip -n9 >datfiles.tgz && \
     rm -rf *.{def,html,tpl,zip} attributes && \
-    chmod 644 datfiles.tgz && \
-    mv * ~/public_html/CacheWolf-BE/r$v/
+    chmod 644 datfiles.tgz)
+mkdir -p ~/public_html/CacheWolf-BE/r$v
+mv published/* ~/public_html/CacheWolf-BE/r$v/
 rm -rf published



From mik77 at mail.berlios.de  Fri Oct 26 19:19:57 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 26 Oct 2007 19:19:57 +0200
Subject: [Cachewolf-svn] r1003 - trunk
Message-ID: <200710261719.l9QHJvJu003628@sheep.berlios.de>

Author: mik77
Date: 2007-10-26 19:19:49 +0200 (Fri, 26 Oct 2007)
New Revision: 1003

Added:
   trunk/cwsnapshot.sh
Removed:
   trunk/fwrtsnapshot.sh
Log:
we don't program routers here ;-)

Copied: trunk/cwsnapshot.sh (from rev 1002, trunk/fwrtsnapshot.sh)

Deleted: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-26 16:44:49 UTC (rev 1002)
+++ trunk/fwrtsnapshot.sh	2007-10-26 17:19:49 UTC (rev 1003)
@@ -1,24 +0,0 @@
-#!/bin/sh
-# $Id$
-
-v=$(svn info | sed -n '/Revision: /s///p')
-echo '/VER_SVN =/s/\$.*\$/$LastChangedRevision: '$v' $/\nwq' | \
-    ed -s src/CacheWolf/Version.java
-javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
-/usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
-rm -rf published
-mkdir -p published/attributes
-mv programs/CacheWolf/* published/
-chmod 755 published/*
-chmod 644 published/*/*
-install -c -m 644 work/CacheWolf.ewe published/
-install -c -m 644 resources/*.{def,html,tpl,zip} published/
-install -c -m 644 resources/attributes-big/*.gif published/attributes/
-(cd published && \
-    find *.{def,html,tpl,zip} attributes/*.gif -type f | sort | \
-    /usr/local/bin/cpio -oC512 -Hustar -Mdist | gzip -n9 >datfiles.tgz && \
-    rm -rf *.{def,html,tpl,zip} attributes && \
-    chmod 644 datfiles.tgz)
-mkdir -p ~/public_html/CacheWolf-BE/r$v
-mv published/* ~/public_html/CacheWolf-BE/r$v/
-rm -rf published



From mirabilos at mail.berlios.de  Fri Oct 26 19:33:25 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 26 Oct 2007 19:33:25 +0200
Subject: [Cachewolf-svn] r1004 - trunk
Message-ID: <200710261733.l9QHXPML018994@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-26 19:33:25 +0200 (Fri, 26 Oct 2007)
New Revision: 1004

Added:
   trunk/fwrtsnapshot.sh
Removed:
   trunk/cwsnapshot.sh
Log:
we maybe don't program routers here, but this name is
hardcoded by "fwrtbuilder" (the programme which does
the automated builds)


Deleted: trunk/cwsnapshot.sh
===================================================================
--- trunk/cwsnapshot.sh	2007-10-26 17:19:49 UTC (rev 1003)
+++ trunk/cwsnapshot.sh	2007-10-26 17:33:25 UTC (rev 1004)
@@ -1,24 +0,0 @@
-#!/bin/sh
-# $Id$
-
-v=$(svn info | sed -n '/Revision: /s///p')
-echo '/VER_SVN =/s/\$.*\$/$LastChangedRevision: '$v' $/\nwq' | \
-    ed -s src/CacheWolf/Version.java
-javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
-/usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
-rm -rf published
-mkdir -p published/attributes
-mv programs/CacheWolf/* published/
-chmod 755 published/*
-chmod 644 published/*/*
-install -c -m 644 work/CacheWolf.ewe published/
-install -c -m 644 resources/*.{def,html,tpl,zip} published/
-install -c -m 644 resources/attributes-big/*.gif published/attributes/
-(cd published && \
-    find *.{def,html,tpl,zip} attributes/*.gif -type f | sort | \
-    /usr/local/bin/cpio -oC512 -Hustar -Mdist | gzip -n9 >datfiles.tgz && \
-    rm -rf *.{def,html,tpl,zip} attributes && \
-    chmod 644 datfiles.tgz)
-mkdir -p ~/public_html/CacheWolf-BE/r$v
-mv published/* ~/public_html/CacheWolf-BE/r$v/
-rm -rf published

Copied: trunk/fwrtsnapshot.sh (from rev 1003, trunk/cwsnapshot.sh)



From mirabilos at mail.berlios.de  Fri Oct 26 19:35:07 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 26 Oct 2007 19:35:07 +0200
Subject: [Cachewolf-svn] r1005 - trunk
Message-ID: <200710261735.l9QHZ7ae019059@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-26 19:35:07 +0200 (Fri, 26 Oct 2007)
New Revision: 1005

Modified:
   trunk/fwrtsnapshot.sh
Log:
too many people have issues with .tar.gz on Windows, where only
.tar can be extracted using the tools which come with it (by
using \WINNT\SYSTEM32\PAX.EXE with the -r option); furthermore,
the usual GUI tools people install present both the .gz and the
.tar part as separate archives

? switch to .tar only, the extra compression isn?t worth it


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-26 17:33:25 UTC (rev 1004)
+++ trunk/fwrtsnapshot.sh	2007-10-26 17:35:07 UTC (rev 1005)
@@ -16,7 +16,7 @@
 install -c -m 644 resources/attributes-big/*.gif published/attributes/
 (cd published && \
     find *.{def,html,tpl,zip} attributes/*.gif -type f | sort | \
-    /usr/local/bin/cpio -oC512 -Hustar -Mdist | gzip -n9 >datfiles.tgz && \
+    /usr/local/bin/cpio -oC512 -Hustar -Mdist >datfiles.tar && \
     rm -rf *.{def,html,tpl,zip} attributes && \
     chmod 644 datfiles.tgz)
 mkdir -p ~/public_html/CacheWolf-BE/r$v



From mirabilos at mail.berlios.de  Fri Oct 26 19:48:50 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 26 Oct 2007 19:48:50 +0200
Subject: [Cachewolf-svn] r1006 - trunk
Message-ID: <200710261748.l9QHmoXX019805@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-26 19:48:50 +0200 (Fri, 26 Oct 2007)
New Revision: 1006

Modified:
   trunk/fwrtsnapshot.sh
Log:
according to http://www.geoclub.de/ftopic19437.html
the ?12M? doesn?t work on Windoze


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-26 17:35:07 UTC (rev 1005)
+++ trunk/fwrtsnapshot.sh	2007-10-26 17:48:50 UTC (rev 1006)
@@ -2,7 +2,7 @@
 # $Id$
 
 v=$(svn info | sed -n '/Revision: /s///p')
-echo '/VER_SVN =/s/\$.*\$/$LastChangedRevision: '$v' $/\nwq' | \
+printf '/VER_SVN =/s/\$.*\$/$LastChangedRevision: %s $/\nwq\n' $v | \
     ed -s src/CacheWolf/Version.java
 javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
 /usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
@@ -11,6 +11,7 @@
 mv programs/CacheWolf/* published/
 chmod 755 published/*
 chmod 644 published/*/*
+printf '1,$g/ 12M/s///\nwq\n' | ed -s published/Jar/CacheWolf.bat
 install -c -m 644 work/CacheWolf.ewe published/
 install -c -m 644 resources/*.{def,html,tpl,zip} published/
 install -c -m 644 resources/attributes-big/*.gif published/attributes/



From mirabilos at mail.berlios.de  Fri Oct 26 20:14:58 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Fri, 26 Oct 2007 20:14:58 +0200
Subject: [Cachewolf-svn] r1007 - trunk
Message-ID: <200710261814.l9QIEwd9021109@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-26 20:14:58 +0200 (Fri, 26 Oct 2007)
New Revision: 1007

Modified:
   trunk/fwrtsnapshot.sh
Log:
trace ? debugging

Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-26 17:48:50 UTC (rev 1006)
+++ trunk/fwrtsnapshot.sh	2007-10-26 18:14:58 UTC (rev 1007)
@@ -1,6 +1,7 @@
 #!/bin/sh
 # $Id$
 
+set -x
 v=$(svn info | sed -n '/Revision: /s///p')
 printf '/VER_SVN =/s/\$.*\$/$LastChangedRevision: %s $/\nwq\n' $v | \
     ed -s src/CacheWolf/Version.java



From mik77 at mail.berlios.de  Fri Oct 26 20:17:28 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 26 Oct 2007 20:17:28 +0200
Subject: [Cachewolf-svn] r1008 - trunk/src/CacheWolf
Message-ID: <200710261817.l9QIHSjB021237@sheep.berlios.de>

Author: mik77
Date: 2007-10-26 20:17:23 +0200 (Fri, 26 Oct 2007)
New Revision: 1008

Modified:
   trunk/src/CacheWolf/Profile.java
Log:
some more bugs with 7 character waypoints

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-10-26 18:14:58 UTC (rev 1007)
+++ trunk/src/CacheWolf/Profile.java	2007-10-26 18:17:23 UTC (rev 1008)
@@ -483,11 +483,11 @@
 			ch = (CacheHolder)cacheDB.get(i);
 			if (ch.isAddiWpt()) {
 				//search main cache
-				index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(ch.wayPoint.length()-4));
+				index = (Integer) dbIndex.get("GC"+ ch.wayPoint.substring(2));
 				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
-					index = (Integer) dbIndex.get("OC"+ ch.wayPoint.substring(ch.wayPoint.length()-4));
+					index = (Integer) dbIndex.get("OC"+ ch.wayPoint.substring(2));
 				if (index == null)  // TODO save the source (GC or OC or Custom) of the maincache somewhere else to avoid ambiguity of addi-wpt-names
-					index = (Integer) dbIndex.get("CW"+ ch.wayPoint.substring(ch.wayPoint.length()-4));
+					index = (Integer) dbIndex.get("CW"+ ch.wayPoint.substring(2));
 				
 				if (index != null) {
 					mainCh = (CacheHolder) cacheDB.get(index.intValue());



From salzkammergut at mail.berlios.de  Fri Oct 26 21:05:41 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 26 Oct 2007 21:05:41 +0200
Subject: [Cachewolf-svn] r1009 - trunk/lib/ewesoft/xml/sax
Message-ID: <200710261905.l9QJ5fxC024986@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-26 21:05:40 +0200 (Fri, 26 Oct 2007)
New Revision: 1009

Modified:
   trunk/lib/ewesoft/xml/sax/SAXException.java
Log:
SAXException: Fix for compile bug

Modified: trunk/lib/ewesoft/xml/sax/SAXException.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/SAXException.java	2007-10-26 18:17:23 UTC (rev 1008)
+++ trunk/lib/ewesoft/xml/sax/SAXException.java	2007-10-26 19:05:40 UTC (rev 1009)
@@ -35,8 +35,8 @@
     * @see ewesoft.xml.sax.Parser#setLocale
     */
   public SAXException (String message) {
-    super();
-    this.message = message;
+    super(message);
+    //this.message = message;
     this.exception = null;
   }
 
@@ -52,8 +52,8 @@
     */
   public SAXException (Exception e)
   {
-    super();
-    this.message = null;
+    super(e.getMessage());
+    //this.message = null;
     this.exception = e;
   }
 
@@ -70,8 +70,8 @@
     */
   public SAXException (String message, Exception e)
   {
-    super();
-    this.message = message;
+    super(message);
+    //this.message = message;
     this.exception = e;
   }
 
@@ -86,7 +86,7 @@
     * @return The error or warning message.
     * @see ewesoft.xml.sax.Parser#setLocale
     */
-  public String getMessage ()
+  /*public String getMessage ()
   {
     if (message == null && exception != null) {
       return exception.getMessage();
@@ -94,8 +94,8 @@
       return this.message;
     }
   }
+*/
 
-
   /**
     * Return the embedded exception, if any.
     *



From mik77 at mail.berlios.de  Fri Oct 26 22:22:13 2007
From: mik77 at mail.berlios.de (mik77 at mail.berlios.de)
Date: Fri, 26 Oct 2007 22:22:13 +0200
Subject: [Cachewolf-svn] r1010 - trunk/src/CacheWolf
Message-ID: <200710262022.l9QKMDQL028988@sheep.berlios.de>

Author: mik77
Date: 2007-10-26 22:22:10 +0200 (Fri, 26 Oct 2007)
New Revision: 1010

Modified:
   trunk/src/CacheWolf/DescriptionPanel.java
Log:
line for better separation of AW description and description of main cache

Modified: trunk/src/CacheWolf/DescriptionPanel.java
===================================================================
--- trunk/src/CacheWolf/DescriptionPanel.java	2007-10-26 19:05:40 UTC (rev 1009)
+++ trunk/src/CacheWolf/DescriptionPanel.java	2007-10-26 20:22:10 UTC (rev 1010)
@@ -38,7 +38,7 @@
 		else {
 			if (cache.isAddiWpt()) {
 				if (cache.LongDescription != null && cache.LongDescription.length() > 0)
-					 desc = cache.LongDescription + "<br>\n"+cache.mainCache.getCacheDetails(true).LongDescription;
+					 desc = cache.LongDescription + "<hr>\n"+cache.mainCache.getCacheDetails(true).LongDescription;
 				else desc = cache.mainCache.getCacheDetails(true).LongDescription;
 
 			} else // not an addi-wpt



From salzkammergut at mail.berlios.de  Fri Oct 26 22:23:33 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 26 Oct 2007 22:23:33 +0200
Subject: [Cachewolf-svn] r1011 - trunk/src/CacheWolf
Message-ID: <200710262023.l9QKNXID029043@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-26 22:23:28 +0200 (Fri, 26 Oct 2007)
New Revision: 1011

Modified:
   trunk/src/CacheWolf/CWPoint.java
Log:
CWPoint: Small fix for Rev 985. Added leading 0 for east coordinates.

Modified: trunk/src/CacheWolf/CWPoint.java
===================================================================
--- trunk/src/CacheWolf/CWPoint.java	2007-10-26 20:22:10 UTC (rev 1010)
+++ trunk/src/CacheWolf/CWPoint.java	2007-10-26 20:23:28 UTC (rev 1011)
@@ -330,7 +330,7 @@
 		case DD: 	return MyLocale.formatDouble(this.lonDec, "000.00000").replace(',','.');
 		case CW:
 		case DMM:
-		case DMS:	return getDMS(lonDec,0,format);
+		case DMS:	return (lonDec<100.0?"0":"")+getDMS(lonDec,0,format);
 		default: 	return ""; 
 		}
 	}



From salzkammergut at mail.berlios.de  Fri Oct 26 22:36:50 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Fri, 26 Oct 2007 22:36:50 +0200
Subject: [Cachewolf-svn] r1012 - trunk/src/CacheWolf
Message-ID: <200710262036.l9QKaobI029799@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-26 22:36:44 +0200 (Fri, 26 Oct 2007)
New Revision: 1012

Modified:
   trunk/src/CacheWolf/Log.java
Log:
Log: Fix to ensure that logs with a trailing space do not trigger a  log_update=true

Modified: trunk/src/CacheWolf/Log.java
===================================================================
--- trunk/src/CacheWolf/Log.java	2007-10-26 20:23:28 UTC (rev 1011)
+++ trunk/src/CacheWolf/Log.java	2007-10-26 20:36:44 UTC (rev 1012)
@@ -39,7 +39,7 @@
 		this.icon=icon;
 		this.date=date;
 		this.logger=logger;
-		this.message=message;
+		this.message=message.trim();
 	}
 	
 	public static Log maxLog() {
@@ -68,7 +68,7 @@
 		return message;
 	}
 	public void setMessage(String message) {
-		this.message = message;
+		this.message = message.trim();
 	}
 
 	/** Return XML representation of log for storing in cache.xml */



From mirabilos at mail.berlios.de  Sat Oct 27 03:10:18 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 27 Oct 2007 03:10:18 +0200
Subject: [Cachewolf-svn] r1013 - trunk/lib/ewesoft/xml/sax
Message-ID: <200710270110.l9R1AIGS004718@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-27 03:10:17 +0200 (Sat, 27 Oct 2007)
New Revision: 1013

Modified:
   trunk/lib/ewesoft/xml/sax/SAXException.class
Log:
put in the compiled result too

@salzkammergut: I get the below messages, is this correct?
$ javac SAXException.java
----------
1. WARNING in SAXException.java (at line 28)
        public class SAXException extends Exception {
                     ^^^^^^^^^^^^
The serializable class SAXException does not declare a static final serialVersionUID field of type long
----------
2. WARNING in SAXException.java (at line 125)
        private String message;
                       ^^^^^^^
The field SAXException.message is never read locally
----------
2 problems (2 warnings)


Modified: trunk/lib/ewesoft/xml/sax/SAXException.class
===================================================================
(Binary files differ)



From mirabilos at mail.berlios.de  Sat Oct 27 03:26:51 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 27 Oct 2007 03:26:51 +0200
Subject: [Cachewolf-svn] r1014 - in trunk: . res_noewe resources
Message-ID: <200710270126.l9R1QpWg007009@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-27 03:26:48 +0200 (Sat, 27 Oct 2007)
New Revision: 1014

Added:
   trunk/res_noewe/
   trunk/res_noewe/ExpressLogger.tpl
   trunk/res_noewe/GCTemplate.html
   trunk/res_noewe/MSAutoRoute.tpl
   trunk/res_noewe/POIIcons.zip
   trunk/res_noewe/TomTomASC.tpl
   trunk/res_noewe/blue.png
   trunk/res_noewe/bug.gif
   trunk/res_noewe/desti.tpl
   trunk/res_noewe/dnf.gif
   trunk/res_noewe/icon_attended.gif
   trunk/res_noewe/icon_camera.gif
   trunk/res_noewe/icon_disabled.gif
   trunk/res_noewe/icon_enabled.gif
   trunk/res_noewe/icon_greenlight.gif
   trunk/res_noewe/icon_maint.gif
   trunk/res_noewe/icon_needsmaint.gif
   trunk/res_noewe/icon_note.gif
   trunk/res_noewe/icon_rsvp.gif
   trunk/res_noewe/icon_sad.gif
   trunk/res_noewe/icon_smile.gif
   trunk/res_noewe/images.gif
   trunk/res_noewe/index.tpl
   trunk/res_noewe/info.html
   trunk/res_noewe/kml.tpl
   trunk/res_noewe/legende.html
   trunk/res_noewe/mn6route.tpl
   trunk/res_noewe/mnroute.tpl
   trunk/res_noewe/ozi_ns.tpl
   trunk/res_noewe/page.tpl
   trunk/res_noewe/red.png
   trunk/res_noewe/spider.def
   trunk/res_noewe/wolflang.html
   trunk/res_noewe/yellow.png
Removed:
   trunk/resources/ExpressLogger.tpl
   trunk/resources/GCTemplate.html
   trunk/resources/MSAutoRoute.tpl
   trunk/resources/POIIcons.zip
   trunk/resources/TomTomASC.tpl
   trunk/resources/blue.png
   trunk/resources/bug.gif
   trunk/resources/desti.tpl
   trunk/resources/dnf.gif
   trunk/resources/icon_attended.gif
   trunk/resources/icon_camera.gif
   trunk/resources/icon_disabled.gif
   trunk/resources/icon_enabled.gif
   trunk/resources/icon_greenlight.gif
   trunk/resources/icon_maint.gif
   trunk/resources/icon_needsmaint.gif
   trunk/resources/icon_note.gif
   trunk/resources/icon_rsvp.gif
   trunk/resources/icon_sad.gif
   trunk/resources/icon_smile.gif
   trunk/resources/images.gif
   trunk/resources/index.tpl
   trunk/resources/info.html
   trunk/resources/kml.tpl
   trunk/resources/legende.html
   trunk/resources/mn6route.tpl
   trunk/resources/mnroute.tpl
   trunk/resources/ozi_ns.tpl
   trunk/resources/page.tpl
   trunk/resources/red.png
   trunk/resources/spider.def
   trunk/resources/wolflang.html
   trunk/resources/yellow.png
Modified:
   trunk/fwrtsnapshot.sh
   trunk/getRes.bat
   trunk/getRes.sh
Log:
according to MiK, certain files, namely
??? icon_*.gif
??? these referenced by *.html
must not be placed in the .ewe file either.

Move all files (but not (yet) the attributes*/ dirs) that
should not be placed in the .ewe to the new directory
res_noewe/ and adjust the getRes.{bat,sh} and autobuilder
scripts accordingly


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/fwrtsnapshot.sh	2007-10-27 01:26:48 UTC (rev 1014)
@@ -8,19 +8,19 @@
 javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
 /usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
 rm -rf published
-mkdir -p published/attributes
+mkdir -p published/dat/attributes
 mv programs/CacheWolf/* published/
 chmod 755 published/*
 chmod 644 published/*/*
+chmod 755 published/dat/attributes
 printf '1,$g/ 12M/s///\nwq\n' | ed -s published/Jar/CacheWolf.bat
 install -c -m 644 work/CacheWolf.ewe published/
-install -c -m 644 resources/*.{def,html,tpl,zip} published/
-install -c -m 644 resources/attributes-big/*.gif published/attributes/
-(cd published && \
-    find *.{def,html,tpl,zip} attributes/*.gif -type f | sort | \
-    /usr/local/bin/cpio -oC512 -Hustar -Mdist >datfiles.tar && \
-    rm -rf *.{def,html,tpl,zip} attributes && \
-    chmod 644 datfiles.tgz)
+install -c -m 644 res_noewe/* published/dat/
+install -c -m 644 resources/attributes-big/*.gif published/dat/attributes/
+(cd published/dat && find * -type f | sort | \
+    /usr/local/bin/cpio -oC512 -Hustar -Mdist >../datfiles.tar)
+rm -rf published/dat
+chmod 644 published/datfiles.tar
 mkdir -p ~/public_html/CacheWolf-BE/r$v
 mv published/* ~/public_html/CacheWolf-BE/r$v/
 rm -rf published

Modified: trunk/getRes.bat
===================================================================
--- trunk/getRes.bat	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/getRes.bat	2007-10-27 01:26:48 UTC (rev 1014)
@@ -6,6 +6,7 @@
 del .\work\*.ico
 REM get ressources
 copy .\resources\*.* .\work\*.*
+copy .\res_noewe\*.* .\work\*.*
 copy .\resources\attributes\*.* .\work\attributes\*.*
 copy .\lib\*.dll .\work\
 move .\work\cachewolf.Languages.cfg .\work\_config\

Modified: trunk/getRes.sh
===================================================================
--- trunk/getRes.sh	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/getRes.sh	2007-10-27 01:26:48 UTC (rev 1014)
@@ -7,5 +7,6 @@
 rm ./work/*.ico
 # get ressources
 cp resources/*.* work
+cp res_noewe/*.* work
 cp resources/attributes/*.* work/attributes
 mv work/cachewolf.Languages.cfg work/_config/cachewolf.Languages.cfg

Copied: trunk/res_noewe/ExpressLogger.tpl (from rev 1012, trunk/resources/ExpressLogger.tpl)

Copied: trunk/res_noewe/GCTemplate.html (from rev 1012, trunk/resources/GCTemplate.html)

Copied: trunk/res_noewe/MSAutoRoute.tpl (from rev 1012, trunk/resources/MSAutoRoute.tpl)

Copied: trunk/res_noewe/POIIcons.zip (from rev 1012, trunk/resources/POIIcons.zip)

Copied: trunk/res_noewe/TomTomASC.tpl (from rev 1012, trunk/resources/TomTomASC.tpl)

Copied: trunk/res_noewe/blue.png (from rev 1012, trunk/resources/blue.png)

Copied: trunk/res_noewe/bug.gif (from rev 1012, trunk/resources/bug.gif)

Copied: trunk/res_noewe/desti.tpl (from rev 1012, trunk/resources/desti.tpl)

Copied: trunk/res_noewe/dnf.gif (from rev 1012, trunk/resources/dnf.gif)

Copied: trunk/res_noewe/icon_attended.gif (from rev 1012, trunk/resources/icon_attended.gif)

Copied: trunk/res_noewe/icon_camera.gif (from rev 1012, trunk/resources/icon_camera.gif)

Copied: trunk/res_noewe/icon_disabled.gif (from rev 1012, trunk/resources/icon_disabled.gif)

Copied: trunk/res_noewe/icon_enabled.gif (from rev 1012, trunk/resources/icon_enabled.gif)

Copied: trunk/res_noewe/icon_greenlight.gif (from rev 1012, trunk/resources/icon_greenlight.gif)

Copied: trunk/res_noewe/icon_maint.gif (from rev 1012, trunk/resources/icon_maint.gif)

Copied: trunk/res_noewe/icon_needsmaint.gif (from rev 1012, trunk/resources/icon_needsmaint.gif)

Copied: trunk/res_noewe/icon_note.gif (from rev 1012, trunk/resources/icon_note.gif)

Copied: trunk/res_noewe/icon_rsvp.gif (from rev 1012, trunk/resources/icon_rsvp.gif)

Copied: trunk/res_noewe/icon_sad.gif (from rev 1012, trunk/resources/icon_sad.gif)

Copied: trunk/res_noewe/icon_smile.gif (from rev 1012, trunk/resources/icon_smile.gif)

Copied: trunk/res_noewe/images.gif (from rev 1012, trunk/resources/images.gif)

Copied: trunk/res_noewe/index.tpl (from rev 1012, trunk/resources/index.tpl)

Copied: trunk/res_noewe/info.html (from rev 1012, trunk/resources/info.html)

Copied: trunk/res_noewe/kml.tpl (from rev 1012, trunk/resources/kml.tpl)

Copied: trunk/res_noewe/legende.html (from rev 1012, trunk/resources/legende.html)

Copied: trunk/res_noewe/mn6route.tpl (from rev 1012, trunk/resources/mn6route.tpl)

Copied: trunk/res_noewe/mnroute.tpl (from rev 1012, trunk/resources/mnroute.tpl)

Copied: trunk/res_noewe/ozi_ns.tpl (from rev 1012, trunk/resources/ozi_ns.tpl)

Copied: trunk/res_noewe/page.tpl (from rev 1012, trunk/resources/page.tpl)

Copied: trunk/res_noewe/red.png (from rev 1012, trunk/resources/red.png)

Copied: trunk/res_noewe/spider.def (from rev 1012, trunk/resources/spider.def)

Copied: trunk/res_noewe/wolflang.html (from rev 1012, trunk/resources/wolflang.html)

Copied: trunk/res_noewe/yellow.png (from rev 1012, trunk/resources/yellow.png)

Deleted: trunk/resources/ExpressLogger.tpl
===================================================================
--- trunk/resources/ExpressLogger.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/ExpressLogger.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,16 +0,0 @@
-<#-- Express Logger GPX -->
-<#-- Codecs: ASCII, UTF8 -->
-<tmpl_par name="charset" value="UTF8">
-<#-- newline: CR, LF, CRLF -->
-<tmpl_par name="newline" value="CRLF">
-<?xml version="1.0" encoding="utf-8"?><br/>
-<gpx><br/>
-<tmpl_loop cache_index>
-   <wpt><br/>
-       <name><tmpl_var name=WAYPOINT></name><br/>
-       <cmlog:log version="1.0" found="true"><br/>
-           <cmlog:notes><tmpl_var name=NOTES></cmlog:notes><br/>
-       </cmlog:log><br/>
-   </wpt><br/>
-</tmpl_loop>
-</gpx><br/>
\ No newline at end of file

Deleted: trunk/resources/GCTemplate.html
===================================================================
--- trunk/resources/GCTemplate.html	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/GCTemplate.html	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,158 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
-<!-- saved from url=(0014)http://localhost/ -->
-<!-- Note: The line above is needed to avoid the warning due to the javascript contained in this page.
-   Using javascript, various sections of the Cache listing can be hidden/unhidden. 
-   Try clicking on anything that is underlined.
--->
-<html>
-<META HTTP-EQUIV="content-type" content="text/html; charset=utf-8" />
-<META HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08:21:57 GMT">
-<META HTTP-EQUIV="Pragma" CONTENT="no-cache"> 
-<script type="text/javascript">
-function toggleDivOL( elemID ) { // Hide or show a DIV
-	var elem = document.getElementById( elemID );
-	if (!elem.style.display || elem.style.display=='block') {
-		elem.style.display='none';
-	} else {
-		elem.style.display='block';	
-	}
-}
-var logsVisible=true;
-function toggleAll() {
-	logsVisible=!logsVisible;
-	var logs = document.getElementsByName("log");
-	for (logElem=0; logElem<logs.length; logElem++) {
-		if (logsVisible) 
-			logs[logElem].style.display='block';
-		else
-			logs[logElem].style.display='none';
-	}
-}
-</script>
-<style type="text/css">
-body {
-	font-family: Verdana,sans-serif; font-size:80%;
-}
-.notes {
-	padding: 5px;
-	background-color: #EEEEEE;
-	border: 1px solid #000000;
-}
-.solver {
-	padding: 5px;
-	background-color: #EEEEEE;
-	border: 1px dashed #000000;
-}
-.logs {
-	padding: 5px;
-	background-color: #EEEEEE;
-}
-td { font-size:small;  }
- at media screen {.clickHint {font-family: Arial; font-size:xx-small; padding-left:30px; display:inline; } }
- at media print {.clickHint {font-family: Arial; font-size:xx-small; display:none; }
-</style>
-<head>
-	<title>Cache: <tmpl_var WAYPOINT> <tmpl_var CACHE_NAME> by <tmpl_var OWNER></title>
-</head>
-	
-<body bgcolor="#FFFFFF" LINK="#000000" VLINK="#000000" ALINK="#000000" TEXT="#000000" marginwidth="20" marginheight="0" leftmargin="20" topmargin="0">
-<div style="float:left;">
-	<img src=<tmpl_var TYPE> BORDER=0 WIDTH=32 HEIGHT=32><FONT face="Verdana" size="4"><strong> <tmpl_var CACHE_NAME></strong></FONT>
-	<FONT face="Verdana" size="2" style="font-size:X-Small;font-weight:bold;"> by <tmpl_var OWNER></FONT>
-	<br/><br/>
-    <strong><tmpl_var LATLON></strong> (WGS84)<br/>
-	Difficulty: <tmpl_var DIFFICULTY> 	Terrain: <tmpl_var TERRAIN>
-	<FONT face="Verdana" size="-2">&nbsp;&nbsp;&nbsp;(ratings out of 5 stars. 1 is easiest, 5 is hardest)</FONT><br/>
-	Container: <strong><tmpl_var SIZE></strong><br/><br/>
-</div>
-<div style="float:right;margin:0; margin-top:10px"><FONT face="Verdana" size="4"><strong><tmpl_var WAYPOINT></strong></FONT><br/></div>
-
-<div style="float:left">
-	<div style="float:left;">
-	<table cellpadding=0>
-		<tr><td>Waypoint:</td><td> <tmpl_var WAYPOINT></td></tr>
-		<tr><td>Hidden:</td><td> <tmpl_var DATE></td></tr>
-		<tr><td>Distance:</td><td> <tmpl_var DISTANCE></td></tr>
-		<tr><td>Bearing:</td><td> <tmpl_var BEARING></td></tr>
-		<tr><td>Status:</td><td> <tmpl_var STATUS></td></tr>
-	</table>
-	</div>
-	<div style="float:right;">
-		<tmpl_loop ATTRIBUTES><tmpl_var IMAGE><tmpl_var BR><!--<tmpl_var INFO>-->
-		</tmpl_loop>
-	</div>
-</div>
-<div style="float:left">
-	<hr>
-<tmpl_if UNAVAILABLE>	
-	<FONT face="Verdana" color="red" size="+0">
-	<br/><strong>The cache is not currently available.<br/></strong>
-	</FONT>
-</tmpl_if>	
-
-	<br/>
-	<FONT face="Verdana" size="2">
-	<P><BLOCKQUOTE><span id="LongDescription"><tmpl_var DESCRIPTION></span></BLOCKQUOTE>
-	</FONT>
-<tmpl_if ADDIS><a href="javascript:toggleDivOL('addis');"><STRONG>Additional Waypoints</STRONG></a><BR/><br/>
-	<div id="addis"><TABLE cellSpacing=1 cellPadding=4 bgColor=#448e35 border=0>
-		<TBODY>
-			<TR bgColor=#c6e3c0>
-				<TH align=middle width=16>&nbsp;</TH>
-				<TH align=left>Waypoint</TH>
-				<TH align=left>Name</TH>
-				<TH align=left>Coordinate</TH>
-			<tmpl_loop ADDIS>	
-			<TR bgColor=#ffffff>
-				<TD vAlign=top align=middle width=16><tmpl_var IMG></TD>
-				<TD vAlign=top align=left><tmpl_var WAYPOINT></TD>
-				<TD vAlign=top align=left><tmpl_var NAME></TD>
-				<TD vAlign=top align=left><tmpl_var LATLON></TD></TR>
-			<TR bgColor=#ffffff>
-				<TD vAlign=top align=middle width=16>Note:</TD>
-				<TD vAlign=top align=left ColSpan=3><tmpl_var LONGDESC></TD>
-			</tmpl_loop>	
-		</TBODY>
-	</TABLE><BR/></div>	
-</tmpl_if>
-<tmpl_if IMAGES> 
-	<tmpl_loop IMAGES>
-		<a href="javascript:toggleDivOL(<tmpl_var I>);"><image src="images.gif" border=0> <tmpl_var IMAGETEXT></a><br/>
-		<div id=<tmpl_var I> style="display:none"><tmpl_var IMAGE></div>
-	</tmpl_loop>
-</tmpl_if>
-
-<tmpl_if HINT>
-	<br/><br/><STRONG>Additional Hints (Highlight blank area to see)</STRONG><br/>
-	<FONT face="Verdana" color="white" size="1"><tmpl_var HINT></FONT><br/><br/>
-</tmpl_if>
-
-<tmpl_if LOGS>
-	<br/><a href="javascript:toggleDivOL('logs');"><FONT face="Verdana" size="+0"><STRONG>Logs</STRONG></FONT></a><font class="clickHint" onClick="toggleAll();">Click 'Logs' to hide/unhide section; Click this to hide/unhide each log; Click any log to hide/unhide</font><br/><br/>
-	<div id="logs" class="logs">
-	<tmpl_loop LOGS>
-		<a href="javascript:toggleDivOL(<tmpl_var I>);"><tmpl_var LOGTYPE></a>
-		<div id=<tmpl_var I> name="log" style="display:block"><font face='Verdana' size='2'><tmpl_var LOG></font><br/>
-		<div><center><div style="width:66%"><hr></div></center></div></div>
-	</tmpl_loop>
-	</div>
-<tmpl_else><br/><STRONG>No logs</STRONG><br/>	
-</tmpl_if>
-<tmpl_if BUGS>
-	<hr>
-	<a href="javascript:toggleDivOL('bugs');"><FONT face="Verdana" size="+0"><STRONG>Bugs</STRONG></FONT></a><span class="clickHint">Click to hide/unhide section</span><br/><br/>
-	<div id="bugs" class="bugs"><tmpl_var BUGS></div>	
-</tmpl_if>
-<tmpl_if NOTES>
-<tmpl_if BUGS><TMPL_ELSE><hr></tmpl_if>
-    <a href="javascript:toggleDivOL('notes');"><FONT face="Verdana" size="+0"><STRONG>Personal Notes</STRONG></FONT></a><span class="clickHint">Click to hide/unhide section</span><br/><br/>
-	<div id="notes" class="notes"><br/><tmpl_var NOTES></div>
-</tmpl_if>
-<tmpl_if SOLVER>
-    <a href="javascript:toggleDivOL('solver');"><FONT face="Verdana" size="+0"><STRONG>Solver Instructions</STRONG></FONT></a><span class="clickHint">Click to hide/unhide section</span><br/><br/>
-	<div id="solver" class="solver"><br/><tmpl_var SOLVER></div>
-</tmpl_if>
-</div>
-</body>
-</html>
-

Deleted: trunk/resources/MSAutoRoute.tpl
===================================================================
--- trunk/resources/MSAutoRoute.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/MSAutoRoute.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,13 +0,0 @@
-<#-- Microsoft AutoRoute -->
-<#-- Codecs: ASCII, UTF8 -->
-<tmpl_par name="charset" value="ASCII">
-<#-- somme chars should not appear in the cachename -->
-<tmpl_par name="badchars" value=";"">
-<#-- newline: CR, LF, CRLF -->
-<tmpl_par name="newline" value="CRLF">
-<#-- decimal seperator: . or , -->
-<tmpl_par name="decsep" value=",">
-Name;Breitengrad;L?ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink<br />
-<tmpl_loop cache_index>
-"<tmpl_var name=SHORTTYPE>-<tmpl_var name=SHORTSIZE>-<tmpl_var name=DIFFICULTY>-<tmpl_var name=TERRAIN> <tmpl_var name=NAME>";<tmpl_var name=LAT>;<tmpl_var name=LON>;"<tmpl_var name=TYPE>";"<tmpl_var name=SIZE>";"<tmpl_var name=WAYPOINT>";"<tmpl_var name=DATE>";"<tmpl_var name=URL>"<br />
-</tmpl_loop>

Deleted: trunk/resources/POIIcons.zip
===================================================================
(Binary files differ)

Deleted: trunk/resources/TomTomASC.tpl
===================================================================
--- trunk/resources/TomTomASC.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/TomTomASC.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,10 +0,0 @@
-<#-- TomTom ASC or POI -->
-<#-- Codecs: ASCII, UTF8 -->
-<tmpl_par name="charset" value="ASCII">
-<#-- somme chars should not appear in the cachename -->
-<tmpl_par name="badchars" value=",">
-<#-- newline: CR, LF, CRLF -->
-<tmpl_par name="newline" value="CRLF">
-<tmpl_loop cache_index>
-<tmpl_var name=LON>,<tmpl_var name=LAT>,"<tmpl_var name=SHORTTYPE>-<tmpl_var name=SHORTSIZE>-<tmpl_var name=DIFFICULTY>-<tmpl_var name=TERRAIN>-<tmpl_var name=NAME>"<br />
-</tmpl_loop>

Deleted: trunk/resources/blue.png
===================================================================
(Binary files differ)

Deleted: trunk/resources/bug.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/desti.tpl
===================================================================
--- trunk/resources/desti.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/desti.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,10 +0,0 @@
-<#-- Detinator -->
-<#-- Codecs: ASCII, UTF8 -->
-<tmpl_par name="charset" value="ASCII">
-<#-- somme chars should not appear in the cachename -->
-<tmpl_par name="badchars" value=",">
-<#-- newline: CR, LF, CRLF -->
-<tmpl_par name="newline" value="CRLF">
-<tmpl_loop cache_index>
-<tmpl_var name=WAYPOINT>-<tmpl_var name=NAME>,<tmpl_var name=SHORTTYPE>-<tmpl_var name=SHORTSIZE>-<tmpl_var name=DIFFICULTY>-<tmpl_var name=TERRAIN>,<tmpl_var name=LON>,<tmpl_var name=LAT>,,,,<br />
-</tmpl_loop>

Deleted: trunk/resources/dnf.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_attended.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_camera.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_disabled.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_enabled.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_greenlight.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_maint.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_needsmaint.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_note.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_rsvp.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_sad.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/icon_smile.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/images.gif
===================================================================
(Binary files differ)

Deleted: trunk/resources/index.tpl
===================================================================
--- trunk/resources/index.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/index.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,49 +0,0 @@
-<html>
-<head>
-<title></title>
-<meta name="generator" content="CacheWolf">
-<meta http-equiv="content-type" content="text/html; charset=utf-8">
-</head>
-<body>
- <tmpl_if navi_index>
-	 <tmpl_loop navi_index>
-	 	<a name=top></a>
-	  	<a href="#<tmpl_var HREF>"><tmpl_var TEXT></a>
-	 </tmpl_loop>
-</tmpl_if>
-<table border = "2px" align = "center">
- <tr style = "background-color:lightgrey;font-variant:small-caps; font-family:sans-serif;font-size:16;">
-    <td><a href = "index_type.html">Art</a></td>
-    <td><a href = "index_size.html">Size</a></td>
-    <td><a href = "index_wp.html">Wegpunkt</td>
-    <td><a href = "index_alpha.html">Name</a></td>
-    <td>Besitzer</td>
-    <td>Schwierigkeit</td>
-    <td>Gel&auml;nde</td>
-    <td><a href = "index_dist.html">Entfernung</a></td>
-    <td>Richtung</td>
-    <td>Koordinaten</td>
- </tr>
- <tmpl_loop cache_index>
- <tmpl_if ANCHORNAME>
-  <tr style = "font-family:sans-serif;font-size:12;">
- 		<td colspan="2" style = "background-color:lightgrey;font-variant:small-caps; font-family:sans-serif;font-size:16;"><a name = "<tmpl_var ANCHORNAME>"><tmpl_var ANCHORTEXT></a></td>
- 		<td><a href="#top">Back</a></td>
-  </tr>
- </tmpl_if>
- <tr style = "font-family:sans-serif;font-size:12;">
-    <td><tmpl_var TYPE></td>
-    <td><tmpl_var SIZE></td>
-    <td><a href = "<tmpl_var WAYPOINT>.html"><tmpl_var WAYPOINT></a></td>
-    <td><tmpl_var NAME></td>
-    <td><tmpl_var OWNER></td>
-    <td><tmpl_var DIFFICULTY></td>
-    <td><tmpl_var TERRAIN></td>
-    <td><tmpl_var DISTANCE></td>
-    <td><tmpl_var BEARING></td>
-    <td><tmpl_var LATLON></td>
- </tr>
- </tmpl_loop>
-</table>
-</body>
-</html>
\ No newline at end of file

Deleted: trunk/resources/info.html
===================================================================
--- trunk/resources/info.html	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/info.html	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,19 +0,0 @@
-<font face="Tahoma">
-<h1>CacheWolf</h1></font>
-<font face="Tahoma" size = "3">
-<strong>A geocaching programm</strong><br>
-<font face="Tahoma" size = "2"><em>
-from Bilbowolf, Kalli, Pfeffer, salzkammergut, MiK, Blackeye501, mirabilos<br>
-for Windows, Linux and Pocket PC</em><br>
-<br>
-CacheWolf was created sometime 2003 to enable paperless caching with a Sharp Zaurus.
-As it was written in Java it was natural that after a while requests originated
-asking if it was possible to run the Wolf on Pocket PCs. But the existing Java
-Virtual Machines just did not deliver the required performance.<br>
-CacheWolf was then reprogrammed using EWE, a Java like virtual machine.<BR><BR>
-If you want to help us developing CacheWolf you are welcome!<BR><BR>
-
-CacheWolf Homepage: www.cachewolf.de<br>
-Discussions may be joined at: www.geoclub.de<br><br>
-<STRONG>Cache On 'n Cache hard!</STRONG>
-</font>

Deleted: trunk/resources/kml.tpl
===================================================================
--- trunk/resources/kml.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/kml.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,19 +0,0 @@
-<tmpl_par name="newline" value="CRLF">
-<?xml version="1.0" encoding="UTF-8"?>
-<kml xmlns="http://earth.google.com/kml/2.1">
-
-<Document>
-  <name>Geocaching</name>
-  <description><![CDATA[Geocaching mit CacheWolf]]></description>
-<tmpl_loop cache_index>
- <Placemark><br/>
-   <description><tmpl_var name=NAME></description><br/>
-   <name><tmpl_var name=NAME></name><br/>
-   <Point><br/>
-     <coordinates><tmpl_var name=LON>,<tmpl_var name=LAT>,0</coordinates><br/>
-   </Point><br/>
- </Placemark><br/>
-</tmpl_loop>
-</Document>
-</kml>
-

Deleted: trunk/resources/legende.html
===================================================================
--- trunk/resources/legende.html	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/legende.html	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,22 +0,0 @@
-<font face="Tahoma" size="2">
-<b>Farben und Punkte</b>
-<br><br>
-
-<b><i>Listenansicht (farbige Zeilen)</i></b>
-<table>
-<tr><td><font color="#FF0000"=>Cache ist nicht suchbar</font></td></tr>
-<tr><td><font color="#93170C"=>Cache wurde archiviert</font></td></tr>
-<tr><td><font color="#1D4AEE"=>Eigene Caches</font></td></tr>
-<tr><td><font color="#0BB206"=>Gefundene Caches</font></td></tr>
-</table>
-<br>
-
-<b><i>Punkte vor Wegpunktnamen</i></b><br>
-<img src='yellow.png'>Cache ist "neu" durch GPX-Import<br>
-<img src='red.png'>Update in Cachebeschreibung<br>
-<img src='blue.png'>Neue Logeintraege<br>
-<br>
-
-<b><i>Sonstige Symbole</i></b><br>
-<img src='bug.gif'>TravelBug<br>
-<img src='dnf.gif'>DNF-Indikator (je mehr Farben zu sehen, desto mehr DNF's)

Deleted: trunk/resources/mn6route.tpl
===================================================================
--- trunk/resources/mn6route.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/mn6route.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,9 +0,0 @@
-<#-- Mobile Navigator 6 Route -->
-<tmpl_par name="charset" value="ASCII">
-<#-- somme chars should not appear in the cachename -->
-<tmpl_par name="badchars" value="|">
-<#-- newline: CR, LF, CRLF -->
-<tmpl_par name="newline" value="CRLF">
-<tmpl_loop cache_index>
-[<tmpl_var name=NAME>|][0][10]|<tmpl_var name=LON>,<tmpl_var name=LAT>||<tmpl_var name=LON>|<tmpl_var name=LAT>[7]||[6]|||<tmpl_var name=LON>|<tmpl_var name=LAT>[3]||[2]|||[0]|||<br/>
-</tmpl_loop>
\ No newline at end of file

Deleted: trunk/resources/mnroute.tpl
===================================================================
--- trunk/resources/mnroute.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/mnroute.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,8 +0,0 @@
-<#-- Mobile Navigator Route -->
-<#-- newline: CR, LF, CRLF -->
-<tmpl_par name="newline" value="CRLF">
-<#-- somme chars should not appear in the cachename -->
-<tmpl_par name="badchars" value="|">
-<tmpl_loop cache_index>
-<tmpl_var name=NAME>|-|-|-|-|-|-|-|-|-|<tmpl_var name=LON>|<tmpl_var name=LAT>|-|<br/>
-</tmpl_loop>
\ No newline at end of file

Deleted: trunk/resources/ozi_ns.tpl
===================================================================
--- trunk/resources/ozi_ns.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/ozi_ns.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,13 +0,0 @@
-<#-- OziExplorer Namesearch -->
-<#-- Codecs: ASCII, UTF8 -->
-<tmpl_par name="charset" value="ASCII">
-<#-- somme chars should not appear in the cachename -->
-<tmpl_par name="badchars" value=",">
-<#-- newline: CR, LF, CRLF -->
-<tmpl_par name="newline" value="CRLF">
-;nst FORMAT :  FULL NAME,CODE,UTM ZONE,LAT,LONG,IGNORE ANYTHING ELSE<br />
-#1,,<br />
-#2,WGS 84<br />
-<tmpl_loop cache_index>
-"<tmpl_var name=SHORTTYPE>-<tmpl_var name=SHORTSIZE>-<tmpl_var name=DIFFICULTY>-<tmpl_var name=TERRAIN>-<tmpl_var name=NAME>",<tmpl_var name=TYPE>,,<tmpl_var name=LAT>,<tmpl_var name=LON>,<br />
-</tmpl_loop>

Deleted: trunk/resources/page.tpl
===================================================================
--- trunk/resources/page.tpl	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/page.tpl	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,55 +0,0 @@
-<html>
-<head>
-<title></title>
-<meta name="generator" content="CacheWolf">
-<meta http-equiv="content-type" content="text/html; charset=utf-8">
-</head>
-<body>
-<table border = "2px" align = "center">
-<tr style = "background-color:lightgrey;font-family:sans-serif;font-size:14;"><td>
-<tmpl_var TYPE> <tmpl_var WAYPOINT> <tmpl_var NAME> by <tmpl_var OWNER><br>
-Difficulty: <tmpl_var DIFFICULTY>&nbsp;&nbsp;Terrain: <tmpl_var TERRAIN>&nbsp;&nbsp;Size: <tmpl_var SIZE>
-</td></tr>
-<tr style = "font-family:sans-serif;font-size:12;"><td>
-Description:<br>
-<tmpl_var DESCRIPTION>
-</td></tr>
-<tr style = "font-family:sans-serif;font-size:12;"><td>
-Hints:<br>
-<tmpl_var HINTS>
-</td></tr>
-<tr style = "font-family:sans-serif;font-size:12;"><td>
-Decrypted Hints:<br>
-<tmpl_var DECRYPTEDHINTS>
-</td></tr>
-<tr style = "font-family:sans-serif;font-size:12;"><td>
-Logs:<br>
-<tmpl_var LOGS>
-</td></tr>
-<tr style = "font-family:sans-serif;font-size:12;"><td>
-Notes:<br>
-<tmpl_var NOTES>
-</td></tr>
-<tr style = "font-family:sans-serif;font-size:12;"><td>
-Pictures:<br>
-Cache:<br>
-<tmpl_loop cacheImg>
-<a href = "<tmpl_var FILE>"><tmpl_var TEXT></a><br>
-</tmpl_loop>
-User:<br>
-<tmpl_loop userImg>
-<a href = "<tmpl_var FILE>"><tmpl_var TEXT></a><br>
-</tmpl_loop>
-Logs:<br>
-<tmpl_loop logImg>
-<a href = "<tmpl_var FILE>"><tmpl_var TEXT></a><br>
-</tmpl_loop>
-Maps:<br>
-<tmpl_loop mapImg>
-<a href = "<tmpl_var FILE>"><tmpl_var TEXT></a><br>
-</tmpl_loop>
-</td></tr>
-<tr style = "font-family:sans-serif;font-size:12;"><td>
-</table>
-</body>
-</html>
\ No newline at end of file

Deleted: trunk/resources/red.png
===================================================================
(Binary files differ)

Deleted: trunk/resources/spider.def
===================================================================
--- trunk/resources/spider.def	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/spider.def	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,143 +0,0 @@
-#============================================================
-# spider.def - Definition file for reading caches from GC.COM
-# Version 1.0 - 20070526 skg
-# Version 2.0 - 20070531 nach GC ?nderungen
-# Version 2.1 - 20070601 TB Anpassung an GC ?nderung
-# Version 2.2 - 20070602 firstLine erg?nzt. Damit funktionieren jetzt auch die n?chsten Seiten.
-# Version 2.3 - 20070602 sizeRex an GC ?nderungen angepasst
-# Version 2.4 - 20070616 neu: Attribute
-# Version 2.5 - 20070629 Anpassungen an Listen?nderung bei GC
-# Version 2.6 - 20070701 Bugfix: Wenn Zentrum exakt in Cachekoordinaten liegt wurde der Cache nicht gespidert
-# Version 2.7 - 20070811 Bugfix fuer verschluesselte Logs
-# Version 2.8 - 20070814 Findet jetzt auch Addi Wpts in eigenen Caches
-# Version 2.9 - 20070817 Bessere Unterscheidung zwischen Werbung vs.normalen Caches + Caches ohne Richtung/Entfenung
-# Version 2.10 - 20070825 Travelbug support
-# Version 2.11 - 20070907 get travelbug mission by tracking number
-# Version 3.0 - 20071010 adaption to new GC-design
-# Version 3.1 - 20071013 Use the given prefix for addi waypoints
-# Version 3.2 - 20071024 longer end sequence for longDescRex
-#============================================================
-# A suffix of Rex indicates a regular expression
-# A suffix of ExStart indicates the start of an Extractor search pattern
-# A suffix of ExEnd indicates the end of an Extractor search pattern
-#
-# Important:
-# * When entering spaces into a string ensure to escape them or write them as \\u0020
-# * Be sure that you have no hidden spaces at the end of a line or the patterns will not match!
-#------------------------------------------------------------
-loginPage          = http://www.geocaching.com/login/Default.aspx
-loginSuccess       = You\ are\ logged\ in\ as
-nextPage           = /login/default.aspx
-waypoint           = http://www.geocaching.com/seek/cache_details.aspx?wp=
-#--------------------------------------
-#Section1: First page with list of caches
-#--------------------------------------
-firstPage          = http://www.geocaching.com/seek/nearest.aspx?lat=
-firstPage2         = &lon=
-# Regex to search for cachenames 
-listBlockRex       = <table id="dlResults"((?s).*?)</table>
-lineRex            = <tr\ bgcolor='#.{6}'>(?:(?s).*?)<td\ valign="top"\ align="left">((?s).*?)</tr>
-distRex            = <br\ />(.*?)(km|mi)</td>
-waypointRex        = \\(GC(.*?)\\)<br\ />
-showOnlyFound      = &f=1
-firstLine          = http://www.geocaching.com/seek/nearest.aspx?
-nextListPage       = /seek/nearest.aspx
-
-#--------------------------------------
-#Section2: Get cachepage by name
-#--------------------------------------
-getPageByName      = http://www.geocaching.com/seek/cache_details.aspx?wp=
-fetchAllLogs       = &log=y
-cacheUnavailable   = This\ cache\ is\ temporarily\ unavailable
-cacheArchived      = This cache\ has\ been\ archived
-latLonRex          = <span\ id="LatLon"\ style="font-weight:bold;">((?s).*?)</span>
-shortDescRex       = <span\ id="ShortDescription">((?s).*?)</span>
-longDescRex        = <span\ id="LongDescription">((?s).*?)<strong>Additional\ Hints&nbsp;\\(</strong>
-cacheNameRex       = <span\ id="CacheName">((?s).*?)</span>
-cacheOwnerRex      = <span\ id="CacheOwner">by\ <a\ href=(?:(?s).*?)>((?s).*?)</a></span>
-dateHiddenRex      = <span\ id="DateHidden">((?s).*?)</span>
-hintsRex           = <span\ id="Hints"\ class="displayMe">((?s).*?)</span>
-sizeRex            = alt="Size:\ ((?s).*?)"\ title="Size:
-difficultyRex      = <span\ id="Difficulty">.*?alt="(.*?)\ out\ of
-terrainRex         = <span\ id="Terrain">.*?alt="(.*?)\ out\ of
-cacheTypeRex       = <img\ src="../images/WptTypes/(.*?)\\.gif
-
-#--------------------------------------
-#Section2a: Logs
-#--------------------------------------
-# blockRex extrahiert zun?chst aus der gesamten Seite den Logbereich
-blockRex           = <span\ id="CacheLogs">((?s).*?)</span>
-# singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
-singleLogExStart   = <STRONG>
-singleLogExEnd     = [<A\ href=
-# iconEx, nameTempEx, dateEx, singleLogEx werden auf einen singleLog angewendet
-iconExStart        = http://www.geocaching.com/images/icons/
-iconExEnd          = '\ align='abs
-nameTempExStart    = <A\ HREF="
-nameTempExEnd      = /A>
-# Name extrahiert aus nameTemp
-nameExStart        = >
-nameExEnd          = <
-dateExStart        = align='absmiddle'>&nbsp;
-dateExEnd          = \ by\ <
-logExStart         = found)<br>
-logExEnd           = <br>[
-# Die Icons, die einen erfolgreichen Fund signalisieren
-icon_smile         = icon_smile.gif
-icon_camera        = icon_camera.gif
-
-#--------------------------------------
-#Section2b: Bugs
-#--------------------------------------
-# blockEx extrahiert zun?chst den Bugbereich aus der gesamten Seite
-blockExStart       = >&nbsp;<b>Inventory</b>
-blockExEnd         = What\ is\ a\ Travel\ Bug?
-# bugEx extrahiert die Namen der einzelnen Bugs aus dem Bugbereich
-bugExStart         = <a\ href='
-bugExEnd           = </a></strong></td>
-bugDetailsStart    = id="BugDetail_BugGoal">
-bugDetailsEnd      = </span>
-getBugByName       = http://www.geocaching.com/track/search.aspx?k=
-getBugByGuid       = http://www.geocaching.com/track/details.aspx?guid=
-getBugById         = http://www.geocaching.com/track/details.aspx?id=
-getBugByTrackNr    = http://www.geocaching.com/track/details.aspx?tracker=
-bugGuidExStart     = www.geocaching.com/track/details.aspx?id=
-bugGuidExEnd       = "
-bugNotFound        = No\ results\ were\ found\ for\ your\ search
-bugTotalRecords    = Total\ Records:\ <b>1</b>
-
-#--------------------------------------
-#Section2c: Images
-#--------------------------------------
-# imgBlockEx searches for images in the long description
-imgBlockExStart    = <IMG
-imgBlockExEnd      = >
-# imgSpanEx searches for images in the image section
-imgSpanExStart     = <span\ id="Images"
-imgSpanExEnd       = </span>
-imgNameExStart     = align=absmiddle\ border=0>
-imgNameExEnd       = </a><br/>
-imgSrcExStart      = <A\ HREF='http://
-imgSrcExEnd        = '\ rel='lightbox'
-
-#--------------------------------------
-#Section2d: Additional waypoints
-#--------------------------------------
-wayBlockExStart    = <strong>Additional\ Waypoints</strong>
-wayBlockExEnd      = </table>
-nameRex            = &RefDS=1">(.*)</a>
-koordRex           = align="left">([NSns]\ [0-9]{1,2}..[0-9]{1,2}.[0-9]{1,3}\ [EWew]\ [0-9]{1,3}..[0-9]{1,2}.[0-9]{1,3})</td>
-descRex            = colspan="4">(.*)</td>
-typeRex            = </a>\ \\((.*)\\)</td>
-rowBlockExStart    = <tr
-rowBlockExEnd      = </tr>
-prefixExStart      = <td\ valign=\"top\"\ align=\"left\">
-prefixExEnd        = </td>
-
-#--------------------------------------
-#Section2e: Attributes
-#--------------------------------------
-attBlockExStart = &nbsp;<b>Attributes</b><br/><table
-attBlockExEnd  = </td></tr></table>
-attExStart = src="../images/attributes/
-attExEnd = " Alt="

Deleted: trunk/resources/wolflang.html
===================================================================
--- trunk/resources/wolflang.html	2007-10-27 01:10:17 UTC (rev 1013)
+++ trunk/resources/wolflang.html	2007-10-27 01:26:48 UTC (rev 1014)
@@ -1,67 +0,0 @@
-<font face="Tahoma" size = "2"><b>WolfLanguage Commands:</b><br>
-Chars after # until end of line are ignored<br>
-Multiple commands per line separated by ;<br>
-<i>Example: stop</i>   # ends execution<br>
-<i>Example: cls()</i>   # clears output screen<br>
-<br>
-<b><u>Basic Operations</u></b><br>
- Assignment:<br>
- var = value<br>
-<i> Example: a = 2</i><br>
-<i> Example: $a = 2; b="abc"</i><br>
-$a is global variable.<br>
-Format numerical expression:<br>
-Example: 3.14159:000.00:<br>
-<i>Format chars:</i> 0 . # where # stands for any number of decimal chars<br> 
-<br>
-<u><b> Showing values</b></u><br>
- "some text" " more text":<br>
-<i> Example: "N 34 12." a " :the " rot13("gnetrg")</i>
- +, -, *, /, (, ):<br>
-<i> Example: a = 1 / 2 + 34 - 8 * 12<br>
- or a = (1 / b + 34 - b) * 12</i><br>
-<br>
-<b><u>Root, Power</u></b><br>
- sqrt(), ^:<br>
-<i> Example: a = sqrt(2) ^ 5</i><br>
-<br>
-<b><u>Trigonometric functions</u></b><br>
- cos(), sin(), tan(),<br>
- atan(), asin(), acos():<br>
-<i> Example: a = cos(1);<br>
- or a = atan(b);</i><br>
-<br>
-<b><u>Numeric functions</u></b><br>
-ct(number) # crosstotal<br>
-q(number) # Quersumme/crosstotal<br><br>
-<b><u>Text functions</u></b>[s is a string]<br>
-length(s)<br>
-mid(s,startpos,length)<br> 
-instr(s,searchStr)<br>
-instr(startpos,s,searchstr)<br>
-ucase(s)<br>
-lcase(s)<br>
-replace(s,searchStr,ReplaceStr)<br>
-reverse(s)<br>
-encode(s,s1,s2)<br>
-count(s,whatStr)<br>
-val(s)<i> # A=1, B=2, ... Z=26;  Add all</i><br>
-sval(s)<i> # A=1, B=2, ... Z=26</i><br>
-rot13(s)<br><br>
-<b><u>Coordinate</u></b><br>
-bearing(coordinate1,coordinate2)<br>
-center() # get current center<br>
-center(coordinate)<br>
-cp() # get current GPS position<br>
-distance(coordinate1,coordinate2)<br>  
-format(coordinate,fmt) <br>
-  <i>where fmt="CW" or "UTM" or "DMS" or "DD"</i><br>
-goto(coordinate)<br>
-goto(coordinate,waypointname)<br>
-project(coordinate,angle,distance)<br><br>
-<b><u>Generate program for Multis (with/without addi Wpts)</u></b><br>
-skeleton() # current cache   also<br>
-skeleton(numberOfStages)<br><br>
-<b><u>IF THEN ENDIF</u></b><br>
-IF condition THEN statement; statement .... ENDIF<br><br>
-</font>

Deleted: trunk/resources/yellow.png
===================================================================
(Binary files differ)



From salzkammergut at mail.berlios.de  Sat Oct 27 09:29:01 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Oct 2007 09:29:01 +0200
Subject: [Cachewolf-svn] r1015 - trunk/lib/ewesoft/xml/sax
Message-ID: <200710270729.l9R7T1ct005426@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-27 09:29:00 +0200 (Sat, 27 Oct 2007)
New Revision: 1015

Modified:
   trunk/lib/ewesoft/xml/sax/SAXException.java
Log:
SAXException: Commented out the message field to avoid compiler warning


Modified: trunk/lib/ewesoft/xml/sax/SAXException.java
===================================================================
--- trunk/lib/ewesoft/xml/sax/SAXException.java	2007-10-27 01:26:48 UTC (rev 1014)
+++ trunk/lib/ewesoft/xml/sax/SAXException.java	2007-10-27 07:29:00 UTC (rev 1015)
@@ -122,7 +122,7 @@
   // Internal state.
   //////////////////////////////////////////////////////////////////////
 
-  private String message;
+  //private String message;
   private Exception exception;
 
 }



From salzkammergut at mail.berlios.de  Sat Oct 27 14:09:54 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Oct 2007 14:09:54 +0200
Subject: [Cachewolf-svn] r1016 - trunk/src/CacheWolf
Message-ID: <200710271209.l9RC9sjR003303@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-27 14:09:51 +0200 (Sat, 27 Oct 2007)
New Revision: 1016

Modified:
   trunk/src/CacheWolf/SpiderGC.java
Log:
SpiderGC: Fix for Rev 990. When a new waypoint was created (e.g. GCD825) and then refreshed from GC using the context menu, no cache description and logs were displayed, even though they were stored in GCD825.xml. When the profile was reloaded, the cache description and log were visible.

Modified: trunk/src/CacheWolf/SpiderGC.java
===================================================================
--- trunk/src/CacheWolf/SpiderGC.java	2007-10-27 07:29:00 UTC (rev 1015)
+++ trunk/src/CacheWolf/SpiderGC.java	2007-10-27 12:09:51 UTC (rev 1016)
@@ -202,15 +202,15 @@
 			if (this.login()!=Form.IDOK) return false;
 			// loggedIn is already set by this.login()
 		}
-		CacheHolderDetail chD=new CacheHolderDetail(ch);
+		CacheHolderDetail chD=ch.getCacheDetails(true); //new CacheHolderDetail(ch);
 		try{
-			// Get all existing details of the cache
+/*			// Get all existing details of the cache
 			try {
 				chD.readCache(profile.dataDir);
 			} catch (IOException ioex) {
 				pref.log("No .XML file found for cache "+chD.wayPoint);
 			};
-			// Read the cache data from GC.COM and compare to old data
+*/			// Read the cache data from GC.COM and compare to old data
 			ret=getCacheByWaypointName(chD,true,true,false,true);
 			// Save the spidered data
 			if (ret) {



From salzkammergut at mail.berlios.de  Sat Oct 27 17:42:35 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Oct 2007 17:42:35 +0200
Subject: [Cachewolf-svn] r1017 - trunk/src/CacheWolf
Message-ID: <200710271542.l9RFgZTi015465@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-27 17:42:29 +0200 (Sat, 27 Oct 2007)
New Revision: 1017

Modified:
   trunk/src/CacheWolf/MainTab.java
   trunk/src/CacheWolf/TablePanel.java
Log:
mainTab: Fix for Rev 990. Fixed problems when table was empty and new waypoint was created from goto panel.

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-10-27 12:09:51 UTC (rev 1016)
+++ trunk/src/CacheWolf/MainTab.java	2007-10-27 15:42:29 UTC (rev 1017)
@@ -114,7 +114,7 @@
 	 * Code to execute when leaving a panel (oldCard is the panel number)
 	 *
 	 */
-	private void onLeavingPanel(int panelNo) {
+	private void onLeavingPanel(int panelNo) {//Vm.debug("Leaving "+panelNo);
 		if (panelNo==0) { // Leaving the list view
 			// Get the cache for the current line (ch)
 			// Get the details for the current line (chD)
@@ -141,9 +141,11 @@
 			if(detP.isDirty()) {
 				cacheDirty=true;
 				detP.saveDirtyWaypoint();
-				tbP.myMod.updateRows();
+				tbP.myMod.updateRows();// This sorts the waypoint (if it is new) into the right position
 				tbP.selectRow(profile.getCacheIndex(detP.thisCache.wayPoint));
-				tbP.refreshTable();
+				//was tbP.refreshTable();
+				tbP.tc.update(true); // Update and repaint
+				if (statBar!=null) statBar.updateDisplay();
 			}
 		}
 		if (panelNo==5) { // Leaving the Solver Panel
@@ -166,7 +168,7 @@
 	 * Code to execute when entering a panel (getSelectedItem() is the panel number)
 	 *
 	 */
-	private void onEnteringPanel(int panelNo) {
+	private void onEnteringPanel(int panelNo) {//Vm.debug("Entering "+panelNo);
 		switch (panelNo) {// Switch by panel number
 		case 0:
 			// If Solver or Details has changed, save Cache
@@ -179,7 +181,7 @@
 			break;
 		case 1:  // DetailsPanel
 			if (chD==null) { // Empty DB - show a dummy detail
-				newWaypoint(chD=new CacheHolderDetail()); 
+				newWaypoint(ch=new CacheHolder()); 
 			}
 			MyLocale.setSIPButton();
 			detP.setDetails(ch);
@@ -204,11 +206,11 @@
 			MyLocale.setSIPButton();
 			if (chD!=null) {
 				if (chD.isAddiWpt()) { 
-					chMain=new CacheHolderDetail(chD.mainCache);
-					try {
+					chMain=chD.mainCache.getCacheDetails(true);//new CacheHolderDetail(chD.mainCache);
+/*					try {
 						chMain.readCache(profile.dataDir); //Vm.debug("mainT:readCache "+chD.wayPoint+"=>Main=>"+chMain.wayPoint+"/S:"+chMain.Solver);
 					} catch(Exception e){pref.log("Error reading cache .xml",e);}
-					solverP.setInstructions(chMain.Solver);
+*/					solverP.setInstructions(chMain.Solver);
 				} else {
 					//Vm.debug("mainT: Waypoint:"+chD.wayPoint);
 					solverP.setInstructions(chD.Solver);
@@ -271,6 +273,7 @@
 	 * @param ch
 	 */
 	public void newWaypoint(CacheHolder ch){
+		//When creating a new waypoint, simulate a change to the list view
 		onLeavingPanel(oldCard);
 		updatePendingChanges(); // was: onEnteringPanel(0); oldCard=0;
 		mainCache=lastselected;
@@ -281,25 +284,32 @@
 				mainCache = selectedCache.mainCache.wayPoint;
 			}			
 		}
-		//if (detP.isDirty()) detP.saveDirtyWaypoint();
 		Global.getProfile().hasUnsavedChanges=true;
 		detP.setIsNew(true);
-		if (ch.type == null || ch.type == "") ch.type = "0";
-		if (CacheType.isAddiWpt(ch.type)) {
+		if (ch.type == null || ch.type.equals("")) ch.type = "0";
+		if (CacheType.isAddiWpt(ch.type) && mainCache!=null && mainCache.length()>2) {
 			ch.wayPoint = profile.getNewAddiWayPointName(mainCache);
 			profile.setAddiRef(ch);
-		} else ch.wayPoint = profile.getNewWayPointName();
+		} else { 
+			ch.wayPoint = profile.getNewWayPointName();
+			ch.type="0";
+			lastselected=ch.wayPoint;
+		}
 		ch.CacheSize = "None";
 		chD = ch.getCacheDetails(true);
 		this.ch = ch;
 		cacheDB.add(ch);
+		tbP.myMod.numRows++;
+		detP.setDetails(ch);
+		oldCard=1;
 		//tbP.myMod.updateRows();
-		//tbP.selectRow(profile.getCacheIndex(waypoint));
-		//Global.mainTab.tbP.refreshTable();
+		tbP.selectRow(cacheDB.find(ch));
+		//tbP.refreshTable();
 		if (this.cardPanel.selectedItem==1) { // Detailpanel already selected
-			postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,1));
-		} else	
+			//postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,1));
+		} else {	
 			select(detP);
+		}
 		solverP.setInstructions(""); // TODO save them first, don't delete them when the new one is an addi
 		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
@@ -351,7 +361,6 @@
 	void updatePendingChanges() {
 		if (cacheDirty) {
 			chD.saveCacheDetails(Global.getProfile().dataDir);
-			//Vm.debug("mainT: Saveing "+chD.wayPoint);
 		}
 	}
 	

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-10-27 12:09:51 UTC (rev 1016)
+++ trunk/src/CacheWolf/TablePanel.java	2007-10-27 15:42:29 UTC (rev 1017)
@@ -45,7 +45,7 @@
 	public void selectRow(int row) {
 		// Ensure that the highlighted row is visible (e.g. when coming from radar panel)
 		// Next line needed for key scrolling 
-		tc.cursorTo(row, tc.cursor.x+tc.listMode, true); 
+		tc.cursorTo(row, 0, true); //tc.cursor.x+tc.listMode
 	}
 	
 	/** Highlight the first row in grey. It can be unhighlighted by clicking */



From salzkammergut at mail.berlios.de  Sat Oct 27 18:33:53 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Oct 2007 18:33:53 +0200
Subject: [Cachewolf-svn] r1018 - trunk/src/CacheWolf
Message-ID: <200710271633.l9RGXrvK031390@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-27 18:33:50 +0200 (Sat, 27 Oct 2007)
New Revision: 1018

Modified:
   trunk/src/CacheWolf/DataMover.java
   trunk/src/CacheWolf/myTableControl.java
Log:
Fix for getCacheDetails: When deleting/moving/copying caches the cacheDetails need to be deleted too so that CacheHolderDetail can be released.

Modified: trunk/src/CacheWolf/DataMover.java
===================================================================
--- trunk/src/CacheWolf/DataMover.java	2007-10-27 15:42:29 UTC (rev 1017)
+++ trunk/src/CacheWolf/DataMover.java	2007-10-27 16:33:50 UTC (rev 1018)
@@ -195,6 +195,7 @@
 			 this.title=title;
 		 }
 		 public void doIt(int i,CacheHolder srcHolder) {
+			srcHolder.releaseCacheDetails();
 			deleteCacheFiles(srcHolder.wayPoint,profile.dataDir);
 			srcDB.removeElementAt(i);
 		 }
@@ -206,6 +207,7 @@
 			 this.dstProfile=dstProfile;
 		 }
 		 public void doIt(int i,CacheHolder srcHolder) {
+			srcHolder.releaseCacheDetails();
 			// does cache exists in destDB ?
 			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
 			if (dstPos >= 0){
@@ -230,6 +232,7 @@
 		 }
 		 public void doIt(int i,CacheHolder srcHolder) {
 			// does cache exists in destDB ?
+			srcHolder.releaseCacheDetails();
 			int dstPos = dstProfile.getCacheIndex(srcHolder.wayPoint);
 			if (dstPos >= 0){
 				deleteCacheFiles(srcHolder.wayPoint, dstProfile.dataDir);

Modified: trunk/src/CacheWolf/myTableControl.java
===================================================================
--- trunk/src/CacheWolf/myTableControl.java	2007-10-27 15:42:29 UTC (rev 1017)
+++ trunk/src/CacheWolf/myTableControl.java	2007-10-27 16:33:50 UTC (rev 1018)
@@ -146,6 +146,8 @@
 						h.changed();
 						dm.deleteCacheFiles(ch.wayPoint,profile.dataDir);
 						cacheDB.remove(ch);
+						ch.releaseCacheDetails();
+						ch=null;
 						if (pbf.isClosed) break;
 					}
 				}



From mirabilos at mail.berlios.de  Sat Oct 27 19:37:44 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sat, 27 Oct 2007 19:37:44 +0200
Subject: [Cachewolf-svn] r1019 - trunk/lib/ewesoft/xml/sax
Message-ID: <200710271737.l9RHbiLn012501@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-27 19:37:44 +0200 (Sat, 27 Oct 2007)
New Revision: 1019

Modified:
   trunk/lib/ewesoft/xml/sax/SAXException.class
Log:
commit the compiled version of this class too?
@all: if you make changes in lib/ please commit the compiled variants.

1. WARNING in SAXException.java (at line 28)
        public class SAXException extends Exception {
                     ^^^^^^^^^^^^
The serializable class SAXException does not declare a static final serialVersionUID field of type long


Modified: trunk/lib/ewesoft/xml/sax/SAXException.class
===================================================================
(Binary files differ)



From pfeffer at mail.berlios.de  Sat Oct 27 20:58:42 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Sat, 27 Oct 2007 20:58:42 +0200
Subject: [Cachewolf-svn] r1020 - trunk/src/CacheWolf
Message-ID: <200710271858.l9RIwg8t018688@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-27 20:58:40 +0200 (Sat, 27 Oct 2007)
New Revision: 1020

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
   trunk/src/CacheWolf/MainTab.java
Log:
DetailsPanel: new waypoint: removed a redundant medthod call, little clean up

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-10-27 17:37:44 UTC (rev 1019)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-10-27 18:58:40 UTC (rev 1020)
@@ -465,23 +465,9 @@
 		  thisCache.type = transSelect(chcType.getInt());
 		 // thisCache.saveCacheDetails(profile.dataDir); // this is redundant, because all changes affecting the details are immediately saved
 		  // Now update the table
-		  CacheHolder ch = thisCache; //(CacheHolder)cacheDB.get(dbIndex);
+		  CacheHolder ch = thisCache; // TODO variable ch is redundant
 		  
-	/*	  ch.CacheStatus=thisCache.CacheStatus;
-		  ch.is_found=thisCache.is_found;
-		  ch.is_owned=thisCache.is_owned;
-		  ch.is_black=thisCache.is_black;
-		  ch.wayPoint=thisCache.wayPoint;
-		  ch.CacheSize=thisCache.CacheSize;
-		  ch.wayPoint=thisCache.wayPoint;
-		  ch.CacheName=thisCache.CacheName;
-		  ch.LatLon=thisCache.LatLon;
-		  ch.DateHidden=thisCache.DateHidden;
-		  ch.CacheOwner=thisCache.CacheOwner;
-		  ch.has_bug=thisCache.has_bug;
-		  ch.type=thisCache.type;
-*/		  // If the type has changed from/to an addi waypoint, rebuild the references
-		  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType)) {
+	  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType)) {
 			  // If we changed the type to addi, check that a parent exists
 			  if (CacheType.isAddiWpt(ch.type)) {
 				  int idx;

Modified: trunk/src/CacheWolf/MainTab.java
===================================================================
--- trunk/src/CacheWolf/MainTab.java	2007-10-27 17:37:44 UTC (rev 1019)
+++ trunk/src/CacheWolf/MainTab.java	2007-10-27 18:58:40 UTC (rev 1020)
@@ -302,15 +302,8 @@
 		tbP.myMod.numRows++;
 		detP.setDetails(ch);
 		oldCard=1;
-		//tbP.myMod.updateRows();
-		tbP.selectRow(cacheDB.find(ch));
-		//tbP.refreshTable();
-		if (this.cardPanel.selectedItem==1) { // Detailpanel already selected
-			//postEvent(new MultiPanelEvent(MultiPanelEvent.SELECTED,detP,1));
-		} else {	
-			select(detP);
-		}
-		solverP.setInstructions(""); // TODO save them first, don't delete them when the new one is an addi
+		if (this.cardPanel.selectedItem !=1) select(detP);
+		solverP.setInstructions("");
 		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
 	}



From salzkammergut at mail.berlios.de  Sat Oct 27 23:59:50 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sat, 27 Oct 2007 23:59:50 +0200
Subject: [Cachewolf-svn] r1021 - trunk/src/CacheWolf
Message-ID: <200710272159.l9RLxoQ5031779@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-27 23:59:48 +0200 (Sat, 27 Oct 2007)
New Revision: 1021

Modified:
   trunk/src/CacheWolf/OCXMLImporter.java
Log:
OCXMLImporter: Fix for bug introduced in Rev 980. Need to save cache after every log (this is sub-optimal and should be improved).

Modified: trunk/src/CacheWolf/OCXMLImporter.java
===================================================================
--- trunk/src/CacheWolf/OCXMLImporter.java	2007-10-27 18:58:40 UTC (rev 1020)
+++ trunk/src/CacheWolf/OCXMLImporter.java	2007-10-27 21:59:48 UTC (rev 1021)
@@ -588,7 +588,8 @@
 	private void endCacheLog(String name){
 		if (name.equals("cachelog")){ // </cachelog>
 			chD.CacheLogs.merge(new Log(logIcon,logDate,logFinder,logData));
-			//chD.saveCacheDetails(profile.dataDir);
+			//TODO Optimize this. Currently the cache needs to be saved after every log as we don't know whether the next log is for the same cache.
+			chD.saveCacheDetails(profile.dataDir);
 			return;
 		}
 



From salzkammergut at mail.berlios.de  Sun Oct 28 00:24:41 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Oct 2007 00:24:41 +0200
Subject: [Cachewolf-svn] r1022 - trunk/src/CacheWolf
Message-ID: <200710272224.l9RMOfbq001110@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-28 00:24:36 +0200 (Sun, 28 Oct 2007)
New Revision: 1022

Modified:
   trunk/src/CacheWolf/TablePanel.java
Log:
TablePanel: When the selected Cache is hidden from view (e.g. by applying a filter), the last row of the table is selected. 

Modified: trunk/src/CacheWolf/TablePanel.java
===================================================================
--- trunk/src/CacheWolf/TablePanel.java	2007-10-27 21:59:48 UTC (rev 1021)
+++ trunk/src/CacheWolf/TablePanel.java	2007-10-27 22:24:36 UTC (rev 1022)
@@ -61,6 +61,10 @@
 	 * @return index of selected cache (-1 if not visible)
 	 */
 	public int getSelectedCache(){
+		// If the selected Cache is no longer visible (e.g. after applying a filter)
+		// select the last row
+		if (tc.cursor.y>=myMod.numRows)
+			return myMod.numRows-1;
 		return tc.cursor.y;
 	}
 	



From salzkammergut at mail.berlios.de  Sun Oct 28 08:08:32 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Oct 2007 08:08:32 +0100
Subject: [Cachewolf-svn] r1023 - trunk/src/CacheWolf
Message-ID: <200710280708.l9S78WJu030176@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-28 08:08:30 +0100 (Sun, 28 Oct 2007)
New Revision: 1023

Modified:
   trunk/src/CacheWolf/DetailsPanel.java
Log:
DetailsPanel: Fix for change of waypointname of addi. References are now rebuilt when the name or type of an addi changes.

Modified: trunk/src/CacheWolf/DetailsPanel.java
===================================================================
--- trunk/src/CacheWolf/DetailsPanel.java	2007-10-27 22:24:36 UTC (rev 1022)
+++ trunk/src/CacheWolf/DetailsPanel.java	2007-10-28 07:08:30 UTC (rev 1023)
@@ -449,6 +449,7 @@
 					        (!pref.myAlias2.equals("") && pref.myAlias2.equals(thisCache.CacheOwner));
 		  }
 		  thisCache.is_black = blackStatus;
+		  String oldWaypoint=thisCache.wayPoint;
 		  thisCache.wayPoint = inpWaypoint.getText().trim();
 		  thisCache.CacheSize = chcSize.getText();
 		  // If the waypoint does not have a name, give it one
@@ -467,7 +468,14 @@
 		  // Now update the table
 		  CacheHolder ch = thisCache; // TODO variable ch is redundant
 		  
-	  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType)) {
+	  /* The references have to be rebuilt if:
+	   *   - the cachetype changed from addi->normal or normal->addi
+	   *   - the old cachetype or the new cachetype were 'addi' and 
+	   *     the waypointname has changed 
+	   */
+	  if (CacheType.isAddiWpt(ch.type)!=CacheType.isAddiWpt(oldType) ||
+		 ((CacheType.isAddiWpt(ch.type) || CacheType.isAddiWpt(oldType)) &&
+		 !thisCache.wayPoint.equals(oldWaypoint))) {
 			  // If we changed the type to addi, check that a parent exists
 			  if (CacheType.isAddiWpt(ch.type)) {
 				  int idx;



From salzkammergut at mail.berlios.de  Sun Oct 28 10:00:52 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Oct 2007 10:00:52 +0100
Subject: [Cachewolf-svn] r1024 - trunk/src/CacheWolf
Message-ID: <200710280900.l9S90qqB002534@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-28 10:00:45 +0100 (Sun, 28 Oct 2007)
New Revision: 1024

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Preferences.java
Log:
Added setting for CacheHolder.maxDetails to preferences (but not to preferences screen). Added number of stored details to system info.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-10-28 07:08:30 UTC (rev 1023)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-10-28 09:00:45 UTC (rev 1024)
@@ -268,7 +268,7 @@
 		   details.update(this);
 		   return details;
 	   }
-	   if (cachesWithLoadedDetails.size() >= maxDetails) removeOldestDetails();
+	   if (cachesWithLoadedDetails.size() >= Global.getPref().maxDetails) removeOldestDetails();
 	   details = new CacheHolderDetail(this);
 	   try {
 		   details.readCache(Global.getProfile().dataDir);
@@ -288,15 +288,12 @@
 	   cachesWithLoadedDetails.remove(this);
    }
    
-   final static int maxDetails = 50; 
-   static Vector cachesWithLoadedDetails = new Vector(maxDetails);
+   //final static int maxDetails = 50; 
+   static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
    
    public static void removeOldestDetails() { // TODO save changes if requested?
-	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
-	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
-	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
-	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
-	   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+	   for (int i=0; i<Global.getPref().deleteDetails; i++)
+		   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
    }
    
 /*

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-10-28 07:08:30 UTC (rev 1023)
+++ trunk/src/CacheWolf/MainMenu.java	2007-10-28 09:00:45 UTC (rev 1024)
@@ -556,21 +556,25 @@
 			}
 			if(mev.selectedItem == sysinfo){
 				//Vm.debug("Checking system...");
-				String sysstring;
+				StringBuffer sb=new StringBuffer(400);
 				Rect s = (Rect)Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new Rect(),0);
 				Font f = mApp.guiFont;
-				sysstring =  "Profile: " + profile.dataDir + "<br>" +
-							 "Platform: " + Vm.getPlatform() + "<br>" +
-							 "Locale lang is: " + MyLocale.getLocaleLanguage() + "<br>" +
-							 "Locale country is: " + MyLocale.getLocaleCountry() + "<br>"+
-							 "Decimal separator is: \"" + pref.digSeparator + "\"<br>" +
-							 "Device is PDA: " + Vm.isMobile()+ "<br>" +
-							 "Screen: " + MyLocale.getScreenWidth() + " x " + MyLocale.getScreenHeight() + "<br>"+
-							 "Font size: " + f.getSize() + "<br>" +
-							 "Entries in DB: " +cacheDB.size() + "<br>"+
-							 "File separator is: \"" + Vm.getProperty("file.separator","def")+ "\"<br>"+
-							 "Programme directory is " + File.getProgramDirectory()+"<br>";
-				InfoScreen is = new InfoScreen(sysstring, "System", false,pref);
+				sb.append("Profile: "); 				sb.append(profile.dataDir);
+				sb.append("<br>Platform: "); 			sb.append(Vm.getPlatform());
+				sb.append("<br>Locale lang is: ");		sb.append(MyLocale.getLocaleLanguage()); 
+				sb.append("<br>Locale country is: "); 	sb.append(MyLocale.getLocaleCountry()); 
+				sb.append("<br>Decimal separator is: \""); sb.append(pref.digSeparator);
+				sb.append("\"<br>Device is PDA: ");		sb.append(Vm.isMobile());
+				sb.append("<br>Screen: ");				sb.append(MyLocale.getScreenWidth()); 
+					sb.append(" x ");	 sb.append(MyLocale.getScreenHeight()); 
+				sb.append("<br>Font size: ");			sb.append(f.getSize());
+				sb.append("<br>Entries in DB: ");		sb.append(cacheDB.size());
+				sb.append("<br>File separator is: \""); sb.append(Vm.getProperty("file.separator","def")); 
+				sb.append("\"<br>Programme directory is "); sb.append(File.getProgramDirectory());
+				sb.append("<br>Number of details in RAM is "); sb.append(CacheHolder.cachesWithLoadedDetails.size());
+				sb.append(" Max.: ");					sb.append(Global.getPref().maxDetails);
+				sb.append("<br>");
+				InfoScreen is = new InfoScreen(sb.toString(), "System", false,pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
 			if(mev.selectedItem == chkVersion){

Modified: trunk/src/CacheWolf/Preferences.java
===================================================================
--- trunk/src/CacheWolf/Preferences.java	2007-10-28 07:08:30 UTC (rev 1023)
+++ trunk/src/CacheWolf/Preferences.java	2007-10-28 09:00:45 UTC (rev 1024)
@@ -92,6 +92,7 @@
 	public boolean tabsAtTop=true;
 	/** True if the status bar is to be displayed (hidden if false) */
 	public boolean showStatus=true;
+	//public boolean noTabs=false;
 	/** True if the application can be closed by clicking on the close button in the top line.
 	 * This can be set to avoid accidental closing of the application */
 	public boolean hasCloseButton=true;
@@ -133,7 +134,11 @@
 	public boolean northCenteredGoto = true;
 	/** If not null, a customs map path has been specified by the user */
 	private String customMapsPath=null; 
-
+	/** Number of CacheHolder details that are kept in memory */
+	public int maxDetails=50;
+	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
+	public int deleteDetails=5;
+	
 	//////////////////////////////////////////////
 	/** The debug switch (Can be used to activate dormant code) by adding
 	 * the line: <pre><debug value="true"></pre>
@@ -282,6 +287,12 @@
 		if (name.equals("spider")) {
 			forceLogin = Boolean.valueOf(atts.getValue("forcelogin")).booleanValue();
 		}
+		if (name.equals("details")) {
+			maxDetails=Common.parseInt(atts.getValue("cacheSize"));
+			deleteDetails=Common.parseInt(atts.getValue("delete"));
+			if (maxDetails<2) maxDetails=2;
+			if (deleteDetails<1) deleteDetails=1;
+		}
 	}
 
 	public void characters( char ch[], int start, int length ) {
@@ -336,6 +347,7 @@
 			outp.print("	<location lat = \""+curCentrePt.getLatDeg(CWPoint.DD)+"\" long = \""+curCentrePt.getLonDeg(CWPoint.DD)+"\"/>\n");
 			outp.print("    <spider forcelogin=\""+forceLogin+"\"/>\n");
 			outp.print("    <gotopanel northcentered=\""+northCenteredGoto+"\" />\n");
+			outp.print("    <details cacheSize=\""+maxDetails+"\" delete=\""+deleteDetails+"\"/>\n");
 			if (customMapsPath!=null) outp.print("	<mapspath dir = \""+ customMapsPath +"\"/>\n");
 			if (debug) outp.print("    <debug value=\"true\" />\n"); // Keep the debug switch if it is set
 			// save last path of different exporters



From salzkammergut at mail.berlios.de  Sun Oct 28 10:29:04 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Sun, 28 Oct 2007 10:29:04 +0100
Subject: [Cachewolf-svn] r1025 - trunk/src/CacheWolf
Message-ID: <200710280929.l9S9T47V004072@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-28 10:29:01 +0100 (Sun, 28 Oct 2007)
New Revision: 1025

Modified:
   trunk/src/CacheWolf/CacheHolder.java
   trunk/src/CacheWolf/MainMenu.java
   trunk/src/CacheWolf/Profile.java
Log:
Fix for Rev 990: When opening a new profile, all stored details must be freed.

Modified: trunk/src/CacheWolf/CacheHolder.java
===================================================================
--- trunk/src/CacheWolf/CacheHolder.java	2007-10-28 09:00:45 UTC (rev 1024)
+++ trunk/src/CacheWolf/CacheHolder.java	2007-10-28 09:29:01 UTC (rev 1025)
@@ -295,7 +295,11 @@
 	   for (int i=0; i<Global.getPref().deleteDetails; i++)
 		   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
    }
-   
+ 
+   public static void removeAllDetails() {
+	   for (int i=cachesWithLoadedDetails.size()-1; i>=0; i--)
+		   ((CacheHolder)(cachesWithLoadedDetails.get(0))).releaseCacheDetails();
+   }
 /*
 public void finalize() {nObjects--;
    Vm.debug("Destroying CacheHolder "+wayPoint);

Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-10-28 09:00:45 UTC (rev 1024)
+++ trunk/src/CacheWolf/MainMenu.java	2007-10-28 09:29:01 UTC (rev 1025)
@@ -237,6 +237,7 @@
 					Global.mainTab.saveUnsavedChanges(true);
 					if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
 						tbp.myMod.numRows=0;
+						CacheHolder.removeAllDetails();
 						profile.cacheDB.clear();
 						InfoBox infB = new InfoBox("CacheWolf",MyLocale.getMsg(5000,"Loading Cache-List"));
 						infB.exec();

Modified: trunk/src/CacheWolf/Profile.java
===================================================================
--- trunk/src/CacheWolf/Profile.java	2007-10-28 09:00:45 UTC (rev 1024)
+++ trunk/src/CacheWolf/Profile.java	2007-10-28 09:29:01 UTC (rev 1025)
@@ -79,6 +79,7 @@
 	}
 
 	public void clearProfile() {
+		CacheHolder.removeAllDetails();
 		cacheDB.clear();
 		centre.set(-361,-361);
 		name="";



From mirabilos at mail.berlios.de  Sun Oct 28 13:33:40 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sun, 28 Oct 2007 13:33:40 +0100
Subject: [Cachewolf-svn] r1026 - trunk
Message-ID: <200710281233.l9SCXeAj032625@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-28 13:33:39 +0100 (Sun, 28 Oct 2007)
New Revision: 1026

Modified:
   trunk/fwrtsnapshot.sh
Log:
the fwrt snapshot builder uses ecj to compile, which apparently has to be
passed a special option to specify the source files? encoding if it is not
UTF-8; also, it can be passed a parameter to ensure the generated .class
files are Java? 1.1 compatible, which seems to be needed for Ewe (or was
it Java? 1.2? can?t find it in the Ewe docs right now).


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-28 09:29:01 UTC (rev 1025)
+++ trunk/fwrtsnapshot.sh	2007-10-28 12:33:39 UTC (rev 1026)
@@ -5,7 +5,7 @@
 v=$(svn info | sed -n '/Revision: /s///p')
 printf '/VER_SVN =/s/\$.*\$/$LastChangedRevision: %s $/\nwq\n' $v | \
     ed -s src/CacheWolf/Version.java
-javac -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
+javac -target 1.1 -encoding windows-1252 -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
 /usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
 rm -rf published
 mkdir -p published/dat/attributes



From mirabilos at mail.berlios.de  Sun Oct 28 14:59:21 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Sun, 28 Oct 2007 14:59:21 +0100
Subject: [Cachewolf-svn] r1027 - trunk
Message-ID: <200710281359.l9SDxL6G004924@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-28 14:59:20 +0100 (Sun, 28 Oct 2007)
New Revision: 1027

Modified:
   trunk/fwrtsnapshot.sh
Log:
remove bin/ after building, so that the changes from e.g. switching the
encoding will be reflected in a new build, we don?t need to build CW
incrementally (I hope/think/guess)

noticed by Dr. Pfeffer, reproduced by me


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-28 12:33:39 UTC (rev 1026)
+++ trunk/fwrtsnapshot.sh	2007-10-28 13:59:20 UTC (rev 1027)
@@ -23,4 +23,4 @@
 chmod 644 published/datfiles.tar
 mkdir -p ~/public_html/CacheWolf-BE/r$v
 mv published/* ~/public_html/CacheWolf-BE/r$v/
-rm -rf published
+rm -rf bin published



From mirabilos at mail.berlios.de  Mon Oct 29 11:42:05 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Mon, 29 Oct 2007 11:42:05 +0100
Subject: [Cachewolf-svn] r1028 - trunk/src/CacheWolf
Message-ID: <200710291042.l9TAg5Y9008208@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-29 11:42:05 +0100 (Mon, 29 Oct 2007)
New Revision: 1028

Modified:
   trunk/src/CacheWolf/MainMenu.java
Log:
display CW version number in About?System, for these whose windowing
environment does not feature any title bars


Modified: trunk/src/CacheWolf/MainMenu.java
===================================================================
--- trunk/src/CacheWolf/MainMenu.java	2007-10-28 13:59:20 UTC (rev 1027)
+++ trunk/src/CacheWolf/MainMenu.java	2007-10-29 10:42:05 UTC (rev 1028)
@@ -560,6 +560,7 @@
 				StringBuffer sb=new StringBuffer(400);
 				Rect s = (Rect)Window.getGuiInfo(Window.INFO_SCREEN_RECT,null,new Rect(),0);
 				Font f = mApp.guiFont;
+				Version vers = new Version();
 				sb.append("Profile: "); 				sb.append(profile.dataDir);
 				sb.append("<br>Platform: "); 			sb.append(Vm.getPlatform());
 				sb.append("<br>Locale lang is: ");		sb.append(MyLocale.getLocaleLanguage()); 
@@ -574,6 +575,7 @@
 				sb.append("\"<br>Programme directory is "); sb.append(File.getProgramDirectory());
 				sb.append("<br>Number of details in RAM is "); sb.append(CacheHolder.cachesWithLoadedDetails.size());
 				sb.append(" Max.: ");					sb.append(Global.getPref().maxDetails);
+				sb.append("<br>CacheWolf version: ");		sb.append(vers.getRelease());
 				sb.append("<br>");
 				InfoScreen is = new InfoScreen(sb.toString(), "System", false,pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);



From mirabilos at mail.berlios.de  Mon Oct 29 16:38:05 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Mon, 29 Oct 2007 16:38:05 +0100
Subject: [Cachewolf-svn] r1029 - trunk
Message-ID: <200710291538.l9TFc5Dn024932@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-29 16:38:05 +0100 (Mon, 29 Oct 2007)
New Revision: 1029

Modified:
   trunk/fwrtsnapshot.sh
Log:
fix apparent build error


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-29 10:42:05 UTC (rev 1028)
+++ trunk/fwrtsnapshot.sh	2007-10-29 15:38:05 UTC (rev 1029)
@@ -5,7 +5,7 @@
 v=$(svn info | sed -n '/Revision: /s///p')
 printf '/VER_SVN =/s/\$.*\$/$LastChangedRevision: %s $/\nwq\n' $v | \
     ed -s src/CacheWolf/Version.java
-javac -target 1.1 -encoding windows-1252 -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
+javac -source 1.3 -target 1.1 -encoding windows-1252 -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
 /usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
 rm -rf published
 mkdir -p published/dat/attributes



From mirabilos at mail.berlios.de  Mon Oct 29 16:42:54 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Mon, 29 Oct 2007 16:42:54 +0100
Subject: [Cachewolf-svn] r1030 - trunk
Message-ID: <200710291542.l9TFgsOh025428@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-29 16:42:54 +0100 (Mon, 29 Oct 2007)
New Revision: 1030

Modified:
   trunk/fwrtsnapshot.sh
Log:
ensure that if the Ewe generation fails, the job will be marked as broken


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-29 15:38:05 UTC (rev 1029)
+++ trunk/fwrtsnapshot.sh	2007-10-29 15:42:54 UTC (rev 1030)
@@ -8,6 +8,10 @@
 javac -source 1.3 -target 1.1 -encoding windows-1252 -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
 /usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
 rm -rf published
+if test '!' -e programs/CacheWolf/Jar/CacheWolf.bat; then
+	rm -rf bin
+	exit 1
+fi
 mkdir -p published/dat/attributes
 mv programs/CacheWolf/* published/
 chmod 755 published/*



From salzkammergut at mail.berlios.de  Mon Oct 29 20:22:37 2007
From: salzkammergut at mail.berlios.de (salzkammergut at mail.berlios.de)
Date: Mon, 29 Oct 2007 20:22:37 +0100
Subject: [Cachewolf-svn] r1031 - trunk/src/CacheWolf
Message-ID: <200710291922.l9TJMbKd026536@sheep.berlios.de>

Author: salzkammergut
Date: 2007-10-29 20:22:32 +0100 (Mon, 29 Oct 2007)
New Revision: 1031

Modified:
   trunk/src/CacheWolf/SearchCache.java
Log:
Search: Fix:When clearing a search, the caches that were filtered out by the search were not re-displayed correctly.

Modified: trunk/src/CacheWolf/SearchCache.java
===================================================================
--- trunk/src/CacheWolf/SearchCache.java	2007-10-29 15:42:54 UTC (rev 1030)
+++ trunk/src/CacheWolf/SearchCache.java	2007-10-29 19:22:32 UTC (rev 1031)
@@ -50,7 +50,9 @@
 	*/
 	public void clearSearch(){
 		for(int i = cacheDB.size()-1;i >=0;i--){
-			((CacheHolder)cacheDB.get(i)).is_flaged=false;
+			CacheHolder ch=((CacheHolder)cacheDB.get(i));
+			ch.is_flaged=false;
+			ch.is_filtered=(ch.is_black^Filter.showBlacklisted) ;
 		}
 		Global.getProfile().filterActive=Filter.filterActive; //TODO This is a hack. Need to tidy this up
 		Global.getProfile().filterInverted=Filter.filterInverted;



From mirabilos at mail.berlios.de  Mon Oct 29 22:41:23 2007
From: mirabilos at mail.berlios.de (mirabilos at BerliOS)
Date: Mon, 29 Oct 2007 22:41:23 +0100
Subject: [Cachewolf-svn] r1032 - trunk
Message-ID: <200710292141.l9TLfNFi001596@sheep.berlios.de>

Author: mirabilos
Date: 2007-10-29 22:41:23 +0100 (Mon, 29 Oct 2007)
New Revision: 1032

Modified:
   trunk/fwrtsnapshot.sh
Log:
I hope this fixes
./src/CacheWolf/Attribute.java:11: error while writing CacheWolf.Attribute: ./bin/CacheWolf/Attribute.class (No such file or directory)


Modified: trunk/fwrtsnapshot.sh
===================================================================
--- trunk/fwrtsnapshot.sh	2007-10-29 19:22:32 UTC (rev 1031)
+++ trunk/fwrtsnapshot.sh	2007-10-29 21:41:23 UTC (rev 1032)
@@ -5,6 +5,8 @@
 v=$(svn info | sed -n '/Revision: /s///p')
 printf '/VER_SVN =/s/\$.*\$/$LastChangedRevision: %s $/\nwq\n' $v | \
     ed -s src/CacheWolf/Version.java
+rm -rf bin
+mkdir -p bin/CacheWolf
 javac -source 1.3 -target 1.1 -encoding windows-1252 -cp ./lib/CompileEwe.zip:./lib/  -d ./bin/ -deprecation -nowarn ./src/CacheWolf/*.java ./src/CacheWolf/*/*.java ./src/exp/*.java ./src/utils/*.java
 /usr/local/bin/ewecl programs/Jewel.ewe -c cwberlios.jnf
 rm -rf published



From pfeffer at mail.berlios.de  Wed Oct 31 02:37:18 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 31 Oct 2007 02:37:18 +0100
Subject: [Cachewolf-svn] r1033 - trunk/src/CacheWolf/navi
Message-ID: <200710310137.l9V1bI8g007360@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-31 02:37:09 +0100 (Wed, 31 Oct 2007)
New Revision: 1033

Added:
   trunk/src/CacheWolf/navi/TransformCoordinates.java
Log:
MapDownload: first step to implement download from WMS, which only answer correctly when using Gau?-Kr?ger-Coordinates: Transformation from WGS84 to Gau?-Kr?ger

Added: trunk/src/CacheWolf/navi/TransformCoordinates.java
===================================================================
--- trunk/src/CacheWolf/navi/TransformCoordinates.java	2007-10-29 21:41:23 UTC (rev 1032)
+++ trunk/src/CacheWolf/navi/TransformCoordinates.java	2007-10-31 01:37:09 UTC (rev 1033)
@@ -0,0 +1,151 @@
+package CacheWolf.navi;
+
+import CacheWolf.CWPoint;
+import CacheWolf.Matrix;
+
+import java.lang.Math;
+
+public class TransformCoordinates {
+//	public Ellipsoid ellipsoid;
+//	public TransformParameters transParams;
+	
+	static final Ellipsoid Bessel = new Ellipsoid(6377397.155, 6356078.962);
+	static final Ellipsoid WGS84 = new Ellipsoid(6378137.000, 6356752.314);
+	static final TransformParameters GKToWGS84 = new TransformParameters(584.8, 67.0, 400.3, -0.105 * Math.PI/180/3600, -0.013 * Math.PI/180/3600, 2.378 * Math.PI/180/3600, 1/(1 - 10.290 * Math.pow(10, -6)) );
+	static final TransformParameters WGS84ToGK = new TransformParameters(-584.8, -67.0, -400.3, 0.105 * Math.PI/180/3600, 0.013 * Math.PI/180/3600, -2.378 * Math.PI/180/3600, 1- 10.290 * Math.pow(10, -6) );
+	
+	public static GKPoint WGS84ToGK(CWPoint ll) {
+		XyzCoordinates wgsxyz = latLon2xyz(ll, 0, WGS84);
+		XyzCoordinates gkxyz = transform(wgsxyz, WGS84ToGK);
+		CWPoint gkll = Xyz2Latlon(gkxyz, Bessel);
+		return projectLatlon2GK(gkll, Bessel);
+	}
+	
+	public static XyzCoordinates latLon2xyz(CWPoint ll, double alt, Ellipsoid ellipsoid) {
+		double e2 = (ellipsoid.a * ellipsoid.a - ellipsoid.b * ellipsoid.b)/(ellipsoid.a * ellipsoid.a);
+		double N = ellipsoid.a/ Math.sqrt(1 - e2 * Math.pow(Math.sin(ll.latDec / 180*Math.PI), 2));
+		XyzCoordinates ret = new XyzCoordinates(0,0,0);
+		ret.x = (N+alt) * Math.cos(ll.latDec /180*Math.PI) * Math.cos(ll.lonDec /180*Math.PI);
+		ret.y = (N+alt) * Math.cos(ll.latDec /180*Math.PI) * Math.sin(ll.lonDec /180*Math.PI);
+		ret.z = (N * Math.pow(ellipsoid.b, 2) / Math.pow(ellipsoid.a , 2) + alt) * Math.sin(ll.latDec /180*Math.PI);
+		return ret;
+	}
+	
+	public static XyzCoordinates transform(XyzCoordinates from, TransformParameters transParams) {
+		Matrix coos = new Matrix(3, 1);
+		coos.matrix[0][0] = from.x;
+		coos.matrix[1][0] = from.y;
+		coos.matrix[2][0] = from.z;
+
+		Matrix shift = new Matrix(3,1);
+		shift.matrix[0][0] = transParams.dx;
+		shift.matrix[1][0] = transParams.dy;
+		shift.matrix[2][0] = transParams.dz;
+		
+		coos.add(shift);
+		
+		Matrix rotate = new Matrix(3,3);
+		rotate.matrix[0][0] = 1;
+		rotate.matrix[1][1] = 1;
+		rotate.matrix[2][2] = 1;
+		rotate.matrix[0][1] = transParams.ez; 
+		rotate.matrix[0][2] = - transParams.ey;
+		rotate.matrix[1][0] = - rotate.matrix[0][1];
+		rotate.matrix[1][2] = transParams.ex;
+		rotate.matrix[2][0] = - rotate.matrix[0][2];
+		rotate.matrix[2][1] = - rotate.matrix[1][2];
+		
+		rotate.Multiply(coos);
+		coos = rotate;
+		coos.MultiplyByScalar(transParams.s); // scale
+		
+		return new XyzCoordinates(coos.matrix[0][0], coos.matrix[1][0], coos.matrix[2][0]);
+	}
+	
+	public static CWPoint Xyz2Latlon(XyzCoordinates from, Ellipsoid ellipsoid) {
+		double e2 = (ellipsoid.a * ellipsoid.a - ellipsoid.b * ellipsoid.b)/(ellipsoid.a * ellipsoid.a);
+		double s = Math.sqrt( Math.pow(from.x,2) + Math.pow(from.y,2));
+		double T = Math.atan( from.z * ellipsoid.a / (s * ellipsoid.b));
+		double B = Math.atan( (from.z + e2 * Math.pow(ellipsoid.a, 2) / ellipsoid.b * Math.pow(Math.sin(T), 3) )/(s - e2 * ellipsoid.a * Math.pow(Math.cos(T),3)));
+		double L = Math.atan(from.y / from.x);
+		double N = ellipsoid.a / Math.sqrt(1 - e2 * Math.pow(Math.sin(B),2));
+		double h = s / Math.cos(B)- N;
+		CWPoint ret = new CWPoint();
+		ret.latDec = B * 180/Math.PI;
+		ret.lonDec = L * 180/Math.PI;
+		//ret.alt = h;
+		return ret;
+	}
+	
+	public static GKPoint projectLatlon2GK(CWPoint ll, Ellipsoid ellipsoid) {
+		int stripe;
+		for (stripe=0; stripe <= 360; stripe += 3) { // TODO -180 bis +180
+			if (Math.abs(ll.lonDec - stripe) < 1.5) break;
+		}
+		double e2 = (ellipsoid.a * ellipsoid.a - ellipsoid.b * ellipsoid.b)/(ellipsoid.a * ellipsoid.a);
+		double l = (ll.lonDec - stripe) /180*Math.PI; // TODO see is int to double works
+		double B = ll.latDec /180*Math.PI;
+		double N = ellipsoid.a/ Math.sqrt(1- e2 * Math.pow(Math.sin(B),2));
+		double nue = Math.sqrt(Math.pow(ellipsoid.a, 2) / Math.pow(ellipsoid.b, 2)* e2 * Math.pow(Math.cos(B), 2));
+		double t = Math.tan(B);
+		
+		double n1 = (ellipsoid.a-ellipsoid.b)/(ellipsoid.a+ellipsoid.b);
+		double n2 = (ellipsoid.a+ellipsoid.b)/2 * (1+ Math.pow(n1, 2)/4 + Math.pow(n1, 4)/64);
+		double n3 = n1 * -3/2 + Math.pow(n1, 3) * 9/16  - Math.pow(n1, 5) * 3/32;
+		double n4 = Math.pow(n1, 2) * 15/16 - Math.pow(n1, 4) * 15/32;
+		double n5 = Math.pow(n1, 3) * -35/48 + Math.pow(n1, 5) * 105/256;
+		double n6 = Math.pow(n1, 4) * 315/512;
+		double arclength = n2 * (B + n3 * Math.sin(B*2) + n4 * Math.sin(B*4) + n5 * Math.sin(B*6) + n6 * Math.sin(B*8));
+		
+		double h1 = t/2 * N * Math.pow(Math.cos(B), 2) * l*l;
+		double h2 = t/24 * N * Math.pow(Math.cos(B),4) * (5 - t*t + 9 * nue*nue + 4*Math.pow(nue, 4)) * Math.pow(l,4);
+		double northing = arclength + h1 + h2;
+		
+		
+		double r1 = N * Math.cos(B) * l;
+		double r2 = N/6 * Math.pow(Math.cos(B), 3) * (1-t*t+nue*nue)*l*l*l;
+		double easting = r1 + r2 + stripe / 3 * 1000000 + 500000;
+		GKPoint ret = new GKPoint();
+		ret.easting = easting;
+		ret.northing = northing;
+		return ret;
+	}
+}
+
+class XyzCoordinates {
+	double x, y, z;
+	public XyzCoordinates (double xi, double yi, double zi) {
+		x = xi;
+		y = yi;
+		z = zi;
+	}
+}
+
+class Ellipsoid {
+	double a, b;
+	public Ellipsoid(double ai, double bi) {
+		a = ai;
+		b = bi;
+	}
+}
+
+class TransformParameters {
+	// shift parameter
+	double dx, dy, dz, 
+	// rotation parameter in rad
+	ex, ey, ez, 
+	// scale as multiplicator
+	s;
+	
+	public TransformParameters(double dxi, double dyi, double dzi, double exi, double eyi, double ezi, double si) {
+		dx = dxi; dy = dyi; dz = dzi; ex = exi; ey =eyi; ez = ezi; s = si;
+	}
+}
+
+class GKPoint {
+	double northing;
+	double easting;
+	public String toString() {
+		return Double.toString(easting) + ";" + Double.toString(northing);
+	}
+}



From pfeffer at mail.berlios.de  Wed Oct 31 16:10:03 2007
From: pfeffer at mail.berlios.de (pfeffer at mail.berlios.de)
Date: Wed, 31 Oct 2007 16:10:03 +0100
Subject: [Cachewolf-svn] r1034 - trunk/src/CacheWolf
Message-ID: <200710311510.l9VFA3AP032624@sheep.berlios.de>

Author: pfeffer
Date: 2007-10-31 16:09:59 +0100 (Wed, 31 Oct 2007)
New Revision: 1034

Modified:
   trunk/src/CacheWolf/Matrix.java
Log:
Gau?-Kr?ger-Transformation: I forgot to commit this file yesterday

Modified: trunk/src/CacheWolf/Matrix.java
===================================================================
--- trunk/src/CacheWolf/Matrix.java	2007-10-31 01:37:09 UTC (rev 1033)
+++ trunk/src/CacheWolf/Matrix.java	2007-10-31 15:09:59 UTC (rev 1034)
@@ -49,6 +49,18 @@
 		return product;
 	}
 	
+	public void MultiplyByScalar (double f) {
+		for (int i = 0; i < matrix.length; i++)
+			for (int j = 0; j < matrix[0].length; j++)
+				matrix[i][j] = matrix[i][j] * f;
+	}
+	
+	public void add (Matrix a) {
+		for (int i = 0; i < matrix.length; i++)
+			for (int j = 0; j < matrix[0].length; j++)
+				matrix[i][j] = matrix[i][j] + a.matrix[i][j];
+	}
+	
 	/**
 	*	Method to transpose a matrix
 	*	example:	| 1 2 |



