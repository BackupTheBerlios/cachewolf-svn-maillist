<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3048 - in branches/r1.2: . docs res_noewe	res_noewe/attributes res_noewe/languages res_noewe/symbols	res_noewe/templates res_noewe/webmapservices resources	src/CacheWolf src/CacheWolf/exp src/CacheWolf/imp	src/CacheWolf/model src/CacheWolf/navi	src/CacheWolf/navi/touchControls src/CacheWolf/utils	src/CacheWolf/view src/CacheWolf/view/ewe	src/CacheWolf/view/pda tools/MakeWMSFile	tools/MakeWMSFile/capxml2wms tools/MakeWMSFile/capxml2wms/My	Project tools/MakeWMSFile/capxml2wms/bin/Debug
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-August/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3048%20-%20in%20branches/r1.2%3A%20.%20docs%20res_noewe%0A%09res_noewe/attributes%20res_noewe/languages%20res_noewe/symbols%0A%09res_noewe/templates%20res_noewe/webmapservices%20resources%0A%09src/CacheWolf%20src/CacheWolf/exp%20src/CacheWolf/imp%0A%09src/CacheWolf/model%20src/CacheWolf/navi%0A%09src/CacheWolf/navi/touchControls%20src/CacheWolf/utils%0A%09src/CacheWolf/view%20src/CacheWolf/view/ewe%0A%09src/CacheWolf/view/pda%20tools/MakeWMSFile%0A%09tools/MakeWMSFile/capxml2wms%20tools/MakeWMSFile/capxml2wms/My%0A%09Project%20tools/MakeWMSFile/capxml2wms/bin/Debug&In-Reply-To=%3C20110801180808.147394833A6%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="003040.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3048 - in branches/r1.2: . docs res_noewe	res_noewe/attributes res_noewe/languages res_noewe/symbols	res_noewe/templates res_noewe/webmapservices resources	src/CacheWolf src/CacheWolf/exp src/CacheWolf/imp	src/CacheWolf/model src/CacheWolf/navi	src/CacheWolf/navi/touchControls src/CacheWolf/utils	src/CacheWolf/view src/CacheWolf/view/ewe	src/CacheWolf/view/pda tools/MakeWMSFile	tools/MakeWMSFile/capxml2wms tools/MakeWMSFile/capxml2wms/My	Project tools/MakeWMSFile/capxml2wms/bin/Debug</H1>
    <B>araber95 at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3048%20-%20in%20branches/r1.2%3A%20.%20docs%20res_noewe%0A%09res_noewe/attributes%20res_noewe/languages%20res_noewe/symbols%0A%09res_noewe/templates%20res_noewe/webmapservices%20resources%0A%09src/CacheWolf%20src/CacheWolf/exp%20src/CacheWolf/imp%0A%09src/CacheWolf/model%20src/CacheWolf/navi%0A%09src/CacheWolf/navi/touchControls%20src/CacheWolf/utils%0A%09src/CacheWolf/view%20src/CacheWolf/view/ewe%0A%09src/CacheWolf/view/pda%20tools/MakeWMSFile%0A%09tools/MakeWMSFile/capxml2wms%20tools/MakeWMSFile/capxml2wms/My%0A%09Project%20tools/MakeWMSFile/capxml2wms/bin/Debug&In-Reply-To=%3C20110801180808.147394833A6%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3048 - in branches/r1.2: . docs res_noewe	res_noewe/attributes res_noewe/languages res_noewe/symbols	res_noewe/templates res_noewe/webmapservices resources	src/CacheWolf src/CacheWolf/exp src/CacheWolf/imp	src/CacheWolf/model src/CacheWolf/navi	src/CacheWolf/navi/touchControls src/CacheWolf/utils	src/CacheWolf/view src/CacheWolf/view/ewe	src/CacheWolf/view/pda tools/MakeWMSFile	tools/MakeWMSFile/capxml2wms tools/MakeWMSFile/capxml2wms/My	Project tools/MakeWMSFile/capxml2wms/bin/Debug">araber95 at mail.berlios.de
       </A><BR>
    <I>Mon Aug  1 08:08:06 CEST 2011</I>
    <P><UL>
        
        <LI>Next message: <A HREF="003040.html">[Cachewolf-svn] r3049 - in branches/r1.2/src/CacheWolf: . navi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3039">[ date ]</a>
              <a href="thread.html#3039">[ thread ]</a>
              <a href="subject.html#3039">[ subject ]</a>
              <a href="author.html#3039">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: araber95
Date: 2011-08-01 20:08:06 +0200 (Mon, 01 Aug 2011)
New Revision: 3048

Added:
   branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt
   branches/r1.2/res_noewe/attributes/sponsored-no.gif
   branches/r1.2/res_noewe/attributes/sponsored-non.gif
   branches/r1.2/res_noewe/attributes/sponsored-yes.gif
   branches/r1.2/res_noewe/icon_smile_dissapprove.gif
   branches/r1.2/res_noewe/icon_smile_sad.gif
   branches/r1.2/res_noewe/icon_smile_shy.gif
   branches/r1.2/res_noewe/templates/Parking.tpl
   branches/r1.2/res_noewe/webmapservices/at-5_p.wms
   branches/r1.2/res_noewe/webmapservices/at-5_t.wms
   branches/r1.2/res_noewe/webmapservices/at-6_p.wms
   branches/r1.2/res_noewe/webmapservices/at-8_t.wms
   branches/r1.2/res_noewe/webmapservices/cz_t.wms
   branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms
   branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms
   branches/r1.2/res_noewe/webmapservices/de-sl-t.wms
   branches/r1.2/res_noewe/webmapservices/de_t25.wms
   branches/r1.2/res_noewe/webmapservices/de_t_itc.wms
   branches/r1.2/res_noewe/webmapservices/dk_p.wms
   branches/r1.2/res_noewe/webmapservices/dk_t.wms
   branches/r1.2/res_noewe/webmapservices/dk_t25.wms
   branches/r1.2/res_noewe/webmapservices/dk_t50.wms
   branches/r1.2/res_noewe/webmapservices/fr_t.wms
   branches/r1.2/res_noewe/webmapservices/it-25_p.wms
   branches/r1.2/res_noewe/webmapservices/wfl-format.txt
   branches/r1.2/resources/archived.png
   branches/r1.2/resources/bonus.png
   branches/r1.2/resources/disabled.png
   branches/r1.2/resources/dnf.png
   branches/r1.2/resources/found.png
   branches/r1.2/resources/owned.png
   branches/r1.2/resources/solved.png
   branches/r1.2/src/CacheWolf/exp/OCLogExport.java
   branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java
   branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java
   branches/r1.2/src/CacheWolf/model/
   branches/r1.2/src/CacheWolf/model/DefaultListModel.java
   branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java
   branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java
   branches/r1.2/src/CacheWolf/view/
   branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java
   branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java
   branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java
   branches/r1.2/src/CacheWolf/view/ewe/
   branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
   branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java
   branches/r1.2/src/CacheWolf/view/pda/
   branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java
   branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java
   branches/r1.2/src/CacheWolf/view/pda/PDAList.java
   branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java
   branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java
   branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java
   branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java
   branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java
   branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java
   branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java
Modified:
   branches/r1.2/CacheWolf.launch
   branches/r1.2/compile.bat
   branches/r1.2/currentversions.txt
   branches/r1.2/fwrtsnapshot.sh
   branches/r1.2/res_noewe/languages/DE.cfg
   branches/r1.2/res_noewe/languages/EN.cfg
   branches/r1.2/res_noewe/languages/FR.cfg
   branches/r1.2/res_noewe/languages/NL.cfg
   branches/r1.2/res_noewe/languages/PL.cfg
   branches/r1.2/res_noewe/languages/SV.cfg
   branches/r1.2/res_noewe/legende.html
   branches/r1.2/res_noewe/legende_de.html
   branches/r1.2/res_noewe/spider.def
   branches/r1.2/res_noewe/symbols/readme.htm
   branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm
   branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms
   branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms
   branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms
   branches/r1.2/res_noewe/webmapservices/at-3_p.wms
   branches/r1.2/res_noewe/webmapservices/at-3_t50.wms
   branches/r1.2/res_noewe/webmapservices/at_p.wms
   branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms
   branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms
   branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms
   branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms
   branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-bw_p.wms
   branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-by_p.wms
   branches/r1.2/res_noewe/webmapservices/de-by_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-he_p.wms
   branches/r1.2/res_noewe/webmapservices/de-he_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms
   branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms
   branches/r1.2/res_noewe/webmapservices/de-ni_p.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_p.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-rp_p.wms
   branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms
   branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-sh_t.wms
   branches/r1.2/res_noewe/webmapservices/de-sn_p.wms
   branches/r1.2/res_noewe/webmapservices/de-sn_t.wms
   branches/r1.2/res_noewe/webmapservices/de-st_p.wms
   branches/r1.2/res_noewe/webmapservices/de-st_t10.wms
   branches/r1.2/res_noewe/webmapservices/de-st_t50.wms
   branches/r1.2/res_noewe/webmapservices/de-th_t25.wms
   branches/r1.2/res_noewe/webmapservices/de_t2500.wms
   branches/r1.2/res_noewe/webmapservices/es-an_p.wms
   branches/r1.2/res_noewe/webmapservices/es-an_t.wms
   branches/r1.2/res_noewe/webmapservices/es-an_t1.wms
   branches/r1.2/res_noewe/webmapservices/es-ar_p.wms
   branches/r1.2/res_noewe/webmapservices/es-ar_t.wms
   branches/r1.2/res_noewe/webmapservices/es-cn_p.wms
   branches/r1.2/res_noewe/webmapservices/es-cn_t.wms
   branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms
   branches/r1.2/res_noewe/webmapservices/es_p.wms
   branches/r1.2/res_noewe/webmapservices/es_t25.wms
   branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms
   branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms
   branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms
   branches/r1.2/res_noewe/webmapservices/it-52_t10.wms
   branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms
   branches/r1.2/res_noewe/webmapservices/it-88_m.wms
   branches/r1.2/res_noewe/webmapservices/it-88_p.wms
   branches/r1.2/res_noewe/webmapservices/it-88_t10.wms
   branches/r1.2/res_noewe/webmapservices/it_p.wms
   branches/r1.2/res_noewe/webmapservices/it_t100.wms
   branches/r1.2/res_noewe/webmapservices/it_t25.wms
   branches/r1.2/res_noewe/webmapservices/jp-t.wms
   branches/r1.2/res_noewe/webmapservices/no-no_t.wms
   branches/r1.2/res_noewe/webmapservices/pl_p.wms
   branches/r1.2/res_noewe/webmapservices/pl_t50.wms
   branches/r1.2/res_noewe/webmapservices/pt_t500.wms
   branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms
   branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms
   branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms
   branches/r1.2/res_noewe/webmapservices/us_p.wms
   branches/r1.2/res_noewe/webmapservices/us_t.wms
   branches/r1.2/src/CacheWolf/Attribute.java
   branches/r1.2/src/CacheWolf/Attributes.java
   branches/r1.2/src/CacheWolf/AttributesSelector.java
   branches/r1.2/src/CacheWolf/CacheHolder.java
   branches/r1.2/src/CacheWolf/CacheHolderDetail.java
   branches/r1.2/src/CacheWolf/CacheImages.java
   branches/r1.2/src/CacheWolf/CacheList.java
   branches/r1.2/src/CacheWolf/CacheType.java
   branches/r1.2/src/CacheWolf/CalcPanel.java
   branches/r1.2/src/CacheWolf/Common.java
   branches/r1.2/src/CacheWolf/CoordsScreen.java
   branches/r1.2/src/CacheWolf/DBStats.java
   branches/r1.2/src/CacheWolf/DataMover.java
   branches/r1.2/src/CacheWolf/DateFormat.java
   branches/r1.2/src/CacheWolf/DateTimeChooser.java
   branches/r1.2/src/CacheWolf/DetailsPanel.java
   branches/r1.2/src/CacheWolf/Extractor.java
   branches/r1.2/src/CacheWolf/Filter.java
   branches/r1.2/src/CacheWolf/GeoCodeGui.java
   branches/r1.2/src/CacheWolf/GeocoderOsm.java
   branches/r1.2/src/CacheWolf/GuiImageBroker.java
   branches/r1.2/src/CacheWolf/HintLogPanel.java
   branches/r1.2/src/CacheWolf/HttpConnection.java
   branches/r1.2/src/CacheWolf/ImagePanel.java
   branches/r1.2/src/CacheWolf/InfoBox.java
   branches/r1.2/src/CacheWolf/LogList.java
   branches/r1.2/src/CacheWolf/MainForm.java
   branches/r1.2/src/CacheWolf/MainMenu.java
   branches/r1.2/src/CacheWolf/MainTab.java
   branches/r1.2/src/CacheWolf/MyComparer.java
   branches/r1.2/src/CacheWolf/OC.java
   branches/r1.2/src/CacheWolf/Parser.java
   branches/r1.2/src/CacheWolf/Preferences.java
   branches/r1.2/src/CacheWolf/PreferencesScreen.java
   branches/r1.2/src/CacheWolf/Profile.java
   branches/r1.2/src/CacheWolf/RadarPanel.java
   branches/r1.2/src/CacheWolf/SafeXML.java
   branches/r1.2/src/CacheWolf/Travelbug.java
   branches/r1.2/src/CacheWolf/TravelbugJourneyList.java
   branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java
   branches/r1.2/src/CacheWolf/TravelbugPickup.java
   branches/r1.2/src/CacheWolf/TravelbugScreen.java
   branches/r1.2/src/CacheWolf/UrlFetcher.java
   branches/r1.2/src/CacheWolf/exp/DistanceComparer.java
   branches/r1.2/src/CacheWolf/exp/ExploristExporter.java
   branches/r1.2/src/CacheWolf/exp/Exporter.java
   branches/r1.2/src/CacheWolf/exp/GpxExportNg.java
   branches/r1.2/src/CacheWolf/exp/KMLExporter.java
   branches/r1.2/src/CacheWolf/exp/LocExporter.java
   branches/r1.2/src/CacheWolf/exp/OziExporter.java
   branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java
   branches/r1.2/src/CacheWolf/exp/TPLExporter.java
   branches/r1.2/src/CacheWolf/exp/TomTomExporter.java
   branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java
   branches/r1.2/src/CacheWolf/imp/GPXImporter.java
   branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java
   branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java
   branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java
   branches/r1.2/src/CacheWolf/imp/SpiderGC.java
   branches/r1.2/src/CacheWolf/myTableControl.java
   branches/r1.2/src/CacheWolf/myTableModel.java
   branches/r1.2/src/CacheWolf/navi/Area.java
   branches/r1.2/src/CacheWolf/navi/AreaList.java
   branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java
   branches/r1.2/src/CacheWolf/navi/GotoPanel.java
   branches/r1.2/src/CacheWolf/navi/MapImage.java
   branches/r1.2/src/CacheWolf/navi/MapInfoObject.java
   branches/r1.2/src/CacheWolf/navi/MapLoader.java
   branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java
   branches/r1.2/src/CacheWolf/navi/MapSymbol.java
   branches/r1.2/src/CacheWolf/navi/MapsList.java
   branches/r1.2/src/CacheWolf/navi/MovingMap.java
   branches/r1.2/src/CacheWolf/navi/Navigate.java
   branches/r1.2/src/CacheWolf/navi/Track.java
   branches/r1.2/src/CacheWolf/navi/TrackOverlay.java
   branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
   branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
   branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java
   branches/r1.2/src/CacheWolf/utils/CWWrapper.java
   branches/r1.2/tools/MakeWMSFile/capxml2wms.sln
   branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/bin/Debug/capxml2wms.exe
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj
   branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user
Log:
Release from NB 3047

Modified: branches/r1.2/CacheWolf.launch
===================================================================
--- branches/r1.2/CacheWolf.launch	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/CacheWolf.launch	2011-08-01 18:08:06 UTC (rev 3048)
@@ -7,9 +7,9 @@
 &lt;listEntry value=&quot;4&quot;/&gt;
 &lt;/listAttribute&gt;
 &lt;listAttribute key=&quot;org.eclipse.jdt.launching.CLASSPATH&quot;&gt;
-&lt;listEntry value=&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry internalArchive=&quot;/CacheWolf/lib/ewe.jar&quot; path=&quot;3&quot; type=&quot;2&quot;/&gt;&#13;&#10;&quot;/&gt;
-&lt;listEntry value=&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.jdt.launching.classpathentry.defaultClasspath&quot;&gt;&#13;&#10;&lt;memento exportedEntriesOnly=&quot;false&quot; project=&quot;CacheWolf&quot;/&gt;&#13;&#10;&lt;/runtimeClasspathEntry&gt;&#13;&#10;&quot;/&gt;
+&lt;listEntry value=&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry path=&quot;3&quot; projectName=&quot;CacheWolf&quot; type=&quot;1&quot;/&gt;&#13;&#10;&quot;/&gt;
 &lt;listEntry value=&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry internalArchive=&quot;/CacheWolf/lib/JavaEwe.zip&quot; path=&quot;3&quot; type=&quot;2&quot;/&gt;&#13;&#10;&quot;/&gt;
+&lt;listEntry value=&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;runtimeClasspathEntry internalArchive=&quot;/CacheWolf/lib&quot; path=&quot;3&quot; type=&quot;2&quot;/&gt;&#13;&#10;&quot;/&gt;
 &lt;/listAttribute&gt;
 &lt;booleanAttribute key=&quot;org.eclipse.jdt.launching.DEFAULT_CLASSPATH&quot; value=&quot;false&quot;/&gt;
 &lt;stringAttribute key=&quot;org.eclipse.jdt.launching.MAIN_TYPE&quot; value=&quot;Ewe&quot;/&gt;

Modified: branches/r1.2/compile.bat
===================================================================
--- branches/r1.2/compile.bat	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/compile.bat	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,4 +1,4 @@
 if not exist bin\CacheWolf mkdir bin\CacheWolf
-javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/CacheWolf/navi/touchControls/*.java ./src/CacheWolf/exp/*.java ./src/CacheWolf/utils/*.java 
+javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./bin/ -deprecation ./src/CacheWolf/*.java ./src/CacheWolf/imp/*.java ./src/CacheWolf/navi/*.java ./src/CacheWolf/navi/touchControls/*.java ./src/CacheWolf/exp/*.java ./src/CacheWolf/utils/*.java ./src/CacheWolf/model/*.java ./src/CacheWolf/view/*.java  ./src/CacheWolf/view/ewe/*.java  ./src/CacheWolf/view/pda/*.java
 javac -source 1.3 -target 1.1 -cp ./lib/CompileEwe.zip;./lib/  -d ./lib/ -deprecation ./lib/net/ax86/*.java ./lib/org/json/*.java
-pause
\ No newline at end of file
+pause

Modified: branches/r1.2/currentversions.txt
===================================================================
--- branches/r1.2/currentversions.txt	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/currentversions.txt	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,12 +1,12 @@
 # Release
 T0VersionMajor: 1
-T0VersionMinor: 0
-T0SvnRevision: 2716
+T0VersionMinor: 2
+T0SvnRevision: <A HREF="http://cachewolf.aldos.de/rc/mostrecentbuild.txt">http://cachewolf.aldos.de/rc/mostrecentbuild.txt</A> [\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)
 
 # ReleaseCandidate
 T1VersionMajor: 1
-T1VersionMinor: 2
-T1SvnRevision: <A HREF="http://cachewolf.aldos.de/rc/mostrecentbuild.txt">http://cachewolf.aldos.de/rc/mostrecentbuild.txt</A> [\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)
+T1VersionMinor: 3
+T1SvnRevision: <A HREF="http://cachewolf.aldos.de/mostrecentbuild.txt">http://cachewolf.aldos.de/mostrecentbuild.txt</A> [\\s]*[\\\\r]*[\\\\n]*[\\s]*([0-9]*)
 
 # InDevelopmentStable
 T2VersionMajor: 1

Added: branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt
===================================================================
--- branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt	                        (rev 0)
+++ branches/r1.2/docs/Sonderzeichen_in_languages.cfg.txt	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,27 @@
+&#239;&#187;&#191;Zeichen sind als &quot;Quoted printable&quot; kodiert mit einem % Zeichen
+Siehe auch <A HREF="http://de.wikipedia.org/wiki/Quoted-printable">http://de.wikipedia.org/wiki/Quoted-printable</A>
+und <A HREF="http://www.cs.tut.fi/~jkorpela/chars.html">http://www.cs.tut.fi/~jkorpela/chars.html</A>
+
+Leertaste: +
+&#195;&#164; %e4
+&#195;&#182; %f6
+&#195;&#188; %fc
+&#195;&#159; %df
+&#195;&#132; %c4
+&#195;&#150; %d6
+&#195;&#156; %dc
+\n %0a
+&#195;&#169; %e9
+&#195;&#168; %e8
+&#195;&#137; %c9
+&#195;&#136; %c8
+&#195;&#160; %e0
+&#195;&#128; %c0
+&#195;&#185; %f9
+&#195;&#153; %d9
+&#195;&#174; %ee
+&#195;&#142; %ce
+&#195;&#162; %e2
+&#195;&#130; %c2
+&#195;&#180; %f4
+&#195;&#148; %d4

Modified: branches/r1.2/fwrtsnapshot.sh
===================================================================
--- branches/r1.2/fwrtsnapshot.sh	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/fwrtsnapshot.sh	2011-08-01 18:08:06 UTC (rev 3048)
@@ -18,8 +18,8 @@
 rm -rf bin
 mkdir -p bin/CacheWolf
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
-    -cp lib/CompileEwe.zip:lib -d bin -deprecation -nowarn \
-    src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java
+     -cp lib/CompileEwe.zip:lib -d bin -deprecation -nowarn \
+     src/CacheWolf/*.java src/CacheWolf/*/*.java src/CacheWolf/navi/touchControls/*.java src/CacheWolf/view/*/*.java	 
 javac -source 1.3 -target 1.1 -encoding windows-1252 \
     -cp ./lib/CompileEwe.zip:lib -d lib -deprecation -nowarn \
 	lib/net/ax86/*.java ./lib/org/json/*.java

Added: branches/r1.2/res_noewe/attributes/sponsored-no.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/attributes/sponsored-no.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/attributes/sponsored-non.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/attributes/sponsored-non.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/attributes/sponsored-yes.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/attributes/sponsored-yes.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/icon_smile_dissapprove.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/icon_smile_dissapprove.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/icon_smile_sad.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/icon_smile_sad.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/res_noewe/icon_smile_shy.gif
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/res_noewe/icon_smile_shy.gif
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: branches/r1.2/res_noewe/languages/DE.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/DE.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/DE.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Markierte ausfiltern
 161=Zeige Blacklist
 162=Kalibrierte herunterladen
+163=von OC Funde
+164=nur bei OC gelistet
+165=Lade nur, wenn mit Cache
 170=Datenverzeichnis w&#195;&#164;hlen
 171=Profil existiert nicht:+
 172=Kann das Kartenverzeichnis nicht erstellen:
@@ -452,6 +455,8 @@
 1206=Rechner
 1207=&#195;&#132;nderungen im Profil Speichern?
 1208=Bewertungen von gcvote
+1209=Link zu OC - Cache
+1210=Logs nach OC
 1300=Letzte Einstellung
 1301=Profil ausw&#195;&#164;hlen:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=Tankstelle nahebei
 2679=keine Verpflegungsm&#195;&#182;glichkeit
 2680=Verpflegungsm&#195;&#182;glichkeit nahebei
-2681=RFID / Funk Ausr&#195;&#188;stung
+2681=RFID, CHIRP / Funk Ausr&#195;&#188;stung nicht n&#195;&#182;tig
+2682=RFID, CHIRP / Funk Ausr&#195;&#188;stung
+2683=keine Erste Hilfe 
+2684=Erste Hilfe nahebei
+2685=nicht gesponsert
+2686=gesponsert
 3000=Schlie&#195;&#159;en
 4000=Geladene Caches:+
 4001=GPX-Dateien von Opencaching enthalten keine Informationen zu Bildern, sie werden nicht heruntergeladen. Am besten Caches von Opencaching holen per Men&#195;&#188; /Anwendung/Import/von Opencaching
@@ -988,6 +998,7 @@
 5520=Nur das eingestellte Maximum an Caches wurde geladen.\nWiederholen sie das Spidern sp&#195;&#164;ter um weitere Caches zu laden.\nEs wurden keine vorhandenen Caches aktualisiert.
 5521=Seite+
 5522=Pr&#195;&#188;fen auf &#195;&#164;ltere XML-Dateien ( ohne &lt;CACHE... /&gt; ) ?
+
 6000=Guid
 6001=Name
 6002=Track#
@@ -1029,7 +1040,19 @@
 6046=Nur nicht geloggte zeigen
 6047=Ausgew&#195;&#164;hlte Zeilen l&#195;&#182;schen
 6050=Spalten zeigen
-6051=Spalten verbergen
+6051=Spalten verbergen
+6052=Men&#195;&#188;
+6053=Travelbug Men&#195;&#188;
+6054=Alle anzeigen
+6055=Sortieren...
+6056=Expertenansicht
+6057=zur&#195;&#188;ck
+6058=Aufgenommen:
+6059=Datum: 
+6060=Abgelegt:
+6061=Schlie&#195;&#159;en
+6062=Track-Nr
+
 6100=Sonne
 6101=Mond
 6102=Gro&#195;&#159;er Wagen

Modified: branches/r1.2/res_noewe/languages/EN.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/EN.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/EN.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filter out ticked
 161=Show Blacklist
 162=Download calibrated
+163 = OC finds
+164 = only available at OC
+165 = load only, if with cache
 170=Select data directory
 171=Profile does not exist:+
 172=Error: cannot create maps directory:
@@ -452,6 +455,8 @@
 1206=Calc
 1207=Your profile has unsaved changes. Do you want to save?
 1208=ratings from GCVote
+1209=link to OC - Cache
+1210=logs to OC
 1300=Last Setting
 1301=Select Profile:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=Fuel nearby
 2679=no Food nearby
 2680=Food nearby
-2681=wireless beacon
+2681 = RFID, CHIRP / radio equipment is not necessary
+2682 = RFID, CHIRP / radio equipment
+2683 = No emergency
+2684 = First Aid nearby
+2685=not sponsored
+2686=sponsored
 3000=Close
 4000=Loaded caches:+
 4001=GPX files from opencaching don't contain information of images, they cannot be loaded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching
@@ -1029,7 +1039,19 @@
 6046=Show only not logged
 6047=Delete selected Travelbugs
 6050=Show column
-6051=Don't show column
+6051=Don't show column
+6052=Menu
+6053=Travelbug Menu
+6054=Show all
+6055=Sort ...
+6056=Expertview
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-No
+
 6100=Sun
 6101=Moon
 6102=Greater Bear

Modified: branches/r1.2/res_noewe/languages/FR.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/FR.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/FR.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filtre les caches coch&#195;&#169;es
 161=Montre liste noire
 162=T&#195;&#169;l&#195;&#169;charger calibr&#195;&#169;e
+163 = OC trouve
+164 = uniquement disponible chez OC
+165 = seulement, si avec une cache
 170=Choisir dossier de base pour les profiles
 171=Profile n'existe pas:+
 172=Ne peut pas cr&#195;&#169;er dossier pour des cartes:
@@ -452,6 +455,8 @@
 1206=Ordinateur
 1207=Sauvegarder les changements dans le profil?
 1208=ratings from GCVote
+1209 = lien vers OC - Cache
+1210 = journaux pour OC
 1300=Dernier param&#195;&#168;tage
 1301=Choisir profil:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=carburant &#195;&#160; proximit&#195;&#169;
 2679=pas de nourriture &#195;&#160; proximit&#195;&#169;
 2680=la nourriture &#195;&#160; proximit&#195;&#169;
-2681=Chirp (Garmin)
+2681 = RFID, CHIRP / &#195;&#169;quipement radio n'est pas n&#195;&#169;cessaire
+2682 = RFID, CHIRP &#195;&#169;quipement radio /
+2683 = Pas d'urgence
+2684 = First Aid &#195;&#160; proximit&#195;&#169;
+2685 = non parrain&#195;&#169;
+2686 = parrain&#195;&#169;
 3000=Fermer
 4000=Caches charg&#195;&#169;es:
 4001=GPX fichiers &#195;&#160; partir Opencaching ne contiennent pas d'informations d'images, ils ne peuvent pas &#195;&#170;tre charg&#195;&#169;. Pour le meilleur vous obtenez des caches de Opencaching par le menu /Application/importation/Download from Opencaching
@@ -1030,6 +1040,18 @@
 6047=Effacer lignes selectionn&#195;&#169;es
 6050=Montrer colonnes
 6051=Masquer colonnes
+6052=Menu
+6053=Travelbug Men&#195;&#188;
+6054=Alle anzeigen
+6055=Sort ...
+6056=Expertenansicht
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-Nr
+
 6100=Soleil
 6101=Lune
 6102=Grande Ourse

Modified: branches/r1.2/res_noewe/languages/NL.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/NL.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/NL.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Gemarkeerd filteren
 161=Toon Blacklist
 162=Gekalibreerde kaarten downloaden.
+163 = OC vindt
+164 = alleen verkrijgbaar bij OC
+165 = alleen downloaden, als met cache
 170=Selecteer basis map voor cache data.
 171=Profiel bestaat niet:+
 172=Fout: kan kaarten map niet maken:\n.
@@ -452,6 +455,8 @@
 1206=Calculator
 1207=Jouw profiel is veranderd, wil je het profiel opslaan?
 1208=ratings from GCVote
+1209 = link naar OC - Cache
+1210 = logboeken naar OC
 1300=Laatste instellingen
 1301=Selecteer profiel
 1400=Zone
@@ -786,7 +791,12 @@
 2678=brandstof in de omgeving
 2679=geen eten in de buurt
 2680=Voedsel in de buurt
-2681=Chirp (Garmin)
+2681 = RFID, CHIRP / radio-apparatuur is niet nodig
+2682 = RFID, CHIRP / radio-apparatuur
+2683 = Geen spoed
+2684 = Eerste Hulp in de buurt
+2685 = niet gesponsord
+2686 = gesponsord
 3000=Sluiten
 4000=Geladen caches
 4001=GPX bestanden uit opencaching bevatten geen informatie van beelden, kunnen zij niet worden downloaden. Beste je caches van opencaching menu /Application/Import/Download from Opencaching
@@ -1029,7 +1039,19 @@
 6046=Toon alleen gelogd.
 6047=Verwijder geselecteerde Travelbugs.
 6050=Toon kolom
-6051=Toon kolom niet.
+6051=Toon kolom niet.
+6052=Menu
+6053=Travelbug Men&#195;&#188;
+6054=Alle anzeigen
+6055=Sort ...
+6056=Expertenansicht
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-Nr
+
 6100=Zon
 6101=Maan
 6102=Grote Beer

Modified: branches/r1.2/res_noewe/languages/PL.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/PL.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/PL.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filtruj zaznaczone
 161=Pokaz czarna liste
 162=Sciagnij skalibrowane
+163 = OC stwierdzi
+164 = dost&#196;&#153;pne tylko w OC
+165 = tylko w&#195;&#179;wczas, gdy z pami&#196;&#153;ci podr&#196;&#153;cznej
 170=Wybierz folder z danymi
 171=Profil nie istnieje:+
 172=Blad: nie mozna utworzyc katalogu map:
@@ -452,6 +455,8 @@
 1206=Calc
 1207=Twoj Profil ma niezapisane zmiany. Chcesz zapisac?
 1208=ratings from GCVote
+1209 = link do OC - Cache
+1210 = dziennik&#195;&#179;w OC
 1300=Ostatnie ustawienia
 1301=Wybierz Profil:
 1400=Strefa
@@ -786,7 +791,12 @@
 2678=paliwa w poblizu
 2679=brak zywnosci w poblizu
 2680=Zywnosci w poblizu
-2681=Chirp (Garmin)
+2681 = RFID, CHIRP / radio sprz&#196;&#153;t nie jest konieczne
+2682 = RFID, CHIRP / urz&#196;&#133;dze&#197;&#132; radiowych
+2683 = Nie awaryjne
+2684 = Pierwsza pomoc w pobli&#197;&#188;u
+2685 = nie sponsorowane
+2686 = sponsorowane
 3000=Zamknij
 4000=Wczytaj skrzynki:+
 4001=Pliki GPX z opencaching nie zawieraja informacji o obrazach, nie moga byc one wczytane. Najlepiej pobierz skrzynki z opencaching przez menu /Aplikacja/Importuj/Sciagnij Z Opencaching
@@ -1029,7 +1039,19 @@
 6046=Pokaz tylko nie zalogowane
 6047=Usun wybrane Travelbugi
 6050=Pokaz kolumny
-6051=Nie pokazuj kolumny
+6051=Nie pokazuj kolumny
+6052=Menu
+6053=Travelbug Men&#195;&#188;
+6054=Alle anzeigen
+6055=Sort ...
+6056=Expertenansicht
+6057=Back
+6058=Retrieved:
+6059=Date: 
+6060=Dropped off:
+6061=Close
+6062=Track-Nr
+
 6100=Slonce
 6101=Ksiezyc
 6102=Wielka Niedzwiedzica

Modified: branches/r1.2/res_noewe/languages/SV.cfg
===================================================================
--- branches/r1.2/res_noewe/languages/SV.cfg	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/languages/SV.cfg	2011-08-01 18:08:06 UTC (rev 3048)
@@ -92,6 +92,9 @@
 160=Filter markeras ut
 161=Visa Blacklist
 162=Ladda kalibrerad
+163 = OC finner
+164 = endast tillg&#195;&#164;nglig p&#195;&#165; OC
+165 = endast h&#195;&#164;mta om med cache
 170=V&#195;&#164;lj databas
 171=profil finns inte:+
 172=Fel: kan inte skapa kartor katalog:
@@ -452,6 +455,8 @@
 1206=Calc
 1207=Din profil har sparats. Vill du spara?
 1208=ratings from GCVote
+1209 = l&#195;&#164;nk till OC - Cache
+1210 = loggar till OC
 1300=senaste inst&#195;&#164;llningen
 1301=V&#195;&#164;lj profil:
 1400=Zone
@@ -786,7 +791,12 @@
 2678=Br&#195;&#164;nsle i n&#195;&#164;rheten
 2679=ingen mat i n&#195;&#164;rheten
 2680=Food i n&#195;&#164;rheten
-2681=Chirp (Garmin)
+2681 = RFID,CHIRP / tr&#195;&#165;dl&#195;&#182;s utrustning &#195;&#164;r inte n&#195;&#182;dv&#195;&#164;ndig
+2682 = RFID,CHIRP / tr&#195;&#165;dl&#195;&#182;s utrustning
+2683 = Ingen akut
+2684 = F&#195;&#182;rsta hj&#195;&#164;lpen i n&#195;&#164;rheten
+2685 = inte sponsras
+2686 = sponsrade
 3000=St&#195;&#164;ng
 4000=Loaded cachar:+
 4001=GPX filer fr&#195;&#165;n opencaching inte inneh&#195;&#165;ller n&#195;&#165;gon information av bilder, kan de inte laoded. B&#195;&#164;st du cachar fr&#195;&#165;n opencaching genom menyn / Application / Import / Download fr&#195;&#165;n Opencaching

Modified: branches/r1.2/res_noewe/legende.html
===================================================================
--- branches/r1.2/res_noewe/legende.html	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/legende.html	2011-08-01 18:08:06 UTC (rev 3048)
@@ -19,4 +19,5 @@
 
 &lt;b&gt;&lt;i&gt;Other Symbols&lt;/i&gt;&lt;/b&gt;&lt;br&gt;
 &lt;img src='bug.gif'&gt;TravelBug&lt;br&gt;
-&lt;img src='dnf.gif'&gt;DNF-Indicator (as You can see more colours, the more DNF's are logged)
+&lt;img src='dnf.gif'&gt;DNF-Indicator (as You can see more colours, the more DNF's are logged)&lt;br&gt;
+&lt;img src='guiError.png'&gt;Data record incomplete&lt;br&gt;

Modified: branches/r1.2/res_noewe/legende_de.html
===================================================================
--- branches/r1.2/res_noewe/legende_de.html	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/legende_de.html	2011-08-01 18:08:06 UTC (rev 3048)
@@ -19,4 +19,5 @@
 
 &lt;b&gt;&lt;i&gt;Sonstige Symbole&lt;/i&gt;&lt;/b&gt;&lt;br&gt;
 &lt;img src='bug.gif'&gt;TravelBug&lt;br&gt;
-&lt;img src='dnf.gif'&gt;DNF-Indikator (je mehr Farben zu sehen, desto mehr DNF's)
+&lt;img src='dnf.gif'&gt;DNF-Indikator (je mehr Farben zu sehen, desto mehr DNF's)&lt;br&gt;
+&lt;img src='guiError.png'&gt;Datensatz unvollst&#195;&#164;ndig&lt;br&gt;

Modified: branches/r1.2/res_noewe/spider.def
===================================================================
--- branches/r1.2/res_noewe/spider.def	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/spider.def	2011-08-01 18:08:06 UTC (rev 3048)
@@ -53,7 +53,8 @@
 # * When entering spaces into a string ensure to escape them or write them as \\u0020
 # * Be sure that you have no hidden spaces at the end of a line or the patterns will not match!
 #------------------------------------------------------------
-loginPage          = <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
+#loginPage          = <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
+loginPage          = <A HREF="https://www.geocaching.com/login/default.aspx">https://www.geocaching.com/login/default.aspx</A>
 loginSuccess       = You\ are\ logged\ in\ as
 nextPage           = /login/default.aspx
 waypoint           = <A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>
@@ -67,9 +68,9 @@
 maxDistance        = &amp;dist=
 nextListPage       = /seek/nearest.aspx
 # Regex to search for cachenames
-listBlockRex       = &lt;table id=&quot;ctl00_ContentBody_dlResults&quot;((?s).*?)&lt;/table&gt;
-lineRex            = &lt;tr\ bgcolor='#.{6}'\\s*class=&quot;Data\ BorderTop&quot;&gt;((?s).*?)&lt;/tr&gt;
-logDateRex         = &lt;td valign=&quot;top&quot;&gt;\\s*(.*?)&lt;br\ /&gt;
+listBlockRex       = &lt;table\ class=&quot;SearchResultsTable\ Table&quot;&gt;((?s).*?)&lt;/table&gt;
+lineRex            = Data\ BorderTop&quot;&gt;((?s).*?)&lt;/tr&gt;
+logDateRex         = &lt;/span&gt;\\s+&lt;/td&gt;\\s+&lt;td\ valign=&quot;top&quot;\ width=&quot;70&quot;&gt;\\s+&lt;span\ class=&quot;small&quot;&gt;\\s+(.*?)&lt;br\ /&gt;
 availableRex       = class=&quot;lnk\ \ Strike&quot;&gt;
 archivedRex        = class=&quot;lnk\ OldWarning\ Strike\ Strike&quot;&gt;
 PMRex              = small_profile.gif
@@ -78,8 +79,8 @@
 distRex            = (.*?)(?:km|mi|ft)
 DTSRex             = v=(.*?)&quot;
 DTSCodeKey         = hbM9fjmrxy7z42LFD58BkKgPGdHscvCqNnw3ptO6lJ
-waypointRex        = \\(GC(.*?)\\)&lt;br\ /&gt;
-TypeRex            = www.geocaching.com/images/wpttypes/sm/(.*?)\\.gif
+waypointRex        = \\|\\s+GC(.*?)\\s+
+TypeRex            = www.geocaching.com/images/wpttypes/(.*?)\\.gif
 found              = class=&quot;Success&quot;
 own                = /WptTypes/name_tag.gif
 TBRex              = /wpttypes/([0-9]+).gif&quot; alt=&quot;(.*?)&quot;
@@ -109,13 +110,12 @@
 cacheArchived      = class=&quot;OldWarning&quot;&gt;&lt;li&gt;This\ cache\ has\ been\ archived
 premiumCachepage   = class=&quot;Warning&quot;&gt;listing\ visible\ to\ Premium
 latLonRex          = tBody_LatLon&quot;\ style=&quot;font-weight:bold;&quot;&gt;((?s).*?)&lt;/span&gt;
-#latLonRex          = tBody_LatLon&quot;&gt;&lt;b&gt;((?s).*?)&lt;/b&gt;&lt;/span&gt;
 shortDescRex       = tBody_ShortDescription&quot;&gt;((?s).*?)&lt;/span&gt;
-longDescRex        = tBody_LongDescription&quot;&gt;((?s).*?)&lt;td\ valign=&quot;top&quot;\ width=&quot;10%&quot;&gt;\\s*&nbsp;\\s*&lt;/td
+longDescRex        = tBody_LongDescription&quot;&gt;((?s).*?)&lt;strong&gt;\\s+Additional\ Hints&lt;/strong&gt;
 cacheNameRex       = tBody_CacheName&quot;&gt;((?s).*?)&lt;/span&gt;
 cacheOwnerRex      = &amp;wid(?:(?s).*?)&gt;((?s).*?)&lt;
 dateHiddenRex      = (?:Hidden|Event\ Date)\\s*:\\s*((?s).*?)&lt;
-hintsRex           = &lt;div id=&quot;div_hint&quot; class=&quot;HalfLeft&quot;&gt;\\s*((?s).*?)\\s*&lt;/div&gt;
+hintsRex           = &lt;div\ id=&quot;div_hint&quot;\ class=&quot;span-8\ WrapFix&quot;&gt;\\s*((?s).*?)\\s*&lt;/div&gt;
 sizeRex            = alt=&quot;Size:\ ((?s).*?)&quot;
 difficultyRex      = difficulty\ of\ (.*?),
 terrainRex         = terrain\ of\ (.*?)\\.\\ 
@@ -126,7 +126,7 @@
 #Section2a: Logs
 #--------------------------------------
 # blockRex extrahiert zun&#228;chst aus der gesamten Seite den Logbereich
-blockRex           = &lt;table class=&quot;LogsTable Table&quot;&gt;((?s).*?)&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
+blockRex           = &lt;table class=&quot;LogsTable&quot;&gt;((?s).*?)&lt;/table&gt;\\s+&lt;p&gt;
 # singleLogEx extrahiert in einer Schleife alle Logs aus dem Logbereich
 singleLogExStart   = &gt;&lt;strong&gt;&lt;img src=
 singleLogExEnd     = &lt;small&gt;&lt;a\ href=&quot;
@@ -153,16 +153,17 @@
 #Section2b: Bugs
 #--------------------------------------
 # blockEx extrahiert zun&#228;chst den Bugbereich aus der gesamten Seite
-blockExStart       = &lt;span\ id=&quot;ctl00_ContentBody_uxTravelBugList_uxInventoryLabel&quot;&gt;Inventory&lt;/span&gt;
-blockExEnd         = &lt;p\ class=&quot;NoSpacing&quot;&gt;
+blockExStart       = ctl00_ContentBody_uxTravelBugList_uxInventoryLabel
+#blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsLinks
+blockExEnd         = ctl00_ContentBody_uxTravelBugList_uxTrackableItemsHistory
 # bugEx extrahiert die Namen der einzelnen Bugs aus dem Bugbereich
 bugExStart         = &lt;a\ href=&quot;
 bugExEnd           = &lt;/a&gt;
 bugLinkEnd         = &quot;\ class=&quot;lnk&quot;&gt;
 bugNameExStart     = &lt;span&gt;
 bugNameExEnd       = &lt;/span&gt;
-bugDetailsStart    = &quot;og:description&quot;\ content=&quot;
-bugDetailsEnd      = &quot;\ property=&quot;og:desc
+bugDetailsStart    = &lt;meta\ name=&quot;og:description&quot;\ content=&quot;
+bugDetailsEnd      = &quot;\ property=&quot;og:description&quot;
 getBugByName       = <A HREF="http://www.geocaching.com/track/search.aspx?k=">http://www.geocaching.com/track/search.aspx?k=</A>
 getBugByGuid       = <A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>
 getBugById         = <A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>
@@ -208,7 +209,7 @@
 #--------------------------------------
 #Section2e: Attributes
 #--------------------------------------
-attBlockExStart = &lt;div\ class=&quot;CacheDetailNavigationWidget\ Spacing&quot;&gt;
+attBlockExStart = &lt;div\ class=&quot;CacheDetailNavigationWidget
 attBlockExEnd  = What\ are\ Attributes?&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
 attExStart = /images/attributes/
 attExEnd = &quot;\ alt=&quot;

Modified: branches/r1.2/res_noewe/symbols/readme.htm
===================================================================
--- branches/r1.2/res_noewe/symbols/readme.htm	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/symbols/readme.htm	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,18 +13,18 @@
 &lt;!--[if gte mso 9]&gt;&lt;xml&gt;
  &lt;o:DocumentProperties&gt;
   &lt;o:Author&gt;.&lt;/o:Author&gt;
-  &lt;o:LastAuthor&gt;.&lt;/o:LastAuthor&gt;
-  &lt;o:Revision&gt;5&lt;/o:Revision&gt;
+  &lt;o:LastAuthor&gt;Franz&lt;/o:LastAuthor&gt;
+  &lt;o:Revision&gt;8&lt;/o:Revision&gt;
   &lt;o:Created&gt;2009-10-23T21:05:00Z&lt;/o:Created&gt;
-  &lt;o:LastSaved&gt;2010-06-08T16:27:00Z&lt;/o:LastSaved&gt;
+  &lt;o:LastSaved&gt;2011-05-20T16:42:00Z&lt;/o:LastSaved&gt;
   &lt;o:Pages&gt;1&lt;/o:Pages&gt;
-  &lt;o:Words&gt;238&lt;/o:Words&gt;
-  &lt;o:Characters&gt;1506&lt;/o:Characters&gt;
+  &lt;o:Words&gt;390&lt;/o:Words&gt;
+  &lt;o:Characters&gt;2458&lt;/o:Characters&gt;
   &lt;o:Company&gt;CF Computer&lt;/o:Company&gt;
-  &lt;o:Lines&gt;12&lt;/o:Lines&gt;
-  &lt;o:Paragraphs&gt;3&lt;/o:Paragraphs&gt;
-  &lt;o:CharactersWithSpaces&gt;1741&lt;/o:CharactersWithSpaces&gt;
-  &lt;o:Version&gt;10.6858&lt;/o:Version&gt;
+  &lt;o:Lines&gt;20&lt;/o:Lines&gt;
+  &lt;o:Paragraphs&gt;5&lt;/o:Paragraphs&gt;
+  &lt;o:CharactersWithSpaces&gt;2843&lt;/o:CharactersWithSpaces&gt;
+  &lt;o:Version&gt;10.6870&lt;/o:Version&gt;
  &lt;/o:DocumentProperties&gt;
 &lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
  &lt;w:WordDocument&gt;
@@ -84,7 +84,7 @@
 	font-family:&quot;Times New Roman&quot;;}
 &lt;/style&gt;
 &lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
- &lt;o:shapedefaults v:ext=&quot;edit&quot; spidmax=&quot;5122&quot;/&gt;
+ &lt;o:shapedefaults v:ext=&quot;edit&quot; spidmax=&quot;7170&quot;/&gt;
 &lt;/xml&gt;&lt;![endif]--&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;
  &lt;o:shapelayout v:ext=&quot;edit&quot;&gt;
   &lt;o:idmap v:ext=&quot;edit&quot; data=&quot;1&quot;/&gt;
@@ -97,7 +97,7 @@
 
 &lt;p class=MsoNormal&gt;In diesem Verzeichnis vorhandene .&lt;span class=SpellE&gt;png-Dateien&lt;/span&gt;
 werden als alternative Symbole in den Cachewolf geladen, falls in den
-Einstellungen/Tab mehr eingeschaltet.&lt;/p&gt;
+Einstellungen/Tab Mehr/nutze eigene Symbole eingeschaltet.&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;Dabei sollte es sich um &lt;span class=SpellE&gt;PNGs&lt;/span&gt; der
 Gr&#246;&#223;e 16x16 handeln oder kleiner.&lt;/p&gt;
@@ -106,9 +106,38 @@
 Symbole angezeigt, falls sie existieren und der Dateiname auf &lt;span
 class=SpellE&gt;size&lt;/span&gt; endet.&lt;/p&gt;
 
-&lt;p class=MsoNormal&gt;Es m&#252;ssen nur die Dateien erstellt werden, die ersetzt
-werden sollen.&lt;/p&gt;
+&lt;p class=MsoNormal&gt;F&#252;r folgende &lt;span class=SpellE&gt;Stati&lt;/span&gt; kann ein extra
+Symbol auf der Kartenansicht &#252;berlagert werden: &lt;/p&gt;
 
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;&lt;span class=GramE&gt;found.png&lt;/span&gt;&lt;/span&gt;&lt;span
+class=GramE&gt; :&lt;/span&gt; habe den Cache schon gefunden.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;dnf.png&lt;/span&gt;: habe den Cache nicht
+gefunden:&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;&lt;span class=GramE&gt;archived.png&lt;/span&gt;&lt;/span&gt;&lt;span
+class=GramE&gt; :&lt;/span&gt; der Cache ist archiviert.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;disabled.png&lt;/span&gt;: Der Cache ist
+vor&#252;bergehend nicht &lt;span class=SpellE&gt;suchbar&lt;/span&gt;.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;owned.png&lt;/span&gt;: Den Cache habe ich
+selber platziert.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;solved.png&lt;/span&gt;: Du hast dem Cache den
+Status &#132;gel&#246;st&#147; gegeben, d.h. an den Koordinaten ist der Cache zu finden.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;span class=SpellE&gt;bonus.png&lt;/span&gt;: Das ist ein Bonuscache.
+Die Koordinaten ergeben sich durch Suchen eines anderen Cache.&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;Das &#252;berlagernde Symbol &lt;span class=SpellE&gt;mu&#223;&lt;/span&gt;
+kleiner oder gleich gro&#223; sein wie das Cachesymbol.&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/p&gt;
+
+&lt;p class=MsoNormal&gt;Es m&#252;ssen nur die Dateien erstellt werden, die ersetzt werden
+sollen.&lt;/p&gt;
+
 &lt;p class=MsoNormal&gt;Ist keine entsprechende Datei vorhanden, wird das
 Cachewolf-interne Symbol beibehalten.&lt;/p&gt;
 
@@ -118,19 +147,35 @@
 &lt;p class=MsoNormal&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;.&lt;span
-class=SpellE&gt;png&lt;/span&gt;-files in this directory will be loaded as customized
-symbols into &lt;span class=SpellE&gt;Cachewolf&lt;/span&gt; if checked in preferences tab
-more.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+class=SpellE&gt;png&lt;/span&gt;-files in this directory will be loaded as customized symbols
+into &lt;span class=SpellE&gt;Cachewolf&lt;/span&gt; if checked in preferences tab more.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;They're
 supposed to be 16x16 &lt;span class=SpellE&gt;PNGs&lt;/span&gt; or less.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;On the map larger
-symbols are shown, if they exist and the filename ends on size.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;On the map
+larger symbols are shown, if they exist and the filename ends on size.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;Incorrectly
-named files will be ignored.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;For&nbsp;the
+following&nbsp;states, an&nbsp;extra&nbsp;symbol is&nbsp;superimposed&nbsp;on&nbsp;the&nbsp;map&lt;span
+class=GramE&gt;:&lt;/span&gt;&lt;br&gt;
+&lt;span class=SpellE&gt;found.png&lt;/span&gt;:&nbsp;the&nbsp;cache&nbsp;had&nbsp;been&nbsp;found.&lt;br&gt;
+&lt;span class=SpellE&gt;dnf.png&lt;/span&gt;:&nbsp;the&nbsp;cache&nbsp;was&nbsp;not found&lt;span
+class=GramE&gt;:&lt;/span&gt;&lt;br&gt;
+&lt;span class=SpellE&gt;archived.png&lt;/span&gt;:&nbsp;the cache&nbsp;is&nbsp;archived.&lt;br&gt;
+&lt;span class=SpellE&gt;disabled.png&lt;/span&gt;: The&nbsp;cache&nbsp;is&nbsp;temporarily
+not searchable.&lt;br&gt;
+&lt;span class=SpellE&gt;owned.png&lt;/span&gt;:&nbsp;the&nbsp;cache&nbsp;I&nbsp;have myself
+placed.&lt;br&gt;
+&lt;span class=SpellE&gt;solved.png&lt;/span&gt;: You&nbsp;have&nbsp;the&nbsp;cache&nbsp;status
+&quot;solved&quot;&nbsp;if&nbsp;i.e.&nbsp;at coordinates cache can be&nbsp;found.&lt;br&gt;
+&lt;span class=SpellE&gt;bonus.png&lt;/span&gt;: This is&nbsp;a&nbsp;bonus.&nbsp;The Coordinates&nbsp;result&nbsp;from&nbsp;searching
+another&nbsp;cache.&lt;br&gt;
+The&nbsp;superimposed&nbsp;image&nbsp;must be smaller&nbsp;or be&nbsp;the same
+size&nbsp;as&nbsp;the&nbsp;icon&nbsp;cache.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
+&lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+
 &lt;p class=MsoNormal&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;You only
 have to create images for those symbols you want customized.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
@@ -154,12 +199,11 @@
 &lt;p class=MsoNormal&gt;&lt;span class=GramE&gt;&lt;span lang=EN-GB style='mso-ansi-language:
 EN-GB'&gt;old&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt; Nr&lt;span
 style='mso-tab-count:1'&gt;&#160; &lt;/span&gt;&lt;span class=SpellE&gt;newNr&lt;/span&gt;&lt;span
-style='mso-tab-count:1'&gt; &lt;/span&gt;&lt;span style='mso-tab-count:1'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;meaning&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;meaning&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span class=GramE&gt;&lt;span lang=EN-GB style='mso-ansi-language:
 EN-GB'&gt;0.png&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;span
-style='mso-tab-count:1'&gt;&#160;&#160; &lt;/span&gt;0.png&lt;span style='mso-tab-count:1'&gt;&#160;&#160; &lt;/span&gt;&lt;span
-style='mso-tab-count:1'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Custom&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+style='mso-tab-count:1'&gt;&#160;&#160; &lt;/span&gt;0.png&lt;span style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Custom&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal&gt;&lt;span class=GramE&gt;&lt;span lang=EN-GB style='mso-ansi-language:
 EN-GB'&gt;1.png&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;span

Added: branches/r1.2/res_noewe/templates/Parking.tpl
===================================================================
--- branches/r1.2/res_noewe/templates/Parking.tpl	                        (rev 0)
+++ branches/r1.2/res_noewe/templates/Parking.tpl	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,14 @@
+&#239;&#187;&#191;&lt;tmpl_par name=&quot;decsep&quot; value=&quot;.&quot;&gt;
+&lt;tmpl_par name=&quot;Out&quot; value=&quot;*.loc&quot;&gt;
+&lt;tmpl_par name=&quot;charset&quot; value=&quot;UTF8&quot;&gt;
+&lt;tmpl_par name=&quot;newline&quot; value=&quot;CRLF&quot;&gt;
+&lt;tmpl_par name=&quot;takeOnlyWp&quot; value=&quot;parking&quot;&gt;
+&lt;?xml version=&quot;1.0&quot;?&gt;&lt;loc version=&quot;1.0&quot; src=&quot;EasyGPS&quot;&gt;&lt;br/&gt;
+&lt;tmpl_loop cache_index&gt;
+&lt;waypoint&gt;&lt;br/&gt;
+   &lt;name id=&quot;&lt;tmpl_var WAYPOINT&gt;&quot;&gt;&lt;![CDATA[&lt;tmpl_var NAME&gt;]]&gt;&lt;/name&gt;&lt;br/&gt;
+   &lt;coord lat=&quot;&lt;tmpl_var LAT&gt;&quot; lon=&quot;&lt;tmpl_var LON&gt;&quot;/&gt;&lt;br/&gt;
+   &lt;type&gt;&lt;tmpl_var GMTYPE&gt;&lt;/type&gt;&lt;br/&gt;
+&lt;/waypoint&gt;&lt;br/&gt;
+&lt;/tmpl_loop&gt;
+&lt;/loc&gt;&lt;br/&gt;

Modified: branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm
===================================================================
--- branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/templates/Short documentation for the export via templates.htm	2011-08-01 18:08:06 UTC (rev 3048)
@@ -43,7 +43,7 @@
 	mso-font-charset:0;
 	mso-generic-font-family:swiss;
 	mso-font-pitch:variable;
-	mso-font-signature:-520078593 -1073717157 41 0 66047 0;}
+	mso-font-signature:-520077569 -1073717157 41 0 66047 0;}
  /* Style Definitions */
  p.MsoNormal, li.MsoNormal, div.MsoNormal
 	{mso-style-parent:&quot;&quot;;
@@ -77,9 +77,6 @@
 span.SpellE
 	{mso-style-name:&quot;&quot;;
 	mso-spl-e:yes;}
-span.GramE
-	{mso-style-name:&quot;&quot;;
-	mso-gram-e:yes;}
 @page Section1
 	{size:595.3pt 841.9pt;
 	margin:70.85pt 70.85pt 2.0cm 70.85pt;
@@ -165,80 +162,71 @@
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;#--
-&lt;span class=SpellE&gt;TomTom&lt;/span&gt; ASC or POI --&gt;&lt;span style='mso-tab-count:
-5'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Anything between
-&quot;&lt;#--&quot; and &quot;--&gt;&quot; is handled as a comment&lt;/span&gt;&lt;span
+TomTom ASC or POI --&gt;&lt;span style='mso-tab-count:5'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Anything
+between &quot;&lt;#--&quot; and &quot;--&gt;&quot; is handled as a comment&lt;/span&gt;&lt;span
 lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;Configuration
 section &lt;/span&gt;&lt;/u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span
-class=SpellE&gt;NameOfParameter&lt;/span&gt;&quot; value=&quot;&lt;span class=SpellE&gt;ValueOfParameter&lt;/span&gt;&quot;&gt;&lt;/span&gt;&lt;span
-lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+mso-ansi-language:EN-GB'&gt;&lt;tmpl_par name=&quot;NameOfParameter&quot;
+value=&quot;ValueOfParameter&quot;&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
+EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;&lt;span
-class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;charset&lt;/span&gt;&quot;
-value=&quot;ASCII&quot;&gt;&lt;span style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
-class=SpellE&gt;Charsets&lt;/span&gt;: &nbsp;values ASCII or UTF8 or UNICODE&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;badchars&lt;/span&gt;&quot;
-value=&quot;,&quot;&gt;&lt;span style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
-class=SpellE&gt;&lt;span class=GramE&gt;BadChars&lt;/span&gt;&lt;/span&gt;&lt;span class=GramE&gt; :&lt;/span&gt;
-These chars are removed from the &lt;span class=SpellE&gt;cachename&lt;/span&gt;, hints and
-notes. &lt;br&gt;
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;tmpl_par
+name=&quot;charset&quot; value=&quot;ASCII&quot;&gt;&lt;span style='mso-tab-count:
+3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Charsets: &nbsp;values ASCII or UTF8
+or UNICODE&lt;br&gt;
+&lt;tmpl_par name=&quot;badchars&quot; value=&quot;,&quot;&gt;&lt;span
+style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;BadChars :
+These chars are removed from the cachename, hints and notes. &lt;br&gt;
 &lt;span style='mso-spacerun:yes'&gt;&#160;&lt;/span&gt;&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;for
-example the value=&quot;,&quot; if ',' is used as a separator. &lt;span
-class=GramE&gt;Regular expressions possible.&lt;/span&gt;&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;newline&lt;/span&gt;&quot;
-value=&quot;CRLF&quot;&gt;&lt;span style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
-class=SpellE&gt;&lt;span class=GramE&gt;Newline&lt;/span&gt;&lt;/span&gt;&lt;span class=GramE&gt; :&lt;/span&gt;
-values are CR, LF or CRLF . These defines, what should be used for replacing&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;decsep&lt;/span&gt;&quot;
-value=&quot;,&quot;&gt;&lt;span style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Decimal
+example the value=&quot;,&quot; if ',' is used as a separator. Regular
+expressions possible.&lt;br&gt;
+&lt;tmpl_par name=&quot;newline&quot; value=&quot;CRLF&quot;&gt;&lt;span
+style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Newline : values
+are CR, LF or CRLF . These defines, what should be used for replacing&lt;br&gt;
+&lt;tmpl_par name=&quot;decsep&quot; value=&quot;,&quot;&gt;&lt;span
+style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Decimal
 separator : Defines, which decimal separator is used , values &quot;.&quot; or ','&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;ShortNameLength&lt;/span&gt;&quot;
-value=&quot;30&quot;&gt;&lt;span style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Number
-of characters for Variable SHORTNAME &lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;WaypointLength&lt;/span&gt;&quot;
-value=&quot;3&quot;&gt;&lt;span style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Number
-of characters for Variable SHORTWAYPOINT&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;Out&quot; value=&quot;.&lt;span
-class=SpellE&gt;gpx&lt;/span&gt;&quot;&gt;&lt;span style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Output
+&lt;tmpl_par name=&quot;ShortNameLength&quot; value=&quot;30&quot;&gt;&lt;span
+style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Number of characters for
+Variable SHORTNAME &lt;br&gt;
+&lt;tmpl_par name=&quot;WaypointLength&quot; value=&quot;3&quot;&gt;&lt;span
+style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Number of characters
+for Variable SHORTWAYPOINT&lt;br&gt;
+&lt;tmpl_par name=&quot;Out&quot; value=&quot;.gpx&quot;&gt;&lt;span
+style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Output
 Filename or Extension&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;NrLogs&lt;/span&gt;&quot;
-value=&quot;-1&quot;&gt;&lt;span style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
-class=SpellE&gt;Anzahl&lt;/span&gt; logs (-1 = alle)&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;singleFile&lt;/span&gt;&quot;
-value=&quot;yes&quot;&gt;&lt;span style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;one
-&lt;span class=SpellE&gt;outputfile&lt;/span&gt; value=&#148;yes&#148; or one file per cache
-value=&#148;no&#148; (use a dummy / not existing name for Out par)&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;formatModifier&lt;/span&gt;&quot;
-value=&quot;0&quot;&gt;&lt;span style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;0
-is xml as &lt;span class=SpellE&gt;gpx&lt;/span&gt; generation before, 1 is html for local
-use 2 is html for export use&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;takeOnlyWp&lt;/span&gt;&quot;
-value=&quot;all&quot;&gt;&lt;span style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;process
-only this &lt;span class=SpellE&gt;Cachetypegroups&lt;/span&gt; value is either &#147;main&#148; or &#147;&lt;span
-class=SpellE&gt;addi&lt;/span&gt;&#148; else both (here all = default ) is assumed&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;CopyCacheImages&lt;/span&gt;&quot;
-value=&quot;yes&quot;&gt;&lt;span style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
-class=SpellE&gt;CacheImages&lt;/span&gt; are copied to the output directory (copy &lt;span
-class=SpellE&gt;attribs&lt;/span&gt; and icons manually, they are fix)&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;inputEingabe&lt;/span&gt;&quot;
-value=&quot;default&quot;&gt;&lt;span style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;calls
-input with a &#147;default&#148; value and makes a &lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-with the name &lt;span class=SpellE&gt;Eingabe&lt;/span&gt; (&lt;span class=SpellE&gt;Eingabe&lt;/span&gt;
-is placeholder) (!&lt;span class=SpellE&gt;dont&lt;/span&gt; use umlauts in defaults)&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;constKonstante&lt;/span&gt;&quot;
-value=&quot;value&quot;&gt;&lt;span style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;sets
-a &lt;span class=SpellE&gt;tmpl_var&lt;/span&gt; with the name &lt;span class=SpellE&gt;Konstante&lt;/span&gt;
-(&lt;span class=SpellE&gt;Konstante&lt;/span&gt; is placeholder) (!&lt;span class=SpellE&gt;dont&lt;/span&gt;
-use umlauts in value)&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;sortedBy&lt;/span&gt;&quot;
-value=&quot;-1&quot;&gt;&lt;span style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;sets
-a &lt;span class=SpellE&gt;tmpl_var&lt;/span&gt; with the name &lt;span class=SpellE&gt;sortedBy&lt;/span&gt;:
-values are 1..19. (4=Waypoint,5=Name,9=Status,10=Distance&#133; see myComparer.java)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;tmpl_par name=&quot;NrLogs&quot; value=&quot;-1&quot;&gt;&lt;span
+style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;Anzahl
+logs (-1 = alle)&lt;br&gt;
+&lt;tmpl_par name=&quot;singleFile&quot; value=&quot;yes&quot;&gt;&lt;span
+style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;one outputfile
+value=&#148;yes&#148; or one file per cache value=&#148;no&#148; (use a dummy / not existing name
+for Out par)&lt;br&gt;
+&lt;tmpl_par name=&quot;formatModifier&quot; value=&quot;0&quot;&gt;&lt;span
+style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;0 is xml as gpx
+generation before, 1 is html for local use 2 is html for export use&lt;br&gt;
+&lt;tmpl_par name=&quot;takeOnlyWp&quot; value=&quot;all&quot;&gt;&lt;span
+style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;process only this
+Cachetypegroups value is either &#147;main&#148; or &#147;addi&#148; or &#147;parking&#148; else all (here
+all = default ) is assumed&lt;br&gt;
+&lt;tmpl_par name=&quot;CopyCacheImages&quot; value=&quot;yes&quot;&gt;&lt;span
+style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;CacheImages are copied to the
+output directory (copy attribs and icons manually, they are fix)&lt;br&gt;
+&lt;tmpl_par name=&quot;inputEingabe&quot; value=&quot;default&quot;&gt;&lt;span
+style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;calls input with a
+&#147;default&#148; value and makes a tmpl_var with the name Eingabe (Eingabe is
+placeholder) (!dont use umlauts in defaults)&lt;br&gt;
+&lt;tmpl_par name=&quot;constKonstante&quot; value=&quot;value&quot;&gt;&lt;span
+style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;sets a tmpl_var with the
+name Konstante (Konstante is placeholder) (!dont use umlauts in value)&lt;br&gt;
+&lt;tmpl_par name=&quot;sortedBy&quot; value=&quot;-1&quot;&gt;&lt;span
+style='mso-tab-count:3'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;sets a
+tmpl_var with the name sortedBy: values are 1..19.
+(4=Waypoint,5=Name,9=Status,10=Distance&#133; see myComparer.java)&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;Output
@@ -247,23 +235,20 @@
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;Anything
 (except comments and variables) is written to the output file.&lt;br&gt;
-The &lt;span class=SpellE&gt;cachedata&lt;/span&gt; &lt;span class=SpellE&gt;&lt;span class=GramE&gt;ist&lt;/span&gt;&lt;/span&gt;
-placed between &lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt; &lt;span class=SpellE&gt;cache_index&lt;/span&gt;&gt;
-and &lt;/&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt;&gt;. &lt;br&gt;
-Variables defined like this: &lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=LON&gt;. &lt;br&gt;
-At the end of the line &lt;&lt;span class=SpellE&gt;br&lt;/span&gt; /&gt; has to be placed,
-this is replaced by CR.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+The cachedata ist placed between &lt;tmpl_loop cache_index&gt; and
+&lt;/tmpl_loop&gt;. &lt;br&gt;
+Variables defined like this: &lt;tmpl_var name=LON&gt;. &lt;br&gt;
+At the end of the line &lt;br /&gt; has to be placed, this is replaced by CR.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;Variables
-&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt; &lt;span class=SpellE&gt;NameOfVariable&lt;/span&gt;&gt;&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span
-lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
+&lt;tmpl_var NameOfVariable&gt;&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span lang=EN-GB style='mso-ansi-language:
+EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;PROGDIR&lt;span
 style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;FileBase.getProgramDirectory&lt;/span&gt;()&lt;br&gt;
+FileBase.getProgramDirectory()&lt;br&gt;
 PROFILDIR&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;span
 style='mso-tab-count:6'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
 style='mso-tab-count:2'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;: &lt;br&gt;
@@ -271,13 +256,12 @@
 TYPE&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 &lt;type&gt; Type of cache, e.g. Regular, Multi&lt;br&gt;
 TYPENO&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;type&gt; as number string (see &lt;span class=SpellE&gt;CacheType.java&lt;/span&gt; &lt;span
-class=SpellE&gt;e.g&lt;/span&gt; : 0=Custom , 2=&lt;span class=SpellE&gt;Tradi&lt;/span&gt;
+&lt;type&gt; as number string (see CacheType.java e.g : 0=Custom , 2=Tradi
 ,50=Parking 104=Earth)&lt;br&gt;
 SYM&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 &lt;sym&gt;&lt;br&gt;
 GSTYPE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;&lt;span class=SpellE&gt;groundspeak:type&lt;/span&gt;&gt;&lt;br&gt;
+&lt;groundspeak:type&gt;&lt;br&gt;
 SHORTTYPE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 First Letter of &lt;type&gt; ???&lt;br&gt;
 SIZE&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
@@ -286,57 +270,49 @@
 First letter of size&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'&gt;MAINWP&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&#147;&#147; if is &lt;span class=SpellE&gt;Mainwaypoint&lt;/span&gt;, &lt;span class=SpellE&gt;Mainwaypoint&lt;/span&gt;
-if is &lt;span class=SpellE&gt;Addi&lt;/span&gt; Waypoint&lt;br&gt;
+&#147;&#147; if is Mainwaypoint, Mainwaypoint if is Addi Waypoint&lt;br&gt;
 MAINWPNAME&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&#147;&#147; if is &lt;span class=SpellE&gt;Mainwaypoint&lt;/span&gt;, &lt;span class=SpellE&gt;Mainwaypoint&lt;/span&gt;
-name if is &lt;span class=SpellE&gt;Addi&lt;/span&gt; Waypoint&lt;br&gt;
+&#147;&#147; if is Mainwaypoint, Mainwaypoint name if is Addi Waypoint&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'&gt;WAYPOINT&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 &lt;name&gt; GCXXXX, OCXXXX&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'&gt;SHORTWAYPOINT&lt;span style='mso-tab-count:7'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;/span&gt;&lt;span class=SpellE&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:
-Arial;mso-ansi-language:EN-GB'&gt;ShortNameLength&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB
-style='font-size:10.0pt;font-family:Helvetica;mso-ansi-language:EN-GB'&gt; &lt;span
-class=SpellE&gt;Zeichen&lt;/span&gt; des Waypoints (&lt;span class=SpellE&gt;f&#252;r&lt;/span&gt; &lt;span
-class=SpellE&gt;Benutzer&lt;/span&gt; alter &lt;span class=SpellE&gt;Ger&#228;te&lt;/span&gt; &lt;span
-class=SpellE&gt;mit&lt;/span&gt; &lt;span class=SpellE&gt;nur&lt;/span&gt; 6 &lt;span class=SpellE&gt;Waypointzeichen&lt;/span&gt;,
-&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
+EN-GB'&gt;ShortNameLength&lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
+font-family:Helvetica;mso-ansi-language:EN-GB'&gt; Zeichen des Waypoints (f&#252;r
+Benutzer alter Ger&#228;te mit nur 6 Waypointzeichen, &lt;br&gt;
+&lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'&gt;OWNER&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;Cacheowner&lt;/span&gt;&lt;br&gt;
+Cacheowner&lt;br&gt;
 DIFFICULTY&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'&gt;SHORTDIFFICULTY&lt;span style='mso-tab-count:7'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Difficulty mal 10 also 15 &lt;span class=SpellE&gt;statt&lt;/span&gt; 1.5&lt;br&gt;
+Difficulty mal 10 also 15 statt 1.5&lt;br&gt;
 SHDIFFICULTY&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Difficulty &lt;span class=SpellE&gt;abgerundet&lt;/span&gt; also 1 &lt;span class=SpellE&gt;statt&lt;/span&gt;
-1.5&lt;br&gt;
+Difficulty abgerundet also 1 statt 1.5&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'&gt;TERRAIN&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
 mso-ansi-language:EN-GB'&gt;SHORTTERRAIN&lt;span style='mso-tab-count:7'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 Terrain mal 10&lt;br&gt;
 SHTERRAIN&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Terrain &lt;span class=SpellE&gt;abgerundet&lt;/span&gt;&lt;br&gt;
+Terrain abgerundet&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:
 EN-GB'&gt;DISTANCE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Distance calculated in &lt;span class=SpellE&gt;cachelist&lt;/span&gt;&lt;br&gt;
+Distance calculated in cachelist&lt;br&gt;
 BEARING&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Bearing calculated in &lt;span class=SpellE&gt;cachelist&lt;/span&gt;&lt;br&gt;
+Bearing calculated in cachelist&lt;br&gt;
 LATLON&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 Coordinates in long format, e.g. N 50&#176; 31.234 E 008&#176; 45.267&lt;br&gt;
 LAT&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;&lt;span class=SpellE&gt;wpt&lt;/span&gt; lat=&#148;&lt;span class=SpellE&gt;xx.yyyy&lt;/span&gt;&#148;
-&#133;&#133;..&gt; Latitude in decimal format, e.g. 50.20147&lt;br&gt;
+&lt;wpt lat=&#148;xx.yyyy&#148; &#133;&#133;..&gt; Latitude in decimal format, e.g. 50.20147&lt;br&gt;
 LON&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;&lt;span class=SpellE&gt;wpt&lt;/span&gt; &#133;&#133; &lt;span class=SpellE&gt;lon&lt;/span&gt;=&#148;&lt;span
-class=SpellE&gt;xx.yyyy&lt;/span&gt;&#148; &gt; Longitude in decimal format, e.g. 008.58132&lt;br&gt;
+&lt;wpt &#133;&#133; lon=&#148;xx.yyyy&#148; &gt; Longitude in decimal format, e.g. 008.58132&lt;br&gt;
 STATUS&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;span
 style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;means found&lt;br&gt;
 GC_LOGTYPE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-the English Status texts (for &lt;span class=SpellE&gt;gpx&lt;/span&gt; &#150; export)&lt;br&gt;
+the English Status texts (for gpx &#150; export)&lt;br&gt;
 STATUS_DATE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 Get the date part of the status &lt;br&gt;
 STATUS_TIME&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
@@ -346,44 +322,30 @@
 CACHE_NAME&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 original Name of cache&lt;br&gt;
 NAME&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Name of cache (&lt;span class=SpellE&gt;badchars&lt;/span&gt; are removed, see below) (&lt;span
-class=SpellE&gt;neuerdings&lt;/span&gt; &lt;span class=SpellE&gt;bei&lt;/span&gt; ASCII &lt;span
-class=SpellE&gt;Simplifizierung&lt;/span&gt; von &lt;span class=SpellE&gt;Zeichen&lt;/span&gt;)&lt;br&gt;
+Name of cache (badchars are removed, see below) (neuerdings bei ASCII
+Simplifizierung von Zeichen)&lt;br&gt;
 SHORTNAME&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Helvetica;
-mso-ansi-language:EN-GB'&gt;Name &lt;span class=SpellE&gt;der&lt;/span&gt; &lt;span class=SpellE&gt;durch&lt;/span&gt;
-&lt;span class=SpellE&gt;Weglassen&lt;/span&gt; von &lt;span class=SpellE&gt;Vokalen&lt;/span&gt; von &lt;span
-class=SpellE&gt;hinten&lt;/span&gt; und &lt;span class=SpellE&gt;wenn&lt;/span&gt; &lt;span
-class=SpellE&gt;das&lt;/span&gt; &lt;span class=SpellE&gt;nicht&lt;/span&gt; &lt;span class=SpellE&gt;reicht&lt;/span&gt;
-&lt;span class=SpellE&gt;durch&lt;/span&gt; &lt;span class=SpellE&gt;Weglassen&lt;/span&gt; von&lt;span
-style='mso-spacerun:yes'&gt;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
+mso-ansi-language:EN-GB'&gt;Name der durch Weglassen von Vokalen von hinten und
+wenn das nicht reicht durch Weglassen von&lt;span style='mso-spacerun:yes'&gt;&#160;&#160;&#160;&#160;
+&lt;/span&gt;&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
 style='mso-tab-count:5'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;Kleinbuchstaben&lt;/span&gt; von &lt;span class=SpellE&gt;hinten&lt;/span&gt;
-auf &lt;span class=SpellE&gt;eine&lt;/span&gt; in den &lt;span class=SpellE&gt;Einstellungen&lt;/span&gt;
-&lt;span class=SpellE&gt;vorgegebene&lt;/span&gt; &lt;span class=SpellE&gt;L&#228;nge&lt;/span&gt; &lt;span
-class=SpellE&gt;gek&#252;rzt&lt;/span&gt; &lt;span class=SpellE&gt;wird&lt;/span&gt;. &lt;br&gt;
+Kleinbuchstaben von hinten auf eine in den Einstellungen vorgegebene L&#228;nge
+gek&#252;rzt wird. &lt;br&gt;
 &lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-(&lt;span class=SpellE&gt;Hintergrund&lt;/span&gt;: &lt;span class=SpellE&gt;das&lt;/span&gt; Notes -&lt;span
-class=SpellE&gt;Feld&lt;/span&gt; &lt;span class=SpellE&gt;der&lt;/span&gt; &lt;span class=SpellE&gt;meisten&lt;/span&gt;
-&lt;span class=SpellE&gt;Garmins&lt;/span&gt; &lt;span class=SpellE&gt;kann&lt;/span&gt; &lt;span
-class=SpellE&gt;nur&lt;/span&gt; 30 &lt;span class=SpellE&gt;Buchstaben&lt;/span&gt;)&lt;br&gt;
+(Hintergrund: das Notes -Feld der meisten Garmins kann nur 30 Buchstaben)&lt;br&gt;
 &lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;dann&lt;/span&gt; &lt;span class=SpellE&gt;kriegen&lt;/span&gt; &lt;span
-class=SpellE&gt;sie&lt;/span&gt; &lt;span class=SpellE&gt;noch&lt;/span&gt; &lt;span class=SpellE&gt;Infos&lt;/span&gt;
-&lt;span class=SpellE&gt;wie&lt;/span&gt; Difficulty etc. rein)&lt;br&gt;
+dann kriegen sie noch Infos wie Difficulty etc. rein)&lt;br&gt;
 CACHEID&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;br&gt;
 ARCHIVED&lt;span style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
 style='mso-tab-count:4'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;br&gt;
 AVAILABLE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 &lt;br&gt;
 TRAVELBUG&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Y or N &lt;span class=SpellE&gt;f&#252;r&lt;/span&gt; &lt;span class=SpellE&gt;Anwesenheit/Abwesenheit&lt;/span&gt;
-von &lt;span class=SpellE&gt;TBs&lt;/span&gt; &lt;span class=SpellE&gt;im&lt;/span&gt; Cache&nbsp;&lt;br&gt;
+Y or N f&#252;r Anwesenheit/Abwesenheit von TBs im Cache&nbsp;&lt;br&gt;
 GMTYPE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Type &lt;span class=SpellE&gt;aus&lt;/span&gt; &lt;span class=SpellE&gt;der&lt;/span&gt; &lt;span
-class=SpellE&gt;Garminmap.xml&lt;/span&gt;, also &lt;span class=SpellE&gt;z.B&lt;/span&gt;. Custom
-1, &lt;span class=SpellE&gt;zur&lt;/span&gt; &lt;span class=SpellE&gt;Verwendung&lt;/span&gt; &lt;span
-class=SpellE&gt;der&lt;/span&gt; &lt;span class=SpellE&gt;Benutzerdefinierten&lt;/span&gt; Icons&lt;br&gt;
+Type aus der Garminmap.xml, also z.B. Custom 1, zur Verwendung der
+Benutzerdefinierten Icons&lt;br&gt;
 NOW&lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
 mso-ansi-language:EN-GB'&gt;_DATE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 Get the date part of now&lt;br&gt;
@@ -393,47 +355,42 @@
 DESCRIPTION&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 Cache Description (possibly in HTML Format)&lt;br&gt;
 NOTES&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-User Notes&nbsp;&nbsp; (&lt;span class=SpellE&gt;badchars&lt;/span&gt; are removed, see
-below)&lt;br&gt;
+User Notes&nbsp;&nbsp; (badchars are removed, see below)&lt;br&gt;
 HINTS&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Encrypted hints&nbsp;&nbsp; (&lt;span class=SpellE&gt;badchars&lt;/span&gt; are removed,
-see below)&lt;br&gt;
+Encrypted hints&nbsp;&nbsp; (badchars are removed, see below)&lt;br&gt;
 DECRYPTEDHINTS&lt;span style='mso-tab-count:7'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Decrypted hints&nbsp;&nbsp;&nbsp; (&lt;span class=SpellE&gt;badchars&lt;/span&gt; are
-removed, see below) &lt;br&gt;
+Decrypted hints&nbsp;&nbsp;&nbsp; (badchars are removed, see below) &lt;br&gt;
 BUGS&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;Liste&lt;/span&gt; &lt;span class=SpellE&gt;der&lt;/span&gt; &lt;span
-class=SpellE&gt;TBs&lt;/span&gt; : &lt;br&gt;
+Liste der TBs : &lt;br&gt;
 SOLVER&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Solver &lt;span class=SpellE&gt;Infos&lt;/span&gt;&lt;br&gt;
+Solver Infos&lt;br&gt;
 COUNTRY&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;Staat&lt;/span&gt; &lt;br&gt;
+Staat &lt;br&gt;
 STATE&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;Bundesland&lt;/span&gt;&lt;br&gt;
+Bundesland&lt;br&gt;
 HTML&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 TRUE / FALSE if description is html&lt;br&gt;
 VOTE&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;gcvote&lt;/span&gt; / OC&lt;br style='mso-special-character:line-break'&gt;
+gcvote / OC&lt;br style='mso-special-character:line-break'&gt;
 &lt;![if !supportLineBreakNewLine]&gt;&lt;br style='mso-special-character:line-break'&gt;
 &lt;![endif]&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;ATTRIBUTES&lt;span
 style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-the &lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt; ATTRIBUTES&gt;, example see
-GCTemplate.html / show cache in browser offline&lt;br&gt;
+the &lt;tmpl_loop ATTRIBUTES&gt;, example see GCTemplate.html / show cache in
+browser offline&lt;br&gt;
 PATHANDIMAGE&lt;span style='mso-tab-count:7'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-path an &lt;span class=SpellE&gt;imagename&lt;/span&gt; of the attribute&lt;br&gt;
+path an imagename of the attribute&lt;br&gt;
 IMAGE&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;imagename&lt;/span&gt; of the attribute&lt;br&gt;
+imagename of the attribute&lt;br&gt;
 INFO&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-description of the attribute from language &lt;span class=SpellE&gt;config&lt;/span&gt;&lt;br&gt;
+description of the attribute from language config&lt;br&gt;
 GCINFO&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 description of the attribute as from gc.com&lt;br&gt;
 BR&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-contains &lt;&lt;span class=SpellE&gt;br&lt;/span&gt;/&gt; every 5&lt;sup&gt;th&lt;/sup&gt; attribute
-else empty (can be used with &lt;&lt;span class=SpellE&gt;tmp_if&lt;/span&gt;&gt;&lt;span
-class=GramE&gt;)&lt;/span&gt;&lt;br&gt;
+contains &lt;br/&gt; every 5&lt;sup&gt;th&lt;/sup&gt; attribute else empty (can be used
+with &lt;tmp_if&gt;)&lt;br&gt;
 GCID&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 ID of gc.com&lt;br&gt;
 INC&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
@@ -445,21 +402,21 @@
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;LOGS&lt;span
 style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-the &lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt; LOGS &gt;, example see
-GCTemplate.html / show cache in browser offline&lt;br&gt;
+the &lt;tmpl_loop LOGS &gt;, example see GCTemplate.html / show cache in
+browser offline&lt;br&gt;
 ICON&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 name of the log picture&lt;br&gt;
 LOGTYPE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=GramE&gt;Text :&lt;/span&gt; found it&lt;span style='mso-spacerun:yes'&gt;&#160;
-&lt;/span&gt;etc&#133;.(&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;gc.com
+Text : found it&lt;span style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;etc&#133;.(&lt;/span&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
+style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;gc.com
 compatible string representation)&lt;br&gt;
 DATE&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 date of the log&lt;br&gt;
 LOGGER&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 name&lt;br&gt;
 MESSAGE&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;logtext&lt;/span&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+logtext&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
@@ -467,23 +424,19 @@
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;ADDIS&lt;span
 style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-the &lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt; ADDIS&gt; example see
-GCTemplate.html&lt;br&gt;
+the &lt;tmpl_loop ADDIS&gt; example see GCTemplate.html&lt;br&gt;
 WAYPOINT&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;der&lt;/span&gt; &lt;span class=SpellE&gt;Addi&lt;/span&gt;&lt;br&gt;
+der Addi&lt;br&gt;
 NAME&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Name des &lt;span class=SpellE&gt;Addi&lt;/span&gt;&lt;br&gt;
+Name des Addi&lt;br&gt;
 LATLON&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;span class=SpellE&gt;Koordinaten&lt;/span&gt; des &lt;span class=SpellE&gt;Addi&lt;/span&gt;&lt;br&gt;
-LAT&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;&lt;span
-class=GramE&gt;:&lt;/span&gt;&lt;br&gt;
+Koordinaten des Addi&lt;br&gt;
+LAT&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;br&gt;
 LON&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:&lt;br&gt;
 IMG&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-Name des &lt;span class=SpellE&gt;Addi&lt;/span&gt; Icons &lt;span class=SpellE&gt;png&lt;/span&gt;
-(resources &lt;span class=SpellE&gt;oder&lt;/span&gt; &lt;span class=SpellE&gt;exporticons&lt;/span&gt;)&lt;br&gt;
+Name des Addi Icons png (resources oder exporticons)&lt;br&gt;
 ICON&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-&lt;type&gt; as number string (see &lt;span class=SpellE&gt;CacheType.java&lt;/span&gt; &lt;span
-class=SpellE&gt;e.g&lt;/span&gt; : &#133;,50=Parking &#133;.)&lt;br&gt;
+&lt;type&gt; as number string (see CacheType.java e.g : &#133;,50=Parking &#133;.)&lt;br&gt;
 &lt;/span&gt;&lt;span style='font-size:10.0pt;font-family:Arial'&gt;TYPENAME&lt;span
 style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 Typename des Addi wie in der GUI&lt;br&gt;
@@ -500,11 +453,9 @@
 mso-outline-level:1'&gt;&lt;span style='font-size:10.0pt;font-family:Arial'&gt;&lt;o:p&gt;&nbsp;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
-mso-outline-level:1'&gt;&lt;span class=SpellE&gt;&lt;span class=GramE&gt;&lt;span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;cacheImg&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;span
-style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
-the &lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt; &lt;span class=SpellE&gt;cacheImg&lt;/span&gt;&gt;&lt;br&gt;
+mso-outline-level:1'&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'&gt;cacheImg&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
+the &lt;tmpl_loop cacheImg&gt;&lt;br&gt;
 FILENAME&lt;span style='mso-tab-count:8'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
 the filename in the profile directory&lt;br&gt;
 TEXT&lt;span style='mso-tab-count:9'&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;/span&gt;:
@@ -528,34 +479,24 @@
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;#--
 Microsoft AutoRoute --&gt;&lt;br&gt;
-&lt;#-- &lt;span class=SpellE&gt;Codecs&lt;/span&gt;: ASCII, UTF8 --&gt;&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;charset&lt;/span&gt;&quot;
-value=&quot;ASCII&quot;&gt;&lt;br&gt;
-&lt;#-- &lt;span class=SpellE&gt;somme&lt;/span&gt; chars should not appear in the &lt;span
-class=SpellE&gt;cachename&lt;/span&gt; --&gt;&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;badchars&lt;/span&gt;&quot;
-value=&quot;;&quot;&quot;&lt;span class=GramE&gt;&gt;&lt;/span&gt;&lt;br&gt;
-&lt;#-- &lt;span class=SpellE&gt;newline&lt;/span&gt;: CR, LF, CRLF --&gt;&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;newline&lt;/span&gt;&quot;
-value=&quot;CRLF&quot;&gt;&lt;br&gt;
-&lt;#-- decimal &lt;span class=SpellE&gt;seperator&lt;/span&gt;: . or , --&gt;&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_par&lt;/span&gt; name=&quot;&lt;span class=SpellE&gt;decsep&lt;/span&gt;&quot;
-value=&quot;,&quot;&gt;&lt;br&gt;
+&lt;#-- Codecs: ASCII, UTF8 --&gt;&lt;br&gt;
+&lt;tmpl_par name=&quot;charset&quot; value=&quot;ASCII&quot;&gt;&lt;br&gt;
+&lt;#-- somme chars should not appear in the cachename --&gt;&lt;br&gt;
+&lt;tmpl_par name=&quot;badchars&quot; value=&quot;;&quot;&quot;&gt;&lt;br&gt;
+&lt;#-- newline: CR, LF, CRLF --&gt;&lt;br&gt;
+&lt;tmpl_par name=&quot;newline&quot; value=&quot;CRLF&quot;&gt;&lt;br&gt;
+&lt;#-- decimal seperator: . or , --&gt;&lt;br&gt;
+&lt;tmpl_par name=&quot;decsep&quot; value=&quot;,&quot;&gt;&lt;br&gt;
 Name;Breitengrad;L&#228;ngengrad;Typ1;Typ2;Waypoint;Datum;Hyperlink&lt;br /&gt;&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt; &lt;span class=SpellE&gt;cache_index&lt;/span&gt;&gt;&lt;br&gt;
-&quot;&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt; name=SHORTTYPE&gt;-&lt;&lt;span
-class=SpellE&gt;tmpl_var&lt;/span&gt; name=SHORTSIZE&gt;-&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=DIFFICULTY&gt;-&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt; name=TERRAIN&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt; name=NAME&gt;&quot;;&lt;&lt;span
-class=SpellE&gt;tmpl_var&lt;/span&gt; name=LAT&gt;;&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=LON&gt;;&quot;&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=TYPE&gt;&quot;;&quot;&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=SIZE&gt;&quot;;&quot;&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=WAYPOINT&gt;&quot;;&quot;&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=DATE&gt;&quot;;&quot;&lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;
-name=URL&gt;&quot;&lt;&lt;span class=SpellE&gt;br&lt;/span&gt; /&gt;&lt;br&gt;
-&lt;/&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt;&gt;&lt;br style='mso-special-character:
-line-break'&gt;
+&lt;tmpl_loop cache_index&gt;&lt;br&gt;
+&quot;&lt;tmpl_var name=SHORTTYPE&gt;-&lt;tmpl_var
+name=SHORTSIZE&gt;-&lt;tmpl_var name=DIFFICULTY&gt;-&lt;tmpl_var
+name=TERRAIN&gt; &lt;tmpl_var name=NAME&gt;&quot;;&lt;tmpl_var
+name=LAT&gt;;&lt;tmpl_var name=LON&gt;;&quot;&lt;tmpl_var
+name=TYPE&gt;&quot;;&quot;&lt;tmpl_var name=SIZE&gt;&quot;;&quot;&lt;tmpl_var
+name=WAYPOINT&gt;&quot;;&quot;&lt;tmpl_var name=DATE&gt;&quot;;&quot;&lt;tmpl_var
+name=URL&gt;&quot;&lt;br /&gt;&lt;br&gt;
+&lt;/tmpl_loop&gt;&lt;br style='mso-special-character:line-break'&gt;
 &lt;![if !supportLineBreakNewLine]&gt;&lt;br style='mso-special-character:line-break'&gt;
 &lt;![endif]&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
@@ -564,22 +505,19 @@
 Arial;mso-ansi-language:EN-GB'&gt;Tags&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span lang=EN-GB
 style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-class=SpellE&gt;&lt;u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;tmpl_var&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;u&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
+&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;tmpl_var&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;You
 can set default values for your template variables, which&lt;/span&gt;&lt;span
 lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
 style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;will be used
-if no value has been set through the &lt;span class=SpellE&gt;setParam&lt;/span&gt; method.&lt;br&gt;
-&lt;TMPL_VAR name=&quot;&lt;span class=SpellE&gt;var_name&lt;/span&gt;&quot;
-default=&quot;my value&quot;&gt;&lt;br&gt;
-If &lt;span class=SpellE&gt;var_name&lt;/span&gt; is set using &lt;span class=SpellE&gt;setParam&lt;/span&gt;
-(or &lt;span class=SpellE&gt;setParams&lt;/span&gt;), then it's value will be whatever it
-was set to&lt;span class=GramE&gt;,&lt;span style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;else&lt;/span&gt;&lt;/span&gt;&lt;span
+if no value has been set through the setParam method.&lt;br&gt;
+&lt;TMPL_VAR name=&quot;var_name&quot; default=&quot;my value&quot;&gt;&lt;br&gt;
+If var_name is set using setParam (or setParams), then it's value will be
+whatever it was set to,&lt;span style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;else&lt;/span&gt;&lt;span
 lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
 style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;it will be
 &quot;my value&quot; (without the quotes).&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
@@ -589,21 +527,15 @@
 can also &quot;escape&quot; certain strings. The following escape modes are
 possible.&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&nbsp; &lt;/span&gt;&lt;span
-class=GramE&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;none&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='font-size:
-10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;:&nbsp;&nbsp; String
-unchanged (this is the default if escape is not specified)&lt;br&gt;
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;none:&nbsp;&nbsp;
+String unchanged (this is the default if escape is not specified)&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&nbsp; &lt;/span&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;html:&nbsp;&nbsp;
 Encode special characters: &amp; &gt; &lt; &quot;.&nbsp; They are changed to
-&amp;amp; &amp;&lt;span class=SpellE&gt;lt&lt;/span&gt;;&lt;span class=GramE&gt;&nbsp; &amp;&lt;/span&gt;&lt;span
-class=SpellE&gt;gt&lt;/span&gt;;&nbsp; and &amp;&lt;span class=SpellE&gt;quot&lt;/span&gt;;
-respectively&lt;br&gt;
+&amp;amp; &amp;lt;&nbsp; &amp;gt;&nbsp; and &amp;quot; respectively&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&nbsp; &lt;/span&gt;&lt;span
-class=SpellE&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;url&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB style='font-size:
-10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;:&nbsp;&nbsp;&nbsp; Encode
-special characters in URL, e.g. space becomes %20&lt;br&gt;
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;url:&nbsp;&nbsp;&nbsp;
+Encode special characters in URL, e.g. space becomes %20&lt;br&gt;
 &lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&nbsp; &lt;/span&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;quote:&nbsp;
 Change quotation marks:&nbsp;&nbsp; &quot; becomes \&quot;&nbsp; and ' becomes
@@ -613,47 +545,41 @@
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;Example:
-&lt;TMPL_VAR name=&quot;&lt;span class=SpellE&gt;var_name&lt;/span&gt;&quot;
-escape=&quot;html&quot;&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
-EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;TMPL_VAR name=&quot;var_name&quot; escape=&quot;html&quot;&gt;&lt;/span&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&nbsp;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-class=SpellE&gt;&lt;u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;tmpl_if&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;u&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
+&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;tmpl_if&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;The
-&lt;&lt;span class=SpellE&gt;tmpl_if&lt;/span&gt;&gt; tag allows you to include or not
-include a block of the template based on the &lt;span class=GramE&gt;value&lt;span
-style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;of&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
-font-family:Arial;mso-ansi-language:EN-GB'&gt;a given parameter name. If the
-parameter is given a value that is true, then the block is included in&lt;/span&gt;&lt;span
+&lt;tmpl_if&gt; tag allows you to include or not include a block of the
+template based on the value&lt;span style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;of&lt;/span&gt;&lt;span
 lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;the output.
-If the value is false, then it is skipped.&lt;br&gt;
-The &lt;span class=SpellE&gt;tmpl_if&lt;/span&gt; must be closed with a corresponding /&lt;span
-class=SpellE&gt;tmpl_if&lt;/span&gt;, e.g.&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
-EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;a given
+parameter name. If the parameter is given a value that is true, then the block
+is included in&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;the
+output. If the value is false, then it is skipped.&lt;br&gt;
+The tmpl_if must be closed with a corresponding /tmpl_if, e.g.&lt;/span&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;&lt;span
-class=SpellE&gt;tmpl_if&lt;/span&gt; ...&gt;&lt;br&gt;
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;&lt;tmpl_if
+...&gt;&lt;br&gt;
 ...&lt;br&gt;
-&lt;/&lt;span class=SpellE&gt;tmpl_if&lt;/span&gt;&gt;&lt;/span&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;/tmpl_if&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;Parameter
-values for conditions are Strings in java, and not &lt;span class=SpellE&gt;&lt;span
-class=GramE&gt;boolean&lt;/span&gt;&lt;/span&gt; values, hence, what evaluates to true and&lt;/span&gt;&lt;span
-lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;false needs
-to be specifically defined.&lt;br&gt;
+values for conditions are Strings in java, and not boolean values, hence, what
+evaluates to true and&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;false
+needs to be specifically defined.&lt;br&gt;
 As of now, the following values evaluate to false:&lt;br&gt;
 &quot;&quot; - the empty string&lt;br&gt;
 &quot;0&quot; - the string containing only the number zero&lt;br&gt;
@@ -663,58 +589,52 @@
 &lt;![if !supportLineBreakNewLine]&gt;&lt;br style='mso-special-character:line-break'&gt;
 &lt;![endif]&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-class=SpellE&gt;&lt;u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;tmpl_else&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;u&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
+&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;tmpl_else&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;While
-the if block allows us to display some output if a condition is true&lt;span
-class=GramE&gt;,&lt;span style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;we&lt;/span&gt;&lt;/span&gt;&lt;span
-lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;may also
-need to display content if the condition is false. This can be done by using
-the optional else&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;branch
-of &lt;span class=GramE&gt;the if&lt;/span&gt; block.&lt;/span&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+the if block allows us to display some output if a condition is true,&lt;span
+style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;we&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
+EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'&gt;may also need to display content if the condition is
+false. This can be done by using the optional else&lt;/span&gt;&lt;span lang=EN-GB
+style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'&gt;branch of the if block.&lt;/span&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-class=SpellE&gt;&lt;u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;tmpl_unless&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;u&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
+&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;tmpl_unless&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;This
-tag is the exact opposite of the &lt;&lt;span class=SpellE&gt;tmpl_if&lt;/span&gt;&gt; tag.
-A &lt;&lt;span class=SpellE&gt;tmpl_unless&lt;/span&gt;&gt; block is displayed if its
-control variable&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span
-lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;evaluates
-to false. If the control variable evaluates to true, then the else block, if&lt;/span&gt;&lt;span
-lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;any, is
-displayed instead.&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+tag is the exact opposite of the &lt;tmpl_if&gt; tag. A &lt;tmpl_unless&gt;
+block is displayed if its control variable&lt;/span&gt;&lt;span lang=EN-GB
+style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'&gt;evaluates to false. If the control
+variable evaluates to true, then the else block, if&lt;/span&gt;&lt;span lang=EN-GB
+style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'&gt;any, is displayed instead.&lt;/span&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-class=SpellE&gt;&lt;u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;tmpl_loop&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;u&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
+&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;tmpl_loop&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;The
-&lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt;&gt; tag is a bit more complicated than
-the other tags. It allows you to create a section of text that&lt;/span&gt;&lt;span
-lang=EN-GB style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB
-style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;will be
-displayed repeatedly for every item in the loop control variable. Inside the
-&lt;&lt;span class=SpellE&gt;tmpl_loop&lt;/span&gt;&gt;&lt;span class=GramE&gt;,&lt;span
-style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;you&lt;/span&gt;&lt;/span&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
-font-family:Arial;mso-ansi-language:EN-GB'&gt;place &lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;&gt;s.&lt;b
-style='mso-bidi-font-weight:normal'&gt; The only loop used by the template
-exporter is '&lt;span class=SpellE&gt;cache_index&lt;/span&gt;', see example above. &lt;/b&gt;&lt;/span&gt;&lt;span
-lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+&lt;tmpl_loop&gt; tag is a bit more complicated than the other tags. It allows
+you to create a section of text that&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
+EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'&gt;will be displayed repeatedly for every item in the
+loop control variable. Inside the &lt;tmpl_loop&gt;,&lt;span
+style='mso-spacerun:yes'&gt;&#160; &lt;/span&gt;you&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
+EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'&gt;place &lt;tmpl_var&gt;s.&lt;b style='mso-bidi-font-weight:
+normal'&gt; The only loop used by the template exporter is 'cache_index', see
+example above. &lt;/b&gt;&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
 mso-outline-level:1'&gt;&lt;st1:place&gt;&lt;u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
@@ -725,11 +645,11 @@
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;If
-you set &lt;span class=SpellE&gt;loop_context_vars&lt;/span&gt; to true in your Template's
-constructor, then you will have access to five special&lt;/span&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
-font-family:Arial;mso-ansi-language:EN-GB'&gt;variables in all your loops. These
-are:&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
+you set loop_context_vars to true in your Template's constructor, then you will
+have access to five special&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
+EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
+mso-ansi-language:EN-GB'&gt;variables in all your loops. These are:&lt;/span&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;__FIRST__&lt;span
@@ -761,20 +681,18 @@
 mso-ansi-language:EN-GB'&gt;You may use these like any other &lt;TMPL_VAR&gt;
 inside your loop.&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 
-&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
-class=SpellE&gt;&lt;u&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;tmpl_include&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;u&gt;&lt;span lang=EN-GB
-style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
+&lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;tmpl_include&lt;/span&gt;&lt;/u&gt;&lt;u&gt;&lt;span
+lang=EN-GB style='mso-ansi-language:EN-GB'&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
 
 &lt;p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'&gt;&lt;span
 lang=EN-GB style='font-size:10.0pt;font-family:Arial;mso-ansi-language:EN-GB'&gt;The
-&lt;&lt;span class=SpellE&gt;tmpl_include&lt;/span&gt;&gt; tag is the next simplest tag
-after &lt;&lt;span class=SpellE&gt;tmpl_var&lt;/span&gt;&gt;, however, it will not do what
-you expect it to do inside&lt;/span&gt;&lt;span lang=EN-GB style='mso-ansi-language:
-EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;font-family:Arial;
-mso-ansi-language:EN-GB'&gt;a &lt;&lt;span class=SpellE&gt;tmpl_if&lt;/span&gt;&gt;&lt;br&gt;
-&lt;&lt;span class=SpellE&gt;tmpl_include&lt;/span&gt;&gt; is used to include the contents
-of another template within this template, at the position of the tag. &lt;br&gt;
+&lt;tmpl_include&gt; tag is the next simplest tag after &lt;tmpl_var&gt;,
+however, it will not do what you expect it to do inside&lt;/span&gt;&lt;span lang=EN-GB
+style='mso-ansi-language:EN-GB'&gt; &lt;/span&gt;&lt;span lang=EN-GB style='font-size:10.0pt;
+font-family:Arial;mso-ansi-language:EN-GB'&gt;a &lt;tmpl_if&gt;&lt;br&gt;
+&lt;tmpl_include&gt; is used to include the contents of another template within
+this template, at the position of the tag. &lt;br&gt;
 Processing then continues, as if the included template were always a part of
 the current template. &lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
 

Modified: branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/OSMCycleMap.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,27 @@
-TakenFromUrl: <A HREF="http://downloads.igorbrejc.net/osm/kosmos/">http://downloads.igorbrejc.net/osm/kosmos/</A>
-#Kosmos Download : <A HREF="http://downloads.igorbrejc.net/osm/kosmos/">http://downloads.igorbrejc.net/osm/kosmos/</A>
+TakenFromUrl: <A HREF="http://maperitive.net/">http://maperitive.net/</A>
 GetCapabilitiesUrl:
-Name:               OSMCycleMap mit Kosmos.Console.exe
+Name:               OSM Cyclemap with Maperitive.exe
 MapType:                        topo
-MainUrl:            C:\\Programme\\Kosmos-2.5.405.6\\Console\\Kosmos.Console.exe
-ServiceTypeUrlPart: OSMCycleMap.kpr
-VersionUrlPart:
+#MainUrl: name of exceutable
+MainUrl:            Maperitive.exe
+#ServiceTypeUrlPart: default map to use : may be empty(=mapnik) or mapnik or osmarender or cyclemap
+ServiceTypeUrlPart: cyclemap
+#VersionUrlPart: path to executable of mainUrl
+VersionUrlPart: C:/Programme/Maperitive
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:     Kosmos
+#RequestUrlPart: must be Maperitive
+RequestUrlPart:     Maperitive
+#LayersUrlPart: empty or filename (osm or other) for the load-source command; path from VersionUrlPart will be added by CW
 LayersUrlPart:
+#StylesUrlPart: empty or filename for the use-ruleset location; path from VersionUrlPart will be added by CW
 StylesUrlPart:
 ImageFormatUrlPart:FORMAT=image/png
+# BBox the osm-file covers
 BoundingBoxTopLeftWGS84: N 90.0000 W 180.0000
-BoundingBoxButtomRightWGS84: S 90.0000 E 180.0000
+BoundingBoxBottomRightWGS84: S 90.0000 E 180.0000
 MinScale:   0
 MaxScale:   1000
 RecommendedScale:   5
-ImageFileExtension: .png
+#Maperitive does many png, jpg(jpeg), bmp, tif(tiff) , gif, emf, wmf
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/OSMMapnik.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,27 @@
-TakenFromUrl: <A HREF="http://downloads.igorbrejc.net/osm/kosmos/">http://downloads.igorbrejc.net/osm/kosmos/</A>
-#Kosmos Download : <A HREF="http://downloads.igorbrejc.net/osm/kosmos/">http://downloads.igorbrejc.net/osm/kosmos/</A>
+TakenFromUrl: <A HREF="http://maperitive.net/">http://maperitive.net/</A>
 GetCapabilitiesUrl:
-Name:               OSMMapnik mit Kosmos.Console.exe
+Name:               OSM Mapnik with Maperitive.exe
 MapType:                        topo
-MainUrl:            C:\\Programme\\Kosmos-2.5.405.6\\Console\\Kosmos.Console.exe
-ServiceTypeUrlPart: OSMMapnik.kpr
-VersionUrlPart:
+#MainUrl: name of exceutable
+MainUrl:            Maperitive.exe
+#ServiceTypeUrlPart: default map to use : may be empty(=mapnik) or mapnik or osmarender or cyclemap
+ServiceTypeUrlPart: 
+#VersionUrlPart: path to executable of mainUrl
+VersionUrlPart: C:/Programme/Maperitive
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:     Kosmos
+#RequestUrlPart: must be Maperitive
+RequestUrlPart:     Maperitive
+#LayersUrlPart: empty or filename (osm or other) for the load-source command; path from VersionUrlPart will be added by CW
 LayersUrlPart:
+#StylesUrlPart: empty or filename for the use-ruleset location; path from VersionUrlPart will be added by CW
 StylesUrlPart:
 ImageFormatUrlPart:FORMAT=image/png
+# BBox the osm-file covers
 BoundingBoxTopLeftWGS84: N 90.0000 W 180.0000
-BoundingBoxButtomRightWGS84: S 90.0000 E 180.0000
+BoundingBoxBottomRightWGS84: S 90.0000 E 180.0000
 MinScale:   0
 MaxScale:   1000
 RecommendedScale:   5
-ImageFileExtension: .png
+#Maperitive does many png, jpg(jpeg), bmp, tif(tiff) , gif, emf, wmf
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/OSMOsmarender.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,27 @@
-TakenFromUrl: <A HREF="http://downloads.igorbrejc.net/osm/kosmos/">http://downloads.igorbrejc.net/osm/kosmos/</A>
-#Kosmos Download : <A HREF="http://downloads.igorbrejc.net/osm/kosmos/">http://downloads.igorbrejc.net/osm/kosmos/</A>
+TakenFromUrl: <A HREF="http://maperitive.net/">http://maperitive.net/</A>
 GetCapabilitiesUrl:
-Name:               OSMOsmarender mit Kosmos.Console.exe
+Name:               OSMarender with Maperitive.exe
 MapType:                        topo
-MainUrl:            C:\\Programme\\Kosmos-2.5.405.6\\Console\\Kosmos.Console.exe
-ServiceTypeUrlPart: OSMOsmarender.kpr
-VersionUrlPart:
+#MainUrl: name of exceutable
+MainUrl:            Maperitive.exe
+#ServiceTypeUrlPart: default map to use : may be empty(=mapnik) or mapnik or osmarender or cyclemap
+ServiceTypeUrlPart: osmarender
+#VersionUrlPart: path to executable of mainUrl
+VersionUrlPart: C:/Programme/Maperitive
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:     Kosmos
+#RequestUrlPart: must be Maperitive
+RequestUrlPart:     Maperitive
+#LayersUrlPart: empty or filename (osm or other) for the load-source command; path from VersionUrlPart will be added by CW
 LayersUrlPart:
+#StylesUrlPart: empty or filename for the use-ruleset location; path from VersionUrlPart will be added by CW
 StylesUrlPart:
 ImageFormatUrlPart:FORMAT=image/png
+# BBox the osm-file covers
 BoundingBoxTopLeftWGS84: N 90.0000 W 180.0000
-BoundingBoxButtomRightWGS84: S 90.0000 E 180.0000
+BoundingBoxBottomRightWGS84: S 90.0000 E 180.0000
 MinScale:   0
 MaxScale:   1000
 RecommendedScale:   5
-ImageFileExtension: .png
+#Maperitive does many png, jpg(jpeg), bmp, tif(tiff) , gif, emf, wmf
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/at-3_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-3_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/at-3_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -41,7 +41,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.112935  E 14.243781
-BoundingBoxButtomRightWGS84:   N 47.297627 E 17.481360
+BoundingBoxBottomRightWGS84:   N 47.297627 E 17.481360
 #BBox_Mitte: N 48.205281 E 15.862571
 MinScale:   0
 MaxScale:   45

Modified: branches/r1.2/res_noewe/webmapservices/at-3_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-3_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/at-3_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -39,7 +39,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.112935  E 14.243781
-BoundingBoxButtomRightWGS84:   N 47.297627 E 17.481360
+BoundingBoxBottomRightWGS84:   N 47.297627 E 17.481360
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   5

Added: branches/r1.2/res_noewe/webmapservices/at-5_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-5_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-5_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+TakenFromUrl:       <A HREF="http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer">http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer</A>
+GetCapabilitiesUrl: <A HREF="http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               at.Salzburg p
+MapType:                        photo
+MainUrl:            <A HREF="http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?">http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=0|Polygondecker||
+#LayersUrlPart:     LAYERS=1|Orientierungskarte|0.000396|198.000000
+#LayersUrlPart:     LAYERS=2|Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=3|Flugjahr Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=4|Vogelschutzgebiete|0.792000|39.600000
+#LayersUrlPart:     LAYERS=5|Habitat Richtlinie (PSCI)|0.792000|39.600000
+#LayersUrlPart:     LAYERS=6|Naturpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=7|Landschaftsschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=8|Nationalpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=9|Naturschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=10|geschuetzte Landschaftsteile|0.792000|39.600000
+#LayersUrlPart:     LAYERS=11|Landesstrasse B|0.000396|39.600000
+#LayersUrlPart:     LAYERS=12|Landesstrasse L|0.000396|39.600000
+#LayersUrlPart:     LAYERS=13|Autobahn|0.000396|39.600000
+#LayersUrlPart:     LAYERS=14|Radwanderroute|0.0|1.980396
+#LayersUrlPart:     LAYERS=15|geonam|0.000396|7.919604
+#LayersUrlPart:     LAYERS=16|Politische Gemeinde|7.920000|39.600000
+#LayersUrlPart:     LAYERS=17|Politische Bezirke|39.600396|99.000000
+#LayersUrlPart:     LAYERS=18|NUTS 3 Regionen|3.959604|Infinity
+#LayersUrlPart:     LAYERS=19|Landesgrenze|198.000396|297.000000
+LayersUrlPart:     LAYERS=2
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 48.8794 E 11.1495
+BoundingBoxBottomRightWGS84: N 46.5273 E 15.1958
+#BBox_Mitte: N 47.70337 E 13.1726725
+MinScale:   0
+MaxScale:   3
+RecommendedScale:    1 2
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/at-5_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-5_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-5_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+TakenFromUrl:       <A HREF="http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer">http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer</A>
+GetCapabilitiesUrl: <A HREF="http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               at.Salzburg t
+MapType:                        topo
+MainUrl:            <A HREF="http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?">http://service.salzburg.gv.at/ArcGIS/services/Geoland_WMS_Land_Salzburg/MapServer/WMSServer?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=0|Polygondecker||
+#LayersUrlPart:     LAYERS=1|Orientierungskarte|0.000396|198.000000
+#LayersUrlPart:     LAYERS=2|Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=3|Flugjahr Orthofoto|3.960000|7.920396
+#LayersUrlPart:     LAYERS=4|Vogelschutzgebiete|0.792000|39.600000
+#LayersUrlPart:     LAYERS=5|Habitat Richtlinie (PSCI)|0.792000|39.600000
+#LayersUrlPart:     LAYERS=6|Naturpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=7|Landschaftsschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=8|Nationalpark|0.792000|39.600000
+#LayersUrlPart:     LAYERS=9|Naturschutzgebiet|0.792000|39.600000
+#LayersUrlPart:     LAYERS=10|geschuetzte Landschaftsteile|0.792000|39.600000
+#LayersUrlPart:     LAYERS=11|Landesstrasse B|0.000396|39.600000
+#LayersUrlPart:     LAYERS=12|Landesstrasse L|0.000396|39.600000
+#LayersUrlPart:     LAYERS=13|Autobahn|0.000396|39.600000
+#LayersUrlPart:     LAYERS=14|Radwanderroute|0.0|1.980396
+#LayersUrlPart:     LAYERS=15|geonam|0.000396|7.919604
+#LayersUrlPart:     LAYERS=16|Politische Gemeinde|7.920000|39.600000
+#LayersUrlPart:     LAYERS=17|Politische Bezirke|39.600396|99.000000
+#LayersUrlPart:     LAYERS=18|NUTS 3 Regionen|3.959604|Infinity
+#LayersUrlPart:     LAYERS=19|Landesgrenze|198.000396|297.000000
+LayersUrlPart:     LAYERS=1,11,12,13,15,16,17,19
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/png
+BoundingBoxTopLeftWGS84: N 48.8794 E 11.1495
+BoundingBoxBottomRightWGS84: N 46.5273 E 15.1958
+#BBox_Mitte: N 47.70337 E 13.1726725
+MinScale:   0
+MaxScale:   1000
+RecommendedScale:   1 5 10
+ImageFileExtension: .png

Added: branches/r1.2/res_noewe/webmapservices/at-6_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-6_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-6_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,42 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://stmk-nt10:80/wmsconnector/com.esri.wms.Esrimap/geoland34_wms?">http://stmk-nt10:80/wmsconnector/com.esri.wms.Esrimap/geoland34_wms?</A>
+GetCapabilitiesUrl: <A HREF="http://gis2.stmk.gv.at/wmsconnector/com.esri.wms.Esrimap?serviceName=geoland34_wms&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://gis2.stmk.gv.at/wmsconnector/com.esri.wms.Esrimap?serviceName=geoland34_wms&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               at.Steiermark p
+MapType:                        photo
+MainUrl:            <A HREF="http://gis2.stmk.gv.at/wmsconnector/com.esri.wms.Esrimap?serviceName=geoland34_wms&amp;">http://gis2.stmk.gv.at/wmsconnector/com.esri.wms.Esrimap?serviceName=geoland34_wms&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=Polygondecker|Polygondecker||
+#LayersUrlPart:     LAYERS=orientierungskarte|Orientierungskarte|NaN|99999999
+#LayersUrlPart:     LAYERS=Vogelschutzrichtlinie|Vogelschutzrichtlinie (SPA)||
+#LayersUrlPart:     LAYERS=Habitatrichtlinie|Habitat-Richtlinie (PSCI)||
+#LayersUrlPart:     LAYERS=Naturpark|Naturpark||
+#LayersUrlPart:     LAYERS=Landschaftsschutzgebiet|Landschaftsschutzgebiet||
+#LayersUrlPart:     LAYERS=Nationalpark|Nationalpark||
+#LayersUrlPart:     LAYERS=Naturschutzgebiet|Naturschutzgebiet||
+#LayersUrlPart:     LAYERS=geschuetzteLandschaftsteile|geschuetzte Landschaftsteile||
+#LayersUrlPart:     LAYERS=l_str|Landesstrasse L||
+#LayersUrlPart:     LAYERS=b_str|Landesstrasse B||
+#LayersUrlPart:     LAYERS=s_str|Schnellstrasse||
+#LayersUrlPart:     LAYERS=a_str|Autobahn||
+#LayersUrlPart:     LAYERS=radwanderrouten|Radwanderrouten||
+#LayersUrlPart:     LAYERS=oertl_str|&#195;&#182;rtliches Strassennetz||
+#LayersUrlPart:     LAYERS=geo_nam|geonam|NaN|NaN
+#LayersUrlPart:     LAYERS=ortho05m_farbe|Orthofoto||
+#LayersUrlPart:     LAYERS=Flugdatum_Farbe|Flugdatum Orthofoto Farbe||
+#LayersUrlPart:     LAYERS=PolitischeGemeinden|Politische Gemeinden||
+#LayersUrlPart:     LAYERS=PolitischeBezirke|Politische Bezirke||
+#LayersUrlPart:     LAYERS=Nuts3Regionen|Nuts3 Regionen|NaN|99999999
+#LayersUrlPart:     LAYERS=Landesgrenzen|Landesgrenzen||
+LayersUrlPart:     LAYERS=l_str,b_str,s_str,a_str,oertl_str,geo_nam,ortho05m_farbe
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 50.6551 E 6.6948
+BoundingBoxBottomRightWGS84: N 42.9679 E 23.0349
+#BBox_Mitte: N 46.8114789243 E 14.86481406315
+MinScale:   0
+MaxScale:   1000
+RecommendedScale:   1
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/at-8_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at-8_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/at-8_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,29 @@
+TakenFromUrl:       <A HREF="http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&amp;version=1.1.1&amp;">http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&amp;version=1.1.1&amp;</A>
+GetCapabilitiesUrl: <A HREF="http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               at.Vorarlberg t
+MapType:                        topo
+MainUrl:            <A HREF="http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&amp;">http://vogis.cnv.at/mapserver/mapserv?map=i_topographie_r_wms.map&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=MS|Topographische Karten||
+#LayersUrlPart:     LAYERS=topokarte_isoli_text_20t|Topographische Karte Isoli_Text 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topokarte_winter_isoli_text_20t|Topographische Karte Isoli_Text Winter 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topokarte_20t|Topographische Karte 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topokarte_winter_20t|Topographische Karte Winter 1:20.000|0.37455131345855|187.08894233825
+#LayersUrlPart:     LAYERS=topo_symbole|Topographische Karte Symbole|0.37455131345855|18.7092309932477
+#LayersUrlPart:     LAYERS=topo_texte|Topographische Karte Texte|0.37455131345855|18.7092309932477
+#LayersUrlPart:     LAYERS=topo_linien|Topographische Karte Linien|0.37455131345855|18.7092309932477
+#LayersUrlPart:     LAYERS=topo_textlinien|Topographische Karte Textlinien|0.37455131345855|18.7092309932477
+LayersUrlPart:     LAYERS=topokarte_20t
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 47.6586 E 9.4012
+BoundingBoxBottomRightWGS84: N 46.7554 E 10.3996
+#BBox_Mitte: N 47.207 E 9.90039
+MinScale:   1.3811
+MaxScale:   88.3883
+RecommendedScale:    2 5 10
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/at_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/at_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/at_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -32,7 +32,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.027050  E 9.529250
-BoundingBoxButtomRightWGS84:   N 46.357433 E 17.202733
+BoundingBoxBottomRightWGS84:   N 46.357433 E 17.202733
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-jc_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #S&#252;db&#246;hmen
 BoundingBoxTopLeftWGS84: N 49.62233 E 13.51730
-BoundingBoxButtomRightWGS84: N 48.54843 E 15.61450
+BoundingBoxBottomRightWGS84: N 48.54843 E 15.61450
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-jm_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -91,7 +91,7 @@
 ImageFormatUrlPart:FORMAT=image/jpeg
 #manuell
 BoundingBoxTopLeftWGS84: N 49.634341 E 15.50975
-BoundingBoxButtomRightWGS84: N 48.614016 E 17.666016
+BoundingBoxBottomRightWGS84: N 48.614016 E 17.666016
 #MinScale:   0
 #MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-jm_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #Real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #S&#252;dm&#228;hren
 BoundingBoxTopLeftWGS84: N 49.634619 E 15.531836
-BoundingBoxButtomRightWGS84: N 48.609817 E 17.657948
+BoundingBoxBottomRightWGS84: N 48.609817 E 17.657948
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -33,9 +33,9 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 #BoundingBoxTopLeftWGS84: N 49.9457 E 14.7989
-#BoundingBoxButtomRightWGS84: N 48.8765 E 16.5340
+#BoundingBoxBottomRightWGS84: N 48.8765 E 16.5340
 BoundingBoxTopLeftWGS84: N 49.9841 E 14.7605
-BoundingBoxButtomRightWGS84: N 48.7959 E 16.5811
+BoundingBoxBottomRightWGS84: N 48.7959 E 16.5811
 #BBox_Mitte: N 49.41110624465 E 15.6664623227
 #MinScale:   0
 #MaxScale:   45

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -33,9 +33,9 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 #BoundingBoxTopLeftWGS84: N 49.9457 E 14.7989
-#BoundingBoxButtomRightWGS84: N 48.8765 E 16.5340
+#BoundingBoxBottomRightWGS84: N 48.8765 E 16.5340
 BoundingBoxTopLeftWGS84: N 49.9841 E 14.7605
-BoundingBoxButtomRightWGS84: N 48.7959 E 16.5811
+BoundingBoxBottomRightWGS84: N 48.7959 E 16.5811
 #BBox_Mitte: N 49.41110624465 E 15.6664623227
 #MinScale:   0
 #MaxScale:   45

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #Hochland
 BoundingBoxTopLeftWGS84: N 49.86521 E 14.886475
-BoundingBoxButtomRightWGS84: N 48.932583 E 16.42529
+BoundingBoxBottomRightWGS84: N 48.932583 E 16.42529
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/cz-vy_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -33,9 +33,9 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 #BoundingBoxTopLeftWGS84: N 49.9457 E 14.7989
-#BoundingBoxButtomRightWGS84: N 48.8765 E 16.5340
+#BoundingBoxBottomRightWGS84: N 48.8765 E 16.5340
 BoundingBoxTopLeftWGS84: N 49.9841 E 14.7605
-BoundingBoxButtomRightWGS84: N 48.7959 E 16.5811
+BoundingBoxBottomRightWGS84: N 48.7959 E 16.5811
 #BBox_Mitte: N 49.41110624465 E 15.6664623227
 #MinScale:   0
 #MaxScale:   45

Added: branches/r1.2/res_noewe/webmapservices/cz_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/cz_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/cz_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,22 @@
+&#239;&#187;&#191;TakenFromUrl:       
+GetCapabilitiesUrl: <A HREF="http://geoportal.cuzk.cz/WMS_ZM50_PUB/service.svc/get?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://geoportal.cuzk.cz/WMS_ZM50_PUB/service.svc/get?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               cz.Tschechien t50k
+MapType:                        topo
+MainUrl:            <A HREF="http://geoportal.cuzk.cz/WMS_ZM50_PUB/service.svc/get?">http://geoportal.cuzk.cz/WMS_ZM50_PUB/service.svc/get?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=GR_ZM50|Z&#195;&#161;kladn&#195;&#173; mapa 1:50 000|1|100000
+#LayersUrlPart:     LAYERS=GT_TEXT_ZM10|Copyright|1|100000
+LayersUrlPart:     LAYERS=GR_ZM50
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 51.4961 E 11.6156
+BoundingBoxBottomRightWGS84: N 48.0913 E 19.0612
+#BBox_Mitte: N 49.7936991896322 E 15.3384076389007
+MinScale:   0
+MaxScale:   12
+RecommendedScale:    5 2 4
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bb_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:   STYLES=2
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.5000 E 11.7000
-BoundingBoxButtomRightWGS84: N 51.3000 E 14.8000
+BoundingBoxBottomRightWGS84: N 51.3000 E 14.8000
 MinScale:   0.1
 MaxScale:   11
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bb_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -20,7 +20,7 @@
 StylesUrlPart:     STYLES=2
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.5000 E 11.7000
-BoundingBoxButtomRightWGS84: N 51.3000 E 14.8000
+BoundingBoxBottomRightWGS84: N 51.3000 E 14.8000
 MinScale:   0.1
 MaxScale:   25
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/de-bw_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bw_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bw_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.0000 E 7.6000
-BoundingBoxButtomRightWGS84: N 47.4000 E 10.0000
+BoundingBoxBottomRightWGS84: N 47.4000 E 10.0000
 MinScale:   1
 MaxScale:   700
 RecommendedScale:    1 8

Added: branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-bw_t10k.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,22 @@
+TakenFromUrl:       <A HREF="http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten">http://deutschlandviewer.bayern.de/deutschlandviewer/D_Viewer_Hilfe/Hilfe_D_Viewer.htm#Geodaten</A>
+GetCapabilitiesUrl: <A HREF="http://www.lv-bw.de/dv/service/getrds.asp?login=dv&amp;pw=anonymous&amp;SERVICE=WMS&amp;REQUEST=GetCapabilities">http://www.lv-bw.de/dv/service/getrds.asp?login=dv&amp;pw=anonymous&amp;SERVICE=WMS&amp;REQUEST=GetCapabilities</A>
+Name: de.Baden-Wuerttemberg t10k
+MapType:                        topo
+#MainUrl:            <A HREF="http://www.lv-bw.de/dv/service/getrds.asp?login=dv&amp;pw=anonymous&amp;">http://www.lv-bw.de/dv/service/getrds.asp?login=dv&amp;pw=anonymous&amp;</A>
+MainUrl:            <A HREF="http://www.lv-bw.de/dv/service/getrds.asp?login=geoportal&amp;pw=gdi_bw&amp;">http://www.lv-bw.de/dv/service/getrds.asp?login=geoportal&amp;pw=gdi_bw&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31467
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31467
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=DVDOP2|DOP_2m||
+#LayersUrlPart:     LAYERS=DVTK50K|TK50||
+LayersUrlPart:     LAYERS=RK10
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 50.0000 E 7.6000
+BoundingBoxBottomRightWGS84: N 47.4000 E 10.0000
+MinScale:   0
+MaxScale:   20
+RecommendedScale:    1 5 10
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-bw_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.0000 E 7.6000
-BoundingBoxButtomRightWGS84: N 47.4000 E 10.0000
+BoundingBoxBottomRightWGS84: N 47.4000 E 10.0000
 MinScale:   0.3
 MaxScale:   700
 RecommendedScale:    5 8 4 2 1

Modified: branches/r1.2/res_noewe/webmapservices/de-by_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-by_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-by_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -17,7 +17,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.6269 E 8.8929
-BoundingBoxButtomRightWGS84: N 47.0828 E 13.9782
+BoundingBoxBottomRightWGS84: N 47.0828 E 13.9782
 MinScale:   2.82
 MaxScale:   11
 RecommendedScale:    3 4 5

Modified: branches/r1.2/res_noewe/webmapservices/de-by_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-by_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-by_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -17,7 +17,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 50.6269 E 8.8929
-BoundingBoxButtomRightWGS84: N 47.0828 E 13.9782
+BoundingBoxBottomRightWGS84: N 47.0828 E 13.9782
 MinScale:   1
 MaxScale:   15
 RecommendedScale:    3 5 7

Modified: branches/r1.2/res_noewe/webmapservices/de-he_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-he_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-he_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.6697 E 7.6991
-BoundingBoxButtomRightWGS84: N 49.3455 E 11.3986
+BoundingBoxBottomRightWGS84: N 49.3455 E 11.3986
 MinScale:   0.4
 MaxScale:   3
 RecommendedScale:    1

Modified: branches/r1.2/res_noewe/webmapservices/de-he_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-he_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-he_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -16,7 +16,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.6697 E 7.6991
-BoundingBoxButtomRightWGS84: N 49.3455 E 11.3986
+BoundingBoxBottomRightWGS84: N 49.3455 E 11.3986
 MinScale:   2
 MaxScale:   16
 RecommendedScale:    3 7 10

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_photo.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	0.000374177136322228
 MaxScale:	37.4180878093591
 RecommendedScale:	0.4

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_topo_10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/png
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	0.186714391024792
 MaxScale:	11.2256882668032
 RecommendedScale:	1.0

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_topo_25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/png
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	1.87051150447482
 MaxScale:	18.7092309932477
 RecommendedScale:	2.5

Modified: branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-mv_topo_50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:	STYLES=
 ImageFormatUrlPart:	FORMAT=image/png
 BoundingBoxTopLeftWGS84:	N 54.8209 E 10.3394
-BoundingBoxButtomRightWGS84:	N 53.0392 E 14.477
+BoundingBoxBottomRightWGS84:	N 53.0392 E 14.477
 MinScale:	5.6122828676971
 MaxScale:	28.0636594013034
 RecommendedScale:	5.0

Modified: branches/r1.2/res_noewe/webmapservices/de-ni_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-ni_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-ni_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,43 +1,43 @@
-TakenFromUrl:       <A HREF="http://www.umwelt.niedersachsen.de/master/C7089178_N7088657_L20_D0_I598.html">http://www.umwelt.niedersachsen.de/master/C7089178_N7088657_L20_D0_I598.html</A>
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer">http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer</A>
 GetCapabilitiesUrl: <A HREF="http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
-Name:               de.Niedersachsen photo c SF=0..1,95
+Name:               de.Niedersachsen p
 MapType:                        photo
-#MainUrl:            <A HREF="http://www.umweltkarten.niedersachsen.de/arcgis/services/GR_Gebiete/MapServer/WMSServer?">http://www.umweltkarten.niedersachsen.de/arcgis/services/GR_Gebiete/MapServer/WMSServer?</A>
 MainUrl:            <A HREF="http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?">http://www.umweltkarten.niedersachsen.de/arcgis/services/Programme/MapServer/WMSServer?</A>
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
-CoordinateReferenceSystemCacheWolf:  31467
-CoordinateReferenceSystemUrlPart: SRS=EPSG:31467 
+CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
 RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=0|Gebiete mit gesamtstaatlicher repr&#228;sentativer Bedeutung|2.772396|Infinity
-#LayersUrlPart:     LAYERS=1|Flie&#223;gew&#228;sserschutzsystem Verbindungsgew&#228;sser|2.772396|Infinity
-#LayersUrlPart:     LAYERS=2|Flie&#223;gew&#228;sserschutzsystem Hauptgew&#228;sser und Auen|2.772396|Infinity
-#LayersUrlPart:     LAYERS=3|Moorschutzprogramm Neubewertung|2,772396|Infinity
+#LayersUrlPart:     LAYERS=0|Gebiete mit gesamtstaatlicher repr&#195;&#164;sentativer Bedeutung|2.772396|Infinity
+#LayersUrlPart:     LAYERS=1|Flie&#195;&#159;gew&#195;&#164;sserschutzsystem Verbindungsgew&#195;&#164;sser|2.772396|Infinity
+#LayersUrlPart:     LAYERS=2|Flie&#195;&#159;gew&#195;&#164;sserschutzsystem Hauptgew&#195;&#164;sser und Auen|2.772396|Infinity
+#LayersUrlPart:     LAYERS=3|Moorschutzprogramm Neubewertung|2.772396|Infinity
 #LayersUrlPart:     LAYERS=4|Moorschutzprogramm Teil II|2.772396|Infinity
 #LayersUrlPart:     LAYERS=5|Abgrenzung des Hochmoorkomplexes MSP Teil I|2.772396|Infinity
 #LayersUrlPart:     LAYERS=6|Moorschutzprogramm (MSP) Teil I|2.772396|Infinity
-#LayersUrlPart:     LAYERS=7|Untere  Naturschutzbeh&#246;rden|2.772396|Infinity
-#LayersUrlPart:     LAYERS=8|Landkreise||
-#LayersUrlPart:     LAYERS=9|Ortslagen|99.000000|237.600000
-#LayersUrlPart:     LAYERS=10|Grosse Seen|198.000000|Infinity
-#LayersUrlPart:     LAYERS=11|Gro&#223;e Fl&#252;sse|198.000000|Infinity
-#LayersUrlPart:     LAYERS=12|Orthophoto Farbe|0.0|2.772000
-#LayersUrlPart:     LAYERS=13|DTK 25|2.772396|4.950000
-#LayersUrlPart:     LAYERS=14|TK 50|4.950396|9.900000
-#LayersUrlPart:     LAYERS=15|TK 100|9.900396|29.700000
-#LayersUrlPart:     LAYERS=16|TK 500|29.700396|99.000000
-#LayersUrlPart:     LAYERS=17|Autobahnen||
-#LayersUrlPart:     LAYERS=18|Schrift: Gro&#223;e Orte||
-#LayersUrlPart:     LAYERS=19|Schrift: Kleine Orte||
-LayersUrlPart:     LAYERS=12
+#LayersUrlPart:     LAYERS=7|Untere  Naturschutzbeh&#195;&#182;rden|2.772396|Infinity
+#LayersUrlPart:     LAYERS=8|Naturr&#195;&#164;umliche Regionen und Unterregionen DTK50||
+#LayersUrlPart:     LAYERS=9|Naturr&#195;&#164;umliche Regionen DTK50||
+#LayersUrlPart:     LAYERS=10|Landesgrenze inkl. 12 Seemeilen-Zone||
+#LayersUrlPart:     LAYERS=11|Landkreise||
+#LayersUrlPart:     LAYERS=12|Ortslagen|99.000000|237.600000
+#LayersUrlPart:     LAYERS=13|Grosse Seen|198.000000|Infinity
+#LayersUrlPart:     LAYERS=14|Gro&#195;&#159;e Fl&#195;&#188;sse|198.000000|Infinity
+#LayersUrlPart:     LAYERS=15|Orthophoto Farbe|0.0|2.772000
+#LayersUrlPart:     LAYERS=16|DTK 25|2.772396|4.950000
+#LayersUrlPart:     LAYERS=17|TK 50 |4.950396|9.900000
+#LayersUrlPart:     LAYERS=18|TK 100|9.900396|29.700000
+#LayersUrlPart:     LAYERS=19|DTK 500 |29.700396|99.000000
+#LayersUrlPart:     LAYERS=20|Autobahnen||
+#LayersUrlPart:     LAYERS=21|Schrift: Gro&#195;&#159;e Orte||
+#LayersUrlPart:     LAYERS=22|Schrift: Kleine Orte||
+LayersUrlPart:     LAYERS=15
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
-BoundingBoxTopLeftWGS84: N 53.898485 E 6.600296
-BoundingBoxButtomRightWGS84: N 51.265165 E 11.665345
-MinScale:   0
-MaxScale:   2.772396
-RecommendedScale:   1
-#MinSFInput:0
-#MaxSFInput:1,9586
+BoundingBoxTopLeftWGS84: N 54.0098 E 6.4705
+BoundingBoxBottomRightWGS84: N 51.2325 E 11.6591
+#BBox_Mitte: N 52.6211685 E 9.0647625
+MinScale:   0.2
+MaxScale:   3
+RecommendedScale:    1
 ImageFileExtension: .jpg
-#weitere Overlays hinzuf&#252;gen geht bei Photo nicht.
\ No newline at end of file

Added: branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-ni_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,220 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://www.geodaten.niedersachsen.de/">http://www.geodaten.niedersachsen.de/</A>
+GetCapabilitiesUrl: <A HREF="http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               de.Niedersachsen t50
+MapType:                        topo
+MainUrl:            <A HREF="http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?">http://geoportal.geodaten.niedersachsen.de/geodatenportal/servlet/gtEntryPoint?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=map_618|Kartenhintergrund||
+#LayersUrlPart:     LAYERS=map_2501|Kartenhintergrund (grau / transp.)||
+#LayersUrlPart:     LAYERS=layer_3603|Bundesl&#195;&#164;ndergrenzen|4989.031178|0.000499
+#LayersUrlPart:     LAYERS=layer_3602|Kreisgrenzen Bund|748.354677|0.000499
+#LayersUrlPart:     LAYERS=layer_3601|Gemeindegrenzen Bund|249.451559|0.000499
+#LayersUrlPart:     LAYERS=layer_3701|&#195;&#156;bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3702|&#195;&#156;bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3703|&#195;&#156;bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3704|&#195;&#156;bersichtskarte 1:500000|296.052238|0.000000
+#LayersUrlPart:     LAYERS=layer_3705|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3707|Digit. Topogr. Karte 1:50000|29.605225|0.000000
+#LayersUrlPart:     LAYERS=layer_3708|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3709|Digit. Stra&#195;&#159;enkarte 1:10000|5.921047|0.000000
+#LayersUrlPart:     LAYERS=layer_1445|Hausnummern|3.492322|0.000000
+#LayersUrlPart:     LAYERS=layer_3710|Amtliche Karte 1:5000|6.315779|0.000000
+#LayersUrlPart:     LAYERS=layer_3713|Digit. Orthophoto||
+#LayersUrlPart:     LAYERS=layer_3714|&#195;&#156;bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3715|&#195;&#156;bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3716|&#195;&#156;bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3717|&#195;&#156;bersichtskarte 1:500000|296.052240|0.000000
+#LayersUrlPart:     LAYERS=layer_3718|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3720|Digit. Topogr. Karte 1:50000|29.605224|0.000000
+#LayersUrlPart:     LAYERS=layer_3721|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3722|Digit. Stra&#195;&#159;enkarte 1:10000|5.921045|0.000000
+#LayersUrlPart:     LAYERS=layer_3723|Amtliche Karte 1:5000|6.315781|0.000000
+#LayersUrlPart:     LAYERS=layer_3724|&#195;&#156;bersichtskarte 1:5000000||
+#LayersUrlPart:     LAYERS=layer_3725|&#195;&#156;bersichtskarte 1:2500000|1184.208959|0.000000
+#LayersUrlPart:     LAYERS=layer_3726|&#195;&#156;bersichtskarte 1:1000000|592.104481|0.000000
+#LayersUrlPart:     LAYERS=layer_3727|&#195;&#156;bersichtskarte 1:500000|296.052240|0.000000
+#LayersUrlPart:     LAYERS=layer_3728|Topogr. Karte 1:100000|59.210446|0.000000
+#LayersUrlPart:     LAYERS=layer_3730|Digit. Topogr. Karte 1:50000|29.605224|0.000000
+#LayersUrlPart:     LAYERS=layer_3731|Digit. Topogr. Karte 1:25000|19.736817|0.000000
+#LayersUrlPart:     LAYERS=layer_3732|Digit. Stra&#195;&#159;enkarte 1:10000|5.921045|0.000000
+#LayersUrlPart:     LAYERS=layer_3733|Amtliche Karte 1:5000|3.947363|0.000000
+#LayersUrlPart:     LAYERS=layer_1487|Geolog. &#195;&#156;bersichtskarte 1: 500000||
+#LayersUrlPart:     LAYERS=layer_1485|Geologische Karte 1:50000|132.582186|0.000000
+#LayersUrlPart:     LAYERS=layer_2102|Tiefenlage der Quart&#195;&#164;rbasis 1:500000||
+#LayersUrlPart:     LAYERS=layer_1489|Hochwassergef&#195;&#164;hrdg. 1:500000||
+#LayersUrlPart:     LAYERS=layer_1486|Hochwassergef&#195;&#164;hrdg. 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1488|Urspr&#195;&#188;ngliche Moorverbreitung||
+#LayersUrlPart:     LAYERS=layer_1490|Rohstoffsicherungskarte 1:25000||
+#LayersUrlPart:     LAYERS=layer_1494|Ingenieurgeolog. Karte 1:500000||
+#LayersUrlPart:     LAYERS=layer_1493|Ingenieurgeolog. Karte 1:50000|132.582186|0.000000
+#LayersUrlPart:     LAYERS=layer_1491|Bodenklassen&#195;&#188;bersichtskarte von 0m bis 1m|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1492|Bodenklassen&#195;&#188;bersichtskarte von 1m bis 2m (n. DIN 18300) 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1542|Bodengro&#195;&#159;landschaften 1:500000||
+#LayersUrlPart:     LAYERS=layer_1535|Bodenversiegelung 1:500000||
+#LayersUrlPart:     LAYERS=layer_1533|Bodenlandschaften 1:200000||
+#LayersUrlPart:     LAYERS=layer_1541|Bodentypenkarte 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1537|Standortbezogenes ackerbaul. Ertragspotenzial 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1534|Standorteignung f&#195;&#188;r die Beseitigung von Tierk&#195;&#182;rpern bei Seuchenz&#195;&#188;gen 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1538|Schutzw&#195;&#188;rdige B&#195;&#182;den 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1539|Bodensch&#195;&#164;tzungskarte 1:25000|33.145547|0.000000
+#LayersUrlPart:     LAYERS=layer_1540|Forstliche Standortstypenkarte 1:25000|33.145547|0.000000
+#LayersUrlPart:     LAYERS=layer_1536|Histor. Landnutzung 1:25000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1902|Hydrogeolog. Einheiten 1:500000||
+#LayersUrlPart:     LAYERS=layer_1913|Hydrogeolog. R&#195;&#164;ume u. Teilr&#195;&#164;ume 1:500000||
+#LayersUrlPart:     LAYERS=layer_1907|Grundwasserleitertypen der oberfl&#195;&#164;chennahen Gesteine 1:500000||
+#LayersUrlPart:     LAYERS=layer_1906|Durchl&#195;&#164;ssigkeit der oberfl&#195;&#164;chennahen Gesteine 1:500000||
+#LayersUrlPart:     LAYERS=layer_1903|Entnahmebedingungen in den Grundwasser f&#195;&#188;hrenden Gesteinen 1:500000||
+#LayersUrlPart:     LAYERS=layer_1914|Grundwasserk&#195;&#182;rper 1:500000||
+#LayersUrlPart:     LAYERS=layer_1904|Schutzpotenzial der Grundwasser&#195;&#188;berdeckung 1:200000||
+#LayersUrlPart:     LAYERS=layer_1908|Versalzung des Grundwassers 1:200000||
+#LayersUrlPart:     LAYERS=layer_1915|Fliessrichtung im Festgestein||
+#LayersUrlPart:     LAYERS=map_802|Grundwasseroberfl&#195;&#164;che 1:200000||
+#LayersUrlPart:     LAYERS=layer_1917|Tiefenstufe||
+#LayersUrlPart:     LAYERS=layer_1916|H&#195;&#182;hengleichen u. Beschriftung||
+#LayersUrlPart:     LAYERS=map_803|Grundwasseroberfl&#195;&#164;che 1:50000||
+#LayersUrlPart:     LAYERS=layer_1922|Tiefenstufe||
+#LayersUrlPart:     LAYERS=layer_1919|H&#195;&#182;hengleichen|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1918|H&#195;&#182;hengleichen (Beschriftung)|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1613|Erlaubnisse offshore||
+#LayersUrlPart:     LAYERS=layer_1609|Erlaubnisse onshore||
+#LayersUrlPart:     LAYERS=layer_1611|Bewilligungen offshore||
+#LayersUrlPart:     LAYERS=layer_1612|Bewilligungen onshore||
+#LayersUrlPart:     LAYERS=layer_1608|Bergwerksfelder||
+#LayersUrlPart:     LAYERS=layer_1610|Entenschnabel||
+#LayersUrlPart:     LAYERS=layer_1607|Nutzungsbed. oberfl&#195;&#164;chennaher Geothermie||
+#LayersUrlPart:     LAYERS=layer_1606|Potenzielle Standorteignung f&#195;&#188;r Erdw&#195;&#164;rmekollektoren (Einbautiefe 1,2-1,5m) 1:50000|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1468|Staatsgrenze (12sm-Grenze)||
+#LayersUrlPart:     LAYERS=layer_1469|Grenzpunkte||
+#LayersUrlPart:     LAYERS=layer_1471|Weitere Grenzen u. Linien||
+#LayersUrlPart:     LAYERS=layer_1470|Tiefwasserreede (Zust. NI)||
+#LayersUrlPart:     LAYERS=layer_1472|Grenze Binnenwasserstr.||
+#LayersUrlPart:     LAYERS=layer_1473|Bereich Emsm&#195;&#188;ndung (8.4.1960)||
+#LayersUrlPart:     LAYERS=layer_1474|Grenzbereich Emsm&#195;&#188;ndung||
+#LayersUrlPart:     LAYERS=layer_1475|Linie Zusatzabkommen||
+#LayersUrlPart:     LAYERS=layer_1476|Gebiet mit nds. Recht||
+#LayersUrlPart:     LAYERS=layer_1477|Wasserpolizeilicher Bereich|997.805697|0.498903
+#LayersUrlPart:     LAYERS=layer_1478|Wasserpolizeil. Grenzen zum K&#195;&#188;stenmeer|1995.611394|0.498903
+#LayersUrlPart:     LAYERS=layer_1479|zust&#195;&#164;ndige Bundesl&#195;&#164;nder|299.341711|0.498903
+#LayersUrlPart:     LAYERS=layer_1480|Grenze Wasser- u. Schifffahrtsdirektionen Nordwest u. Nord||
+#LayersUrlPart:     LAYERS=layer_1481|Nationalpark Nds. Wattenmeer||
+#LayersUrlPart:     LAYERS=layer_3101|Landschaftsschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3102|Naturpark||
+#LayersUrlPart:     LAYERS=layer_3103|Biosph&#195;&#164;renreservat||
+#LayersUrlPart:     LAYERS=layer_3104|Nationalpark||
+#LayersUrlPart:     LAYERS=layer_3105|Vogelschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3106|Fauna-Flora-Habitat - Gebiet||
+#LayersUrlPart:     LAYERS=layer_3107|Naturschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_3108|Wasserschutzgebiet||
+#LayersUrlPart:     LAYERS=layer_4111|Nationalpark (NLP)||
+#LayersUrlPart:     LAYERS=layer_4110|Biosph&#195;&#164;renreservat (BSR)||
+#LayersUrlPart:     LAYERS=layer_4109|Naturschutzgebiet (NSG)||
+#LayersUrlPart:     LAYERS=layer_4108|Naturdenkmal (ND)||
+#LayersUrlPart:     LAYERS=layer_4107|ND in schmaler Laengsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4106|ND kleiner 1 ha||
+#LayersUrlPart:     LAYERS=layer_4105|Landschaftsschutzgebiet (LSG)||
+#LayersUrlPart:     LAYERS=layer_4104|LSG in schmaler L&#195;&#164;ngsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4103|Gesch. Landschaftsbestandteil (GLB)||
+#LayersUrlPart:     LAYERS=layer_4102|GLB in schmaler L&#195;&#164;ngsausdehnung||
+#LayersUrlPart:     LAYERS=layer_4101|GLB kleiner 1 ha||
+#LayersUrlPart:     LAYERS=layer_3007|Gebietsname und -nummer||
+#LayersUrlPart:     LAYERS=layer_3008|H&#195;&#182;chster Schutzzweck/zone||
+#LayersUrlPart:     LAYERS=layer_3009|Priorit&#195;&#164;tenprogramm Trinkwasserschutz||
+#LayersUrlPart:     LAYERS=layer_3010|Zuwendungskulisse ELER||
+#LayersUrlPart:     LAYERS=layer_3011|Wasserrahmenrichtlinie: Gesch&#195;&#188;tzte Gebiete||
+#LayersUrlPart:     LAYERS=layer_3013|Heilquellenschutzgebiete||
+#LayersUrlPart:     LAYERS=layer_3014|Trinkwasserschutzgebiete||
+#LayersUrlPart:     LAYERS=layer_3012|Trinkwassergewinnungsgeb.||
+#LayersUrlPart:     LAYERS=layer_3405|vorl&#195;&#164;ufig gesicherte &#195;&#156;berschwemmungsgebiete||
+#LayersUrlPart:     LAYERS=layer_3401|&#195;&#156;berschwemmungsgebiete im Verfahren (Bremen)||
+#LayersUrlPart:     LAYERS=layer_3402|Verordnungsfl&#195;&#164;chen||
+#LayersUrlPart:     LAYERS=layer_3404|... geeignet ab 1: 50000|15.839605|0.000000
+#LayersUrlPart:     LAYERS=layer_3403|... geeignet ab 1: 10000|3.168000|0.000000
+#LayersUrlPart:     LAYERS=layer_1482|Feldbl&#195;&#182;cke|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_1484|Feldblockinseln|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_1483|Landschaftselemente|9.999999|0.000000
+#LayersUrlPart:     LAYERS=layer_4201|Potenzielle Wassererosion|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_4202|Potenzielle Winderosion|66.291093|0.000000
+#LayersUrlPart:     LAYERS=layer_1805|Amtsbezirke &#195;&#132;fL|1000000.000002|1.000001
+#LayersUrlPart:     LAYERS=layer_1806|Dorferneuerung|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1809|Neuvermessungsgebiete|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1807|Stand der Flurbereinigung|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_1808|Flurbereinigungsgebiete|407.859201|0.000000
+#LayersUrlPart:     LAYERS=layer_2301|LROP (Stand: 2008)|9899.495094|24.945141
+#LayersUrlPart:     LAYERS=layer_2501|ROKK 2005|548.793430|24.944657
+#LayersUrlPart:     LAYERS=layer_2603|Fl&#195;&#164;chennutzungsplan|99.780624|0.049890
+#LayersUrlPart:     LAYERS=layer_2602|B-Plan (Umringe)|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2610|Kompensationsfl&#195;&#164;chen|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2601|Liegenschaften|14.967094|0.049890
+#LayersUrlPart:     LAYERS=layer_2611|1: Landsch.-&#195;&#182;kolog. Raumeinheiten|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2612|2: Wasser|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2613|3: Boden|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2614|4: Luft|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2615|5a: Arten u. Lebensgemeinschaften|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2616|5b: Schutzgebiete|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2617|6: Vielfalt, Eigenart, Sch&#195;&#182;nheit|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2618|7: Belastungen, Gef&#195;&#164;hrdungen|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2619|7a: Konflikte mit st&#195;&#164;dtebaul. Entwicklung|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2620|8: Ma&#195;&#159;nahmen und Entwicklung|99.780624|0.498903
+#LayersUrlPart:     LAYERS=layer_2621|Gew&#195;&#164;sser 2. Ordnung|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2622|Gew&#195;&#164;sser 3. Ordnung|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2606|Renaturierung der Else|54.879343|0.049890
+#LayersUrlPart:     LAYERS=layer_2201|B-Plan Hiddestorf||
+#LayersUrlPart:     LAYERS=map_1702|Regionale Gesch&#195;&#164;ftsbereiche||
+#LayersUrlPart:     LAYERS=layer_2912|GB-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2913|GB-Standorte||
+#LayersUrlPart:     LAYERS=map_1703|Stra&#195;&#159;enmeistereien||
+#LayersUrlPart:     LAYERS=layer_2910|SM-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2911|SM-Standorte||
+#LayersUrlPart:     LAYERS=map_1704|Autobahnmeistereien||
+#LayersUrlPart:     LAYERS=layer_2908|AM-Grenzen||
+#LayersUrlPart:     LAYERS=layer_2909|AM-Standorte||
+#LayersUrlPart:     LAYERS=layer_2907|sonstige Dienstorte||
+#LayersUrlPart:     LAYERS=layer_1454|Autobahnen||
+#LayersUrlPart:     LAYERS=layer_1455|Bundesstra&#195;&#159;en||
+#LayersUrlPart:     LAYERS=layer_1456|Landesstra&#195;&#159;en||
+#LayersUrlPart:     LAYERS=layer_1457|Kreisstra&#195;&#159;en||
+#LayersUrlPart:     LAYERS=layer_1458|Anschlussstellenbezeichnung|249.451559|0.000000
+#LayersUrlPart:     LAYERS=layer_1459|Anschlussstellennummer||
+#LayersUrlPart:     LAYERS=layer_1460|Netzknoten||
+#LayersUrlPart:     LAYERS=layer_1461|Nullpunkte||
+#LayersUrlPart:     LAYERS=layer_815|Z&#195;&#164;hlstellen||
+#LayersUrlPart:     LAYERS=layer_812|Werte Kraftfahrzeuge||
+#LayersUrlPart:     LAYERS=layer_813|Werte G&#195;&#188;terverkehr||
+#LayersUrlPart:     LAYERS=layer_814|Werte Schwerverkehr||
+#LayersUrlPart:     LAYERS=layer_809|Verkehrsmengen Autobahn||
+#LayersUrlPart:     LAYERS=layer_810|Verkehrsmengen Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_811|Verkehrsmengen Landesstr.||
+#LayersUrlPart:     LAYERS=layer_1448|Verkehrsmengen Autobahn||
+#LayersUrlPart:     LAYERS=layer_1449|Verkehrsmengen Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_1450|Verkehrsmengen Landesstr.||
+#LayersUrlPart:     LAYERS=layer_1451|DTV- / SV-Werte Autobahn||
+#LayersUrlPart:     LAYERS=layer_1452|DTV- / SV-Werte Bundesstr.||
+#LayersUrlPart:     LAYERS=layer_1453|DTV- / SV-Werte Landesstr.||
+#LayersUrlPart:     LAYERS=layer_2402|Sonderflugh&#195;&#164;fen||
+#LayersUrlPart:     LAYERS=layer_2403|Verkehrsflugh&#195;&#164;fen||
+#LayersUrlPart:     LAYERS=layer_2404|Verkehrslandepl&#195;&#164;tze||
+#LayersUrlPart:     LAYERS=layer_2405|Sonderlandepl&#195;&#164;tze||
+#LayersUrlPart:     LAYERS=layer_2406|Segelfluggel&#195;&#164;nde||
+#LayersUrlPart:     LAYERS=layer_802|Arch&#195;&#164;ologie (Gro&#195;&#159;steingr&#195;&#164;ber)|126.713409|1.999998
+#LayersUrlPart:     LAYERS=layer_803|Arch&#195;&#164;ologie (GeoLife)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_804|Arch&#195;&#164;ologie (Wurten und Deiche)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_805|Bau- und Kunstdenkmalpflege (M&#195;&#188;hlen)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_806|Bau- und Kunstdenkmalpflege (Kirchen)|44.901281|1.999998
+#LayersUrlPart:     LAYERS=layer_807|Bau- und Kunstdenkmalpflege (Worpswede)|15.839176|1.999998
+#LayersUrlPart:     LAYERS=layer_808|Bau- und Kunstdenkmalpflege (Herrenhausen)|15.839176|1.999998
+#LayersUrlPart:     LAYERS=layer_1428|Preu&#195;&#159;. Landesaufn. 1:25000 (grau/transp.)|24.945141|0.000000
+#LayersUrlPart:     LAYERS=layer_1427|Preu&#195;&#159;. Landesaufn. 1:25000 (schwarz/transp.)|24.945141|0.000000
+LayersUrlPart:     LAYERS=layer_3707
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 53.9771 E 6.4229
+BoundingBoxBottomRightWGS84: N 51.2089 E 11.7272
+#BBox_Mitte: N 52.5929772805 E 9.0750485755
+MinScale:   0
+MaxScale:   16
+RecommendedScale:    5 1 10
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-ni_t_lv.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,36 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://www.lgln.niedersachsen.de?">http://www.lgln.niedersachsen.de?</A>
+GetCapabilitiesUrl: <A HREF="http://www.geobasisdaten.niedersachsen.de/bestand?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://www.geobasisdaten.niedersachsen.de/bestand?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               de.Niedersachsen t25
+MapType:                        topo
+MainUrl:            <A HREF="http://www.geobasisdaten.niedersachsen.de/bestand?">http://www.geobasisdaten.niedersachsen.de/bestand?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31466 31467 31468 31469
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467 SRS=EPSG:31468 SRS=EPSG:31469 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=bestand|LGLN-Bestand||
+#LayersUrlPart:     LAYERS=rasterdaten|&#195;&#156;bersichtskarten||
+#LayersUrlPart:     LAYERS=ueb5000_gd|UKN 5.000|633.499852296075|9899.49490168847
+#LayersUrlPart:     LAYERS=ukn2500_gd|UKN 2.500|296.999859087254|633.499852296075
+#LayersUrlPart:     LAYERS=ueb1000_gd|UKN 1.000|126.713500006|296.999859087254
+#LayersUrlPart:     LAYERS=ukn500_gd|UKN 500|44.901280999479|126.713500006
+#LayersUrlPart:     LAYERS=dtk100_v_gd|TK 100|0|44.901280999479
+#LayersUrlPart:     LAYERS=dtk100_v_b|Topographischen Karte 1:100.000||
+#LayersUrlPart:     LAYERS=dtk50_b|Topographischen Karte 1:50.000||
+#LayersUrlPart:     LAYERS=dtk25_b|Topographischen Karte 1:25.000||
+#LayersUrlPart:     LAYERS=pl25_b|Preu&#195;&#159;ischen Landesaufnahme 1:25.000||
+#LayersUrlPart:     LAYERS=dsk10_b|Digitalen Stra&#195;&#159;enkarte 1:10.000||
+#LayersUrlPart:     LAYERS=dgk5g_b|Deutsche Grundkarte 1:5.000||
+#LayersUrlPart:     LAYERS=ak5_b|Amtlichen Karte 1:5.000||
+#LayersUrlPart:     LAYERS=dop_b|Digitales Orthophoto||
+#LayersUrlPart:     LAYERS=landkreise_umringe|Landkreisgrenzen|0|9899.49490168847
+#LayersUrlPart:     LAYERS=gemeinden_umringe|Gemeindegrenzen|0|126.713500006
+LayersUrlPart:     LAYERS=rasterdaten
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 54.5532 E 5.8980
+BoundingBoxBottomRightWGS84: N 50.6527 E 12.6222
+MinScale:   2
+MaxScale:   60
+RecommendedScale:    2.5 1 5 7.5
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 52.5391 E 5.7591
-BoundingBoxButtomRightWGS84: N 50.3040 E 9.4718
+BoundingBoxBottomRightWGS84: N 50.3040 E 9.4718
 #BBox_Mitte: N 51.421555 E 7.6154425
 MinScale:   0
 MaxScale:   1000

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 52.6020 E 5.7250
-BoundingBoxButtomRightWGS84: N 50.1506 E 9.5315
+BoundingBoxBottomRightWGS84: N 50.1506 E 9.5315
 #BBox_Mitte: N 51.3763 E 7.628265
 MinScale:   0
 MaxScale:   1000

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 52.5850 E 5.7043
-BoundingBoxButtomRightWGS84: N 50.2178 E 9.5219
+BoundingBoxBottomRightWGS84: N 50.2178 E 9.5219
 #BBox_Mitte: N 51.4014 E 7.61312
 MinScale:   0.5
 MaxScale:   18

Modified: branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-nw_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 52.5850 E 5.7043
-BoundingBoxButtomRightWGS84: N 50.2178 E 9.5219
+BoundingBoxBottomRightWGS84: N 50.2178 E 9.5219
 #BBox_Mitte: N 51.4014 E 7.61312
 MinScale:   2
 MaxScale:   36

Modified: branches/r1.2/res_noewe/webmapservices/de-rp_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-rp_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-rp_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 51.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 48.8000 E 8.7000
+BoundingBoxBottomRightWGS84: N 48.8000 E 8.7000
 MinScale:   0.5
 MaxScale:   24.95
 RecommendedScale:	0.4

Modified: branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-rp_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 48.8000 E 8.7000
+BoundingBoxBottomRightWGS84: N 48.8000 E 8.7000
 MinScale:   1
 MaxScale:   50
 RecommendedScale:   2,5

Modified: branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-rp_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,7 +21,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 48.8000 E 8.7000
+BoundingBoxBottomRightWGS84: N 48.8000 E 8.7000
 MinScale:   1
 MaxScale:   50
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/de-sh_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sh_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-sh_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -121,7 +121,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 55.08 E 8.156
-BoundingBoxButtomRightWGS84: N 53.34 E 11.33
+BoundingBoxBottomRightWGS84: N 53.34 E 11.33
 MinScale:   0
 MaxScale:   150
 RecommendedScale:    1 2.5 5 10 16

Added: branches/r1.2/res_noewe/webmapservices/de-sl-t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sl-t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de-sl-t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,38 @@
+TakenFromUrl:       <A HREF="http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?">http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?</A>
+GetCapabilitiesUrl: <A HREF="http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               de.Saarland t
+MapType:                        topo
+MainUrl:            <A HREF="http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?">http://geoportal.lkvk.saarland.de/freewms/uebersichtsl?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  31466 31467
+CoordinateReferenceSystemUrlPart: SRS=EPSG:31466 SRS=EPSG:31467
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=Saarland|SL_UEBERSICHT||
+#LayersUrlPart:     LAYERS=landesflaeche|Landesflaeche||
+#LayersUrlPart:     LAYERS=gruenland|Gruenland||
+#LayersUrlPart:     LAYERS=industrie|Industrie||
+#LayersUrlPart:     LAYERS=wald|Wald||
+#LayersUrlPart:     LAYERS=sonderkultur|Sonderkulturen||
+#LayersUrlPart:     LAYERS=ortslagen|Ortslagen||
+#LayersUrlPart:     LAYERS=gewaesser|Gewaesser||
+#LayersUrlPart:     LAYERS=weg|Wege||
+#LayersUrlPart:     LAYERS=strasse|Strassen||
+#LayersUrlPart:     LAYERS=gemeindestrasse|Gemeindestrassen||
+#LayersUrlPart:     LAYERS=kreisstrasse|Kreisstrassen||
+#LayersUrlPart:     LAYERS=landesstrasse|Landesstrassen||
+#LayersUrlPart:     LAYERS=bundesstrasse|Bundesstrassen||
+#LayersUrlPart:     LAYERS=autobahn|Autobahnen||
+#LayersUrlPart:     LAYERS=bahn|Bahn||
+#LayersUrlPart:     LAYERS=orte|Orte||
+#LayersUrlPart: LAYERS=Saarland,landesflaeche,gruenland,industrie,wald,sonderkultur,ortslagen,gewaesser,weg,strasse,gemeindestrasse,kreisstrasse,landesstrasse,bundesstrasse,autobahn,bahn,orte
+LayersUrlPart:		LAYERS=Saarland
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 49.6445 E 6.3553
+BoundingBoxBottomRightWGS84: N 49.1094 E 7.4138
+#BBox_Mitte: N 49.37695 E 6.88454
+MinScale:   0.2
+MaxScale:   200
+RecommendedScale:    9 2
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/de-sn_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sn_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-sn_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -15,7 +15,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84: N 50.0294 E 15.1358
+BoundingBoxBottomRightWGS84: N 50.0294 E 15.1358
 #BBox_Mitte: N 50.9443 E 13.45045
 MinScale:   0.2
 MaxScale:   10

Modified: branches/r1.2/res_noewe/webmapservices/de-sn_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-sn_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-sn_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.8592 E 11.7651
-BoundingBoxButtomRightWGS84: N 50.0294 E 15.1358
+BoundingBoxBottomRightWGS84: N 50.0294 E 15.1358
 #BBox_Mitte: N 50.9443 E 13.45045
 MinScale:   0.5
 MaxScale:   70

Modified: branches/r1.2/res_noewe/webmapservices/de-st_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-st_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-st_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -75,7 +75,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 53.2226 E 10.5012
-BoundingBoxButtomRightWGS84: N 50.5272 E 13.4957
+BoundingBoxBottomRightWGS84: N 50.5272 E 13.4957
 #BBox_Mitte: N 51.874924375 E 11.9984684985
 MinScale:   0
 MaxScale:   25

Modified: branches/r1.2/res_noewe/webmapservices/de-st_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-st_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-st_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -75,7 +75,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.2226 E 10.5012
-BoundingBoxButtomRightWGS84: N 50.5272 E 13.4957
+BoundingBoxBottomRightWGS84: N 50.5272 E 13.4957
 #BBox_Mitte: N 51.874924375 E 11.9984684985
 MinScale:   0
 MaxScale:   12

Modified: branches/r1.2/res_noewe/webmapservices/de-st_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-st_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-st_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -75,7 +75,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 53.2226 E 10.5012
-BoundingBoxButtomRightWGS84: N 50.5272 E 13.4957
+BoundingBoxBottomRightWGS84: N 50.5272 E 13.4957
 #BBox_Mitte: N 51.874924375 E 11.9984684985
 MinScale:   5
 MaxScale:   90

Modified: branches/r1.2/res_noewe/webmapservices/de-th_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de-th_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de-th_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -349,7 +349,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 51.7 E 10.3
-BoundingBoxButtomRightWGS84: N 50.1 E 12.7
+BoundingBoxBottomRightWGS84: N 50.1 E 12.7
 MinScale:   1
 MaxScale:   12
 RecommendedScale:   2,5

Added: branches/r1.2/res_noewe/webmapservices/de_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de_t25.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,19 @@
+TakenFromUrl:       map.adfc-tourenportal.de = 195.66.99.21
+GetCapabilitiesUrl: doesn't work
+Name:               ADFC Tourenportal t25
+MapType:                        topo
+MainUrl:            <A HREF="http://195.66.99.21/mm-mapserver_v2/wms/wms.php?">http://195.66.99.21/mm-mapserver_v2/wms/wms.php?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
+RequestUrlPart:     REQUEST=GetMap
+LayersUrlPart:     LAYERS=MM_TOPO
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/gif
+BoundingBoxTopLeftWGS84: N 55.7319 E 4.6186
+BoundingBoxBottomRightWGS84: N 45.9690 E 16.7118
+MinScale:   3.5
+MaxScale:   3.6
+RecommendedScale:    2.5
+ImageFileExtension: .gif

Modified: branches/r1.2/res_noewe/webmapservices/de_t2500.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de_t2500.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/de_t2500.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,8 +13,8 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 55.7319 E 4.6186
-BoundingBoxButtomRightWGS84: N 45.9690 E 16.7118
+BoundingBoxBottomRightWGS84: N 45.9690 E 16.7118
 MinScale:   50
-MaxScale:   350
-RecommendedScale:    150
+MaxScale:   400
+RecommendedScale:    250 100 200 300
 ImageFileExtension: .png

Added: branches/r1.2/res_noewe/webmapservices/de_t_itc.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/de_t_itc.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/de_t_itc.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,34 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://osmwms.itc-halle.de/maps/osmfree?SERVICE=WMS&amp;">http://osmwms.itc-halle.de/maps/osmfree?SERVICE=WMS&amp;</A>
+GetCapabilitiesUrl: <A HREF="http://osmwms.itc-halle.de/maps/osmfree?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://osmwms.itc-halle.de/maps/osmfree?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               de OSM(ITC Halle)  t
+MapType:                        topo
+MainUrl:            <A HREF="http://osmwms.itc-halle.de/maps/osmfree?">http://osmwms.itc-halle.de/maps/osmfree?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=osmwms|OpenStreetMap-WMS||
+#LayersUrlPart:     LAYERS=grenzen|Administrative Grenzen||
+#LayersUrlPart:     LAYERS=flaechen|Fl&#195;&#164;chen (M 1:5000)||
+#LayersUrlPart:     LAYERS=gebaeude|Geb&#195;&#164;udefl&#195;&#164;chen (M1:50000)||
+#LayersUrlPart:     LAYERS=wasser|Wasserstrassen (M 1:100000000)||
+#LayersUrlPart:     LAYERS=schienen|Bahn (M 1:10000000)||
+#LayersUrlPart:     LAYERS=strassen|Strassen und Wege (M 1:100000000)||
+#LayersUrlPart:     LAYERS=Wanderwege|Wanderwege (M 1:100000000)|0|49890.2848429637
+#LayersUrlPart:     LAYERS=Radwanderwege|Radwanderwege_50000 (M 1:100000000)|0|49890.2848429637
+#LayersUrlPart:     LAYERS=power|Stromleitungen (M 1:100000)||
+#LayersUrlPart:     LAYERS=Funkmasten|Funkmasten||
+#LayersUrlPart:     LAYERS=Atomkraftwerke|Atomkraftwerke||
+#LayersUrlPart:     LAYERS=punkte|Punkte (M 1:20000)||
+#LayersUrlPart:     LAYERS=orte|Ortsnamen (M 1:100000000)||
+LayersUrlPart:     LAYERS=grenzen,flaechen,gebaeude,wasser,schienen,strassen,Wanderwege,Radwanderwege,orte
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 81.8600 W 31.2600
+BoundingBoxBottomRightWGS84: N 34.8100 E 69.0700
+#BBox_Mitte: N 58.335 E 18.905
+MinScale:   0.1
+MaxScale:   180
+RecommendedScale:   5 1 2.5 10 15 30 60
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,46 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://kortforsyningen.kms.dk/orto_foraar?">http://kortforsyningen.kms.dk/orto_foraar?</A>
+GetCapabilitiesUrl: <A HREF="http://kortforsyningen.kms.dk/service?servicename=orto_foraar&amp;&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://kortforsyningen.kms.dk/service?servicename=orto_foraar&amp;&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               dk p
+MapType:                        photo
+MainUrl:            <A HREF="http://kortforsyningen.kms.dk/service?servicename=orto_foraar&amp;&amp;login=kfmonitor&amp;password=kfmonitor&amp;">http://kortforsyningen.kms.dk/service?servicename=orto_foraar&amp;&amp;login=kfmonitor&amp;password=kfmonitor&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=orto_foraar|Ortofoto for&#195;&#165;r||
+#LayersUrlPart:     LAYERS=jylland2004_40cm|jylland2004_40cm||
+#LayersUrlPart:     LAYERS=fyn2005_40cm|fyn2005_40cm||
+#LayersUrlPart:     LAYERS=jylland2005_40cm|jylland2005_40cm||
+#LayersUrlPart:     LAYERS=jylland2006_40cm|jylland2006_40cm||
+#LayersUrlPart:     LAYERS=sjaelland2006_40cm|sjaelland2006_40cm||
+#LayersUrlPart:     LAYERS=sjaelland2006_10cm|sjaelland2006_10cm||
+#LayersUrlPart:     LAYERS=bornholm2006_40cm|bornholm2006_40cm||
+#LayersUrlPart:     LAYERS=jylland2007_20cm|jylland2007_20cm||
+#LayersUrlPart:     LAYERS=jylland2007_10cm|jylland2007_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2007_10cm|sjaelland2007_10cm||
+#LayersUrlPart:     LAYERS=jylland2008_20cm|jylland2008_20cm||
+#LayersUrlPart:     LAYERS=jylland2008_10cm|jylland2008_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2008_10cm|sjaelland2008_10cm||
+#LayersUrlPart:     LAYERS=jylland2009_20cm|jylland2009_20cm||
+#LayersUrlPart:     LAYERS=jylland2009_10cm|jylland2009_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2009_20cm|sjaelland2009_20cm||
+#LayersUrlPart:     LAYERS=sjaelland2009_10cm|sjaelland2009_10cm||
+#LayersUrlPart:     LAYERS=bornholm2010_hrks10cm|bornholm2010_hrks10cm||
+#LayersUrlPart:     LAYERS=fyn2010_20cm|fyn2010_20cm||
+#LayersUrlPart:     LAYERS=fyn2010_10cm|fyn2010_10cm||
+#LayersUrlPart:     LAYERS=jylland2010_20cm|jylland2010_20cm||
+#LayersUrlPart:     LAYERS=jylland2010_10cm|jylland2010_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2010_20cm|sjaelland2010_20cm||
+#LayersUrlPart:     LAYERS=sjaelland2010_10cm|sjaelland2010_10cm||
+#LayersUrlPart:     LAYERS=sjaelland2010_hrks10cm|sjaelland2010_hrks10cm||
+LayersUrlPart:     LAYERS=orto_foraar
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   0
+MaxScale:   25
+RecommendedScale:    1 4 8
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,21 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://kortforsyningen.kms.dk/topo_skaermkort?">http://kortforsyningen.kms.dk/topo_skaermkort?</A>
+GetCapabilitiesUrl: <A HREF="http://kortforsyningen.kms.dk/service?servicename=topo_skaermkort&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://kortforsyningen.kms.dk/service?servicename=topo_skaermkort&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               dk topo
+MapType:                        topo
+MainUrl:            <A HREF="http://kortforsyningen.kms.dk/service?servicename=topo_skaermkort&amp;login=kfmonitor&amp;password=kfmonitor&amp;">http://kortforsyningen.kms.dk/service?servicename=topo_skaermkort&amp;login=kfmonitor&amp;password=kfmonitor&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=dtk_skaermkort|DTK/Sk&#195;&#166;rmkort||
+LayersUrlPart:     LAYERS=dtk_skaermkort
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   0
+MaxScale:   20
+RecommendedScale:    4 1
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_t25.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://kortforsyningen.kms.dk/topo25?">http://kortforsyningen.kms.dk/topo25?</A>
+GetCapabilitiesUrl: <A HREF="http://kortforsyningen.kms.dk/service?servicename=topo25&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://kortforsyningen.kms.dk/service?servicename=topo25&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               dk t25
+MapType:                        topo
+MainUrl:            <A HREF="http://kortforsyningen.kms.dk/service?servicename=topo25&amp;login=kfmonitor&amp;password=kfmonitor&amp;">http://kortforsyningen.kms.dk/service?servicename=topo25&amp;login=kfmonitor&amp;password=kfmonitor&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=topo25_graa_2008|DTK/kort25 gr&#195;&#165; 2008||
+#LayersUrlPart:     LAYERS=topo25_daempet_2008|DTK/kort25 d&#195;&#166;mpet 2008||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2008|DTK/kort25 klassisk 2008||
+#LayersUrlPart:     LAYERS=topo25_graa_2007|DTK/kort25 gr&#195;&#165; 2007||
+#LayersUrlPart:     LAYERS=topo25_daempet_2007|DTK/kort25 d&#195;&#166;mpet 2007||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2007|DTK/kort25 klassisk 2007||
+#LayersUrlPart:     LAYERS=topo25_graa_2006|DTK/kort25 gr&#195;&#165; 2006||
+#LayersUrlPart:     LAYERS=topo25_daempet_2006|DTK/kort25 d&#195;&#166;mpet 2006||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2006|DTK/kort25 klassisk 2006||
+#LayersUrlPart:     LAYERS=topo25_graa_2005|DTK/kort25 gr&#195;&#165; 2005||
+#LayersUrlPart:     LAYERS=topo25_daempet_2005|DTK/kort25 d&#195;&#166;mpet 2005||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2005|DTK/kort25 klassisk 2005||
+#LayersUrlPart:     LAYERS=topo25_graa_2004|DTK/kort25 gr&#195;&#165; 2004||
+#LayersUrlPart:     LAYERS=topo25_daempet_2004|DTK/kort25 d&#195;&#166;mpet 2004||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2004|DTK/kort25 klassisk 2004||
+#LayersUrlPart:     LAYERS=topo25_daempet_2002|DTK/kort25 d&#195;&#166;mpet 2002||
+#LayersUrlPart:     LAYERS=topo25_klassisk_2002|DTK/kort25 klassisk 2002||
+#LayersUrlPart:     LAYERS=topo25_graa|DTK/kort25 gr&#195;&#165;||
+#LayersUrlPart:     LAYERS=topo25_daempet|DTK/kort25 d&#195;&#166;mpet||
+#LayersUrlPart:     LAYERS=topo25_klassisk|DTK/kort25 klassisk||
+LayersUrlPart:     LAYERS=topo25_klassisk
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   1
+MaxScale:   20
+RecommendedScale:    2.5 5
+ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/dk_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/dk_t50.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/dk_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,26 @@
+TakenFromUrl:       <A HREF="http://kortforsyningen.kms.dk/topo50?">http://kortforsyningen.kms.dk/topo50?</A>
+GetCapabilitiesUrl: <A HREF="http://kortforsyningen.kms.dk/service?servicename=topo50&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://kortforsyningen.kms.dk/service?servicename=topo50&amp;login=kfmonitor&amp;password=kfmonitor&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               dk t50
+MapType:                        topo
+MainUrl:            <A HREF="http://kortforsyningen.kms.dk/service?servicename=topo50&amp;login=kfmonitor&amp;password=kfmonitor&amp;">http://kortforsyningen.kms.dk/service?servicename=topo50&amp;login=kfmonitor&amp;password=kfmonitor&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=dtk_2cm_2007|DTK/kort50 2007|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2006|DTK/kort50 2006|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2005|DTK/kort50 2005|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2004|DTK/kort50 2004|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm_2002|DTK/kort50 2002|0.000000|0.000000
+#LayersUrlPart:     LAYERS=dtk_2cm|DTK/kort50|0.000000|0.000000
+LayersUrlPart:     LAYERS=dtk_2cm
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+BoundingBoxTopLeftWGS84: N 58.4744 E 2.4783
+BoundingBoxBottomRightWGS84: N 53.0150 E 17.5575
+#BBox_Mitte: N 55.7447 E 10.017915
+MinScale:   1
+MaxScale:   20
+RecommendedScale:    5 4 6
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/es-an_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-an_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-an_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 38.748  W 7.587
-BoundingBoxButtomRightWGS84:   N 35.947 W 1.602
+BoundingBoxBottomRightWGS84:   N 35.947 W 1.602
 MinScale:   0
 MaxScale:   49.8902848429637
 RecommendedScale:   1.000

Modified: branches/r1.2/res_noewe/webmapservices/es-an_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-an_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-an_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 38.748  W 7.587
-BoundingBoxButtomRightWGS84:   N 35.947 W 1.602
+BoundingBoxBottomRightWGS84:   N 35.947 W 1.602
 MinScale:   0
 MaxScale:   49.8902848429637
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es-an_t1.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-an_t1.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-an_t1.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 38.748  W 7.587
-BoundingBoxButtomRightWGS84:   N 35.947 W 1.602
+BoundingBoxBottomRightWGS84:   N 35.947 W 1.602
 MinScale:   0
 MaxScale:   49.8902848429637
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es-ar_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-ar_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-ar_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -27,7 +27,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 42.945  W 2.19
-BoundingBoxButtomRightWGS84:   N 39.813 E 0.805
+BoundingBoxBottomRightWGS84:   N 39.813 E 0.805
 MinScale:   0
 MaxScale:   72
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/es-ar_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-ar_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-ar_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -27,7 +27,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 42.945  W 2.19
-BoundingBoxButtomRightWGS84:   N 39.813 E 0.805
+BoundingBoxBottomRightWGS84:   N 39.813 E 0.805
 MinScale:   0
 MaxScale:   72
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/es-cn_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-cn_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-cn_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 29.8305 W 18.3099
-BoundingBoxButtomRightWGS84: N 26.1839 W 13.1373
+BoundingBoxBottomRightWGS84: N 26.1839 W 13.1373
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/es-cn_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-cn_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-cn_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 29.8305 W 18.3099
-BoundingBoxButtomRightWGS84:   N 26.1839 W 13.137
+BoundingBoxBottomRightWGS84:   N 26.1839 W 13.137
 MinScale:   1.49671
 MaxScale:   174.0000
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es-cn_ts.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 29.8305 W 18.3099
-BoundingBoxButtomRightWGS84:   N 26.1839 W 13.137
+BoundingBoxBottomRightWGS84:   N 26.1839 W 13.137
 MinScale:   0
 MaxScale:   2500.0000
 RecommendedScale:   5.000

Modified: branches/r1.2/res_noewe/webmapservices/es_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -15,7 +15,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 45.2863 W 18.1621
-BoundingBoxButtomRightWGS84: N 21.8992 E 6.2893
+BoundingBoxBottomRightWGS84: N 21.8992 E 6.2893
 MinScale:   0
 MaxScale:   10
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/es_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/es_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/es_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -13,7 +13,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 44.3814 W 18.3276
-BoundingBoxButtomRightWGS84: N 27.0611 E 6.6826
+BoundingBoxBottomRightWGS84: N 27.0611 E 6.6826
 MinScale:   2
 MaxScale:   80
 RecommendedScale:    2.5 5 15 30 

Modified: branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/eu_t_osm_wheregroup.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -59,7 +59,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 74.1000 W 10.4000
-BoundingBoxButtomRightWGS84: N 35.7000 E 43.0000
+BoundingBoxBottomRightWGS84: N 35.7000 E 43.0000
 #BBox_Mitte: N 54.9 E 16.3
 MinScale: 0.6
 MaxScale: 99.99

Added: branches/r1.2/res_noewe/webmapservices/fr_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/fr_t.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/fr_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,90 @@
+&#239;&#187;&#191;TakenFromUrl:       <A HREF="http://mapdmz.brgm.fr/cgi-bin/mapserv?map=/carto/infoterre/mapFiles/geocat_metr.map&amp;">http://mapdmz.brgm.fr/cgi-bin/mapserv?map=/carto/infoterre/mapFiles/geocat_metr.map&amp;</A>
+GetCapabilitiesUrl: <A HREF="http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               fr + (Guadeloupe..Polynesie) t
+MapType:                        topo
+MainUrl:            <A HREF="http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&amp;">http://mapdmz.brgm.fr/cgi-bin/mapserv54?map=/carto/infoterre/mapFiles/geocat_metr.map&amp;</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=METROPOLE|Fonds Geosignal|1.24725712107409|0
+#LayersUrlPart:     LAYERS=raster_geosignal|raster_geosignal||
+#LayersUrlPart:     LAYERS=WORLD_COUNTRIES_FR|Limites du monde|1496.70854528891|0
+#LayersUrlPart:     LAYERS=HydroSurf|Hydrographie surfacique - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=HydroLigne|Hydrographie lineaire - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=Routes|Reseau routier - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=fer|Reseau ferre - France metropolitaine|0|37.4182125350712
+#LayersUrlPart:     LAYERS=Communes|Communes - France metropolitaine|0|37.4182125350712
+
+#LayersUrlPart:     LAYERS=RASTER4000k|Raster Metropole 1/4 000 000|997.805696859274|4989.02848429637
+#LayersUrlPart:     LAYERS=RASTER1000k|Raster Metropole 1/1 000 000|374.177136322228|997.805696859274
+#LayersUrlPart:     LAYERS=RASTER500k_01|Raster Metropole 1/500 000|199.561139371855|374.177136322228
+#LayersUrlPart:     LAYERS=RASTER250k_01|Raster Metropole 1/250 000|99.7805696859274|199.561139371855
+#LayersUrlPart:     LAYERS=RASTER175k|Raster Metropole 1/175 000|62.3628560537046|99.7805696859274
+#LayersUrlPart:     LAYERS=RASTER100k_01|Raster Metropole 1/100 000|37.4177136322228|62.3628560537046
+#LayersUrlPart:     LAYERS=RASTER50k_01|Raster Metropole 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_01|Raster Metropole 1/25 000|6.23628560537046|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER10k|Raster Metropole 1/10 000|3.74177136322228|6.23628560537046
+#LayersUrlPart:     LAYERS=RASTER5k_01|Raster Metropole 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_02|Raster Guadeloupe 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_02|Raster Guadeloupe 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_02|Raster Guadeloupe 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_02|Raster Guadeloupe 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_02|Raster Guadeloupe 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_01|Raster Guadeloupe 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_02|Raster Guadeloupe 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_03|Raster Guyane 1/500 000|174.615996950373|4989.02848429637
+#LayersUrlPart:     LAYERS=RASTER250k_03|Raster Guyane 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_03|Raster Guyane 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_03|Raster Guyane 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_03|Raster Guyane 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_02|Raster Guyane 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_03|Raster Guyane 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_04|Raster Martinique 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_04|Raster Martinique 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_04|Raster Martinique 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_04|Raster Martinique 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_04|Raster Martinique 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_03|Raster Martinique 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_04|Raster Martinique 1/5 000|0|3.74177136322228
+
+#LayersUrlPart:     LAYERS=RASTER500k_05|Raster La Reunion 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_05|Raster La Reunion 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_05|Raster La Reunion 1/100 000|37.4177136322228|74.8354272644456
+#LayersUrlPart:     LAYERS=RASTER50k_05|Raster La Reunion 1/50 000|17.4615996950373|37.4177136322228
+#LayersUrlPart:     LAYERS=RASTER25k_05|Raster La Reunion 1/25 000|7.48354272644456|17.4615996950373
+#LayersUrlPart:     LAYERS=RASTER12_5k_04|Raster La Reunion 1/12 500|3.74177136322228|7.48354272644456
+#LayersUrlPart:     LAYERS=RASTER5k_05|Raster La Reunion 1/5 000|0|7.48354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_06|Raster Mayotte 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_06|Raster Mayotte 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_06|Raster Mayotte 1/100 000|0|74.8354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_07|Raster caledonie 1/500 000|174.615996950373|1496.70854528891
+#LayersUrlPart:     LAYERS=RASTER250k_07|Raster caledonie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_07|Raster caledonie 1/100 000|0|74.8354272644456
+
+#LayersUrlPart:     LAYERS=RASTER500k_08|Raster Polynesie 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_08|Raster Polynesie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_08|Raster Polynesie 1/100 000|0|1496.70854528891
+#LayersUrlPart:     LAYERS=RASTER500k_09|Raster Polynesie 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_09|Raster Polynesie 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_09|Raster Polynesie 1/100 000|0|1496.70854528891
+
+#LayersUrlPart:     LAYERS=RASTER500k_10|Raster Saint-Pierre et Miquelon 1/500 000|174.615996950373|498.902848429637
+#LayersUrlPart:     LAYERS=RASTER250k_10|Raster Saint-Pierre et Miquelon 1/250 000|74.8354272644456|174.615996950373
+#LayersUrlPart:     LAYERS=RASTER100k_10|Raster Saint-Pierre et Miquelon 1/100 000|0|74.8354272644456
+LayersUrlPart:     LAYERS=raster_geosignal
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/jpeg
+#BoundingBoxTopLeftWGS84: N 51.1007 W 5.8482
+#BoundingBoxBottomRightWGS84: N 41.1326 E 11.1984
+#BBox_Mitte: N 46.11665 E 2.67511
+MinScale:   0
+MaxScale:   100
+RecommendedScale:   1 5
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/hu-gs_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #HU Gyor-Moson-Sopron
 BoundingBoxTopLeftWGS84: N 48.027490 E 16.421143
-BoundingBoxButtomRightWGS84: N 47.392132 E 17.953978
+BoundingBoxBottomRightWGS84: N 47.392132 E 17.953978
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/hu-va_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #HU Vas
 BoundingBoxTopLeftWGS84: N 47.46660 E 16.11368
-BoundingBoxButtomRightWGS84: N 46.72205 E 17.33420
+BoundingBoxBottomRightWGS84: N 46.72205 E 17.33420
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Added: branches/r1.2/res_noewe/webmapservices/it-25_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-25_p.wms	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/it-25_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,22 @@
+TakenFromUrl:       <A HREF="http://10.220.56.127/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer">http://10.220.56.127/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer</A>
+GetCapabilitiesUrl: <A HREF="http://www.cartografia.regione.lombardia.it/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://www.cartografia.regione.lombardia.it/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               it.lombardia p
+MapType:                        photo
+MainUrl:            <A HREF="http://www.cartografia.regione.lombardia.it/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer?">http://www.cartografia.regione.lombardia.it/ArcGIS93/services/wms/ortofoto_UTM32N_wms/MapServer/WMSServer?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
+CoordinateReferenceSystemCacheWolf:  4326
+CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=0|lombardia2007wgs84.ecw||
+#LayersUrlPart:     LAYERS=1|Province||
+LayersUrlPart:     LAYERS=0
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/png
+BoundingBoxTopLeftWGS84: N 46.7475 E 8.2398
+BoundingBoxBottomRightWGS84: N 44.5181 E 11.7416
+#BBox_Mitte: N 45.632761 E 9.990684
+MinScale:   0.3453
+MaxScale:   2.7621
+RecommendedScale:    1
+ImageFileExtension: .png

Modified: branches/r1.2/res_noewe/webmapservices/it-52_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-52_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-52_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -284,7 +284,7 @@
 StylesUrlPart:   STYLES=Default,Default,Default,Default,Default,Default,Default,Default
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 44.500805 E 9.642548
-BoundingBoxButtomRightWGS84:   N 42.168745 E 12.462359
+BoundingBoxBottomRightWGS84:   N 42.168745 E 12.462359
 MinScale:   0
 MaxScale:   70
 # maxscale 14.14214

Modified: branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-52_t10bw.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -283,7 +283,7 @@
 StylesUrlPart:   STYLES=Default,Default,Default,Default,Default,Default,Default,Default
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 44.500805 E 9.642548
-BoundingBoxButtomRightWGS84:   N 42.168745 E 12.462359
+BoundingBoxBottomRightWGS84:   N 42.168745 E 12.462359
 MinScale:   0
 MaxScale:   71
 #Scale 2 and 3 are scaled versions of scale 1. Scale 5 and 6 are scaled versions of scale 4

Modified: branches/r1.2/res_noewe/webmapservices/it-88_m.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-88_m.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-88_m.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -12,7 +12,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 41.400307 E 7.964019
-BoundingBoxButtomRightWGS84:   N 38.792131 E 10.022418
+BoundingBoxBottomRightWGS84:   N 38.792131 E 10.022418
 MinScale:   1
 MaxScale:   3
 #RecommendedScale:   1.000 sonst kann man die Topodaten nicht lesen bzw es werden keine Fotos geladen

Modified: branches/r1.2/res_noewe/webmapservices/it-88_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-88_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-88_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,20 +1,26 @@
-TakenFromUrl:   <A HREF="http://wiki.gfoss.it/index.php/GIS_Open_Data#Italia">http://wiki.gfoss.it/index.php/GIS_Open_Data#Italia</A>
-GetCapabilitiesUrl:   <A HREF="http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?request=getcapabilities&amp;service=WMS&amp;version=1.1.1">http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?request=getcapabilities&amp;service=WMS&amp;version=1.1.1</A>
-Name:   it.Sardinien photo
-MapType:   photo
-MainUrl:   <A HREF="http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?">http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?</A>
-ServiceTypeUrlPart:   SERVICE=WMS
-VersionUrlPart:   VERSION=1.1.1
+TakenFromUrl:       <A HREF="http://webgis.regione.sardegna.it:80/wmsconnector/com.esri.wms.Esrimap/ras_wms?">http://webgis.regione.sardegna.it:80/wmsconnector/com.esri.wms.Esrimap/ras_wms?</A>
+GetCapabilitiesUrl: <A HREF="http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               it.sardegna p
+MapType:                        photo
+MainUrl:            <A HREF="http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?">http://webgis.regione.sardegna.it/wmsconnector/com.esri.wms.Esrimap/ras_wms?</A>
+ServiceTypeUrlPart: SERVICE=WMS
+VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326
-RequestUrlPart:   REQUEST=GetMap
-LayersUrlPart:   LAYERS=ortofoto_it_2006
-StylesUrlPart:   STYLES=
-ImageFormatUrlPart:   FORMAT=image/png
-BoundingBoxTopLeftWGS84:   N 41.400307 E 7.964019
-BoundingBoxButtomRightWGS84:   N 38.792131 E 10.022418
-MinScale:   4
-MaxScale:   6
-# RecommendedScale:   1.000
-RecommendedScale:   4
+RequestUrlPart:     REQUEST=GetMap
+#LayersUrlPart:     LAYERS=ortofoto_it_2000|Ortofoto IT2000||
+#LayersUrlPart:     LAYERS=ortofoto_it_2006|Ortofoto IT2006||
+#LayersUrlPart:     LAYERS=Carta fisica|Carta fisica||
+#LayersUrlPart:     LAYERS=CTR10K raster|CTR10K raster||
+#LayersUrlPart:     LAYERS=IKONOS_RGB_Mosaico_Sardegna|IKONOS Mosaico RGB||
+#LayersUrlPart:     LAYERS=orto2k_totale|Ortofoto 2K||
+LayersUrlPart:     LAYERS=ortofoto_it_2006
+StylesUrlPart:     STYLES=
+ImageFormatUrlPart:FORMAT=image/png
+BoundingBoxTopLeftWGS84: N 41.4003 E 7.9640
+BoundingBoxBottomRightWGS84: N 38.7921 E 10.0224
+#BBox_Mitte: N 40.0962197844 E 8.99321880565
+MinScale:   0.3453
+MaxScale:   2.7621
+RecommendedScale:    1 0.5 1.5
 ImageFileExtension: .png

Modified: branches/r1.2/res_noewe/webmapservices/it-88_t10.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it-88_t10.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it-88_t10.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -22,7 +22,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 41.400307 E 7.964019
-BoundingBoxButtomRightWGS84:   N 38.792131 E 10.022418
+BoundingBoxBottomRightWGS84:   N 38.792131 E 10.022418
 MinScale:   1
 MaxScale:   3
 #RecommendedScale:   1 - 2.000 bei gr&#246;sserer Skalierung wird es un&#252;bersichtlich

Modified: branches/r1.2/res_noewe/webmapservices/it_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -16,7 +16,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 48.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 36.0000 E 19.0000
+BoundingBoxBottomRightWGS84: N 36.0000 E 19.0000
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/it_t100.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it_t100.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it_t100.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -16,7 +16,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 48.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 36.0000 E 19.0000
+BoundingBoxBottomRightWGS84: N 36.0000 E 19.0000
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   10

Modified: branches/r1.2/res_noewe/webmapservices/it_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/it_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/it_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -19,9 +19,9 @@
 # .jpg appears white in sun-vm --&gt; use .gif, that works on both VMs 
 ImageFormatUrlPart:FORMAT=image/gif
 BoundingBoxTopLeftWGS84: N 48.0000 E 6.0000
-BoundingBoxButtomRightWGS84: N 36.0000 E 19.0000
+BoundingBoxBottomRightWGS84: N 36.0000 E 19.0000
 # min and maxScale found by testing the server (pfeffer 1-10-2009)
-MinScale:   0
-MaxScale:   6.6
-RecommendedScale:   2.5
+MinScale:   1
+MaxScale:   25
+RecommendedScale:   2.5 5 8
 ImageFileExtension: .gif

Modified: branches/r1.2/res_noewe/webmapservices/jp-t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/jp-t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/jp-t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -30,7 +30,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/png
 BoundingBoxTopLeftWGS84: N 45.576199 E 122.521907
-BoundingBoxButtomRightWGS84: N 20.424949 E 145.888782
+BoundingBoxBottomRightWGS84: N 20.424949 E 145.888782
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/no-no_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/no-no_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/no-no_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -165,7 +165,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 71.8912 W 2.5599
-BoundingBoxButtomRightWGS84: N 57.0881 E 33.0199
+BoundingBoxBottomRightWGS84: N 57.0881 E 33.0199
 #BBox_Mitte: N 64.48965 E 15.229995
 MinScale:   0
 MaxScale:   1000

Modified: branches/r1.2/res_noewe/webmapservices/pl_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/pl_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/pl_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -14,7 +14,7 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 54.8793 E 10.0579
-BoundingBoxButtomRightWGS84: N 48.3726 E 28.4862
+BoundingBoxBottomRightWGS84: N 48.3726 E 28.4862
 #BBox_Center: N 51.6259298143288 E 19.2720480387164
 MinScale:   0
 MaxScale:   24

Modified: branches/r1.2/res_noewe/webmapservices/pl_t50.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/pl_t50.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/pl_t50.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -37,7 +37,7 @@
 
 # pfeffer entered here the bounding box of Poland
 BoundingBoxTopLeftWGS84: N 54.84 E 14.121686
-BoundingBoxButtomRightWGS84: N 48.9996 E 24.1488
+BoundingBoxBottomRightWGS84: N 48.9996 E 24.1488
 MinScale:   1
 MaxScale:   11
 RecommendedScale:   5

Modified: branches/r1.2/res_noewe/webmapservices/pt_t500.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/pt_t500.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/pt_t500.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -12,10 +12,10 @@
 #LayersUrlPart:     LAYERS=sc500k|Carta de Portugal Continental 1:500.000|0.249451424214819|249451.424214819
 LayersUrlPart:     LAYERS=sc500k
 StylesUrlPart:     STYLES=
-ImageFormatUrlPart:FORMAT=image/png
+ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 42.2787 W 10.1943
-BoundingBoxButtomRightWGS84: N 36.7636 W 5.71067
+BoundingBoxBottomRightWGS84: N 36.7636 W 5.71067
 MinScale:   0
-MaxScale:   45
-RecommendedScale:   5
-ImageFileExtension: .png
+MaxScale:   100
+RecommendedScale:   50
+ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/region_at_hu_cz.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -32,7 +32,7 @@
 StylesUrlPart:   STYLES=
 ImageFormatUrlPart:   FORMAT=image/png
 BoundingBoxTopLeftWGS84:   N 49.027050  E 9.529250
-BoundingBoxButtomRightWGS84:   N 46.357433 E 17.202733
+BoundingBoxBottomRightWGS84:   N 46.357433 E 17.202733
 MinScale:   0
 MaxScale:   45
 RecommendedScale:   1

Modified: branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/sk-bl_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #SK Bratislava
 BoundingBoxTopLeftWGS84: N 48.659222 E 16.819382
-BoundingBoxButtomRightWGS84: N 48.009865 E 17.517636
+BoundingBoxBottomRightWGS84: N 48.009865 E 17.517636
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/sk-ta_t25.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,14 +84,14 @@
 ImageFormatUrlPart:FORMAT=image/png
 #Server
 #BoundingBoxTopLeftWGS84: N 51.2574 E 7.8974
-#BoundingBoxButtomRightWGS84: N 43.9529 E 24.7863
+#BoundingBoxBottomRightWGS84: N 43.9529 E 24.7863
 #BBox_Mitte: N 47.60515 E 16.341865
 #real
 #BoundingBoxTopLeftWGS84: N 49.85157 E 13.44451
-#BoundingBoxButtomRightWGS84: N 46.72608 E 18.08012
+#BoundingBoxBottomRightWGS84: N 46.72608 E 18.08012
 #SK Tyrnauer
 BoundingBoxTopLeftWGS84: N 48.882582 E 16.927528
-BoundingBoxButtomRightWGS84: N 47.75606 E 18.08583
+BoundingBoxBottomRightWGS84: N 47.75606 E 18.08583
 #MinScale:   1
 #MaxScale:   26
 RecommendedScale:   2.5

Modified: branches/r1.2/res_noewe/webmapservices/us_p.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/us_p.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/us_p.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,22 +1,21 @@
-TakenFromUrl:       <A HREF="http://terraservice.net/">http://terraservice.net/</A>
-GetCapabilitiesUrl: <A HREF="http://terraservice.net/ogccapabilities.ashx?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://terraservice.net/ogccapabilities.ashx?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
-Name:               USA photo
-MapType:                        photo
-MainUrl:            <A HREF="http://terraservice.net/ogcwms.aspx?">http://terraservice.net/ogcwms.aspx?</A>
+TakenFromUrl:       <A HREF="http://igskmncngs617.cr.usgs.gov/arcgis/services/baseline/ImageServer/WMSServer">http://igskmncngs617.cr.usgs.gov/arcgis/services/baseline/ImageServer/WMSServer</A>
+GetCapabilitiesUrl: <A HREF="http://isse.cr.usgs.gov/ArcGIS/services/Baseline/ImageServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://isse.cr.usgs.gov/ArcGIS/services/Baseline/ImageServer/WMSServer?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
+Name:               USA p
+MapType:            photo
+MainUrl:            <A HREF="http://isse.cr.usgs.gov/ArcGIS/services/Baseline/ImageServer/WMSServer?">http://isse.cr.usgs.gov/ArcGIS/services/Baseline/ImageServer/WMSServer?</A>
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf:  4326
 CoordinateReferenceSystemUrlPart: SRS=EPSG:4326 
 RequestUrlPart:     REQUEST=GetMap
-#LayersUrlPart:     LAYERS=DOQ|USGS Digital Ortho-Quadrangles||
-#LayersUrlPart:     LAYERS=DRG|USGS Raster Graphics (Topo Maps)||
-#LayersUrlPart:     LAYERS=UrbanArea|USGS Urban Areas Ortho-Imagery||
-LayersUrlPart:     LAYERS=DOQ
+#LayersUrlPart:     LAYERS=0|IGSKMNCNGS617/baseline||
+LayersUrlPart:     LAYERS=0
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
-BoundingBoxTopLeftWGS84: N 71.5500 W 168.6700
-BoundingBoxButtomRightWGS84: N 17.8400 W 65.1500
+BoundingBoxTopLeftWGS84: N 81.9971 W 170.9250
+BoundingBoxBottomRightWGS84: N 6.2961 W 50.8429
+#BBox_Mitte: N 44.146614 W 110.883977
 MinScale:   0
-MaxScale:   45
-RecommendedScale:   5
+MaxScale:   20
+RecommendedScale:    1 0.5 2
 ImageFileExtension: .jpg

Modified: branches/r1.2/res_noewe/webmapservices/us_t.wms
===================================================================
--- branches/r1.2/res_noewe/webmapservices/us_t.wms	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/res_noewe/webmapservices/us_t.wms	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,8 +1,8 @@
 TakenFromUrl:       <A HREF="http://terraservice.net/">http://terraservice.net/</A>
 GetCapabilitiesUrl: <A HREF="http://terraservice.net/ogccapabilities.ashx?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities">http://terraservice.net/ogccapabilities.ashx?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</A>
-Name:               USA topo
-MapType:                        topo
-MainUrl:            <A HREF="http://terraservice.net/ogcwms.aspx?">http://terraservice.net/ogcwms.aspx?</A>
+Name:               USA t
+MapType:            topo
+MainUrl:            <A HREF="http://terraservice.net/ogcmap.ashx?">http://terraservice.net/ogcmap.ashx?</A>
 ServiceTypeUrlPart: SERVICE=WMS
 VersionUrlPart:     VERSION=1.1.1
 CoordinateReferenceSystemCacheWolf:  4326
@@ -15,8 +15,8 @@
 StylesUrlPart:     STYLES=
 ImageFormatUrlPart:FORMAT=image/jpeg
 BoundingBoxTopLeftWGS84: N 71.5500 W 168.6700
-BoundingBoxButtomRightWGS84: N 17.8400 W 65.1500
+BoundingBoxBottomRightWGS84: N 17.8400 W 65.1500
 MinScale:   0
 MaxScale:   45
-RecommendedScale:   5
+RecommendedScale:   2.5 5 10
 ImageFileExtension: .jpg

Added: branches/r1.2/res_noewe/webmapservices/wfl-format.txt
===================================================================
--- branches/r1.2/res_noewe/webmapservices/wfl-format.txt	                        (rev 0)
+++ branches/r1.2/res_noewe/webmapservices/wfl-format.txt	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,34 @@
+f0 affine lat x
+f1 affine lon x
+f2 affine lat y
+f3 affine lon y
+topleft.lat
+topleft.lon
+bottomright.lat
+bottomright.lon
+EPSG - Code
+
+
+
+
+
+Berechnung der Koordinaten ll aus einem Bildpunkt (x,y)
+		ll.lat = x * f0 + y * f2 + topleft.lat;
+		ll.lon = x * f1 + y * f3 + topleft.lon;
+
+Berechnung 
+			//calculate reverse affine
+			double nenner=(-f1*f2+f0*f3);
+			transLatX = f3/nenner; // nenner == 0 cannot happen as long als affine is correct
+			transLonX = -f2/nenner;
+			transLatY = -f1/nenner;
+			transLonY = f0/nenner;
+
+Berechnung Bildpunkt x,y aus Koordinaten t
+		x = (int)Math.round(transLatX * (t.latDec - topleft.lat) + transLonX * (t.lonDec - topleft.lon));
+		y = (int)Math.round(transLatY * (t.latDec - topleft.lat) + transLonY * (t.lonDec - topleft.lon));
+
+Beispiel
+Berechnung f2,f1 vereinfacht bei f0,f3=0(keineDrehung) Bildgr&#246;sse 500x500
+(bottomright.lon-topleft.lon)/499=f1
+(bottomright.lat-topleft.lat)/499=f2

Added: branches/r1.2/resources/archived.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/archived.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/bonus.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/bonus.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/disabled.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/disabled.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/dnf.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/dnf.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/found.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/found.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/owned.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/owned.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: branches/r1.2/resources/solved.png
===================================================================
(Binary files differ)


Property changes on: branches/r1.2/resources/solved.png
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Modified: branches/r1.2/src/CacheWolf/Attribute.java
===================================================================
--- branches/r1.2/src/CacheWolf/Attribute.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Attribute.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.mImage;
@@ -30,331 +30,372 @@
 
 /**
  * This class represents a single attribute
+ * 
  * @author skg
- *
+ * 
  */
 public class Attribute {
 	// Constructors
-	public Attribute(int id, int inc) {_Id=id;setInc(inc);setIdBit();}
-	public Attribute(String attributeName) { attName2attNo(attributeName); setIdBit();}
-	public Attribute(int attIdOC) { OCAttNo2attNo(attIdOC); setIdBit();}
-	public Attribute(int attIdGC, String Yes1No0) { GCAttNo2attNo(attIdGC, Yes1No0); setIdBit();}
+	public Attribute(int id, int inc) {
+		_Id = id;
+		setInc(inc);
+		setIdBit();
+	}
+
+	public Attribute(String attributeName) {
+		attName2attNo(attributeName);
+		setIdBit();
+	}
+
+	public Attribute(int attIdOC) {
+		OCAttNo2attNo(attIdOC);
+		setIdBit();
+	}
+
+	public Attribute(int attIdGC, String Yes1No0) {
+		GCAttNo2attNo(attIdGC, Yes1No0);
+		setIdBit();
+	}
+
 	// Constructors end
 	private int _Id;
 	private int _Inc; // Yes=1 No=0 non=2
 	private String _ImageName;
-	private long[] _bit = {0l,0l};
+	private long[] _bit = { 0l, 0l };
+
 	// for GC Constructor Spider
 	private void attName2attNo(String attributeName) {
-    	for (int i=0; i&lt;maxAttRef; i++) {
-    		if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
-				_Id=i;
-				_Inc=attributeName.toLowerCase().endsWith(&quot;-no.gif&quot;) ? 0 : 1;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attributeName.toLowerCase().startsWith(attRef[i][PIC_NAME])) {
+				_Id = i;
+				_Inc = attributeName.toLowerCase().endsWith(&quot;-no.gif&quot;) ? 0 : 1;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName=&quot;error.gif&quot;;
-    	}
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = &quot;error.gif&quot;;
+	}
+
 	// for OC Constructor
-    private void OCAttNo2attNo(int attIdOC) {
-    	for (int i=0; i&lt;maxAttRef; i++) {
-    		if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
-				_Id=i;
-				_Inc=1;
-				_ImageName=attRef[i][PIC_NAME]+&quot;-yes.gif&quot;;
+	private void OCAttNo2attNo(int attIdOC) {
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attIdOC == Common.parseInt(attRef[i][OC_ID])) {
+				_Id = i;
+				_Inc = 1;
+				_ImageName = attRef[i][PIC_NAME] + &quot;-yes.gif&quot;;
 				return;
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName=&quot;error.gif&quot;;
-    }
-    // for GC Constructor gpx-Import
-    private void GCAttNo2attNo(int attIdGC, String Yes1No0 ) {
-    	for (int i=0; i&lt;maxAttRef; i++) {
-    		if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
-				_Id=i;
-    			_Inc=Yes1No0.equals(&quot;1&quot;) ? 1 : 0;
-				_ImageName=attRef[i][PIC_NAME]+(_Inc==0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
-				return;				
-    		}
-    	}
-    	_Id=-1; // Error
-    	_ImageName=&quot;error.gif&quot;;
-    }
-    // used by all Constructors
-    private void setIdBit() {
-    	_bit=getIdBit(_Id);
-    }
-    // checking for array limits (caus -1 is possible value)
-    private static String attRef(int row, int column ) {
-    	if (row &gt; -1 &amp;&amp; row &lt; maxAttRef) {
-    		return attRef[row][column];
-    	}
-    	else {
-    		return &quot;&quot;;
-    	}
-    }
-    // *** public part
-    public static long[] getIdBit(int id) {
-    	long [] bit = new long[2];
-    	if (id&gt;-1 &amp;&amp; id&lt;maxAttRef) {
-        	int b = Common.parseInt(attRef[id][BIT_NR]);
-    		bit[0] = b&gt;63 ? 0l : (1L &lt;&lt; b);
-    		bit[1] = b&gt;63 ? (1L &lt;&lt; b-64) : 0;
-    	}
-    	else {
-        	bit[0]=0;
-        	bit[1]=0;
-    	}
-    	return bit;
-    }    
-    /**
-     * get GC_TEXT string
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = &quot;error.gif&quot;;
+	}
+
+	// for GC Constructor gpx-Import
+	private void GCAttNo2attNo(int attIdGC, String Yes1No0) {
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attIdGC == Common.parseInt(attRef[i][GC_ID])) {
+				_Id = i;
+				_Inc = Yes1No0.equals(&quot;1&quot;) ? 1 : 0;
+				_ImageName = attRef[i][PIC_NAME] + (_Inc == 0 ? &quot;-no.gif&quot; : &quot;-yes.gif&quot;);
+				return;
+			}
+		}
+		_Id = -1; // Error
+		_ImageName = &quot;error.gif&quot;;
+	}
+
+	// used by all Constructors
+	private void setIdBit() {
+		_bit = getIdBit(_Id);
+	}
+
+	// checking for array limits (caus -1 is possible value)
+	private static String attRef(int row, int column) {
+		if (row &gt; -1 &amp;&amp; row &lt; maxAttRef) {
+			return attRef[row][column];
+		} else {
+			return &quot;&quot;;
+		}
+	}
+
+	// *** public part
+	public static long[] getIdBit(int id) {
+		long[] bit = new long[2];
+		if (id &gt; -1 &amp;&amp; id &lt; maxAttRef) {
+			int b = Common.parseInt(attRef[id][BIT_NR]);
+			bit[0] = b &gt; 63 ? 0l : (1L &lt;&lt; b);
+			bit[1] = b &gt; 63 ? (1L &lt;&lt; b - 64) : 0;
+		} else {
+			bit[0] = 0;
+			bit[1] = 0;
+		}
+		return bit;
+	}
+
+	/**
+	 * get GC_TEXT string
 	 */
-    public String getGCText () { return attRef(_Id,GC_TEXT); }
-    /**
-     * get GC_ID string
+	public String getGCText() {
+		return attRef(_Id, GC_TEXT);
+	}
+
+	/*
+     * 
+     */
+	public static String getIdFromGCText(String t) {
+		for (int i = 0; i &lt; maxAttRef; i++) {
+			if (attRef[i][GC_TEXT].equals(t)) {
+				return attRef[i][GC_ID];
+			}
+		}
+		return &quot;-1&quot;;
+	}
+
+	/**
+	 * get GC_ID string
 	 */
-    public String getGCId () { return attRef(_Id,GC_ID); }
-    /**
-     * getting attribute given=1,negative=0,not specified=2  
-     */
-	public int getInc () { return _Inc; }
-    /**
-     * getting CW internal attribute number (-1..127)  
-     */
-	public int getId () { return _Id; }
-    /**
-     * setting/changing attribute given=1,negative=0,not specified=2  
-     */
-    public void setInc(int inc) {
-    	_Inc=inc;
-    	if (_Id&lt;0 || _Id&gt;=maxAttRef) {
-    		_ImageName=&quot;error.gif&quot;;
-    	}
-    	else {
-    		_ImageName=attRef(_Id,PIC_NAME);
-    		if (inc==0) _ImageName+=&quot;-no.gif&quot;;
-    		else if (inc==1) _ImageName+=&quot;-yes.gif&quot;;
-    		else _ImageName+=&quot;-non.gif&quot;;
-    	}
-    }
-    /**
-     * getting name of corresponding image stored in attributes subdirectory 
-     */
-    public String getImageName() {
-    	return _ImageName;
-    }   
-    /**
-     * getting path+name of corresponding image stored in attributes subdirectory 
-     */
-    public String getPathAndImageName() {
-    	return IMAGEDIR+_ImageName;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getYesBit(long[] yes) {
-    	if (_Inc==1) {
-    		yes[0]|=_bit[0];
-    		yes[1]|=_bit[1];    		
-    	}
-    	else {
-    		yes[0]&amp;=~_bit[0];
-    		yes[1]&amp;=~_bit[1];    		
-    	}
-    	return yes;
-    }
-    /**
-     * set/unset the bit in the long array that belongs to the Id of the attribute  
-     */
-    public long[] getNoBit(long[] no) {
-    	if (_Inc==0) {
-    		no[0]|=_bit[0];
-    		no[1]|=_bit[1];
-    	}
-    	else {
-    		no[0]&amp;=~_bit[0];
-    		no[1]&amp;=~_bit[1];    		
-    	}
-    	return no;
-    }
-    /**
-     * get the language dependant description of the attribute  
-     */
-    public String getMsg() {
-    	return getMsg(_Id,_Inc);
-    }
-	
-	private final static int BIT_NR = 0; 
+	public String getGCId() {
+		return attRef(_Id, GC_ID);
+	}
+
+	/**
+	 * getting attribute given=1,negative=0,not specified=2
+	 */
+	public int getInc() {
+		return _Inc;
+	}
+
+	/**
+	 * getting CW internal attribute number (-1..127)
+	 */
+	public int getId() {
+		return _Id;
+	}
+
+	/**
+	 * setting/changing attribute given=1,negative=0,not specified=2
+	 */
+	public void setInc(int inc) {
+		_Inc = inc;
+		if (_Id &lt; 0 || _Id &gt;= maxAttRef) {
+			_ImageName = &quot;error.gif&quot;;
+		} else {
+			_ImageName = attRef(_Id, PIC_NAME);
+			if (inc == 0)
+				_ImageName += &quot;-no.gif&quot;;
+			else if (inc == 1)
+				_ImageName += &quot;-yes.gif&quot;;
+			else
+				_ImageName += &quot;-non.gif&quot;;
+		}
+	}
+
+	/**
+	 * getting name of corresponding image stored in attributes subdirectory
+	 */
+	public String getImageName() {
+		return _ImageName;
+	}
+
+	/**
+	 * getting path+name of corresponding image stored in attributes subdirectory
+	 */
+	public String getPathAndImageName() {
+		return IMAGEDIR + _ImageName;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getYesBit(long[] yes) {
+		if (_Inc == 1) {
+			yes[0] |= _bit[0];
+			yes[1] |= _bit[1];
+		} else {
+			yes[0] &amp;= ~_bit[0];
+			yes[1] &amp;= ~_bit[1];
+		}
+		return yes;
+	}
+
+	/**
+	 * set/unset the bit in the long array that belongs to the Id of the attribute
+	 */
+	public long[] getNoBit(long[] no) {
+		if (_Inc == 0) {
+			no[0] |= _bit[0];
+			no[1] |= _bit[1];
+		} else {
+			no[0] &amp;= ~_bit[0];
+			no[1] &amp;= ~_bit[1];
+		}
+		return no;
+	}
+
+	/**
+	 * get the language dependant description of the attribute
+	 */
+	public String getMsg() {
+		return getMsg(_Id, _Inc);
+	}
+
+	private final static int BIT_NR = 0;
 	private final static int MSG_NR = 1;
 	private final static int PIC_NAME = 2;
-	private final static int OC_ID = 3;
-	private final static int GC_ID = 4;
-	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum	
-	private static final String[][] attRef = {
-		// Empfehlungen / Personen - Conditions (Yes/No)
-		{&quot;30&quot;,&quot;2562&quot;,&quot;scenic&quot;,&quot;0&quot;,&quot;8&quot;,&quot;Scenic view&quot;},//62 scenic view
-		{&quot;17&quot;,&quot;2536&quot;,&quot;kids&quot;,&quot;59&quot;,&quot;6&quot;,&quot;Recommended for kids&quot;},//36 kid friendly
-		{&quot;35&quot;,&quot;2572&quot;,&quot;stroller&quot;,&quot;0&quot;,&quot;41&quot;,&quot;Stroller accessible&quot;},//72 stroller accessible	
-		{&quot;41&quot;,&quot;2584&quot;,&quot;wheelchair&quot;,&quot;0&quot;,&quot;24&quot;,&quot;Wheelchair accessible&quot;},//84 wheelchair accessible
-		//  vorhanden / Eigenschaften / Infrastruktur - Facilities (Yes/No)
-		{&quot;22&quot;,&quot;2546&quot;,&quot;parking&quot;,&quot;18&quot;,&quot;25&quot;,&quot;Parking available&quot;},//46 parking available
-		{&quot;26&quot;,&quot;2554&quot;,&quot;public&quot;,&quot;19&quot;,&quot;26&quot;,&quot;Public transportation&quot;},//54 public transit available
-		{&quot;40&quot;,&quot;2582&quot;,&quot;water&quot;,&quot;20&quot;,&quot;27&quot;,&quot;Drinking water nearby&quot;},//82 drinking water nearby
-		{&quot;29&quot;,&quot;2560&quot;,&quot;restrooms&quot;,&quot;21&quot;,&quot;28&quot;,&quot;Public restrooms nearby&quot;},//60 restrooms available
-		{&quot;23&quot;,&quot;2548&quot;,&quot;phone&quot;,&quot;22&quot;,&quot;29&quot;,&quot;Telephone nearby&quot;},//48 telephone nearby
-		{&quot;24&quot;,&quot;2550&quot;,&quot;picnic&quot;,&quot;0&quot;,&quot;30&quot;,&quot;Picnic tables nearby&quot;},//50 picnic tables available
-		{&quot;43&quot;,&quot;2588&quot;,&quot;firstaid&quot;,&quot;23&quot;,&quot;42&quot;,&quot;Firstaid&quot;}, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe 
-		{&quot;73&quot;,&quot;2654&quot;,&quot;rv&quot;,&quot;0&quot;,&quot;46&quot;,&quot;Truck Driver/RV&quot;},// changed by Moorteufel 12.07.10 
-		{&quot;85&quot;,&quot;2678&quot;,&quot;fuel&quot;,&quot;0&quot;,&quot;58&quot;,&quot;Fuel nearby&quot;}, // changed by araber95 14.08.10 
-		{&quot;86&quot;,&quot;2680&quot;,&quot;food&quot;,&quot;0&quot;,&quot;59&quot;,&quot;Food nearby&quot;}, // changed by araber95 14.08.10
-		// Erlaubt - Permissions (Allowed/Not Allowed)
-		{&quot;11&quot;,&quot;2524&quot;,&quot;dogs&quot;,&quot;0&quot;,&quot;1&quot;,&quot;Dogs&quot;},//24 dogs allowed
-		{&quot;05&quot;,&quot;2512&quot;,&quot;camping&quot;,&quot;0&quot;,&quot;31&quot;,&quot;Camping available&quot;},//12 Camping allowed
-		{&quot;01&quot;,&quot;2504&quot;,&quot;bicycles&quot;,&quot;0&quot;,&quot;32&quot;,&quot;Bicycles&quot;},//04 bikes allowed
-		{&quot;19&quot;,&quot;2540&quot;,&quot;motorcycles&quot;,&quot;0&quot;,&quot;33&quot;,&quot;Motorcycles&quot;},//40 motorcycles allowed
-		{&quot;27&quot;,&quot;2556&quot;,&quot;quads&quot;,&quot;0&quot;,&quot;34&quot;,&quot;Quads&quot;},//56 quads allowed
-		{&quot;16&quot;,&quot;2534&quot;,&quot;jeeps&quot;,&quot;0&quot;,&quot;35&quot;,&quot;Off-road vehicles&quot;},//34 off-road vehicles allowed
-		{&quot;33&quot;,&quot;2568&quot;,&quot;snowmobiles&quot;,&quot;0&quot;,&quot;36&quot;,&quot;Snowmobiles&quot;},//68
-		{&quot;14&quot;,&quot;2530&quot;,&quot;horses&quot;,&quot;0&quot;,&quot;37&quot;,&quot;Horses&quot;},//30 horses allowed
-		{&quot;04&quot;,&quot;2510&quot;,&quot;campfires&quot;,&quot;0&quot;,&quot;38&quot;,&quot;Campfires&quot;},//10 campfires allowed
-		// Eigenschaften / Gefahren - Hazards (Present/Not Present)
-		{&quot;10&quot;,&quot;2522&quot;,&quot;danger&quot;,&quot;9&quot;,&quot;23&quot;,&quot;Dangerous area&quot;},//22 dangerous area
-		{&quot;62&quot;,&quot;2644&quot;,&quot;train&quot;,&quot;10&quot;,&quot;0&quot;,&quot;&quot;},// 144 aktive Eisenbahnlinien in der N&#228;he
-		{&quot;06&quot;,&quot;2514&quot;,&quot;cliff&quot;,&quot;11&quot;,&quot;21&quot;,&quot;Cliff / falling rocks&quot;},//14 falling-rocks nearby
-		{&quot;15&quot;,&quot;2532&quot;,&quot;hunting&quot;,&quot;12&quot;,&quot;22&quot;,&quot;Hunting&quot;},//32 hunting area
-		{&quot;37&quot;,&quot;2576&quot;,&quot;thorn&quot;,&quot;13&quot;,&quot;39&quot;,&quot;Thorns&quot;},//76 thorns!
-		{&quot;38&quot;,&quot;2578&quot;,&quot;ticks&quot;,&quot;14&quot;,&quot;19&quot;,&quot;Ticks&quot;},//78 ticks!
-		{&quot;18&quot;,&quot;2538&quot;,&quot;mine&quot;,&quot;15&quot;,&quot;20&quot;,&quot;Abandoned mines&quot;},//38
-		{&quot;25&quot;,&quot;2552&quot;,&quot;poisonoak&quot;,&quot;16&quot;,&quot;17&quot;,&quot;Poison plants&quot;},//52 Giftige Pflanzen
-		{&quot;46&quot;,&quot;2594&quot;,&quot;animals&quot;,&quot;17&quot;,&quot;0&quot;,&quot;&quot;},// 94 Giftige/gef%e4hrliche Tiere
-		// {&quot;03&quot;,&quot;2508&quot;,&quot;cactus&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;},//08 removed 14.08.10 araber95
-		{&quot;32&quot;,&quot;2566&quot;,&quot;dangerousanimals&quot;,&quot;0&quot;,&quot;18&quot;,&quot;Dangerous Animals&quot;},//66
-		// {&quot;32&quot;,&quot;2566&quot;,&quot;snakes&quot;,&quot;0&quot;,&quot;18&quot;,&quot;Snakes&quot;},//66 araber95 replaced by Dangerous Animals 14.08.10
-		{&quot;09&quot;,&quot;2520&quot;,&quot;cow&quot;,&quot;0&quot;,&quot;43&quot;,&quot;Watch for livestock&quot;},//20 watch for livestock
-		// Eigenschaften / Der Weg - Conditions (Yes/No)
-		{&quot;49&quot;,&quot;2600&quot;,&quot;car&quot;,&quot;24&quot;,&quot;0&quot;,&quot;&quot;},// 100 Nahe beim Auto
-		{&quot;21&quot;,&quot;2544&quot;,&quot;onehour&quot;,&quot;0&quot;,&quot;7&quot;,&quot;Takes less than an hour&quot;},//44 takes less than one hour
-		{&quot;82&quot;,&quot;2672&quot;,&quot;hike_short&quot;,&quot;0&quot;,&quot;55&quot;,&quot;Short hike&quot;}, // added by araber95 14.8.10
-		{&quot;83&quot;,&quot;2674&quot;,&quot;hike_med&quot;,&quot;0&quot;,&quot;56&quot;,&quot;Medium Hike&quot;}, // added by araber95 14.8.10
-		{&quot;84&quot;,&quot;2676&quot;,&quot;hike_long&quot;,&quot;0&quot;,&quot;57&quot;,&quot;Long Hike&quot;}, // added by araber95 14.8.10
-		{&quot;13&quot;,&quot;2528&quot;,&quot;hiking&quot;,&quot;25&quot;,&quot;9&quot;,&quot;Significant hike&quot;},//28 significant hike
-		{&quot;39&quot;,&quot;2580&quot;,&quot;wading&quot;,&quot;26&quot;,&quot;11&quot;,&quot;May require wading&quot;},//80 may require wading
-		{&quot;65&quot;,&quot;2634&quot;,&quot;steep&quot;,&quot;27&quot;,&quot;0&quot;,&quot;&quot;},// 134 H&#252;geliges Gel&#228;nde
-		{&quot;07&quot;,&quot;2516&quot;,&quot;climbing&quot;,&quot;28&quot;,&quot;10&quot;,&quot;Difficult climbing&quot;},//16 easy climbing(OC-28), difficult climbing(GC-10) 
-		{&quot;36&quot;,&quot;2574&quot;,&quot;swimming&quot;,&quot;29&quot;,&quot;12&quot;,&quot;May require swimming&quot;},//74
-		{&quot;79&quot;,&quot;2666&quot;,&quot;nightcache&quot;,&quot;0&quot;,&quot;52&quot;,&quot;Night Cache&quot;}, // added by araber95 14.8.10
-		{&quot;80&quot;,&quot;2668&quot;,&quot;parkngrab&quot;,&quot;0&quot;,&quot;53&quot;,&quot;Park and grab&quot;}, // added by araber95 14.8.10
-		{&quot;81&quot;,&quot;2670&quot;,&quot;abandonedbuilding&quot;,&quot;0&quot;,&quot;54&quot;,&quot;Abandoned structure&quot;}, // added by araber95 14.8.10
-		// Eigenschaften / Wegpunkte  - Conditions (Yes/No)
-		{&quot;55&quot;,&quot;2612&quot;,&quot;letter&quot;,&quot;8&quot;,&quot;0&quot;,&quot;&quot;},// 112 Letterbox (ben&#246;tigt Stempel)
-		{&quot;54&quot;,&quot;2610&quot;,&quot;interestsign&quot;,&quot;30&quot;,&quot;0&quot;,&quot;&quot;},// 110 Interessanter Ort ev mit scenic zusammenfassen?
-		{&quot;56&quot;,&quot;2614&quot;,&quot;moving&quot;,&quot;31&quot;,&quot;0&quot;,&quot;&quot;},// 114 Bewegliches Ziel
-		{&quot;64&quot;,&quot;2646&quot;,&quot;webcam&quot;,&quot;32&quot;,&quot;0&quot;,&quot;&quot;},// 146 Webcam am Ziel
-		{&quot;53&quot;,&quot;2608&quot;,&quot;indoor&quot;,&quot;33&quot;,&quot;0&quot;,&quot;&quot;},// 108 In geschlossenen R&#228;umen
-		{&quot;66&quot;,&quot;2636&quot;,&quot;submerged&quot;,&quot;34&quot;,&quot;0&quot;,&quot;&quot;},// 136 Im Wasser
-		{&quot;58&quot;,&quot;2618&quot;,&quot;nogps&quot;,&quot;35&quot;,&quot;0&quot;,&quot;&quot;},// 118 Ohne GPS
-		{&quot;34&quot;,&quot;2570&quot;,&quot;stealth&quot;,&quot;0&quot;,&quot;40&quot;,&quot;Stealth required&quot;},//70 stealth required (Heimlich,List,Schl&#228;ue)
-		// Einschr&#228;nkungen und Voraussetzungen / Allgemein
-		{&quot;12&quot;,&quot;2526&quot;,&quot;fee&quot;,&quot;36&quot;,&quot;2&quot;,&quot;Access or parking fee&quot;},//26 access/parking fees
-		{&quot;61&quot;,&quot;2624&quot;,&quot;overnight&quot;,&quot;37&quot;,&quot;0&quot;,&quot;&quot;},// 124 &#220;bernachtung erforderlich
-		// Einschr&#228;nkungen und Voraussetzungen / Zeitlich
-		{&quot;20&quot;,&quot;2542&quot;,&quot;night&quot;,&quot;1&quot;,&quot;14&quot;,&quot;Recommended at night&quot;},//42 recommended at night
-		{&quot;00&quot;,&quot;2502&quot;,&quot;available&quot;,&quot;38&quot;,&quot;13&quot;,&quot;Available at all times&quot;},//02 available 24-7
-		{&quot;68&quot;,&quot;2640&quot;,&quot;time&quot;,&quot;39&quot;,&quot;0&quot;,&quot;&quot;},// 140 An bestimmte Zeiten gebunden
-		{&quot;52&quot;,&quot;2606&quot;,&quot;day&quot;,&quot;40&quot;,&quot;0&quot;,&quot;&quot;},// 106 nur tags&#252;ber
-		{&quot;67&quot;,&quot;2638&quot;,&quot;tide&quot;,&quot;41&quot;,&quot;0&quot;,&quot;&quot;},// 138 Gezeiten
-		// Einschr&#228;nkungen und Voraussetzungen / Saisonbedingt
-		{&quot;51&quot;,&quot;2604&quot;,&quot;date&quot;,&quot;42&quot;,&quot;0&quot;,&quot;&quot;},// 104 w&#228;hrend des ganzen Jahres zug&#228;nglich
-		{&quot;57&quot;,&quot;2616&quot;,&quot;naturschutz&quot;,&quot;43&quot;,&quot;0&quot;,&quot;&quot;},// 116 Brutsaison/Naturschutz
-		{&quot;42&quot;,&quot;2586&quot;,&quot;winter&quot;,&quot;44&quot;,&quot;15&quot;,&quot;Available during winter&quot;},//86 available in winter 132 Schneesicheres Versteck
-		// Einschr&#228;nkungen und Voraussetzungen / Systembedingt
-		{&quot;59&quot;,&quot;2620&quot;,&quot;oconly&quot;,&quot;6&quot;,&quot;0&quot;,&quot;&quot;},// 120 Nur bei Opencaching logbar
-		{&quot;71&quot;,&quot;2650&quot;,&quot;wwwlink&quot;,&quot;7&quot;,&quot;0&quot;,&quot;&quot;},// 150 Nur Hyperlink zu OC-externen Portalen
-		// Einschr&#228;nkungen und Voraussetzungen / Werkzeug - Equipment (Required/Not Required)
-		{&quot;69&quot;,&quot;2642&quot;,&quot;tools&quot;,&quot;46&quot;,&quot;0&quot;,&quot;Special Tool required&quot;},// 142 Spezielle Ausr&#252;stung
-		{&quot;08&quot;,&quot;2518&quot;,&quot;compass&quot;,&quot;47&quot;,&quot;0&quot;,&quot;&quot;},//18 Kompass
-		{&quot;44&quot;,&quot;2590&quot;,&quot;flashlight&quot;,&quot;48&quot;,&quot;44&quot;,&quot;Flashlight required&quot;}, // 90 Flashlight required
-		{&quot;28&quot;,&quot;2558&quot;,&quot;rappelling&quot;,&quot;49&quot;,&quot;3&quot;,&quot;Climbing gear&quot;},//58 climbing gear Kletterausr&#252;stung
-		{&quot;50&quot;,&quot;2602&quot;,&quot;cave&quot;,&quot;50&quot;,&quot;0&quot;,&quot;&quot;},// 102 H&#246;hlenausr&#252;stung
-		{&quot;31&quot;,&quot;2564&quot;,&quot;scuba&quot;,&quot;51&quot;,&quot;5&quot;,&quot;Scuba gear&quot;},//64 Tauchausr&#252;stung
-		{&quot;02&quot;,&quot;2506&quot;,&quot;boat&quot;,&quot;52&quot;,&quot;4&quot;,&quot;Boat&quot;},//06 Wasserfahrzeug
-		{&quot;45&quot;,&quot;2592&quot;,&quot;aircraft&quot;,&quot;53&quot;,&quot;38&quot;,&quot;&quot;},// 92
-		{&quot;75&quot;,&quot;2658&quot;,&quot;uv&quot;,&quot;0&quot;,&quot;48&quot;,&quot;UV Light required&quot;}, // added by araber95 14.8.10
-		{&quot;76&quot;,&quot;2660&quot;,&quot;snowshoes&quot;,&quot;0&quot;,&quot;49&quot;,&quot;Snowshoes&quot;}, // added by araber95 14.8.10&quot;
-		{&quot;77&quot;,&quot;2662&quot;,&quot;skiis&quot;,&quot;0&quot;,&quot;50&quot;,&quot;Cross Country Skis&quot;}, // added by araber95 14.8.10
-		{&quot;78&quot;,&quot;2664&quot;,&quot;s-tool&quot;,&quot;0&quot;,&quot;51&quot;,&quot;Special Tool required&quot;}, // added by araber95 14.8.10
-		{&quot;87&quot;,&quot;2681&quot;,&quot;wirelessbeacon&quot;,&quot;0&quot;,&quot;60&quot;,&quot;Wireless Beacon&quot;}, // added by araber95 27.10.10
-		// Einschr&#228;nkungen und Voraussetzungen / Ben&#246;tigt Vorarbeit
-		{&quot;70&quot;,&quot;2648&quot;,&quot;wiki&quot;,&quot;54&quot;,&quot;0&quot;,&quot;&quot;},// 148 Recherche
-		{&quot;63&quot;,&quot;2630&quot;,&quot;riddle&quot;,&quot;55&quot;,&quot;0&quot;,&quot;&quot;},// 130 R&#228;tsel
-		{&quot;74&quot;,&quot;2656&quot;,&quot;field_puzzle&quot;,&quot;0&quot;,&quot;47&quot;,&quot;Field Puzzle&quot;},// changed by Moorteufel 12.07.10
-		{&quot;47&quot;,&quot;2596&quot;,&quot;arith_prob&quot;,&quot;56&quot;,&quot;0&quot;,&quot;&quot;},// 96 Rechenaufgabe
-		{&quot;60&quot;,&quot;2622&quot;,&quot;othercache&quot;,&quot;57&quot;,&quot;0&quot;,&quot;&quot;},// 122 besondere Cacheart
-		{&quot;48&quot;,&quot;2598&quot;,&quot;ask&quot;,&quot;58&quot;,&quot;0&quot;,&quot;&quot;},// 98 Startbedingungen beim Owner erfragen
-		{&quot;72&quot;,&quot;2652&quot;,&quot;landf&quot;,&quot;0&quot;,&quot;45&quot;,&quot;Lost And Found Tour&quot;}, // thx to Kappler and MiK
-		// {&quot;-1&quot;,&quot;2500&quot;,&quot;error&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;}, //
+	private final static int OC_ID = 3; // OC - XML
+	private final static int GC_ID = 4; // auch OC neues gpx
+	private final static int GC_TEXT = 5; // for export , didn't extract by myself, copied from forum
+	private static final String[][] attRef = { { &quot;00&quot;, &quot;2502&quot;, &quot;available&quot;, &quot;38&quot;, &quot;13&quot;, &quot;Available at all times&quot; },// 02 available 24-7
+			{ &quot;01&quot;, &quot;2504&quot;, &quot;bicycles&quot;, &quot;0&quot;, &quot;32&quot;, &quot;Bicycles&quot; },// 04 bikes allowed
+			{ &quot;02&quot;, &quot;2506&quot;, &quot;boat&quot;, &quot;52&quot;, &quot;4&quot;, &quot;Boat&quot; },// 06 Wasserfahrzeug
+			// {&quot;03&quot;,&quot;2508&quot;,&quot;cactus&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;},//08 removed 14.08.10 araber95
+			{ &quot;04&quot;, &quot;2510&quot;, &quot;campfires&quot;, &quot;0&quot;, &quot;38&quot;, &quot;Campfires&quot; },// 10 campfires allowed
+			{ &quot;05&quot;, &quot;2512&quot;, &quot;camping&quot;, &quot;0&quot;, &quot;31&quot;, &quot;Camping available&quot; },// 12 Camping allowed
+			{ &quot;06&quot;, &quot;2514&quot;, &quot;cliff&quot;, &quot;11&quot;, &quot;21&quot;, &quot;Cliff / falling rocks&quot; },// 14 falling-rocks nearby
+			{ &quot;07&quot;, &quot;2516&quot;, &quot;climbing&quot;, &quot;28&quot;, &quot;10&quot;, &quot;Difficult climbing&quot; },// 16 easy climbing(OC-28), difficult climbing(GC-10)
+			{ &quot;08&quot;, &quot;2518&quot;, &quot;compass&quot;, &quot;47&quot;, &quot;147&quot;, &quot;Compass&quot; }, // OC special
+			{ &quot;09&quot;, &quot;2520&quot;, &quot;cow&quot;, &quot;0&quot;, &quot;43&quot;, &quot;Watch for livestock&quot; },// 20 watch for livestock
+			{ &quot;10&quot;, &quot;2522&quot;, &quot;danger&quot;, &quot;9&quot;, &quot;23&quot;, &quot;Dangerous area&quot; },// 22 dangerous area
+			{ &quot;11&quot;, &quot;2524&quot;, &quot;dogs&quot;, &quot;0&quot;, &quot;1&quot;, &quot;Dogs&quot; },// 24 dogs allowed
+			{ &quot;12&quot;, &quot;2526&quot;, &quot;fee&quot;, &quot;36&quot;, &quot;2&quot;, &quot;Access or parking fee&quot; },// 26 access/parking fees
+			// {&quot;13&quot;,&quot;2528&quot;,&quot;hiking&quot;,&quot;0&quot;,&quot;9&quot;,&quot;Significant hike&quot;},//28 significant hike : removed
+			{ &quot;13&quot;, &quot;2528&quot;, &quot;hiking&quot;, &quot;25&quot;, &quot;125&quot;, &quot;Long walk&quot; }, // OC special
+			{ &quot;14&quot;, &quot;2530&quot;, &quot;horses&quot;, &quot;0&quot;, &quot;37&quot;, &quot;Horses&quot; },// 30 horses allowed
+			{ &quot;15&quot;, &quot;2532&quot;, &quot;hunting&quot;, &quot;12&quot;, &quot;22&quot;, &quot;Hunting&quot; },// 32 hunting area
+			{ &quot;16&quot;, &quot;2534&quot;, &quot;jeeps&quot;, &quot;0&quot;, &quot;35&quot;, &quot;Off-road vehicles&quot; },// 34 off-road vehicles allowed
+			{ &quot;17&quot;, &quot;2536&quot;, &quot;kids&quot;, &quot;59&quot;, &quot;6&quot;, &quot;Recommended for kids&quot; },// 36 kid friendly
+			{ &quot;18&quot;, &quot;2538&quot;, &quot;mine&quot;, &quot;15&quot;, &quot;20&quot;, &quot;Abandoned mines&quot; },// 38
+			{ &quot;19&quot;, &quot;2540&quot;, &quot;motorcycles&quot;, &quot;0&quot;, &quot;33&quot;, &quot;Motorcycles&quot; },// 40 motorcycles allowed
+			{ &quot;20&quot;, &quot;2542&quot;, &quot;night&quot;, &quot;1&quot;, &quot;14&quot;, &quot;Recommended at night&quot; },// 42 recommended at night
+			{ &quot;21&quot;, &quot;2544&quot;, &quot;onehour&quot;, &quot;0&quot;, &quot;7&quot;, &quot;Takes less than an hour&quot; },// 44 takes less than one hour
+			{ &quot;22&quot;, &quot;2546&quot;, &quot;parking&quot;, &quot;18&quot;, &quot;25&quot;, &quot;Parking available&quot; },// 46 parking available
+			{ &quot;23&quot;, &quot;2548&quot;, &quot;phone&quot;, &quot;22&quot;, &quot;29&quot;, &quot;Telephone nearby&quot; },// 48 telephone nearby
+			{ &quot;24&quot;, &quot;2550&quot;, &quot;picnic&quot;, &quot;0&quot;, &quot;30&quot;, &quot;Picnic tables nearby&quot; },// 50 picnic tables available
+			{ &quot;25&quot;, &quot;2552&quot;, &quot;poisonoak&quot;, &quot;16&quot;, &quot;17&quot;, &quot;Poison plants&quot; },// 52 Giftige Pflanzen
+			{ &quot;26&quot;, &quot;2554&quot;, &quot;public&quot;, &quot;19&quot;, &quot;26&quot;, &quot;Public transportation&quot; },// 54 public transit available
+			{ &quot;27&quot;, &quot;2556&quot;, &quot;quads&quot;, &quot;0&quot;, &quot;34&quot;, &quot;Quads&quot; },// 56 quads allowed
+			{ &quot;28&quot;, &quot;2558&quot;, &quot;rappelling&quot;, &quot;49&quot;, &quot;3&quot;, &quot;Climbing gear&quot; },// 58 climbing gear Kletterausr&#252;stung
+			{ &quot;29&quot;, &quot;2560&quot;, &quot;restrooms&quot;, &quot;21&quot;, &quot;28&quot;, &quot;Public restrooms nearby&quot; },// 60 restrooms available
+			{ &quot;30&quot;, &quot;2562&quot;, &quot;scenic&quot;, &quot;0&quot;, &quot;8&quot;, &quot;Scenic view&quot; },// 62 scenic view
+			{ &quot;31&quot;, &quot;2564&quot;, &quot;scuba&quot;, &quot;51&quot;, &quot;5&quot;, &quot;Scuba gear&quot; },// 64 Tauchausr&#252;stung
+			// {&quot;32&quot;,&quot;2566&quot;,&quot;snakes&quot;,&quot;0&quot;,&quot;18&quot;,&quot;Snakes&quot;},//66 araber95 replaced by Dangerous Animals 14.08.10
+			{ &quot;32&quot;, &quot;2566&quot;, &quot;dangerousanimals&quot;, &quot;0&quot;, &quot;18&quot;, &quot;Dangerous Animals&quot; },// 66
+			{ &quot;33&quot;, &quot;2568&quot;, &quot;snowmobiles&quot;, &quot;0&quot;, &quot;36&quot;, &quot;Snowmobiles&quot; },// 68
+			{ &quot;34&quot;, &quot;2570&quot;, &quot;stealth&quot;, &quot;0&quot;, &quot;40&quot;, &quot;Stealth required&quot; },// 70 stealth required (Heimlich,List,Schl&#228;ue)
+			{ &quot;35&quot;, &quot;2572&quot;, &quot;stroller&quot;, &quot;0&quot;, &quot;41&quot;, &quot;Stroller accessible&quot; },// 72 stroller accessible
+			{ &quot;36&quot;, &quot;2574&quot;, &quot;swimming&quot;, &quot;29&quot;, &quot;12&quot;, &quot;May require swimming&quot; },// 74
+			{ &quot;37&quot;, &quot;2576&quot;, &quot;thorn&quot;, &quot;13&quot;, &quot;39&quot;, &quot;Thorns&quot; },// 76 thorns!
+			{ &quot;38&quot;, &quot;2578&quot;, &quot;ticks&quot;, &quot;14&quot;, &quot;19&quot;, &quot;Ticks&quot; },// 78 ticks!
+			{ &quot;39&quot;, &quot;2580&quot;, &quot;wading&quot;, &quot;26&quot;, &quot;11&quot;, &quot;May require wading&quot; },// 80 may require wading
+			{ &quot;40&quot;, &quot;2582&quot;, &quot;water&quot;, &quot;20&quot;, &quot;27&quot;, &quot;Drinking water nearby&quot; },// 82 drinking water nearby
+			{ &quot;41&quot;, &quot;2584&quot;, &quot;wheelchair&quot;, &quot;0&quot;, &quot;24&quot;, &quot;Wheelchair accessible&quot; },// 84 wheelchair accessible
+			{ &quot;42&quot;, &quot;2586&quot;, &quot;winter&quot;, &quot;44&quot;, &quot;15&quot;, &quot;Available during winter&quot; },// 86 available in winter 132 Schneesicheres Versteck
+			{ &quot;43&quot;, &quot;2588&quot;, &quot;firstaid&quot;, &quot;0&quot;, &quot;42&quot;, &quot;Firstaid&quot; }, // GC: Cachewartung notwendig (Auto Attribut) , OC: erste Hilfe
+			{ &quot;44&quot;, &quot;2590&quot;, &quot;flashlight&quot;, &quot;48&quot;, &quot;44&quot;, &quot;Flashlight required&quot; }, // 90 Flashlight required
+			{ &quot;45&quot;, &quot;2592&quot;, &quot;aircraft&quot;, &quot;53&quot;, &quot;153&quot;, &quot;Aircraft&quot; }, // OC special //38 GC removed
+			{ &quot;46&quot;, &quot;2594&quot;, &quot;animals&quot;, &quot;17&quot;, &quot;0&quot;, &quot;&quot; },// 94 Giftige/gef%e4hrliche Tiere
+			{ &quot;47&quot;, &quot;2596&quot;, &quot;arith_prob&quot;, &quot;56&quot;, &quot;156&quot;, &quot;Arithmetical problem&quot; }, // OC special
+			{ &quot;48&quot;, &quot;2598&quot;, &quot;ask&quot;, &quot;58&quot;, &quot;158&quot;, &quot;Ask owner for start conditions&quot; }, // OC special
+			{ &quot;49&quot;, &quot;2600&quot;, &quot;car&quot;, &quot;24&quot;, &quot;0&quot;, &quot;&quot; },// 100 Nahe beim Auto
+			{ &quot;50&quot;, &quot;2602&quot;, &quot;cave&quot;, &quot;50&quot;, &quot;150&quot;, &quot;Cave equipment&quot; }, // OC special
+			{ &quot;51&quot;, &quot;2604&quot;, &quot;date&quot;, &quot;42&quot;, &quot;142&quot;, &quot;All seasons&quot; }, // OC special
+			{ &quot;52&quot;, &quot;2606&quot;, &quot;day&quot;, &quot;40&quot;, &quot;140&quot;, &quot;by day only&quot; }, // OC special
+			{ &quot;53&quot;, &quot;2608&quot;, &quot;indoor&quot;, &quot;33&quot;, &quot;133&quot;, &quot;Within enclosed rooms (caves, buildings etc.)&quot; }, // OC special
+			{ &quot;54&quot;, &quot;2610&quot;, &quot;interestsign&quot;, &quot;30&quot;, &quot;130&quot;, &quot;Point of interest&quot; }, // OC special
+			{ &quot;55&quot;, &quot;2612&quot;, &quot;letter&quot;, &quot;8&quot;, &quot;108&quot;, &quot;Letterbox (needs stamp)&quot; }, // OC special
+			{ &quot;56&quot;, &quot;2614&quot;, &quot;moving&quot;, &quot;31&quot;, &quot;131&quot;, &quot;Moving target&quot; }, // OC special
+			{ &quot;57&quot;, &quot;2616&quot;, &quot;naturschutz&quot;, &quot;43&quot;, &quot;143&quot;, &quot;Breeding season / protected nature&quot; }, // OC special
+			{ &quot;58&quot;, &quot;2618&quot;, &quot;nogps&quot;, &quot;35&quot;, &quot;135&quot;, &quot;Without GPS (letterboxes, cistes, compass juggling ...)&quot; }, // OC special
+			{ &quot;59&quot;, &quot;2620&quot;, &quot;oconly&quot;, &quot;6&quot;, &quot;106&quot;, &quot;Only loggable at Opencaching&quot; },// 120 Nur bei Opencaching logbar
+			{ &quot;60&quot;, &quot;2622&quot;, &quot;othercache&quot;, &quot;57&quot;, &quot;157&quot;, &quot;Other cache type&quot; }, // OC special
+			{ &quot;61&quot;, &quot;2624&quot;, &quot;overnight&quot;, &quot;37&quot;, &quot;137&quot;, &quot;Overnight stay necessary&quot; }, // OC special
+			{ &quot;62&quot;, &quot;2644&quot;, &quot;train&quot;, &quot;10&quot;, &quot;110&quot;, &quot;Active railway nearby&quot; }, // OC special
+			{ &quot;63&quot;, &quot;2630&quot;, &quot;riddle&quot;, &quot;55&quot;, &quot;0&quot;, &quot;&quot; },// 130 R&#228;tsel
+			{ &quot;64&quot;, &quot;2646&quot;, &quot;webcam&quot;, &quot;32&quot;, &quot;132&quot;, &quot;Webcam&quot; }, // OC special
+			{ &quot;65&quot;, &quot;2634&quot;, &quot;steep&quot;, &quot;27&quot;, &quot;127&quot;, &quot;Hilly area&quot; }, // OC special
+			{ &quot;66&quot;, &quot;2636&quot;, &quot;submerged&quot;, &quot;34&quot;, &quot;134&quot;, &quot;In the water&quot; }, // OC special
+			{ &quot;67&quot;, &quot;2638&quot;, &quot;tide&quot;, &quot;41&quot;, &quot;141&quot;, &quot;Tide&quot; }, // OC special
+			{ &quot;68&quot;, &quot;2640&quot;, &quot;time&quot;, &quot;39&quot;, &quot;139&quot;, &quot;Only available at specified times&quot; }, // OC special
+			{ &quot;69&quot;, &quot;2642&quot;, &quot;tools&quot;, &quot;46&quot;, &quot;0&quot;, &quot;Special Tool required&quot; },// 142 Spezielle Ausr&#252;stung
+			{ &quot;70&quot;, &quot;2648&quot;, &quot;wiki&quot;, &quot;54&quot;, &quot;154&quot;, &quot;Investigation&quot; }, // OC special
+			{ &quot;71&quot;, &quot;2650&quot;, &quot;wwwlink&quot;, &quot;7&quot;, &quot;107&quot;, &quot;Hyperlink to another caching portal only&quot; }, // OC special
+			{ &quot;72&quot;, &quot;2652&quot;, &quot;landf&quot;, &quot;0&quot;, &quot;45&quot;, &quot;Lost And Found Tour&quot; }, // thx to Kappler and MiK
+			{ &quot;73&quot;, &quot;2654&quot;, &quot;rv&quot;, &quot;0&quot;, &quot;46&quot;, &quot;Truck Driver/RV&quot; },// changed by Moorteufel 12.07.10
+			{ &quot;74&quot;, &quot;2656&quot;, &quot;field_puzzle&quot;, &quot;0&quot;, &quot;47&quot;, &quot;Field Puzzle&quot; },// changed by Moorteufel 12.07.10
+			{ &quot;75&quot;, &quot;2658&quot;, &quot;uv&quot;, &quot;0&quot;, &quot;48&quot;, &quot;UV Light required&quot; }, // added by araber95 14.8.10
+			{ &quot;76&quot;, &quot;2660&quot;, &quot;snowshoes&quot;, &quot;0&quot;, &quot;49&quot;, &quot;Snowshoes&quot; }, // added by araber95 14.8.10&quot;
+			{ &quot;77&quot;, &quot;2662&quot;, &quot;skiis&quot;, &quot;0&quot;, &quot;50&quot;, &quot;Cross Country Skis&quot; }, // added by araber95 14.8.10
+			{ &quot;78&quot;, &quot;2664&quot;, &quot;s-tool&quot;, &quot;0&quot;, &quot;51&quot;, &quot;Special Tool required&quot; }, // added by araber95 14.8.10
+			{ &quot;79&quot;, &quot;2666&quot;, &quot;nightcache&quot;, &quot;0&quot;, &quot;52&quot;, &quot;Night Cache&quot; }, // added by araber95 14.8.10
+			{ &quot;80&quot;, &quot;2668&quot;, &quot;parkngrab&quot;, &quot;0&quot;, &quot;53&quot;, &quot;Park and grab&quot; }, // added by araber95 14.8.10
+			{ &quot;81&quot;, &quot;2670&quot;, &quot;abandonedbuilding&quot;, &quot;0&quot;, &quot;54&quot;, &quot;Abandoned structure&quot; }, // added by araber95 14.8.10
+			{ &quot;82&quot;, &quot;2672&quot;, &quot;hike_short&quot;, &quot;0&quot;, &quot;55&quot;, &quot;Short hike&quot; }, // added by araber95 14.8.10
+			{ &quot;83&quot;, &quot;2674&quot;, &quot;hike_med&quot;, &quot;0&quot;, &quot;56&quot;, &quot;Medium Hike&quot; }, // added by araber95 14.8.10
+			{ &quot;84&quot;, &quot;2676&quot;, &quot;hike_long&quot;, &quot;0&quot;, &quot;57&quot;, &quot;Long Hike&quot; }, // added by araber95 14.8.10
+			{ &quot;85&quot;, &quot;2678&quot;, &quot;fuel&quot;, &quot;0&quot;, &quot;58&quot;, &quot;Fuel nearby&quot; }, // changed by araber95 14.08.10
+			{ &quot;86&quot;, &quot;2680&quot;, &quot;food&quot;, &quot;0&quot;, &quot;59&quot;, &quot;Food nearby&quot; }, // changed by araber95 14.08.10
+			{ &quot;87&quot;, &quot;2681&quot;, &quot;wirelessbeacon&quot;, &quot;0&quot;, &quot;60&quot;, &quot;Wireless Beacon&quot; }, // added by araber95 27.10.10
+			{ &quot;88&quot;, &quot;2588&quot;, &quot;firstaid&quot;, &quot;23&quot;, &quot;123&quot;, &quot;First aid available&quot; }, // OC special
+			{ &quot;89&quot;, &quot;2685&quot;, &quot;sponsored&quot;, &quot;0&quot;, &quot;61&quot;, &quot;Sponsored Cache&quot; },
+	// {&quot;-1&quot;,&quot;2500&quot;,&quot;error&quot;,&quot;0&quot;,&quot;0&quot;,&quot;&quot;}, //
 
 	};
-    public static int maxAttRef=attRef.length;	
-    private static String IMAGEDIR=STRreplace.replace(FileBase.getProgramDirectory()+&quot;/attributes/&quot;, &quot;//&quot;, &quot;/&quot;);
-    /*
-    private static String getImageName(int cw_Id, int cw_Inc){
-		if (cw_Id&lt;0 || cw_Id&gt;maxAttRef)
-			return &quot;error.gif&quot;;
-		else {
-			switch (cw_Inc) {
-			case 1: return attRef[cw_Id][PIC_NAME]+&quot;-yes.gif&quot;;
-			case 0: return attRef[cw_Id][PIC_NAME]+&quot;-no.gif&quot;;
-			case 2: return attRef[cw_Id][PIC_NAME]+&quot;-non.gif&quot;;
-			default:return &quot;error.gif&quot;;
-			}
+	public static int maxAttRef = attRef.length;
+	private static String IMAGEDIR = STRreplace.replace(FileBase.getProgramDirectory() + &quot;/attributes/&quot;, &quot;//&quot;, &quot;/&quot;);
+
+	/*
+	 * private static String getImageName(int cw_Id, int cw_Inc){ if (cw_Id&lt;0 || cw_Id&gt;maxAttRef) return &quot;error.gif&quot;; else { switch (cw_Inc) { case 1: return attRef[cw_Id][PIC_NAME]+&quot;-yes.gif&quot;; case 0: return attRef[cw_Id][PIC_NAME]+&quot;-no.gif&quot;; case 2:
+	 * return attRef[cw_Id][PIC_NAME]+&quot;-non.gif&quot;; default:return &quot;error.gif&quot;; } } }
+	 */
+	private static String getMsg(int cw_Id, int cw_Inc) {
+		if (cw_Id &lt; 0 || cw_Id &gt;= maxAttRef) {
+			return MyLocale.getMsg(2500, &quot;error attribute&quot;);
 		}
-	}
-	*/
-    private static String getMsg(int cw_Id, int cw_Inc){
-    	if (cw_Id&lt;0 || cw_Id&gt;=maxAttRef) {
-    		return MyLocale.getMsg(2500,&quot;error attribute&quot;);
-    	}
-		if (cw_Inc==0)
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR])-1,&quot;&quot;);
+		if (cw_Inc == 0)
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]) - 1, &quot;&quot;);
 		else
-			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]),&quot;&quot;);
+			return MyLocale.getMsg(Common.parseInt(attRef[cw_Id][MSG_NR]), &quot;&quot;);
 	}
-    private static mImage[] yesImages=new mImage[maxAttRef];
-	private static mImage[] noImages=new mImage[maxAttRef];
-	private static mImage[] nonImages=new mImage[maxAttRef];
-	private static final mImage errorImage=new mImage(IMAGEDIR+&quot;error.gif&quot;);	
+
+	private static mImage[] yesImages = new mImage[maxAttRef];
+	private static mImage[] noImages = new mImage[maxAttRef];
+	private static mImage[] nonImages = new mImage[maxAttRef];
+	private static final mImage errorImage = new mImage(IMAGEDIR + &quot;error.gif&quot;);
+
 	/**
 	 * Returns the width of the attribute icons
-	 * @return The width of the images 
+	 * 
+	 * @return The width of the images
 	 */
 	public static int getImageWidth() {
 		return errorImage.image.getWidth();
-	}	
-    /**
-     * Get the image for a given attribute number. 
-     * We use lazy initialisation here, i.e. the images are only loaded when they are requested. 
-     * @return
-     */
-    public mImage getImage() {
-    	if (_Id&lt;0 || _Id&gt;=maxAttRef) {
-    		return errorImage;
-    	}
-    	if (_Inc==1) {
-    		if (yesImages[_Id]==null) {yesImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return yesImages[_Id];
-    	}
-    	else if (_Inc==0) {
-    		if (noImages[_Id]==null) {noImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return noImages[_Id];
-    	} 
-    	else {
-    		if (nonImages[_Id]==null) {nonImages[_Id]=new mImage(IMAGEDIR+getImageName());}
-    		return nonImages[_Id];
-    	}
-    }	
+	}
+
+	/**
+	 * Get the image for a given attribute number. We use lazy initialisation here, i.e. the images are only loaded when they are requested.
+	 * 
+	 * @return
+	 */
+	public mImage getImage() {
+		if (_Id &lt; 0 || _Id &gt;= maxAttRef) {
+			return errorImage;
+		}
+		if (_Inc == 1) {
+			if (yesImages[_Id] == null) {
+				yesImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return yesImages[_Id];
+		} else if (_Inc == 0) {
+			if (noImages[_Id] == null) {
+				noImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return noImages[_Id];
+		} else {
+			if (nonImages[_Id] == null) {
+				nonImages[_Id] = new mImage(IMAGEDIR + getImageName());
+			}
+			return nonImages[_Id];
+		}
+	}
 }

Modified: branches/r1.2/src/CacheWolf/Attributes.java
===================================================================
--- branches/r1.2/src/CacheWolf/Attributes.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Attributes.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,133 +1,150 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 public class Attributes {
-	public Attributes(){} // Just a public constructor
-	public final static int MAXATTRIBS=12;
+	public Attributes() {
+	} // Just a public constructor
+
+	public final static int MAXATTRIBS = 12;
 	/**
 	 * The number of attributes for this cache (=number of array elements in use in attribs)
 	 */
-	private int _count=0;
+	private int _count = 0;
 	/**
 	 * The attributes as array of MAXATTRIBS Attribute
 	 */
-	private Attribute attribs[]=new Attribute[MAXATTRIBS];
+	private Attribute attribs[] = new Attribute[MAXATTRIBS];
 	/**
-	 * The attributes presence in Bit Representation 
+	 * The attributes presence in Bit Representation
 	 */
-	private long[] attrYes = {0l,0l};
-	private long[] attrNo = {0l,0l};	
+	private long[] attrYes = { 0l, 0l };
+	private long[] attrNo = { 0l, 0l };
+
 	/**
 	 * Get the number of attributes in the list
+	 * 
 	 * @return number of attributes
 	 */
-	public int count(){return _count;}	
+	public int count() {
+		return _count;
+	}
+
 	/**
-	 * getting an empty attributes list for this Cache 
+	 * getting an empty attributes list for this Cache
 	 */
 	public void clear() {
-		_count=0;
-		attrYes[0]=0l;
-		attrYes[1]=0l;
-		attrNo[0]=0l;
-		attrNo[1]=0l;
+		_count = 0;
+		attrYes[0] = 0l;
+		attrYes[1] = 0l;
+		attrNo[0] = 0l;
+		attrNo[1] = 0l;
 	}
+
 	/**
-	 *  Filling the Attributes from Cache.xml (CacheHolderDetail)
-	 *  todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
+	 * Filling the Attributes from Cache.xml (CacheHolderDetail)
+	 * todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public void XmlAttributesEnd(String elem){
+	public void XmlAttributesEnd(String elem) {
 		clear();
-		Extractor ex=new Extractor(elem,&quot;&lt;ATT&gt;&quot;,&quot;&lt;/ATT&gt;&quot;,0,true);
-		String dummy = ex.findNext();
-		while(ex.endOfSearch()==false){
+		Extractor ex = new Extractor(elem, &quot;&lt;ATT&gt;&quot;, &quot;&lt;/ATT&gt;&quot;, 0, true);
+		String dummy;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
 			add(dummy);
-			dummy = ex.findNext();
 		}
 	}
+
 	/**
-	 * Prepare for attributes to be written to cache.xml file 
-	 *  todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
+	 * Prepare for attributes to be written to cache.xml file
+	 * todo : remove this &quot;historic&quot; reprensentation , saving as Bits should be enough (araber95)
 	 */
-	public String XmlAttributesWrite(){
-		StringBuffer sb=new StringBuffer(1000);
+	public String XmlAttributesWrite() {
+		StringBuffer sb = new StringBuffer(1000);
 		sb.append(&quot;&lt;ATTRIBUTES&gt;\n&quot;);
-		for (int i=0; i&lt;_count; i++) {
+		for (int i = 0; i &lt; _count; i++) {
 			sb.append(&quot;   &lt;ATT&gt;&quot;);
 			sb.append(attribs[i].getImageName());
 			sb.append(&quot;&lt;/ATT&gt;\n&quot;);
 		}
 		sb.append(&quot;&lt;/ATTRIBUTES&gt;\n&quot;);
 		return sb.toString();
-	}	
+	}
+
 	/**
 	 * Add a new attribute to the array by Name, meaning its icon picture name
+	 * 
 	 * @param attributeName
 	 */
-	public void add(String attributeName){
-		if (_count&lt;attribs.length) {
-			if ( !attributeName.equalsIgnoreCase( &quot;attribute-blank.gif&quot; ) ) {
+	public void add(String attributeName) {
+		if (_count &lt; attribs.length) {
+			if (!attributeName.equalsIgnoreCase(&quot;attribute-blank.gif&quot;)) {
 				Attribute attr = new Attribute(attributeName);
 				attribs[_count++] = attr;
-				attrYes=attr.getYesBit(attrYes);
-				attrNo=attr.getNoBit(attrNo);
+				attrYes = attr.getYesBit(attrYes);
+				attrNo = attr.getNoBit(attrNo);
 			}
 		}
 	}
+
 	/**
 	 * Add a new attribute to the array by ID and Inc as you get it from GC gpx-File
-	 * @param GC attribute ID
-	 * @param GC attribute Inc (attribute set = 0 ,attribute  not set = 1)
+	 * 
+	 * @param GC
+	 *            attribute ID
+	 * @param GC
+	 *            attribute Inc (attribute set = 0 ,attribute not set = 1)
 	 */
 	public void add(int attIdGC, String Yes1No0) {
-		if (_count&lt;attribs.length) {
+		if (_count &lt; attribs.length) {
 			Attribute attr = new Attribute(attIdGC, Yes1No0);
 			boolean doAdd = true;
-			int replace=0;
+			int replace = 0;
 			for (int i = 0; i &lt; _count; i++) {
-				if (attribs[i].getGCId().equals(attr.getGCId())){
-					doAdd=false;
-					replace=i;
+				if (attribs[i].getGCId().equals(attr.getGCId())) {
+					doAdd = false;
+					replace = i;
 					break;
 				}
 			}
 			if (doAdd) {
 				attribs[_count++] = attr;
-			}
-			else {
+			} else {
 				// free old attr ?
-				attribs[replace]=attr;
+				attribs[replace] = attr;
 			}
-			attrYes=attr.getYesBit(attrYes);
-			attrNo=attr.getNoBit(attrNo);			
+			attrYes = attr.getYesBit(attrYes);
+			attrNo = attr.getNoBit(attrNo);
 		}
 	}
+
 	/**
-	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download 
-	 * @param OC attribute ID
+	 * Add a new attribute to the array by OC-IDas you get it from OC xml/zip-download
+	 * 
+	 * @param OC
+	 *            attribute ID
 	 */
 	public void add(int attIdOC) {
 		Attribute attr = new Attribute(attIdOC);
@@ -136,30 +153,34 @@
 				return;
 			}
 		}
-		if (_count&lt;attribs.length) {
+		if (_count &lt; attribs.length) {
 			attribs[_count++] = attr;
-			attrYes=attr.getYesBit(attrYes);
+			attrYes = attr.getYesBit(attrYes);
 		}
 	}
+
 	/**
 	 * to get the Bit Representation of the Attributs of this Cache
+	 * 
 	 * @return the Long array representing the Attributes of this Cache
 	 */
 	public long[] getAttribsAsBits() {
 		long ret[] = new long[4];
-		ret[0]=attrYes[0];
-		ret[1]=attrYes[1];
-		ret[2]=attrNo[0];
-		ret[3]=attrNo[1];
+		ret[0] = attrYes[0];
+		ret[1] = attrYes[1];
+		ret[2] = attrNo[0];
+		ret[3] = attrNo[1];
 		return ret;
 	}
+
 	/**
 	 * Get the i-th attribute
-	 * @param i The number for which the attribute is to be retrieved
+	 * 
+	 * @param i
+	 *            The number for which the attribute is to be retrieved
 	 * @return The attribute
 	 */
 	public Attribute getAttribute(int i) {
 		return attribs[i];
 	}
 }
-

Modified: branches/r1.2/src/CacheWolf/AttributesSelector.java
===================================================================
--- branches/r1.2/src/CacheWolf/AttributesSelector.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/AttributesSelector.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Image;
@@ -38,99 +38,107 @@
 
 public class AttributesSelector extends Panel {
 	protected static int TILESIZE;
-	protected static int W_OFFSET;  // depends on Global.getPref().fontSize ?
-	protected static int H_OFFSET;	// depends on Global.getPref().fontSize ?
-	private long[] selectionMaskYes = {0l,0l};
-	private long[] selectionMaskNo = {0l,0l};
+	protected static int W_OFFSET; // depends on Global.getPref().fontSize ?
+	protected static int H_OFFSET; // depends on Global.getPref().fontSize ?
+	private long[] selectionMaskYes = { 0l, 0l };
+	private long[] selectionMaskNo = { 0l, 0l };
 	protected mLabel mInfo;
-	protected InteractivePanel iap=new attInteractivePanel();
+	protected InteractivePanel iap = new attInteractivePanel();
 	protected MyScrollBarPanel scp = new MyScrollBarPanel(iap);
-	private int virtualWidth; 
+	private int virtualWidth;
 
 	public AttributesSelector() {
 		scp.setOptions(MyScrollBarPanel.NeverShowHorizontalScrollers);
-		TILESIZE = 30; W_OFFSET=100; H_OFFSET=150;
-		if(Vm.isMobile()){
-			if(MyLocale.getScreenWidth() == 240 &amp; MyLocale.getScreenHeight() == 320){
-				TILESIZE = 28; W_OFFSET=80; H_OFFSET=120;
+		TILESIZE = 30;
+		W_OFFSET = 100;
+		H_OFFSET = 150;
+		if (Vm.isMobile()) {
+			if (MyLocale.getScreenWidth() == 240 &amp; MyLocale.getScreenHeight() == 320) {
+				TILESIZE = 28;
+				W_OFFSET = 80;
+				H_OFFSET = 120;
 			}
-			if(MyLocale.getScreenWidth() == 320 &amp; MyLocale.getScreenHeight() == 240){
+			if (MyLocale.getScreenWidth() == 320 &amp; MyLocale.getScreenHeight() == 240) {
 			}
-			if(MyLocale.getScreenWidth() == 480 &amp; MyLocale.getScreenHeight() == 640){
+			if (MyLocale.getScreenWidth() == 480 &amp; MyLocale.getScreenHeight() == 640) {
 			}
-			if(MyLocale.getScreenWidth() == 480 &amp; MyLocale.getScreenHeight() == 800){
+			if (MyLocale.getScreenWidth() == 480 &amp; MyLocale.getScreenHeight() == 800) {
 			}
-			if(MyLocale.getScreenWidth() == 640 &amp; MyLocale.getScreenHeight() == 480){
+			if (MyLocale.getScreenWidth() == 640 &amp; MyLocale.getScreenHeight() == 480) {
 			}
+		} else {
+			TILESIZE = 36;
+			W_OFFSET = 106;
+			H_OFFSET = 150;
 		}
-		else {
-			TILESIZE = 36; W_OFFSET=106; H_OFFSET=150;
-		}
-		iap.virtualSize = new Rect(0,0,0,0); // create once
-		addLast(scp,STRETCH,FILL);
-		addLast(mInfo=new mLabel(&quot;&quot;),HSTRETCH,HFILL);
+		iap.virtualSize = new Rect(0, 0, 0, 0); // create once
+		addLast(scp, STRETCH, FILL);
+		addLast(mInfo = new mLabel(&quot;&quot;), HSTRETCH, HFILL);
 	}
 
 	public void setSelectionMasks(long[] SelectionMasks) {
 		selectionMaskYes[0] = SelectionMasks[0];
 		selectionMaskYes[1] = SelectionMasks[1];
 		selectionMaskNo[0] = SelectionMasks[2];
-		selectionMaskNo[1] = SelectionMasks[3];		
+		selectionMaskNo[1] = SelectionMasks[3];
 		showAttributePalette();
 	}
-	
+
 	public long[] getSelectionMasks() {
 		long[] SelectionMasks = new long[4];
 		SelectionMasks[0] = selectionMaskYes[0];
 		SelectionMasks[1] = selectionMaskYes[1];
 		SelectionMasks[2] = selectionMaskNo[0];
-		SelectionMasks[3] = selectionMaskNo[1];		
+		SelectionMasks[3] = selectionMaskNo[1];
 		return SelectionMasks;
 	}
-	
+
 	public boolean isSetSelectionMask() {
-		return  selectionMaskYes[0] != 0l || selectionMaskNo[0] != 0l ||
-				selectionMaskYes[1] != 0l || selectionMaskNo[1] != 0l;
+		return selectionMaskYes[0] != 0l || selectionMaskNo[0] != 0l || selectionMaskYes[1] != 0l || selectionMaskNo[1] != 0l;
 	}
 
 	protected class attImage extends AniImage {
-		public Attribute att;		
-		attImage (mImage img, Attribute _att) {
+		public Attribute att;
+
+		attImage(mImage img, Attribute _att) {
 			super(img);
-			att=_att;
-		}		
+			att = _att;
+		}
+
 		attImage(attImage cp, int val) {
-			att=cp.att;
+			att = cp.att;
 			att.setInc(val);
-			mImage rawImg=att.getImage();
-			setMImage (rawImg.getHeight()!=TILESIZE-2 ? rawImg.scale(TILESIZE-2,TILESIZE-2,null,Image.FOR_DISPLAY) : rawImg  );
+			mImage rawImg = att.getImage();
+			setMImage(rawImg.getHeight() != TILESIZE - 2 ? rawImg.scale(TILESIZE - 2, TILESIZE - 2, null, Image.FOR_DISPLAY) : rawImg);
 			location = cp.location;
 		}
 	}
-	
+
 	protected class attInteractivePanel extends InteractivePanel {
 		public boolean imageMovedOn(AniImage which) {
-			mInfo.setText(((attImage)which).att.getMsg());			
+			mInfo.setText(((attImage) which).att.getMsg());
 			mInfo.repaintNow();
 			return true;
 		}
+
 		public boolean imageMovedOff(AniImage which) {
 			mInfo.setText(&quot;&quot;);
 			mInfo.repaintNow();
 			return true;
 		}
+
 		public boolean imagePressed(AniImage which, Point pos) {
 			if (which != null) {
-				int value=((attImage)which).att.getInc();
-				value=(value + 1) % 3;
-				((attImage)which).att.setInc(value);
-				selectionMaskNo=((attImage)which).att.getNoBit(selectionMaskNo);
-				selectionMaskYes=((attImage)which).att.getYesBit(selectionMaskYes);
-				attImage tmpImg = new attImage(((attImage)which), value );
+				int value = ((attImage) which).att.getInc();
+				value = (value + 1) % 3;
+				((attImage) which).att.setInc(value);
+				selectionMaskNo = ((attImage) which).att.getNoBit(selectionMaskNo);
+				selectionMaskYes = ((attImage) which).att.getYesBit(selectionMaskYes);
+				attImage tmpImg = new attImage(((attImage) which), value);
 				removeImage(which);
 				addImage(tmpImg);
 				refresh();
-				notifyDataChange(new DataChangeEvent(DataChangeEvent.DATA_CHANGED,this));
+				notifyDataChange(new DataChangeEvent(DataChangeEvent.DATA_CHANGED, this));
 			}
 			return true;
 		}
@@ -139,51 +147,49 @@
 	private void showAttributePalette() {
 		iap.images.clear();
 		int myWidth = virtualWidth;
-		int myX = 2; int myY = 2;
+		int myX = 2;
+		int myY = 2;
 		int inc = 2;
 		for (int i = 0; i &lt; Attribute.maxAttRef; i++) {
 			long[] bitMask = Attribute.getIdBit(i);
-			if ( ((selectionMaskYes[0] &amp; bitMask[0]) != 0 ) || 
-					((selectionMaskYes[1] &amp; bitMask[1]) != 0 ))
+			if (((selectionMaskYes[0] &amp; bitMask[0]) != 0) || ((selectionMaskYes[1] &amp; bitMask[1]) != 0))
 				inc = 1;
-			else if ( ((selectionMaskNo[0] &amp; bitMask[0]) != 0 ) ||
-					((selectionMaskNo[1] &amp; bitMask[1]) != 0 ))
+			else if (((selectionMaskNo[0] &amp; bitMask[0]) != 0) || ((selectionMaskNo[1] &amp; bitMask[1]) != 0))
 				inc = 0;
 			else
-				inc = 2;			
-			Attribute att = new Attribute(i,inc); 
-			mImage rawImg=att.getImage();
-			attImage img=new attImage(rawImg.getHeight()!=TILESIZE-2 ? rawImg.scale(TILESIZE-2,TILESIZE-2,null,Image.FOR_DISPLAY) : rawImg, att);
+				inc = 2;
+			Attribute att = new Attribute(i, inc);
+			mImage rawImg = att.getImage();
+			attImage img = new attImage(rawImg.getHeight() != TILESIZE - 2 ? rawImg.scale(TILESIZE - 2, TILESIZE - 2, null, Image.FOR_DISPLAY) : rawImg, att);
 
-			if (myX+TILESIZE &gt; myWidth) {
+			if (myX + TILESIZE &gt; myWidth) {
 				myX = 2;
 				myY += TILESIZE;
 			}
-			img.location=new Rect(myX,myY,TILESIZE,TILESIZE);
+			img.location = new Rect(myX, myY, TILESIZE, TILESIZE);
 			iap.addImage(img);
 			myX += TILESIZE;
-			
+
 		}
-		iap.repaintNow();		
+		iap.repaintNow();
 	}
-	
 
 	private void setIapSize(int width, int height) {
 		iap.setPreferredSize(width, height);
-		Global.getPref().log(&quot;[AttributesSelector:changeIapSize]  pref. area: &quot;+width+&quot;x&quot;+height);
+		Global.getPref().log(&quot;[AttributesSelector:changeIapSize]  pref. area: &quot; + width + &quot;x&quot; + height);
 
-		int anzPerWidth = width / (TILESIZE+2);
-		virtualWidth = anzPerWidth * (TILESIZE+2);
+		int anzPerWidth = width / (TILESIZE + 2) - 1;
+		virtualWidth = anzPerWidth * (TILESIZE + 2);
 		double max = Attribute.maxAttRef;
 		int anzPerHeight = (int) java.lang.Math.ceil(max / anzPerWidth);
-		iap.virtualSize.set(0,0,virtualWidth ,anzPerHeight * (TILESIZE+2));
-		Global.getPref().log(&quot;[AttributesSelector:setIapSize] virt. area: &quot;+virtualWidth+&quot;x&quot;+anzPerHeight * (TILESIZE+2));
+		iap.virtualSize.set(0, 0, virtualWidth, anzPerHeight * (TILESIZE + 2));
+		Global.getPref().log(&quot;[AttributesSelector:setIapSize] virt. area: &quot; + virtualWidth + &quot;x&quot; + anzPerHeight * (TILESIZE + 2));
 
 	}
 
 	public void changeIapSize(int width, int height) {
-		Global.getPref().log(&quot;[AttributesSelector:changeIapSize]  max. area: &quot;+width+&quot;x&quot;+height);
-		setIapSize(width-W_OFFSET, height-H_OFFSET);
+		Global.getPref().log(&quot;[AttributesSelector:changeIapSize]  max. area: &quot; + width + &quot;x&quot; + height);
+		setIapSize(width - W_OFFSET, height - H_OFFSET);
 		showAttributePalette();
 	}
 

Modified: branches/r1.2/src/CacheWolf/CacheHolder.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheHolder.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheHolder.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,33 +1,34 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.exp.Exporter;
 import CacheWolf.exp.GarminMap;
 import CacheWolf.navi.Metrics;
+import CacheWolf.navi.TrackPoint;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -45,12 +46,11 @@
 import ewe.util.Vector;
 
 /**
- *	A class to hold information on a cache.&lt;br&gt;
- *	Not all attributes are filled at once. You will have to look at other
- *	classes and methods to get more information.
- *	
+ * A class to hold information on a cache.&lt;br&gt;
+ * Not all attributes are filled at once. You will have to look at other classes and methods to get more information.
+ * 
  */
-public class CacheHolder{
+public class CacheHolder {
 	protected static final String NOBEARING = &quot;?&quot;;
 	protected static final String EMPTY = &quot;&quot;;
 
@@ -59,13 +59,11 @@
 	/** The name of the waypoint, typically GC.... or OC.... or CW...... (can be any characters) */
 	private String wayPoint = EMPTY;
 	/** The name of the cache (short description) */
-	public String cacheName = EMPTY;
+	private String cacheName = EMPTY;
 	/** The alias of the owner */
 	private String cacheOwner = EMPTY;
 	/** The coordinates of the cache */
-	public CWPoint pos = new CWPoint();
-	/** The coordinates of the cache */
-	private String LatLon = pos.toString();
+	private CWPoint pos = new CWPoint();
 	/** The date when the cache was hidden in format yyyy-mm-dd */
 	private String dateHidden = EMPTY;
 	/** The size of the cache (as per GC cache sizes Micro, Small, ....) */
@@ -79,12 +77,12 @@
 	private String bearing = NOBEARING;
 	/** The angle (0=North, 180=South) from the current centre to this point */
 	public double degrees = 0;
-	/** The difficulty of the cache from 1 to 5 in .5 incements */ 
+	/** The difficulty of the cache from 1 to 5 in .5 incements */
 	private byte hard = CacheTerrDiff.CW_DT_UNSET;
 	/** The terrain rating of the cache from 1 to 5 in .5 incements */
 	private byte terrain = CacheTerrDiff.CW_DT_UNSET;
-	/** The cache type (@see CacheType for translation table)  */
-	private byte type; 
+	/** The cache type (@see CacheType for translation table) */
+	private byte type;
 	/** True if the cache has been archived */
 	private boolean archived = false;
 	/** True if the cache is available for searching */
@@ -97,7 +95,7 @@
 	private boolean filtered = false;
 	/** True if the number of logs for this cache has changed */
 	private boolean log_updated = false;
-	/** True if cache details have changed: longDescription, Hints,  */
+	/** True if cache details have changed: longDescription, Hints, */
 	private boolean cache_updated = false;
 	/** True if the cache data is incomplete (e.g. an error occurred during spidering */
 	private boolean incomplete = false;
@@ -119,7 +117,7 @@
 	private int numRecommended = 0;
 	/** Number of Founds since start of recommendations system */
 	private int numFoundsSinceRecommendation = 0;
-	/** Recommendation score: calculated as rations  numRecommended / numLogsSinceRecommendation * 100 */
+	/** Recommendation score: calculated as rations numRecommended / numLogsSinceRecommendation * 100 */
 	public int recommendationScore = 0;
 	/** True if this cache has travelbugs */
 	private boolean bugs = false;
@@ -127,7 +125,7 @@
 	private boolean html = true;
 	/** List of additional waypoints associated with this waypoint */
 	public Vector addiWpts = new Vector();
-	/** in range is used by the route filter to identify caches in range of a segment*/
+	/** in range is used by the route filter to identify caches in range of a segment */
 	public boolean in_range = false;
 	/** If this is an additional waypoint, this links back to the main waypoint */
 	public CacheHolder mainCache;
@@ -138,304 +136,295 @@
 	/** True if a note is entered for the cache */
 	private boolean hasNote = false;
 	private CacheHolderDetail details = null;
-	/** When sorting the cacheDB this field is used. The relevant field is copied here and
-	 *  the sort is always done on this field to speed up the sorting process 
+	/**
+	 * When sorting the cacheDB this field is used. The relevant field is copied here and the sort is always done on this field to speed up the sorting process
 	 */
 	public String sort;
-	private static StringBuffer sb=new StringBuffer(530); // Used in toXML()
+	private static StringBuffer sb = new StringBuffer(530); // Used in toXML()
 
-	private long[] attributesBits = {0l,0l,0l,0l};
-	
+	private long[] attributesBits = { 0l, 0l, 0l, 0l };
+
 	private IconAndText iconAndTextWP = null;
 	private int iconAndTextWPLevel = 0;
 
-	static char decSep,notDecSep;
+	static char decSep, notDecSep;
 	static {
-		decSep=MyLocale.getDigSeparator().charAt(0);
-		notDecSep = (decSep == '.'?',':'.');
+		decSep = MyLocale.getDigSeparator().charAt(0);
+		notDecSep = (decSep == '.' ? ',' : '.');
 	}
 
 	public CacheHolder() {
 		// do nothing
 	}
-	
+
 	public CacheHolder(String wp) {
 		wayPoint = wp;
-		type=CacheType.CW_TYPE_ERROR;
-    }
-	
+		type = CacheType.CW_TYPE_ERROR;
+	}
+
 	public CacheHolder(String xmlString, int version) {
-		int start,end;
-	        try {
-				if (version == 1) {
-			        start = xmlString.indexOf('&quot;');
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        // Assume coordinates are in decimal format
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-			                notDecSep, decSep));
-			        pos = new CWPoint(lat, lon);
-			        LatLon = pos.toString();
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setDateHidden(xmlString.substring(start + 1, end));
-			        // Convert the US format to YYYY-MM-DD if necessary
-			        if (getDateHidden().indexOf('/') &gt; -1)
-				        setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setCacheStatus(xmlString.substring(start + 1, end));
-			        
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-		        	setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
-		            
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setHard(CacheTerrDiff.CW_DT_UNSET);
-			        } else {
-				        try {
-				        	setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setHard(CacheTerrDiff.CW_DT_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('&quot;', end + 1);
-				    end = xmlString.indexOf('&quot;', start + 1);
-				    if (isAddiWpt() || isCustomWpt()) {
-				    	setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				    } else {
-					    try {
-					    	setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
-					    } catch (IllegalArgumentException ex) {
-					    	setTerrain(CacheTerrDiff.CW_DT_ERROR);
-					    	setIncomplete(true);
-					    	Global.getPref().log(wayPoint, ex, true);
-				        }
-				    }
-			        // The next item was 'dirty' but this is no longer used.
-		            start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setFiltered(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        if (isAddiWpt() || isCustomWpt()) {
-			        	setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-			        } else {
-				        try {
-				        	setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
-				        } catch (IllegalArgumentException ex) {
-				        	setCacheSize(CacheSize.CW_SIZE_ERROR);
-				        	setIncomplete(true);
-				        	Global.getPref().log(wayPoint, ex, true);
-				        }
-			        }
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setAvailable(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setArchived(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setHas_bugs(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setBlack(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setOwned(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setFound(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setNew(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setLog_updated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setUpdated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
-			        // for backwards compatibility set value to true, if it is not in the file
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setHTML(!xmlString.substring(start + 1, end).equals(&quot;false&quot;));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-		            setNoFindLogs((byte)Convert.toInt(xmlString.substring(start + 1, end)));
-	
-		            start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setOcCacheID(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;) || incomplete);
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setLastSync(xmlString.substring(start + 1, end));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-			        end = xmlString.indexOf('&quot;', start + 1);
-			        setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-			        recommendationScore = LogList.getScore(getNumRecommended(),
-			                getNumFoundsSinceRecommendation());
-	
-			        start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-		            if (start &gt; -1 &amp;&amp; end &gt; -1) {
-		            	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		        		
-				        start = xmlString.indexOf('&quot;', end + 1);
-				        end = xmlString.indexOf('&quot;', start + 1);
-				        if (start &gt; -1 &amp;&amp; end &gt; -1)
-			            	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            setAttribsAsBits(attribsBits);
-	            } else if (version == 3 || version == 2) {
-		            start = xmlString.indexOf('&quot;');
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            // Assume coordinates are in decimal format
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(
-		                    notDecSep, decSep));
-		            pos = new CWPoint(lat, lon);
-		            LatLon = pos.toString();
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setDateHidden(xmlString.substring(start + 1, end));
-		            // Convert the US format to YYYY-MM-DD if necessary
-		            if (getDateHidden().indexOf('/') &gt; -1)
-			            setDateHidden(DateFormat.MDY2YMD(getDateHidden()));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setCacheStatus(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setOcCacheID(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setLastSync(xmlString.substring(start + 1, end));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
-		            recommendationScore = LogList.getScore(getNumRecommended(),
-		                    getNumFoundsSinceRecommendation());
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            long[] attribsBits={0l,0l,0l,0l};
-			        if (start &gt; -1 &amp;&amp; end &gt; -1) {
-			        	attribsBits[0]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('&quot;', end + 1);
-				        end = xmlString.indexOf('&quot;', start + 1);
-				        if (start &gt; -1 &amp;&amp; end &gt; -1)
-				        	attribsBits[2]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-		            if (version == 2) {
-		            	long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            } else {
-		            	long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
-		            }
-		            start = xmlString.indexOf('&quot;', end + 1);
-		            end = xmlString.indexOf('&quot;', start + 1);
-			        if (start &gt; -1 &amp;&amp; end &gt; -1) {
-			        	attribsBits[1]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-	
-				        start = xmlString.indexOf('&quot;', end + 1);
-				        end = xmlString.indexOf('&quot;', start + 1);
-				        if (start &gt; -1 &amp;&amp; end &gt; -1)
-				        	attribsBits[3]=(Convert.parseLong(xmlString.substring(start + 1, end)));
-			        }
-			        setAttribsAsBits(attribsBits);
-	            }
-				if (version &lt; Profile.CURRENTFILEFORMAT) {
-		            // forceload of details, creates waypoint.xml if missing
-		            details = getCacheDetails(false);
-		            // make sure details get (re)written in new format
-		            details.hasUnsavedChanges = true;
-		            // update information on notes and solver info
-		            setHasNote(!details.getCacheNotes().equals(&quot;&quot;));
-			    setHasSolver(!details.getSolver().equals(&quot;&quot;));
+		int start, end;
+		try {
+			if (version == 1) {
+				start = xmlString.indexOf('&quot;');
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos.set(lat, lon);
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') &gt; -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setType(CacheType.v1Converter((xmlString.substring(start + 1, end))));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setHard(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setHard(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
 				}
-	        } catch (Exception ex) {
-	        	// Global.getPref().log(&quot;Ignored Exception in CacheHolder()&quot;, ex, true);
-	        }
-        }
-	
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				} else {
+					try {
+						setTerrain(CacheTerrDiff.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setTerrain(CacheTerrDiff.CW_DT_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				// The next item was 'dirty' but this is no longer used.
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setFiltered(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (isAddiWpt() || isCustomWpt()) {
+					setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				} else {
+					try {
+						setCacheSize(CacheSize.v1Converter(xmlString.substring(start + 1, end)));
+					} catch (IllegalArgumentException ex) {
+						setCacheSize(CacheSize.CW_SIZE_ERROR);
+						setIncomplete(true);
+						Global.getPref().log(wayPoint, ex, true);
+					}
+				}
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setAvailable(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setArchived(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setHas_bugs(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setBlack(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setOwned(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setFound(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNew(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setLog_updated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setUpdated(xmlString.substring(start + 1, end).equals(&quot;true&quot;));
+				// for backwards compatibility set value to true, if it is not in the file
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setHTML(!xmlString.substring(start + 1, end).equals(&quot;false&quot;));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNoFindLogs((byte) Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setIncomplete(xmlString.substring(start + 1, end).equals(&quot;true&quot;) || incomplete);
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start &gt; -1 &amp;&amp; end &gt; -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('&quot;', end + 1);
+					end = xmlString.indexOf('&quot;', start + 1);
+					if (start &gt; -1 &amp;&amp; end &gt; -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			} else if (version == 3 || version == 2) {
+				start = xmlString.indexOf('&quot;');
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheName(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheOwner(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				// Assume coordinates are in decimal format
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lat = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				double lon = Convert.parseDouble(xmlString.substring(start + 1, end).replace(notDecSep, decSep));
+				pos = new CWPoint(lat, lon);
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setDateHidden(xmlString.substring(start + 1, end));
+				// Convert the US format to YYYY-MM-DD if necessary
+				if (getDateHidden().indexOf('/') &gt; -1)
+					setDateHidden(DateFormat.toYYMMDD(getDateHidden()));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setWayPoint(SafeXML.cleanback(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setCacheStatus(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setOcCacheID(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setLastSync(xmlString.substring(start + 1, end));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumRecommended(Convert.toInt(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				setNumFoundsSinceRecommendation(Convert.toInt(xmlString.substring(start + 1, end)));
+				recommendationScore = LogList.getScore(getNumRecommended(), getNumFoundsSinceRecommendation());
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				long[] attribsBits = { 0l, 0l, 0l, 0l };
+				if (start &gt; -1 &amp;&amp; end &gt; -1) {
+					attribsBits[0] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('&quot;', end + 1);
+					end = xmlString.indexOf('&quot;', start + 1);
+					if (start &gt; -1 &amp;&amp; end &gt; -1)
+						attribsBits[2] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				this.long2boolFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (version == 2) {
+					long2byteFieldsv2(Convert.parseLong(xmlString.substring(start + 1, end)));
+				} else {
+					long2byteFields(Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				start = xmlString.indexOf('&quot;', end + 1);
+				end = xmlString.indexOf('&quot;', start + 1);
+				if (start &gt; -1 &amp;&amp; end &gt; -1) {
+					attribsBits[1] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+
+					start = xmlString.indexOf('&quot;', end + 1);
+					end = xmlString.indexOf('&quot;', start + 1);
+					if (start &gt; -1 &amp;&amp; end &gt; -1)
+						attribsBits[3] = (Convert.parseLong(xmlString.substring(start + 1, end)));
+				}
+				setAttribsAsBits(attribsBits);
+			}
+			if (version &lt; Profile.CURRENTFILEFORMAT) {
+				// forceload of details, creates waypoint.xml if missing
+				details = getCacheDetails(false);
+				// make sure details get (re)written in new format
+				details.hasUnsavedChanges = true;
+				// update information on notes and solver info
+				setHasNote(!details.getCacheNotes().equals(&quot;&quot;));
+				setHasSolver(!details.getSolver().equals(&quot;&quot;));
+			}
+		} catch (Exception ex) {
+			// Global.getPref().log(&quot;Ignored Exception in CacheHolder()&quot;, ex, true);
+		}
+	}
+
 	/**
-	 * Returns the distance in formatted output. Using kilometers when metric system is active,
-	 * using miles when imperial system is active.
+	 * Returns the distance in formatted output. Using kilometers when metric system is active, using miles when imperial system is active.
 	 * 
 	 * @return The current distance.
 	 */
@@ -461,8 +450,7 @@
 				}
 				result = MyLocale.formatDouble(newValue, &quot;0.00&quot;) + &quot; &quot; + newUnit;
 			} else {
-				result = &quot;? &quot;
-				        + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
+				result = &quot;? &quot; + (Global.getPref().metricSystem == Metrics.IMPERIAL ? Metrics.getUnit(Metrics.MILES) : Metrics.getUnit(Metrics.KILOMETER));
 			}
 			// Caching values, so reevaluation is only done when really needed
 			this.lastKilom = this.kilom;
@@ -471,31 +459,26 @@
 		}
 		return result;
 	}
-	/** 
-	 * Updates Cache information with information provided by cache given as argument. This is used
-	 * to update the cache with the information retrieved from files or web: The argument cache
-	 * is the one that is filled with the read information, &lt;code&gt;this&lt;/code&gt; is the cache that
-	 * is already in the database and subject to update. 
-	 * @param ch The cache who's information is updating the current one
-	 * @param overwrite If &lt;code&gt;true&lt;/code&gt;, then &lt;i&gt;status&lt;/i&gt;, &lt;i&gt;is_found&lt;/i&gt; and &lt;i&gt;position&lt;/i&gt;
-	 * is updated, otherwise not.
+
+	/**
+	 * Updates Cache information with information provided by cache given as argument. This is used to update the cache with the information retrieved from files or web: The argument cache is the one that is filled with the read information,
+	 * &lt;code&gt;this&lt;/code&gt; is the cache that is already in the database and subject to update.
+	 * 
+	 * @param ch
+	 *            The cache who's information is updating the current one
+	 * @param overwrite
+	 *            If &lt;code&gt;true&lt;/code&gt;, then &lt;i&gt;status&lt;/i&gt;, &lt;i&gt;is_found&lt;/i&gt; and &lt;i&gt;position&lt;/i&gt; is updated, otherwise not.
 	 */
 	public void update(CacheHolder ch) {
 		this.recommendationScore = ch.recommendationScore;
 		this.setNumFoundsSinceRecommendation(ch.getNumFoundsSinceRecommendation());
 		this.setNumRecommended(ch.getNumRecommended());
-		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362,&quot;solved&quot;));
-		/* Here we have to distinguish several cases:
-		 * this.is_found       this                ch               Update 'this'
-		 *                                         (values are
-		 *                                     empty or yyyy-mm-dd)
-		 * ----------------------------------------------------------------------
-		 * false               any                 yyyy-mm-dd       yes
-		 * true                &quot;Found&quot;             yyyy-mm-dd       yes
-		 * true                yyyy-mm-dd          yyyy-mm-dd       yes (or no)
-		 * true                yyyy-mm-dd hh:mm    yyyy-mm-dd       no
-		*/
-		if (!this.found || this.cacheStatus.indexOf(&quot;:&quot;)&lt;0) {
+		boolean mayChangeCoordinates = !this.cacheStatus.startsWith(MyLocale.getMsg(362, &quot;solved&quot;));
+		/*
+		 * Here we have to distinguish several cases: this.is_found this ch Update 'this' (values are empty or yyyy-mm-dd) ---------------------------------------------------------------------- false any yyyy-mm-dd yes true &quot;Found&quot; yyyy-mm-dd yes true
+		 * yyyy-mm-dd yyyy-mm-dd yes (or no) true yyyy-mm-dd hh:mm yyyy-mm-dd no
+		 */
+		if (!this.found || this.cacheStatus.indexOf(&quot;:&quot;) &lt; 0) {
 			// don't overwrite with empty data
 			if (!ch.getCacheStatus().trim().equals(&quot;&quot;)) {
 				this.setCacheStatus(ch.getCacheStatus());
@@ -506,7 +489,6 @@
 		if (ch.pos.isValid() || !this.pos.isValid()) {
 			if (mayChangeCoordinates) {
 				this.pos = ch.pos;
-				this.LatLon = ch.LatLon;
 			}
 		}
 		this.setWayPoint(ch.getWayPoint());
@@ -527,19 +509,21 @@
 		this.setFiltered(ch.is_filtered());
 		this.setIncomplete(ch.is_incomplete());
 		this.addiWpts = ch.addiWpts;
-		this.mainCache=ch.mainCache;
-		this.setOcCacheID(ch.getOcCacheID());
+		this.mainCache = ch.mainCache;
+		if (ch.getOcCacheID().length() &gt; 0)
+			this.setOcCacheID(ch.getOcCacheID());
 		this.setNoFindLogs(ch.getNoFindLogs());
 		this.setHas_bugs(ch.has_bugs());
 		this.setHTML(ch.is_HTML());
-		this.sort=ch.sort;
+		this.sort = ch.sort;
 		this.setLastSync(ch.getLastSync());
 
 		this.setAttribsAsBits(ch.getAttributesBits());
 		if (ch.detailsLoaded()) {
 			this.getCacheDetails(false).update(ch.getCacheDetails(false));
-		}	
+		}
 	}
+
 	/**
 	 * Call it only when necessary, it takes time, because all logs must be parsed
 	 */
@@ -565,84 +549,93 @@
 		} else {
 			recommendationScore = -1;
 			setNumFoundsSinceRecommendation(-1);
-//			setNumRecommended(-1);
+			// setNumRecommended(-1);
 		}
 	}
-	
+
 	/** Return a XML string containing all the cache data for storing in index.xml */
 	public String toXML() {
-		calcRecommendationScore(); 
-		sb.delete(0,sb.length());
+		calcRecommendationScore();
+		sb.delete(0, sb.length());
 		sb.append(&quot;    &lt;CACHE &quot;);
-		sb.append(&quot; name = \&quot;&quot;);        sb.append(SafeXML.clean(getCacheName()));
-		sb.append(&quot;\&quot; owner = \&quot;&quot;);		sb.append(SafeXML.clean(getCacheOwner()));
-		sb.append(&quot;\&quot; lat = \&quot;&quot;); 		sb.append(pos.latDec ); 
-		sb.append(&quot;\&quot; lon = \&quot;&quot;);		sb.append(pos.lonDec);
-		sb.append(&quot;\&quot; hidden = \&quot;&quot;);	sb.append(getDateHidden());
-		sb.append(&quot;\&quot; wayp = \&quot;&quot;);		sb.append(SafeXML.clean(getWayPoint()));
-		sb.append(&quot;\&quot; status = \&quot;&quot;);	sb.append(getCacheStatus());
-		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot; );sb.append(getOcCacheID()); 
-		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot; );sb.append(getLastSync()); 
-		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);sb.append(Convert.formatInt(getNumRecommended())); 
-		sb.append(&quot;\&quot; num_found = \&quot;&quot; );sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
+		sb.append(&quot; name = \&quot;&quot;);
+		sb.append(SafeXML.clean(getCacheName()));
+		sb.append(&quot;\&quot; owner = \&quot;&quot;);
+		sb.append(SafeXML.clean(getCacheOwner()));
+		sb.append(&quot;\&quot; lat = \&quot;&quot;);
+		sb.append(pos.latDec);
+		sb.append(&quot;\&quot; lon = \&quot;&quot;);
+		sb.append(pos.lonDec);
+		sb.append(&quot;\&quot; hidden = \&quot;&quot;);
+		sb.append(getDateHidden());
+		sb.append(&quot;\&quot; wayp = \&quot;&quot;);
+		sb.append(SafeXML.clean(getWayPoint()));
+		sb.append(&quot;\&quot; status = \&quot;&quot;);
+		sb.append(getCacheStatus());
+		sb.append(&quot;\&quot; ocCacheID = \&quot;&quot;);
+		sb.append(getOcCacheID());
+		sb.append(&quot;\&quot; lastSyncOC = \&quot;&quot;);
+		sb.append(getLastSync());
+		sb.append(&quot;\&quot; num_recommended = \&quot;&quot;);
+		sb.append(Convert.formatInt(getNumRecommended()));
+		sb.append(&quot;\&quot; num_found = \&quot;&quot;);
+		sb.append(Convert.formatInt(getNumFoundsSinceRecommendation()));
 		long[] attribsBits = getAttributesBits();
-		sb.append(&quot;\&quot; attributesYes = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[0]));
-		sb.append(&quot;\&quot; attributesNo = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[2]));
-		sb.append(&quot;\&quot; boolFields=\&quot;&quot; ); sb.append(Convert.formatLong(this.boolFields2long()));
-		sb.append(&quot;\&quot; byteFields=\&quot;&quot; ); sb.append(Convert.formatLong(this.byteFields2long()));
-		sb.append(&quot;\&quot; attributesYes1 = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[1]));
-		sb.append(&quot;\&quot; attributesNo1 = \&quot;&quot; ); sb.append(Convert.formatLong(attribsBits[3]));
+		sb.append(&quot;\&quot; attributesYes = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[0]));
+		sb.append(&quot;\&quot; attributesNo = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[2]));
+		sb.append(&quot;\&quot; boolFields=\&quot;&quot;);
+		sb.append(Convert.formatLong(this.boolFields2long()));
+		sb.append(&quot;\&quot; byteFields=\&quot;&quot;);
+		sb.append(Convert.formatLong(this.byteFields2long()));
+		sb.append(&quot;\&quot; attributesYes1 = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[1]));
+		sb.append(&quot;\&quot; attributesNo1 = \&quot;&quot;);
+		sb.append(Convert.formatLong(attribsBits[3]));
 		sb.append(&quot;\&quot; /&gt;\n&quot;);
 		return sb.toString();
 	}
-	
+
 	/** Return a Hashtable containing all the cache data for Templates */
-	public Hashtable toHashtable(
-			Regex decSep, Regex badChars, 
-			int shortWaypointLength, int shortNameLength, int nrOfLogs,
-			TextCodec codec, GarminMap gm,
-			boolean withFoundText,
-			int ModTyp,
-			String expName
-			) {
+	public Hashtable toHashtable(Regex decSep, Regex badChars, int shortWaypointLength, int shortNameLength, int nrOfLogs, TextCodec codec, GarminMap gm, boolean withFoundText, int ModTyp, String expName) {
 		Hashtable varParams = new Hashtable();
 		CacheHolderDetail det = this.getCacheDetails(false);
 		varParams.put(&quot;PROGDIR&quot;, FileBase.getProgramDirectory());
 		varParams.put(&quot;PROFILDIR&quot;, Global.getProfile().dataDir);
 		varParams.put(&quot;ALIAS&quot;, Global.getPref().myAlias);
-		varParams.put(&quot;TYPE&quot;, CacheType.type2TypeTag(type)); //&lt;type&gt;
-		varParams.put(&quot;TYPENO&quot;,&quot;&quot;+type);
-		varParams.put(&quot;SYM&quot;, CacheType.type2SymTag(type)); //&lt;sym&gt;
-		varParams.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(type)); //&lt;groundspeak:type&gt;
+		varParams.put(&quot;TYPE&quot;, CacheType.type2TypeTag(type)); // &lt;type&gt;
+		varParams.put(&quot;TYPENO&quot;, &quot;&quot; + type);
+		varParams.put(&quot;SYM&quot;, CacheType.type2SymTag(type)); // &lt;sym&gt;
+		varParams.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(type)); // &lt;groundspeak:type&gt;
 		varParams.put(&quot;SHORTTYPE&quot;, CacheType.getExportShortId(type));
 		if (isAddiWpt()) {
-			CacheHolder ch=this.mainCache;
-			varParams.put(&quot;MAINWP&quot;,ch.getWayPoint());
+			CacheHolder ch = this.mainCache;
+			varParams.put(&quot;MAINWP&quot;, ch.getWayPoint());
 			varParams.put(&quot;MAINWPNAME&quot;, ch.getCacheName());
-			varParams.put(&quot;DIFFICULTY&quot;, (ch.hard &lt; 0)?&quot;!&lt;!&quot;:decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
+			varParams.put(&quot;DIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;!&lt;!&quot; : decSep.replaceAll(CacheTerrDiff.longDT(ch.hard)));
 			String sHard = Integer.toString(ch.hard);
-			varParams.put(&quot;SHORTDIFFICULTY&quot;, (ch.hard &lt; 0)?&quot;&quot;:sHard);
-			varParams.put(&quot;SHDIFFICULTY&quot;, (ch.hard &lt; 0)?&quot;&quot;:sHard.substring(0,1));
-			varParams.put(&quot;TERRAIN&quot;, (ch.terrain &lt; 0)?&quot;&quot;:decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
+			varParams.put(&quot;SHORTDIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;&quot; : sHard);
+			varParams.put(&quot;SHDIFFICULTY&quot;, (ch.hard &lt; 0) ? &quot;&quot; : sHard.substring(0, 1));
+			varParams.put(&quot;TERRAIN&quot;, (ch.terrain &lt; 0) ? &quot;&quot; : decSep.replaceAll(CacheTerrDiff.longDT(ch.terrain)));
 			String sTerrain = Integer.toString(ch.terrain);
-			varParams.put(&quot;SHORTTERRAIN&quot;, (ch.terrain &lt; 0)?&quot;&quot;:sTerrain);
-			varParams.put(&quot;SHTERRAIN&quot;, (ch.terrain &lt; 0)?&quot;&quot;:sTerrain.substring(0,1));
+			varParams.put(&quot;SHORTTERRAIN&quot;, (ch.terrain &lt; 0) ? &quot;&quot; : sTerrain);
+			varParams.put(&quot;SHTERRAIN&quot;, (ch.terrain &lt; 0) ? &quot;&quot; : sTerrain.substring(0, 1));
 			varParams.put(&quot;SIZE&quot;, CacheSize.cw2ExportString(ch.cacheSize));
 			varParams.put(&quot;SHORTSIZE&quot;, CacheSize.getExportShortId(ch.cacheSize));
 			varParams.put(&quot;OWNER&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(ch.cacheOwner) : ch.cacheOwner);
 			varParams.put(&quot;DATE&quot;, ch.dateHidden);
-		}
-		else {
+		} else {
 			varParams.put(&quot;MAINWP&quot;, &quot;&quot;);
 			varParams.put(&quot;MAINWPNAME&quot;, &quot;&quot;);
-			varParams.put(&quot;DIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0)?&quot;&quot;:decSep.replaceAll(CacheTerrDiff.longDT(hard)));
+			varParams.put(&quot;DIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0) ? &quot;&quot; : decSep.replaceAll(CacheTerrDiff.longDT(hard)));
 			String sHard = Integer.toString(hard);
-			varParams.put(&quot;SHORTDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0)?&quot;&quot;:sHard);
-			varParams.put(&quot;SHDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0)?&quot;&quot;:sHard.substring(0,1));
-			varParams.put(&quot;TERRAIN&quot;, (isCustomWpt() || terrain &lt; 0)?&quot;&quot;:decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
+			varParams.put(&quot;SHORTDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0) ? &quot;&quot; : sHard);
+			varParams.put(&quot;SHDIFFICULTY&quot;, (isCustomWpt() || hard &lt; 0) ? &quot;&quot; : sHard.substring(0, 1));
+			varParams.put(&quot;TERRAIN&quot;, (isCustomWpt() || terrain &lt; 0) ? &quot;&quot; : decSep.replaceAll(CacheTerrDiff.longDT(terrain)));
 			String sTerrain = Integer.toString(terrain);
-			varParams.put(&quot;SHORTTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0)?&quot;&quot;:sTerrain);
-			varParams.put(&quot;SHTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0)?&quot;&quot;:sTerrain.substring(0,1));
+			varParams.put(&quot;SHORTTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0) ? &quot;&quot; : sTerrain);
+			varParams.put(&quot;SHTERRAIN&quot;, (isCustomWpt() || terrain &lt; 0) ? &quot;&quot; : sTerrain.substring(0, 1));
 			varParams.put(&quot;SIZE&quot;, CacheSize.cw2ExportString(cacheSize));
 			varParams.put(&quot;SHORTSIZE&quot;, CacheSize.getExportShortId(cacheSize));
 			varParams.put(&quot;OWNER&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(cacheOwner) : cacheOwner);
@@ -650,48 +643,52 @@
 		}
 		if (isCustomWpt()) {
 
-		}		
-		varParams.put(&quot;WAYPOINT&quot;, wayPoint); //&lt;name&gt;
+		}
+		varParams.put(&quot;WAYPOINT&quot;, wayPoint); // &lt;name&gt;
 		int wpl = wayPoint.length();
 		int wps = (wpl &lt; shortWaypointLength) ? 0 : wpl - shortWaypointLength;
 		varParams.put(&quot;SHORTWAYPOINT&quot;, wayPoint.substring(wps, wpl));
 		varParams.put(&quot;DISTANCE&quot;, decSep.replaceAll(getDistance()));
 		varParams.put(&quot;BEARING&quot;, bearing);
-		if ((pos!=null &amp;&amp; pos.isValid())) {
-			varParams.put(&quot;LATLON&quot;, decSep.replaceAll(LatLon));
+		if ((pos != null &amp;&amp; pos.isValid())) {
+			varParams.put(&quot;LATLON&quot;, decSep.replaceAll(pos.toString()));
 			varParams.put(&quot;LAT&quot;, decSep.replaceAll(pos.getLatDeg(CWPoint.DD)));
-			varParams.put(&quot;LON&quot;, decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));		
-		}
-		else {
+			varParams.put(&quot;LON&quot;, decSep.replaceAll(pos.getLonDeg(CWPoint.DD)));
+		} else {
 			varParams.put(&quot;LATLON&quot;, &quot;unknown&quot;);
 			varParams.put(&quot;LAT&quot;, &quot;&quot;);
-			varParams.put(&quot;LON&quot;, &quot;&quot;);		
+			varParams.put(&quot;LON&quot;, &quot;&quot;);
 		}
 		if (withFoundText) {
-			varParams.put(&quot;STATUS&quot;,getStatusText());
-		}
-		else
+			varParams.put(&quot;STATUS&quot;, getStatusText());
+		} else
 			varParams.put(&quot;STATUS&quot;, cacheStatus);
 		varParams.put(&quot;GC_LOGTYPE&quot;, getGCLogType());
 		varParams.put(&quot;STATUS_DATE&quot;, getStatusDate());
 		varParams.put(&quot;STATUS_TIME&quot;, getStatusTime());
 		varParams.put(&quot;CACHE_NAME&quot;, cacheName);
-		if (codec instanceof AsciiCodec) { cacheName=Exporter.simplifyString(cacheName);} // use for &quot;NAME&quot;
-		if (badChars != null) { cacheName=badChars.replaceAll(cacheName); } // use for &quot;NAME&quot;
-		varParams.put(&quot;NAME&quot;, cacheName); // !!! cacheName used twice
-		String shortName=shortenName(cacheName, shortNameLength);
+		String cn = cacheName;
+		if (codec instanceof AsciiCodec) {
+			cn = Exporter.simplifyString(cacheName);
+		} // use for &quot;NAME&quot;
+		if (badChars != null) {
+			cn = badChars.replaceAll(cacheName);
+		} // use for &quot;NAME&quot;
+		varParams.put(&quot;NAME&quot;, cn);
+		String shortName = shortenName(cn, shortNameLength);
 		varParams.put(&quot;SHORTNAME&quot;, shortName);
-		varParams.put(&quot;TRAVELBUG&quot;, (bugs?&quot;Y&quot;:&quot;N&quot;));
-		if (gm!=null) varParams.put(&quot;GMTYPE&quot;, gm.getIcon(this));
-		varParams.put(&quot;NOW_DATE&quot;,nowdate().setToCurrentTime().toString());
-		varParams.put(&quot;NOW_TIME&quot;,nowtime().setToCurrentTime().toString());
+		varParams.put(&quot;TRAVELBUG&quot;, (bugs ? &quot;Y&quot; : &quot;N&quot;));
+		if (gm != null)
+			varParams.put(&quot;GMTYPE&quot;, gm.getIcon(this));
+		varParams.put(&quot;NOW_DATE&quot;, nowdate().setToCurrentTime().toString());
+		varParams.put(&quot;NOW_TIME&quot;, nowtime().setToCurrentTime().toString());
 		varParams.put(&quot;CACHEID&quot;, GetCacheID());
 		varParams.put(&quot;AVAILABLE&quot;, available ? &quot;TRUE&quot; : &quot;FALSE&quot;);
 		varParams.put(&quot;ARCHIVED&quot;, archived ? &quot;TRUE&quot; : &quot;FALSE&quot;);
 		varParams.put(&quot;HTML&quot;, html ? &quot;TRUE&quot; : &quot;FALSE&quot;);
 		varParams.put(&quot;VOTE&quot;, getRecommended());
-		//() ? TRUE : FALSE
-		if (det == null){
+		// () ? TRUE : FALSE
+		if (det == null) {
 			varParams.put(&quot;URL&quot;, &quot;&quot;);
 			varParams.put(&quot;DESCRIPTION&quot;, &quot;&quot;);
 			varParams.put(&quot;NOTES&quot;, &quot;&quot;);
@@ -699,145 +696,157 @@
 			varParams.put(&quot;DECRYPTEDHINTS&quot;, &quot;&quot;);
 			varParams.put(&quot;COUNTRY&quot;, &quot;&quot;);
 			varParams.put(&quot;STATE&quot;, &quot;&quot;);
-		}
-		else {
+		} else {
 			varParams.put(&quot;URL&quot;, det.URL);
 			if (html) {
 				if (ModTyp == 0) {
-					varParams.put(&quot;DESCRIPTION&quot;,SafeXML.cleanGPX(det.LongDescription));
-				}
-				else {
+					varParams.put(&quot;DESCRIPTION&quot;, SafeXML.cleanGPX(det.LongDescription));
+				} else {
 					varParams.put(&quot;DESCRIPTION&quot;, modifyLongDesc(det, ModTyp));
 				}
 			} else {
-				 // what was the reason? replace or no replace? I dont remember
-				varParams.put(&quot;DESCRIPTION&quot;,STRreplace.replace(det.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
+				// what was the reason? replace or no replace? I dont remember
+				varParams.put(&quot;DESCRIPTION&quot;, STRreplace.replace(det.LongDescription, &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
 			}
-			
+
 			if (badChars != null) {
-				if (ModTyp == 0){
-					varParams.put(&quot;NOTES&quot;,badChars.replaceAll(det.getCacheNotes()));
+				if (ModTyp == 0) {
+					varParams.put(&quot;NOTES&quot;, badChars.replaceAll(det.getCacheNotes()));
+				} else {
+					varParams.put(&quot;NOTES&quot;, STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
 				}
-				else {
-					varParams.put(&quot;NOTES&quot;,STRreplace.replace(badChars.replaceAll(det.getCacheNotes()), &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
-				}
-				varParams.put(&quot;HINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
-				varParams.put(&quot;DECRYPTEDHINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
+				varParams.put(&quot;HINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(det.Hints)) : badChars.replaceAll(det.Hints));
+				varParams.put(&quot;DECRYPTEDHINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(badChars.replaceAll(Common.rot13(det.Hints))) : badChars.replaceAll(Common.rot13(det.Hints)));
 			} else {
-				if (ModTyp == 0){
+				if (ModTyp == 0) {
 					varParams.put(&quot;NOTES&quot;, SafeXML.cleanGPX(det.getCacheNotes()));
-				}
-				else {
+				} else {
 					varParams.put(&quot;NOTES&quot;, STRreplace.replace(det.getCacheNotes(), &quot;\n&quot;, &quot;&lt;br&gt;&quot;));
 				}
-				varParams.put(&quot;HINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
-				varParams.put(&quot;DECRYPTEDHINTS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
+				varParams.put(&quot;HINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(det.Hints) : det.Hints);
+				varParams.put(&quot;DECRYPTEDHINTS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(Common.rot13(det.Hints)) : Common.rot13(det.Hints));
 			}
-			if (det.Travelbugs.size()&gt;0) varParams.put(&quot;BUGS&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
-			if (det.getSolver()!=null &amp;&amp; det.getSolver().trim().length()&gt;0) 
-				varParams.put(&quot;SOLVER&quot;, STRreplace.replace(det.getSolver(),&quot;\n&quot;,&quot;&lt;br/&gt;\n&quot;));
+			if (det.Travelbugs.size() &gt; 0)
+				varParams.put(&quot;BUGS&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(det.Travelbugs.toHtml()) : det.Travelbugs.toHtml());
+			if (det.getSolver() != null &amp;&amp; det.getSolver().trim().length() &gt; 0)
+				varParams.put(&quot;SOLVER&quot;, STRreplace.replace(det.getSolver(), &quot;\n&quot;, &quot;&lt;br/&gt;\n&quot;));
 			varParams.put(&quot;COUNTRY&quot;, det.Country);
 			varParams.put(&quot;STATE&quot;, det.State);
-			
+
 			// attributes
-			Vector attVect=new Vector(det.attributes.count()+1);
-			for (int i=0; i&lt;det.attributes.count(); i++) {
-				Hashtable atts=new Hashtable();
+			Vector attVect = new Vector(det.attributes.count() + 1);
+			for (int i = 0; i &lt; det.attributes.count(); i++) {
+				Hashtable atts = new Hashtable();
 				atts.put(&quot;PATHANDIMAGE&quot;, det.attributes.getAttribute(i).getPathAndImageName());
 				atts.put(&quot;IMAGE&quot;, det.attributes.getAttribute(i).getImageName());
 				atts.put(&quot;GCID&quot;, det.attributes.getAttribute(i).getGCId());
 				atts.put(&quot;INC&quot;, &quot;&quot; + det.attributes.getAttribute(i).getInc());
-				atts.put(&quot;INC2TXT&quot;, det.attributes.getAttribute(i).getInc()==1 ? &quot;YES:&quot; : &quot;NO:&quot;);
-				if (i % 5 ==4)
-					atts.put(&quot;BR&quot;,&quot;&lt;br/&gt;&quot;);
+				atts.put(&quot;INC2TXT&quot;, det.attributes.getAttribute(i).getInc() == 1 ? &quot;YES:&quot; : &quot;NO:&quot;);
+				if (i % 5 == 4)
+					atts.put(&quot;BR&quot;, &quot;&lt;br/&gt;&quot;);
 				else
-					atts.put(&quot;BR&quot;,&quot;&quot;);
-				atts.put(&quot;INFO&quot;,det.attributes.getAttribute(i).getMsg());
-				atts.put(&quot;GCINFO&quot;,det.attributes.getAttribute(i).getGCText());
+					atts.put(&quot;BR&quot;, &quot;&quot;);
+				atts.put(&quot;INFO&quot;, det.attributes.getAttribute(i).getMsg());
+				atts.put(&quot;GCINFO&quot;, det.attributes.getAttribute(i).getGCText());
 				attVect.add(atts);
 			}
-			varParams.put(&quot;ATTRIBUTES&quot;,attVect);
-			
+			varParams.put(&quot;ATTRIBUTES&quot;, attVect);
+
 			// logs
-			Vector logVect=new Vector(det.CacheLogs.size());
+			Vector logVect = new Vector(det.CacheLogs.size());
 			int maxlogs = det.CacheLogs.size();
-			if (nrOfLogs &gt; -1 &amp;&amp; nrOfLogs &lt; maxlogs ) maxlogs=nrOfLogs;
-			for (int i=0; i&lt;maxlogs; i++) {
-				Hashtable logs=new Hashtable();
+			if (nrOfLogs &gt; -1 &amp;&amp; nrOfLogs &lt; maxlogs)
+				maxlogs = nrOfLogs;
+			for (int i = 0; i &lt; maxlogs; i++) {
+				Hashtable logs = new Hashtable();
 				String stmp;
 				if (det.CacheLogs.getLog(i).getIcon().equals(&quot;MAXLOG&quot;)) {
 					logs.put(&quot;WAYPOINT&quot;, wayPoint);
-					logs.put(&quot;ICON&quot;,&quot;&quot;);
-					logs.put(&quot;LOGTYPE&quot;,&quot;&quot;);
+					logs.put(&quot;ICON&quot;, &quot;&quot;);
+					logs.put(&quot;LOGTYPE&quot;, &quot;&quot;);
 					logs.put(&quot;DATE&quot;, &quot;&quot;);
 					logs.put(&quot;LOGGER&quot;, &quot;&quot;);
-					stmp = &quot;&lt;hr&gt;&quot;+MyLocale.getMsg(736,&quot;Too many logs&quot;)+&quot;&lt;hr&gt;&quot;;
-				}
-				else {
+					stmp = &quot;&lt;hr&gt;&quot; + MyLocale.getMsg(736, &quot;Too many logs&quot;) + &quot;&lt;hr&gt;&quot;;
+				} else {
 					logs.put(&quot;WAYPOINT&quot;, wayPoint);
-					logs.put(&quot;ICON&quot;,det.CacheLogs.getLog(i).getIcon());
-					logs.put(&quot;LOGTYPE&quot;,image2TypeText(det.CacheLogs.getLog(i).getIcon()));
+					logs.put(&quot;ICON&quot;, det.CacheLogs.getLog(i).getIcon());
+					logs.put(&quot;LOGTYPE&quot;, image2TypeText(det.CacheLogs.getLog(i).getIcon()));
 					logs.put(&quot;DATE&quot;, det.CacheLogs.getLog(i).getDate());
 					logs.put(&quot;LOGGER&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(det.CacheLogs.getLog(i).getLogger()) : det.CacheLogs.getLog(i).getLogger());
-					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(),&quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;,null);
+					stmp = STRreplace.replace(det.CacheLogs.getLog(i).getMessage().trim(), &quot;<A HREF="http://www.geocaching.com/images/icons/">http://www.geocaching.com/images/icons/</A>&quot;, null);
 				}
 				logs.put(&quot;MESSAGE&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(stmp) : stmp);
 				logVect.add(logs);
 			}
-			varParams.put(&quot;LOGS&quot;,logVect);
+			varParams.put(&quot;LOGS&quot;, logVect);
 
-			Vector addiVect=new Vector(addiWpts.size());
-			for (int i=0; i&lt;addiWpts.size(); i++) {
-				Hashtable addis=new Hashtable();
-				CacheHolder ch=(CacheHolder) addiWpts.get(i);
-				addis.put(&quot;WAYPOINT&quot;,ch.getWayPoint());
-				addis.put(&quot;NAME&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
-				if ((ch.pos!=null &amp;&amp; ch.pos.isValid())) {
-					addis.put(&quot;LATLON&quot;,decSep.replaceAll(ch.pos.toString()));
-					addis.put(&quot;LAT&quot;,decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
-					addis.put(&quot;LON&quot;,decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
-				}
-				else {
+			Vector addiVect = new Vector(addiWpts.size());
+			for (int i = 0; i &lt; addiWpts.size(); i++) {
+				Hashtable addis = new Hashtable();
+				CacheHolder ch = (CacheHolder) addiWpts.get(i);
+				addis.put(&quot;WAYPOINT&quot;, ch.getWayPoint());
+				addis.put(&quot;NAME&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheName()) : ch.getCacheName());
+				if ((ch.pos != null &amp;&amp; ch.pos.isValid())) {
+					addis.put(&quot;LATLON&quot;, decSep.replaceAll(ch.pos.toString()));
+					addis.put(&quot;LAT&quot;, decSep.replaceAll(ch.pos.getLatDeg(CWPoint.DD)));
+					addis.put(&quot;LON&quot;, decSep.replaceAll(ch.pos.getLonDeg(CWPoint.DD)));
+				} else {
 					addis.put(&quot;LATLON&quot;, &quot;unknown&quot;);
 					addis.put(&quot;LAT&quot;, &quot;&quot;);
-					addis.put(&quot;LON&quot;, &quot;&quot;);		
+					addis.put(&quot;LON&quot;, &quot;&quot;);
 				}
-				addis.put(&quot;IMG&quot;,CacheType.typeImageForId(ch.getType()));
-				addis.put(&quot;ICON&quot;,&quot;&quot;+ch.getType());
+				addis.put(&quot;IMG&quot;, CacheType.typeImageForId(ch.getType()));
+				addis.put(&quot;ICON&quot;, &quot;&quot; + ch.getType());
 				addis.put(&quot;TYPENAME&quot;, CacheType.type2Gui(ch.getType()));
-				addis.put(&quot;TYPE&quot;, CacheType.type2TypeTag(ch.getType())); //&lt;type&gt;
-				addis.put(&quot;SYM&quot;, CacheType.type2SymTag(ch.getType())); //&lt;sym&gt;
-				addis.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(ch.getType())); //&lt;groundspeak:type&gt;
-				addis.put(&quot;LONGDESC&quot;,(ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
+				addis.put(&quot;TYPE&quot;, CacheType.type2TypeTag(ch.getType())); // &lt;type&gt;
+				addis.put(&quot;SYM&quot;, CacheType.type2SymTag(ch.getType())); // &lt;sym&gt;
+				addis.put(&quot;GSTYPE&quot;, CacheType.type2GSTypeTag(ch.getType())); // &lt;groundspeak:type&gt;
+				addis.put(&quot;LONGDESC&quot;, (ModTyp == 0) ? SafeXML.cleanGPX(ch.getCacheDetails(false).LongDescription) : ch.getCacheDetails(false).LongDescription);
 				addiVect.add(addis);
 			}
-			varParams.put(&quot;ADDIS&quot;,addiVect);
-			
-			Vector imgVect=new Vector(det.images.size());
-			for (int i=0; i&lt;det.images.size(); i++) {
-				Hashtable imgs=new Hashtable();
+			varParams.put(&quot;ADDIS&quot;, addiVect);
+
+			Vector imgVect = new Vector(det.images.size());
+			for (int i = 0; i &lt; det.images.size(); i++) {
+				Hashtable imgs = new Hashtable();
 				String imgFile = det.images.get(i).getFilename();
-				imgs.put(&quot;FILENAME&quot;,imgFile);
-				imgs.put(&quot;TEXT&quot;,det.images.get(i).getTitle());
-				imgs.put(&quot;COMMENT&quot;,det.images.get(i).getComment());
-				imgs.put(&quot;URL&quot;,det.images.get(i).getURL());
-				if (!expName.equals(&quot;&quot;)) {
-					String src = Global.getProfile().dataDir + imgFile;
-					String dest = Global.getPref().getExportPath(expName) + imgFile;
-					if (!DataMover.copy(src,dest)) {
-						Global.getPref().log(&quot;[CacheHolder:toHashtable]error copying &quot;+imgFile+&quot; to &quot;+Global.getPref().getExportPath(expName));
+				boolean doit = true;
+				for (int j = i + 1; j &lt; det.images.size(); j++) {
+					String jmgFile = det.images.get(j).getFilename();
+					if (imgFile.equals(jmgFile)) {
+						doit = false;
+						break;
 					}
 				}
-				imgVect.add(imgs);
+				if (doit) {
+					imgs.put(&quot;FILENAME&quot;, imgFile);
+					String title = det.images.get(i).getTitle();
+					imgs.put(&quot;TEXT&quot;, title);
+					String comment = det.images.get(i).getComment();
+					imgs.put(&quot;COMMENT&quot;, comment);
+					imgs.put(&quot;URL&quot;, det.images.get(i).getURL());
+					if (!expName.equals(&quot;&quot;)) {
+						String src = Global.getProfile().dataDir + imgFile;
+						String dest = Global.getPref().getExportPath(expName) + imgFile;
+						if (!DataMover.copy(src, dest)) {
+							Global.getPref().log(&quot;[CacheHolder:toHashtable]error copying &quot; + imgFile + &quot; to &quot; + Global.getPref().getExportPath(expName));
+						}
+					}
+					if (!title.toLowerCase().startsWith(wayPoint.toLowerCase())) {
+						imgVect.add(imgs);
+					}
+				}
 			}
-			varParams.put(&quot;cacheImg&quot;,imgVect);
+			varParams.put(&quot;cacheImg&quot;, imgVect);
 		}
 		return varParams;
-	}	
+	}
 
 	/**
 	 * generate a gc.com compatible string representation of log derived from the internally stored image
-	 * @param image name of the image to display
+	 * 
+	 * @param image
+	 *            name of the image to display
 	 * @return log type. will default to &quot;Write note&quot; for unknown logtypes
 	 */
 	public static final String image2TypeText(String image) {
@@ -877,36 +886,43 @@
 	}
 
 	/**
-	 * Modify the image links in the long description so that they point to image files in the local directory
-	 * Also copy the image file to the target directory so that it can be displayed.
-	 * @param chD CacheHolderDetail
+	 * Modify the image links in the long description so that they point to image files in the local directory Also copy the image file to the target directory so that it can be displayed.
+	 * 
+	 * @param chD
+	 *            CacheHolderDetail
 	 * @param int ModTypLongDesc == 1 get image from profile path, == 2 get image from html-path
 	 * @return The modified long description
 	 */
 	private String modifyLongDesc(CacheHolderDetail chD, int ModTypLongDesc) {
-		StringBuffer s=new StringBuffer(chD.LongDescription.length());
-		int start=0;
+		StringBuffer s = new StringBuffer(chD.LongDescription.length());
+		int start = 0;
 		int pos;
-		int imageNo=0;
-		String imgsrc=&quot;&quot;;
-		if (ModTypLongDesc==1) imgsrc=&quot;<A HREF="file://">file://</A>&quot;+Global.getProfile().dataDir;
-		while (start&gt;=0 &amp;&amp; (pos=chD.LongDescription.indexOf(&quot;&lt;img&quot;,start))&gt;0) {
-			if (imageNo &gt;= chD.images.size()) break;
-			s.append(chD.LongDescription.substring(start,pos));
-			start=chD.LongDescription.indexOf(&quot;&gt;&quot;,pos)+1;
-			String oldurl=chD.images.get(imageNo).getURL();
-			String imgString=chD.LongDescription.substring(pos, start);
-			if (imgString.indexOf(oldurl)==-1) {
+		int imageNo = 0;
+		String imgsrc = &quot;&quot;;
+		if (ModTypLongDesc == 1)
+			imgsrc = &quot;<A HREF="file://">file://</A>&quot; + Global.getProfile().dataDir;
+		while (start &gt;= 0 &amp;&amp; (pos = chD.LongDescription.indexOf(&quot;&lt;img&quot;, start)) &gt; 0) {
+			if (imageNo &gt;= chD.images.size())
+				break;
+			s.append(chD.LongDescription.substring(start, pos));
+			start = chD.LongDescription.indexOf(&quot;&gt;&quot;, pos) + 1;
+			String oldurl = chD.images.get(imageNo).getURL();
+			String imgString = chD.LongDescription.substring(pos, start);
+			imgString = STRreplace.replace(imgString, &quot;\n&quot;, &quot;&quot;);
+			imgString = STRreplace.replace(imgString, &quot;\r&quot;, &quot;&quot;);
+			imgString = STRreplace.replace(imgString, &quot;groundspeak&quot;, &quot;geocaching&quot;);
+			if (imgString.indexOf(oldurl) == -1) {
 				if (oldurl.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) {
-					int i = oldurl.indexOf(&quot;/&quot;, 7)+1;
-					oldurl=oldurl.substring(i);
+					int i = oldurl.indexOf(&quot;/&quot;, 7) + 1;
+					oldurl = oldurl.substring(i);
 				}
 			}
-			String newurl=imgsrc+chD.images.get(imageNo).getFilename();
-			s.append(STRreplace.replace(imgString,oldurl,newurl));
+			String newurl = imgsrc + chD.images.get(imageNo).getFilename();
+			s.append(STRreplace.replace(imgString, oldurl, newurl));
 			imageNo++;
 		}
-		if (start&gt;=0) s.append(chD.LongDescription.substring(start));
+		if (start &gt;= 0)
+			s.append(chD.LongDescription.substring(start));
 		return s.toString();
 	}
 
@@ -914,56 +930,61 @@
 		Time nd = new Time();
 		return nd.setFormat(&quot;yyyy-MM-dd&quot;);
 	}
+
 	private final static Time nowtime() {
 		Time nt = new Time();
 		return nt.setFormat(&quot;HH:mm&quot;);
 	}
 
-	private final static String selbstLaute=&quot;aeiouAEIOU&quot;;
+	private final static String selbstLaute = &quot;aeiouAEIOU&quot;;
+
 	private final static String mitLauteKlein() {
-		final StringBuffer lower=new StringBuffer(26);// region/language dependent ?
-		for (int i=97; i&lt;=122; i++ ) {
+		final StringBuffer lower = new StringBuffer(26);// region/language dependent ?
+		for (int i = 97; i &lt;= 122; i++) {
 			lower.append((char) i);
 		}
 		return lower.toString();
 	}
+
 	public String shortenName(String Name, int maxLength) {
-		String shortName=removeCharsfromString(Name, maxLength, selbstLaute);
-		return  removeCharsfromString(shortName, maxLength, mitLauteKlein());
+		String shortName = removeCharsfromString(Name, maxLength, selbstLaute);
+		return removeCharsfromString(shortName, maxLength, mitLauteKlein());
 	}
-    private static String removeCharsfromString( String text, int MaxLength, String chars ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        int anzToRemove=originalTextLength-MaxLength;
-        if (anzToRemove&lt;=0) return text;
-        int anzRemoved=0;
-        StringBuffer sb = new StringBuffer( 50 );
-        for ( int i = originalTextLength-1; i &gt;= 0; i-- ) {
-            char c = text.charAt( i );
-            if (chars.indexOf(c) == -1) {
-            	sb.insert(0,c);
-            }
-            else {
-            	anzRemoved++;
-            	if (anzRemoved==anzToRemove) {
-            		sb.insert(0, text.substring(0,i));
-            		i=0; // exit for
-            	}
-            }
-        }
-        return sb.toString();
-    }
 
+	private static String removeCharsfromString(String text, int MaxLength, String chars) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		int anzToRemove = originalTextLength - MaxLength;
+		if (anzToRemove &lt;= 0)
+			return text;
+		int anzRemoved = 0;
+		StringBuffer sb = new StringBuffer(50);
+		for (int i = originalTextLength - 1; i &gt;= 0; i--) {
+			char c = text.charAt(i);
+			if (chars.indexOf(c) == -1) {
+				sb.insert(0, c);
+			} else {
+				anzRemoved++;
+				if (anzRemoved == anzToRemove) {
+					sb.insert(0, text.substring(0, i));
+					i = 0; // exit for
+				}
+			}
+		}
+		return sb.toString();
+	}
+
 	/** return true if waypoint is an additional waypoint of a cache */
 	public boolean isAddiWpt() {
 		return CacheType.isAddiWpt(type);
 	}
-	
+
 	/** return true if waypoint is a custom waypoint */
 	public boolean isCustomWpt() {
 		return CacheType.isCustomWpt(type);
 	}
-	
+
 	/** return true if waypoint is a cache main waypoint */
 	public boolean isCacheWpt() {
 		return CacheType.isCacheWpt(type);
@@ -971,15 +992,15 @@
 
 	/** return true waypoint has one or more additional waypoints */
 	public boolean hasAddiWpt() {
-		return addiWpts.getCount()&gt;0;
+		return addiWpts.getCount() &gt; 0;
 	}
 
 	public boolean isOC() {
 		return OC.isOC(wayPoint);
 	}
 
-	public void calcDistance(CWPoint toPoint) {	
-		if(pos.isValid()){
+	public void calcDistance(CWPoint toPoint) {
+		if (pos.isValid()) {
 			kilom = pos.getDistance(toPoint);
 			degrees = toPoint.getBearing(pos);
 			bearing = CWPoint.getDirection(degrees);
@@ -989,7 +1010,7 @@
 		}
 	}
 
-	public void setAttributesFromMainCache(){
+	public void setAttributesFromMainCache() {
 		CacheHolder mainCh = this.mainCache;
 		this.setCacheOwner(mainCh.getCacheOwner());
 		if (mainCh.is_found()) {
@@ -997,9 +1018,8 @@
 				this.setCacheStatus(mainCh.getCacheStatus());
 				this.setFound(true);
 			}
-			// else addi is already found (perhaps at other time) 
-		}
-		else {
+			// else addi is already found (perhaps at other time)
+		} else {
 			// there may be a found addi , so don't overwrite
 			if ((this.getType() == CacheType.CW_TYPE_FINAL)) {
 				this.setCacheStatus(mainCh.getCacheStatus());
@@ -1013,10 +1033,10 @@
 		this.setNew(mainCh.is_new());
 	}
 
-	public void setAttributesToAddiWpts(){
-		if (this.hasAddiWpt()){
+	public void setAttributesToAddiWpts() {
+		if (this.hasAddiWpt()) {
 			CacheHolder addiWpt;
-			for (int i= this.addiWpts.getCount() - 1;  i&gt;=0; i--){
+			for (int i = this.addiWpts.getCount() - 1; i &gt;= 0; i--) {
 				addiWpt = (CacheHolder) this.addiWpts.get(i);
 				addiWpt.setAttributesFromMainCache();
 			}
@@ -1024,39 +1044,46 @@
 	}
 
 	/**
-	 * True if ch and this belong to the same main cache. 
+	 * True if ch and this belong to the same main cache.
+	 * 
 	 * @param ch
 	 * @return
 	 */
 	public boolean hasSameMainCache(CacheHolder ch) {
-		if (this == ch) return true;
-		if (ch == null) return false;
-		if ((!this.isAddiWpt()) &amp;&amp; (!ch.isAddiWpt())) return false;
+		if (this == ch)
+			return true;
+		if (ch == null)
+			return false;
+		if ((!this.isAddiWpt()) &amp;&amp; (!ch.isAddiWpt()))
+			return false;
 		CacheHolder main1, main2;
-		if (this.isAddiWpt()) main1 = this.mainCache;  else main1 = this;
-		if (ch.isAddiWpt()) main2 = ch.mainCache; else main2 = ch; 
+		if (this.isAddiWpt())
+			main1 = this.mainCache;
+		else
+			main1 = this;
+		if (ch.isAddiWpt())
+			main2 = ch.mainCache;
+		else
+			main2 = ch;
 		return main1 == main2;
 	}
 
-	/** Find out of detail object of Cache is loaded. Returns &lt;code&gt;true&lt;/code&gt; if this is the case.
+	/**
+	 * Find out of detail object of Cache is loaded. Returns &lt;code&gt;true&lt;/code&gt; if this is the case.
+	 * 
 	 * @return True when details object is present
 	 */
 	public boolean detailsLoaded() {
-		return details!=null;
+		return details != null;
 	}
 
 	/**
-	 * Gets the detail object of a cache. The detail object stores information which is not needed
-	 * for every cache instantaneously, but can be loaded if the user decides to look at this cache.
-	 * If the cache object is already existing, the method will return this object, otherwise it 
-	 * will create it and try to read it from the corresponding &lt;waypoint&gt;.xml file.
-	 * Depending on the parameters it is allowed that the &lt;waypoint&gt;.xml file does not yet exist,
-	 * or the user is warned that the file doesn't exist.
-	 * If more than &lt;code&gt;maxdetails&lt;/code&gt; details are loaded, then the 5 last recently loaded 
-	 * caches are unloaded (to save ram). 
+	 * Gets the detail object of a cache. The detail object stores information which is not needed for every cache instantaneously, but can be loaded if the user decides to look at this cache. If the cache object is already existing, the method will
+	 * return this object, otherwise it will create it and try to read it from the corresponding &lt;waypoint&gt;.xml file. Depending on the parameters it is allowed that the &lt;waypoint&gt;.xml file does not yet exist, or the user is warned that the file doesn't
+	 * exist. If more than &lt;code&gt;maxdetails&lt;/code&gt; details are loaded, then the 5 last recently loaded caches are unloaded (to save ram).
+	 * 
 	 * @param alarmuser
-	 *            If true an error message will be displayed to the user, if the details could not
-	 *            be read, and the method returns null 
+	 *            If true an error message will be displayed to the user, if the details could not be read, and the method returns null
 	 * @return The respective CacheHolderDetail, or null
 	 */
 	public CacheHolderDetail getCacheDetails(boolean alarmuser) {
@@ -1066,9 +1093,8 @@
 				details.readCache(Global.getProfile().dataDir);
 			} catch (IOException e) {
 				if (alarmuser) {
-					//FIXME: put a message to languages file
-					(new MessageBox(MyLocale.getMsg(31415,&quot;Error&quot;), MyLocale.getMsg(31415, &quot;Could not read cache details for cache: &quot;)
-					        + this.getWayPoint(), FormBase.OKB)).execute();
+					// FIXME: put a message to languages file
+					(new MessageBox(MyLocale.getMsg(31415, &quot;Error&quot;), MyLocale.getMsg(31415, &quot;Could not read cache details for cache: &quot;) + this.getWayPoint(), FormBase.OKB)).execute();
 					// details = null;
 				}
 				this.setIncomplete(true);
@@ -1076,111 +1102,115 @@
 			// for importing/spidering reasons helper objects with same waypoint are created
 			if (details != null &amp;&amp; !cachesWithLoadedDetails.contains(this)) {
 				cachesWithLoadedDetails.add(this);
-				if (cachesWithLoadedDetails.size() &gt;= Global.getPref().maxDetails) removeOldestDetails();
+				if (cachesWithLoadedDetails.size() &gt;= Global.getPref().maxDetails)
+					removeOldestDetails();
 			}
 		}
 		return details;
 	}
 
 	/**
-	 * Saves the cache to the corresponding &lt;waypoint&gt;.xml file, located in the profiles
-	 * directory. The waypoint of the 
-	 * cache should be set to do so.
+	 * Saves the cache to the corresponding &lt;waypoint&gt;.xml file, located in the profiles directory. The waypoint of the cache should be set to do so.
 	 */
 	public void save() {
 		checkIncomplete();
 		this.getCacheDetails(false).saveCacheDetails(Global.getProfile().dataDir);
 	}
-	
+
 	void releaseCacheDetails() {
-		if (details != null &amp;&amp; details.hasUnsavedChanges){
+		if (details != null &amp;&amp; details.hasUnsavedChanges) {
 			details.saveCacheDetails(Global.getProfile().dataDir);
 		}
 		details = null;
 		cachesWithLoadedDetails.remove(this);
 	}
 
-	//final static int maxDetails = 50; 
+	// final static int maxDetails = 50;
 	static Vector cachesWithLoadedDetails = new Vector(Global.getPref().maxDetails);
 
 	public static void removeOldestDetails() {
 		CacheHolder ch;
-		for (int i=0; i&lt;Global.getPref().deleteDetails; i++) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-	//		CacheHolder ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = 0; i &lt; Global.getPref().deleteDetails; i++) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null) ch.releaseCacheDetails();
-		}	
+			if (ch != null)
+				ch.releaseCacheDetails();
+		}
 	}
 
 	public static void removeAllDetails() {
 		CacheHolder ch;
-		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--) {
+		for (int i = cachesWithLoadedDetails.size() - 1; i &gt;= 0; i--) {
 			// String wp = (String) cachesWithLoadedDetails.get(i);
 			// CacheHolder ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
-			if (ch!=null &amp;&amp; ch.detailsLoaded()) ch.releaseCacheDetails();
+			if (ch != null &amp;&amp; ch.detailsLoaded())
+				ch.releaseCacheDetails();
 		}
 	}
 
 	/**
-	 * when importing caches you can set details.saveChanges = true
-	 * when the import is finished call this method to save the pending changes
+	 * when importing caches you can set details.saveChanges = true when the import is finished call this method to save the pending changes
 	 */
 	public static void saveAllModifiedDetails() {
 		CacheHolder ch;
 		CacheHolderDetail chD;
-		for (int i=cachesWithLoadedDetails.size()-1; i&gt;=0; i--) {
-//			String wp = (String) cachesWithLoadedDetails.get(i);
-//			ch = Global.getProfile().cacheDB.get(wp);
+		for (int i = cachesWithLoadedDetails.size() - 1; i &gt;= 0; i--) {
+			// String wp = (String) cachesWithLoadedDetails.get(i);
+			// ch = Global.getProfile().cacheDB.get(wp);
 			ch = (CacheHolder) cachesWithLoadedDetails.get(i);
 			if (ch != null) {
-	            chD = ch.getCacheDetails(true);
-	            if (chD!=null &amp;&amp; chD.hasUnsavedChanges) {
-		            //ch.calcRecommendationScore();
-		            chD.saveCacheDetails(Global.getProfile().dataDir);
-	            }
-            }
+				chD = ch.getCacheDetails(true);
+				if (chD != null &amp;&amp; chD.hasUnsavedChanges) {
+					// ch.calcRecommendationScore();
+					chD.saveCacheDetails(Global.getProfile().dataDir);
+				}
+			}
 		}
 	}
-	
+
 	public String getFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		return MyLocale.getMsg(msgNr, &quot;Found&quot;);
 	}
+
 	public String getGCFoundText() {
-		int msgNr=318; // normal found			 
-		if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-		else if (type == CacheType.CW_TYPE_EVENT 
-				|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (type == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 		for (int i = 0; i &lt; _logType.length; i++) {
-			if ((&quot;&quot;+msgNr).equals(_logType[i][MSG_NR])) {
+			if ((&quot;&quot; + msgNr).equals(_logType[i][MSG_NR])) {
 				return _logType[i][GC_MSG];
-			}			
+			}
 		}
 		return &quot;&quot;;
 	}
+
 	public String getCWLogText(String s) {
 		for (int i = 0; i &lt; _logType.length; i++) {
 			if ((s).equals(_logType[i][GC_MSG])) {
-				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),&quot;&quot;);
-			}			
+				return MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), &quot;&quot;);
+			}
 		}
 		return &quot;&quot;;
 	}
-	
+
 	public String getStatusText() {
-		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) &amp;&amp;
-				cacheStatus.charAt(4) == '-') {
-			return getFoundText() + &quot; &quot; + cacheStatus;			
+		if ((cacheStatus.length() == 10 || cacheStatus.length() == 16) &amp;&amp; cacheStatus.charAt(4) == '-') {
+			return getFoundText() + &quot; &quot; + cacheStatus;
 		} else {
 			if (found) {
 				return getFoundText();
-			}
-			else {
+			} else {
 				return cacheStatus;
 			}
 		}
@@ -1188,137 +1218,119 @@
 
 	public String getStatusDate() {
 		String statusDate = &quot;&quot;;
-		
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,&quot;not found&quot;))&gt;10) {
-			Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, &quot;not found&quot;)) &gt; 10) {
+			Regex rexDate = new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
 			rexDate.search(getCacheStatus());
-			if (rexDate.stringMatched(1)!= null) {
+			if (rexDate.stringMatched(1) != null) {
 				statusDate = rexDate.stringMatched(1);
 			}
 		}
 
-		return statusDate;		
+		return statusDate;
 	}
-	
+
 	public String getStatusTime() {
 		String statusTime = &quot;&quot;;
 
-		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319,&quot;not found&quot;))&gt;10) {
-			Regex rexTime=new Regex(&quot;([0-9]{1,2}:[0-9]{2})&quot;);
+		if (is_found() || getCacheStatus().indexOf(MyLocale.getMsg(319, &quot;not found&quot;)) &gt; 10) {
+			Regex rexTime = new Regex(&quot;([0-9]{1,2}:[0-9]{2})&quot;);
 			rexTime.search(getCacheStatus());
-			if (rexTime.stringMatched(1)!= null) {
+			if (rexTime.stringMatched(1) != null) {
 				statusTime = rexTime.stringMatched(1);
-			}
-			else {
-				Regex rexDate=new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
+			} else {
+				Regex rexDate = new Regex(&quot;([0-9]{4}-[0-9]{2}-[0-9]{2})&quot;);
 				rexDate.search(getCacheStatus());
-				if (rexDate.stringMatched(1)!= null) {
+				if (rexDate.stringMatched(1) != null) {
 					statusTime = &quot;00:00&quot;;
 				}
 			}
 		}
 
-		return statusTime;		
+		return statusTime;
 	}
-		
+
 	public String GetCacheID() {
 		String result = &quot;&quot;;
-		String pattern = getWayPoint().toUpperCase();
+		String pattern = wayPoint.toUpperCase();
 
-		if ( pattern.startsWith( &quot;GC&quot; ) ) {
+		if (pattern.startsWith(&quot;GC&quot;)) {
 			int gcId = 0;
 
 			String sequence = &quot;0123456789ABCDEFGHJKMNPQRTVWXYZ&quot;;
-			
-			String rightPart = getWayPoint().substring( 2 ).toUpperCase();
-			
+
+			String rightPart = getWayPoint().substring(2).toUpperCase();
+
 			int base = 31;
 			if ((rightPart.length() &lt; 4) || (rightPart.length() == 4 &amp;&amp; sequence.indexOf(rightPart.charAt(0)) &lt; 16)) {
 				base = 16;
 			}
-			
-			for ( int p = 0; p &lt; rightPart.length(); p++ ) {
+
+			for (int p = 0; p &lt; rightPart.length(); p++) {
 				gcId *= base;
 				gcId += sequence.indexOf(rightPart.charAt(p));
 			}
-			
-	        if ( base == 31 ) {
-	        	gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
-	        }
-	        
-	        result = Integer.toString(gcId);	        
+
+			if (base == 31) {
+				gcId += java.lang.Math.pow(16, 4) - 16 * java.lang.Math.pow(31, 3);
+			}
+
+			result = Integer.toString(gcId);
 		} else if (isOC()) {
-        	result = getOcCacheID();
-        }
+			result = getOcCacheID();
+		}
 
 		return result;
 	}
 
-	private final static int MSG_NR = 0; 
-	private final static int GC_MSG = 1; 
-	private final static int IDX_WRITENOTE = 5; 	
-	private final static String[][] _logType = {	
-			{&quot;353&quot;, &quot;&quot;},
-			{&quot;318&quot;, &quot;Found it&quot;},
-			{&quot;355&quot;, &quot;Attended&quot;},
-			{&quot;361&quot;, &quot;Webcam Photo Taken&quot;},
-			{&quot;319&quot;, &quot;Didn't find it&quot;},
-			{&quot;314&quot;, &quot;Write note&quot;}, // at change do change IDX_WRITENOTE = 5;
-			{&quot;315&quot;, &quot;Needs Archived&quot;},
-			{&quot;316&quot;, &quot;Needs Maintenance&quot;},
-			{&quot;317&quot;, &quot;Search&quot;}, 
-			{&quot;354&quot;, &quot;Will Attend&quot;},
-			{&quot;320&quot;, &quot;Owner&quot;},
-			{&quot;359&quot;, &quot;Owner Maintenance&quot;},
-			{&quot;356&quot;, &quot;Temporarily Disable Listing&quot;},
-			{&quot;357&quot;, &quot;Enable Listing&quot;},
-			{&quot;358&quot;, &quot;Post Reviewer Note&quot;},
-			{&quot;362&quot;, &quot;Solved&quot;},
-			{&quot;313&quot;, &quot;Flag 1&quot;},
-			{&quot;360&quot;, &quot;Flag 2&quot;},
-	};
+	private final static int MSG_NR = 0;
+	private final static int GC_MSG = 1;
+	private final static int IDX_WRITENOTE = 5;
+	private final static String[][] _logType = { { &quot;353&quot;, &quot;&quot; }, { &quot;318&quot;, &quot;Found it&quot; }, { &quot;355&quot;, &quot;Attended&quot; }, { &quot;361&quot;, &quot;Webcam Photo Taken&quot; }, { &quot;319&quot;, &quot;Didn't find it&quot; },
+			{ &quot;314&quot;, &quot;Write note&quot; }, // at change do change IDX_WRITENOTE = 5;
+			{ &quot;315&quot;, &quot;Needs Archived&quot; }, { &quot;316&quot;, &quot;Needs Maintenance&quot; }, { &quot;317&quot;, &quot;Search&quot; }, { &quot;354&quot;, &quot;Will Attend&quot; }, { &quot;320&quot;, &quot;Owner&quot; }, { &quot;359&quot;, &quot;Owner Maintenance&quot; }, { &quot;356&quot;, &quot;Temporarily Disable Listing&quot; }, { &quot;357&quot;, &quot;Enable Listing&quot; },
+			{ &quot;358&quot;, &quot;Post Reviewer Note&quot; }, { &quot;362&quot;, &quot;Solved&quot; }, { &quot;313&quot;, &quot;Flag 1&quot; }, { &quot;360&quot;, &quot;Flag 2&quot; }, };
 
 	public final static String[] GetGuiLogTypes() {
 		String[] ret = new String[_logType.length];
 		for (int i = 0; i &lt; _logType.length; i++) {
-			ret[i]=MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),&quot;&quot;);
+			ret[i] = MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), &quot;&quot;);
 		}
 		return ret;
 	}
-	
-	public String getGCLogType() {                                                                                
-		String gcLogType=_logType[IDX_WRITENOTE][GC_MSG];
+
+	public String getGCLogType() {
+		String gcLogType = _logType[IDX_WRITENOTE][GC_MSG];
 		if (is_found()) {
-			String msgNr=&quot;318&quot;; // normal found			
-			if (type == CacheType.CW_TYPE_WEBCAM) { msgNr=&quot;361&quot;;}
-			else if (type == CacheType.CW_TYPE_EVENT 
-					|| type == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=&quot;355&quot;;}
+			String msgNr = &quot;318&quot;; // normal found
+			if (type == CacheType.CW_TYPE_WEBCAM) {
+				msgNr = &quot;361&quot;;
+			} else if (type == CacheType.CW_TYPE_EVENT || type == CacheType.CW_TYPE_MEGA_EVENT) {
+				msgNr = &quot;355&quot;;
+			}
 			for (int i = 1; i &lt; _logType.length; i++) {
 				if (_logType[i][MSG_NR].equals(msgNr)) {
-					gcLogType = _logType[i][GC_MSG]; 
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
-		}
-		else {
-			String CacheStatus=getCacheStatus();  
+		} else {
+			String CacheStatus = getCacheStatus();
 			for (int i = 1; i &lt; _logType.length; i++) {
-				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]),&quot;&quot;))) {
-					gcLogType=_logType[i][GC_MSG];
+				if (CacheStatus.endsWith(MyLocale.getMsg(Common.parseInt(_logType[i][MSG_NR]), &quot;&quot;))) {
+					gcLogType = _logType[i][GC_MSG];
 					break;
 				}
 			}
 		}
-		return gcLogType;    
-	}                                                                                                             
-	
-	
-	
+		return gcLogType;
+	}
+
 	/**
-	 * Initializes the caches states (and its addis) before updating, so that the &quot;new&quot;, &quot;updated&quot;,
-	 * &quot;log_updated&quot; and &quot;incomplete&quot; properties are properly set. 
-	 * @param pNewCache &lt;code&gt;true&lt;/code&gt; if it is a new cache (i.e. a cache not existing in CacheDB),
-	 * &lt;code&gt;false&lt;/code&gt; otherwise.
+	 * Initializes the caches states (and its addis) before updating, so that the &quot;new&quot;, &quot;updated&quot;, &quot;log_updated&quot; and &quot;incomplete&quot; properties are properly set.
+	 * 
+	 * @param pNewCache
+	 *            &lt;code&gt;true&lt;/code&gt; if it is a new cache (i.e. a cache not existing in CacheDB), &lt;code&gt;false&lt;/code&gt; otherwise.
 	 */
 	public void initStates(boolean pNewCache) {
 		this.setNew(pNewCache);
@@ -1326,59 +1338,43 @@
 		this.setLog_updated(false);
 		this.setIncomplete(false);
 		if (!pNewCache &amp;&amp; this.hasAddiWpt()) {
-			for (int i=0; i&lt;this.addiWpts.size(); i++) {
-				((CacheHolder)this.addiWpts.get(i)).initStates(pNewCache);
+			for (int i = 0; i &lt; this.addiWpts.size(); i++) {
+				((CacheHolder) this.addiWpts.get(i)).initStates(pNewCache);
 			}
 		}
 	}
 
 	/**
-	 * Creates a bit field of boolean values of the cache, represented as a long value.
-	 * Boolean value of &lt;code&gt;true&lt;/code&gt; results in &lt;code&gt;1&lt;/code&gt; in the long values bits,
-	 * and, vice versa, 0 for false.
+	 * Creates a bit field of boolean values of the cache, represented as a long value. Boolean value of &lt;code&gt;true&lt;/code&gt; results in &lt;code&gt;1&lt;/code&gt; in the long values bits, and, vice versa, 0 for false.
+	 * 
 	 * @return long value representing the boolean bit field
 	 */
 	private long boolFields2long() {
 		// To get the same list of visible caches after loading a profile,
-		// the property isVisible() is saved instead of is_filtered(), but at 
+		// the property isVisible() is saved instead of is_filtered(), but at
 		// the place where is_filtered() is read.
-		long value = bool2BitMask(!this.isVisible(), 1)     | 
-		             bool2BitMask(this.is_available(), 2)   |
-		             bool2BitMask(this.is_archived(), 3)    |
-		             bool2BitMask(this.has_bugs(), 4)       |
-		             bool2BitMask(this.is_black(), 5)       |
-		             bool2BitMask(this.is_owned(), 6)       |
-		             bool2BitMask(this.is_found(), 7)       |
-		             bool2BitMask(this.is_new(), 8)         |
-		             bool2BitMask(this.is_log_updated(), 9) |
-		             bool2BitMask(this.is_updated(), 10)    |
-		             bool2BitMask(this.is_HTML(), 11)       |
-		             bool2BitMask(this.is_incomplete(), 12) |
-		             bool2BitMask(this.hasNote(), 13)       |
-		             bool2BitMask(this.hasSolver(), 14);		             
+		long value = bool2BitMask(!this.isVisible(), 1) | bool2BitMask(this.is_available(), 2) | bool2BitMask(this.is_archived(), 3) | bool2BitMask(this.has_bugs(), 4) | bool2BitMask(this.is_black(), 5) | bool2BitMask(this.is_owned(), 6)
+				| bool2BitMask(this.is_found(), 7) | bool2BitMask(this.is_new(), 8) | bool2BitMask(this.is_log_updated(), 9) | bool2BitMask(this.is_updated(), 10) | bool2BitMask(this.is_HTML(), 11) | bool2BitMask(this.is_incomplete(), 12)
+				| bool2BitMask(this.hasNote(), 13) | bool2BitMask(this.hasSolver(), 14);
 		return value;
 	}
 
 	/**
-	 * Creates a field of byte values of certain properties of the cache, represented
-	 * as a long value.
-	 * As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8
-	 * bits. The position indicates the group of bits where the byte is packed,
+	 * Creates a field of byte values of certain properties of the cache, represented as a long value. As a long is 8 bytes wide, one might pack 8 bytes into a long, one every 8 bits. The position indicates the group of bits where the byte is packed,
 	 * counting starting from one by the right side of the long.
+	 * 
 	 * @return long value representing the byte field
 	 */
 	private long byteFields2long() {
-		long value = byteBitMask(hard, 1)    | 
-		byteBitMask(terrain, 2)   |
-		byteBitMask(type, 3)    |
-		byteBitMask(cacheSize, 4)|
-		byteBitMask(this.noFindLogs, 5);		             
+		long value = byteBitMask(hard, 1) | byteBitMask(terrain, 2) | byteBitMask(type, 3) | byteBitMask(cacheSize, 4) | byteBitMask(this.noFindLogs, 5);
 		return value;
 	}
-	
+
 	/**
 	 * Evaluates byte values from a long value for certain properties of the cache.
-	 * @param value The long value which contains up to 8 bytes.
+	 * 
+	 * @param value
+	 *            The long value which contains up to 8 bytes.
 	 */
 	private void long2byteFields(long value) {
 		setHard(byteFromLong(value, 1));
@@ -1386,17 +1382,15 @@
 		setType(byteFromLong(value, 3));
 		setCacheSize(byteFromLong(value, 4));
 		setNoFindLogs((byteFromLong(value, 5)));
-		
-		if ( getHard() == CacheTerrDiff.CW_DT_ERROR 
-				|| getTerrain() == CacheTerrDiff.CW_DT_ERROR 
-				|| getCacheSize() == CacheSize.CW_SIZE_ERROR 
-				|| getType() == CacheType.CW_TYPE_ERROR ) {
+
+		if (getHard() == CacheTerrDiff.CW_DT_ERROR || getTerrain() == CacheTerrDiff.CW_DT_ERROR || getCacheSize() == CacheSize.CW_SIZE_ERROR || getType() == CacheType.CW_TYPE_ERROR) {
 			setIncomplete(true);
 		}
 	}
-	
+
 	/**
 	 * convert a v2 byte filed to the current structures
+	 * 
 	 * @param value
 	 */
 	private void long2byteFieldsv2(long value) {
@@ -1408,11 +1402,14 @@
 		if (getHard() == -1 || getTerrain() == -1 || getCacheSize() == -1) {
 			if (isAddiWpt() || isCustomWpt()) {
 				// Addis don't have their own values for difficulty, terrain and size
-				// Custom waypoints can't be updated to remove incomplete flag, so we 
+				// Custom waypoints can't be updated to remove incomplete flag, so we
 				// have to set reasonable values.
-				if (getHard() == CacheTerrDiff.CW_DT_ERROR) setHard(CacheTerrDiff.CW_DT_UNSET);
-				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR) setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (getCacheSize() == CacheSize.CW_SIZE_ERROR) setCacheSize(CacheSize.CW_SIZE_NONE);
+				if (getHard() == CacheTerrDiff.CW_DT_ERROR)
+					setHard(CacheTerrDiff.CW_DT_UNSET);
+				if (getTerrain() == CacheTerrDiff.CW_DT_ERROR)
+					setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				if (getCacheSize() == CacheSize.CW_SIZE_ERROR)
+					setCacheSize(CacheSize.CW_SIZE_NONE);
 			} else {
 				setIncomplete(true);
 			}
@@ -1420,21 +1417,24 @@
 	}
 
 	/**
-	 * Extracts a byte from a long value. The position is the number of the 8-bit block
-	 * of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the
-	 * right side of the long.
-     * @param value The long value which contains the bytes
-     * @param position The position of the byte, from 1 to 8
-     * @return The decoded byte value
-     */
-    private byte byteFromLong(long value, int position) {
+	 * Extracts a byte from a long value. The position is the number of the 8-bit block of the long (which contains 8 8-bit blocks), counted from 1 to 8, starting from the right side of the long.
+	 * 
+	 * @param value
+	 *            The long value which contains the bytes
+	 * @param position
+	 *            The position of the byte, from 1 to 8
+	 * @return The decoded byte value
+	 */
+	private byte byteFromLong(long value, int position) {
 		byte b = -1; // = 11111111
-	    return (byte)((value &amp; this.byteBitMask(b, position))&gt;&gt;&gt;(position-1)*8);
-    }
+		return (byte) ((value &amp; this.byteBitMask(b, position)) &gt;&gt;&gt; (position - 1) * 8);
+	}
 
 	/**
 	 * Evaluates boolean values from a long value, which is seen as bit field.
-	 * @param value The bit field as long value
+	 * 
+	 * @param value
+	 *            The bit field as long value
 	 */
 	private void long2boolFields(long value) {
 		this.setFiltered((value &amp; this.bool2BitMask(true, 1)) != 0);
@@ -1452,57 +1452,49 @@
 		this.setHasNote((value &amp; this.bool2BitMask(true, 13)) != 0);
 		this.setHasSolver((value &amp; this.bool2BitMask(true, 14)) != 0);
 	}
-	
+
 	/**
-	 * Represents a bit mask as long value for a boolean value which is saved at
-	 * a specified position in the long field.
-	 * @param value The boolean value we want to code
-	 * @param position Position of the value in the bit mask
-	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for
-	 * the one we like to represent: This is 1 if the value is true, 0 if not. 
+	 * Represents a bit mask as long value for a boolean value which is saved at a specified position in the long field.
+	 * 
+	 * @param value
+	 *            The boolean value we want to code
+	 * @param position
+	 *            Position of the value in the bit mask
+	 * @return The corresponding bit mask: A long value where all bits are set to 0 except for the one we like to represent: This is 1 if the value is true, 0 if not.
 	 */
 	private long bool2BitMask(boolean value, int position) {
 		if (value) {
-			return (1L &lt;&lt; (position-1));
+			return (1L &lt;&lt; (position - 1));
 		} else {
 			return 0L;
 		}
 	}
-	
+
 	/**
-	 * Coding a long field which has only the bits of the byte value set. The position is the 
-	 * number (from 1 to 8) of the byte block which is used from the long.
-	 * @param value Byte to encode
-	 * @param position Position of the byte value in the long
+	 * Coding a long field which has only the bits of the byte value set. The position is the number (from 1 to 8) of the byte block which is used from the long.
+	 * 
+	 * @param value
+	 *            Byte to encode
+	 * @param position
+	 *            Position of the byte value in the long
 	 * @return Encoded byte value as long
 	 */
 	private long byteBitMask(byte value, int position) {
-		long result = (0xFF &amp; (long) value) &lt;&lt; ((position-1) *8);
+		long result = (0xFF &amp; (long) value) &lt;&lt; ((position - 1) * 8);
 		return result;
 	}
 
-
 	/**
-	 * Returns &lt;code&gt;true&lt;/code&gt; if the waypoint should appear in the cache list, 
-	 * &lt;code&gt;false&lt;/code&gt; if it should not appear.&lt;br&gt;
-	 * The method takes into account blacklist, filters, search results - everything
-	 * that determines if a cache is visible in the list or not. 
+	 * Returns &lt;code&gt;true&lt;/code&gt; if the waypoint should appear in the cache list, &lt;code&gt;false&lt;/code&gt; if it should not appear.&lt;br&gt;
+	 * The method takes into account blacklist, filters, search results - everything that determines if a cache is visible in the list or not.
+	 * 
 	 * @return
 	 */
 	public boolean isVisible() {
 		Profile profile = Global.getProfile();
 		int filter = profile.getFilterActive();
-		boolean noShow=
-			(  (profile.showBlacklisted() != this.is_black())   
-				||
-			   (profile.showSearchResult() &amp;&amp; !this.is_flaged)   
-			    ||
-			   ( (filter == Filter.FILTER_ACTIVE||filter == Filter.FILTER_MARKED_ONLY) &amp;&amp;	
-			  	 (this.is_filtered())^profile.isFilterInverted())                            
-			  	||
-			   (filter == Filter.FILTER_CACHELIST) &amp;&amp; 
-			     !Global.mainForm.cacheList.contains(this.getWayPoint())
-			);
+		boolean noShow = ((profile.showBlacklisted() != this.is_black()) || (profile.showSearchResult() &amp;&amp; !this.is_flaged) || ((filter == Filter.FILTER_ACTIVE || filter == Filter.FILTER_MARKED_ONLY) &amp;&amp; (this.is_filtered()) ^ profile.isFilterInverted()) || (filter == Filter.FILTER_CACHELIST)
+				&amp;&amp; !Global.mainForm.cacheList.contains(this.getWayPoint()));
 		boolean showAddi = this.showAddis() &amp;&amp; this.mainCache != null &amp;&amp; this.mainCache.isVisible();
 		noShow = noShow &amp;&amp; !showAddi;
 		return !noShow;
@@ -1510,198 +1502,215 @@
 
 	// Getter and Setter for private properties
 
-	public String getLatLon() { return LatLon; }
-	public void setLatLon(String _LatLon) {
-		_LatLon=_LatLon.trim();
-		if (!_LatLon.equals(LatLon.trim())) setUpdated(true);
-		LatLon = _LatLon;
-		pos.set(_LatLon);
+	public CWPoint getPos() {
+		return pos;
 	}
 
-	public String getBearing() {return bearing;}
-	
+	public void setPos(TrackPoint _pos) {
+		if (!_pos.toString().equals(pos.toString()))
+			setUpdated(true);
+		pos.set(_pos);
+	}
+
+	public String getBearing() {
+		return bearing;
+	}
+
 	/**
-	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the 
-	 * last call of the method, the same (cached) object is returned. If the object is
-	 * null or the level is different, a new object is created.&lt;br&gt; 
-	 * @param level 4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
-	 * @param fm Font metrics
+	 * Gets an IconAndText object for the cache. If the level of the Icon is equal to the last call of the method, the same (cached) object is returned. If the object is null or the level is different, a new object is created.&lt;br&gt;
+	 * 
+	 * @param level
+	 *            4=is_incomplete(), 3=is_new(), 2=is_updated(), 1=is_log_updated
+	 * @param fm
+	 *            Font metrics
 	 * @return New or old IconAndText object
 	 */
 	public IconAndText getIconAndTextWP(int level, FontMetrics fm) {
 		if (level != iconAndTextWPLevel || iconAndTextWP == null || !iconAndTextWP.text.equals(wayPoint)) {
 			switch (level) {
-				case 4: iconAndTextWP = new IconAndText(GuiImageBroker.imageError, wayPoint, fm); break;
-				case 3: iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm); break;
-				case 2: iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm); break;
-				case 1: iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm); break;
+			case 4:
+				iconAndTextWP = new IconAndText(CacheType.getTypeImage(CacheType.CW_TYPE_ERROR), wayPoint, fm);
+				break;
+			case 3:
+				iconAndTextWP = new IconAndText(myTableModel.yellow, wayPoint, fm);
+				break;
+			case 2:
+				iconAndTextWP = new IconAndText(myTableModel.red, wayPoint, fm);
+				break;
+			case 1:
+				iconAndTextWP = new IconAndText(myTableModel.blue, wayPoint, fm);
+				break;
 			}
 			iconAndTextWPLevel = level;
 		}
 		return iconAndTextWP;
 	}
-	
-	public String getCacheStatus() { return cacheStatus; }
 
+	public String getCacheStatus() {
+		return cacheStatus;
+	}
+
 	public void setCacheStatus(String cacheStatus) {
-        if (!cacheStatus.equals(this.cacheStatus)) {
-        	this.cacheStatus = cacheStatus;
-            Global.getProfile().notifyUnsavedChanges(true);		
-            this.cacheStatus = cacheStatus;
-            if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null) ) {
-              this.mainCache.setCacheStatus(this.getCacheStatus());
-              // change the addi's in setFound
-            }
-        }
+		if (!cacheStatus.equals(this.cacheStatus)) {
+			this.cacheStatus = cacheStatus;
+			Global.getProfile().notifyUnsavedChanges(true);
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null)) {
+				this.mainCache.setCacheStatus(this.getCacheStatus());
+				// change the addi's in setFound
+			}
+		}
 	}
 
 	public String getWayPoint() {
-    	return wayPoint;
-    }
+		return wayPoint;
+	}
 
 	public void setWayPoint(String wayPoint) {
-		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));		
-    	this.wayPoint = wayPoint;
-    }
+		Global.getProfile().notifyUnsavedChanges(!wayPoint.equals(this.wayPoint));
+		this.wayPoint = wayPoint;
+	}
 
 	public String getCacheName() {
-    	return cacheName;
-    }
+		return cacheName;
+	}
 
 	public void setCacheName(String cacheName) {
-		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));		
-    	this.cacheName = cacheName;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheName.equals(this.cacheName));
+		this.cacheName = cacheName;
+	}
 
 	public String getCacheOwner() {
-    	return cacheOwner;
-    }
+		return cacheOwner;
+	}
 
 	public void setCacheOwner(String cacheOwner) {
-		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));		
-    	this.cacheOwner = cacheOwner;
-    }
+		Global.getProfile().notifyUnsavedChanges(!cacheOwner.equals(this.cacheOwner));
+		this.cacheOwner = cacheOwner;
+	}
 
 	public String getDateHidden() {
-    	return dateHidden;
-    }
+		return dateHidden;
+	}
 
 	public void setDateHidden(String dateHidden) {
-		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));		
-    	this.dateHidden = dateHidden;
-    }
+		Global.getProfile().notifyUnsavedChanges(!dateHidden.equals(this.dateHidden));
+		this.dateHidden = dateHidden;
+	}
 
 	public byte getCacheSize() {
-    	return cacheSize;
-    }
+		return cacheSize;
+	}
 
 	public void setCacheSize(byte cacheSize) {
-		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);		
-    	this.cacheSize = cacheSize;
-    }
+		Global.getProfile().notifyUnsavedChanges(cacheSize != this.cacheSize);
+		this.cacheSize = cacheSize;
+	}
 
 	public byte getHard() {
-    	return hard;
-    }
+		return hard;
+	}
 
 	public void setHard(byte hard) {
-		Global.getProfile().notifyUnsavedChanges(hard != this.hard);		
-    	this.hard = hard;
-    }
+		Global.getProfile().notifyUnsavedChanges(hard != this.hard);
+		this.hard = hard;
+	}
 
 	public byte getTerrain() {
-    	return terrain;
-    }
+		return terrain;
+	}
 
 	public void setTerrain(byte terrain) {
-		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);		
-    	this.terrain = terrain;
-    }
+		Global.getProfile().notifyUnsavedChanges(terrain != this.terrain);
+		this.terrain = terrain;
+	}
 
 	/**
 	 * Gets the type of cache as integer.
+	 * 
 	 * @return Cache type
 	 */
 	public byte getType() {
 		return type;
-    }
+	}
 
 	/**
-	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf
-	 * and byte internally of CacheHolder, some conversion has to be done.
-	 * @param typeId Cache Type
+	 * Sets the type of the cache. As the cache type values are int for the rest of CacheWolf and byte internally of CacheHolder, some conversion has to be done.
+	 * 
+	 * @param typeId
+	 *            Cache Type
 	 */
 	public void setType(byte typeId) {
-		Global.getProfile().notifyUnsavedChanges(typeId != type);		
-    	type = typeId;
-    }
+		Global.getProfile().notifyUnsavedChanges(typeId != type);
+		type = typeId;
+	}
 
 	public boolean is_archived() {
-    	return archived;
-    }
+		return archived;
+	}
 
 	public void setArchived(boolean is_archived) {
-		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);		
-    	this.archived = is_archived;
-    	if (this.archived) {this.available=false;}
-    }
+		Global.getProfile().notifyUnsavedChanges(is_archived != this.archived);
+		this.archived = is_archived;
+		if (this.archived) {
+			this.available = false;
+		}
+	}
 
 	public boolean is_available() {
-    	return available;
-    }
+		return available;
+	}
 
 	public void setAvailable(boolean is_available) {
 		Global.getProfile().notifyUnsavedChanges(is_available != this.available);
-    	this.available = is_available;
-		if (this.available) {this.archived=false;}
-    }
+		this.available = is_available;
+		if (this.available) {
+			this.archived = false;
+		}
+	}
 
 	public boolean is_owned() {
-    	return owned;
-    }
+		return owned;
+	}
 
 	public void setOwned(boolean is_owned) {
-		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);		
-    	this.owned = is_owned;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_owned != this.owned);
+		this.owned = is_owned;
+	}
 
 	public boolean is_found() {
-    	return found;
-    }
+		return found;
+	}
 
 	public void setFound(boolean is_found) {
-    if (is_found != this.found) {
-      Global.getProfile().notifyUnsavedChanges(true);		
-      this.found = is_found;
-      if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null) ) {
-        this.mainCache.setFound(is_found);
-		// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
-        // so setFound should be called after setCacheStatus 
-        if (is_found) this.mainCache.setAttributesToAddiWpts();
-      }
-    }
-  }
+		if (is_found != this.found) {
+			Global.getProfile().notifyUnsavedChanges(true);
+			this.found = is_found;
+			if ((this.getType() == CacheType.CW_TYPE_FINAL) &amp;&amp; (this.mainCache != null)) {
+				this.mainCache.setFound(is_found);
+				// done in setCacheStatus this.mainCache.setCacheStatus(this.getCacheStatus());
+				// so setFound should be called after setCacheStatus
+				if (is_found)
+					this.mainCache.setAttributesToAddiWpts();
+			}
+		}
+	}
 
 	/**
-	 * If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal 
-	 * filter settings apply.&lt;br&gt;
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
+	 * If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal filter settings apply.&lt;br&gt;
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
 	 * @return &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
 	 */
 	public boolean showAddis() {
 		return this.showAddis;
 	}
-	
+
 	/**
-	 * Setter for &lt;code&gt;showAddis()&lt;/code&gt;. 
-	 * If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be 
-	 * displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal 
-	 * filter settings apply.&lt;br&gt;
-	 * This property is not saved in index.xml, so if you reload the data, then this information
-	 * is gone.
-	 * @param value &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
+	 * Setter for &lt;code&gt;showAddis()&lt;/code&gt;. If this returns &lt;code&gt;true&lt;/code&gt;, then the additional waypoints for this cache should be displayed regardless how the filter is set. If it is &lt;code&gt;false&lt;/code&gt;, then the normal filter settings apply.&lt;br&gt;
+	 * This property is not saved in index.xml, so if you reload the data, then this information is gone.
+	 * 
+	 * @param value
+	 *            &lt;code&gt;True&lt;/code&gt;: Always display additional waypoints for cache.
 	 */
 	public void setShowAddis(boolean value) {
 		// This value is always stored in the main cache and all addis.
@@ -1713,17 +1722,15 @@
 		}
 		if (mc.showAddis != value) {
 			mc.showAddis = value;
-			for (int i=0; i&lt;mc.addiWpts.size(); i++) {
+			for (int i = 0; i &lt; mc.addiWpts.size(); i++) {
 				CacheHolder ac = (CacheHolder) mc.addiWpts.get(i);
 				ac.showAddis = value;
 			}
 		}
 	}
-	
+
 	/**
-	 * &lt;b&gt;&lt;u&gt;Important&lt;/u&gt;&lt;/b&gt;: This flag no longer indicates if a cache is visible
-	 * in the list. Instead, it now &lt;u&gt;only&lt;/u&gt; flags if the cache is filtered out
-	 * by filter criteria. Use &lt;code&gt;isVisible()&lt;/code&gt; instead.&lt;br&gt;
+	 * &lt;b&gt;&lt;u&gt;Important&lt;/u&gt;&lt;/b&gt;: This flag no longer indicates if a cache is visible in the list. Instead, it now &lt;u&gt;only&lt;/u&gt; flags if the cache is filtered out by filter criteria. Use &lt;code&gt;isVisible()&lt;/code&gt; instead.&lt;br&gt;
 	 * This property is affected by the following features:
 	 * &lt;ul&gt;
 	 * &lt;li&gt;&quot;Defining and applying&quot; a filter&lt;/li&gt;
@@ -1737,239 +1744,232 @@
 	 * &lt;li&gt;Applying a cache tour filter&lt;/li&gt;
 	 * &lt;li&gt;Switching between normal view and blacklist view&lt;/li&gt;
 	 * &lt;li&gt;Performing searches&lt;/li&gt;
-	 * &lt;li&gt;Anything else that isn't directly connected to filters in 
-	 * it's proper sense.&lt;/li&gt;
+	 * &lt;li&gt;Anything else that isn't directly connected to filters in it's proper sense.&lt;/li&gt;
 	 * &lt;/ul&gt;
 	 * The new method for deciding if a cache is visible or not is &lt;code&gt;isVisible()
-	 * &lt;/code&gt;.  
+	 * &lt;/code&gt;.
+	 * 
 	 * @return &lt;code&gt;True&lt;/code&gt; if filter criteria are matched
 	 */
 	public boolean is_filtered() {
-    	return filtered;
-    }
+		return filtered;
+	}
 
 	public void setFiltered(boolean is_filtered) {
-		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);		
-    	this.filtered = is_filtered;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_filtered != this.filtered);
+		this.filtered = is_filtered;
+	}
 
 	public boolean is_log_updated() {
-    	return log_updated;
-    }
+		return log_updated;
+	}
 
 	public void setLog_updated(boolean is_log_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);		
-		if (is_log_updated &amp;&amp; iconAndTextWPLevel == 1) iconAndTextWP = null;
-    	this.log_updated = is_log_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_log_updated != this.log_updated);
+		if (is_log_updated &amp;&amp; iconAndTextWPLevel == 1)
+			iconAndTextWP = null;
+		this.log_updated = is_log_updated;
+	}
 
 	public boolean is_updated() {
-    	return cache_updated;
-    }
+		return cache_updated;
+	}
 
 	public void setUpdated(boolean is_updated) {
-		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);		
-		if (is_updated &amp;&amp; iconAndTextWPLevel == 2) iconAndTextWP = null;
-    	this.cache_updated = is_updated;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_updated != this.cache_updated);
+		if (is_updated &amp;&amp; iconAndTextWPLevel == 2)
+			iconAndTextWP = null;
+		this.cache_updated = is_updated;
+	}
 
 	public boolean is_incomplete() {
-    	return incomplete;
-    }
+		return incomplete;
+	}
 
 	public void setIncomplete(boolean is_incomplete) {
-		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);	
-		if (is_incomplete &amp;&amp; iconAndTextWPLevel == 4) iconAndTextWP = null;
-    	this.incomplete = is_incomplete;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(is_incomplete != this.incomplete);
+		if (is_incomplete &amp;&amp; iconAndTextWPLevel == 4)
+			iconAndTextWP = null;
+		this.incomplete = is_incomplete;
+	}
+
 	/** checks the waypoint data integrity to set a warning flag if something is missing */
 	public boolean checkIncomplete() {
 		// TODO: discuss if we should only check cache waypoints and silently &quot;fix&quot; everything else
 		boolean ret;
 		if (isCacheWpt()) {
-			if (getWayPoint().length() &lt; 3
-					|| getHard() &lt; CacheTerrDiff.CW_DT_UNSET
-					|| getTerrain() &lt; CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() == CacheSize.CW_SIZE_ERROR
-					|| getCacheOwner().length() == 0
-					|| getDateHidden().length() == 0 
-					|| getCacheName().length() == 0) 
+			if (getWayPoint().length() &lt; 3 || getHard() &lt; CacheTerrDiff.CW_DT_UNSET || getTerrain() &lt; CacheTerrDiff.CW_DT_UNSET || getCacheSize() == CacheSize.CW_SIZE_ERROR || getCacheOwner().length() == 0 || getDateHidden().length() == 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isAddiWpt()) {
-			//FIXME: do not check for mainCache == null, since it will be null during initial import
-			//FIXME: find out why we only check waypoints with IDs of a certain length ???
-//			if (mainCache == null
-//					|| getHard() != CacheTerrDiff.CW_DT_UNSET 
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getWayPoint().length() &lt; 3
-//					|| getCacheOwner().length() &gt; 0
-//					|| getDateHidden().length() &gt; 0 
-					|| getCacheName().length() == 0
-					)
+			// FIXME: do not check for mainCache == null, since it will be null during initial import
+			// FIXME: find out why we only check waypoints with IDs of a certain length ???
+			// if (mainCache == null
+			// || getHard() != CacheTerrDiff.CW_DT_UNSET
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getWayPoint().length() &lt; 3
+			// || getCacheOwner().length() &gt; 0
+			// || getDateHidden().length() &gt; 0
+					|| getCacheName().length() == 0)
 				ret = true;
 			else
 				ret = false;
 		} else if (isCustomWpt()) {
-			if (getHard() != CacheTerrDiff.CW_DT_UNSET 
-					|| getTerrain() != CacheTerrDiff.CW_DT_UNSET
-					|| getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN
-					|| getWayPoint().length() &lt; 3
-//					|| getCacheOwner().length() &gt; 0
-//					|| getDateHidden().length() &gt; 0 
-//					|| getCacheName().length() == 0
-					)
+			if (getHard() != CacheTerrDiff.CW_DT_UNSET || getTerrain() != CacheTerrDiff.CW_DT_UNSET || getCacheSize() != CacheSize.CW_SIZE_NOTCHOSEN || getWayPoint().length() &lt; 3
+			// || getCacheOwner().length() &gt; 0
+			// || getDateHidden().length() &gt; 0
+			// || getCacheName().length() == 0
+			)
 				ret = true;
 			else
 				ret = false;
 		} else {
 			// we should not get here, so let's set a warning just in case
-			ret=true;
+			ret = true;
 		}
 		setIncomplete(ret);
 		return ret;
 	}
 
 	/**
-	 * Determines if the blacklist status is set for the cache. Do not use this method
-	 * to check if the cache should be displayed. Use &lt;code&gt;isVisible()&lt;/code&gt; for
-	 * this, which already does this (and other) checks.&lt;br&gt;
-	 * Only use this method if you really want to inform yourself about the 
-	 * black status of the cache!
+	 * Determines if the blacklist status is set for the cache. Do not use this method to check if the cache should be displayed. Use &lt;code&gt;isVisible()&lt;/code&gt; for this, which already does this (and other) checks.&lt;br&gt;
+	 * Only use this method if you really want to inform yourself about the black status of the cache!
+	 * 
 	 * @return &lt;code&gt;true&lt;/code&gt; if he black status of the cache is set.
 	 */
 	public boolean is_black() {
-    	return black;
-    }
+		return black;
+	}
 
 	public void setBlack(boolean is_black) {
-		Global.getProfile().notifyUnsavedChanges(is_black != this.black);		
-    	this.black = is_black;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_black != this.black);
+		this.black = is_black;
+	}
 
 	public boolean is_new() {
-    	return newCache;
-    }
+		return newCache;
+	}
 
 	public void setNew(boolean is_new) {
-		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);		
-		if (is_new &amp;&amp; iconAndTextWPLevel == 3) iconAndTextWP = null;
+		Global.getProfile().notifyUnsavedChanges(is_new != this.newCache);
+		if (is_new &amp;&amp; iconAndTextWPLevel == 3)
+			iconAndTextWP = null;
 		this.newCache = is_new;
-    }
+	}
 
 	public String getOcCacheID() {
-    	return ocCacheID;
-    }
+		return ocCacheID;
+	}
 
 	public void setOcCacheID(String ocCacheID) {
-		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));		
-    	this.ocCacheID = ocCacheID;
-    }
+		Global.getProfile().notifyUnsavedChanges(!ocCacheID.equals(this.ocCacheID));
+		this.ocCacheID = ocCacheID;
+	}
 
 	public byte getNoFindLogs() {
-    	return noFindLogs;
-    }
+		return noFindLogs;
+	}
 
 	public void setNoFindLogs(byte noFindLogs) {
-		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);		
-    	this.noFindLogs = noFindLogs;
-    }
+		Global.getProfile().notifyUnsavedChanges(noFindLogs != this.noFindLogs);
+		this.noFindLogs = noFindLogs;
+	}
 
 	public int getNumRecommended() {
-    	return numRecommended;
-    }
+		return numRecommended;
+	}
+
 	public String getRecommended() {
 		if (!isCacheWpt())
 			return &quot;&quot;;
-		if ( isOC() ) {
-		  return Convert.formatInt(numRecommended);
+		if (isOC()) {
+			return Convert.formatInt(recommendationScore) + &quot; (&quot; + Convert.formatInt(numRecommended) + &quot;)&quot;;
 		} else {
-		  int gcVote = numRecommended;
-		  if ( gcVote &lt; 100 ) {
-		    return MyLocale.formatDouble((double)gcVote/10.0, &quot;0.0&quot;); 
-		  } else {
-		    int votes = gcVote / 100;
-		    gcVote = gcVote - 100 * votes;
-		    return MyLocale.formatDouble((double)gcVote/10.0, &quot;0.0&quot;) + &quot; (&quot; + Convert.formatInt(votes) + &quot;)&quot;;
-		  }
+			int gcVote = numRecommended;
+			if (gcVote &lt; 100) {
+				return MyLocale.formatDouble((double) gcVote / 10.0, &quot;0.0&quot;);
+			} else {
+				int votes = gcVote / 100;
+				gcVote = gcVote - 100 * votes;
+				return MyLocale.formatDouble((double) gcVote / 10.0, &quot;0.0&quot;) + &quot; (&quot; + Convert.formatInt(votes) + &quot;)&quot;;
+			}
 		}
 	}
 
 	public void setNumRecommended(int numRecommended) {
-		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);		
-    	this.numRecommended = numRecommended;
-    }
+		Global.getProfile().notifyUnsavedChanges(numRecommended != this.numRecommended);
+		this.numRecommended = numRecommended;
+	}
 
 	public int getNumFoundsSinceRecommendation() {
-    	return numFoundsSinceRecommendation;
-    }
+		return numFoundsSinceRecommendation;
+	}
 
 	public void setNumFoundsSinceRecommendation(int numFoundsSinceRecommendation) {
-		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);		
-    	this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
-    }
+		Global.getProfile().notifyUnsavedChanges(numFoundsSinceRecommendation != this.numFoundsSinceRecommendation);
+		this.numFoundsSinceRecommendation = numFoundsSinceRecommendation;
+	}
 
 	public boolean has_bugs() {
-    	return bugs;
-    }
+		return bugs;
+	}
 
 	public void setHas_bugs(boolean has_bug) {
-		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);		
-    	this.bugs = has_bug;
-    }
+		Global.getProfile().notifyUnsavedChanges(has_bug != this.bugs);
+		this.bugs = has_bug;
+	}
 
 	public boolean is_HTML() {
-    	return html;
-    }
+		return html;
+	}
 
 	public void setHTML(boolean is_HTML) {
-		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);		
-    	this.html = is_HTML;
-    }
+		Global.getProfile().notifyUnsavedChanges(is_HTML != this.html);
+		this.html = is_HTML;
+	}
 
 	public String getLastSync() {
-    	return lastSync;
-    }
+		return lastSync;
+	}
 
 	public void setLastSync(String lastSync) {
-		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));		
-    	this.lastSync = lastSync;
-    }
+		Global.getProfile().notifyUnsavedChanges(!lastSync.equals(this.lastSync));
+		this.lastSync = lastSync;
+	}
 
 	public long[] getAttributesBits() {
-    	return this.attributesBits;
-    }
+		return this.attributesBits;
+	}
 
 	public void setAttribsAsBits(long[] attributesBits) {
-		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);		
-    	this.attributesBits = attributesBits;
-    }
-	
+		Global.getProfile().notifyUnsavedChanges(attributesBits != this.attributesBits);
+		this.attributesBits = attributesBits;
+	}
+
 	public boolean hasSolver() {
 		return hasSolver;
 	}
-	
+
 	public void setHasSolver(boolean hasSolver) {
-		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);		
+		Global.getProfile().notifyUnsavedChanges(hasSolver != this.hasSolver);
 		this.hasSolver = hasSolver;
 	}
 
 	public boolean hasNote() {
 		return hasNote;
 	}
-	
+
 	public void setHasNote(boolean hasNote) {
-		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);		
+		Global.getProfile().notifyUnsavedChanges(hasNote != this.hasNote);
 		this.hasNote = hasNote;
 	}
-	
+
 	/**
 	 * rename a waypoint and all its associated files
-	 * @param newWptId new waypoint id (will be converted to upper case)
+	 * 
+	 * @param newWptId
+	 *            new waypoint id (will be converted to upper case)
 	 * @return true on success, false on error
 	 */
 	public boolean rename(String newWptId) {
@@ -1985,4 +1985,3 @@
 		}
 	}
 }
-

Modified: branches/r1.2/src/CacheWolf/CacheHolderDetail.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheHolderDetail.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheHolderDetail.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -40,532 +40,555 @@
 import ewe.util.Vector;
 
 public class CacheHolderDetail {
-	  
-	  
-	 /** CacheHolder which holds the detail. &lt;b&gt;Only&lt;/b&gt; set by CacheHolder when creating detail! **/
-	  private CacheHolder parent = null;
-	  public String LongDescription = CacheHolder.EMPTY;
-	  public String LastUpdate = CacheHolder.EMPTY;
-	  public String Hints = CacheHolder.EMPTY;
-	  public LogList CacheLogs=new LogList();
-	  private String CacheNotes = CacheHolder.EMPTY;
-	  public CacheImages images = new CacheImages();
-	  public CacheImages logImages = new CacheImages();
-	  public CacheImages userImages = new CacheImages();
-	  public Attributes attributes=new Attributes();
-	  public Vector CacheIcons = new Vector();
-	  public TravelbugList Travelbugs=new TravelbugList();
-	  //public String Bugs = EMPTY; Superceded by Travelbugs
-	  public String URL = CacheHolder.EMPTY;
-	  private String Solver = CacheHolder.EMPTY;
-	  public String OwnLogId = CacheHolder.EMPTY;
-	  public Log OwnLog = null;
-	  public String Country = CacheHolder.EMPTY;
-	  public String State = CacheHolder.EMPTY;
-	  /** For faster cache import (from opencaching) changes are only written when the details are freed from memory 
-	   * If you want to save the changes automatically when the details are unloaded, set this to true */ 
-	  public boolean hasUnsavedChanges = false;
-	  
-	 public CacheHolderDetail(CacheHolder ch) {
-		 parent = ch;
-	 }
 
-	 public CacheHolder getParent() {
-		 return parent;
-	 }
-	 public void setLongDescription(String longDescription) {
-	 	if (LongDescription.equals(&quot;&quot;)) getParent().setNew(true);
-	 	else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription))) getParent().setUpdated(true);
-	 	LongDescription = longDescription;
-	 }
-	 
-	 private String stripControlChars(String desc) {
-		 StringBuffer sb=new StringBuffer(desc.length());
-		 for (int i=0; i&lt;desc.length(); i++) {
-			char c=desc.charAt(i);
-			if (c&gt;' ') sb.append(c);
-		 }
-		 return sb.toString();
-	 }
-	 
-	 public void setHints(String hints) {
-	 	if (!Hints.equals(hints)) getParent().setUpdated(true);
-	 	Hints = hints;
-	 }
-	 
-	 public void setSolver(String solver) {
-		 if (!Solver.equals(solver)) getParent().setUpdated(true);
-		 getParent().setHasSolver(!solver.trim().equals(&quot;&quot;));
-		 Solver = solver;
-	 }
-	 
-	 public String getSolver() {
-		 return this.Solver;
-	 }
+	/** CacheHolder which holds the detail. &lt;b&gt;Only&lt;/b&gt; set by CacheHolder when creating detail! **/
+	private CacheHolder parent = null;
+	public String LongDescription = CacheHolder.EMPTY;
+	public String LastUpdate = CacheHolder.EMPTY;
+	public String Hints = CacheHolder.EMPTY;
+	public LogList CacheLogs = new LogList();
+	private String CacheNotes = CacheHolder.EMPTY;
+	public CacheImages images = new CacheImages();
+	public CacheImages logImages = new CacheImages();
+	public CacheImages userImages = new CacheImages();
+	public Attributes attributes = new Attributes();
+	public Vector CacheIcons = new Vector();
+	public TravelbugList Travelbugs = new TravelbugList();
+	// public String Bugs = EMPTY; Superceded by Travelbugs
+	public String URL = CacheHolder.EMPTY;
+	private String Solver = CacheHolder.EMPTY;
+	public String OwnLogId = CacheHolder.EMPTY;
+	public Log OwnLog = null;
+	public String Country = CacheHolder.EMPTY;
+	public String State = CacheHolder.EMPTY;
+	/**
+	 * For faster cache import (from opencaching) changes are only written when the details are freed from memory
+	 * If you want to save the changes automatically when the details are unloaded, set this to true
+	 */
+	public boolean hasUnsavedChanges = false;
 
-	 public void setCacheNotes(String notes) {
-		 if (!CacheNotes.equals(notes)) getParent().setUpdated(true);
-		 getParent().setHasNote(!notes.trim().equals(&quot;&quot;));
-		 CacheNotes = notes;
-	 }
-	 
-	 public String getCacheNotes() {
-		 return this.CacheNotes;
-	 }
-	 
-	 public void setCacheLogs(LogList newLogs) {
-		 int size=newLogs.size();
-		 for (int i=size-1; i&gt;=0; i--) { // Loop over all new logs, must start with oldest log
-			 if (CacheLogs.merge(newLogs.getLog(i))&gt;=0) getParent().setLog_updated(true);
-		 }
-		 if (CacheLogs.purgeLogs() &gt; 0) hasUnsavedChanges=true;
-		 getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
-	 }
+	public CacheHolderDetail(CacheHolder ch) {
+		parent = ch;
+	}
 
-	 
-	  /**
+	public CacheHolder getParent() {
+		return parent;
+	}
+
+	public void setLongDescription(String longDescription) {
+		if (LongDescription.equals(&quot;&quot;))
+			getParent().setNew(true);
+		else if (!stripControlChars(LongDescription).equals(stripControlChars(longDescription)))
+			getParent().setUpdated(true);
+		LongDescription = longDescription;
+	}
+
+	private String stripControlChars(String desc) {
+		StringBuffer sb = new StringBuffer(desc.length());
+		for (int i = 0; i &lt; desc.length(); i++) {
+			char c = desc.charAt(i);
+			if (c &gt; ' ')
+				sb.append(c);
+		}
+		return sb.toString();
+	}
+
+	public void setHints(String hints) {
+		if (!Hints.equals(hints))
+			getParent().setUpdated(true);
+		Hints = hints;
+	}
+
+	public void setSolver(String solver) {
+		if (!Solver.equals(solver))
+			getParent().setUpdated(true);
+		getParent().setHasSolver(!solver.trim().equals(&quot;&quot;));
+		Solver = solver;
+	}
+
+	public String getSolver() {
+		return this.Solver;
+	}
+
+	public void setCacheNotes(String notes) {
+		if (!CacheNotes.equals(notes))
+			getParent().setUpdated(true);
+		getParent().setHasNote(!notes.trim().equals(&quot;&quot;));
+		CacheNotes = notes;
+	}
+
+	public String getCacheNotes() {
+		return this.CacheNotes;
+	}
+
+	public void setCacheLogs(LogList newLogs) {
+		int size = newLogs.size();
+		for (int i = size - 1; i &gt;= 0; i--) { // Loop over all new logs, must start with oldest log
+			if (CacheLogs.merge(newLogs.getLog(i)) &gt;= 0)
+				getParent().setLog_updated(true);
+		}
+		if (CacheLogs.purgeLogs() &gt; 0)
+			hasUnsavedChanges = true;
+		getParent().setNoFindLogs(CacheLogs.countNotFoundLogs());
+	}
+
+	/**
 	 * Method to update an existing cache with new data. This is
 	 * necessary to avoid missing old logs. Called from GPX Importer
-	 * @param newCh new cache data
+	 * 
+	 * @param newCh
+	 *            new cache data
 	 * @return CacheHolder with updated data
 	 */
-	 public CacheHolderDetail update(CacheHolderDetail newCh) {
-			// flags
-			CacheHolder ch = getParent();
-			if (ch.is_found() &amp;&amp; ch.getCacheStatus().equals(&quot;&quot;)) {
-				ch.setCacheStatus(ch.getFoundText());
+	public CacheHolderDetail update(CacheHolderDetail newCh) {
+		// flags
+		CacheHolder ch = getParent();
+		if (ch.is_found() &amp;&amp; ch.getCacheStatus().equals(&quot;&quot;)) {
+			ch.setCacheStatus(ch.getFoundText());
+		}
+		// travelbugs:GPX-File contains all actual travelbugs but not the missions
+		// we need to check whether the travelbug is already in the existing list
+		getParent().setHas_bugs(newCh.Travelbugs.size() &gt; 0);
+		for (int i = newCh.Travelbugs.size() - 1; i &gt;= 0; i--) {
+			Travelbug tb = newCh.Travelbugs.getTB(i);
+			Travelbug oldTB = this.Travelbugs.find(tb.getName());
+			// If the bug is already in the cache, we keep it
+			if (oldTB != null) {
+				if (tb.getMission().length() &gt; 0)
+					oldTB.setMission(tb.getMission());
+				if (tb.getGuid().length() &gt; 0)
+					oldTB.setGuid(tb.getGuid());
+				newCh.Travelbugs.replace(i, oldTB);
 			}
-			//travelbugs:GPX-File contains all actual travelbugs but not the missions
-			// we need to check whether the travelbug is already in the existing list
-			getParent().setHas_bugs(newCh.Travelbugs.size()&gt;0);
-			for (int i=newCh.Travelbugs.size()-1; i&gt;=0; i--) {
-				Travelbug tb=newCh.Travelbugs.getTB(i);
-				Travelbug oldTB=this.Travelbugs.find(tb.getName());
-				// If the bug is already in the cache, we keep it
-				if (oldTB != null) {
-					if (tb.getMission().length() &gt; 0)
-						oldTB.setMission(tb.getMission());
-					if (tb.getGuid().length() &gt; 0)
-						oldTB.setGuid(tb.getGuid());
-					newCh.Travelbugs.replace(i,oldTB);
-				}
+		}
+		this.Travelbugs = newCh.Travelbugs;
+		if (newCh.attributes.count() &gt; 0)
+			this.attributes = newCh.attributes;
+		// URL
+		this.URL = newCh.URL;
+		// Images
+		this.images = newCh.images;
+		setLongDescription(newCh.LongDescription);
+		setHints(newCh.Hints);
+		setCacheLogs(newCh.CacheLogs);
+		if (newCh.OwnLogId.length() &gt; 0)
+			this.OwnLogId = newCh.OwnLogId;
+		if (newCh.OwnLog != null)
+			this.OwnLog = newCh.OwnLog;
+		if (newCh.Country.length() &gt; 0)
+			this.Country = newCh.Country;
+		if (newCh.State.length() &gt; 0)
+			this.State = newCh.State;
+		if (newCh.getSolver().length() &gt; 0)
+			this.setSolver(newCh.getSolver());
+		return this;
+	}
+
+	/**
+	 * Adds a user image to the cache data
+	 * 
+	 * @param profile
+	 */
+	public void addUserImage(Profile profile) {
+		File imgFile;
+		String imgDesc, imgDestName;
+
+		// Get Image and description
+		FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
+		fc.setTitle(&quot;Select image file:&quot;);
+		if (fc.execute() != FormBase.IDCANCEL) {
+			imgFile = fc.getChosenFile();
+			imgDesc = new InputBox(&quot;Description&quot;).input(&quot;&quot;, 10);
+			// Create Destination Filename
+			String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
+			imgDestName = getParent().getWayPoint() + &quot;_U_&quot; + (this.userImages.size() + 1) + ext;
+
+			ImageInfo userImageInfo = new ImageInfo();
+			userImageInfo.setFilename(imgDestName);
+			userImageInfo.setTitle(imgDesc);
+			this.userImages.add(userImageInfo);
+			// Copy File
+			DataMover.copy(imgFile.getFullPath(), profile.dataDir + imgDestName);
+			// Save Data
+			saveCacheDetails(profile.dataDir);
+		}
+	}
+
+	/**
+	 * Method to parse a specific cache.xml file.
+	 * It fills information on cache details, hints, logs, notes and
+	 * images.
+	 */
+	void readCache(String dir) throws IOException {
+		String dummy;
+		FileReader in = null;
+		ImageInfo imageInfo;
+		// If parent cache has empty waypoint then don't do anything. This might happen
+		// when a cache object is freshly created to serve as container for imported data
+		if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY))
+			return;
+		FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
+		if (cacheFile.exists()) {
+			try {
+				in = new FileReader(cacheFile.getAbsolutePath());
+			} catch (FileNotFoundException e) {
+				in = null; // exception is thrown again below, if file could not be found in upper case, too
 			}
-			this.Travelbugs = newCh.Travelbugs;
-			if (newCh.attributes.count() &gt; 0) this.attributes = newCh.attributes;
-			// URL
-			this.URL = newCh.URL;
-			// Images
-			this.images = newCh.images;
-			setLongDescription(newCh.LongDescription);
-			setHints(newCh.Hints);
-			setCacheLogs(newCh.CacheLogs);
-			if (newCh.OwnLogId.length()&gt;0) this.OwnLogId=newCh.OwnLogId;
-			if (newCh.OwnLog != null) this.OwnLog = newCh.OwnLog;
-			if (newCh.Country.length()&gt;0) this.Country=newCh.Country;
-			if (newCh.State.length()&gt;0) this.State=newCh.State;
-			if (newCh.getSolver().length()&gt;0) this.setSolver(newCh.getSolver());
-			return this;		
-	 }
-	  
-	  /**
-	   * Adds a user image to the cache data
-	   * @param profile
-	   */
-		public void addUserImage(Profile profile){
-		  File imgFile;
-		  String imgDesc, imgDestName;
-		  
-		  //Get Image and description
-			FileChooser fc = new FileChooser(FileChooserBase.OPEN, profile.dataDir);
-			fc.setTitle(&quot;Select image file:&quot;);
-			if(fc.execute() != FormBase.IDCANCEL){
-				imgFile = fc.getChosenFile();
-				imgDesc = new InputBox(&quot;Description&quot;).input(&quot;&quot;,10);
-				//Create Destination Filename
-				String ext = imgFile.getFileExt().substring(imgFile.getFileExt().lastIndexOf('.'));
-				imgDestName = getParent().getWayPoint() + &quot;_U_&quot; + (this.userImages.size()+1) + ext;
-				
-				ImageInfo userImageInfo = new ImageInfo();
-				userImageInfo.setFilename(imgDestName);
-				userImageInfo.setTitle(imgDesc);
-				this.userImages.add(userImageInfo);
-				// Copy File
-				DataMover.copy(imgFile.getFullPath(),profile.dataDir + imgDestName);
-				// Save Data
-				saveCacheDetails(profile.dataDir);
+		}
+		if (in == null) {
+			cacheFile = new FileBugfix(dir + getParent().getWayPoint() + &quot;.xml&quot;);
+			if (cacheFile.exists()) {
+				in = new FileReader(cacheFile.getAbsolutePath());
 			}
-	  }
+		}
 
-	  
-		/**
-		*	Method to parse a specific cache.xml file.
-		*	It fills information on cache details, hints, logs, notes and
-		*	images.
-		*/
-		void readCache(String dir) throws IOException{
-			String dummy;
-			FileReader in = null;
-			ImageInfo imageInfo;
-			// If parent cache has empty waypoint then don't do anything. This might happen
-			// when a cache object is freshly created to serve as container for imported data
-			if (this.getParent().getWayPoint().equals(CacheHolder.EMPTY)) return;
-			FileBugfix cacheFile = new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);			
-			if (cacheFile.exists()) {
-				try {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				} catch (FileNotFoundException e) {
-					in = null; //exception is thrown again below, if file could not be found in upper case, too
-				}
+		if (in == null)
+			throw new FileNotFoundException(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
+		Global.getPref().log(&quot;Reading file &quot; + getParent().getWayPoint() + &quot;.xml&quot;);
+		String text = in.readAll();
+		in.close();
+
+		Extractor ex = new Extractor(text, &quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/DETAILS&gt;&quot;, 0, true);
+		LongDescription = ex.findNext();
+
+		ex.set(text, &quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/COUNTRY&gt;&quot;, 0, true);
+		Country = ex.findNext();
+
+		ex.set(text, &quot;&lt;STATE&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/STATE&gt;&quot;, 0, true);
+		State = ex.findNext();
+
+		// Attributes
+		ex.set(text, &quot;&lt;ATTRIBUTES&gt;&quot;, &quot;&lt;/ATTRIBUTES&gt;&quot;, 0, true);
+		attributes.XmlAttributesEnd(ex.findNext());
+
+		ex.set(text, &quot;&lt;HINTS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/HINTS&gt;&quot;, 0, true);
+		Hints = ex.findNext();
+
+		ex.set(text, &quot;&lt;LOGS&gt;&quot;, &quot;&lt;/LOGS&gt;&quot;, 0, true);
+		dummy = ex.findNext();
+
+		ex.set(dummy, &quot;&lt;OWNLOGID&gt;&quot;, &quot;&lt;/OWNLOGID&gt;&quot;, 0, true);
+		OwnLogId = ex.findNext();
+
+		ex.set(dummy, &quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/OWNLOG&gt;&quot;, 0, true);
+		String ownLogText = ex.findNext();
+		if (ownLogText.length() &gt; 0) {
+			if (ownLogText.indexOf(&quot;&lt;img src='&quot;) &gt;= 0) {
+				OwnLog = new Log(ownLogText + &quot;]]&gt;&quot;);
+			} else {
+				OwnLog = new Log(&quot;icon_smile.gif&quot;, &quot;1900-01-01&quot;, Global.getPref().myAlias, ownLogText);
 			}
-			if (in == null) {
-				cacheFile = new FileBugfix(dir + getParent().getWayPoint() + &quot;.xml&quot;);			
-				if (cacheFile.exists()) {
-					in = new FileReader(cacheFile.getAbsolutePath());
-				}
-			}
+		} else {
+			OwnLog = null;
+		}
 
-			if (in == null) throw new FileNotFoundException(dir+getParent().getWayPoint().toLowerCase()+&quot;.xml&quot;);
-			Global.getPref().log(&quot;Reading file &quot;+getParent().getWayPoint() + &quot;.xml&quot;);
-			String text= in.readAll();
-			in.close();
-			Extractor ex = new Extractor(text, &quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/DETAILS&gt;&quot;, 0, true);		
-			LongDescription = ex.findNext();
-			ex = new Extractor(text, &quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/COUNTRY&gt;&quot;, 0, true);
-			Country = ex.findNext();
-			ex = new Extractor(text, &quot;&lt;STATE&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/STATE&gt;&quot;, 0, true);
-			State = ex.findNext();
-			// Attributes
-			ex = new Extractor(text,&quot;&lt;ATTRIBUTES&gt;&quot;,&quot;&lt;/ATTRIBUTES&gt;&quot;,0,true);
-			attributes.XmlAttributesEnd(ex.findNext());
-			
-			ex = new Extractor(text, &quot;&lt;HINTS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/HINTS&gt;&quot;, 0, true);
-			Hints = ex.findNext();
-			ex = new Extractor(text, &quot;&lt;LOGS&gt;&quot;,&quot;&lt;/LOGS&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			ex = new Extractor(dummy, &quot;&lt;OWNLOGID&gt;&quot;,&quot;&lt;/OWNLOGID&gt;&quot;, 0, true);
-			OwnLogId = ex.findNext();
-			ex = new Extractor(dummy, &quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/OWNLOG&gt;&quot;, 0, true);
-			String ownLogText = ex.findNext();
-			if ( ownLogText.length() &gt; 0 ) {
-				if (ownLogText.indexOf(&quot;&lt;img src='&quot;) &gt;= 0) {
-					OwnLog = new Log( ownLogText + &quot;]]&gt;&quot; );
-				} else {
-					OwnLog = new Log( &quot;icon_smile.gif&quot;, &quot;1900-01-01&quot;, Global.getPref().myAlias, ownLogText );
-				}
+		CacheLogs.clear();
+		ex.set(dummy, &quot;&lt;LOG&gt;&quot;, &quot;&lt;/LOG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			CacheLogs.add(new Log(dummy));
+		}
+
+		ex.set(text, &quot;&lt;NOTES&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/NOTES&gt;&quot;, 0, true);
+		CacheNotes = ex.findNext();
+		images.clear();
+
+		ex.set(text, &quot;&lt;IMG&gt;&quot;, &quot;&lt;/IMG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = new ImageInfo();
+			int pos = dummy.indexOf(&quot;&lt;URL&gt;&quot;);
+			if (pos &gt; 0) {
+				imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0, pos)));
+				imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos + 5, dummy.indexOf(&quot;&lt;/URL&gt;&quot;)))));
 			} else {
-				OwnLog = null;
+				imageInfo.setFilename(SafeXML.cleanback(dummy));
 			}
-			CacheLogs.clear();
-			ex = new Extractor(dummy, &quot;&lt;LOG&gt;&quot;,&quot;&lt;/LOG&gt;&quot;, 0, true);
-			
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				CacheLogs.add(new Log(dummy));
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, &quot;&lt;NOTES&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/NOTES&gt;&quot;, 0, true);
-			CacheNotes = ex.findNext();
-			images.clear();
-			ex = new Extractor(text, &quot;&lt;IMG&gt;&quot;, &quot;&lt;/IMG&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				int pos=dummy.indexOf(&quot;&lt;URL&gt;&quot;);
-				if (pos&gt;0) {
-					imageInfo.setFilename(SafeXML.cleanback(dummy.substring(0,pos)));
-					imageInfo.setURL(SafeXML.cleanback((dummy.substring(pos+5,dummy.indexOf(&quot;&lt;/URL&gt;&quot;)))));
-				} else {
-					imageInfo.setFilename(SafeXML.cleanback(dummy));
-				}
-				this.images.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, &quot;&lt;IMGTEXT&gt;&quot;, &quot;&lt;/IMGTEXT&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			int imgNr = 0;
-			while(!ex.endOfSearch()){
-				if (imgNr &gt;= this.images.size()) {
-					images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the &lt;cache&gt;.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
-					Global.getPref().log(&quot;Error reading &quot; + this.getParent().getWayPoint() + &quot;More IMGTEXT tags than IMG tags&quot;);
-				}
-				imageInfo = this.images.get(imgNr);
-				int pos=dummy.indexOf(&quot;&lt;DESC&gt;&quot;);
-				if (pos&gt;0) {
-					imageInfo.setTitle(dummy.substring(0,pos));
-					imageInfo.setComment(dummy.substring(pos+6,dummy.indexOf(&quot;&lt;/DESC&gt;&quot;)));
-				} else {
-					imageInfo.setTitle(dummy);
-				}
-				dummy = ex.findNext();
-				imgNr = imgNr + 1;
-			}
-			// Logimages
-			logImages.clear();
-			ex = new Extractor(text, &quot;&lt;LOGIMG&gt;&quot;, &quot;&lt;/LOGIMG&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				logImages.add(imageInfo);
-				dummy = ex.findNext();
-			}
-			ex = new Extractor(text, &quot;&lt;LOGIMGTEXT&gt;&quot;, &quot;&lt;/LOGIMGTEXT&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = logImages.get(imgNr++);
-				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
-			}
+			this.images.add(imageInfo);
+		}
 
-			userImages.clear();
-			ex = new Extractor(text, &quot;&lt;USERIMG&gt;&quot;, &quot;&lt;/USERIMG&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			while(!ex.endOfSearch()){
-				imageInfo = new ImageInfo();
-				imageInfo.setFilename(dummy);
-				userImages.add(imageInfo);
-				dummy = ex.findNext();
+		ex.set(text, &quot;&lt;IMGTEXT&gt;&quot;, &quot;&lt;/IMGTEXT&gt;&quot;, 0, true);
+		int imgNr = 0;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			if (imgNr &gt;= this.images.size()) {
+				images.add(new ImageInfo()); // this (more IMGTEXT than IMG in the &lt;cache&gt;.xml, but it happens. So avoid an ArrayIndexOutOfBoundException and add an ImageInfo gracefully
+				Global.getPref().log(&quot;Error reading &quot; + this.getParent().getWayPoint() + &quot;More IMGTEXT tags than IMG tags&quot;);
 			}
-			ex = new Extractor(text, &quot;&lt;USERIMGTEXT&gt;&quot;, &quot;&lt;/USERIMGTEXT&gt;&quot;, 0, true);
-			dummy = ex.findNext();
-			imgNr = 0;
-			while(!ex.endOfSearch()){
-				imageInfo = userImages.get(imgNr++);
+			imageInfo = this.images.get(imgNr);
+			int pos = dummy.indexOf(&quot;&lt;DESC&gt;&quot;);
+			if (pos &gt; 0) {
+				imageInfo.setTitle(dummy.substring(0, pos));
+				imageInfo.setComment(dummy.substring(pos + 6, dummy.indexOf(&quot;&lt;/DESC&gt;&quot;)));
+			} else {
 				imageInfo.setTitle(dummy);
-				dummy = ex.findNext();
 			}
+			imgNr = imgNr + 1;
+		}
 
-			ex = new Extractor(text, &quot;&lt;TRAVELBUGS&gt;&quot;, &quot;&lt;/TRAVELBUGS&gt;&quot;, 0, false);
-			dummy=ex.findNext();
-			if (ex.endOfSearch()) {
-				ex = new Extractor(text, &quot;&lt;BUGS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/BUGS&gt;&quot;, 0, true);
-				String Bugs = ex.findNext();
-				Travelbugs.addFromHTML(Bugs);
-			} else
-				Travelbugs.addFromXML(dummy);
-			
-			ex = new Extractor(text, &quot;&lt;URL&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/URL&gt;&quot;, 0, true);
-			// if no URL is stored, set default URL (at this time only possible for gc.com)
-			dummy = ex.findNext();
-			if (dummy.length() &gt; 10){
-				URL = dummy;
-				int logpos = URL.indexOf(&quot;&amp;&quot;); //&amp;Submit &amp;log=y
-				if (logpos &gt; 0) URL=URL.substring(0,logpos);
-			}
-			else {
-				if (getParent().getWayPoint().startsWith(&quot;GC&quot;)) {
-					URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+ getParent().getWayPoint();
-				}
-			}
-			ex = new Extractor(text, &quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/SOLVER&gt;&quot;, 0, true);
-			this.setSolver(ex.findNext());
+		logImages.clear();
+		ex.set(text, &quot;&lt;LOGIMG&gt;&quot;, &quot;&lt;/LOGIMG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			logImages.add(imageInfo);
 		}
-		public void deleteFile(String FileName) {	
-			//File exists?
-			boolean exists = (new File(FileName)).exists();
-			//yes: then delete
-			if (exists) {
-				boolean ok = (new File(FileName)).delete();
-				if(ok) ok = true;
-			}
-			boolean exists2 = (new File(FileName.toLowerCase())).exists();
-			//yes: delete
-			if (exists2) {
-				boolean ok2 = (new File(FileName.toLowerCase())).delete();
-				if(ok2) ok2=true;
-			}
+
+		ex.set(text, &quot;&lt;LOGIMGTEXT&gt;&quot;, &quot;&lt;/LOGIMGTEXT&gt;&quot;, 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = logImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
 		}
-		/**
-		*	Method to save a cache.xml file.
-		*/
-		public void saveCacheDetails(String dir){
-			PrintWriter detfile;
-			deleteFile(dir + getParent().getWayPoint() + &quot;.xml&quot;);
-			try{
-			  detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;).getAbsolutePath())));
-			} catch (Exception e) {
-				Global.getPref().log(&quot;Problem creating details file&quot;,e,true);
-				return;
-			}
-			try{
-				if(getParent().getWayPoint().length()&gt;0){
-				  detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;CACHEDETAILS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;VERSION value = \&quot;3\&quot;/&gt;\n&quot;);
-				  detfile.print(&quot;&lt;DETAILS&gt;&lt;![CDATA[&quot;+LongDescription+&quot;]]&gt;&lt;/DETAILS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot;+Country+&quot;]]&gt;&lt;/COUNTRY&gt;\n&quot;);
-				  detfile.print(&quot;&lt;STATE&gt;&lt;![CDATA[&quot;+State+&quot;]]&gt;&lt;/STATE&gt;\n&quot;);
-				  detfile.print(attributes.XmlAttributesWrite());
-				  detfile.print(&quot;&lt;HINTS&gt;&lt;![CDATA[&quot;+Hints+&quot;]]&gt;&lt;/HINTS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;LOGS&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;OWNLOGID&gt;&quot;+OwnLogId+&quot;&lt;/OWNLOGID&gt;\r\n&quot;);
-				  if ( OwnLog != null ) {
-					  detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot;+OwnLog.toHtml()+&quot;]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
-				  } else {
-					  detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
-				  }
-				  for(int i = 0; i &lt; CacheLogs.size(); i++){
-					  detfile.print(CacheLogs.getLog(i).toXML());
-				  }
-				  detfile.print(&quot;&lt;/LOGS&gt;\r\n&quot;);
-			
-				  detfile.print(&quot;&lt;NOTES&gt;&lt;![CDATA[&quot;+CacheNotes+&quot;]]&gt;&lt;/NOTES&gt;\n&quot;);
-				  detfile.print(&quot;&lt;IMAGES&gt;\n&quot;);
-				  String stbuf = new String();
-				  for(int i = 0;i&lt;images.size();i++){
-						stbuf = images.get(i).getFilename();
-						String urlBuf = images.get(i).getURL();
-						if (urlBuf != null &amp;&amp; !urlBuf.equals(&quot;&quot;)) {
-							detfile.print(&quot;    &lt;IMG&gt;&quot;+SafeXML.clean(stbuf)+&quot;&lt;URL&gt;&quot;+SafeXML.clean(urlBuf)+&quot;&lt;/URL&gt;&lt;/IMG&gt;\n&quot;);
-						} else {
-							detfile.print(&quot;    &lt;IMG&gt;&quot;+SafeXML.clean(stbuf)+&quot;&lt;/IMG&gt;\n&quot;);
-						}
-				  }
-				  int iis = images.size();
-				  for(int i = 0;i&lt;iis;i++){
-						stbuf = images.get(i).getTitle();
-						if (i&lt; iis &amp;&amp; !images.get(i).getComment().equals(&quot;&quot;))
-							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;DESC&gt;&quot;+images.get(i).getComment()+&quot;&lt;/DESC&gt;&lt;/IMGTEXT&gt;\n&quot;);
-						else 
-							detfile.print(&quot;    &lt;IMGTEXT&gt;&quot;+stbuf+&quot;&lt;/IMGTEXT&gt;\n&quot;);
-				  }
 
-				  for(int i = 0;i&lt;logImages.size();i++){
-						stbuf = logImages.get(i).getFilename();
-						detfile.print(&quot;    &lt;LOGIMG&gt;&quot;+stbuf+&quot;&lt;/LOGIMG&gt;\n&quot;);
-				  }
-				  for(int i = 0;i&lt;logImages.size();i++){
-						stbuf = logImages.get(i).getTitle();
-						detfile.print(&quot;    &lt;LOGIMGTEXT&gt;&quot;+stbuf+&quot;&lt;/LOGIMGTEXT&gt;\n&quot;);
-				  }
-				  for(int i = 0;i&lt;userImages.size();i++){
-						stbuf = userImages.get(i).getFilename();
-						detfile.print(&quot;    &lt;USERIMG&gt;&quot;+stbuf+&quot;&lt;/USERIMG&gt;\n&quot;);
-				  }
-				  for(int i = 0;i&lt;userImages.size();i++){
-						stbuf = userImages.get(i).getTitle();
-						detfile.print(&quot;    &lt;USERIMGTEXT&gt;&quot;+stbuf+&quot;&lt;/USERIMGTEXT&gt;\n&quot;);
-				  }
+		userImages.clear();
+		ex.set(text, &quot;&lt;USERIMG&gt;&quot;, &quot;&lt;/USERIMG&gt;&quot;, 0, true);
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = new ImageInfo();
+			imageInfo.setFilename(dummy);
+			userImages.add(imageInfo);
+		}
 
+		ex.set(text, &quot;&lt;USERIMGTEXT&gt;&quot;, &quot;&lt;/USERIMGTEXT&gt;&quot;, 0, true);
+		imgNr = 0;
+		while ((dummy = ex.findNext()).length() &gt; 0) {
+			imageInfo = userImages.get(imgNr++);
+			imageInfo.setTitle(dummy);
+		}
 
-				  detfile.print(&quot;&lt;/IMAGES&gt;\n&quot;);
-				  //detfile.print(&quot;&lt;BUGS&gt;&lt;![CDATA[\n&quot;);
-				  //detfile.print(Bugs+&quot;\n&quot;);
-				  //detfile.print(&quot;]]&gt;&lt;/BUGS&gt;\n&quot;);
-				  detfile.print(Travelbugs.toXML());
-				  detfile.print(&quot;&lt;URL&gt;&lt;![CDATA[&quot;+URL+&quot;]]&gt;&lt;/URL&gt;\r\n&quot;);
-				  detfile.print(&quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;+getSolver()+&quot;]]&gt;&lt;/SOLVER&gt;\r\n&quot;);
-				  detfile.print(getParent().toXML()); // This will allow restoration of index.xml
-				  detfile.print(&quot;&lt;/CACHEDETAILS&gt;\n&quot;);
-				  Global.getPref().log(&quot;Writing file: &quot;+getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
-				} // if length
-			} catch (Exception e){
-				Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;,e);
+		ex.set(text, &quot;&lt;TRAVELBUGS&gt;&quot;, &quot;&lt;/TRAVELBUGS&gt;&quot;, 0, false);
+		dummy = ex.findNext();
+		if (dummy.length() == 0) {
+			ex = new Extractor(text, &quot;&lt;BUGS&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/BUGS&gt;&quot;, 0, true);
+			String Bugs = ex.findNext();
+			Travelbugs.addFromHTML(Bugs);
+		} else
+			Travelbugs.addFromXML(dummy);
+
+		ex.set(text, &quot;&lt;URL&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/URL&gt;&quot;, 0, true);
+		// if no URL is stored, set default URL (at this time only possible for gc.com)
+		dummy = ex.findNext();
+		if (dummy.length() &gt; 10) {
+			URL = dummy;
+			int logpos = URL.indexOf(&quot;&amp;&quot;); // &amp;Submit &amp;log=y
+			if (logpos &gt; 0)
+				URL = URL.substring(0, logpos);
+		} else {
+			if (getParent().getWayPoint().startsWith(&quot;GC&quot;)) {
+				URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + getParent().getWayPoint();
 			}
-			try{
-			  detfile.close();
-			} catch (Exception e){
-				Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;,e);
-			}
-			hasUnsavedChanges = false;
 		}
-				
-		/**
-		 * Return true if this cache has additional info for some pictures
-		 * @return true if cache has additional info, false otherwise
-		 */
-		public boolean hasImageInfo() {
-			for (int i=this.images.size()-1; i&gt;=0; i--)
-				if (!this.images.get(i).getComment().equals(&quot;&quot;)) return true;
-			return false;
+
+		ex.set(text, &quot;&lt;SOLVER&gt;&lt;![CDATA[&quot;, &quot;]]&gt;&lt;/SOLVER&gt;&quot;, 0, true);
+		this.setSolver(ex.findNext());
+	}
+
+	public void deleteFile(String FileName) {
+		// File exists?
+		boolean exists = (new File(FileName)).exists();
+		// yes: then delete
+		if (exists) {
+			boolean ok = (new File(FileName)).delete();
+			if (ok)
+				ok = true;
 		}
+		boolean exists2 = (new File(FileName.toLowerCase())).exists();
+		// yes: delete
+		if (exists2) {
+			boolean ok2 = (new File(FileName.toLowerCase())).delete();
+			if (ok2)
+				ok2 = true;
+		}
+	}
 
-		/**
-		 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
-		 * @param newWptId new id of the waypoint
-		 * @return true on success, false for failure
-		 */
-		protected boolean rename(String newWptId) {
-			boolean success = false;
-			String profiledir = Global.getProfile().dataDir;
-			int oldWptLength = getParent().getWayPoint().length();
-			
-			// just in case ... (got the pun? ;) )
-			newWptId = newWptId.toUpperCase();
-			
-			// update image information
-			for(int i = 0;i&lt;images.size();i++){
-				String filename = images.get(i).getFilename();
-				String comment = images.get(i).getComment();
-				String title = images.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					images.get(i).setFilename(filename);
+	/**
+	 * Method to save a cache.xml file.
+	 */
+	public void saveCacheDetails(String dir) {
+		PrintWriter detfile;
+		deleteFile(dir + getParent().getWayPoint() + &quot;.xml&quot;);
+		try {
+			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dir + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;).getAbsolutePath())));
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem creating details file&quot;, e, true);
+			return;
+		}
+		try {
+			if (getParent().getWayPoint().length() &gt; 0) {
+				detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;CACHEDETAILS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;VERSION value = \&quot;3\&quot;/&gt;\n&quot;);
+				detfile.print(&quot;&lt;DETAILS&gt;&lt;![CDATA[&quot; + LongDescription + &quot;]]&gt;&lt;/DETAILS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;COUNTRY&gt;&lt;![CDATA[&quot; + Country + &quot;]]&gt;&lt;/COUNTRY&gt;\n&quot;);
+				detfile.print(&quot;&lt;STATE&gt;&lt;![CDATA[&quot; + State + &quot;]]&gt;&lt;/STATE&gt;\n&quot;);
+				detfile.print(attributes.XmlAttributesWrite());
+				detfile.print(&quot;&lt;HINTS&gt;&lt;![CDATA[&quot; + Hints + &quot;]]&gt;&lt;/HINTS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;LOGS&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;OWNLOGID&gt;&quot; + OwnLogId + &quot;&lt;/OWNLOGID&gt;\r\n&quot;);
+				if (OwnLog != null) {
+					detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[&quot; + OwnLog.toHtml() + &quot;]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
+				} else {
+					detfile.print(&quot;&lt;OWNLOG&gt;&lt;![CDATA[]]&gt;&lt;/OWNLOG&gt;\r\n&quot;);
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					images.get(i).setComment(comment);
+				for (int i = 0; i &lt; CacheLogs.size(); i++) {
+					detfile.print(CacheLogs.getLog(i).toXML());
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					images.get(i).setTitle(title);
+				detfile.print(&quot;&lt;/LOGS&gt;\r\n&quot;);
+
+				detfile.print(&quot;&lt;NOTES&gt;&lt;![CDATA[&quot; + CacheNotes + &quot;]]&gt;&lt;/NOTES&gt;\n&quot;);
+				detfile.print(&quot;&lt;IMAGES&gt;\n&quot;);
+				String stbuf;
+				for (int i = 0; i &lt; images.size(); i++) {
+					stbuf = images.get(i).getFilename();
+					String urlBuf = images.get(i).getURL();
+					if (urlBuf != null &amp;&amp; !urlBuf.equals(&quot;&quot;)) {
+						detfile.print(&quot;    &lt;IMG&gt;&quot; + SafeXML.clean(stbuf) + &quot;&lt;URL&gt;&quot; + SafeXML.clean(urlBuf) + &quot;&lt;/URL&gt;&lt;/IMG&gt;\n&quot;);
+					} else {
+						detfile.print(&quot;    &lt;IMG&gt;&quot; + SafeXML.clean(stbuf) + &quot;&lt;/IMG&gt;\n&quot;);
+					}
 				}
-			}
-			for(int i = 0;i&lt;logImages.size();i++){
-				String filename = logImages.get(i).getFilename();
-				String comment = logImages.get(i).getComment();
-				String title = logImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					logImages.get(i).setFilename(filename);
+				int iis = images.size();
+				for (int i = 0; i &lt; iis; i++) {
+					stbuf = images.get(i).getTitle();
+					if (i &lt; iis &amp;&amp; !images.get(i).getComment().equals(&quot;&quot;))
+						detfile.print(&quot;    &lt;IMGTEXT&gt;&quot; + stbuf + &quot;&lt;DESC&gt;&quot; + images.get(i).getComment() + &quot;&lt;/DESC&gt;&lt;/IMGTEXT&gt;\n&quot;);
+					else
+						detfile.print(&quot;    &lt;IMGTEXT&gt;&quot; + stbuf + &quot;&lt;/IMGTEXT&gt;\n&quot;);
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					logImages.get(i).setComment(comment);
+
+				for (int i = 0; i &lt; logImages.size(); i++) {
+					stbuf = logImages.get(i).getFilename();
+					detfile.print(&quot;    &lt;LOGIMG&gt;&quot; + stbuf + &quot;&lt;/LOGIMG&gt;\n&quot;);
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					logImages.get(i).setTitle(title);
+				for (int i = 0; i &lt; logImages.size(); i++) {
+					stbuf = logImages.get(i).getTitle();
+					detfile.print(&quot;    &lt;LOGIMGTEXT&gt;&quot; + stbuf + &quot;&lt;/LOGIMGTEXT&gt;\n&quot;);
 				}
-			}
-			for(int i = 0;i&lt;userImages.size();i++){
-				String filename = userImages.get(i).getFilename();
-				String comment = userImages.get(i).getComment();
-				String title = userImages.get(i).getTitle();
-				if (filename.indexOf(getParent().getWayPoint()) == 0) {
-					filename=newWptId.concat(filename.substring(oldWptLength));
-					userImages.get(i).setFilename(filename);
+				for (int i = 0; i &lt; userImages.size(); i++) {
+					stbuf = userImages.get(i).getFilename();
+					detfile.print(&quot;    &lt;USERIMG&gt;&quot; + stbuf + &quot;&lt;/USERIMG&gt;\n&quot;);
 				}
-				if (comment.indexOf(getParent().getWayPoint()) == 0) {
-					comment=newWptId.concat(comment.substring(oldWptLength));
-					userImages.get(i).setComment(comment);
+				for (int i = 0; i &lt; userImages.size(); i++) {
+					stbuf = userImages.get(i).getTitle();
+					detfile.print(&quot;    &lt;USERIMGTEXT&gt;&quot; + stbuf + &quot;&lt;/USERIMGTEXT&gt;\n&quot;);
 				}
-				if (title.indexOf(getParent().getWayPoint()) == 0) {
-					title=newWptId.concat(title.substring(oldWptLength));
-					userImages.get(i).setTitle(title);
-				}
+
+				detfile.print(&quot;&lt;/IMAGES&gt;\n&quot;);
+				// detfile.print(&quot;&lt;BUGS&gt;&lt;![CDATA[\n&quot;);
+				// detfile.print(Bugs+&quot;\n&quot;);
+				// detfile.print(&quot;]]&gt;&lt;/BUGS&gt;\n&quot;);
+				detfile.print(Travelbugs.toXML());
+				detfile.print(&quot;&lt;URL&gt;&lt;![CDATA[&quot; + URL + &quot;]]&gt;&lt;/URL&gt;\r\n&quot;);
+				detfile.print(&quot;&lt;SOLVER&gt;&lt;![CDATA[&quot; + getSolver() + &quot;]]&gt;&lt;/SOLVER&gt;\r\n&quot;);
+				detfile.print(getParent().toXML()); // This will allow restoration of index.xml
+				detfile.print(&quot;&lt;/CACHEDETAILS&gt;\n&quot;);
+				Global.getPref().log(&quot;Writing file: &quot; + getParent().getWayPoint().toLowerCase() + &quot;.xml&quot;);
+			} // if length
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;, e);
+		}
+		try {
+			detfile.close();
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Problem waypoint &quot; + getParent().getWayPoint() + &quot; writing to a details file: &quot;, e);
+		}
+		hasUnsavedChanges = false;
+	}
+
+	/**
+	 * Return true if this cache has additional info for some pictures
+	 * 
+	 * @return true if cache has additional info, false otherwise
+	 */
+	public boolean hasImageInfo() {
+		for (int i = this.images.size() - 1; i &gt;= 0; i--)
+			if (!this.images.get(i).getComment().equals(&quot;&quot;))
+				return true;
+		return false;
+	}
+
+	/**
+	 * change id in waypoint details and rename associated files. Function should only be called by CacheHolder
+	 * 
+	 * @param newWptId
+	 *            new id of the waypoint
+	 * @return true on success, false for failure
+	 */
+	protected boolean rename(String newWptId) {
+		boolean success = false;
+		String profiledir = Global.getProfile().dataDir;
+		int oldWptLength = getParent().getWayPoint().length();
+
+		// just in case ... (got the pun? ;) )
+		newWptId = newWptId.toUpperCase();
+
+		// update image information
+		for (int i = 0; i &lt; images.size(); i++) {
+			String filename = images.get(i).getFilename();
+			String comment = images.get(i).getComment();
+			String title = images.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				images.get(i).setFilename(filename);
 			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				images.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				images.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i &lt; logImages.size(); i++) {
+			String filename = logImages.get(i).getFilename();
+			String comment = logImages.get(i).getComment();
+			String title = logImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				logImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				logImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				logImages.get(i).setTitle(title);
+			}
+		}
+		for (int i = 0; i &lt; userImages.size(); i++) {
+			String filename = userImages.get(i).getFilename();
+			String comment = userImages.get(i).getComment();
+			String title = userImages.get(i).getTitle();
+			if (filename.indexOf(getParent().getWayPoint()) == 0) {
+				filename = newWptId.concat(filename.substring(oldWptLength));
+				userImages.get(i).setFilename(filename);
+			}
+			if (comment.indexOf(getParent().getWayPoint()) == 0) {
+				comment = newWptId.concat(comment.substring(oldWptLength));
+				userImages.get(i).setComment(comment);
+			}
+			if (title.indexOf(getParent().getWayPoint()) == 0) {
+				title = newWptId.concat(title.substring(oldWptLength));
+				userImages.get(i).setTitle(title);
+			}
+		}
 
-			// rename the files
-			try {
-				// since we use *.* we do not need FileBugFix
-				String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat(&quot;*.*&quot;), ewe.io.FileBase.LIST_FILES_ONLY);
-				for (int i=0; i &lt; srcFiles.length;i++){
-					String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
-					File srcFile = new File(profiledir.concat(srcFiles[i]));
-					File dstFile = new File(profiledir.concat(newfile));
-					srcFile.move(dstFile);
-				}
-				success = true;
-			} catch (Exception e) {
-				Global.getPref().log(&quot;Error renaming waypoint details&quot;, e, true);
-				//TODO: any chance of a roll back?
-				//TODO: should we ignore a file not found?
+		// rename the files
+		try {
+			// since we use *.* we do not need FileBugFix
+			String srcFiles[] = new File(profiledir).list(getParent().getWayPoint().concat(&quot;*.*&quot;), ewe.io.FileBase.LIST_FILES_ONLY);
+			for (int i = 0; i &lt; srcFiles.length; i++) {
+				String newfile = newWptId.concat(srcFiles[i].substring(oldWptLength));
+				File srcFile = new File(profiledir.concat(srcFiles[i]));
+				File dstFile = new File(profiledir.concat(newfile));
+				srcFile.move(dstFile);
 			}
-			hasUnsavedChanges = true;
-			return success;
+			success = true;
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Error renaming waypoint details&quot;, e, true);
+			// TODO: any chance of a roll back?
+			// TODO: should we ignore a file not found?
 		}
+		hasUnsavedChanges = true;
+		return success;
+	}
 }
-
-

Modified: branches/r1.2/src/CacheWolf/CacheImages.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheImages.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheImages.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -30,66 +30,75 @@
 import ewe.util.Vector;
 
 /**
- * This class holds the image information of a cache. 
+ * This class holds the image information of a cache.
+ * 
  * @author torsti
- *
+ * 
  */
 public class CacheImages {
-	
-	private int initialSize=10;
-	/** Lazy initialization of the vector: It is created only when needed. If it is not accessed,
-	 * it will stay &lt;code&gt;null&lt;/code&gt;.*/
-	private Vector vector=null;
+
+	private int initialSize = 10;
+	/**
+	 * Lazy initialization of the vector: It is created only when needed. If it is not accessed,
+	 * it will stay &lt;code&gt;null&lt;/code&gt;.
+	 */
+	private Vector vector = null;
 	/** Images that should display in the image panel */
-	private CacheImages display=null;
-	
-	public CacheImages(){ // Public constructor
+	private CacheImages display = null;
+
+	public CacheImages() { // Public constructor
 	}
 
 	public CacheImages(int initialSize) {
-		if (initialSize&lt;0) {
-			throw new IllegalArgumentException(&quot;Initial size for CacheImage must be &gt; 0. Value: &quot;+String.valueOf(initialSize));
+		if (initialSize &lt; 0) {
+			throw new IllegalArgumentException(&quot;Initial size for CacheImage must be &gt; 0. Value: &quot; + String.valueOf(initialSize));
 		}
 		this.initialSize = initialSize;
 	}
-	private Vector getVector(){
-		if (this.vector==null) {
+
+	private Vector getVector() {
+		if (this.vector == null) {
 			vector = new Vector(this.initialSize);
 		}
 		return this.vector;
 	}
-	
+
 	/**
-	 * Adds an ImageInfo object to the list of images. The object is always appended in the 
+	 * Adds an ImageInfo object to the list of images. The object is always appended in the
 	 * last position.
-	 * @param img ImageInfo object to add.
+	 * 
+	 * @param img
+	 *            ImageInfo object to add.
 	 */
 	public void add(ImageInfo img) {
-		display = null;  // New Image? Force display to get reevaluated 
-        getVector().add(img);
-    }
-	
+		display = null; // New Image? Force display to get reevaluated
+		getVector().add(img);
+	}
+
 	/**
 	 * Gets the ImageInfo object at the specified position.
-	 * @param idx Index of object to retrieve.
+	 * 
+	 * @param idx
+	 *            Index of object to retrieve.
 	 * @return ImageInfo object
 	 */
 	public ImageInfo get(int idx) {
 		return (ImageInfo) getVector().get(idx);
 	}
-	
+
 	/**
 	 * Removes all image information.
 	 */
 	public void clear() {
-		if (this.vector!=null) {
-			display = null; 
+		if (this.vector != null) {
+			display = null;
 			this.vector.clear();
 		}
 	}
-	
+
 	/**
 	 * Returns the number of ImageInfo objects in the collection.
+	 * 
 	 * @return Number
 	 */
 	public int size() {
@@ -99,52 +108,59 @@
 			return this.vector.size();
 		}
 	}
-	
+
 	/**
 	 * Fills the &lt;code&gt;display&lt;/code&gt; collection with the images that really should display
 	 * in the image panel.
-	 * @param prefix The prefix which is used to name default image titles
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
 	 */
 	private void checkForDisplayImages(String prefix) {
-		if (this.size()&gt;1) {
+		if (this.size() &gt; 1) {
 			display = new CacheImages(this.size());
 			// Loop over every image
-			for (int i=0; i&lt;this.size(); i++) {
+			for (int i = 0; i &lt; this.size(); i++) {
 				boolean shouldDisplay = true;
 				ImageInfo currImg = this.get(i);
 				// Now check against every other image
-				for (int j=0; j&lt;this.size(); j++) {
-					if (i==j) continue; // Except same image
+				for (int j = 0; j &lt; this.size(); j++) {
+					if (i == j)
+						continue; // Except same image
 					ImageInfo testImg = this.get(j);
 					// Are the filenames the same?
 					if (currImg.getFilename().toLowerCase().equals(testImg.getFilename().toLowerCase())) {
 						// Check if other title is better than current one
-						if (currImg.getTitle().startsWith(prefix) &amp;&amp;
-							!testImg.getTitle().startsWith(prefix)) {
+						if (currImg.getTitle().startsWith(prefix) &amp;&amp; !testImg.getTitle().startsWith(prefix)) {
 							// If yes: Don't show the image
 							shouldDisplay = false;
 						}
 					}
 				}
-				if (shouldDisplay) display.add(currImg);
+				if (shouldDisplay)
+					display.add(currImg);
 			}
 		}
 	}
-	
+
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is
 	 * starting with the indicated prefix and if there is another image referring to the same file but
 	 * with a different title.&lt;br&gt;
 	 * Normally, the results are cached and don't need to be evaluated again. If they should
-	 * be reevaluated for whatever reason, then pass &lt;code&gt;true&lt;/code&gt; as parameter.  
-	 * @param prefix The prefix which is used to name default image titles
-	 * @param forceEvaluation When &lt;code&gt;true&lt;/code&gt; the images that should display are
-	 * reexamined.
-	 * @return The CacheImage collection of images. 
+	 * be reevaluated for whatever reason, then pass &lt;code&gt;true&lt;/code&gt; as parameter.
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @param forceEvaluation
+	 *            When &lt;code&gt;true&lt;/code&gt; the images that should display are
+	 *            reexamined.
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix, boolean forceEvaluation) {
-		if (display == null || forceEvaluation) this.checkForDisplayImages(prefix);
+		if (display == null || forceEvaluation)
+			this.checkForDisplayImages(prefix);
 		if (display == null) {
 			return this;
 		} else {
@@ -153,40 +169,42 @@
 	}
 
 	/**
-	 * Returns a CacheImage collection of the images that should be displayed in the 
-	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is 
+	 * Returns a CacheImage collection of the images that should be displayed in the
+	 * image panel. An image should &lt;b&gt;not&lt;/b&gt; be present in this collection if its title is
 	 * equivalent to its filename and if there is another image referring to the same file but
 	 * with a different title.
-	 * @param prefix The prefix which is used to name default image titles
-	 * @return The CacheImage collection of images. 
+	 * 
+	 * @param prefix
+	 *            The prefix which is used to name default image titles
+	 * @return The CacheImage collection of images.
 	 */
 	public CacheImages getDisplayImages(String prefix) {
 		return this.getDisplayImages(prefix, false);
 	}
-	
+
 	/**
 	 * Checks if a image of a given URL needs to be spidered. It does &lt;b&gt;not&lt;/b&gt; need to be spidered
-	 * if the following conditions meet: &lt;ul&gt;
-	 * &lt;li&gt;The url is from &lt;code&gt;<A HREF="http://img.geocaching.com/cache/&lt;/code">http://img.geocaching.com/cache/&lt;/code</A>&gt; or 
-	 * &lt;code&gt;<A HREF="http://img.groundspeak.com/cache/&lt;/code">http://img.groundspeak.com/cache/&lt;/code</A>&gt;. (Reason: Images at these places don't change - 
-	 * if images change, they get a new url.)&lt;/li&gt;
+	 * if the following conditions meet:
+	 * &lt;ul&gt;
+	 * &lt;li&gt;The url is from &lt;code&gt;<A HREF="http://img.geocaching.com/cache/&lt;/code">http://img.geocaching.com/cache/&lt;/code</A>&gt; or &lt;code&gt;<A HREF="http://img.groundspeak.com/cache/&lt;/code">http://img.groundspeak.com/cache/&lt;/code</A>&gt;. (Reason: Images at these places don't change - if images change, they get a new url.)&lt;/li&gt;
 	 * &lt;li&gt;An image with the given URL is among the images of the caches image object.&lt;/li&gt;
 	 * &lt;li&gt;The intended file name is the same.&lt;/li&gt;
 	 * &lt;li&gt;The image is present in the file system.&lt;/li&gt;
-	 * &lt;/ul&gt; If no spidering is needed, then the &lt;code&gt;ImageInfo&lt;/code&gt; object of the equivalent image is
+	 * &lt;/ul&gt;
+	 * If no spidering is needed, then the &lt;code&gt;ImageInfo&lt;/code&gt; object of the equivalent image is
 	 * returned, otherwise (when spidering is needed) &lt;code&gt;null&lt;/code&gt; is returned.
-	 * @param pNewUrl URL to check
+	 * 
+	 * @param pNewUrl
+	 *            URL to check
 	 * @return ImageInfo object
 	 */
 	public ImageInfo needsSpidering(String pNewUrl, String pFilename) {
 		String newUrl = CacheImages.optimizeLink(pNewUrl);
 		ImageInfo result = null;
-		if (this.size() &gt; 0 &amp;&amp; 
-				(newUrl.startsWith(&quot;<A HREF="http://img.geocaching.com/cache/">http://img.geocaching.com/cache/</A>&quot;))) {
-			for (int i=0; i&lt;this.size(); i++) {
+		if (this.size() &gt; 0 &amp;&amp; (newUrl.startsWith(&quot;<A HREF="http://img.geocaching.com/cache/">http://img.geocaching.com/cache/</A>&quot;))) {
+			for (int i = 0; i &lt; this.size(); i++) {
 				ImageInfo img = this.get(i);
-				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) 
-						&amp;&amp; img.getFilename().equals(pFilename)) {
+				if (CacheImages.optimizeLink(img.getURL()).equals(newUrl) &amp;&amp; img.getFilename().equals(pFilename)) {
 					String location = Global.getProfile().dataDir + pFilename;
 					if ((new FileBugfix(location)).exists()) {
 						result = img;
@@ -197,16 +215,18 @@
 		}
 		return result;
 	}
-	
+
 	/**
-	 * Checks if an image with a certain filename is present in the collection of the caches 
+	 * Checks if an image with a certain filename is present in the collection of the caches
 	 * images.
-	 * @param filename Filename to check
+	 * 
+	 * @param filename
+	 *            Filename to check
 	 * @return &lt;code&gt;true&lt;/code&gt; if there is such a file, &lt;code&gt;false&lt;/code&gt; if not.
 	 */
 	private boolean hasFile(String filename) {
 		boolean result = false;
-		for (int i=0; i&lt;this.size(); i++) {
+		for (int i = 0; i &lt; this.size(); i++) {
 			if (this.get(i).getFilename().toUpperCase().equals(filename.toUpperCase())) {
 				result = true;
 				break;
@@ -214,38 +234,43 @@
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Deletes images that are no longer needed. It takes two CacheImage objects as arguments, one
-	 * as a collection of images before an update, the other after. Then every file in the old 
+	 * as a collection of images before an update, the other after. Then every file in the old
 	 * collection is checked if it is also present in the new collection. If not, the file is deleted.
 	 * Note that the &lt;i&gt;content&lt;/i&gt; of the files is irrelevant. It is only important to remove files
-	 * - regardles of their contents - if they are no longer referenced after a cache update. 
-	 * @param oldImages Set of images before update
-	 * @param newImages Set of images after update
+	 * - regardles of their contents - if they are no longer referenced after a cache update.
+	 * 
+	 * @param oldImages
+	 *            Set of images before update
+	 * @param newImages
+	 *            Set of images after update
 	 */
 	public static void cleanupOldImages(CacheImages oldImages, CacheImages newImages) {
 		// Loop over every image in the old collection
-		for (int i=0; i&lt;oldImages.size(); i++) {
+		for (int i = 0; i &lt; oldImages.size(); i++) {
 			// Check if image file is present in new collection
 			String obsoleteFilename = oldImages.get(i).getFilename();
 			if (!newImages.hasFile(obsoleteFilename)) {
 				String location = Global.getProfile().dataDir + obsoleteFilename;
 				File tmpFile = new FileBugfix(location);
 				if (tmpFile.exists() &amp;&amp; tmpFile.canWrite()) {
-					Global.getPref().log(&quot;Image not longer needed. Deleting: &quot;+obsoleteFilename);
+					Global.getPref().log(&quot;Image not longer needed. Deleting: &quot; + obsoleteFilename);
 					tmpFile.delete();
 				}
 			}
 		}
 	}
-	
+
 	/**
 	 * Takes an image url and does some optimization: As img.groundspeak.com is the same as
-	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html, 
-	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to 
+	 * img.geocaching.com and the former is sometimes used by owners in the cache listing html,
+	 * this method replaces img.groundspeak.com by img.geocaching.com, in order to be able to
 	 * identify identical pictures as such.
-	 * @param pUrl URL to modify
+	 * 
+	 * @param pUrl
+	 *            URL to modify
 	 * @return Same URL, eventually modified
 	 */
 	public static String optimizeLink(String pUrl) {
@@ -256,5 +281,5 @@
 		}
 		return url;
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/CacheList.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -133,14 +133,12 @@
 		myList(int rows, int columns, boolean multi) { super(rows,columns,multi); }
 
 		//  Allow the caches to be dragged out of the cachelist
-		String wayPoint;
 		int idx;
 
 		public void startDragging(DragContext dc) {
 			 idx=getSelectedIndex(0);
 			 if (idx&gt;=0) {
 				 CacheHolder ch=cacheList.get(idx);
-				 wayPoint=ch.getWayPoint();
 				 IconAndText imgDrag=new IconAndText();
 				 imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
 				 imgDrag.addColumn(ch.getWayPoint());

Modified: branches/r1.2/src/CacheWolf/CacheType.java
===================================================================
--- branches/r1.2/src/CacheWolf/CacheType.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CacheType.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Image;
@@ -31,26 +31,27 @@
 	public byte _cwMappedCType; // CW Cache Typ intern
 	public byte _cwCType; // CW Cache Typ intern
 	public char _cwCGroup; // Cache Typ Group intern
-	public String _cwCTypeV1; // V1 Cache Typ 
-	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com 
-	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com 
-	public byte _cwCTypeV2; // V2 Cache Typ 
+	public String _cwCTypeV1; // V1 Cache Typ
+	public String _gcCTypeSpider; // GC Type on Spider Import from GC.com
+	public String _ocCTypeXmlImport; // GC Type on Spider Import from GC.com
+	public byte _cwCTypeV2; // V2 Cache Typ
 	public char _gpxShortCType; // Short Typ (one char abbreviation)
 	public String _imageName; // name of imageName for Icon, &quot;showCacheInBrowser&quot; and &quot;KML Export&quot;
 	public String _gpxWptTypeTag; // gpx wpt &lt;type&gt; tag
 	public String _gpxWptSymTag; // gpx wpt &lt;sym&gt; tag
 	public String _gpxWptGCextensionTypTag; // gpx cache extension &lt;groundspeak:type&gt; tag
-	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources 		
+	public String _gpxAlternativeWptTypTags; // alternative typ - names for gpx from other sources
 	public int _msgNrCTypeName; // message number for gui cache Typ name
 	public int _GUIOrder; // sort Order in GUI selection //TODO more intelligent implementation (now manually change each line on new one)
-	public int _FilterStringPos; // BitNr in Filter String (profile) 
+	public int _FilterStringPos; // BitNr in Filter String (profile)
 	public int _FilterPattern; // 2**BitNr in Filter int (does not correspond with BitNr in String)
-	public Image _iconImage; 
+	public Image _iconImage;
 	public Image _mapImage;
-	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, 
-			String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, 
-			String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos, int filterPattern) {
-		
+	public Image[] _modImage = { null, null, null, null, null, null, null };
+
+	public CTyp(byte cwMappedCType, byte cwCType, char cwCGroup, String cwCTypeV1, String gcCTypeSpider, String ocCTypeXmlImport, byte cwCTypeV2, char gpxShortCType, String imageName, String[] gpx, int msgNrCTypeName, int gUIOrder, int filterStringPos,
+			int filterPattern) {
+
 		_cwMappedCType = cwMappedCType;
 		_cwCType = cwCType;
 		_cwCGroup = cwCGroup;
@@ -69,15 +70,14 @@
 		_FilterStringPos = filterStringPos;
 		_FilterPattern = filterPattern;
 		if (!_imageName.equals(&quot;&quot;)) {
-			_iconImage=new Image(_imageName);
-			_mapImage=_iconImage;
+			_iconImage = new Image(_imageName);
+			_mapImage = _iconImage;
 		}
 	}
 }
 
-
 /**
- * Handles all aspects of converting cache type information 
+ * Handles all aspects of converting cache type information
  * from and to the various im- and exporters ...
  * converting legacy profiles to current standard
  *
@@ -110,7 +110,7 @@
 	public static final byte CW_TYPE_WEBCAM = 11;
 	/** locationless cache (GC) */
 	public static final byte CW_TYPE_LOCATIONLESS = 12;
-	/** CITO cache (GC)*/
+	/** CITO cache (GC) */
 	public static final byte CW_TYPE_CITO = 13;
 	/** Mega Event Cache (GC) */
 	public static final byte CW_TYPE_MEGA_EVENT = 100;
@@ -132,88 +132,103 @@
 	public static final byte CW_TYPE_REFERENCE = 55;
 	/** unrecognized cache type or missing information */
 	public static final byte CW_TYPE_ERROR = -1;
-	String[] ggpx={&quot;Geocache|Custom&quot;,&quot;Custom&quot;,&quot;Custom&quot;,&quot;&quot;};
+	String[] ggpx = { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; };
+	private static final byte found = 0;
+	private static final byte archived = 1;
+	private static final byte disabled = 2;
+	private static final byte solved = 3;
+	private static final byte bonus = 4;
+	private static final byte owned = 5;
+	private static final byte dnf = 6;
+	//
 	private static final CTyp[] cTypRef = {
-		// custom waypoints
-		new CTyp(CW_TYPE_CUSTOM,CW_TYPE_CUSTOM,'P',&quot;0&quot;,&quot;&quot;,&quot;&quot;,(byte) -128,'C',&quot;typeCustom.png&quot;,new String[] {&quot;Geocache|Custom&quot;,&quot;Custom&quot;,&quot;Custom&quot;,&quot;&quot;},1,0,10,0x000100),
-		// Cache waypoints
-		new CTyp(CW_TYPE_TRADITIONAL,CW_TYPE_TRADITIONAL,'C',&quot;2&quot;,&quot;2&quot;,&quot;2&quot;,(byte) -126,'T',&quot;typeTradi.png&quot;,new String[] {&quot;Geocache|Traditional Cache&quot;,&quot;Geocache&quot;,&quot;Traditional Cache&quot;,&quot;Traditional|Classic&quot;},2,1,0,0x000001),
-		new CTyp(CW_TYPE_MULTI,CW_TYPE_MULTI,'C',&quot;3&quot;,&quot;3&quot;,&quot;3&quot;,(byte) -125,'M',&quot;typeMulti.png&quot;,new String[] {&quot;Geocache|Multi-cache&quot;,&quot;Geocache&quot;,&quot;Multi-cache&quot;,&quot;Multi|Offset&quot;},3,2,1,0x000002),
-		new CTyp(CW_TYPE_VIRTUAL,CW_TYPE_VIRTUAL,'C',&quot;4&quot;,&quot;4&quot;,&quot;4&quot;,(byte) -124,'V',&quot;typeVirtual.png&quot;,new String[] {&quot;Geocache|Virtual Cache&quot;,&quot;Geocache&quot;,&quot;Virtual Cache&quot;,&quot;Virtual&quot;},4,3,2,0x000004),
-		new CTyp(CW_TYPE_LETTERBOX,CW_TYPE_LETTERBOX,'C',&quot;5&quot;,&quot;5&quot;,&quot;&quot;,(byte) -123,'L',&quot;typeLetterbox.png&quot;,new String[] {&quot;Geocache|Letterbox Hybrid&quot;,&quot;Geocache&quot;,&quot;Letterbox Hybrid&quot;,&quot;Letterbox&quot;},5,4,3,0x000008),
-		new CTyp(CW_TYPE_EVENT,CW_TYPE_EVENT,'C',&quot;6&quot;,&quot;6&quot;,&quot;6&quot;,(byte) -122,'X',&quot;typeEvent.png&quot;,new String[] {&quot;Geocache|Event Cache&quot;,&quot;Geocache&quot;,&quot;Event Cache&quot;,&quot;Event&quot;},6,5,4,0x000010),
-		new CTyp(CW_TYPE_MEGA_EVENT,CW_TYPE_MEGA_EVENT,'C',&quot;453&quot;,&quot;453&quot;,&quot;&quot;,(byte) 101,'X',&quot;typeMegaevent.png&quot;,new String[] {&quot;Geocache|Mega-Event Cache&quot;,&quot;Geocache&quot;,&quot;Mega-Event Cache&quot;,&quot;Mega&quot;},14,6,9,0x000200),
-		new CTyp(CW_TYPE_WEBCAM,CW_TYPE_WEBCAM,'C',&quot;11&quot;,&quot;11&quot;,&quot;5&quot;,(byte) -117,'W',&quot;typeWebcam.png&quot;,new String[] {&quot;Geocache|Webcam Cache&quot;,&quot;Geocache&quot;,&quot;Webcam Cache&quot;,&quot;Webcam&quot;},11,7,5,0x000020),
-		new CTyp(CW_TYPE_UNKNOWN,CW_TYPE_UNKNOWN,'C',&quot;8&quot;,&quot;8&quot;,&quot;&quot;,(byte) -120,'U',&quot;typeUnknown.png&quot;,new String[] {&quot;Geocache|Unknown Cache&quot;,&quot;Geocache&quot;,&quot;Unknown Cache&quot;,&quot;Mystery&quot;},8,8,6,0x000040),
-		new CTyp(CW_TYPE_LOCATIONLESS,CW_TYPE_LOCATIONLESS,'C',&quot;12&quot;,&quot;12&quot;,&quot;&quot;,(byte) -116,'O',&quot;typeLocless.png&quot;,new String[] {&quot;Geocache|Locationless (Reverse) Cache&quot;,&quot;Geocache&quot;,&quot;Locationless (Reverse) Cache&quot;,&quot;Locationless&quot;},12,9,8,0x000080),
-		new CTyp(CW_TYPE_CITO,CW_TYPE_CITO,'C',&quot;13&quot;,&quot;13&quot;,&quot;&quot;,(byte) -115,'X',&quot;typeCito.png&quot;,new String[] {&quot;Geocache|Cache In Trash Out Event&quot;,&quot;Geocache&quot;,&quot;Cache In Trash Out Event&quot;,&quot;CITO&quot;},13,10,17,0x020000),
-		new CTyp(CW_TYPE_EARTH,CW_TYPE_EARTH,'C',&quot;137&quot;,&quot;137&quot;,&quot;&quot;,(byte) 9,'E',&quot;typeEarth.png&quot;,new String[] {&quot;Geocache|Earthcache&quot;,&quot;Geocache&quot;,&quot;Earthcache&quot;,&quot;Earth&quot;},18,11,7,0x000400),
-		new CTyp(CW_TYPE_WHEREIGO,CW_TYPE_WHEREIGO,'C',&quot;1858&quot;,&quot;1858&quot;,&quot;&quot;,(byte) 100,'G',&quot;typeWhereigo.png&quot;,new String[] {&quot;Geocache|Wherigo Cache&quot;,&quot;Geocache&quot;,&quot;Wherigo Cache&quot;,&quot;Wherigo&quot;},15,12,18,0x040000),
-		// additional waypoints
-		new CTyp(CW_TYPE_PARKING,CW_TYPE_PARKING,'A',&quot;50&quot;,&quot;&quot;,&quot;&quot;,(byte) -78,'P',&quot;typeParking.png&quot;,new String[] {&quot;Waypoint|Parking Area&quot;,&quot;Parking Area&quot;,&quot;Parking Area&quot;,&quot;&quot;},50,13,11,0x000800),
-		new CTyp(CW_TYPE_STAGE,CW_TYPE_STAGE,'A',&quot;51&quot;,&quot;&quot;,&quot;&quot;,(byte) -77,'S',&quot;typeStage.png&quot;,new String[] {&quot;Waypoint|Stages of a Multicache&quot;,&quot;Stages of a Multicache&quot;,&quot;Stages of a Multicache&quot;,&quot;&quot;},51,14,12,0x001000),
-		new CTyp(CW_TYPE_QUESTION,CW_TYPE_QUESTION,'A',&quot;52&quot;,&quot;&quot;,&quot;&quot;,(byte) -76,'Q',&quot;typeQuestion.png&quot;,new String[] {&quot;Waypoint|Question to Answer&quot;,&quot;Question to Answer&quot;,&quot;Question to Answer&quot;,&quot;&quot;},52,15,13,0x002000),
-		new CTyp(CW_TYPE_FINAL,CW_TYPE_FINAL,'A',&quot;53&quot;,&quot;&quot;,&quot;&quot;,(byte) -75,'F',&quot;typeFinal.png&quot;,new String[] {&quot;Waypoint|Final Location&quot;,&quot;Final Location&quot;,&quot;Final Location&quot;,&quot;&quot;},53,16,14,0x004000),
-		new CTyp(CW_TYPE_TRAILHEAD,CW_TYPE_TRAILHEAD,'A',&quot;54&quot;,&quot;&quot;,&quot;&quot;,(byte) -74,'H',&quot;typeTrailhead.png&quot;,new String[] {&quot;Waypoint|Trailhead&quot;,&quot;Trailhead&quot;,&quot;Trailhead&quot;,&quot;&quot;},54,17,15,0x008000),
-		new CTyp(CW_TYPE_REFERENCE,CW_TYPE_REFERENCE,'A',&quot;55&quot;,&quot;&quot;,&quot;&quot;,(byte) -73,'R',&quot;typeReference.png&quot;,new String[] {&quot;Waypoint|Reference Point&quot;,&quot;Reference Point&quot;,&quot;Reference Point&quot;,&quot;&quot;},55,18,16,0x010000),
-		// error on waypoint
-		new CTyp(CW_TYPE_ERROR,CW_TYPE_ERROR,'E',&quot;&quot;,&quot;&quot;,&quot;&quot;,(byte) -1,'-',&quot;guiError.png&quot;,new String[] {&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},49,-1,-1,0),
-        // mapped types (recognized on input from gpx or download-spider / or cw - version)                 
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 1,'C',&quot;&quot;,&quot;&quot;,&quot;1&quot;,(byte) -1,'U',&quot;&quot;,new String[] {&quot;Geocache|Other&quot;,&quot;Geocache&quot;,&quot;Other&quot;,&quot;Other&quot;},21,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 7,'C',&quot;7&quot;,&quot;&quot;,&quot;7&quot;,(byte) -121,'U',&quot;&quot;,new String[] {&quot;Geocache|Quiz&quot;,&quot;Geocache&quot;,&quot;Quiz&quot;,&quot;Quiz&quot;},7,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 9,'C',&quot;9&quot;,&quot;&quot;,&quot;9&quot;,(byte) -119,'U',&quot;&quot;,new String[] {&quot;Geocache|Moving&quot;,&quot;Geocache&quot;,&quot;Moving&quot;,&quot;Moving&quot;},9,-1,-1,0),
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 10,'C',&quot;10&quot;,&quot;&quot;,&quot;10&quot;,(byte) -118,'U',&quot;&quot;,new String[] {&quot;Geocache|DriveIn&quot;,&quot;Geocache&quot;,&quot;DriveIn&quot;,&quot;DriveIn&quot;},10,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 14,'C',&quot;&quot;,&quot;3653&quot;,&quot;&quot;,(byte) -1,'X',&quot;&quot;,new String[] {&quot;Geocache|Lost and Found Event Cache&quot;,&quot;Geocache&quot;,&quot;Lost and Found Event Cache&quot;,&quot;&quot;},6,-1,-1,0),		         
-		new CTyp(CW_TYPE_TRADITIONAL,(byte) 102,'C',&quot;&quot;,&quot;9&quot;,&quot;&quot;,(byte) -1,'T',&quot;&quot;,new String[] {&quot;Geocache|Project APE Cache&quot;,&quot;Geocache&quot;,&quot;Project APE Cache&quot;,&quot;APE&quot;},16,-1,-1,0),
-		new CTyp(CW_TYPE_EVENT,(byte) 103,'C',&quot;&quot;,&quot;1304&quot;,&quot;&quot;,(byte) -1,'X',&quot;&quot;,new String[] {&quot;Geocache|GPS Adventures Exhibit&quot;,&quot;Geocache&quot;,&quot;GPS Adventures Exhibit&quot;,&quot;MAZE&quot;},17,-1,-1,0),
-		new CTyp(CW_TYPE_UNKNOWN,(byte) 108,'C',&quot;&quot;,&quot;&quot;,&quot;8&quot;,(byte) -1,'U',&quot;&quot;,new String[] {&quot;only on OC download&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},19,-1,-1,0),
-		new CTyp(CW_TYPE_WHEREIGO,(byte) 15,'C',&quot;&quot;,&quot;&quot;,&quot;&quot;,(byte) -62,'G',&quot;&quot;,new String[] {&quot;Hack for V2 Typ&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},-1,-1,-1,0),
-	};
+			// custom waypoints
+			new CTyp(CW_TYPE_CUSTOM, CW_TYPE_CUSTOM, 'P', &quot;0&quot;, &quot;&quot;, &quot;&quot;, (byte) -128, 'C', &quot;typeCustom.png&quot;, new String[] { &quot;Geocache|Custom&quot;, &quot;Custom&quot;, &quot;Custom&quot;, &quot;&quot; }, 1, 0, 10, 0x000100),
+			// Cache waypoints
+			new CTyp(CW_TYPE_TRADITIONAL, CW_TYPE_TRADITIONAL, 'C', &quot;2&quot;, &quot;2&quot;, &quot;2&quot;, (byte) -126, 'T', &quot;typeTradi.png&quot;, new String[] { &quot;Geocache|Traditional Cache&quot;, &quot;Geocache&quot;, &quot;Traditional Cache&quot;, &quot;Traditional|Classic&quot; }, 2, 1, 0, 0x000001),
+			new CTyp(CW_TYPE_MULTI, CW_TYPE_MULTI, 'C', &quot;3&quot;, &quot;3&quot;, &quot;3&quot;, (byte) -125, 'M', &quot;typeMulti.png&quot;, new String[] { &quot;Geocache|Multi-cache&quot;, &quot;Geocache&quot;, &quot;Multi-cache&quot;, &quot;Multi|Offset&quot; }, 3, 2, 1, 0x000002),
+			new CTyp(CW_TYPE_VIRTUAL, CW_TYPE_VIRTUAL, 'C', &quot;4&quot;, &quot;4&quot;, &quot;4&quot;, (byte) -124, 'V', &quot;typeVirtual.png&quot;, new String[] { &quot;Geocache|Virtual Cache&quot;, &quot;Geocache&quot;, &quot;Virtual Cache&quot;, &quot;Virtual&quot; }, 4, 3, 2, 0x000004),
+			new CTyp(CW_TYPE_LETTERBOX, CW_TYPE_LETTERBOX, 'C', &quot;5&quot;, &quot;5&quot;, &quot;&quot;, (byte) -123, 'L', &quot;typeLetterbox.png&quot;, new String[] { &quot;Geocache|Letterbox Hybrid&quot;, &quot;Geocache&quot;, &quot;Letterbox Hybrid&quot;, &quot;Letterbox&quot; }, 5, 4, 3, 0x000008),
+			new CTyp(CW_TYPE_EVENT, CW_TYPE_EVENT, 'C', &quot;6&quot;, &quot;6&quot;, &quot;6&quot;, (byte) -122, 'X', &quot;typeEvent.png&quot;, new String[] { &quot;Geocache|Event Cache&quot;, &quot;Geocache&quot;, &quot;Event Cache&quot;, &quot;Event&quot; }, 6, 5, 4, 0x000010),
+			new CTyp(CW_TYPE_MEGA_EVENT, CW_TYPE_MEGA_EVENT, 'C', &quot;453&quot;, &quot;453&quot;, &quot;&quot;, (byte) 101, 'X', &quot;typeMegaevent.png&quot;, new String[] { &quot;Geocache|Mega-Event Cache&quot;, &quot;Geocache&quot;, &quot;Mega-Event Cache&quot;, &quot;Mega&quot; }, 14, 6, 9, 0x000200),
+			new CTyp(CW_TYPE_WEBCAM, CW_TYPE_WEBCAM, 'C', &quot;11&quot;, &quot;11&quot;, &quot;5&quot;, (byte) -117, 'W', &quot;typeWebcam.png&quot;, new String[] { &quot;Geocache|Webcam Cache&quot;, &quot;Geocache&quot;, &quot;Webcam Cache&quot;, &quot;Webcam&quot; }, 11, 7, 5, 0x000020),
+			new CTyp(CW_TYPE_UNKNOWN, CW_TYPE_UNKNOWN, 'C', &quot;8&quot;, &quot;8&quot;, &quot;&quot;, (byte) -120, 'U', &quot;typeUnknown.png&quot;, new String[] { &quot;Geocache|Unknown Cache&quot;, &quot;Geocache&quot;, &quot;Unknown Cache&quot;, &quot;Mystery&quot; }, 8, 8, 6, 0x000040),
+			new CTyp(CW_TYPE_LOCATIONLESS, CW_TYPE_LOCATIONLESS, 'C', &quot;12&quot;, &quot;12&quot;, &quot;&quot;, (byte) -116, 'O', &quot;typeLocless.png&quot;, new String[] { &quot;Geocache|Locationless (Reverse) Cache&quot;, &quot;Geocache&quot;, &quot;Locationless (Reverse) Cache&quot;, &quot;Locationless&quot; }, 12, 9, 8,
+					0x000080),
+			new CTyp(CW_TYPE_CITO, CW_TYPE_CITO, 'C', &quot;13&quot;, &quot;13&quot;, &quot;&quot;, (byte) -115, 'X', &quot;typeCito.png&quot;, new String[] { &quot;Geocache|Cache In Trash Out Event&quot;, &quot;Geocache&quot;, &quot;Cache In Trash Out Event&quot;, &quot;CITO&quot; }, 13, 10, 17, 0x020000),
+			new CTyp(CW_TYPE_EARTH, CW_TYPE_EARTH, 'C', &quot;137&quot;, &quot;137&quot;, &quot;&quot;, (byte) 9, 'E', &quot;typeEarth.png&quot;, new String[] { &quot;Geocache|Earthcache&quot;, &quot;Geocache&quot;, &quot;Earthcache&quot;, &quot;Earth&quot; }, 18, 11, 7, 0x000400),
+			new CTyp(CW_TYPE_WHEREIGO, CW_TYPE_WHEREIGO, 'C', &quot;1858&quot;, &quot;1858&quot;, &quot;&quot;, (byte) 100, 'G', &quot;typeWhereigo.png&quot;, new String[] { &quot;Geocache|Wherigo Cache&quot;, &quot;Geocache&quot;, &quot;Wherigo Cache&quot;, &quot;Wherigo&quot; }, 15, 12, 18, 0x040000),
+			// additional waypoints
+			new CTyp(CW_TYPE_PARKING, CW_TYPE_PARKING, 'A', &quot;50&quot;, &quot;&quot;, &quot;&quot;, (byte) -78, 'P', &quot;typeParking.png&quot;, new String[] { &quot;Waypoint|Parking Area&quot;, &quot;Parking Area&quot;, &quot;Parking Area&quot;, &quot;&quot; }, 50, 13, 11, 0x000800),
+			new CTyp(CW_TYPE_STAGE, CW_TYPE_STAGE, 'A', &quot;51&quot;, &quot;&quot;, &quot;&quot;, (byte) -77, 'S', &quot;typeStage.png&quot;, new String[] { &quot;Waypoint|Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;Stages of a Multicache&quot;, &quot;&quot; }, 51, 14, 12, 0x001000),
+			new CTyp(CW_TYPE_QUESTION, CW_TYPE_QUESTION, 'A', &quot;52&quot;, &quot;&quot;, &quot;&quot;, (byte) -76, 'Q', &quot;typeQuestion.png&quot;, new String[] { &quot;Waypoint|Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;Question to Answer&quot;, &quot;&quot; }, 52, 15, 13, 0x002000),
+			new CTyp(CW_TYPE_FINAL, CW_TYPE_FINAL, 'A', &quot;53&quot;, &quot;&quot;, &quot;&quot;, (byte) -75, 'F', &quot;typeFinal.png&quot;, new String[] { &quot;Waypoint|Final Location&quot;, &quot;Final Location&quot;, &quot;Final Location&quot;, &quot;&quot; }, 53, 16, 14, 0x004000),
+			new CTyp(CW_TYPE_TRAILHEAD, CW_TYPE_TRAILHEAD, 'A', &quot;54&quot;, &quot;&quot;, &quot;&quot;, (byte) -74, 'H', &quot;typeTrailhead.png&quot;, new String[] { &quot;Waypoint|Trailhead&quot;, &quot;Trailhead&quot;, &quot;Trailhead&quot;, &quot;&quot; }, 54, 17, 15, 0x008000),
+			new CTyp(CW_TYPE_REFERENCE, CW_TYPE_REFERENCE, 'A', &quot;55&quot;, &quot;&quot;, &quot;&quot;, (byte) -73, 'R', &quot;typeReference.png&quot;, new String[] { &quot;Waypoint|Reference Point&quot;, &quot;Reference Point&quot;, &quot;Reference Point&quot;, &quot;&quot; }, 55, 18, 16, 0x010000),
+			// error on waypoint
+			new CTyp(CW_TYPE_ERROR, CW_TYPE_ERROR, 'E', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -1, '-', &quot;guiError.png&quot;, new String[] { &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 49, -1, -1, 0),
+			// mapped types (recognized on input from gpx or download-spider / or cw - version)
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 1, 'C', &quot;&quot;, &quot;&quot;, &quot;1&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;Geocache|Other&quot;, &quot;Geocache&quot;, &quot;Other&quot;, &quot;Other&quot; }, 21, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 7, 'C', &quot;7&quot;, &quot;&quot;, &quot;7&quot;, (byte) -121, 'U', &quot;&quot;, new String[] { &quot;Geocache|Quiz&quot;, &quot;Geocache&quot;, &quot;Quiz&quot;, &quot;Quiz&quot; }, 7, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 9, 'C', &quot;9&quot;, &quot;&quot;, &quot;9&quot;, (byte) -119, 'U', &quot;&quot;, new String[] { &quot;Geocache|Moving&quot;, &quot;Geocache&quot;, &quot;Moving&quot;, &quot;Moving&quot; }, 9, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 10, 'C', &quot;10&quot;, &quot;&quot;, &quot;10&quot;, (byte) -118, 'U', &quot;&quot;, new String[] { &quot;Geocache|DriveIn&quot;, &quot;Geocache&quot;, &quot;DriveIn&quot;, &quot;DriveIn&quot; }, 10, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 14, 'C', &quot;&quot;, &quot;3653&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|Lost and Found Event Cache&quot;, &quot;Geocache&quot;, &quot;Lost and Found Event Cache&quot;, &quot;&quot; }, 6, -1, -1, 0),
+			new CTyp(CW_TYPE_TRADITIONAL, (byte) 102, 'C', &quot;&quot;, &quot;9&quot;, &quot;&quot;, (byte) -1, 'T', &quot;&quot;, new String[] { &quot;Geocache|Project APE Cache&quot;, &quot;Geocache&quot;, &quot;Project APE Cache&quot;, &quot;APE&quot; }, 16, -1, -1, 0),
+			new CTyp(CW_TYPE_EVENT, (byte) 103, 'C', &quot;&quot;, &quot;1304&quot;, &quot;&quot;, (byte) -1, 'X', &quot;&quot;, new String[] { &quot;Geocache|GPS Adventures Exhibit&quot;, &quot;Geocache&quot;, &quot;GPS Adventures Exhibit&quot;, &quot;MAZE&quot; }, 17, -1, -1, 0),
+			new CTyp(CW_TYPE_UNKNOWN, (byte) 108, 'C', &quot;&quot;, &quot;&quot;, &quot;8&quot;, (byte) -1, 'U', &quot;&quot;, new String[] { &quot;only on OC download&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, 19, -1, -1, 0),
+			new CTyp(CW_TYPE_WHEREIGO, (byte) 15, 'C', &quot;&quot;, &quot;&quot;, &quot;&quot;, (byte) -62, 'G', &quot;&quot;, new String[] { &quot;Hack for V2 Typ&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; }, -1, -1, -1, 0), };
 	// public static final int anzCacheTyps=cTypRef.length;
-	public static final byte maxCWCType=110;
-    static final byte[] Ref_Index = new byte[maxCWCType];
+	public static final byte maxCWCType = 110;
+	static final byte[] Ref_Index = new byte[maxCWCType];
 	static {
 		// +1 cause error is -1 and array starts at 0
-	  for (byte i = (byte) (cTypRef.length - 1); i&gt;=0; i--) {
-		  Ref_Index[1 + cTypRef[i]._cwCType]= i;
-	   }
+		for (byte i = (byte) (cTypRef.length - 1); i &gt;= 0; i--) {
+			Ref_Index[1 + cTypRef[i]._cwCType] = i;
+		}
 	}
+
 	public static byte Ref_Index(final byte type) {
-		byte ret=Ref_Index[cTypRef[Ref_Index[type+1]]._cwMappedCType + 1];
+		final byte ret = Ref_Index[cTypRef[Ref_Index[type + 1]]._cwMappedCType + 1];
 		return ret;
 	}
-	
-	
-	
+
 	/**
 	 * check if a given waypoint type is an additional waypoint
-	 * @param type waypoint type to check
+	 *
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an additional waypoint, false otherwise
 	 */
 	public static boolean isAddiWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'A';
 	}
+
 	/**
 	 * check if a given waypoint type is an cache waypoint
-	 * @param type waypoint type to check
+	 *
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Cache waypoint, false otherwise
 	 */
 	public static boolean isCacheWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'C';
 	}
+
 	/**
 	 * check if a given waypoint type is an Custom waypoint
-	 * @param type waypoint type to check
+	 *
+	 * @param type
+	 *            waypoint type to check
 	 * @return true if it is an Custom waypint, false otherwise
 	 */
 	public static boolean isCustomWpt(final byte type) {
 		return cTypRef[Ref_Index(type)]._cwCGroup == 'P';
 	}
-	
-	
+
 	// done for DetailsPanel.java and KML- and TomTom-Exporter
 	/**
 	 * create list of cache types to be shown in GUI drop down lists
+	 *
 	 * @return list of cache types to be shown in GUI drop down list
 	 * @see guiSelect2Cw
 	 * @see cw2GuiSelect
@@ -222,36 +237,47 @@
 		int j = 0;
 		for (int i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder &gt; j) {
-				j=cTypRef[i]._GUIOrder;
+				j = cTypRef[i]._GUIOrder;
 			}
 		}
-		String[] ret = new String[j+1];
+		final String[] ret = new String[j + 1];
 		for (int i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._GUIOrder &gt; -1) {
-				ret[cTypRef[i]._GUIOrder]=MyLocale.getMsg(cTypRef[i]._msgNrCTypeName,&quot;&quot;);
+				ret[cTypRef[i]._GUIOrder] = MyLocale.getMsg(cTypRef[i]._msgNrCTypeName, &quot;&quot;);
 			}
 		}
 		return ret;
 	}
+
 	/**
 	 * translate GUI drop down index selection back to internally stored type
-	 * @param selection index value from drop down list
+	 *
+	 * @param selection
+	 *            index value from drop down list
 	 * @return internal type
-	 * @throws IllegalArgumentException if &lt;code&gt;selection&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;selection&lt;/code&gt; can not be matched
 	 * @see guiTypeStrings
 	 * @see cw2GuiSelect
 	 */
 	public static byte guiSelect2Cw(final int selection) {
-		for (byte i=0; i&lt;cTypRef.length; i++) {
-			if (cTypRef[i]._GUIOrder == selection) {return cTypRef[i]._cwCType;};
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._GUIOrder == selection) {
+				return cTypRef[i]._cwCType;
+			}
+			;
 		}
 		return -1;
 	}
+
 	/**
 	 * translate cache type to position of index to highlight in GUI cache type drop down list
-	 * @param typeId internal id of cache type
+	 *
+	 * @param typeId
+	 *            internal id of cache type
 	 * @return index of the cache type in GUI list
-	 * @throws IllegalArgumentException if &lt;code&gt;id&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;id&lt;/code&gt; can not be matched
 	 * @see guiTypeStrings
 	 * @see guiSelect2Cw
 	 */
@@ -259,35 +285,46 @@
 		return cTypRef[Ref_Index(typeId)]._GUIOrder;
 	}
 
-	
-	
 	/**
 	 * convert the strings found in import of GPX from GC, OC or TC to internal cache type
-	 * @param gpxType type information found in GPX
+	 *
+	 * @param gpxType
+	 *            type information found in GPX
 	 * @return internal cache type
 	 */
 	public static byte gpxType2CwType(final String gpxType) throws IllegalArgumentException {
-		for (byte i=0; i&lt;cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptTypeTag.equals(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptTypeTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
-		for (byte i=0; i&lt;cTypRef.length; i++) {
-			if (cTypRef[i]._gpxWptGCextensionTypTag.equals(gpxType)) {return cTypRef[i]._cwMappedCType;};
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxWptGCextensionTypTag.equalsIgnoreCase(gpxType)) {
+				return cTypRef[i]._cwMappedCType;
+			}
+			;
 		}
-		for (byte i=0; i&lt;cTypRef.length; i++) {
-			if (cTypRef[i]._gpxAlternativeWptTypTags.indexOf(gpxType) != -1) {
+		final String lowerCaseGPXType = gpxType.toLowerCase();
+		for (byte i = 0; i &lt; cTypRef.length; i++) {
+			if (cTypRef[i]._gpxAlternativeWptTypTags.toLowerCase().indexOf(lowerCaseGPXType) != -1) {
 				return cTypRef[i]._cwMappedCType;
-			};
+			}
+			;
 		}
 		// TODO extend definition of _gpxAlternativeWptTypTags for all cases of Mystery
-		// old code was : if (!(gpxType.indexOf(&quot;Mystery&quot;)==-1)) return CW_TYPE_UNKNOWN; 
+		// old code was : if (!(gpxType.indexOf(&quot;Mystery&quot;)==-1)) return CW_TYPE_UNKNOWN;
 		return -1;
 	}
 
 	/**
 	 * convert the cache type information from an OC XML import to internal cache type
-	 * @param ocType cache type found in OC XML
+	 *
+	 * @param ocType
+	 *            cache type found in OC XML
 	 * @return internal cache type
-	 * @throws IllegalArgumentException if &lt;code&gt;ocType&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;ocType&lt;/code&gt; can not be matched
 	 */
 	public static byte ocType2CwType(final String ocType) {
 		for (int i = 0; i &lt; cTypRef.length; i++) {
@@ -297,11 +334,15 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert type information discovered by GC spider to internal type information
-	 * @param gcType type information from GC spider
+	 *
+	 * @param gcType
+	 *            type information from GC spider
 	 * @return internal representation of cache type
-	 * @throws IllegalArgumentException if &lt;code&gt;gcType&lt;/code&gt; can not be matched
+	 * @throws IllegalArgumentException
+	 *             if &lt;code&gt;gcType&lt;/code&gt; can not be matched
 	 */
 	public static byte gcSpider2CwType(final String gcType) {
 		for (int i = 0; i &lt; cTypRef.length; i++) {
@@ -311,9 +352,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version1 type information to current values
-	 * @param type version1 cache type information
+	 *
+	 * @param type
+	 *            version1 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v1 file version compatibility is abandoned
 	 */
@@ -325,9 +369,12 @@
 		}
 		return -1;
 	}
+
 	/**
 	 * convert version2 type information to current values
-	 * @param type version2 cache type information
+	 *
+	 * @param type
+	 *            version2 cache type information
 	 * @return current version cache type information or -1
 	 * @deprecated remove once v2 file version compatibility is abandoned
 	 */
@@ -340,121 +387,218 @@
 		return -1;
 	}
 
-	
-	
 	/**
 	 * translate cache type to a short version for compact exporters or &quot;smart&quot; cache names.
-	 * @param typeId CacheWolf internal type information
+	 *
+	 * @param typeId
+	 *            CacheWolf internal type information
 	 * @return abbreviation of cache type
 	 */
 	public static String getExportShortId(final byte typeId) {
-		return &quot;&quot;+cTypRef[Ref_Index(typeId)]._gpxShortCType;
+		return &quot;&quot; + cTypRef[Ref_Index(typeId)]._gpxShortCType;
 	}
+
 	/**
 	 * map cache types to images
-	 * @param typeId internal cache type id
+	 *
+	 * @param typeId
+	 *            internal cache type id
 	 * @return non qualified name of image
 	 */
 	public static String typeImageForId(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._imageName;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com &lt;type&gt; GPX format
 	 */
 	public static String type2TypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptTypeTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return symb information in GC.com &lt;sym&gt; GPX format
 	 */
 	public static String type2SymTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptSymTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return type information in GC.com &lt;groundspeak:type&gt; GPX format
 	 */
 	public static String type2GSTypeTag(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._gpxWptGCextensionTypTag;
 	}
+
 	/**
 	 * generate type description matching those of GC for GPX export
-	 * @param typeId internal type id
+	 *
+	 * @param typeId
+	 *            internal type id
 	 * @return Gui - string for type
 	 */
 	public static String type2Gui(final byte typeId) {
-		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName,&quot;&quot;);
+		return MyLocale.getMsg(cTypRef[Ref_Index(typeId)]._msgNrCTypeName, &quot;&quot;);
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 *
+	 * @param typeId
+	 *            internal cache type id
 	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
 	 */
 	public static Image getTypeImage(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
+	 *
+	 * @param typeId
+	 *            internal cache type id
 	 * @return &lt;code&gt;Image&lt;/code&gt; object to be displayed
 	 */
-	public static Image getMapImage(final byte typeId) {
-		return cTypRef[Ref_Index(typeId)]._mapImage;
+	public static Image getMapImage(CacheHolder ch) {
+		byte typeId = ch.getType();
+		Image im = cTypRef[Ref_Index(typeId)]._mapImage;
+		if (ch.is_found()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[found] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[found] = newOverlayedImage(im, GuiImageBroker.found);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[found];
+		} else if (ch.is_archived()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[archived] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[archived] = newOverlayedImage(im, GuiImageBroker.archived);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[archived];
+		} else if (!ch.is_available()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[disabled] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[disabled] = newOverlayedImage(im, GuiImageBroker.disabled);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[disabled];
+		} else if (ch.is_owned()) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[owned] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[owned] = newOverlayedImage(im, GuiImageBroker.owned);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[owned];
+		} else if (ch.getCacheStatus().startsWith(MyLocale.getMsg(362, &quot;solved&quot;))) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[solved] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[solved] = newOverlayedImage(im, GuiImageBroker.solved);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[solved];
+		} else if (ch.getCacheStatus().indexOf(MyLocale.getMsg(319, &quot;Not Found&quot;)) &gt; -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[dnf] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[dnf] = newOverlayedImage(im, GuiImageBroker.dnf);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[dnf];
+		} else if (ch.getCacheName().toLowerCase().indexOf(&quot;bonus&quot;) &gt; -1) {
+			if (cTypRef[Ref_Index(typeId)]._modImage[bonus] == null) {
+				cTypRef[Ref_Index(typeId)]._modImage[bonus] = newOverlayedImage(im, GuiImageBroker.bonus);
+			}
+			im = cTypRef[Ref_Index(typeId)]._modImage[bonus];
+		}
+		return im;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setTypeImage(final byte id, final Image iconImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage) 
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._iconImage.free();
-		cTypRef[Ref_Index(id)]._iconImage=iconImage;
+		cTypRef[Ref_Index(id)]._iconImage = iconImage;
 	}
+
 	/**
 	 * select image to be displayed for a given cache type
-	 * @param typeId internal cache type id
-	 * @param Image object to be displayed
+	 *
+	 * @param typeId
+	 *            internal cache type id
+	 * @param Image
+	 *            object to be displayed
 	 */
 	public static void setMapImage(final byte id, final Image mapImage) {
-		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage) 
+		if (cTypRef[Ref_Index(id)]._iconImage != cTypRef[Ref_Index(id)]._mapImage)
 			cTypRef[Ref_Index(id)]._mapImage.free();
-		cTypRef[Ref_Index(id)]._mapImage=mapImage;
+		cTypRef[Ref_Index(id)]._mapImage = mapImage;
 	}
-	
-	
+
 	// TODO do it better in Version 4
 	public static int getCacheTypePattern(final byte typeId) {
 		return cTypRef[Ref_Index(typeId)]._FilterPattern;
 	}
+
 	public static int Type_FilterString2Type_FilterPattern(final String Type_FilterString) {
 		int typeMatchPattern = 0;
 		for (int i = 0; i &lt; cTypRef.length; i++) {
 			if (cTypRef[i]._FilterStringPos &gt; -1) {
 				if (Type_FilterString.charAt(cTypRef[i]._FilterStringPos) == '1') {
-					typeMatchPattern|=cTypRef[i]._FilterPattern;
+					typeMatchPattern |= cTypRef[i]._FilterPattern;
 				}
 			}
 		}
 		return typeMatchPattern;
 	}
+
 	public static boolean hasTypeMatchPattern(final int typeMatchPattern) {
 		return typeMatchPattern != 0;
 	}
+
 	public static boolean hasMainTypeMatchPattern(final int typeMatchPattern) {
 		int TYPE_MAIN = 0;
 		for (int i = 0; i &lt; cTypRef.length; i++) {
-			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P' ) {
-				TYPE_MAIN|=cTypRef[i]._FilterPattern;
+			if (cTypRef[i]._cwCGroup == 'C' || cTypRef[i]._cwCGroup == 'P') {
+				TYPE_MAIN |= cTypRef[i]._FilterPattern;
 			}
 		}
 		return (typeMatchPattern &amp; TYPE_MAIN) != 0;
 	}
-	
+
+	private static Image newOverlayedImage(Image imsrc, Image imovl) {
+		// Overlay added at topleft
+		int srcWidth = imsrc.getWidth();
+		int srcHeight = imsrc.getHeight();
+		int ovlWidth = imovl.getWidth();
+		int ovlHeight = imovl.getHeight();
+		if (srcWidth &lt; ovlWidth || srcHeight &lt; ovlHeight)
+			return imsrc;
+		int[] srcPixels = imsrc.getPixels(null, 0, 0, 0, srcWidth, srcHeight, 0);
+		int[] ovlPixels = imovl.getPixels(null, 0, 0, 0, ovlWidth, ovlHeight, 0);
+		int offsrc;
+		int offovl = 0;
+		for (int y = 0; y &lt; ovlHeight; y++) { // top down
+			offsrc = y * srcWidth;
+			for (int x = 0; x &lt; ovlWidth; x++) {
+				int alphaval = (ovlPixels[offovl] &gt;&gt; 24) &amp; 0xff;
+				if (alphaval &gt; 0) {
+					srcPixels[offsrc] = ovlPixels[offovl];
+				}
+				offovl++;
+				offsrc++;
+			}
+		}
+		Image modImage = new Image(imsrc, 0);
+		modImage.setPixels(srcPixels, 0, 0, 0, srcWidth, srcHeight, 0);
+		return modImage;
+	}
+
 	// TODO it for OCXMLImporterScreen and FilterScreen ?
 }

Modified: branches/r1.2/src/CacheWolf/CalcPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/CalcPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CalcPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -45,10 +45,10 @@
 import ewe.ui.formatted.TextDisplay;
 
 /**
-*	Class to create the panel to do calculation with waypoints&lt;br&gt;
-*	Also allows for creation of a custom waypoint.&lt;br&gt;
-*	Class ID 1400
-*/
+ *	Class to create the panel to do calculation with waypoints&lt;br&gt;
+ *	Also allows for creation of a custom waypoint.&lt;br&gt;
+ *	Class ID 1400
+ */
 
 /**
  * Wrapper class to pass bearing and distance
@@ -57,7 +57,7 @@
 	public double degrees;
 	public double distance;
 
-	public BearingDistance(){
+	public BearingDistance() {
 		this.degrees = 0;
 		this.distance = 0;
 	}
@@ -95,18 +95,17 @@
 	int currFormat;
 	mButton btnChangeLatLon;
 
-	public CalcPanel()	{
+	public CalcPanel() {
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		cacheDB = profile.cacheDB;
 
+		TopP.addNext(chkDD = new mCheckBox(&quot;d.d&#176;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMM = new mCheckBox(&quot;d&#176;m.m\'&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkDMS = new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addNext(chkCustom = new mCheckBox(&quot;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		TopP.addNext(chkDD =new mCheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMM =new mCheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		TopP.addNext(chkDMS =new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		TopP.addNext(chkCustom =new mCheckBox(&quot;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-
 		chkDD.setGroup(chkFormat);
 		chkDMM.setGroup(chkFormat);
 		chkDMS.setGroup(chkFormat);
@@ -114,24 +113,25 @@
 		chkFormat.setInt(1);
 		currFormat = 1;
 		String[] ls = TransformCoordinates.getProjectedSystemNames();
-		TopP.addLast(localCooSystem = new mChoice(ls, 0),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		TopP.addLast(localCooSystem = new mChoice(ls, 0), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		btnChangeLatLon=new mButton();
-		TopP.addLast(btnChangeLatLon,CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//inpBearing and direction, unit for inpDistance
-		BottomP.addNext(new mLabel(MyLocale.getMsg(1403,&quot;Bearing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(new mLabel(MyLocale.getMsg(1404,&quot;Distance&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(inpBearing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		btnChangeLatLon = new mButton();
+		TopP.addLast(btnChangeLatLon, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpBearing and direction, unit for inpDistance
+		BottomP.addNext(new mLabel(MyLocale.getMsg(1403, &quot;Bearing&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(new mLabel(MyLocale.getMsg(1404, &quot;Distance&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(inpBearing = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpBearing.setText(&quot;0&quot;);
-		BottomP.addNext(inpDistance = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(inpDistance = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		inpDistance.setText(&quot;0&quot;);
 		// Check for narrow screen and reduce width of fields to avoid horizontal scroll panel
-		if (MyLocale.getScreenWidth()&lt;=240) {
+		if (MyLocale.getScreenWidth() &lt;= 240) {
 			FontMetrics fm = getFontMetrics(inpBearing.getFont());
-			inpBearing.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
-			inpDistance.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;),fm.getHeight()*4/3);
+			inpBearing.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;), fm.getHeight() * 4 / 3);
+			inpDistance.setPreferredSize(fm.getTextWidth(&quot;99999999&quot;), fm.getHeight() * 4 / 3);
 		}
-		BottomP.addLast(chcDistUnit = new mChoice(new String[]{&quot;m&quot;, &quot;km&quot;, MyLocale.getMsg(1407,&quot;steps&quot;), MyLocale.getMsg(1408,&quot;feet&quot;), MyLocale.getMsg(1409,&quot;yards&quot;), MyLocale.getMsg(1410,&quot;miles&quot;)},0),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.WEST)).setTag(CellConstants.INSETS,new ewe.fx.Insets(0,2,0,0));
+		BottomP.addLast(chcDistUnit = new mChoice(new String[] { &quot;m&quot;, &quot;km&quot;, MyLocale.getMsg(1407, &quot;steps&quot;), MyLocale.getMsg(1408, &quot;feet&quot;), MyLocale.getMsg(1409, &quot;yards&quot;), MyLocale.getMsg(1410, &quot;miles&quot;) }, 0), CellConstants.DONTSTRETCH,
+				(CellConstants.HFILL | CellConstants.WEST)).setTag(CellConstants.INSETS, new ewe.fx.Insets(0, 2, 0, 0));
 		if (Global.getPref().metricSystem == Metrics.METRIC) {
 			chcDistUnit.setInt(0); // Meter
 		} else {
@@ -139,19 +139,19 @@
 		}
 
 		// Buttons for calc and save
-		BottomP.addNext(btnCalc = new mButton(&quot;Calc&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnClear = new mButton(&quot;Clear&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addNext(btnGoto = new mButton(&quot;Goto&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		BottomP.addNext(btnCalc = new mButton(&quot;Calc&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnClear = new mButton(&quot;Clear&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addNext(btnGoto = new mButton(&quot;Goto&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		BottomP.addLast(btnSave = new mButton(MyLocale.getMsg(311, &quot;Create Waypoint&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
 		// Output
-		txtOutput = new TextDisplay(3,1); // Need to limit size for small screens
+		txtOutput = new TextDisplay(3, 1); // Need to limit size for small screens
 		ScrollBarPanel sbp = new MyScrollBarPanel(txtOutput);
-		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4,1)),CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+		BottomP.addLast(sbp.setTag(CellConstants.SPAN, new Dimension(4, 1)), CellConstants.STRETCH, (CellConstants.FILL | CellConstants.WEST));
 
-		//add Panels
-		this.addLast(TopP,CellConstants.HSTRETCH, CellConstants.WEST);//.setTag(SPAN,new Dimension(4,1));
-		this.addLast(BottomP,CellConstants.VSTRETCH, CellConstants.VFILL|CellConstants.WEST); //.setTag(SPAN,new Dimension(4,1));
+		// add Panels
+		this.addLast(TopP, CellConstants.HSTRETCH, CellConstants.WEST);// .setTag(SPAN,new Dimension(4,1));
+		this.addLast(BottomP, CellConstants.VSTRETCH, CellConstants.VFILL | CellConstants.WEST); // .setTag(SPAN,new Dimension(4,1));
 
 	}
 
@@ -159,13 +159,13 @@
 		return CoordsScreen.getLocalSystem(currFormat);
 	}
 
-	public final void readFields(CWPoint coords, BearingDistance degKm){
+	public final void readFields(CWPoint coords, BearingDistance degKm) {
 		// coords.set(btnChangeLatLon.getText());
 		currFormat = CoordsScreen.combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt());
 		degKm.degrees = Common.parseDouble(inpBearing.getText());
 
 		double rawDistance = Common.parseDouble(inpDistance.getText());
-		switch ( chcDistUnit.getInt() ) {
+		switch (chcDistUnit.getInt()) {
 		case 0:
 			// meter
 			degKm.distance = rawDistance / 1000.0;
@@ -199,88 +199,81 @@
 	}
 
 	// ch must not be null
-	public void setFields(CacheHolder ch){
-		if ( !ch.getWayPoint().equalsIgnoreCase(lastWaypoint) ) {
+	public void setFields(CacheHolder ch) {
+		if (!ch.getWayPoint().equalsIgnoreCase(lastWaypoint)) {
 			lastWaypoint = ch.getWayPoint();
-			if (ch.pos.isValid()) {
+			if (ch.getPos().isValid()) {
 				inpBearing.setText(&quot;0&quot;);
 				inpDistance.setText(&quot;0&quot;);
-
-				//currFormat = 1;
-				if (ch.getLatLon().length()== 0) coordInp.set(0,0);
-				else coordInp.set(ch.getLatLon(), TransformCoordinates.CW);
+				coordInp.set(ch.getPos());
 				setFields();
 			}
 		}
 	}
 
-
 	public void setFields() {
 		btnChangeLatLon.setText(coordInp.toString(getLocalCooSystem()));
-		//chkFormat.selectIndex(currFormat);
+		// chkFormat.selectIndex(currFormat);
 	}
 
+	public void onEvent(Event ev) {
 
-	public void onEvent(Event ev){
-
-
-
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == chkFormat
-					|| ((ev.type == ControlEvent.PRESSED) &amp;&amp; (ev.target == localCooSystem )) ) {
-				if (ev.target == localCooSystem) chkFormat.selectIndex(3);
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == chkFormat || ((ev.type == ControlEvent.PRESSED) &amp;&amp; (ev.target == localCooSystem))) {
+				if (ev.target == localCooSystem)
+					chkFormat.selectIndex(3);
 				readFields(coordInp, bd);
 				setFields();
 				this.repaintNow();
 			}
 
-			if (ev.target == btnCalc){
+			if (ev.target == btnCalc) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				txtOutput.appendText(coordOut.toString(getLocalCooSystem())+ &quot;\n&quot;,true);
+				txtOutput.appendText(coordOut.toString(getLocalCooSystem()) + &quot;\n&quot;, true);
 			}
-			if (ev.target == btnClear){
+			if (ev.target == btnClear) {
 				txtOutput.setText(&quot;&quot;);
 			}
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
-				ch.setLatLon(coordOut.toString());
-				ch.pos.set(coordOut);
+				ch.setPos(coordOut);
 				ch.setType(CacheType.CW_TYPE_STAGE); // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 
-			if (ev.target == btnGoto){
+			if (ev.target == btnGoto) {
 				readFields(coordInp, bd);
 				coordOut = coordInp.project(bd.degrees, bd.distance);
 				mainT.gotoP.setDestinationAndSwitch(coordOut);
 			}
-			
-			if (ev.target == btnChangeLatLon){
-				if(Vm.isMobile()){
+
+			if (ev.target == btnChangeLatLon) {
+				if (Vm.isMobile()) {
 					readFields(coordInp, bd);
 					InputScreen InScr = new InputScreen(getLocalCooSystem());
-					if (coordInp.isValid())	InScr.setCoords(coordInp);
-						else InScr.setCoords(new CWPoint(0,0));
-				if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
-				{
-					btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(InScr.getCoords());
+					if (coordInp.isValid())
+						InScr.setCoords(coordInp);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
+					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
+						btnChangeLatLon.setText(InScr.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(InScr.getCoords());
+					}
+				} else {
+					CoordsScreen cs = new CoordsScreen();
+					readFields(coordInp, bd);
+					cs.setFields(coordInp, getLocalCooSystem());
+					if (cs.execute() == FormBase.IDOK) {
+						btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
+						coordInp.set(cs.getCoords());
+					}
 				}
-			}else{
-				CoordsScreen cs = new CoordsScreen();
-				readFields(coordInp, bd);
-				cs.setFields(coordInp, getLocalCooSystem());
-				if (cs.execute()== FormBase.IDOK){
-					btnChangeLatLon.setText(cs.getCoords().toString(getLocalCooSystem()));
-					coordInp.set(cs.getCoords());
-				}
-			}
 
+			}
+			super.onEvent(ev);
 		}
-		super.onEvent(ev);
 	}
-	}
 }
\ No newline at end of file

Modified: branches/r1.2/src/CacheWolf/Common.java
===================================================================
--- branches/r1.2/src/CacheWolf/Common.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Common.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -185,7 +185,7 @@
 	}
 	
 	public static String fixSerialPortName(String name) {
-		if (name.startsWith(&quot;/&quot;)) return new String(&quot;..&quot;+name); // on linux (*nix) machines it is quite usual to give the complete file path to the serial port, but ewe expects only &quot;ttyS0&quot; or similar
+		if (name.startsWith(&quot;/&quot;)) return &quot;..&quot;+name; // on linux (*nix) machines it is quite usual to give the complete file path to the serial port, but ewe expects only &quot;ttyS0&quot; or similar
 		else                      return name;
 	}
 	

Modified: branches/r1.2/src/CacheWolf/CoordsScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/CoordsScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/CoordsScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.imp.SpiderGC;
@@ -50,11 +50,10 @@
 import ewe.ui.mLabel;
 
 /**
- *	Class for entering coordinates&lt;br&gt;
- *	Class IDs 1400 and 600 (same as calc panel and preferences screen)&lt;br&gt;
+ * Class for entering coordinates&lt;br&gt;
+ * Class IDs 1400 and 600 (same as calc panel and preferences screen)&lt;br&gt;
  */
 
-
 public class CoordsScreen extends Form {
 
 	mCheckBox chkDMM, chkDMS, chkDD, chkCustom;
@@ -70,138 +69,171 @@
 	CWPoint coordInp = new CWPoint();
 	CellPanel topLinePanel = new CellPanel();
 	CellPanel mainPanel = new CellPanel();
-	int exitKeys[]={75009};
+	int exitKeys[] = { 75009 };
 	int currFormat;
 
 	boolean bNSDeg = false;
 	boolean bNSm = false;
-	boolean	bNSs = false;
+	boolean bNSs = false;
 	boolean bEWDeg = false;
 	boolean bEWm = false;
 	boolean bEWs = false;
 	boolean bUTMNorthing = false;
 	boolean bUTMEasting = false;
-	
 
 	private boolean allowInvalid = false;
 
-	public CoordsScreen(boolean allowInvalidCoords)
-	{
+	public CoordsScreen(boolean allowInvalidCoords) {
 		allowInvalid = allowInvalidCoords;
 
-		InitCoordsScreen();		
+		InitCoordsScreen();
 	}
 
-	public CoordsScreen()
-	{
-		InitCoordsScreen();		
+	public CoordsScreen() {
+		InitCoordsScreen();
 	}
 
-	private void InitCoordsScreen()
-	{
+	private void InitCoordsScreen() {
 		this.setTitle(&quot;&quot;);
-		//Radiobuttons for format
-		topLinePanel.addNext(chkDD =new mCheckBox(&quot;d.d&#176;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMM =new mCheckBox(&quot;d&#176;m.m\'&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkDMS =new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;),CellConstants.DONTSTRETCH,CellConstants.WEST);
-		//topLinePanel.addNext(chkUTM =new mCheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
-		topLinePanel.addNext(chkCustom =new mCheckBox(&quot;&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		// Radiobuttons for format
+		topLinePanel.addNext(chkDD = new mCheckBox(&quot;d.d&#176;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMM = new mCheckBox(&quot;d&#176;m.m\'&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkDMS = new mCheckBox(&quot;d&#176;m\'s\&quot;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
+		// topLinePanel.addNext(chkUTM =new mCheckBox(&quot;UTM&quot;),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addNext(chkCustom = new mCheckBox(&quot;&quot;), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		String[] ls = TransformCoordinates.getProjectedSystemNames();
-		topLinePanel.addLast(localCooSystem = new mChoice(ls, 0),CellConstants.DONTSTRETCH, CellConstants.WEST);
+		topLinePanel.addLast(localCooSystem = new mChoice(ls, 0), CellConstants.DONTSTRETCH, CellConstants.WEST);
 
-		chkDD.setGroup(chkFormat); chkDD.exitKeys=exitKeys;
-		chkDMM.setGroup(chkFormat);chkDMM.exitKeys=exitKeys;
-		chkDMS.setGroup(chkFormat);chkDMS.exitKeys=exitKeys;
-		chkCustom.setGroup(chkFormat);chkCustom.exitKeys=exitKeys;
-		this.addLast(topLinePanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		chkDD.setGroup(chkFormat);
+		chkDD.exitKeys = exitKeys;
+		chkDMM.setGroup(chkFormat);
+		chkDMM.exitKeys = exitKeys;
+		chkDMS.setGroup(chkFormat);
+		chkDMS.exitKeys = exitKeys;
+		chkCustom.setGroup(chkFormat);
+		chkCustom.exitKeys = exitKeys;
+		this.addLast(topLinePanel, CellConstants.DONTSTRETCH, CellConstants.WEST);
 
 		// Input for degrees
-		mainPanel.addNext(chcNS = new mChoice(new String[]{&quot;N&quot;, &quot;S&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(chcNS = new mChoice(new String[] { &quot;N&quot;, &quot;S&quot; }, 0), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		chcNS.setInt(0);
-		mainPanel.addNext(inpNSDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpNSm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpNSs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpNSDeg = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpNSm = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(inpNSs = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
-		mainPanel.addNext(chcEW = new mChoice(new String[]{&quot;E&quot;, &quot;W&quot;},0),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(chcEW = new mChoice(new String[] { &quot;E&quot;, &quot;W&quot; }, 0), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		chcEW.setInt(0);
-		mainPanel.addNext(inpEWDeg = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpEWm = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(inpEWs = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		mainPanel.addNext(inpEWDeg = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpEWm = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(inpEWs = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 
 		// Input for UTM
-		if (allowInvalid){
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,&quot;Zone&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,&quot;Easting&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(btnClear = new mButton(MyLocale.getMsg(1413,&quot;Clear&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		if (allowInvalid) {
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400, &quot;Zone&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402, &quot;Easting&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401, &quot;Northing&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addLast(btnClear = new mButton(MyLocale.getMsg(1413, &quot;Clear&quot;)), CellConstants.HSTRETCH, (CellConstants.HFILL));
 		} else {
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400,&quot;Zone&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402,&quot;Easting&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401,&quot;Northing&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.SOUTHWEST));
-			mainPanel.addLast(btnSearch = new mButton(MyLocale.getMsg(1414,&quot;Search&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1400, &quot;Zone&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1402, &quot;Easting&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addNext(new mLabel(MyLocale.getMsg(1401, &quot;Northing&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.SOUTHWEST));
+			mainPanel.addLast(btnSearch = new mButton(MyLocale.getMsg(1414, &quot;Search&quot;)), CellConstants.HSTRETCH, (CellConstants.HFILL));
 		}
 
-		mainPanel.addNext(inpUTMZone = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMEasting = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addNext(inpUTMNorthing = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		mainPanel.addLast(btnGps = new mButton(&quot;GPS&quot;),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		mainPanel.addNext(inpUTMZone = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpUTMEasting = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addNext(inpUTMNorthing = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		mainPanel.addLast(btnGps = new mButton(&quot;GPS&quot;), CellConstants.HSTRETCH, (CellConstants.HFILL));
 
-		//	mainPanel.addLast(new mLabel(MyLocale.getMsg(1405,&quot;To load coordinates from GC, enter GCxxxxx below&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
+		// mainPanel.addLast(new mLabel(MyLocale.getMsg(1405,&quot;To load coordinates from GC, enter GCxxxxx below&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL)).setTag(SPAN,new Dimension(4,1));
 		// Input for free Text
-		mainPanel.addNext(inpText = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		inpText.toolTip=MyLocale.getMsg(1406,&quot;Enter coordinates in any format or GCxxxxx&quot;);
-		inpText.setTag(SPAN,new Dimension(3,1));
-		mainPanel.addLast(btnParse = new mButton(MyLocale.getMsg(619,&quot;Parse&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
+		mainPanel.addNext(inpText = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		inpText.toolTip = MyLocale.getMsg(1406, &quot;Enter coordinates in any format or GCxxxxx&quot;);
+		inpText.setTag(SPAN, new Dimension(3, 1));
+		mainPanel.addLast(btnParse = new mButton(MyLocale.getMsg(619, &quot;Parse&quot;)), CellConstants.HSTRETCH, (CellConstants.HFILL));
 
 		// Buttons for cancel and apply, copy and paste
-		btnCancel = new mButton(MyLocale.getMsg(614,&quot;Cancel&quot;));
+		btnCancel = new mButton(MyLocale.getMsg(614, &quot;Cancel&quot;));
 		btnCancel.setHotKey(0, IKeys.ESCAPE);
-		mainPanel.addNext(btnCancel,CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCancel.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnApply = new mButton(MyLocale.getMsg(615,&quot;Apply&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnApply.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addNext(btnPaste = new mButton(MyLocale.getMsg(617,&quot;Paste&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnParse.setTag(SPAN,new Dimension(4,1));
-		mainPanel.addLast(btnCopy = new mButton(MyLocale.getMsg(618,&quot;Copy&quot;)),CellConstants.HSTRETCH, (CellConstants.HFILL));
-		//btnCopy.setTag(SPAN,new Dimension(4,1));
-		chcNS.exitKeys=exitKeys; chcEW.exitKeys=exitKeys;
-		//add Panels
-		this.addLast(mainPanel,CellConstants.DONTSTRETCH, CellConstants.WEST);
+		mainPanel.addNext(btnCancel, CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnCancel.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnApply = new mButton(MyLocale.getMsg(615, &quot;Apply&quot;)), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnApply.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addNext(btnPaste = new mButton(MyLocale.getMsg(617, &quot;Paste&quot;)), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnParse.setTag(SPAN,new Dimension(4,1));
+		mainPanel.addLast(btnCopy = new mButton(MyLocale.getMsg(618, &quot;Copy&quot;)), CellConstants.HSTRETCH, (CellConstants.HFILL));
+		// btnCopy.setTag(SPAN,new Dimension(4,1));
+		chcNS.exitKeys = exitKeys;
+		chcEW.exitKeys = exitKeys;
+		// add Panels
+		this.addLast(mainPanel, CellConstants.DONTSTRETCH, CellConstants.WEST);
 		chcNS.takeFocus(ControlConstants.ByKeyboard);
-		
-		
+
 	}
 
-	public void activateFields(int format){
-		//inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
+	public void activateFields(int format) {
+		// inpEWDeg.wantReturn=false; inpEWm.wantReturn=false; inpEWs.wantReturn=false; inpUTMNorthing.wantReturn=false;
 
-		switch (format){
+		switch (format) {
 		case TransformCoordinates.DD:
-			enable(chcNS); enable(inpNSDeg); disable(inpNSm); disable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); disable(inpEWm); disable(inpEWs);
-			//inpEWDeg.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+			enable(chcNS);
+			enable(inpNSDeg);
+			disable(inpNSm);
+			disable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			disable(inpEWm);
+			disable(inpEWs);
+			// inpEWDeg.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		case TransformCoordinates.DMM: 	
-			enable(chcNS); enable(inpNSDeg); enable(inpNSm); disable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); enable(inpEWm); disable(inpEWs);
-			//inpEWm.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+		case TransformCoordinates.DMM:
+			enable(chcNS);
+			enable(inpNSDeg);
+			enable(inpNSm);
+			disable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			enable(inpEWm);
+			disable(inpEWs);
+			// inpEWm.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		case TransformCoordinates.DMS: 	
-			enable(chcNS); enable(inpNSDeg); enable(inpNSm); enable(inpNSs);
-			enable(chcEW); enable(inpEWDeg); enable(inpEWm); enable(inpEWs);
-			//inpEWs.wantReturn=true;
-			disable(inpUTMZone); disable(inpUTMNorthing); disable(inpUTMEasting);
+		case TransformCoordinates.DMS:
+			enable(chcNS);
+			enable(inpNSDeg);
+			enable(inpNSm);
+			enable(inpNSs);
+			enable(chcEW);
+			enable(inpEWDeg);
+			enable(inpEWm);
+			enable(inpEWs);
+			// inpEWs.wantReturn=true;
+			disable(inpUTMZone);
+			disable(inpUTMNorthing);
+			disable(inpUTMEasting);
 			break;
-		default: 	
-			disable(chcNS); disable(inpNSDeg); disable(inpNSm); disable(inpNSs);
-			disable(chcEW); disable(inpEWDeg); disable(inpEWm); disable(inpEWs);
-			if (TransformCoordinates.localSystems[localCooSystem.getInt()].zoneSeperatly) enable(inpUTMZone);
-			else disable(inpUTMZone); 
-			enable(inpUTMNorthing); enable(inpUTMEasting);
-			//inpUTMNorthing.wantReturn=true;
+		default:
+			disable(chcNS);
+			disable(inpNSDeg);
+			disable(inpNSm);
+			disable(inpNSs);
+			disable(chcEW);
+			disable(inpEWDeg);
+			disable(inpEWm);
+			disable(inpEWs);
+			if (TransformCoordinates.localSystems[localCooSystem.getInt()].zoneSeperatly)
+				enable(inpUTMZone);
+			else
+				disable(inpUTMZone);
+			enable(inpUTMNorthing);
+			enable(inpUTMEasting);
+			// inpUTMNorthing.wantReturn=true;
 			break;
 		}
 
@@ -210,54 +242,57 @@
 		this.repaintNow();
 	}
 
-	private void enable(Control c) {c.modify(ControlConstants.TakesKeyFocus,ControlConstants.Disabled); }
-	private void disable(Control c) {c.modify(ControlConstants.Disabled,ControlConstants.TakesKeyFocus); }
+	private void enable(Control c) {
+		c.modify(ControlConstants.TakesKeyFocus, ControlConstants.Disabled);
+	}
 
-	public void readFields(CWPoint coords){
+	private void disable(Control c) {
+		c.modify(ControlConstants.Disabled, ControlConstants.TakesKeyFocus);
+	}
+
+	public void readFields(CWPoint coords) {
 		String NS, EW;
 		if (localSystemToformatSel(currFormat) &gt;= formatSelToLocalSystem.length) {
 			if (TransformCoordinates.getLocalSystem(currFormat).zoneSeperatly)
-				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), inpUTMZone.getText(), currFormat); 
+				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), inpUTMZone.getText(), currFormat);
 			else
-				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), currFormat);			
+				coords.set(inpUTMNorthing.getText(), inpUTMEasting.getText(), currFormat);
+		} else {
+			NS = chcNS.getInt() == 0 ? &quot;N&quot; : &quot;S&quot;;
+			EW = chcEW.getInt() == 0 ? &quot;E&quot; : &quot;W&quot;;
+			coords.set(NS, inpNSDeg.getText(), inpNSm.getText(), inpNSs.getText(), EW, inpEWDeg.getText(), inpEWm.getText(), inpEWs.getText(), currFormat);
 		}
-		else {
-			NS = chcNS.getInt()== 0?&quot;N&quot;:&quot;S&quot;;
-			EW = chcEW.getInt()== 0?&quot;E&quot;:&quot;W&quot;;
-			coords.set(NS, inpNSDeg.getText(), inpNSm.getText(), inpNSs.getText(),
-					EW, inpEWDeg.getText(), inpEWm.getText(), inpEWs.getText(),
-					currFormat);
-		}
 		int formatsel = combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt());
 		currFormat = getLocalSystem(formatsel);
 		return;
 	}
+
 	public void setFields(CWPoint coords, int format) {
-		int formatsel = localSystemToformatSel(format); 
-		if ( formatsel &gt;= formatSelToLocalSystem.length){ // projected point = neither dd, dd&#176; mm.mm nor dd&#176; mm' ss.s&quot;
-			if (coords.isValid()){
+		int formatsel = localSystemToformatSel(format);
+		if (formatsel &gt;= formatSelToLocalSystem.length) { // projected point = neither dd, dd&#176; mm.mm nor dd&#176; mm' ss.s&quot;
+			if (coords.isValid()) {
 				localCooSystem.setInt(formatsel - formatSelToLocalSystem.length);
 				ProjectedPoint pp = TransformCoordinates.wgs84ToLocalsystem(coords, format);
 				inpText.setText(pp.toHumanReadableString());
-				inpUTMNorthing.setText(Common.DoubleToString(pp.getNorthing(),0,0));
-				inpUTMEasting.setText(Common.DoubleToString(pp.getEasting(),0,0));
-				if (TransformCoordinates.getLocalSystem(format).zoneSeperatly) inpUTMZone.setText(pp.getZoneString()); 
-				else inpUTMZone.setText(&quot;&quot;);
-			}
-			else {
+				inpUTMNorthing.setText(Common.DoubleToString(pp.getNorthing(), 0, 0));
+				inpUTMEasting.setText(Common.DoubleToString(pp.getEasting(), 0, 0));
+				if (TransformCoordinates.getLocalSystem(format).zoneSeperatly)
+					inpUTMZone.setText(pp.getZoneString());
+				else
+					inpUTMZone.setText(&quot;&quot;);
+			} else {
 				inpUTMNorthing.setText(&quot;0&quot;);
 				inpUTMEasting.setText(&quot;0&quot;);
 			}
-		}
-		else {
-			chcNS.setInt(coords.getNSLetter().equals(&quot;N&quot;)?0:1);
-			chcEW.setInt(coords.getEWLetter().equals(&quot;E&quot;)?0:1);
+		} else {
+			chcNS.setInt(coords.getNSLetter().equals(&quot;N&quot;) ? 0 : 1);
+			chcEW.setInt(coords.getEWLetter().equals(&quot;E&quot;) ? 0 : 1);
 
-			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format),&quot;-&quot;,&quot;&quot;));
+			inpNSDeg.setText(STRreplace.replace(coords.getLatDeg(format), &quot;-&quot;, &quot;&quot;));
 			inpNSm.setText(coords.getLatMin(format));
 			inpNSs.setText(coords.getLatSec(format));
 
-			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format),&quot;-&quot;,&quot;&quot;));
+			inpEWDeg.setText(STRreplace.replace(coords.getLonDeg(format), &quot;-&quot;, &quot;&quot;));
 			inpEWm.setText(coords.getLonMin(format));
 			inpEWs.setText(coords.getLonSec(format));
 		}
@@ -267,140 +302,139 @@
 		activateFields(format);
 	}
 
-	public CWPoint getCoords(){
+	public CWPoint getCoords() {
 		return coordInp;
 	}
 
+	public void onEvent(Event ev) {
 
-	
-	public void onEvent(Event ev){
-
 		// Ensure that the Enter key moves to the appropriate field
 		// for Checkboxes and Choice controls this is done via the exitKeys
 		// For input fields we use the wantReturn field
 
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED){
-			if (((ControlEvent)ev).target==chkDD || ((ControlEvent)ev).target==chkDMM ||
-					((ControlEvent)ev).target==chkDMS) Gui.takeFocus(chcNS,ControlConstants.ByKeyboard);	
-			if (((ControlEvent)ev).target==chkCustom) Gui.takeFocus(inpUTMEasting,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcNS) Gui.takeFocus(inpNSDeg,ControlConstants.ByKeyboard);
-			if (((ControlEvent)ev).target==chcEW) Gui.takeFocus(inpEWDeg,ControlConstants.ByKeyboard);
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED) {
+			if (((ControlEvent) ev).target == chkDD || ((ControlEvent) ev).target == chkDMM || ((ControlEvent) ev).target == chkDMS)
+				Gui.takeFocus(chcNS, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chkCustom)
+				Gui.takeFocus(inpUTMEasting, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chcNS)
+				Gui.takeFocus(inpNSDeg, ControlConstants.ByKeyboard);
+			if (((ControlEvent) ev).target == chcEW)
+				Gui.takeFocus(inpEWDeg, ControlConstants.ByKeyboard);
 		}
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (((ControlEvent)ev).target==inpEWDeg || ((ControlEvent)ev).target==inpEWm ||
-					((ControlEvent)ev).target==inpEWs || ((ControlEvent)ev).target==inpUTMNorthing) Gui.takeFocus(btnApply,ControlConstants.ByKeyboard);	
-			
-			
-			if (ev.target == chkFormat || ev.target == localCooSystem){
-				if (ev.target == localCooSystem) chkFormat.selectIndex(3);
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (((ControlEvent) ev).target == inpEWDeg || ((ControlEvent) ev).target == inpEWm || ((ControlEvent) ev).target == inpEWs || ((ControlEvent) ev).target == inpUTMNorthing)
+				Gui.takeFocus(btnApply, ControlConstants.ByKeyboard);
+
+			if (ev.target == chkFormat || ev.target == localCooSystem) {
+				if (ev.target == localCooSystem)
+					chkFormat.selectIndex(3);
 				readFields(coordInp);
 				setFields(coordInp, currFormat);
 				this.repaintNow();
 			}
 
-			if (ev.target == btnCancel){
+			if (ev.target == btnCancel) {
 				this.close(IDCANCEL);
 			}
 
-			if (ev.target == btnApply){
+			if (ev.target == btnApply) {
 				currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
 				readFields(coordInp);
-				if (coordInp.isValid()) this.close(IDOK);
+				if (coordInp.isValid())
+					this.close(IDOK);
 				else {
-					if	( allowInvalid ) {
-						if ((new MessageBox(MyLocale.getMsg(144,&quot;Warnung&quot;),MyLocale.getMsg(1412,&quot;Coordinates invalid. Apply anyway?&quot;),FormBase.DEFOKB|FormBase.NOB)).execute() == FormBase.IDOK ) {
-							this.close(IDOK);						
+					if (allowInvalid) {
+						if ((new MessageBox(MyLocale.getMsg(144, &quot;Warnung&quot;), MyLocale.getMsg(1412, &quot;Coordinates invalid. Apply anyway?&quot;), FormBase.DEFOKB | FormBase.NOB)).execute() == FormBase.IDOK) {
+							this.close(IDOK);
 						}
 					} else {
-						(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1411,&quot;Please enter valid coordinates&quot;), FormBase.OKB)).execute();						
+						(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1411, &quot;Please enter valid coordinates&quot;), FormBase.OKB)).execute();
 					}
 				}
 			}
 
-			if (ev.target == btnPaste){
+			if (ev.target == btnPaste) {
 				inpText.setText(Vm.getClipboardText(&quot;&quot;));
 			}
 
-			if (ev.target == btnCopy){
+			if (ev.target == btnCopy) {
 				readFields(coordInp); // TODO was anderes als Gau&#223;-Kr&#252;ger unterst&#252;tzen
 				Vm.setClipboardText(coordInp.toString(currFormat));
 			}
 
-			if (ev.target == btnParse){
+			if (ev.target == btnParse) {
 				// try to parse coords
 				CWPoint coord;
-				String inp=inpText.getText().trim().toUpperCase();
+				String inp = inpText.getText().trim().toUpperCase();
 				if (inp.startsWith(&quot;GC&quot;)) {
-					SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile(), false);
+					SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
 					coord = new CWPoint(spider.getCacheCoordinates(inp));
-				} else {	
+					Global.getPref().setOldGCLanguage();
+				} else {
 					coord = new CWPoint(inp);
 				}
-				if (!coord.isValid()){
-					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
+				if (!coord.isValid()) {
+					MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(4111, &quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
 					tmpMB.exec();
-				}else {
-					currFormat =  getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(coord,currFormat);
+				} else {
+					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
+					setFields(coord, currFormat);
 					this.repaintNow();
 				}
 			}
 
-			if (ev.target == btnGps){
-				Navigate nav=Global.mainTab.nav;
-				if (nav.gpsPos.isValid()){
+			if (ev.target == btnGps) {
+				Navigate nav = Global.mainTab.nav;
+				if (nav.gpsPos.isValid()) {
 					CWPoint coord = nav.gpsPos;
 					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(coord,currFormat);
+					setFields(coord, currFormat);
 				}
 			}
 
-			if (ev.target == btnClear){
-				CWPoint coord = new CWPoint(91,361);
+			if (ev.target == btnClear) {
+				CWPoint coord = new CWPoint(91, 361);
 				currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-				setFields(coord,currFormat);
+				setFields(coord, currFormat);
 			}
-			
+
 			if (ev.target == btnSearch) {
-				GeoCodeGui s = new GeoCodeGui(); 
+				GeoCodeGui s = new GeoCodeGui();
 				int ok = s.execute();
 				if (ok == FormBase.IDOK) {
 					currFormat = getLocalSystem(combineToFormatSel(chkFormat.getSelectedIndex(), localCooSystem.getInt()));
-					setFields(s.coordInp,currFormat);
+					setFields(s.coordInp, currFormat);
 				}
 			}
 		}
 		super.onEvent(ev);
 	}
-	
 
-	private static final int[] formatSelToLocalSystem = {
-		TransformCoordinates.DD,
-		TransformCoordinates.DMM,
-		TransformCoordinates.DMS,
-	};
+	private static final int[] formatSelToLocalSystem = { TransformCoordinates.DD, TransformCoordinates.DMM, TransformCoordinates.DMS, };
 
 	public int localSystemToformatSel(int cwpointformat) {
-		for (int i=0; i &lt; formatSelToLocalSystem.length; i++) 
-			if (formatSelToLocalSystem[i] == cwpointformat) return i;
-		for (int i=0; i &lt; TransformCoordinates.localSystems.length; i++) 
-			if (TransformCoordinates.localSystems[i].code == cwpointformat) return i + formatSelToLocalSystem.length;
-		
+		for (int i = 0; i &lt; formatSelToLocalSystem.length; i++)
+			if (formatSelToLocalSystem[i] == cwpointformat)
+				return i;
+		for (int i = 0; i &lt; TransformCoordinates.localSystems.length; i++)
+			if (TransformCoordinates.localSystems[i].code == cwpointformat)
+				return i + formatSelToLocalSystem.length;
+
 		throw new IllegalArgumentException(&quot;CoordScreen.CWPointformatToformatSel: cwpointformat &quot; + cwpointformat + &quot;not supported&quot;);
 	}
 
 	public static final int getLocalSystem(int formatsel) { // be carefull: this method is also used by CalcPanel
-		if (formatsel &lt; formatSelToLocalSystem.length) return formatSelToLocalSystem[formatsel];
+		if (formatsel &lt; formatSelToLocalSystem.length)
+			return formatSelToLocalSystem[formatsel];
 		return TransformCoordinates.localSystems[formatsel - formatSelToLocalSystem.length].code;
 	}
-	
+
 	public static final int combineToFormatSel(int radiobuttonindex, int choiceindex) {
 		int ret = radiobuttonindex;
-		if (ret == formatSelToLocalSystem.length) ret += choiceindex;
+		if (ret == formatSelToLocalSystem.length)
+			ret += choiceindex;
 		return ret;
 	}
 
 }
-
-
-

Modified: branches/r1.2/src/CacheWolf/DBStats.java
===================================================================
--- branches/r1.2/src/CacheWolf/DBStats.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DBStats.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,115 +1,118 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
  * @author Marc
- * Use this class to obtain statistics or information on a cache database.
+ *         Use this class to obtain statistics or information on a cache database.
  */
 public class DBStats {
 	CacheDB cacheDB = null;
-	
-	public DBStats(CacheDB db){
+
+	public DBStats(CacheDB db) {
 		cacheDB = db;
 	}
-	
+
 	/**
 	 * Method to get the number of caches displayed in the list.
 	 * It will count waypoints only that start with
 	 * GC,or
 	 * OC
+	 * 
 	 * @return
 	 */
-	public String visible(boolean big){
+	public String visible(boolean big) {
 		CacheHolder holder;
 		int counter = 0;
 		int whiteCaches = 0;
 		int whiteWaypoints = 0;
-		for(int i = 0; i&lt;cacheDB.size();i++){
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			holder = cacheDB.get(i);
-			if(holder.isVisible()){
+			if (holder.isVisible()) {
 				counter++;
 				if (CacheType.isAddiWpt(holder.getType())) {
 					whiteWaypoints++;
+				} else {
+					whiteCaches++;
 				}
-				else {				
-					whiteCaches++;
-				}		
 			}
 		}
 		if (big)
-			return counter+&quot;(&quot;+whiteCaches+&quot;/&quot;+whiteWaypoints+&quot;)&quot;;
+			return counter + &quot;(&quot; + whiteCaches + &quot;/&quot; + whiteWaypoints + &quot;)&quot;;
 		else
-			return &quot;&quot;+whiteCaches;
-		
+			return &quot;&quot; + whiteCaches;
+
 	}
-	
+
 	/**
 	 * Method to get the number of caches available for display
+	 * 
 	 * @return
 	 */
-	public String total(boolean big){
+	public String total(boolean big) {
 		CacheHolder holder;
 		int all = cacheDB.size();
 		int whiteCaches = 0;
 		int whiteWaypoints = 0;
 		int blackCaches = 0;
 		int blackWaypoints = 0;
-		for(int i = 0; i&lt;all;i++){
+		for (int i = 0; i &lt; all; i++) {
 			holder = cacheDB.get(i);
-			if(holder.is_black()){
-			  if (CacheType.isAddiWpt(holder.getType())) {
-				  blackWaypoints++;  
-			  }
-			  else {
-				  blackCaches++;
-			  }
-			}
-			else {
+			if (holder.is_black()) {
 				if (CacheType.isAddiWpt(holder.getType())) {
+					blackWaypoints++;
+				} else {
+					blackCaches++;
+				}
+			} else {
+				if (CacheType.isAddiWpt(holder.getType())) {
 					whiteWaypoints++;
+				} else {
+					whiteCaches++;
 				}
-				else {				
-					whiteCaches++;
-				}		
 			}
 		}
-		if (big)
-			return all+&quot;(&quot;+whiteCaches+&quot;/&quot;+whiteWaypoints+&quot;+&quot;+blackCaches+&quot;/&quot;+blackWaypoints+&quot;)&quot;;
-		else
-			return &quot;&quot;+whiteCaches;
+		if (big) {
+			if (blackCaches &gt; 0 || blackWaypoints &gt; 0) {
+				return all + &quot;(&quot; + whiteCaches + &quot;/&quot; + whiteWaypoints + &quot;+&quot; + blackCaches + &quot;/&quot; + blackWaypoints + &quot;)&quot;;
+			} else {
+				return all + &quot;(&quot; + whiteCaches + &quot;/&quot; + whiteWaypoints + &quot;)&quot;;
+			}
+		} else
+			return &quot;&quot; + whiteCaches;
 	}
-	
-	public int totalFound(){
+
+	public int totalFound() {
 		CacheHolder holder;
 		int counter = 0;
-		for(int i = 0; i&lt;cacheDB.size();i++){
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			holder = cacheDB.get(i);
-			if(holder.is_found() == true) {
-				if(holder.getWayPoint().startsWith(&quot;GC&quot;) || holder.isOC()) counter++;
+			if (holder.is_found() == true) {
+				if (holder.isCacheWpt())
+					counter++;
 			}
 		}
 		return counter;

Modified: branches/r1.2/src/CacheWolf/DataMover.java
===================================================================
--- branches/r1.2/src/CacheWolf/DataMover.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DataMover.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -281,10 +281,11 @@
 		if (wpt.length() == 0){
 			return;
 		}
+
 		// delete files in dstDir to clean up trash
-		// String tmp[] = new FileBugfix(dir).list(wpt + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+		wpt=wpt.toLowerCase();
 		for (int i=0; i &lt; tmp.length;i++){
-			if (tmp[i].substring(0, java.lang.Math.min(tmp[i].length(),wpt.length())).equalsIgnoreCase(wpt)) {
+			if (tmp[i].toLowerCase().startsWith(wpt+'.') || tmp[i].toLowerCase().startsWith(wpt+'_')){
 				File tmpFile = new File(dir + tmp[i]);
 				tmpFile.delete();
 			}
@@ -295,9 +296,9 @@
 		if (wpt.length() == 0){
 			return;
 		}
-		// String srcFiles[] = new FileBugfix(srcDir).list(wpt + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+		wpt=wpt.toLowerCase();
 		for (int i=0; i &lt; srcFiles.length;i++){
-			if (srcFiles[i].substring(0, java.lang.Math.min(srcFiles[i].length(),wpt.length())).equalsIgnoreCase(wpt)) {
+			if (srcFiles[i].toLowerCase().startsWith(wpt+'.') || srcFiles[i].toLowerCase().startsWith(wpt+'_')){
 				File srcFile = new File(srcDir + srcFiles[i]);
 				File dstFile = new File(dstDir + srcFiles[i]);
 				srcFile.move(dstFile);
@@ -309,9 +310,9 @@
 		if (wpt.length() == 0){
 			return;
 		}
-		// String srcFiles[] = new FileBugfix(srcDir).list(wpt + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+		wpt=wpt.toLowerCase();
 		for (int i=0; i &lt; srcFiles.length;i++){
-			if (srcFiles[i].substring(0, java.lang.Math.min(srcFiles[i].length(),wpt.length())).equalsIgnoreCase(wpt)) {
+			if (srcFiles[i].toLowerCase().startsWith(wpt+'.') || srcFiles[i].toLowerCase().startsWith(wpt+'_')){
 				copy(srcDir + srcFiles[i],dstDir + srcFiles[i]);
 			}
 		}
@@ -439,6 +440,7 @@
 			 destFileList= destPath.list(null,FileBase.LIST_FILES_ONLY|FileBase.LIST_DONT_SORT);
 			 pbf.exit(0);
 		 }
+		 
 		 public void doIt(int i,CacheHolder srcHolder) {
 			 srcDB.removeElementAt(i);
 			 deleteCacheFiles(srcHolder.getWayPoint(),dstProfile.dataDir, destFileList);

Modified: branches/r1.2/src/CacheWolf/DateFormat.java
===================================================================
--- branches/r1.2/src/CacheWolf/DateFormat.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DateFormat.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /* Several date formats are used by GC.COM
@@ -33,75 +33,136 @@
  *    2004-02-27    - YYYY-MM-DD   
  */
 
-import ewe.sys.Convert;
 import ewe.sys.Time;
+import ewe.util.mString;
 
 public class DateFormat {
 
+	public static String GCDateFormat = &quot;&quot;;
+
 	/** Convert the US Format into a sortable format */
-	public static String MDY2YMD(String date) {
-		// Dates are in format M/D/Y
-		int p1, p2 = -1, p3;
-		p1 = date.indexOf(&quot;/&quot;);
-		if (p1==-1){
-			//dayofweek, dayofmonth month year (Monday, 07 June 2010)
-			p1 = date.indexOf(&quot;,&quot;);			
-			p2 = date.indexOf(&quot; &quot;, p1 + 2);
-			p3 = date.indexOf(&quot; &quot;, p2 + 1);
-			final String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;,
-					&quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;,
-					&quot;December&quot; };
-			for (int m = 0; m &lt; 12; m++) {
-				if (monthNames[m].equals(date.substring(p2+1,p3))) {
-					String mm = Integer.toString(m+1);
-					if (mm.length()==1) {mm=0+mm;}
-					return date.substring(p3+1,p3+5) + &quot;-&quot; + mm + &quot;-&quot; + date.substring(p1+2, p1+4);
+	public static String toYYMMDD(String date) {
+		return toYYMMDD(toDate(date));
+	}
+
+	public static Time toDate(String ds) {
+		if (ds == null || ds.equals(&quot;&quot;) || ds.indexOf(&quot;1900&quot;) &gt; -1)
+			return new Time(1, 1, 1900);
+		final long adaylong = new Time(2, 1, 2000).getTime() - new Time(1, 1, 2000).getTime();
+		Time d = new Time();
+		d.hour = 0;
+		d.minute = 0;
+		d.second = 0;
+		d.millis = 0;
+		if (ds.indexOf(&quot;day&quot;) &gt; 0) {
+			if (ds.indexOf(&quot;Yesterday&quot;) &gt; -1) {
+				d.setTime(d.getTime() - adaylong);
+			} else {
+				d.setTime(d.getTime() - adaylong * Common.parseInt(ds.substring(0, 1)));
+			}
+		} else {
+			String[] SDate;
+			ds = STRreplace.replace(ds, &quot;,&quot;, &quot; &quot;);
+			ds = STRreplace.replace(ds, &quot;  &quot;, &quot; &quot;);
+			SDate = mString.split(ds, ' ');
+			if (SDate.length == 1) {
+				if (ds.indexOf('/') &gt; -1)
+					SDate = mString.split(ds, '/');
+				else if (ds.indexOf('-') &gt; -1)
+					SDate = mString.split(ds, '-');
+				// trying to determine Dateformat
+				int v0 = Common.parseInt(SDate[0]);
+				int v1 = Common.parseInt(SDate[1]);
+				int v2 = Common.parseInt(SDate[2]);
+				int dd, mm, yy;
+				if (v0 &gt; 31) {
+					// yyyy mm dd
+					yy = v0;
+					mm = v1;
+					dd = v2;
+				} else {
+					yy = v2;
+					if ((v0 == 0) || (v1 == 0)) {
+						// month as text
+						String month;
+						if (v0 == 0) {
+							month = SDate[0];
+							dd = v1;
+						} else {
+							month = SDate[1];
+							dd = v0;
+						}
+						mm = monthName2int(month);
+					} else {
+						// mm dd yyyy (doesn't work for dd mm yyyy)
+						if (GCDateFormat.equals(&quot;dd/MM/yyyy&quot;)) {
+							dd = v0;
+							mm = v1;
+						} else {
+							mm = v0;
+							dd = v1;
+						}
+					}
+
 				}
+				d.month = mm;
+				d.day = dd;
+				d.year = yy;
+			} else {
+				// starting with dayOfWeek or missing year
+				int offs = SDate.length - 3;
+				if (offs &lt; 0)
+					offs = 0;
+				int v0 = Common.parseInt(SDate[offs]);
+				if (v0 == 0) {
+					d.day = Common.parseInt(SDate[offs + 1]);
+					d.month = monthName2int(SDate[offs]);
+				} else {
+					d.day = Common.parseInt(SDate[offs]);
+					d.month = monthName2int(SDate[offs + 1]);
+				}
+				if (SDate.length &gt; 2) {
+					int yy = Common.parseInt(SDate[offs + 2]);
+					if (yy &lt; 100)
+						d.year = 2000 + yy;
+					else
+						d.year = yy;
+				} else
+					// missing year
+					; // d.year = this year
 			}
-			return date;
 		}
-		else {
-			if (p1 &gt; 0)
-				p2 = date.indexOf(&quot;/&quot;, p1 + 1);
-			if (p1 &gt; 0 &amp;&amp; p2 &gt; 0) {
-				return date.substring(p2 + 1) + &quot;-&quot; + (p1 == 1 ? &quot;0&quot; : &quot;&quot;)
-						+ date.substring(0, p1) + &quot;-&quot; + (p1 + 2 == p2 ? &quot;0&quot; : &quot;&quot;)
-						+ date.substring(p1 + 1, p2);
-			} else
-				return date;
-		}
+		return d;
 	}
 
-	/* Convert the sortable date into a US date */
-	// static String YMD2MDY(String date) {
-	// return
-	// date.substring(4,6)+&quot;/&quot;+date.substring(6,8)+&quot;/&quot;+date.substring(0,4);
-	// }
-	/** Convert the log format into a sortable format */
-	public static String logdate2YMD(String logdate) {
-		String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;,
-				&quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;,
-				&quot;December&quot; };
-		Time t = new Time();
-		String year, month, day;
-		int i, m;
-		logdate += &quot;, &quot; + t.year; // If logdate already has a year, this one is
-									// ignored
-		i = logdate.indexOf(',');
-		year = logdate.substring(i + 2, i + 6);
-		for (m = 0; m &lt; 12; m++) {
-			if (logdate.startsWith(monthNames[m])) {
-				month = (m &lt; 9 ? &quot;0&quot; : &quot;&quot;) + Convert.formatInt(m + 1);
-				day = logdate.substring(monthNames[m].length() + 1, i);
-				if (day.length() == 1)
-					day = &quot;0&quot; + day;
-				return year + &quot;-&quot; + month + &quot;-&quot; + day;
+	private static int monthName2int(String month) {
+		final String enMonthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };
+		for (int m = 0; m &lt; 12; m++) {
+			if (enMonthNames[m].startsWith(month)) {
+				return m + 1;
 			}
 		}
-		return &quot;&quot;;
+		final String deMonthNames[] = { &quot;Januar&quot;, &quot;Februar&quot;, &quot;M&#228;rz&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot; };
+		for (int m = 0; m &lt; 12; m++) {
+			if (deMonthNames[m].startsWith(month)) {
+				return m + 1;
+			}
+		}
+		return 1; // Januar if not detected / in other language
 	}
+
+	public static String toYYMMDD(Time d) {
+		return toYYMMDD(d, '-');
+	}
+
+	public static String toYYMMDD(Time d, char separator) {
+		// the CW Time Format is with separator
+		String f = &quot;yyyy&quot; + separator + &quot;MM&quot; + separator + &quot;dd&quot;;
+		return d.format(f);
+	}
+
 	// from lastSyncDate (yyyyMMddHHmmss) to gpxLogdate (yyyy-MM-dd)
-	// if no lastSyncDate returns current Date 
+	// if no lastSyncDate returns current Date
 	public static String yyyyMMddHHmmss2gpxLogdate(String yyyyMMddHHmmss) {
 		Time d = new Time();
 		try {
@@ -109,7 +170,7 @@
 		} catch (IllegalArgumentException e) {
 			d = new Time();
 			d.parse(yyyyMMddHHmmss, &quot;yyyyMMddHHmmss&quot;);
-		}		
+		}
 		return d.format(&quot;yyyy-MM-dd&quot;); // +d.format(&quot;HH:mm:ss&quot;); is set to 00:00:00 at gpxExport
 	}
 

Modified: branches/r1.2/src/CacheWolf/DateTimeChooser.java
===================================================================
--- branches/r1.2/src/CacheWolf/DateTimeChooser.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DateTimeChooser.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -62,6 +62,7 @@
 	public int hour;
 	public int minute;
 	public String time;
+	Time dateSet;
 	
 	public boolean autoAdvance = true;
 	public boolean didAll = false;
@@ -75,7 +76,7 @@
 	Control timeDisplay;
 	//Control minuteDisplay;
 
-	Time getTime() {
+	Time getDate() {
 		Time t = (Time)dateSet.getCopy();
 		t.day = day;
 		t.month = month;
@@ -84,7 +85,6 @@
 		t.minute = minute;
 		t.update();
 		return t;
-		//return new Time(day,month,year);
 	}
 	
 	void addTable(TableControl tc,TableModel tm,String pName) {
@@ -246,7 +246,6 @@
 		else super.onControlEvent(ev);
 	}
 	
-	Time dateSet;
 	
 	public void setDate(Time t) {
 		dateSet = t;
@@ -275,6 +274,30 @@
 		//dayChooser.repaintNow();
 		//monthChooser.repaintNow();
 	}
+
+	public int getDay() {		
+		return day;
+	}
+
+	public int getMonth() {
+		return month;
+	}
+
+	public int getYear() {
+		return year;
+	}
+
+	public String getTime() {
+		return time;
+	}
+
+	public int getHour() {
+		return hour;
+	}
+
+	public int getMinute() {
+		return minHeight;
+	}
 } // DateTimeChooser
 
 

Modified: branches/r1.2/src/CacheWolf/DetailsPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/DetailsPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/DetailsPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.TransformCoordinates;
@@ -64,7 +64,7 @@
  */
 public class DetailsPanel extends CellPanel {
 
-    // ===== GUI elements =====
+	// ===== GUI elements =====
 	/** way point id. */
 	private static mInput inpWaypoint;
 	/** way point name. */
@@ -135,24 +135,20 @@
 	private boolean blackStatusChanged;
 	/** FIXME */
 	private boolean needsTableUpdate;
-	/** screen is VGA or better */
-	private final boolean isBigScreen;
-	/** use big icons */
-	private final boolean useBigIcons;
-	/** String to display for invalid or not applicable terrain or difficulty values.*/
+	/** String to display for invalid or not applicable terrain or difficulty values. */
 	private final static String DTINVALID = &quot;: -.-&quot;;
-	public boolean evWaypointChanged=false;
-	private String warnedForWaypoint=&quot;&quot;;
+	public boolean evWaypointChanged = false;
+	private String warnedForWaypoint = &quot;&quot;;
 
-    // TODO: move images to image broker
-    //mImage imgBlack, imgBlackNo, imgShowBug, imgShowBugNo, imgNewWpt, imgGoto, imgShowMaps, imgAddImages, imgNotes;
+	// TODO: move images to image broker
+	// mImage imgBlack, imgBlackNo, imgShowBug, imgShowBugNo, imgNewWpt, imgGoto, imgShowMaps, imgAddImages, imgNotes;
 
 	/**
 	 * public constructor for detail panels. should only be called from main tab.
 	 */
 	public DetailsPanel() {
 		super();
-        // ===== local objects =====
+		// ===== local objects =====
 		/** helper panels to organize layout */
 		CellPanel helperPanel1, helperPanel2, helperPanel3, helperPanel4, helperPanel5;
 
@@ -166,11 +162,9 @@
 		blackStatus = false;
 		blackStatusChanged = false;
 		needsTableUpdate = false;
-		isBigScreen = pref.isBigScreen;
-		useBigIcons = pref.useBigIcons;
 
 		// ===== initialize GUI objects =====
-        // ----- main body -----
+		// ----- main body -----
 
 		helperPanel1 = new CellPanel();
 		helperPanel2 = new CellPanel();
@@ -183,7 +177,7 @@
 		chcType.alwaysDrop = true;
 		chcSize = new mChoice(CacheSize.guiSizeStrings(), 0);
 		chcSize.alwaysDrop = true;
-		chcStatus = new mComboBox(CacheHolder.GetGuiLogTypes(),0);
+		chcStatus = new mComboBox(CacheHolder.GetGuiLogTypes(), 0);
 		inpWaypoint = new mInput();
 		inpName = new mInput();
 
@@ -196,7 +190,7 @@
 
 		// ===== put the controls onto the GUI =====
 
-        // ----- helper panels -----
+		// ----- helper panels -----
 
 		btnDiff = new mButton(MyLocale.getMsg(1000, &quot;D&quot;) + &quot;: 5.5&quot;);
 		btnDiff.setPreferredSize(pref.fontSize * 3, chcSize.getPreferredSize(null).height);
@@ -208,10 +202,10 @@
 
 		lblAddiCount = new mLabel(MyLocale.getMsg(1044, &quot;Addis&quot;) + &quot;: 888&quot;);
 
-		btnFoundDate = new mButton(new mImage(useBigIcons ? &quot;calendar_vga.png&quot; : &quot;calendar.png&quot;));
+		btnFoundDate = new mButton(new mImage(pref.useBigIcons ? &quot;calendar_vga.png&quot; : &quot;calendar.png&quot;));
 		btnFoundDate.setToolTip(MyLocale.getMsg(31415, &quot;Set found date / time&quot;));
 
-		btnHiddenDate = new mButton(new mImage(useBigIcons ? &quot;calendar_vga.png&quot;	: &quot;calendar.png&quot;));
+		btnHiddenDate = new mButton(new mImage(pref.useBigIcons ? &quot;calendar_vga.png&quot; : &quot;calendar.png&quot;));
 		btnHiddenDate.setToolTip(MyLocale.getMsg(31415, &quot;Set hidden date&quot;));
 
 		helperPanel1.addNext(chcType, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
@@ -226,7 +220,7 @@
 		helperPanel4.addNext(chcStatus, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 		helperPanel4.addLast(btnFoundDate, DONTSTRETCH, DONTFILL);
 
-		helperPanel5.addNext(inpHidden, CellConstants.HSTRETCH,	(CellConstants.HFILL | CellConstants.WEST));
+		helperPanel5.addNext(inpHidden, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 		helperPanel5.addLast(btnHiddenDate, DONTSTRETCH, DONTFILL);
 
 		// ----- main body -----
@@ -242,10 +236,10 @@
 		addLast(helperPanel3, DONTSTRETCH, HFILL).setTag(CellConstants.SPAN, new Dimension(2, 1));
 
 		addNext(new mLabel(MyLocale.getMsg(303, &quot;Name:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
-		addLast(inpName.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.DONTSTRETCH,	(CellConstants.HFILL | CellConstants.WEST));
+		addLast(inpName.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
 		addNext(new mLabel(MyLocale.getMsg(304, &quot;Coordinates:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
-		addLast(btnCoordinates.setTag(CellConstants.SPAN, new Dimension(2, 1)),	CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		addLast(btnCoordinates.setTag(CellConstants.SPAN, new Dimension(2, 1)), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
 		addNext(new mLabel(MyLocale.getMsg(307, &quot;Status:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		addLast(helperPanel4, DONTSTRETCH, HFILL).setTag(CellConstants.SPAN, new Dimension(2, 1));
@@ -258,56 +252,56 @@
 
 		addLast(attViewer);
 
-		//TODO: decide whether to still use the object without display on small screens to handle notes
-		if (isBigScreen) {
+		// TODO: decide whether to still use the object without display on small screens to handle notes
+		if (pref.isBigScreen) {
 			addLast(new mLabel(MyLocale.getMsg(308, &quot;Notes:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			waypointNotes = new mTextPad();
 			waypointNotes.modify(ControlConstants.NotEditable, 0);
 			addLast(new MyScrollBarPanel(waypointNotes));
 		}
 
-		//FIXME: get rid of this
-		imgBlack = new mImage(useBigIcons?&quot;is_black_vga.png&quot;:&quot;is_black.png&quot;);
+		// FIXME: get rid of this
+		imgBlack = new mImage(pref.useBigIcons ? &quot;is_black_vga.png&quot; : &quot;is_black.png&quot;);
 		imgBlack.transparentColor = Color.White;
-		imgBlackNo = new mImage(useBigIcons ? &quot;no_black_vga.png&quot; : &quot;no_black.png&quot;);
+		imgBlackNo = new mImage(pref.useBigIcons ? &quot;no_black_vga.png&quot; : &quot;no_black.png&quot;);
 		imgBlackNo.transparentColor = Color.Black;
-		imgShowBug = new mImage(useBigIcons ? &quot;bug_vga.gif&quot;:&quot;bug.gif&quot;);
-		imgShowBugNo = new mImage(useBigIcons ? &quot;bug_no_vga.gif&quot;:&quot;bug_no.gif&quot;);
+		imgShowBug = new mImage(pref.useBigIcons ? &quot;bug_vga.gif&quot; : &quot;bug.gif&quot;);
+		imgShowBugNo = new mImage(pref.useBigIcons ? &quot;bug_no_vga.gif&quot; : &quot;bug_no.gif&quot;);
 	}
 
 	private CellPanel createToolsPanel() {
 		final CellPanel pnlTools = new CellPanel();
 
-		btnNewWpt = new mButton(imgNewWpt = new mImage(useBigIcons ? &quot;newwpt_vga.png&quot; : &quot;newwpt.png&quot;));
+		btnNewWpt = new mButton(imgNewWpt = new mImage(pref.useBigIcons ? &quot;newwpt_vga.png&quot; : &quot;newwpt.png&quot;));
 		// FIXME: get an image with proper transparency
 		imgNewWpt.transparentColor = new Color(255, 0, 0);
 		btnNewWpt.setToolTip(MyLocale.getMsg(311, &quot;Create Waypoint&quot;));
 
-		btnGoto = new mButton(imgGoto = new mImage(useBigIcons ? &quot;goto_vga.png&quot;	: &quot;goto.png&quot;));
+		btnGoto = new mButton(imgGoto = new mImage(pref.useBigIcons ? &quot;goto_vga.png&quot; : &quot;goto.png&quot;));
 		// FIXME: get an image with proper transparency
 		imgGoto.transparentColor = Color.White;
 		btnGoto.setToolTip(MyLocale.getMsg(345, &quot;Goto these coordinates&quot;));
 
-		btnShowBug = new mButton(new mImage(useBigIcons ? &quot;bug_no_vga.gif&quot; : &quot;bug_no.gif&quot;));
+		btnShowBug = new mButton(new mImage(pref.useBigIcons ? &quot;bug_no_vga.gif&quot; : &quot;bug_no.gif&quot;));
 		btnShowBug.setToolTip(MyLocale.getMsg(346, &quot;Show travelbugs&quot;));
 
-		btnShowMap = new mButton(new mImage(useBigIcons ? &quot;globe_small_vga.gif&quot; : &quot;globe_small.gif&quot;));
+		btnShowMap = new mButton(new mImage(pref.useBigIcons ? &quot;globe_small_vga.gif&quot; : &quot;globe_small.gif&quot;));
 		btnShowMap.setToolTip(MyLocale.getMsg(347, &quot;Show map&quot;));
 
-		btnAddPicture = new mButton(new mImage(useBigIcons ? &quot;images_vga.gif&quot; : &quot;images.gif&quot;));
+		btnAddPicture = new mButton(new mImage(pref.useBigIcons ? &quot;images_vga.gif&quot; : &quot;images.gif&quot;));
 		btnAddPicture.setToolTip(MyLocale.getMsg(348, &quot;Add user pictures&quot;));
 
-		btnBlack = new mButton(imgBlack = new mImage(useBigIcons ? &quot;no_black_vga.png&quot; : &quot;no_black.png&quot;));
+		btnBlack = new mButton(imgBlack = new mImage(pref.useBigIcons ? &quot;no_black_vga.png&quot; : &quot;no_black.png&quot;));
 		// FIXME: get an image with proper transparency
 		imgBlack.transparentColor = Color.Black;
 		btnBlack.setToolTip(MyLocale.getMsg(349, &quot;Toggle Blacklist status&quot;));
 
-		btnNotes = new mButton(imgNotes = new mImage(useBigIcons ? &quot;notes_vga.gif&quot; : &quot;notes.gif&quot;));
+		btnNotes = new mButton(imgNotes = new mImage(pref.useBigIcons ? &quot;notes_vga.gif&quot; : &quot;notes.gif&quot;));
 		// FIXME: get an image with proper transparency
 		imgNotes.transparentColor = Color.DarkBlue;
 		btnNotes.setToolTip(MyLocale.getMsg(351, &quot;Add/Edit notes&quot;));
 
-		btnAddDateTime = new mButton(new mImage(useBigIcons ? &quot;date_time_vga.gif&quot; : &quot;date_time.gif&quot;));
+		btnAddDateTime = new mButton(new mImage(pref.useBigIcons ? &quot;date_time_vga.gif&quot; : &quot;date_time.gif&quot;));
 		btnAddDateTime.setToolTip(MyLocale.getMsg(350, &quot;Add timestamp to notes&quot;));
 
 		pnlTools.addNext(btnNewWpt);
@@ -351,7 +345,7 @@
 		dirtyDetails = false;
 		inpWaypoint.setText(ch.getWayPoint());
 		inpName.setText(ch.getCacheName());
-		btnCoordinates.setText(ch.pos.toString());
+		btnCoordinates.setText(ch.getPos().toString());
 		inpHidden.setText(mainCache.getDateHidden());
 		inpOwner.setText(mainCache.getCacheOwner());
 		chcStatus.setText(ch.getStatusText());
@@ -425,7 +419,7 @@
 		}
 		lblAddiCount.setText(MyLocale.getMsg(1044, &quot;Addis&quot;) + &quot;: &quot; + addiCount);
 
-		if (isBigScreen) {
+		if (pref.isBigScreen) {
 			waypointNotes.setText(ch.getCacheDetails(true).getCacheNotes());
 		}
 	}
@@ -436,307 +430,270 @@
 	 */
 	public void createWptName() {
 		final String wpt = inpWaypoint.getText().toUpperCase();
-		if (CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-				&amp;&amp; Global.mainTab.mainCache != null
-				&amp;&amp; (Global.mainTab.mainCache.startsWith(&quot;GC&quot;)
-					|| OC.isOC(Global.mainTab.mainCache) || Global.mainTab.mainCache.startsWith(&quot;CW&quot;))
+		if (CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) &amp;&amp; Global.mainTab.mainCache != null &amp;&amp; (Global.mainTab.mainCache.startsWith(&quot;GC&quot;) || OC.isOC(Global.mainTab.mainCache) || Global.mainTab.mainCache.startsWith(&quot;CW&quot;))
 				&amp;&amp; wpt.startsWith(&quot;CW&quot;)) {
 			// for creating the Addiname on creating a new Waypoint
-			Global.mainTab.lastselected = Global.mainTab.mainCache; 
+			Global.mainTab.lastselected = Global.mainTab.mainCache;
 
-			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(
-					Global.mainTab.mainCache));
+			inpWaypoint.setText(Global.getProfile().getNewAddiWayPointName(Global.mainTab.mainCache));
 		}
-		if (!CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-				&amp;&amp; !(wpt.startsWith(&quot;GC&quot;)
-					|| OC.isOC(wpt) || wpt.startsWith(&quot;CW&quot;))) {
+		if (!CacheType.isAddiWpt(CacheType.guiSelect2Cw(chcType.getInt())) &amp;&amp; !(wpt.startsWith(&quot;GC&quot;) || OC.isOC(wpt) || wpt.startsWith(&quot;CW&quot;))) {
 			inpWaypoint.setText(Global.getProfile().getNewWayPointName());
 		}
 	}
 
-    /**
-     * Method to react to a user input.
-     */
-    public void onEvent(final Event ev) {
-        if (ev instanceof DataChangeEvent) {
-            if (ev.target == inpWaypoint) {
-                if (evWaypointChanged) {
-                    String iTmp=inpWaypoint.getText();
-                    String uTmp=iTmp.toUpperCase();
-                    if (!iTmp.equals(uTmp)){
-                        inpWaypoint.setText(uTmp); // If user entered LowerCase -&gt; convert directly to UpperCase
-                        evWaypointChanged=false; //next DataChangeEvent fired by change to UpperCase will be ignored
-                    }
-                    // already warned(multi same DataChangeEvents) or same waypointname as before edit !!!
-                    if(!warnedForWaypoint.equals(uTmp) &amp;&amp; !uTmp.equals(this.cache.getWayPoint())){
-                        if ((new File(profile.dataDir + iTmp.toLowerCase()+&quot;.xml&quot;)).exists()) {
-                            warnedForWaypoint=uTmp; // before MessageBox cause Multithread DataChangeEvents
-                            // filename is LowerCase
-                            new MessageBox(&quot;Warning :&quot;,uTmp+&quot;\n&quot;+MyLocale.getMsg(275,&quot;Waypoint already exists!&quot;),MessageBox.OKB).execute();
-                            // revert waypointname
-                            inpWaypoint.setText(this.cache.getWayPoint());
-                        }
-                    }
-                }
-                else {
-                    // first DataChangeEvent is fired by Klick into (after reload).
-                    // that really didn't change anything
-                    evWaypointChanged=true;
-                }
-                // FIXME: if name was changed, we should rename the waypoint.xml file. how? where?
-            } else if (ev.target == chcType) {
-                createWptName();
-                if (CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.selectedIndex))) {
-                    activateControl(btnTerr);
-                    activateControl(btnDiff);
-                    activateControl(chcSize);
-                    activateControl(inpOwner);
-                    activateControl(inpHidden);
-                    activateControl(btnShowBug);
-                    activateControl(btnBlack);
-                } else {
-                    deactivateControl(btnTerr);
-                    deactivateControl(btnDiff);
-                    deactivateControl(chcSize);
-                    deactivateControl(inpOwner);
-                    deactivateControl(inpHidden);
-                    deactivateControl(btnShowBug);
-                    deactivateControl(btnBlack);
-                    chcSize.select(0);
-                    btnTerr.setText(MyLocale.getMsg(1001, &quot;T&quot;) + DTINVALID);
-                    btnDiff.setText(MyLocale.getMsg(1000, &quot;D&quot;) + DTINVALID);
-                }
-            }
-            //FIXME: check if something was actually changed, since datacachnge events also occur if you just hop through the fileds with the tab key (Why? don't know!)
-            dirtyDetails = true;
-            needsTableUpdate = true;
-        }
-        if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
-            if (ev.target == btnNotes) {
-                dirtyNotes = true; // TODO I think this is redundant, because
-                                    // the notes are saved separately by the notes screen itself
-                final NotesScreen nsc = new NotesScreen(cache.getCacheDetails(true));
-                nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
-                if (isBigScreen) {
-                    waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
-                }
-            } else if (ev.target == btnShowMap) {
-                Global.mainTab.SwitchToMovingMap(cache.pos, true);
-            } else if (ev.target == btnShowBug) {
-                // InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
-                // &quot;Travelbugs&quot;,
-                // false, pref);
-                // is.execute();
-                final TravelbugInCacheScreen ts = new TravelbugInCacheScreen(cache.getCacheDetails(true).Travelbugs.toHtml(),	&quot;Travelbugs&quot;);
-                ts.execute(this.getFrame(), Gui.CENTER_FRAME);
-            /* not fully implemented
-            } else if (ev.target == btnCenter) {
-                final CWPoint cp = new CWPoint(cache.LatLon);
-                if (cp.isValid()) {
-                    pref.setCurCentrePt(cp);
-                } else {
-                    final MessageBox tmpMB = new MessageBox(
-                            MyLocale.getMsg(312, &quot;Error&quot;),
-                            MyLocale.getMsg(4111, &quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;),
-                            FormBase.OKB);
-                    tmpMB.exec();
-                }
-            */
+	/**
+	 * Method to react to a user input.
+	 */
+	public void onEvent(final Event ev) {
+		if (ev instanceof DataChangeEvent) {
+			if (ev.target == inpWaypoint) {
+				if (evWaypointChanged) {
+					String iTmp = inpWaypoint.getText();
+					String uTmp = iTmp.toUpperCase();
+					if (!iTmp.equals(uTmp)) {
+						inpWaypoint.setText(uTmp); // If user entered LowerCase -&gt; convert directly to UpperCase
+						evWaypointChanged = false; // next DataChangeEvent fired by change to UpperCase will be ignored
+					}
+					// already warned(multi same DataChangeEvents) or same waypointname as before edit !!!
+					if (!warnedForWaypoint.equals(uTmp) &amp;&amp; !uTmp.equals(this.cache.getWayPoint())) {
+						if ((new File(profile.dataDir + iTmp.toLowerCase() + &quot;.xml&quot;)).exists()) {
+							warnedForWaypoint = uTmp; // before MessageBox cause Multithread DataChangeEvents
+							// filename is LowerCase
+							new MessageBox(&quot;Warning :&quot;, uTmp + &quot;\n&quot; + MyLocale.getMsg(275, &quot;Waypoint already exists!&quot;), MessageBox.OKB).execute();
+							// revert waypointname
+							inpWaypoint.setText(this.cache.getWayPoint());
+						}
+					}
+				} else {
+					// first DataChangeEvent is fired by Klick into (after reload).
+					// that really didn't change anything
+					evWaypointChanged = true;
+				}
+				// FIXME: if name was changed, we should rename the waypoint.xml file. how? where?
+			} else if (ev.target == chcType) {
+				createWptName();
+				if (CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.selectedIndex))) {
+					activateControl(btnTerr);
+					activateControl(btnDiff);
+					activateControl(chcSize);
+					activateControl(inpOwner);
+					activateControl(inpHidden);
+					activateControl(btnShowBug);
+					activateControl(btnBlack);
+				} else {
+					deactivateControl(btnTerr);
+					deactivateControl(btnDiff);
+					deactivateControl(chcSize);
+					deactivateControl(inpOwner);
+					deactivateControl(inpHidden);
+					deactivateControl(btnShowBug);
+					deactivateControl(btnBlack);
+					chcSize.select(0);
+					btnTerr.setText(MyLocale.getMsg(1001, &quot;T&quot;) + DTINVALID);
+					btnDiff.setText(MyLocale.getMsg(1000, &quot;D&quot;) + DTINVALID);
+				}
+			}
+			// FIXME: check if something was actually changed, since datacachnge events also occur if you just hop through the fileds with the tab key (Why? don't know!)
+			dirtyDetails = true;
+			needsTableUpdate = true;
+		}
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == btnNotes) {
+				dirtyNotes = true; // TODO I think this is redundant, because
+									// the notes are saved separately by the notes screen itself
+				final NotesScreen nsc = new NotesScreen(cache.getCacheDetails(true));
+				nsc.execute(this.getFrame(), Gui.CENTER_FRAME);
+				if (pref.isBigScreen) {
+					waypointNotes.setText(cache.getCacheDetails(true).getCacheNotes());
+				}
+			} else if (ev.target == btnShowMap) {
+				Global.mainTab.SwitchToMovingMap(cache.getPos(), true);
+			} else if (ev.target == btnShowBug) {
+				// InfoScreen is = new InfoScreen(thisCache.Travelbugs.toHtml(),
+				// &quot;Travelbugs&quot;,
+				// false, pref);
+				// is.execute();
+				final TravelbugInCacheScreen ts = new TravelbugInCacheScreen(cache.getCacheDetails(true).Travelbugs.toHtml(), &quot;Travelbugs&quot;);
+				ts.execute(this.getFrame(), Gui.CENTER_FRAME);
+				/*
+				 * not fully implemented
+				 * } else if (ev.target == btnCenter) {
+				 * final CWPoint cp = new CWPoint(cache.LatLon);
+				 * if (cp.isValid()) {
+				 * pref.setCurCentrePt(cp);
+				 * } else {
+				 * final MessageBox tmpMB = new MessageBox(
+				 * MyLocale.getMsg(312, &quot;Error&quot;),
+				 * MyLocale.getMsg(4111, &quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;),
+				 * FormBase.OKB);
+				 * tmpMB.exec();
+				 * }
+				 */
 
-            } else if (ev.target == btnAddDateTime) {
-                dirtyNotes = true;
+			} else if (ev.target == btnAddDateTime) {
+				dirtyNotes = true;
 
-                final StringBuffer newNote = new StringBuffer();
-                newNote.append(cache.getCacheDetails(true).getCacheNotes());
+				final StringBuffer newNote = new StringBuffer();
+				newNote.append(cache.getCacheDetails(true).getCacheNotes());
 
-                final Time dtm = new Time();
-                dtm.getTime();
-                dtm.setFormat(&quot;E dd.MM.yyyy '/' HH:mm&quot;);
+				final Time dtm = new Time();
+				dtm.getTime();
+				dtm.setFormat(&quot;E dd.MM.yyyy '/' HH:mm&quot;);
 
-                if (newNote.length() &gt; 0) {
-                    newNote.append('\n');
-                }
-                newNote.append(dtm.toString()).append('\n');
+				if (newNote.length() &gt; 0) {
+					newNote.append('\n');
+				}
+				newNote.append(dtm.toString()).append('\n');
 
-                cache.getCacheDetails(true).setCacheNotes(newNote.toString());
-                //FIXME: better use saveDirtyWaypoint()?
-                cache.save();
-            } else if (ev.target == btnAddPicture) {
-                cache.getCacheDetails(true).addUserImage(profile);
-            } else if (ev.target == btnBlack) {
-                if (cache.is_black()) {
-                    cache.setBlack(false);
-                    btnBlack.image = imgBlackNo;
-                } else {
-                    cache.setBlack(true);
-                    btnBlack.image = imgBlack;
-                }
-                blackStatus = cache.is_black();
-                cache.setAttributesToAddiWpts();
-                btnBlack.repaintNow();
-                dirtyDetails = true;
-                blackStatusChanged = true;
-            } else if (ev.target == btnNewWpt) {
-                final CacheHolder ch = new CacheHolder();
-                ch.setLatLon(cache.getLatLon());
-                ch.pos = new CWPoint(cache.pos);
-                ch.setType(CacheType.CW_TYPE_STAGE);
-                ch.setHard(CacheTerrDiff.CW_DT_UNSET);
-                ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-                ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-                Global.mainTab.newWaypoint(ch);
-            } else if (ev.target == btnGoto) {
-                // FIXME: if something changed saveDirtyWaypoint();
-                Global.mainTab.gotoP.setDestinationAndSwitch(cache);
-            } else if (ev.target == btnCoordinates) {
-                CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);
-                if(Vm.isMobile()){
-                    InputScreen InScr = new InputScreen(TransformCoordinates.CW, true);
-                    if (coords.isValid())	InScr.setCoords(coords);
-                        else InScr.setCoords(new CWPoint(0,0));
-                    if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
-                    {
-                        dirtyDetails = true;
-                        coords = InScr.getCoords();
-                        Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-                        cache.pos.set(coords);
-                        btnCoordinates.setText(coords.toString());
-                        cache.setLatLon(coords.toString());
-                        // If the current centre is valid, calculate the distance and bearing to it
-                        final CWPoint centre = Global.getPref().getCurCentrePt();
-                        if (centre.isValid()) {
-                            cache.calcDistance(centre); // todo perhaps sortTable
-                        }
-                    }
-                }else{
-                    final CoordsScreen cs = new CoordsScreen(true);
-                    cs.setFields(coords, TransformCoordinates.CW);
-                    if (cs.execute() == FormBase.IDOK) {
-                        dirtyDetails = true;
-                        coords = cs.getCoords();
-                        Global.getProfile().notifyUnsavedChanges(!cache.pos.toString().equals(coords.toString()));
-                        cache.pos.set(coords);
-                        btnCoordinates.setText(coords.toString());
-                        cache.setLatLon(coords.toString());
-                        // If the current centre is valid, calculate the distance and bearing to it
-                        final CWPoint centre = Global.getPref().getCurCentrePt();
-                        if (centre.isValid()) {
-                            cache.calcDistance(centre); // todo perhaps sortTable
-                        }
-                    }
-                }
-            } else if (ev.target == btnFoundDate) {
-            	int msgNr=318; // normal found
-            	if (cache.getType() == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-            	else if (cache.getType() == CacheType.CW_TYPE_EVENT 
-            			|| cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
-                // DateChooser.dayFirst=true;
-                final DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
-                dc.title = MyLocale.getMsg(328, &quot;Date found&quot;);
-                dc.setPreferredSize(240, 240);
-                String foundDate = chcStatus.getText();
-                if (foundDate.startsWith(MyLocale.getMsg(msgNr, &quot;Found&quot;) + &quot; &quot;)) {
-                    foundDate = foundDate.substring(MyLocale.getMsg(msgNr, &quot;Found&quot;).length() + 1);
-                }
-                else if (foundDate.endsWith(MyLocale.getMsg(319, &quot;not Found&quot;))) {
-                    foundDate = foundDate.substring(0,foundDate.length()-MyLocale.getMsg(319, &quot;not Found&quot;).length());
-                    dc.title=MyLocale.getMsg(330,&quot;Date Not Found&quot;);
-                }
-                foundDate=foundDate.trim();
-                if (foundDate.length()&gt;0 &amp;&amp; foundDate.indexOf('-')&gt;0) { //Don't try and parse empty date
-                    final Time t = new Time();
-                    try {
-                        t.parse(foundDate, &quot;y-M-d H:m&quot;);
-                    } catch (IllegalArgumentException e) {
-                        try {
-                            t.parse(foundDate, &quot;y-M-d&quot;);
-                        } catch (IllegalArgumentException e1) {
-                            Global.getPref().log(&quot;No parsable date given - should not appear (&quot;+foundDate+&quot;)&quot;, e1, true);
-                        }
-                    }
+				cache.getCacheDetails(true).setCacheNotes(newNote.toString());
+				// FIXME: better use saveDirtyWaypoint()?
+				cache.save();
+			} else if (ev.target == btnAddPicture) {
+				cache.getCacheDetails(true).addUserImage(profile);
+			} else if (ev.target == btnBlack) {
+				if (cache.is_black()) {
+					cache.setBlack(false);
+					btnBlack.image = imgBlackNo;
+				} else {
+					cache.setBlack(true);
+					btnBlack.image = imgBlack;
+				}
+				blackStatus = cache.is_black();
+				cache.setAttributesToAddiWpts();
+				btnBlack.repaintNow();
+				dirtyDetails = true;
+				blackStatusChanged = true;
+			} else if (ev.target == btnNewWpt) {
+				final CacheHolder ch = new CacheHolder();
+				ch.setPos(cache.getPos());
+				ch.setType(CacheType.CW_TYPE_STAGE);
+				ch.setHard(CacheTerrDiff.CW_DT_UNSET);
+				ch.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+				ch.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+				Global.mainTab.newWaypoint(ch);
+			} else if (ev.target == btnGoto) {
+				// FIXME: if something changed saveDirtyWaypoint();
+				Global.mainTab.gotoP.setDestinationAndSwitch(cache);
+			} else if (ev.target == btnCoordinates) {
+				CWPoint coords = new CWPoint(btnCoordinates.getText(), TransformCoordinates.CW);
+				if (Vm.isMobile()) {
+					InputScreen InScr = new InputScreen(TransformCoordinates.CW, true);
+					if (coords.isValid())
+						InScr.setCoords(coords);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
+					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK) {
+						dirtyDetails = true;
+						coords = InScr.getCoords();
+						cache.setPos(coords);
+						btnCoordinates.setText(coords.toString());
+						// If the current centre is valid, calculate the distance and bearing to it
+						final CWPoint centre = Global.getPref().getCurCentrePt();
+						if (centre.isValid()) {
+							cache.calcDistance(centre); // todo perhaps sortTable
+						}
+					}
+				} else {
+					final CoordsScreen cs = new CoordsScreen(true);
+					cs.setFields(coords, TransformCoordinates.CW);
+					if (cs.execute() == FormBase.IDOK) {
+						dirtyDetails = true;
+						coords = cs.getCoords();
+						cache.setPos(coords);
+						btnCoordinates.setText(coords.toString());
+						// If the current centre is valid, calculate the distance and bearing to it
+						final CWPoint centre = Global.getPref().getCurCentrePt();
+						if (centre.isValid()) {
+							cache.calcDistance(centre); // todo perhaps sortTable
+						}
+					}
+				}
+			} else if (ev.target == btnFoundDate) {
+				int msgNr = 318; // normal found
+				if (cache.getType() == CacheType.CW_TYPE_WEBCAM) {
+					msgNr = 361;
+				} else if (cache.getType() == CacheType.CW_TYPE_EVENT || cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+					msgNr = 355;
+				}
+				// DateChooser.dayFirst=true;
+				final DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, &quot;Date found&quot;);
+				dc.setPreferredSize(240, 240);
+				String foundDate = chcStatus.getText();
+				if (foundDate.startsWith(MyLocale.getMsg(msgNr, &quot;Found&quot;) + &quot; &quot;)) {
+					foundDate = foundDate.substring(MyLocale.getMsg(msgNr, &quot;Found&quot;).length() + 1);
+				} else if (foundDate.endsWith(MyLocale.getMsg(319, &quot;not Found&quot;))) {
+					foundDate = foundDate.substring(0, foundDate.length() - MyLocale.getMsg(319, &quot;not Found&quot;).length());
+					dc.title = MyLocale.getMsg(330, &quot;Date Not Found&quot;);
+				}
+				foundDate = foundDate.trim();
+				if (foundDate.length() &gt; 0 &amp;&amp; foundDate.indexOf('-') &gt; 0) { // Don't try and parse empty date
+					final Time t = new Time();
+					try {
+						t.parse(foundDate, &quot;y-M-d H:m&quot;);
+					} catch (IllegalArgumentException e) {
+						try {
+							t.parse(foundDate, &quot;y-M-d&quot;);
+						} catch (IllegalArgumentException e1) {
+							Global.getPref().log(&quot;No parsable date given - should not appear (&quot; + foundDate + &quot;)&quot;, e1, true);
+						}
+					}
 
-                    dc.reset(t);
-                }
-                // We can create a not found log with date in two ways:
-                //   1) Exiting the date-time dialog by clicking the x if the status is empty (somewhat
-                //      non-standard but quick and dirty)
-                //   2) Exiting the date-time dialog by clicking the tick. Then we check whether
-                //      the status field was preset with the not-found text. If yes it stays a not found
-                //      but the date is prepended
-                //TODO: The functions for extracting the date and the found/not-found text should not be in the GUI
-                int retCode=dc.execute();
-                if (retCode == ewe.ui.FormBase.IDOK &amp;&amp; !chcStatus.getText().endsWith(MyLocale.getMsg(319, &quot;not Found&quot;))) {
-                    chcStatus.setText(MyLocale.getMsg(msgNr, &quot;Found&quot;) + &quot; &quot;
-                                    + Convert.toString(dc.year) + &quot;-&quot;
-                                    + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot;
-                                    + MyLocale.formatLong(dc.day, &quot;00&quot;) + &quot; &quot;
-                                    + dc.time);
-                    dirtyDetails = true;
-                }
-                else if (chcStatus.getText().length()==0 ||
-                		(retCode==ewe.ui.FormBase.IDOK &amp;&amp; chcStatus.getText().endsWith(MyLocale.getMsg(319, &quot;not Found&quot;)) )) {
-                    chcStatus.setText(Convert.toString(dc.year) + &quot;-&quot;
-                            + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot;
-                            + MyLocale.formatLong(dc.day, &quot;00&quot;) + &quot; &quot;
-                            + dc.time + &quot; &quot;
-                            + MyLocale.getMsg(319, &quot;not Found&quot;)
-                            );
-                    dirtyDetails = true;
-                }
-            } else if (ev.target == btnHiddenDate) {
-                DateChooser.dayFirst = true;
-                final DateChooser dc = new DateChooser(Vm.getLocale());
-                dc.title = MyLocale.getMsg(329, &quot;Hidden date&quot;);
-                dc.setPreferredSize(240, 240);
-                if (inpHidden.getText().length() == 10)
-                    try {
-                        dc.setDate(new Time(Convert.parseInt(inpHidden
-                                .getText().substring(8)), Convert
-                                .parseInt(inpHidden.getText().substring(5, 7)),
-                                Convert.parseInt(inpHidden.getText().substring(
-                                        0, 4))));
-                    } catch (NumberFormatException e) {
-                        dc.reset(new Time());
-                    }
-                if (dc.execute() == ewe.ui.FormBase.IDOK) {
-                    inpHidden.setText(Convert.toString(dc.year) + &quot;-&quot;
-                            + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot;
-                            + MyLocale.formatLong(dc.day, &quot;00&quot;));
-                    dirtyDetails = true;
-                    // profile.hasUnsavedChanges=true;
-                }
-            } else if (ev.target == btnTerr) {
-                int returnValue;
-                final TerrDiffForm tdf = new TerrDiffForm(true,
-                        decodeTerrDiff(btnTerr,
-                                MyLocale.getMsg(1001, &quot;T&quot;),
-                                CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-                            )
-                        );
-                returnValue = tdf.execute();
-                if (returnValue == 1) {
-                    btnTerr.setText(MyLocale.getMsg(1001, &quot;T&quot;) + &quot;: &quot; + CacheTerrDiff.longDT(tdf.getDT()));
-                    dirtyDetails = true;
-                }
-            } else if (ev.target == btnDiff) {
-                int returnValue;
-                final TerrDiffForm tdf = new TerrDiffForm(false,
-                        decodeTerrDiff(btnDiff,
-                                MyLocale.getMsg(1001, &quot;D&quot;),
-                                CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))
-                            )
-                        );
+					dc.reset(t);
+				}
+				// We can create a not found log with date in two ways:
+				// 1) Exiting the date-time dialog by clicking the x if the status is empty (somewhat
+				// non-standard but quick and dirty)
+				// 2) Exiting the date-time dialog by clicking the tick. Then we check whether
+				// the status field was preset with the not-found text. If yes it stays a not found
+				// but the date is prepended
+				// TODO: The functions for extracting the date and the found/not-found text should not be in the GUI
+				int retCode = dc.execute();
+				if (retCode == ewe.ui.FormBase.IDOK &amp;&amp; !chcStatus.getText().endsWith(MyLocale.getMsg(319, &quot;not Found&quot;))) {
+					chcStatus.setText(MyLocale.getMsg(msgNr, &quot;Found&quot;) + &quot; &quot; + Convert.toString(dc.year) + &quot;-&quot; + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot; + MyLocale.formatLong(dc.day, &quot;00&quot;) + &quot; &quot; + dc.time);
+					dirtyDetails = true;
+				} else if (chcStatus.getText().length() == 0 || (retCode == ewe.ui.FormBase.IDOK &amp;&amp; chcStatus.getText().endsWith(MyLocale.getMsg(319, &quot;not Found&quot;)))) {
+					chcStatus.setText(Convert.toString(dc.year) + &quot;-&quot; + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot; + MyLocale.formatLong(dc.day, &quot;00&quot;) + &quot; &quot; + dc.time + &quot; &quot; + MyLocale.getMsg(319, &quot;not Found&quot;));
+					dirtyDetails = true;
+				}
+			} else if (ev.target == btnHiddenDate) {
+				DateChooser.dayFirst = true;
+				final DateChooser dc = new DateChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(329, &quot;Hidden date&quot;);
+				dc.setPreferredSize(240, 240);
+				if (inpHidden.getText().length() == 10)
+					try {
+						dc.setDate(new Time(Convert.parseInt(inpHidden.getText().substring(8)), Convert.parseInt(inpHidden.getText().substring(5, 7)), Convert.parseInt(inpHidden.getText().substring(0, 4))));
+					} catch (NumberFormatException e) {
+						dc.reset(new Time());
+					}
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpHidden.setText(Convert.toString(dc.year) + &quot;-&quot; + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot; + MyLocale.formatLong(dc.day, &quot;00&quot;));
+					dirtyDetails = true;
+					// profile.hasUnsavedChanges=true;
+				}
+			} else if (ev.target == btnTerr) {
+				int returnValue;
+				final TerrDiffForm tdf = new TerrDiffForm(true, decodeTerrDiff(btnTerr, MyLocale.getMsg(1001, &quot;T&quot;), CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))));
+				returnValue = tdf.execute();
+				if (returnValue == 1) {
+					btnTerr.setText(MyLocale.getMsg(1001, &quot;T&quot;) + &quot;: &quot; + CacheTerrDiff.longDT(tdf.getDT()));
+					dirtyDetails = true;
+				}
+			} else if (ev.target == btnDiff) {
+				int returnValue;
+				final TerrDiffForm tdf = new TerrDiffForm(false, decodeTerrDiff(btnDiff, MyLocale.getMsg(1001, &quot;D&quot;), CacheType.isCacheWpt(CacheType.guiSelect2Cw(chcType.getInt()))));
 
-                returnValue = tdf.execute();
-                if (returnValue == 1) {
-                    btnDiff.setText(MyLocale.getMsg(1000, &quot;D&quot;) + &quot;: &quot;
-                            + CacheTerrDiff.longDT(tdf.getDT()));
-                    dirtyDetails = true;
-                }
-            }
-            ev.consumed = true;
-        }
-    }
+				returnValue = tdf.execute();
+				if (returnValue == 1) {
+					btnDiff.setText(MyLocale.getMsg(1000, &quot;D&quot;) + &quot;: &quot; + CacheTerrDiff.longDT(tdf.getDT()));
+					dirtyDetails = true;
+				}
+			}
+			ev.consumed = true;
+		}
+	}
 
 	/** allow user input on control item */
 	private void activateControl(final Control ctrl) {
@@ -751,39 +708,39 @@
 	}
 
 	public void saveDirtyWaypoint() {
-		//FIXME: here we should check if the data is now different from what it used to be when calling the details panel instead of relying on dirty flags
-		//FIXME: take care of renaming waypoints
-		//FIXME: add method to convert back text of difficulty &amp; terrain buttons
-		//FIXME: check if manual changes have converted a cache from incomplete to complete
+		// FIXME: here we should check if the data is now different from what it used to be when calling the details panel instead of relying on dirty flags
+		// FIXME: take care of renaming waypoints
+		// FIXME: add method to convert back text of difficulty &amp; terrain buttons
+		// FIXME: check if manual changes have converted a cache from incomplete to complete
 
 		// We have to update two objects: thisCache (a CacheHolderDetail) which
 		// contains
 		// the full cache which will be written to the cache.xml file AND
 		// the CacheHolder object which sits in cacheDB
-		//FIXME: so how do we do this??
+		// FIXME: so how do we do this??
 
-		int msgNr=318; // normal found
-    	if (cache.getType() == CacheType.CW_TYPE_WEBCAM) { msgNr=361;}
-    	else if (cache.getType() == CacheType.CW_TYPE_EVENT 
-    			|| cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) { msgNr=355;}
+		int msgNr = 318; // normal found
+		if (cache.getType() == CacheType.CW_TYPE_WEBCAM) {
+			msgNr = 361;
+		} else if (cache.getType() == CacheType.CW_TYPE_EVENT || cache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+			msgNr = 355;
+		}
 
 		// Strip the found message if the status contains a date
-		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, &quot;Found&quot;)) &amp;&amp;
-			chcStatus.getText().length() &gt;= MyLocale.getMsg(msgNr, &quot;Found&quot;).length() + 11) {
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, &quot;Found&quot;)) &amp;&amp; chcStatus.getText().length() &gt;= MyLocale.getMsg(msgNr, &quot;Found&quot;).length() + 11) {
 			cache.setCacheStatus(chcStatus.getText().substring(MyLocale.getMsg(msgNr, &quot;Found&quot;).length() + 1));
 		} else {
 			cache.setCacheStatus(chcStatus.getText());
 		}
 
-		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, &quot;Found&quot;)) ||
-			(cache.getCacheStatus().length() == 10 || cache.getCacheStatus().length() == 16) &amp;&amp; cache.getCacheStatus().charAt(4) == '-') {
+		if (chcStatus.getText().startsWith(MyLocale.getMsg(msgNr, &quot;Found&quot;)) || (cache.getCacheStatus().length() == 10 || cache.getCacheStatus().length() == 16) &amp;&amp; cache.getCacheStatus().charAt(4) == '-') {
 			// Use same heuristic condition as in setDetails(CacheHolder) to
 			// determine, if this
 			// cache
 			// has to considered as found.
 			cache.setFound(true);
-		}
-		else cache.setFound(false);
+		} else
+			cache.setFound(false);
 
 		if (!cache.isAddiWpt()) {
 			cache.setCacheOwner(inpOwner.getText().trim());
@@ -791,13 +748,7 @@
 		cache.setOwned(cache.getCacheStatus().equals(MyLocale.getMsg(320, &quot;Owner&quot;)));
 		// Avoid setting is_owned if alias is empty and username is empty
 		if (!cache.is_owned()) {
-			cache.setOwned(
-					(!pref.myAlias.equals(&quot;&quot;) &amp;&amp;
-						pref.myAlias.equals(cache.getCacheOwner()))
-					||
-					(!pref.myAlias2.equals(&quot;&quot;) &amp;&amp;
-						pref.myAlias2.equals(cache.getCacheOwner()))
-					);
+			cache.setOwned((!pref.myAlias.equals(&quot;&quot;) &amp;&amp; pref.myAlias.equals(cache.getCacheOwner())) || (!pref.myAlias2.equals(&quot;&quot;) &amp;&amp; pref.myAlias2.equals(cache.getCacheOwner())));
 		}
 		cache.setBlack(blackStatus);
 		final String oldWaypoint = cache.getWayPoint();
@@ -815,7 +766,6 @@
 		if (cache.getWayPoint().length() &lt; 2)
 			cache.setWayPoint(cache.getWayPoint() + &quot; &quot;);
 		cache.setCacheName(inpName.getText().trim());
-		cache.setLatLon(cache.pos.toString());
 		if (!cache.isAddiWpt()) {
 			cache.setDateHidden(inpHidden.getText().trim());
 		}
@@ -833,51 +783,57 @@
 		 * - the cachetype changed from addi-&gt;normal or from normal-&gt;addi
 		 * - the old cachetype or the new cachetype were 'addi' and the waypointname has changed
 		 */
-		if (CacheType.isAddiWpt(cache.getType()) != CacheType.isAddiWpt(oldType) ||
-			((CacheType.isAddiWpt(cache.getType()) || CacheType.isAddiWpt(oldType)) &amp;&amp; !cache.getWayPoint().equals(oldWaypoint))) {
+		if (CacheType.isAddiWpt(cache.getType()) != CacheType.isAddiWpt(oldType) || ((CacheType.isAddiWpt(cache.getType()) || CacheType.isAddiWpt(oldType)) &amp;&amp; !cache.getWayPoint().equals(oldWaypoint))) {
 			// If we changed the type to addi, check that a parent exists
-			//FIXME: if cache was renamed we need to rebuild CacheDB.hashDB first
+			// FIXME: if cache was renamed we need to rebuild CacheDB.hashDB first
 			profile.buildReferences();
 		} else {
 			// set status also on addi wpts
 			cache.setAttributesToAddiWpts();
 		}
 		if (!cache.isAddiWpt()) {
-			cache.setHard(decodeTerrDiff(btnDiff,MyLocale.getMsg(1000, &quot;D&quot;),cache.isCacheWpt()));
-			cache.setTerrain(decodeTerrDiff(btnTerr,MyLocale.getMsg(1001, &quot;T&quot;),cache.isCacheWpt()));
+			cache.setHard(decodeTerrDiff(btnDiff, MyLocale.getMsg(1000, &quot;D&quot;), cache.isCacheWpt()));
+			cache.setTerrain(decodeTerrDiff(btnTerr, MyLocale.getMsg(1001, &quot;T&quot;), cache.isCacheWpt()));
 		}
 		dirtyNotes = false;
 		dirtyDetails = false;
 		needsTableUpdate = false;
 		cache.getCacheDetails(false).hasUnsavedChanges = true;
-		if (!oldWaypoint.equals(cache.getWayPoint())){
-		 // Delete old XML - File
-			cache.getCacheDetails(false).deleteFile(Global.getProfile().dataDir+oldWaypoint+&quot;.xml&quot;);
+		if (!oldWaypoint.equals(cache.getWayPoint())) {
+			// Delete old XML - File
+			cache.getCacheDetails(false).deleteFile(Global.getProfile().dataDir + oldWaypoint + &quot;.xml&quot;);
 		}
 	}
 
 	/**
 	 * convert the string displayed in the terrain in difficulty buttons to a byte for intrernal use&lt;br&gt;
 	 * assumes that the relevant information will at positions 3 and 5 in a 0 indexed string
-	 * @param button button control to get the text from
-	 * @param td localized string for abbreviation of terrain or difficulty
-	 * @param isCache true if waypoint is a cache, false for addis and custom
+	 * 
+	 * @param button
+	 *            button control to get the text from
+	 * @param td
+	 *            localized string for abbreviation of terrain or difficulty
+	 * @param isCache
+	 *            true if waypoint is a cache, false for addis and custom
 	 * @return 0 for additional or custum waypoints, -1 for caches if td is not valid, parsed byte otherwise
 	 */
 	private byte decodeTerrDiff(mButton button, String td, boolean isCache) {
 		// terrain and difficulty are always unset for non cache waypoints
-		if (! isCache) return CacheTerrDiff.CW_DT_UNSET;
+		if (!isCache)
+			return CacheTerrDiff.CW_DT_UNSET;
 
 		// cut off beginning of string
-		String buttonText = button.getText().substring(td.length()+2);
+		String buttonText = button.getText().substring(td.length() + 2);
 		// we now should have a string of length 3
-		if (buttonText.length() != 3) return -1;
+		if (buttonText.length() != 3)
+			return -1;
 
 		final StringBuffer tdv = new StringBuffer(2);
-		buttonText=tdv.append(buttonText.charAt(0)).append(buttonText.charAt(2)).toString();
+		buttonText = tdv.append(buttonText.charAt(0)).append(buttonText.charAt(2)).toString();
 
 		// unset value is invalid
-		if (&quot;--&quot;.equals(buttonText)) return CacheTerrDiff.CW_DT_ERROR;
+		if (&quot;--&quot;.equals(buttonText))
+			return CacheTerrDiff.CW_DT_ERROR;
 
 		return Byte.parseByte(buttonText);
 	}
@@ -887,18 +843,14 @@
 		private final DispPanel disp = new DispPanel();
 		private final mButton btCancel;
 
-
 		TravelbugInCacheScreen(String text, String title) {
 			super();
 			this.setTitle(title);
 			this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
 			disp.setHtml(text);
-			final ScrollBarPanel sbp = new MyScrollBarPanel(disp,
-					ScrollablePanel.NeverShowHorizontalScrollers);
+			final ScrollBarPanel sbp = new MyScrollBarPanel(disp, ScrollablePanel.NeverShowHorizontalScrollers);
 			this.addLast(sbp);
-			this.addLast(
-					btCancel = new mButton(MyLocale.getMsg(3000, &quot;Close&quot;)),
-					CellConstants.DONTSTRETCH, CellConstants.FILL);
+			this.addLast(btCancel = new mButton(MyLocale.getMsg(3000, &quot;Close&quot;)), CellConstants.DONTSTRETCH, CellConstants.FILL);
 		}
 
 		public void onEvent(Event ev) {
@@ -917,10 +869,8 @@
 
 			DispPanel() {
 				super();
-				tbMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(
-						6016, &quot;Pick up Travelbug&quot;));
-				tbMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6017,
-						&quot;Drop Travelbug&quot;));
+				tbMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6016, &quot;Pick up Travelbug&quot;));
+				tbMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6017, &quot;Drop Travelbug&quot;));
 				mnuPopup = new Menu(tbMenuItems, &quot;&quot;);
 			}
 
@@ -946,8 +896,7 @@
 						tbjList = new TravelbugJourneyList();
 						tbjList.readTravelbugsFile();
 						// Add the tb to this list
-						tbjList.addTbPickup(tb, Global.getProfile().name,
-								cache.getWayPoint());
+						tbjList.addTbPickup(tb, Global.getProfile().name, cache.getWayPoint());
 						tbjList.saveTravelbugsFile();
 						setHtml(cache.getCacheDetails(true).Travelbugs.toHtml());
 						repaint();
@@ -958,14 +907,12 @@
 					tbjList = new TravelbugJourneyList();
 					tbjList.readTravelbugsFile();
 					TravelbugList tbl = tbjList.getMyTravelbugs();
-					TravelbugScreen tbs = new TravelbugScreen(tbl, MyLocale
-							.getMsg(6017, &quot;Drop a travelbug&quot;), false);
+					TravelbugScreen tbs = new TravelbugScreen(tbl, MyLocale.getMsg(6017, &quot;Drop a travelbug&quot;), false);
 					tbs.execute();
 					if (tbs.selectedItem &gt;= 0) {
 						Travelbug tb = tbl.getTB(tbs.selectedItem);
 						cache.getCacheDetails(true).Travelbugs.add(tb);
-						tbjList.addTbDrop(tb, Global.getProfile().name,
-								cache.getWayPoint());
+						tbjList.addTbDrop(tb, Global.getProfile().name, cache.getWayPoint());
 					}
 					tbjList.saveTravelbugsFile();
 					cache.setHas_bugs(cache.getCacheDetails(true).Travelbugs.size() &gt; 0);
@@ -993,8 +940,7 @@
 			resizable = false;
 			setTitle(MyLocale.getMsg(31415, &quot;D &amp; T&quot;));
 
-			addNext(new mLabel(terrain ? MyLocale.getMsg(31415, &quot;Terrain&quot;)
-					: MyLocale.getMsg(31415, &quot;Difficulty&quot;)));
+			addNext(new mLabel(terrain ? MyLocale.getMsg(31415, &quot;Terrain&quot;) : MyLocale.getMsg(31415, &quot;Difficulty&quot;)));
 			addLast(mcDT);
 			addButton(btnOk);
 			addButton(btnCancel);

Modified: branches/r1.2/src/CacheWolf/Extractor.java
===================================================================
--- branches/r1.2/src/CacheWolf/Extractor.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Extractor.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,104 +1,124 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+/**
+ * This is a powerfull class that is used very often. It is quicker than
+ * XML parsing and should be used whenever possible to find and extract
+ * parts of a string in a string.
+ */
+public class Extractor {
+	int _startOffset;
+	String _searchText;
+	String start;
+	String end;
+	boolean _betweenonly;
+	public static boolean INCLUDESTARTEND = false;
+	public static boolean EXCLUDESTARTEND = true;
 
-/**
-*	This is a powerfull class that is used very often. It is quicker than
-*	XML parsing and should be used whenever possible to find and extract
-*	parts of a string in a string.
-*/
-public class Extractor  {
-		int startOffset; // No initialisation needed, done in constructor
-		String searchText;
-		String start;
-		String end;
-		String tst;
-		boolean betweenonly;
-		public static boolean INCLUDESTARTEND = false;
-		public static boolean EXCLUDESTARTEND = true;
-		/**
-		*	Create an extractor.
-		*	sTxt = The string to search through.&lt;br&gt;
-		*	st = The string that denotes the start of the string to extract&lt;br&gt;
-		*	e = The string that denotes the end of the string to extract&lt;br&gt;
-		*	sOff = The beginning offset from which to start the search in sTxt&lt;br&gt;
-		*	only = if false the string returned will inlcude st and e; if true
-		*	it will not include st and e.
-		*
-		*/
-		public Extractor(String sTxt, String st, String e, int sOff, boolean only){
-			startOffset = sOff;
-			searchText = sTxt;
-			end = e;
-			start = st;
-			betweenonly = only;
-		}
-		
-		/**
-		 * Mehtod to set the source text to be searched through
-		 * 
-		 */
-		public void setSource(String sTxt){
-			searchText = sTxt;
-			startOffset = 0;
-		}
-		
-		/**
-		* Method that informs if the search has encountered the end of the string
-		* that is being searched through.
-		*/
-		public boolean endOfSearch(){
-			if(searchText == null || startOffset &gt;= searchText.length()) return true;
-			else return false;
-		}
-		
-		/**
-		*	Method to find the next occurance of a string that is enclosed by
-		*	that start (st) and end string (e). if end is not found the string
-		*	is returned til it's end.
-		*/
-		public String findNext(){
-			if (searchText == null) return new String(); //maby null should 
-			int idxStart = searchText.indexOf(start,startOffset);
-			int idxEnd = searchText.indexOf(end, idxStart+start.length());
-			if(idxEnd == -1) idxEnd = searchText.length(); //index counts from zero length from 1 but the last char is not included in substr and substr accepts length +1 (but not length+2)
-			startOffset = idxEnd;
-			tst = new String();
-			if(idxStart &gt; -1){
-				if(betweenonly == false){
-					if (idxEnd+end.length() &gt;= searchText.length()) 
-						 tst = searchText.substring(idxStart);
-					else tst = searchText.substring(idxStart,idxEnd+end.length());
-				}else{ 
-					tst = searchText.substring(idxStart+start.length(),idxEnd);
+	/**
+	 * Create an extractor.
+	 * searchText = The string to search through.&lt;br&gt;
+	 * st = The string that denotes the start of the string to extract&lt;br&gt;
+	 * e = The string that denotes the end of the string to extract&lt;br&gt;
+	 * startOffset = The beginning offset from which to start the search in sTxt&lt;br&gt;
+	 * betweenonly = if false the string returned will inlcude st and e;
+	 * if true it will not include st and e.
+	 * 
+	 */
+	public Extractor(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	/**
+	 * Mehtod to set the source text to be searched through
+	 * 
+	 */
+	public void set(String searchText, String st, String e, int startOffset, boolean betweenonly) {
+		_startOffset = startOffset;
+		_searchText = searchText;
+		end = e;
+		start = st;
+		_betweenonly = betweenonly;
+	}
+
+	public void set(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+	}
+
+	public void set(String searchText, int startOffset) {
+		_searchText = searchText;
+		_startOffset = startOffset;
+	}
+
+	public String findFirst(String searchText) {
+		_searchText = searchText;
+		_startOffset = 0;
+		return findNext();
+	}
+
+	public String findNext(String startText) {
+		start = startText;
+		return findNext();
+	}
+
+	public String findNext(String startText, String endText) {
+		start = startText;
+		end = endText;
+		return findNext();
+	}
+
+	/**
+	 * Method to find the next occurance of a string that is enclosed by
+	 * that start (st) and end string (e).
+	 * if end is not found empty string is returned.
+	 */
+	public String findNext() {
+		String ret = &quot;&quot;;
+		if (_searchText != null &amp;&amp; _searchText.length() &gt; _startOffset + start.length() + end.length()) {
+			int idxStart = _searchText.indexOf(start, _startOffset);
+			int idxEnd = -1;
+			if (idxStart &gt; -1) {
+				idxEnd = _searchText.indexOf(end, idxStart + start.length());
+				if (idxEnd &gt; -1) {
+					_startOffset = idxEnd;
+					ret = _searchText.substring(idxStart + start.length(), idxEnd);
+					if (!this._betweenonly)
+						ret = start + ret + end;
 				}
-			} else {
-				startOffset = searchText.length();
 			}
-			return tst;
+			if (idxEnd == -1) {
+				_startOffset = _searchText.length(); // Schluss
+			}
 		}
+		return ret;
+	}
 }

Modified: branches/r1.2/src/CacheWolf/Filter.java
===================================================================
--- branches/r1.2/src/CacheWolf/Filter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Filter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,31 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import CacheWolf.imp.KMLImporter;
-import CacheWolf.navi.TransformCoordinates;
 
 import com.stevesoft.ewe_pat.Regex;
 
@@ -40,21 +40,22 @@
 import ewe.util.Vector;
 
 /**
-*	Class that actually filters the cache database.&lt;br&gt;
-*	The class that uses this filter must set the different public variables.
-*   @author BilboWolf (optimiert von salzkammergut)
-*/
-public class Filter{
-	public static final int FILTER_INACTIVE=0;
-	public static final int FILTER_ACTIVE=1;
-	public static final int FILTER_CACHELIST=2;
-	public static final int FILTER_MARKED_ONLY=3;
-	
+ * Class that actually filters the cache database.&lt;br&gt;
+ * The class that uses this filter must set the different public variables.
+ * 
+ * @author BilboWolf (optimiert von salzkammergut)
+ */
+public class Filter {
+	public static final int FILTER_INACTIVE = 0;
+	public static final int FILTER_ACTIVE = 1;
+	public static final int FILTER_CACHELIST = 2;
+	public static final int FILTER_MARKED_ONLY = 3;
+
 	/** Indicator whether a filter is inverted */
-	//public static boolean filterInverted=false;
+	// public static boolean filterInverted=false;
 	/** Indicator whether a filter is active. Used in status bar to indicate filter status */
-	//public static int filterActive=FILTER_INACTIVE;
-	
+	// public static int filterActive=FILTER_INACTIVE;
+
 	private static final int SMALLER = -1;
 	private static final int EQUAL = 0;
 	private static final int GREATER = 1;
@@ -75,123 +76,125 @@
 	private static final int NW = 8192;
 	private static final int NNW = 16384;
 	private static final int S = 32768;
-	private static final int ROSE_ALL= N|NNE|NE|ENE|E|ESE|SE|SSE|SSW|SW|WSW|W|WNW|NW|NNW|S;
+	private static final int ROSE_ALL = N | NNE | NE | ENE | E | ESE | SE | SSE | SSW | SW | WSW | W | WNW | NW | NNW | S;
 
 	private int distdirec = 0;
 	private int diffdirec = 0;
 	private int terrdirec = 0;
-	
+
 	String[] byVec;
-	
-	
+
 	private int roseMatchPattern;
 	private boolean hasRoseMatchPattern;
 	private int typeMatchPattern;
 	private boolean hasTypeMatchPattern;
 	private int sizeMatchPattern;
 	private boolean hasSizeMatchPattern;
-	
+
 	private boolean foundByMe;
 	private boolean notFoundByMe;
 
 	private String cacheStatus;
 	private boolean useRegexp;
 	private boolean filterNoCoord;
-	
+
 	private boolean ownedByMe;
 	private boolean notOwnedByMe;
 
 	double fscDist;
 	double fscTerr;
 	double fscDiff;
-	
+
 	private boolean archived = false;
 	private boolean notArchived = false;
-	
-	private boolean available=false;
+
+	private boolean available = false;
 	private boolean notAvailable = false;
-	double pi180=java.lang.Math.PI / 180.0;
+	double pi180 = java.lang.Math.PI / 180.0;
 
-	private long[] attributesPattern = {0l,0l,0l,0l};
+	private long[] attributesPattern = { 0l, 0l, 0l, 0l };
 	private int attributesChoice = 0;
-	
+
 	/**
-	*	Apply a route filter. Each waypoint is on a seperate line.
-	*	We use a regex method to allow for different formats of waypoints:
-	*	possible is currently: DD MM.mmm
-	*/
-	public void doFilterRoute(File routeFile, double distance){
+	 * Apply a route filter. Each waypoint is on a seperate line.
+	 * We use a regex method to allow for different formats of waypoints:
+	 * possible is currently: DD MM.mmm
+	 */
+	public void doFilterRoute(File routeFile, double distance) {
 		Global.getProfile().selectionChanged = true;
-	    CacheDB cacheDB=Global.getProfile().cacheDB;
-		//load file into a vector:
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		// load file into a vector:
 		Vector wayPoints = new Vector();
 		Regex rex = new Regex(&quot;(N|S).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3}).*?(E|W).*?([0-9]{1,2}).*?([0-9]{1,3})(,|.)([0-9]{1,3})&quot;);
 		CWPoint cwp, fromPoint, toPoint;
 		CacheHolder ch;
-		double lat,lon, calcDistance = 0;
-		try{
-			if((routeFile.getFullPath()).indexOf(&quot;.kml&quot;) &gt; 0){
+		double lat, lon, calcDistance = 0;
+		try {
+			if ((routeFile.getFullPath()).indexOf(&quot;.kml&quot;) &gt; 0) {
 				KMLImporter kml = new KMLImporter(routeFile.getFullPath());
 				kml.importFile();
 				wayPoints = kml.getPoints();
 			} else {
 				FileReader in = new FileReader(routeFile);
-				String line; 
-				while((line = in.readLine()) != null){
+				String line;
+				while ((line = in.readLine()) != null) {
 					rex.search(line);
 					// parse the route file
-					if(rex.didMatch()){
-						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3))/60 + Convert.toDouble(rex.stringMatched(5))/60000;
-						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8))/60 + Convert.toDouble(rex.stringMatched(10))/60000;
-					
-						if(rex.stringMatched(1).equals(&quot;S&quot;) || rex.stringMatched(1).equals(&quot;s&quot;)) lat = -lat;
-						if(rex.stringMatched(6).equals(&quot;W&quot;) || rex.stringMatched(6).equals(&quot;w&quot;)) lon = -lon;	
-					
+					if (rex.didMatch()) {
+						lat = Convert.toDouble(rex.stringMatched(2)) + Convert.toDouble(rex.stringMatched(3)) / 60 + Convert.toDouble(rex.stringMatched(5)) / 60000;
+						lon = Convert.toDouble(rex.stringMatched(7)) + Convert.toDouble(rex.stringMatched(8)) / 60 + Convert.toDouble(rex.stringMatched(10)) / 60000;
+
+						if (rex.stringMatched(1).equals(&quot;S&quot;) || rex.stringMatched(1).equals(&quot;s&quot;))
+							lat = -lat;
+						if (rex.stringMatched(6).equals(&quot;W&quot;) || rex.stringMatched(6).equals(&quot;w&quot;))
+							lon = -lon;
+
 						cwp = new CWPoint(lat, lon);
-						
+
 						wayPoints.add(cwp);
 					}
 				}
 			}
-			//initialise database
-			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			// initialise database
+			for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 				ch = cacheDB.get(i);
 				ch.in_range = false;
-				//cacheDB.set(i, ch);
+				// cacheDB.set(i, ch);
 			}
 			// for each segment of the route...
-			for(int z=0;z&lt;wayPoints.size()-1;z++){
+			for (int z = 0; z &lt; wayPoints.size() - 1; z++) {
 				fromPoint = new CWPoint();
 				toPoint = new CWPoint();
-				fromPoint = (CWPoint)wayPoints.get(z);
-				toPoint = (CWPoint)wayPoints.get(z+1);
-				//... go through the current cache database
-				for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+				fromPoint = (CWPoint) wayPoints.get(z);
+				toPoint = (CWPoint) wayPoints.get(z + 1);
+				// ... go through the current cache database
+				for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 					ch = cacheDB.get(i);
-					cwp = new CWPoint(ch.getLatLon(), TransformCoordinates.CW);
+					cwp = new CWPoint(ch.getPos());
 					calcDistance = DistToSegment(fromPoint, toPoint, cwp);
-					calcDistance = (calcDistance*180*60)/java.lang.Math.PI;
+					calcDistance = (calcDistance * 180 * 60) / java.lang.Math.PI;
 					calcDistance = calcDistance * 1.852;
-					if(calcDistance &lt;= distance) {
+					if (calcDistance &lt;= distance) {
 						ch.in_range = true;
 					}
 				} // for database
 			} // for segments
-			for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+			for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 				ch = cacheDB.get(i);
-				if(ch.is_filtered() == false &amp;&amp; ch.in_range == false) ch.setFiltered(true);
+				if (ch.is_filtered() == false &amp;&amp; ch.in_range == false)
+					ch.setFiltered(true);
 			}
-		}catch(FileNotFoundException fnex){
+		} catch (FileNotFoundException fnex) {
 			(new MessageBox(&quot;Error&quot;, &quot;File not found&quot;, FormBase.OKB)).execute();
-		}catch(IOException ioex){
+		} catch (IOException ioex) {
 			(new MessageBox(&quot;Error&quot;, &quot;Problem reading file!&quot;, FormBase.OKB)).execute();
 		}
 	}
-	
+
 	/**
-	*	Method to calculate the distance of a point to a segment
-	*/
-	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp){
+	 * Method to calculate the distance of a point to a segment
+	 */
+	private double DistToSegment(CWPoint fromPoint, CWPoint toPoint, CWPoint cwp) {
 		double dist = 0;
 		double px = cwp.lonDec * pi180;
 		double py = cwp.latDec * pi180;
@@ -201,91 +204,114 @@
 		double Y2 = toPoint.latDec * pi180;
 		double dx = X2 - X1;
 		double dy = Y2 - Y1;
-		if(dx == 0 &amp;&amp; dy == 0){
+		if (dx == 0 &amp;&amp; dy == 0) {
 			// have a point and not a segment!
 			dx = px - X1;
 			dy = py - Y1;
-			return java.lang.Math.sqrt(dx*dx + dy*dy);
+			return java.lang.Math.sqrt(dx * dx + dy * dy);
 		}
-		dist = Matrix.cross(X1,Y1,X2,Y2,px,py) / Matrix.dist(X1,Y1,X2,Y2);
-		double dot1 = Matrix.dot(X1,Y1,X2,Y2,px,py);
-		if(dot1 &gt; 0) return Matrix.dist(X2,Y2,px,py);
-		double dot2 = Matrix.dot(X2,Y2,X1,Y1,px,py);
-		if(dot2 &gt; 0) return Matrix.dist(X1,Y1,px,py);
+		dist = Matrix.cross(X1, Y1, X2, Y2, px, py) / Matrix.dist(X1, Y1, X2, Y2);
+		double dot1 = Matrix.dot(X1, Y1, X2, Y2, px, py);
+		if (dot1 &gt; 0)
+			return Matrix.dist(X2, Y2, px, py);
+		double dot2 = Matrix.dot(X2, Y2, X1, Y1, px, py);
+		if (dot2 &gt; 0)
+			return Matrix.dist(X1, Y1, px, py);
 		dist = java.lang.Math.abs(dist);
 		return dist;
-		
+
 	}
-	
+
 	/**
 	 * Set the filter from the filter data stored in the profile
 	 * (the filterscreen also updates the profile)
 	 */
 	public void setFilter() {
-		Profile profile=Global.getProfile();
-		archived     = profile.getFilterVar().charAt(0) == '1';
-		available    = profile.getFilterVar().charAt(1) == '1';
-		foundByMe    = profile.getFilterVar().charAt(2) == '1';
-		ownedByMe    = profile.getFilterVar().charAt(3) == '1';
-		notArchived  = profile.getFilterVar().charAt(4) == '1';
+		Profile profile = Global.getProfile();
+		archived = profile.getFilterVar().charAt(0) == '1';
+		available = profile.getFilterVar().charAt(1) == '1';
+		foundByMe = profile.getFilterVar().charAt(2) == '1';
+		ownedByMe = profile.getFilterVar().charAt(3) == '1';
+		notArchived = profile.getFilterVar().charAt(4) == '1';
 		notAvailable = profile.getFilterVar().charAt(5) == '1';
 		notFoundByMe = profile.getFilterVar().charAt(6) == '1';
 		notOwnedByMe = profile.getFilterVar().charAt(7) == '1';
-		cacheStatus  = profile.getFilterStatus();
-		useRegexp    = profile.getFilterUseRegexp();
+		cacheStatus = profile.getFilterStatus();
+		useRegexp = profile.getFilterUseRegexp();
 		filterNoCoord = profile.getFilterNoCoord();
-		
-		typeMatchPattern=CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
-		hasTypeMatchPattern=CacheType.hasTypeMatchPattern(typeMatchPattern);
-		roseMatchPattern=0;
-		String filterRose=profile.getFilterRose();
-		if (filterRose.charAt(0) == '1') roseMatchPattern|=NW;
-		if (filterRose.charAt(1) == '1') roseMatchPattern|=NNW;
-		if (filterRose.charAt(2) == '1') roseMatchPattern|=N;
-		if (filterRose.charAt(3) == '1') roseMatchPattern|=NNE;
-		if (filterRose.charAt(4) == '1') roseMatchPattern|=NE;
-		if (filterRose.charAt(5) == '1') roseMatchPattern|=ENE;
-		if (filterRose.charAt(6) == '1') roseMatchPattern|=E;
-		if (filterRose.charAt(7) == '1') roseMatchPattern|=ESE;
-		if (filterRose.charAt(8) == '1') roseMatchPattern|=SE;
-		if (filterRose.charAt(9) == '1') roseMatchPattern|=SSE;
-		if (filterRose.charAt(10) == '1') roseMatchPattern|=S;
-		if (filterRose.charAt(11) == '1') roseMatchPattern|=SSW;
-		if (filterRose.charAt(12) == '1') roseMatchPattern|=SW;
-		if (filterRose.charAt(13) == '1') roseMatchPattern|=WSW;
-		if (filterRose.charAt(14) == '1') roseMatchPattern|=W;
-		if (filterRose.charAt(15) == '1') roseMatchPattern|=WNW;
-		hasRoseMatchPattern=roseMatchPattern!=ROSE_ALL;
-		sizeMatchPattern=0;
-		String filterSize=profile.getFilterSize();
-		if (filterSize.charAt(0) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_MICRO;
-		if (filterSize.charAt(1) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_SMALL;
-		if (filterSize.charAt(2) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NORMAL;
-		if (filterSize.charAt(3) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_LARGE;
-		if (filterSize.charAt(4) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_VERYLARGE;
-		if (filterSize.charAt(5) == '1') sizeMatchPattern|=CacheSize.CW_FILTER_NONPHYSICAL;
-		hasSizeMatchPattern=sizeMatchPattern!=CacheSize.CW_FILTER_ALL;
-		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER; 
-		fscDist = Common.parseDouble(profile.getFilterDist().substring(1));  // Distance
-		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : 
-					(profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER );
-		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1));  // Difficulty
-		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : 
-				(profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER );
-		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1));  // Terrain
+
+		typeMatchPattern = CacheType.Type_FilterString2Type_FilterPattern(profile.getFilterType());
+		hasTypeMatchPattern = CacheType.hasTypeMatchPattern(typeMatchPattern);
+		roseMatchPattern = 0;
+		String filterRose = profile.getFilterRose();
+		if (filterRose.charAt(0) == '1')
+			roseMatchPattern |= NW;
+		if (filterRose.charAt(1) == '1')
+			roseMatchPattern |= NNW;
+		if (filterRose.charAt(2) == '1')
+			roseMatchPattern |= N;
+		if (filterRose.charAt(3) == '1')
+			roseMatchPattern |= NNE;
+		if (filterRose.charAt(4) == '1')
+			roseMatchPattern |= NE;
+		if (filterRose.charAt(5) == '1')
+			roseMatchPattern |= ENE;
+		if (filterRose.charAt(6) == '1')
+			roseMatchPattern |= E;
+		if (filterRose.charAt(7) == '1')
+			roseMatchPattern |= ESE;
+		if (filterRose.charAt(8) == '1')
+			roseMatchPattern |= SE;
+		if (filterRose.charAt(9) == '1')
+			roseMatchPattern |= SSE;
+		if (filterRose.charAt(10) == '1')
+			roseMatchPattern |= S;
+		if (filterRose.charAt(11) == '1')
+			roseMatchPattern |= SSW;
+		if (filterRose.charAt(12) == '1')
+			roseMatchPattern |= SW;
+		if (filterRose.charAt(13) == '1')
+			roseMatchPattern |= WSW;
+		if (filterRose.charAt(14) == '1')
+			roseMatchPattern |= W;
+		if (filterRose.charAt(15) == '1')
+			roseMatchPattern |= WNW;
+		hasRoseMatchPattern = roseMatchPattern != ROSE_ALL;
+		sizeMatchPattern = 0;
+		String filterSize = profile.getFilterSize();
+		if (filterSize.charAt(0) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_MICRO;
+		if (filterSize.charAt(1) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_SMALL;
+		if (filterSize.charAt(2) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NORMAL;
+		if (filterSize.charAt(3) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_LARGE;
+		if (filterSize.charAt(4) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_VERYLARGE;
+		if (filterSize.charAt(5) == '1')
+			sizeMatchPattern |= CacheSize.CW_FILTER_NONPHYSICAL;
+		hasSizeMatchPattern = sizeMatchPattern != CacheSize.CW_FILTER_ALL;
+		distdirec = profile.getFilterDist().charAt(0) == 'L' ? SMALLER : GREATER;
+		fscDist = Common.parseDouble(profile.getFilterDist().substring(1)); // Distance
+		diffdirec = profile.getFilterDiff().charAt(0) == 'L' ? SMALLER : (profile.getFilterDiff().charAt(0) == '=' ? EQUAL : GREATER);
+		fscDiff = Common.parseDouble(profile.getFilterDiff().substring(1)); // Difficulty
+		terrdirec = profile.getFilterTerr().charAt(0) == 'L' ? SMALLER : (profile.getFilterTerr().charAt(0) == '=' ? EQUAL : GREATER);
+		fscTerr = Common.parseDouble(profile.getFilterTerr().substring(1)); // Terrain
 		attributesPattern = profile.getFilterAttr();
 		attributesChoice = profile.getFilterAttrChoice();
 	}
-	
+
 	/**
-	*	Apply the filter. Caches that match a criteria are flagged
-	*	is_filtered = true. The table model is responsible for displaying or
-	*	not displaying a cache that is filtered.
-	*/
-	public void doFilter(){
-		CacheDB cacheDB=Global.getProfile().cacheDB;
+	 * Apply the filter. Caches that match a criteria are flagged
+	 * is_filtered = true. The table model is responsible for displaying or
+	 * not displaying a cache that is filtered.
+	 */
+	public void doFilter() {
+		CacheDB cacheDB = Global.getProfile().cacheDB;
 		Hashtable examinedCaches;
-		if (cacheDB.size()==0) return;
+		if (cacheDB.size() == 0)
+			return;
 		if (!hasFilter()) { // If the filter was completely reset, we can just clear it
 			clearFilter();
 			return;
@@ -293,13 +319,14 @@
 		Global.getProfile().selectionChanged = true;
 		CacheHolder ch;
 		examinedCaches = new Hashtable(cacheDB.size());
-		
-		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
-			if (examinedCaches.containsKey(ch)) continue;
-			
+			if (examinedCaches.containsKey(ch))
+				continue;
+
 			boolean filterCache = excludedByFilter(ch);
-			if (!filterCache &amp;&amp; ch.mainCache!=null &amp;&amp; CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
+			if (!filterCache &amp;&amp; ch.mainCache != null &amp;&amp; CacheType.hasMainTypeMatchPattern(typeMatchPattern)) {
 				if (examinedCaches.containsKey(ch.mainCache)) {
 					filterCache = ch.mainCache.is_filtered();
 				} else {
@@ -308,270 +335,261 @@
 					examinedCaches.put(ch.mainCache, null);
 				}
 			}
-			ch.setFiltered(filterCache);			
+			ch.setFiltered(filterCache);
 		}
 		Global.getProfile().setFilterActive(FILTER_ACTIVE);
 		examinedCaches = null;
-		//Global.getProfile().hasUnsavedChanges=true;
+		// Global.getProfile().hasUnsavedChanges=true;
 	}
 
 	public boolean excludedByFilter(CacheHolder ch) {
-		//Match once against type pattern and once against rose pattern
-		//Default is_filtered = false, means will be displayed!
-		//If cache does not match type or rose pattern then is_filtered is set to true
+		// Match once against type pattern and once against rose pattern
+		// Default is_filtered = false, means will be displayed!
+		// If cache does not match type or rose pattern then is_filtered is set to true
 		// and we proceed to next cache (no further tests needed)
-		//Then we check the other filter criteria one by one: As soon as one is found that
+		// Then we check the other filter criteria one by one: As soon as one is found that
 		// eliminates the cache (i.e. sets is_filtered to true), we can skip the other tests
 		// A cache is only displayed (i.e. is_filtered = false) if it meets all 9 filter criteria
-	    int cacheTypePattern;
-	    int cacheRosePattern;
-	    int cacheSizePattern;
-	    double dummyd1;
-	    boolean cacheFiltered=false;
-	    do {
-	        ///////////////////////////////
-	        // Filter criterium 1: Cache type
-	        ///////////////////////////////
-	        if (hasTypeMatchPattern) { // Only do the checks if we have a filter
-	        	cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
-		        if ((cacheTypePattern &amp; typeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 2: Bearing from centre
-	        ///////////////////////////////
-	        // The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
-	        // By using else if we can reduce the number of comparisons from 16 to just over 8
-	        // By first checking the first letter, we can reduce the average number further to
-	        // just under 5
-	        if (hasRoseMatchPattern) {
-		        if (ch.getBearing().startsWith(&quot;N&quot;)) {
-			        if (ch.getBearing().equals(&quot;NW&quot;))
-				        cacheRosePattern = NW;
-			        else if (ch.getBearing().equals(&quot;NNW&quot;))
-				        cacheRosePattern = NNW;
-			        else if (ch.getBearing().equals(&quot;N&quot;))
-				        cacheRosePattern = N;
-			        else if (ch.getBearing().equals(&quot;NNE&quot;))
-				        cacheRosePattern = NNE;
-			        else
-				        cacheRosePattern = NE;
-		        } else if (ch.getBearing().startsWith(&quot;E&quot;)) {
-			        if (ch.getBearing().equals(&quot;ENE&quot;))
-				        cacheRosePattern = ENE;
-			        else if (ch.getBearing().equals(&quot;E&quot;))
-				        cacheRosePattern = E;
-			        else
-				        cacheRosePattern = ESE;
-		        } else if (ch.getBearing().startsWith(&quot;S&quot;)) {
-			        if (ch.getBearing().equals(&quot;SW&quot;))
-				        cacheRosePattern = SW;
-			        else if (ch.getBearing().equals(&quot;SSW&quot;))
-				        cacheRosePattern = SSW;
-			        else if (ch.getBearing().equals(&quot;S&quot;))
-				        cacheRosePattern = S;
-			        else if (ch.getBearing().equals(&quot;SSE&quot;))
-				        cacheRosePattern = SSE;
-			        else
-				        cacheRosePattern = SE;
-		        } else {
-			        if (ch.getBearing().equals(&quot;WNW&quot;))
-				        cacheRosePattern = WNW;
-			        else if (ch.getBearing().equals(&quot;W&quot;))
-				        cacheRosePattern = W;
-			        else if (ch.getBearing().equals(&quot;WSW&quot;))
-				        cacheRosePattern = WSW;
-			        else
-				        cacheRosePattern = 0;
-		        }
-		        if ((cacheRosePattern != 0) &amp;&amp; ((cacheRosePattern &amp; roseMatchPattern) == 0)) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 3: Distance
-	        ///////////////////////////////
-	        if (fscDist &gt; 0.0) {
-		        dummyd1 = ch.kilom;
-		        if (distdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDist) {
-			        cacheFiltered = true; break;
-		        }
-		        if (distdirec == GREATER &amp;&amp; dummyd1 &lt; fscDist) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 4: Difficulty
-	        ///////////////////////////////
-	        if (fscDiff &gt; 0.0) {
-		        dummyd1 = ch.getHard() / 10D;
-		        if (diffdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == EQUAL &amp;&amp; dummyd1 != fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-		        if (diffdirec == GREATER &amp;&amp; dummyd1 &lt; fscDiff) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 5: Terrain
-	        ///////////////////////////////
-	        if (fscTerr &gt; 0.0) {
-	        	dummyd1 = ch.getTerrain() / 10D;
-		        if (terrdirec == SMALLER &amp;&amp; dummyd1 &gt; fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == EQUAL &amp;&amp; dummyd1 != fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-		        if (terrdirec == GREATER &amp;&amp; dummyd1 &lt; fscTerr) {
-			        cacheFiltered = true; break;
-		        }
-	        }
+		int cacheTypePattern;
+		int cacheRosePattern;
+		int cacheSizePattern;
+		double dummyd1;
+		boolean cacheFiltered = false;
+		do {
+			// /////////////////////////////
+			// Filter criterium 1: Cache type
+			// /////////////////////////////
+			if (hasTypeMatchPattern) { // Only do the checks if we have a filter
+				cacheTypePattern = CacheType.getCacheTypePattern(ch.getType());
+				if ((cacheTypePattern &amp; typeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 2: Bearing from centre
+			// /////////////////////////////
+			// The optimal number of comparisons to identify one of 16 objects is 4 (=log2(16))
+			// By using else if we can reduce the number of comparisons from 16 to just over 8
+			// By first checking the first letter, we can reduce the average number further to
+			// just under 5
+			if (hasRoseMatchPattern) {
+				if (ch.getBearing().startsWith(&quot;N&quot;)) {
+					if (ch.getBearing().equals(&quot;NW&quot;))
+						cacheRosePattern = NW;
+					else if (ch.getBearing().equals(&quot;NNW&quot;))
+						cacheRosePattern = NNW;
+					else if (ch.getBearing().equals(&quot;N&quot;))
+						cacheRosePattern = N;
+					else if (ch.getBearing().equals(&quot;NNE&quot;))
+						cacheRosePattern = NNE;
+					else
+						cacheRosePattern = NE;
+				} else if (ch.getBearing().startsWith(&quot;E&quot;)) {
+					if (ch.getBearing().equals(&quot;ENE&quot;))
+						cacheRosePattern = ENE;
+					else if (ch.getBearing().equals(&quot;E&quot;))
+						cacheRosePattern = E;
+					else
+						cacheRosePattern = ESE;
+				} else if (ch.getBearing().startsWith(&quot;S&quot;)) {
+					if (ch.getBearing().equals(&quot;SW&quot;))
+						cacheRosePattern = SW;
+					else if (ch.getBearing().equals(&quot;SSW&quot;))
+						cacheRosePattern = SSW;
+					else if (ch.getBearing().equals(&quot;S&quot;))
+						cacheRosePattern = S;
+					else if (ch.getBearing().equals(&quot;SSE&quot;))
+						cacheRosePattern = SSE;
+					else
+						cacheRosePattern = SE;
+				} else {
+					if (ch.getBearing().equals(&quot;WNW&quot;))
+						cacheRosePattern = WNW;
+					else if (ch.getBearing().equals(&quot;W&quot;))
+						cacheRosePattern = W;
+					else if (ch.getBearing().equals(&quot;WSW&quot;))
+						cacheRosePattern = WSW;
+					else
+						cacheRosePattern = 0;
+				}
+				if ((cacheRosePattern != 0) &amp;&amp; ((cacheRosePattern &amp; roseMatchPattern) == 0)) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 3: Distance
+			// /////////////////////////////
+			if (fscDist &gt; 0.0) {
+				dummyd1 = ch.kilom;
+				if (distdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+				if (distdirec == GREATER &amp;&amp; dummyd1 &lt; fscDist) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 4: Difficulty
+			// /////////////////////////////
+			if (fscDiff &gt; 0.0) {
+				dummyd1 = ch.getHard() / 10D;
+				if (diffdirec == SMALLER &amp;&amp; dummyd1 &gt; fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == EQUAL &amp;&amp; dummyd1 != fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+				if (diffdirec == GREATER &amp;&amp; dummyd1 &lt; fscDiff) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 5: Terrain
+			// /////////////////////////////
+			if (fscTerr &gt; 0.0) {
+				dummyd1 = ch.getTerrain() / 10D;
+				if (terrdirec == SMALLER &amp;&amp; dummyd1 &gt; fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == EQUAL &amp;&amp; dummyd1 != fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+				if (terrdirec == GREATER &amp;&amp; dummyd1 &lt; fscTerr) {
+					cacheFiltered = true;
+					break;
+				}
+			}
 
-	        ///////////////////////////////
-	        // Filter criterium 6: Found by me
-	        ///////////////////////////////
-	        if ((ch.is_found() &amp;&amp; !foundByMe) || (!ch.is_found() &amp;&amp; !notFoundByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 7: Owned by me
-	        ///////////////////////////////
-	        if ((ch.is_owned() &amp;&amp; !ownedByMe) || (!ch.is_owned() &amp;&amp; !notOwnedByMe)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 8: Archived
-	        ///////////////////////////////
-	        if ((ch.is_archived() &amp;&amp; !archived) || (!ch.is_archived() &amp;&amp; !notArchived)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 9: Unavailable
-	        ///////////////////////////////
-	        if ((ch.is_available() &amp;&amp; !available) || (!ch.is_available() &amp;&amp; !notAvailable)) {
-		        cacheFiltered = true; break;
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 10: Size
-	        ///////////////////////////////
-	        if (hasSizeMatchPattern) {
-		        cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
-		        if ((cacheSizePattern &amp; sizeMatchPattern) == 0) {
-			        cacheFiltered = true; break;
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: Attributes
-	        ///////////////////////////////
-	        if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) 
-	        		&amp;&amp; ch.mainCache == null) {
-	        	long[] chAtts=ch.getAttributesBits();
-		        if (attributesChoice == 0) {
-			        // AND-condition:
-			        if ((chAtts[0] &amp; attributesPattern[0]) != attributesPattern[0] ||
-				        	(chAtts[1] &amp; attributesPattern[1]) != attributesPattern[1] ||
-				        	(chAtts[2] &amp; attributesPattern[2]) != attributesPattern[2] ||
-				        	(chAtts[3] &amp; attributesPattern[3]) != attributesPattern[3] )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else if (attributesChoice == 1) {
-			        // OR-condition:
-			        if ((chAtts[0] &amp; attributesPattern[0]) == 0 ||
-				        	(chAtts[1] &amp; attributesPattern[1]) == 0 ||
-				        	(chAtts[2] &amp; attributesPattern[2]) == 0 ||
-				        	(chAtts[3] &amp; attributesPattern[3]) == 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        } else {
-			        // NOT-condition:
-			        if ((chAtts[0] &amp; attributesPattern[0]) != 0 ||
-				        	(chAtts[1] &amp; attributesPattern[1]) != 0 ||
-				        	(chAtts[2] &amp; attributesPattern[2]) != 0 ||
-				        	(chAtts[3] &amp; attributesPattern[3]) != 0 )
-				        {
-				        cacheFiltered = true;
-				        break;
-			        }
-		        }
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 12: Status
-	        ///////////////////////////////
-	        if (!cacheStatus.equals(&quot;&quot;)) {
-	        	if (!useRegexp) {
-	        		if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase())&lt;0) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	} else {
-	        		Regex rex=new Regex(cacheStatus.toLowerCase());
-	        		rex.search(ch.getStatusText().toLowerCase());
-	        		if (rex.stringMatched()==null) {
-	        			cacheFiltered = true;
-	        			break;
-	        		}
-	        	}
-	        }
-	        ///////////////////////////////
-	        // Filter criterium 11: NoCoord
-	        ///////////////////////////////
-	        if (!filterNoCoord &amp;&amp; !ch.pos.isValid()) {
-	          cacheFiltered = true;
-	        	break;
-        }
+			// /////////////////////////////
+			// Filter criterium 6: Found by me
+			// /////////////////////////////
+			if ((ch.is_found() &amp;&amp; !foundByMe) || (!ch.is_found() &amp;&amp; !notFoundByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 7: Owned by me
+			// /////////////////////////////
+			if ((ch.is_owned() &amp;&amp; !ownedByMe) || (!ch.is_owned() &amp;&amp; !notOwnedByMe)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 8: Archived
+			// /////////////////////////////
+			if ((ch.is_archived() &amp;&amp; !archived) || (!ch.is_archived() &amp;&amp; !notArchived)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 9: Unavailable
+			// /////////////////////////////
+			if ((ch.is_available() &amp;&amp; !available) || (!ch.is_available() &amp;&amp; !notAvailable)) {
+				cacheFiltered = true;
+				break;
+			}
+			// /////////////////////////////
+			// Filter criterium 10: Size
+			// /////////////////////////////
+			if (hasSizeMatchPattern) {
+				cacheSizePattern = CacheSize.getFilterPattern(ch.getCacheSize());
+				if ((cacheSizePattern &amp; sizeMatchPattern) == 0) {
+					cacheFiltered = true;
+					break;
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: Attributes
+			// /////////////////////////////
+			if ((attributesPattern[0] != 0 || attributesPattern[1] != 0 || attributesPattern[2] != 0 || attributesPattern[3] != 0) &amp;&amp; ch.mainCache == null) {
+				long[] chAtts = ch.getAttributesBits();
+				if (attributesChoice == 0) {
+					// AND-condition:
+					if ((chAtts[0] &amp; attributesPattern[0]) != attributesPattern[0] || (chAtts[1] &amp; attributesPattern[1]) != attributesPattern[1] || (chAtts[2] &amp; attributesPattern[2]) != attributesPattern[2]
+							|| (chAtts[3] &amp; attributesPattern[3]) != attributesPattern[3]) {
+						cacheFiltered = true;
+						break;
+					}
+				} else if (attributesChoice == 1) {
+					// OR-condition:
+					if ((chAtts[0] &amp; attributesPattern[0]) == 0 &amp;&amp; (chAtts[1] &amp; attributesPattern[1]) == 0 &amp;&amp; (chAtts[2] &amp; attributesPattern[2]) == 0 &amp;&amp; (chAtts[3] &amp; attributesPattern[3]) == 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					// NOT-condition:
+					if ((chAtts[0] &amp; attributesPattern[0]) != 0 || (chAtts[1] &amp; attributesPattern[1]) != 0 || (chAtts[2] &amp; attributesPattern[2]) != 0 || (chAtts[3] &amp; attributesPattern[3]) != 0) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 12: Status
+			// /////////////////////////////
+			if (!cacheStatus.equals(&quot;&quot;)) {
+				if (!useRegexp) {
+					if (ch.getStatusText().toLowerCase().indexOf(cacheStatus.toLowerCase()) &lt; 0) {
+						cacheFiltered = true;
+						break;
+					}
+				} else {
+					Regex rex = new Regex(cacheStatus.toLowerCase());
+					rex.search(ch.getStatusText().toLowerCase());
+					if (rex.stringMatched() == null) {
+						cacheFiltered = true;
+						break;
+					}
+				}
+			}
+			// /////////////////////////////
+			// Filter criterium 11: NoCoord
+			// /////////////////////////////
+			if (!filterNoCoord &amp;&amp; !ch.getPos().isValid()) {
+				cacheFiltered = true;
+				break;
+			}
 
-	        break;
-        } while (true);
+			break;
+		} while (true);
 		return cacheFiltered;
-    }
-	
+	}
+
 	/**
-	*	Switches flag to invert filter property.
-	*/
-	public void invertFilter(){
+	 * Switches flag to invert filter property.
+	 */
+	public void invertFilter() {
 		Global.getProfile().setFilterInverted(!Global.getProfile().isFilterInverted());
 	}
-	
+
 	/**
-	*	Clear the is_filtered flag from the cache database.
-	*/
-	public void clearFilter(){
+	 * Clear the is_filtered flag from the cache database.
+	 */
+	public void clearFilter() {
 		Global.getProfile().selectionChanged = true;
-		CacheDB cacheDB=Global.getProfile().cacheDB;
-		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			CacheHolder ch = cacheDB.get(i);
 			ch.setFiltered(false);
 		}
 		Global.getProfile().setFilterActive(FILTER_INACTIVE);
 	}
 
-		public boolean hasFilter() {
-		Profile prof=Global.getProfile();
-		long[] attribs=prof.getFilterAttr();
-		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) &amp;&amp;
-		    prof.getFilterRose().equals(FilterData.FILTERROSE) &amp;&amp;
-		    prof.getFilterVar().equals(FilterData.FILTERVAR) &amp;&amp;
-		    prof.getFilterSize().equals(FilterData.FILTERSIZE) &amp;&amp;
-		    prof.getFilterDist().equals(&quot;L&quot;) &amp;&amp;
-		    prof.getFilterDiff().equals(&quot;L&quot;) &amp;&amp;
-		    prof.getFilterTerr().equals(&quot;L&quot;) &amp;&amp;
-		    attribs[0] == 0l &amp;&amp;
-		    attribs[1] == 0l &amp;&amp;
-		    attribs[2] == 0l &amp;&amp;
-		    attribs[3] == 0l &amp;&amp;
-		    prof.getFilterStatus().equals(&quot;&quot;) &amp;&amp;
-        prof.getFilterNoCoord());
+	public boolean hasFilter() {
+		Profile prof = Global.getProfile();
+		long[] attribs = prof.getFilterAttr();
+		return !(prof.getFilterType().equals(FilterData.FILTERTYPE) &amp;&amp; prof.getFilterRose().equals(FilterData.FILTERROSE) &amp;&amp; prof.getFilterVar().equals(FilterData.FILTERVAR) &amp;&amp; prof.getFilterSize().equals(FilterData.FILTERSIZE)
+				&amp;&amp; prof.getFilterDist().equals(&quot;L&quot;) &amp;&amp; prof.getFilterDiff().equals(&quot;L&quot;) &amp;&amp; prof.getFilterTerr().equals(&quot;L&quot;) &amp;&amp; attribs[0] == 0l &amp;&amp; attribs[1] == 0l &amp;&amp; attribs[2] == 0l &amp;&amp; attribs[3] == 0l &amp;&amp; prof.getFilterStatus().equals(&quot;&quot;) &amp;&amp; prof
+					.getFilterNoCoord());
 	}
 
 }
-
-

Modified: branches/r1.2/src/CacheWolf/GeoCodeGui.java
===================================================================
--- branches/r1.2/src/CacheWolf/GeoCodeGui.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/GeoCodeGui.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -25,10 +25,7 @@
     */
 package CacheWolf;
 
-import ewe.io.IOException;
-import ewe.sys.Handle;
-import ewe.sys.HandleStoppedException;
-import ewe.sys.mThread;
+import ewe.sys.Vm;
 import ewe.ui.CellConstants;
 import ewe.ui.CellPanel;
 import ewe.ui.ControlEvent;
@@ -40,8 +37,8 @@
 import ewe.ui.mButton;
 import ewe.ui.mInput;
 import ewe.ui.mLabel;
+import ewe.ui.mList;
 import ewe.util.Vector;
-import ewesoft.xml.sax.SAXException;
 
 /**
  * Class for entering an address and convert it to lat/lon
@@ -55,12 +52,12 @@
 	CWPoint coordInp = new CWPoint();
 	CellPanel topLinePanel = new CellPanel();
 	CellPanel mainPanel = new CellPanel();
-	HtmlDisplay foundTxt;
+	// HtmlDisplay foundTxt;
+	mList choice;
 	int exitKeys[]={75009};
 
 	Vector geoCodeAnsw;
 	String searchText;
-	Handle[] fetchHandle = new Handle[1];
 
 	public GeoCodeGui()
 	{
@@ -76,10 +73,9 @@
 		this.addLast(topLinePanel,CellConstants.STRETCH, CellConstants.FILL | CellConstants.WEST);
 
 		// Description of found sites
-		foundTxt     = new HtmlDisplay();
-		foundTxt.setPreferredSize(200, 200);
-		ScrollBarPanel sbp = new MyScrollBarPanel(foundTxt, 0);
-		sbp.setClientConstraints(ScrollBarPanel.HCONTRACT|ScrollBarPanel.HCONTRACT);
+		choice=new mList(8,50,false);
+		ScrollBarPanel sbp = new MyScrollBarPanel(choice, 0);
+		sbp.setOptions(MyScrollBarPanel.NeverShowVerticalScrollers);
 		mainPanel.addLast(sbp, CellConstants.STRETCH, CellConstants.FILL | CellConstants.WEST);
 
 		// Buttons for cancel and apply
@@ -95,60 +91,29 @@
 
 	public void onEvent(Event ev){
 
-		// Ensure that the Enter key moves to the appropriate field
-		// for Checkboxes and Choice controls this is done via the exitKeys
-		// For input fields we use the wantReturn field
 		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
 			if (ev.target == searchBtn ){
-				foundTxt.setHtml(MyLocale.getMsg(7306, &quot;searching...&quot;));
-				// only insert &quot;,&quot; if city AND street is set
-				searchText = streetInp.text.trim();
-				if (searchText.length() &gt; 0) {
-					if (cityInp.text.trim().length() &gt; 0) searchText = searchText + &quot;,&quot;+cityInp.text;
-				} else searchText = cityInp.text;
-
-				mThread thrdfetch = 
-					new mThread() {
-					public void run() {
-						try {
-							fetchHandle[0] = null;
-							geoCodeAnsw = GeocoderOsm.geocode(searchText, fetchHandle);
-						} catch (IOException e) {
-							geoCodeAnsw = new Vector();
-							geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), &quot;IOExecption&quot;));
-						} catch (SAXException e) {
-							geoCodeAnsw = new Vector();
-							geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), &quot;SAXException&quot;));
-						} catch (HandleStoppedException ie) {
-							geoCodeAnsw = new Vector();
-							if (fetchHandle[0].stopReason == 4321)
-								geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7307, &quot;Canceled by user&quot;)));
-							else geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7308, &quot;Could not connect&quot;)));
-						} catch (InterruptedException ie) {
-							geoCodeAnsw = new Vector();
-							if (fetchHandle[0].stopReason == 4321)
-								geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7307, &quot;Canceled by user&quot;)));
-							else geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), MyLocale.getMsg(7308, &quot;Could not connect&quot;)));
-
-						}
-						// foundTxt.startHtml();
-						if (geoCodeAnsw.size() == 0) foundTxt.setHtml(&quot;nothing found&quot;);
-						else {
-							GeocodeAnswer ga = (GeocodeAnswer)geoCodeAnsw.get(0);
-							foundTxt.setHtml(ga.where.toString() + &quot;&lt;br&gt;&quot; + ga.foundname);
-						}
-						fetchHandle[0] = null;
-					}
-				};
-				thrdfetch.start();
+		        Vm.showWait(true);
+				try {
+					geoCodeAnsw = GeocoderOsm.geocode(cityInp.text.trim(), streetInp.text.trim());
+				} catch (Exception e) {
+					geoCodeAnsw = new Vector();
+					geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), e.getMessage()));
+				}
+		        Vm.showWait(false);
+				if (geoCodeAnsw.size() == 0) {
+					geoCodeAnsw = new Vector();
+					geoCodeAnsw.add(new GeocodeAnswer(new CWPoint(), &quot;nothing found&quot;));
+				}
+				choice.items.clear();
+				for (int i = 0; i &lt; geoCodeAnsw.size(); i++) {
+					GeocodeAnswer ga = (GeocodeAnswer)geoCodeAnsw.get(i);
+					choice.addItem(ga.where.toString() + &quot; | &quot; + ga.foundname);
+				}
+				choice.updateItems();
 			}
 
 			if (ev.target == searchCancelBtn){
-				if (fetchHandle != null &amp;&amp; fetchHandle[0] != null)
-				{
-					fetchHandle[0].stop(4321);
-					fetchHandle[0].set(Handle.Stopped);
-				}
 			}
 
 			if (ev.target == btnCancel){
@@ -156,8 +121,10 @@
 			}
 
 			if (ev.target == btnOk){
-				if (geoCodeAnsw != null &amp;&amp; geoCodeAnsw.size() &gt; 0)
-				coordInp = ((GeocodeAnswer)geoCodeAnsw.get(0)).where;
+				if (geoCodeAnsw != null &amp;&amp; geoCodeAnsw.size() &gt; 0) {
+					int i = choice.selectedIndex;
+					coordInp = ((GeocodeAnswer)geoCodeAnsw.get(i)).where;					
+				}
 				else coordInp.makeInvalid();
 				this.close(IDOK);
 			}

Modified: branches/r1.2/src/CacheWolf/GeocoderOsm.java
===================================================================
--- branches/r1.2/src/CacheWolf/GeocoderOsm.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/GeocoderOsm.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -25,10 +25,14 @@
     */
 package CacheWolf;
 
+import CacheWolf.utils.FileBugfix;
 import ewe.io.ByteArrayInputStream;
+import ewe.io.File;
+import ewe.io.FileInputStream;
 import ewe.io.IO;
 import ewe.io.IOException;
 import ewe.io.InputStreamReader;
+import ewe.io.StringStream;
 import ewe.sys.Handle;
 import ewe.sys.HandleStoppedException;
 import ewe.util.ByteArray;
@@ -39,35 +43,46 @@
 
 public class GeocoderOsm {
 
-	private static final String geocoderUrl = &quot;<A HREF="http://gazetteer.openstreetmap.org/namefinder/search.xml?max=1&amp;find=">http://gazetteer.openstreetmap.org/namefinder/search.xml?max=1&amp;find=</A>&quot;;  
+	//private static final String geocoderUrl = &quot;<A HREF="http://gazetteer.openstreetmap.org/namefinder/search.xml?max=1&amp;find=">http://gazetteer.openstreetmap.org/namefinder/search.xml?max=1&amp;find=</A>&quot;;
+	private static final String geocoderUrl = &quot;<A HREF="http://nominatim.openstreetmap.org/search?">http://nominatim.openstreetmap.org/search?</A>&quot;; //q=135+pilkington+avenue,+birmingham&amp;format=xml&amp;polygon=1&amp;addressdetails=1
 
-	public static Vector geocode(String address, Handle[] h) 
-	throws SAXException, IOException, HandleStoppedException, InterruptedException {
-		ByteArray answ = UrlFetcher.fetchByteArray((geocoderUrl+UrlFetcher.toUtf8Url(address)), null, h);
+	public static Vector geocode(String city, String street) throws Exception 
+	{
+		String searchFor;
+		if (street.equals(&quot;&quot;)) {
+			searchFor=UrlFetcher.toUtf8Url(city);
+		}
+		else {
+			searchFor=UrlFetcher.toUtf8Url(street) + &quot;+&quot; + UrlFetcher.toUtf8Url(city);
+		}
+		String answer = UrlFetcher.fetch(geocoderUrl + &quot;q=&quot; + searchFor + &quot;&amp;format=xml&quot;);
+		answer=STRreplace.replace(answer,&quot;\'&quot;,&quot;\' &quot;);
+		answer=STRreplace.replace(answer,&quot;  &quot;,&quot; &quot;);
 		XMLDecoder xmldec = new XMLDecoder();
-		xmldec.parse(new InputStreamReader(new ByteArrayInputStream(answ), IO.JAVA_UTF8_CODEC));
 		Vector erg = new Vector();
-		if ( &quot;searchresults&quot;.equalsIgnoreCase((String)xmldec.document.tag) ) {
-			XMLElement xe, xe2;
-			String desc, lat, lon;
-			desc = null;
-			CWPoint where = new CWPoint();
-			if (xmldec.document != null &amp;&amp; xmldec.document.subElements != null) {
-				for (int i=0;  i &lt; xmldec.document.subElements.size(); i++) {
-					xe = (XMLElement) xmldec.document.subElements.elementAt(i);
-					if (xe.tag.equalsIgnoreCase(&quot;named&quot;)) {
-						lat = (String) xe.attributes.getPropertyValues(&quot;lat&quot;).get(0);
-						lon = (String) xe.attributes.getPropertyValues(&quot;lon&quot;).get(0);
-						where.set(Common.parseDouble(lat), Common.parseDouble(lon));
-						for (int j = 0; j &lt; xe.subElements.size(); j++) {
-							xe2 = (XMLElement) xe.subElements.elementAt(j);
-							if ( xe2.tag.equalsIgnoreCase(&quot;description&quot;)) { desc = xe2.text; break; }  
+		try {
+			xmldec.parse(new InputStreamReader(new StringStream(answer)));
+			if ( &quot;searchresults&quot;.equalsIgnoreCase((String)xmldec.document.tag) ) {
+				XMLElement xe;
+				String desc, lat, lon;
+				desc = null;
+				CWPoint where = new CWPoint();
+				if (xmldec.document != null &amp;&amp; xmldec.document.subElements != null) {
+					for (int i=0;  i &lt; xmldec.document.subElements.size(); i++) {
+						xe = (XMLElement) xmldec.document.subElements.elementAt(i);
+						if (xe.tag.equalsIgnoreCase(&quot;place&quot;)) {
+							lat = (String) xe.attributes.getPropertyValues(&quot;lat&quot;).get(0);
+							lon = (String) xe.attributes.getPropertyValues(&quot;lon&quot;).get(0);
+							where.set(Common.parseDouble(lat.trim()), Common.parseDouble(lon.trim()));
+							desc = (String) xe.attributes.getPropertyValues(&quot;display_name&quot;).get(0);
+							erg.add(new GeocodeAnswer(where, desc));
 						}
-						erg.add(new GeocodeAnswer(where, desc));
 					}
 				}
 			}
-		}
+		} catch (Exception e) {
+			throw new Exception(e.getMessage());
+		}	
 		return erg;
 	}
 

Modified: branches/r1.2/src/CacheWolf/GuiImageBroker.java
===================================================================
--- branches/r1.2/src/CacheWolf/GuiImageBroker.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/GuiImageBroker.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.utils.FileBugfix;
@@ -31,38 +31,23 @@
 
 /**
  * hold preloaded versions of GUI images in a single place
- *
+ * 
  * Do not instantiate this class, only use it in a static way.
  */
 
 public final class GuiImageBroker {
+	public static Image found = new Image(&quot;found.png&quot;);
+	public static Image disabled = new Image(&quot;disabled.png&quot;); // available
+	public static Image archived = new Image(&quot;archived.png&quot;);
+	public static Image solved = new Image(&quot;solved.png&quot;);
+	public static Image bonus = new Image(&quot;bonus.png&quot;);
+	public static Image owned = new Image(&quot;owned.png&quot;);
+	public static Image dnf = new Image(&quot;dnf.png&quot;);
 
-	// TODO: check with Image and mImage
-
-	/** image to be displayed in case of error */
-	public static Image imageError = new Image(&quot;guiError.png&quot;);
-
-	/**
-	 * images to be displayed for cache types in GUI
-	 * @see getTypeImage
-	 * @see CacheTypes
-	 */
-
-	/** thou shallst not instantiate this object */
 	private GuiImageBroker() {
 		// Noting to do
 	}
 
-	public static Image getTypeImage(byte typeId,boolean map) {
-		if (!map) {
-			return CacheType.getTypeImage(typeId);
-		}
-		else {
-			return CacheType.getMapImage(typeId);
-		}
-	}
-
-
 	/**
 	 * Replaces the build-in symbols by images stored in /symbols:
 	 * If the sub directory symbols exists in CW-directory *.png-files
@@ -73,35 +58,56 @@
 	 * Images are NOT checked for size etc.
 	 */
 	public static void customizedSymbols() {
-		final String sdir=&quot;/symbols/&quot;;
-		final FileBugfix dir=new FileBugfix(FileBase.getProgramDirectory()+sdir);
-		if (dir.isDirectory()){
+		final String sdir = &quot;/symbols/&quot;;
+		final FileBugfix dir = new FileBugfix(FileBase.getProgramDirectory() + sdir);
+		if (dir.isDirectory()) {
 			int id;
-			boolean size=false;
+			boolean size = false;
 			String name = &quot;&quot;;
-			String [] pngFiles;
-			pngFiles=dir.list(&quot;*.png&quot;,0);
-			Global.getPref().log(&quot;Nr. of own symbols (png-files) : &quot;+pngFiles.length);
-			for (int i=0; i&lt;pngFiles.length; i++) {
-				name = pngFiles[i].substring(0,pngFiles[i].length()-4);
-				if (name.toLowerCase().endsWith(&quot;size&quot;)){
-					size=true;
-					name=name.substring(0,name.length()-4);
+			String[] pngFiles;
+			pngFiles = dir.list(&quot;*.png&quot;, FileBase.LIST_FILES_ONLY);
+			Global.getPref().log(&quot;Nr. of own symbols (png-files) : &quot; + pngFiles.length);
+			for (int i = 0; i &lt; pngFiles.length; i++) {
+				name = pngFiles[i].substring(0, pngFiles[i].length() - 4).toLowerCase();
+				if (name.endsWith(&quot;size&quot;)) {
+					size = true;
+					name = name.substring(0, name.length() - 4);
+				} else {
+					if (name.equals(&quot;disabled&quot;)) {
+						disabled = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;archived&quot;)) {
+						archived = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;solved&quot;)) {
+						solved = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;bonus&quot;)) {
+						bonus = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;owned&quot;)) {
+						owned = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;dnf&quot;)) {
+						dnf = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
+					if (name.equals(&quot;found&quot;)) {
+						found = new Image(FileBase.getProgramDirectory() + sdir + pngFiles[i]);
+					}
 				}
 				try {
 					id = Integer.parseInt(name);
+				} catch (final Exception E) {
+					id = -1; // filename invalid for symbols
 				}
-				catch (Exception E){
-					id = -1; //filename invalid for symbols
-				}
-				if (0&lt;=id &amp;&amp; id&lt;=CacheType.maxCWCType){
-					String s=FileBase.getProgramDirectory()+sdir+pngFiles[i];
-					Global.getPref().log(&quot;own symbol: &quot;+(i+1)+&quot; = &quot;+pngFiles[i]);
-					if (size){
+				if (0 &lt;= id &amp;&amp; id &lt;= CacheType.maxCWCType) {
+					final String s = FileBase.getProgramDirectory() + sdir + pngFiles[i];
+					Global.getPref().log(&quot;own symbol: &quot; + (i + 1) + &quot; = &quot; + pngFiles[i]);
+					if (size) {
 						CacheType.setMapImage((byte) id, new Image(s));
-						size=false;
-					}
-					else{
+						size = false;
+
+					} else {
 						CacheType.setTypeImage((byte) id, new Image(s));
 					}
 				}

Modified: branches/r1.2/src/CacheWolf/HintLogPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/HintLogPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/HintLogPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -289,7 +289,7 @@
 			if (dx != 0 || dy != 0) scroll(dx,dy);
 			refresh();
 			return true;
-		}else if (true || where.x &lt; origin.x || where.x &gt;= origin.x+r.width || where.y &lt; origin.y || where.y &gt;= origin.y+r.height){
+		}else if (true/* || where.x &lt; origin.x || where.x &gt;= origin.x+r.width || where.y &lt; origin.y || where.y &gt;= origin.y+r.height*/){
 	 			if (autoScrolling) {
 					didAutoScroll = true;
 					scroll(-to.x,-to.y);

Modified: branches/r1.2/src/CacheWolf/HttpConnection.java
===================================================================
--- branches/r1.2/src/CacheWolf/HttpConnection.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/HttpConnection.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -257,6 +257,11 @@
 {
 	getRequestorProperties().set(name,property);
 }
+public void setRequestorProperty(PropertyList pl)
+//===================================================================
+{
+	getRequestorProperties().set(pl);
+}
 /**
  * Add a non-exclusive requestor property. These are sent to the web server after the initial request line.
  * @param name The name of the property.
@@ -347,6 +352,8 @@
 			}
 		}
 	}
+	getRequestorProperties().clear();
+	command = &quot;GET&quot;;
 }
 
 //FIXME: never referenced

Modified: branches/r1.2/src/CacheWolf/ImagePanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/ImagePanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/ImagePanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.Color;
 import ewe.fx.Font;
@@ -45,105 +46,110 @@
 import ewe.ui.MessageBox;
 import ewe.ui.PenEvent;
 
-
 /**
-*	Class to display the cache and log images. It creates a thumbnail view and
-*	allows the user to click on an image that will then be displayed in its original size
-*	as long as the image fits the application size. If the application size is not sufficient
-*	then the image will be scaled to the available screen size.
-*   A right mouseclick on an image will open a dialogue to delete the file. 
-*/
-public class ImagePanel extends InteractivePanel{
+ * Class to display the cache and log images. It creates a thumbnail view and
+ * allows the user to click on an image that will then be displayed in its original size
+ * as long as the image fits the application size. If the application size is not sufficient
+ * then the image will be scaled to the available screen size.
+ * A right mouseclick on an image will open a dialogue to delete the file.
+ */
+public class ImagePanel extends InteractivePanel {
 	/** Picture to replace deleted pictures */
-	private final String NO_IMAGE=&quot;no_picture.png&quot;;
+	private final String NO_IMAGE = &quot;no_picture.png&quot;;
 	/** Minimum time (msec) to recognise a long pen down event (=right mouse key) */
-	private final int LONG_PEN_DOWN_DURATION=500;
+	private final int LONG_PEN_DOWN_DURATION = 500;
 
 	Preferences pref;
 	Profile profile;
-	//private final int thumb_max_size = 300;
-	//private final int thumb_min_size = 100;
+	// private final int thumb_max_size = 300;
+	// private final int thumb_min_size = 100;
 	private final int padding = 20;
 	private int thumb_size = 0;
 	private int locX, locY, locCounter;
 	/** Start and duration of pen-pressed event to simulate right mouse key */
-	private long start, duration=0;
-	
+	private long start, duration = 0;
+
 	/**
-	* Constructor to create the image panel.&lt;p&gt;
-	*/
-	public ImagePanel(){ // Public constructor
+	 * Constructor to create the image panel.
+	 * &lt;p&gt;
+	 */
+	public ImagePanel() { // Public constructor
 	}
-	
-	static CacheHolderDetail oldCache=null;
+
+	static CacheHolderDetail oldCache = null;
+
 	/**
-	* Method to set the individual cache images.
-	* Gets called immediatly before panel is displayed
-	* @see MainTab#onEvent(Event ev)
-	*/
-	public void setImages(CacheHolderDetail cache){
-		if (cache!=oldCache) { 
+	 * Method to set the individual cache images.
+	 * Gets called immediatly before panel is displayed
+	 * 
+	 * @see MainTab#onEvent(Event ev)
+	 */
+	public void setImages(CacheHolderDetail cache) {
+		if (cache != oldCache) {
 			pref = Global.getPref();
-			profile=Global.getProfile();
+			profile = Global.getProfile();
 			Vm.showWait(true);
 			clearImages();
-			thumb_size = ((pref.myAppWidth-2*padding) / 3);
+			thumb_size = ((pref.myAppWidth - 2 * padding) / 3);
 			thumb_size = thumb_size - padding;
 			double rowCounter1 = 0;
-			if (cache.images.getDisplayImages(cache.getParent().getWayPoint()).size()&gt;0) {
+			if (cache.images.getDisplayImages(cache.getParent().getWayPoint()).size() &gt; 0) {
 				rowCounter1 = cache.images.getDisplayImages(cache.getParent().getWayPoint()).size();
-				rowCounter1 = java.lang.Math.ceil(rowCounter1/3);
+				rowCounter1 = java.lang.Math.ceil(rowCounter1 / 3);
 			}
 			double rowCounter2 = 0;
-			if (cache.userImages.size()&gt;0){
+			if (cache.userImages.size() &gt; 0) {
 				rowCounter2 = cache.userImages.size();
-				rowCounter2 = java.lang.Math.ceil(rowCounter2/3);
+				rowCounter2 = java.lang.Math.ceil(rowCounter2 / 3);
 			}
 			int rowCounter = (int) (rowCounter1 + rowCounter2);
-			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+padding);
+			Rect r = new Rect(0, 0, pref.myAppWidth, rowCounter * thumb_size + rowCounter * padding + padding);
 			this.virtualSize = r;
-			//this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
+			// this.setPreferredSize(pref.myAppWidth, rowCounter*thumb_size+rowCounter*padding+40);
 			// this.checkScrolls();
 			// this.refresh();
-			locY=0;
-			addTitle(MyLocale.getMsg(340,&quot;Cache Images:&quot;));
+			locY = 0;
+			addTitle(MyLocale.getMsg(340, &quot;Cache Images:&quot;));
 			locY = 20;
 			locX = padding;
 			addImages(cache.images.getDisplayImages(cache.getParent().getWayPoint()));
 			// load user images
-			if(locCounter==1 || locCounter ==2) locY = locY + thumb_size;
-			if (cache.userImages.size()&gt; 0){
-				addTitle(MyLocale.getMsg(341,&quot;User Images:&quot;));
+			if (locCounter == 1 || locCounter == 2)
+				locY = locY + thumb_size;
+			if (cache.userImages.size() &gt; 0) {
+				addTitle(MyLocale.getMsg(341, &quot;User Images:&quot;));
 				locY = locY + 20;
 				locX = padding;
 				locCounter = 0;
 				addImages(cache.userImages);
 			}
-			oldCache=cache;
-		} // cache!=oldCache	
-		if (locY&gt;this.height) {
+			oldCache = cache;
+		} // cache!=oldCache
+		if (locY &gt; this.height) {
 			this.checkScrolls();
 		}
 		this.refresh();
 		Vm.showWait(false);
-		//this.repaintNow();
+		// this.repaintNow();
 	}
 
 	/**
 	 * Clear the images in the panel
-	 *
+	 * 
 	 */
 	public void clearImages() {
-		oldCache=null;
+		oldCache = null;
 		int lgr = images.size();
-		for(int i = 0; i&lt;lgr;i++){
-			this.removeImage((AniImage)images.get(0));
+		for (int i = 0; i &lt; lgr; i++) {
+			this.removeImage((AniImage) images.get(0));
 		}
 	}
-	
+
 	/**
 	 * Add a title above the cache images and above the user images
-	 * @param title Title to add (&quot;cache images&quot; or &quot;user images&quot;)
+	 * 
+	 * @param title
+	 *            Title to add (&quot;cache images&quot; or &quot;user images&quot;)
 	 */
 	private void addTitle(String title) {
 		AniImage aImg;
@@ -151,24 +157,27 @@
 		FontMetrics fm = getFontMetrics();
 		int stringWidth = fm.getTextWidth(title);
 		int stringHeight = fm.getHeight();
-		Image img = new Image(stringWidth*2,stringHeight+5);
+		Image img = new Image(stringWidth * 2, stringHeight + 5);
 		Graphics g = new Graphics(img);
-		g.setColor(new Color(195,195,195));
-		g.fillRect(0,0,stringWidth*2,stringHeight+5);
-		g.setColor(new Color(0,0,0));
+		g.setColor(new Color(195, 195, 195));
+		g.fillRect(0, 0, stringWidth * 2, stringHeight + 5);
+		g.setColor(new Color(0, 0, 0));
 		g.setFont(titleFont);
-		g.drawText(title, 0,0);
+		g.drawText(title, 0, 0);
 		g.free();
 		aImg = new AniImage(img);
 		aImg.setLocation(0, locY);
 		addImage(aImg);
 		aImg.refresh();
 	}
-	
+
 	/**
 	 * Add the images to the panel. Can add both normal and user images
-	 * @param pImages Vector of images or userImages
-	 * @param imagesText Vector of image texts or user image texts
+	 * 
+	 * @param pImages
+	 *            Vector of images or userImages
+	 * @param imagesText
+	 *            Vector of image texts or user image texts
 	 */
 	private void addImages(CacheImages pImages) {
 		String location, imgText;
@@ -177,133 +186,147 @@
 		double dummyC;
 		ImagePanelImage ipi;
 		AniImage AimgText;
-		locCounter=0;
-		for(int i = 0; i&lt;pImages.size(); i++){
-			location = profile.dataDir + pImages.get(i).getFilename();
-			if (!(new FileBugfix(location)).exists()) {
-				location=NO_IMAGE;
-				if (!pref.showDeletedImages) continue; // Don't show the deleted Image if user does not want it
+		locCounter = 0;
+		for (int i = 0; i &lt; pImages.size(); i++) {
+			location = pImages.get(i).getFilename();
+			boolean doit = true;
+			for (int j = i + 1; j &lt; pImages.size(); j++) {
+				String jmgFile = pImages.get(j).getFilename();
+				if (location.equals(jmgFile)) {
+					doit = false;
+					break;
+				}
 			}
-			try{
-				mI = new mImage(location);
-				// actuall new mImage(location); should do the following &quot;if&quot; but it doesn't anyhow
-				if (mI.getWidth() &lt;= 0 || mI.getHeight() &lt;= 0 ) throw new IllegalArgumentException(location);
-				scaleX = thumb_size;
-				scaleY = thumb_size;
-				dummyC = 0;
-				double thumb_size2 = thumb_size;
-				if(mI.getWidth()&gt;mI.getHeight()){
+			if (doit) {
+				location = profile.dataDir + location;
+				if (!(new FileBugfix(location)).exists()) {
+					location = NO_IMAGE;
+					if (!pref.showDeletedImages)
+						continue; // Don't show the deleted Image if user does not want it
+				}
+				try {
+					mI = new mImage(location);
+					// actuall new mImage(location); should do the following &quot;if&quot; but it doesn't anyhow
+					if (mI.getWidth() &lt;= 0 || mI.getHeight() &lt;= 0)
+						throw new IllegalArgumentException(location);
 					scaleX = thumb_size;
-					dummyC = (double)mI.getHeight()/ (double)mI.getWidth();
-					dummyC = dummyC * thumb_size2;
-					scaleY = (int)dummyC;
-				}
-				if(mI.getWidth() &lt;= mI.getHeight()){
 					scaleY = thumb_size;
-					dummyC = (double)mI.getWidth()/(double)mI.getHeight();
-					dummyC = dummyC * thumb_size2;
-					scaleX = (int)dummyC;
+					dummyC = 0;
+					double thumb_size2 = thumb_size;
+					if (mI.getWidth() &gt; mI.getHeight()) {
+						scaleX = thumb_size;
+						dummyC = (double) mI.getHeight() / (double) mI.getWidth();
+						dummyC = dummyC * thumb_size2;
+						scaleY = (int) dummyC;
+					}
+					if (mI.getWidth() &lt;= mI.getHeight()) {
+						scaleY = thumb_size;
+						dummyC = (double) mI.getWidth() / (double) mI.getHeight();
+						dummyC = dummyC * thumb_size2;
+						scaleX = (int) dummyC;
+					}
+					if (mI.getWidth() &lt;= thumb_size) {
+						scaleX = mI.getWidth();
+						scaleY = mI.getHeight();
+					}
+					mI = mI.scale(scaleX, scaleY, null, 0);
+					mI.freeSource();
+					ipi = new ImagePanelImage(mI);
+					ipi.freeSource();
+					// mI.free(); --&gt; this only works in java-VM, in ewe it will delete the image, so leave it commented out
+					ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
+					ipi.setLocation(locX, locY);
+					addImage(ipi);
+					// Name of picture:
+					if (pImages.size() &gt; i) {
+						if (location.equals(NO_IMAGE))
+							imgText = MyLocale.getMsg(342, &quot;Deleted&quot;);
+						else
+							imgText = SafeXML.cleanback(pImages.get(i).getTitle());
+						if (imgText.length() == 0)
+							imgText = &quot;???&quot;;
+						AimgText = new AniImage();
+						AimgText = getImageText(imgText);
+						AimgText.setLocation(locX, locY + scaleY);
+						addImage(AimgText);
+						AimgText.refresh();
+						ipi.imageText = imgText;
+						ipi.imageComment = SafeXML.cleanback(pImages.get(i).getComment());
+					}
+					ipi.refresh();
+					locX = locX + thumb_size + padding;
+
+					locCounter++;
+					if (locCounter &gt; 2) {
+						locCounter = 0;
+						locX = padding;
+						locY = locY + thumb_size + padding;
+					}
+				} catch (IllegalArgumentException imex) { // file not found, could not decode etc.
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321, &quot;Fehler&quot;), MyLocale.getMsg(322, &quot;Kann Bild/Karte nicht laden&quot;) + &quot;:\n&quot; + imex.getMessage(), FormBase.OKB); // @todo: language support
+					tmp.exec();
+				} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
+					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(343, &quot;Not enough free memory to load cache image&quot;) + &quot;:\n&quot; + location, FormBase.OKB)).exec();
+				} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
+					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(343, &quot;Not enough free memory to load cache image&quot;) + &quot;\n&quot; + location, FormBase.OKB)).exec();
 				}
-				if(mI.getWidth() &lt;= thumb_size){
-					scaleX = mI.getWidth();
-					scaleY = mI.getHeight();
-				}
-				mI = mI.scale(scaleX,scaleY,null,0);
-				mI.freeSource();
-				ipi = new ImagePanelImage(mI);
-				ipi.freeSource();
-				//mI.free(); --&gt; this only works in java-VM, in ewe it will delete the image, so leave it commented out
-				ipi.fileName = location; // this is set only to easily identify the filename of the image clicked
-				ipi.setLocation(locX, locY);
-				addImage(ipi);
-				//Name of picture:
-				if(pImages.size()&gt;i){
-					if (location.equals(NO_IMAGE))
-						imgText=MyLocale.getMsg(342,&quot;Deleted&quot;);
-					else
-						imgText = SafeXML.cleanback(pImages.get(i).getTitle());
-					if(imgText.length()==0) imgText = &quot;???&quot;;
-					AimgText = new AniImage();
-					AimgText = getImageText(imgText);
-					AimgText.setLocation(locX,locY+scaleY);
-					addImage(AimgText);
-					AimgText.refresh();
-					ipi.imageText = imgText;
-					ipi.imageComment = SafeXML.cleanback(pImages.get(i).getComment());
-				}
-				ipi.refresh();
-				locX = locX + thumb_size + padding;
-				
-				locCounter++;
-				if(locCounter &gt; 2) {
-					locCounter = 0;
-					locX = padding;
-					locY = locY+thumb_size+padding;
-				}
-			}catch(IllegalArgumentException imex){ // file not found, could not decode etc.
-				MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht laden&quot;)+&quot;:\n&quot;+imex.getMessage(), FormBase.OKB); // @todo: language support
-				tmp.exec();
-			} catch (OutOfMemoryError e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;:\n&quot;+location,FormBase.OKB)).exec();
-			} catch (SystemResourceException e) { // TODO show an error icon in the panel instead of nothing
-				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+location,FormBase.OKB)).exec();
 			}
-		} //for
-		
+		} // for
+
 	}
-	
-	private AniImage getImageText(String pText){
+
+	private AniImage getImageText(String pText) {
 		Font aniImageFont = new Font(&quot;Verdana&quot;, Font.BOLD, 14);
 		FontMetrics fm = getFontMetrics();
 		int stringWidth = fm.getTextWidth(pText);
 		int stringHeight = fm.getHeight();
-		Image img = new Image(stringWidth*2,stringHeight+5);
+		Image img = new Image(stringWidth * 2, stringHeight + 5);
 		Graphics g = new Graphics(img);
-		g.setColor(new Color(195,195,195));
-		g.fillRect(0,0,stringWidth*2,stringHeight+5);
-		g.setColor(new Color(0,0,0));
+		g.setColor(new Color(195, 195, 195));
+		g.fillRect(0, 0, stringWidth * 2, stringHeight + 5);
+		g.setColor(new Color(0, 0, 0));
 		g.setFont(aniImageFont);
-		g.drawText(pText, 0,0);
+		g.drawText(pText, 0, 0);
 		g.free();
 		AniImage a = new AniImage(img);
 		return a;
 	}
 
-	
 	/**
-	* React to when a user clicks an image.
-	* If left mouse key is clicked, will open a new window displaying the image scaled
-	* to window size if the image is larger, otherwise the true size is displayed.
-	* If right mouse key is clicked, a dialogue to delete the image wil be displayed
-	*/
-	public void imageClicked(AniImage which, Point pos){
-		if ((ControlBase.currentPenEvent.modifiers&amp;PenEvent.RIGHT_BUTTON)==PenEvent.RIGHT_BUTTON || duration&gt;LONG_PEN_DOWN_DURATION) {
+	 * React to when a user clicks an image.
+	 * If left mouse key is clicked, will open a new window displaying the image scaled
+	 * to window size if the image is larger, otherwise the true size is displayed.
+	 * If right mouse key is clicked, a dialogue to delete the image wil be displayed
+	 */
+	public void imageClicked(AniImage which, Point pos) {
+		if ((ControlBase.currentPenEvent.modifiers &amp; PenEvent.RIGHT_BUTTON) == PenEvent.RIGHT_BUTTON || duration &gt; LONG_PEN_DOWN_DURATION) {
 			// Right button pressed - delete image to conserve space
-			if (which instanceof ImagePanelImage &amp;&amp; !((ImagePanelImage)which).fileName.equals(NO_IMAGE)) {
-				MessageBox mBox = new MessageBox (MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(344,&quot;Delete image&quot;)+&quot; \&quot;&quot;+((ImagePanelImage)which).imageText+&quot;\&quot;?&quot;, FormBase.IDYES |FormBase.IDNO);
-				if (mBox.execute() == FormBase.IDOK){
-						try {
-							File f=new File(((ImagePanelImage)which).fileName);
-							f.delete();
-							removeImage(which);
-						} catch(Exception e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						};
+			if (which instanceof ImagePanelImage &amp;&amp; !((ImagePanelImage) which).fileName.equals(NO_IMAGE)) {
+				MessageBox mBox = new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(344, &quot;Delete image&quot;) + &quot; \&quot;&quot; + ((ImagePanelImage) which).imageText + &quot;\&quot;?&quot;, FormBase.IDYES | FormBase.IDNO);
+				if (mBox.execute() == FormBase.IDOK) {
+					try {
+						File f = new File(((ImagePanelImage) which).fileName);
+						f.delete();
+						removeImage(which);
+					} catch (Exception e) {
+						// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+					}
+					;
 				}
 			}
-		} else { 
+		} else {
 			String fn = new String();
-			if(which instanceof ImagePanelImage){
-				ImagePanelImage ich = (ImagePanelImage)which;
+			if (which instanceof ImagePanelImage) {
+				ImagePanelImage ich = (ImagePanelImage) which;
 				fn = ich.fileName;
 				try {
 					ImageDetailForm iF = new ImageDetailForm(fn, ich.imageText, ich.imageComment, pref);
 					iF.execute(null, Gui.CENTER_FRAME);
 				} catch (IllegalArgumentException e) {
-					MessageBox tmp = new MessageBox(MyLocale.getMsg(321,&quot;Fehler&quot;), MyLocale.getMsg(322,&quot;Kann Bild/Karte nicht finden&quot;), FormBase.OKB); // @todo: language support
+					MessageBox tmp = new MessageBox(MyLocale.getMsg(321, &quot;Fehler&quot;), MyLocale.getMsg(322, &quot;Kann Bild/Karte nicht finden&quot;), FormBase.OKB); // @todo: language support
 					tmp.exec();
 				} catch (OutOfMemoryError e) {
-					(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(343,&quot;Not enough free memory to load cache image&quot;)+&quot;\n&quot;+fn,FormBase.OKB)).exec();
+					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(343, &quot;Not enough free memory to load cache image&quot;) + &quot;\n&quot; + fn, FormBase.OKB)).exec();
 				}
 			}
 		}
@@ -311,15 +334,15 @@
 
 	/**
 	 * Create a &quot;pen held down&quot; event on hardware that does not support a right mouse key (e.g. Windows Mobile)
-	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate 
+	 * by measuring the time between pen down and pen up events. This is used in imageClicked to differentiate
 	 * between left and right mouse keys.
 	 */
 	public void onPenEvent(PenEvent ev) {
-		if (ev.type==PenEvent.PEN_DOWN) {
+		if (ev.type == PenEvent.PEN_DOWN) {
 			start = Vm.getTimeStampLong();
 		}
-		if (ev.type==PenEvent.PEN_UP) {
-			duration=Vm.getTimeStampLong()-start;
+		if (ev.type == PenEvent.PEN_UP) {
+			duration = Vm.getTimeStampLong() - start;
 		}
 		super.onPenEvent(ev);
 	}

Modified: branches/r1.2/src/CacheWolf/InfoBox.java
===================================================================
--- branches/r1.2/src/CacheWolf/InfoBox.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/InfoBox.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.ui.CellConstants;
 import ewe.ui.ControlConstants;
 import ewe.ui.ControlEvent;
@@ -37,7 +38,7 @@
 import ewe.ui.mInput;
 import ewe.ui.mLabel;
 
-public class InfoBox extends Form{
+public class InfoBox extends Form {
 	TextMessage msgArea;
 	mCheckBox mCB;
 	TextMessage warnings;
@@ -50,28 +51,21 @@
 	public final static int DISPLAY_ONLY = 3;
 	public final static int PROGRESS_WITH_WARNINGS = 4;
 	private int type = 0;
-	/** This variable is set to true if the user closed the Info window by
-	 *  clicking the &quot;close&quot; button. It can be used to check if a lengthy task needs to be
-	 *  aborted (i.e. spidering)
+	/**
+	 * This variable is set to true if the user closed the Info window by clicking the &quot;close&quot; button. It can be used to check if a lengthy task needs to be aborted (i.e. spidering)
 	 */
-	public boolean isClosed=false;
+	public boolean isClosed = false;
 
-	public InfoBox(String title, String info){
+	public InfoBox(String title, String info) {
 		this(title, info, DISPLAY_ONLY);
 
-		/*this.setPreferredSize(170,50);
-		this.title = title;
-		msgArea = new MessageArea(&quot;&quot;), CellConstants.STRETCH, CellConstants.FILL)
-		this.addLast(scP = new ScrollBarPanel(msgArea));
-		msgArea.setText(info);
-		mB.setHotKey(0, IKeys.ACTION);
-		mB.setHotKey(0, IKeys.ENTER);
-		//mB.set(Control.Invisible, true);
-		//this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
+		/*
+		 * this.setPreferredSize(170,50); this.title = title; msgArea = new MessageArea(&quot;&quot;), CellConstants.STRETCH, CellConstants.FILL) this.addLast(scP = new ScrollBarPanel(msgArea)); msgArea.setText(info); mB.setHotKey(0, IKeys.ACTION); mB.setHotKey(0,
+		 * IKeys.ENTER); //mB.set(Control.Invisible, true); //this.addLast(mB, CellConstants.STRETCH, CellConstants.FILL);
 		 */
 	}
 
-	public String getInput(){
+	public String getInput() {
 		return feedback.getText();
 	}
 
@@ -80,29 +74,43 @@
 		this.repaintNow();
 	}
 
-	public InfoBox(String title, String info, int ty){
-		this(title, info, ty, true);
-//		this.setPreferredSize(170, 50);
+	public InfoBox(String title, String info, int type) {
+		this(title, info, type, true);
+		// this.setPreferredSize(170, 50);
 		relayout(false);
 	}
 
 	public InfoBox(String title, String info, int ty, boolean autoWrap) {
 		type = ty;
-//		this.setPreferredSize(150,50);
+		// this.setPreferredSize(150,50);
 		// Resize InfoBox with Fontsize
-		Preferences pref=Global.getPref();
+		Preferences pref = Global.getPref();
 		int fs = pref.fontSize;
 		int sw = MyLocale.getScreenWidth();
-		int psx; int psy;
-		psx=170;psy=50;
-		if((fs &gt; 11) &amp;&amp; (sw &gt;= 200)){psx=200;psy=70;}
-		if((fs &gt; 16) &amp;&amp; (sw &gt;= 250)){psx=250;psy=90;}
-		if((fs &gt; 21) &amp;&amp; (sw &gt;= 300)){psx=300;psy=110;}
-		if((fs &gt; 24) &amp;&amp; (sw &gt;= 350)){psx=350;psy=130;}
+		int psx;
+		int psy;
+		psx = 170;
+		psy = 50;
+		if ((fs &gt; 11) &amp;&amp; (sw &gt;= 200)) {
+			psx = 200;
+			psy = 70;
+		}
+		if ((fs &gt; 16) &amp;&amp; (sw &gt;= 250)) {
+			psx = 250;
+			psy = 90;
+		}
+		if ((fs &gt; 21) &amp;&amp; (sw &gt;= 300)) {
+			psx = 300;
+			psy = 110;
+		}
+		if ((fs &gt; 24) &amp;&amp; (sw &gt;= 350)) {
+			psx = 350;
+			psy = 130;
+		}
 		this.setPreferredSize(psx, psy);
 		this.title = title;
 		switch (type) {
-		case CHECKBOX: 
+		case CHECKBOX:
 			mCB = new mCheckBox(info);
 			this.addLast(mCB, CellConstants.STRETCH, CellConstants.FILL);
 			break;
@@ -123,11 +131,11 @@
 			msgArea.autoWrap = autoWrap;
 			msgArea.alignment = CellConstants.CENTER;
 			msgArea.anchor = CellConstants.CENTER;
-			msgArea.setPreferredSize(psx-20, psy);
+			msgArea.setPreferredSize(psx - 20, psy);
 			this.addLast(msgArea.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.HGROW, CellConstants.HEXPAND | CellConstants.HGROW);
 			warnings = new TextMessage(&quot;&quot;);
 			warnings.autoWrap = autoWrap;
-			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND |CellConstants.VGROW);
+			this.addLast(warnings.getScrollablePanel(), CellConstants.HEXPAND | CellConstants.VEXPAND | CellConstants.VGROW, CellConstants.HEXPAND | CellConstants.VEXPAND | CellConstants.VGROW);
 			mB.set(ControlConstants.Disabled, true);
 			mB.setPreferredSize(40, 20);
 			addLast(mB, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
@@ -142,48 +150,52 @@
 		}
 	}
 
-	public void setInfo(String info){
+	public void setInfo(String info) {
 		msgArea.setText(info);
 		this.repaintNow();
 	}
-	
+
 	public void setInfoHeight(int heighti) {
 		msgArea.setPreferredSize(getPreferredSize(null).width, heighti);
 	}
+
 	public void setInfoWidth(int widthi) {
-		msgArea.setPreferredSize(widthi,getPreferredSize(null).height);
+		msgArea.setPreferredSize(widthi, getPreferredSize(null).height);
 	}
-	public String getInfo(){
+
+	public String getInfo() {
 		return msgArea.getText();
 	}
 
-	public void addWarning (String w) {
+	public void addWarning(String w) {
 		warnings.setText(warnings.text + w);
 	}
-	public void addOkButton() { //unfortunately this doesn't work
+
+	public void addOkButton() { // unfortunately this doesn't work
 		mB.set(ControlConstants.Disabled, false);
-		//addNext(mB);
-		//relayout(true);
-		//mB.set(Control.Invisible, false);
+		// addNext(mB);
+		// relayout(true);
+		// mB.set(Control.Invisible, false);
 		this.repaintNow();
 	}
 
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
-			if(ev.target == mB){
-				if(type == CHECKBOX) mCB_state = mCB.getState();
+			if (ev.target == mB) {
+				if (type == CHECKBOX)
+					mCB_state = mCB.getState();
 				this.close(FormBase.IDOK);
 			}
-			if(ev.target == mC){
+			if (ev.target == mC) {
 				this.close(FormBase.IDCANCEL);
 			}
 		}
 		super.onEvent(ev);
 	}
-	
+
 	protected boolean canExit(int exitCode) {
-		isClosed=true;
+		isClosed = true;
 		return true;
 	}
-	
+
 }
\ No newline at end of file

Modified: branches/r1.2/src/CacheWolf/LogList.java
===================================================================
--- branches/r1.2/src/CacheWolf/LogList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/LogList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,55 +1,56 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.util.Vector;
 
 public class LogList {
-	/** The Vector containing the Log objects 
-	 * The list is always sorted in descending order */
-	private Vector logList=new Vector(10);
+	/**
+	 * The Vector containing the Log objects The list is always sorted in descending order
+	 */
+	private Vector logList = new Vector(10);
 	private static final StringBuffer buffer = new StringBuffer();
 
 	/** Construct an empty Log list */
 	public LogList() { // Public constructor
 	}
-	
+
 	/** Get the Log at a certain position in the list */
 	public Log getLog(int i) {
-		if (logList.size()&gt;i) {
-			return (Log) logList.elementAt(i);			
-		}
-		else return null;
+		if (logList.size() &gt; i) {
+			return (Log) logList.elementAt(i);
+		} else
+			return null;
 	}
-	
+
 	/** Return the size of the list */
 	public int size() {
 		return logList.size();
 	}
-	
+
 	/** Clear the Log list */
 	public void clear() {
 		logList.clear();
@@ -57,9 +58,10 @@
 
 	/** Add a Log to the list */
 	public void add(Log log) {
-		if (log.getIcon()!=null) logList.add(log); // Don't add invalid logs
+		if (log.getIcon() != null)
+			logList.add(log); // Don't add invalid logs
 	}
-	
+
 	/** Remove a Log from the list */
 	public void remove(int i) {
 		logList.removeElementAt(i);
@@ -69,47 +71,49 @@
 	public void replace(int i, Log log) {
 		logList.set(i, log);
 	}
-	
-	/** Merge a log into the list at the appropriate position
+
+	/**
+	 * Merge a log into the list at the appropriate position
+	 * 
 	 * @param newLog
 	 * @return the position where the log was placed or -1 if it is already in the list
-	 */ 
-	 
+	 */
+
 	public int merge(Log newLog) {
-		String newDate=newLog.getDate();
-		int size=size();
+		String newDate = newLog.getDate();
+		int size = size();
 		int i;
-		for (i=0; i&lt;size; i++) {
-			 int comp=newDate.compareTo(((Log) logList.elementAt(i)).getDate());
-			 if (comp&gt;0) {
-				 logList.insertElementAt(newLog, i);
-				 return i;
-			 }
-			 if (comp==0) break;
+		for (i = 0; i &lt; size; i++) {
+			int comp = newDate.compareTo(((Log) logList.elementAt(i)).getDate());
+			if (comp &gt; 0) {
+				logList.insertElementAt(newLog, i);
+				return i;
+			}
+			if (comp == 0)
+				break;
 		}
 		// Now i points to the first log with same date as the new log or i==size()
-		if (i==size) {
+		if (i == size) {
 			add(newLog);
 			return size;
 		}
-		int firstLog=i;
+		int firstLog = i;
 		// Check whether we have any logs with same date by same user
-		String newLogger=newLog.getLogger();
-		String newIcon=newLog.getIcon();
-		while (i&lt;size &amp;&amp;  newDate.equals(((Log) logList.elementAt(i)).getDate())) {
-			Log log=(Log) logList.elementAt(i);
-			if (log.getLogger().equals(newLogger) &amp;&amp;
-				log.getIcon().equals(newIcon)) {
+		String newLogger = newLog.getLogger();
+		String newIcon = newLog.getIcon();
+		while (i &lt; size &amp;&amp; newDate.equals(((Log) logList.elementAt(i)).getDate())) {
+			Log log = (Log) logList.elementAt(i);
+			if (log.getLogger().equals(newLogger) &amp;&amp; log.getIcon().equals(newIcon)) {
 				// Has the log message changed vs. the one we have in cache.xml?
 				if (!log.getMessage().equals(newLog.getMessage())) {
-					replace(i,newLog);
+					replace(i, newLog);
 					return i;
 				} else
 					return -1; // Log already in list
 			}
 			i++;
 		}
-		if (i==size) {
+		if (i == size) {
 			add(newLog);
 			return i;
 		} else {
@@ -118,20 +122,18 @@
 		}
 	}
 
-	 /**
-	  *  Count the number of not-found logs
-	  */
+	/**
+	 * Count the number of not-found logs
+	 */
 	public byte countNotFoundLogs() {
 		byte countNoFoundLogs = 0;
 		int currentLog = 0;
 		String currentIcon;
-		while(currentLog &lt; size() &amp;&amp; countNoFoundLogs &lt; 5){
+		while (currentLog &lt; size() &amp;&amp; countNoFoundLogs &lt; 5) {
 			currentIcon = getLog(currentLog).getIcon();
-			if(currentIcon.startsWith(&quot;icon_sad&quot;)) {
+			if (currentIcon.startsWith(&quot;icon_sad&quot;)) {
 				countNoFoundLogs++;
-			}else if (currentIcon.startsWith(&quot;icon_smile&quot;) || currentIcon.startsWith(&quot;icon_camera&quot;)
-             || currentIcon.startsWith(&quot;icon_attended&quot;) || currentIcon.startsWith(&quot;icon_rsvp&quot;)
-             || currentIcon.startsWith(&quot;icon_maint&quot;)) {
+			} else if (currentIcon.startsWith(&quot;icon_smile&quot;) || currentIcon.startsWith(&quot;icon_camera&quot;) || currentIcon.startsWith(&quot;icon_attended&quot;) || currentIcon.startsWith(&quot;icon_rsvp&quot;) || currentIcon.startsWith(&quot;icon_maint&quot;)) {
 				break;
 			}
 			currentLog++;
@@ -139,51 +141,57 @@
 		return countNoFoundLogs;
 	}
 
-	 /** only valid after calling calcRecommendations() */
-	 int numRecommended = 0;
-	 /** only valid after calling calcRecommendations() */
-	 int foundsSinceRecommendation = 0;
-	 /** only valid after calling calcRecommendations() */
-	 int recommendationRating = 0;
-	 
-	 /**
-	  * call this to 
-	  *
-	  */
-	 public void calcRecommendations() {
-		 numRecommended = 0;
-		 foundsSinceRecommendation = 0;
-		 Log l;
-		 int s = size();
-		 int i;
-		 for (i= 0 ; i &lt; s; i++){
-			 l = getLog(i);
-			 if (l.getDate().compareTo(&quot;2007-01-14&quot;) &lt; 0) break; // this is the date when the recommendation system was introdueced in opencaching.de see: <A HREF="http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel">http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel</A>
-			 if (l.isRecomended()) numRecommended++;
-			 if (l.isFoundLog()) foundsSinceRecommendation++; 
-		 }
-		 recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
-	 }
-	 
-	 public static int getScore(int numrecommends, int numfoundlogs) {
-		 return Math.round((((float)numrecommends * (float)numrecommends +1f ) / (numfoundlogs / 10f +1f))*100f);
-	 }
-	 
-	 /**
-	  * Returns a simple concatenation of all Log texts of the list. Intended for text search in 
-	  * Logs.
+	/** only valid after calling calcRecommendations() */
+	int numRecommended = 0;
+	/** only valid after calling calcRecommendations() */
+	int foundsSinceRecommendation = 0;
+	/** only valid after calling calcRecommendations() */
+	int recommendationRating = 0;
+
+	/**
+	 * call this to
+	 * 
+	 */
+	public void calcRecommendations() {
+		numRecommended = 0;
+		foundsSinceRecommendation = 0;
+		Log l;
+		int s = size();
+		int i;
+		for (i = 0; i &lt; s; i++) {
+			l = getLog(i);
+			// 2007-01-14 is the date when the recommendation system was introdueced in opencaching.de see:
+			// <A HREF="http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel">http://www.geoclub.de/viewtopic.php?t=14901&amp;highlight=formel</A>
+			if (l.getDate().compareTo(&quot;2007-01-14&quot;) &lt; 0)
+				break;
+			if (l.isRecomended())
+				numRecommended++;
+			if (l.isFoundLog())
+				foundsSinceRecommendation++;
+		}
+		recommendationRating = getScore(numRecommended, foundsSinceRecommendation);
+	}
+
+	public static int getScore(int numrecommends, int numfoundlogs) {
+		return Math.round((((float) numrecommends * (float) numrecommends + 1f) / (numfoundlogs / 10f + 1f)) * 100f);
+	}
+
+	/**
+	 * Returns a simple concatenation of all Log texts of the list. Intended for text search in Logs.
+	 * 
 	 * @return All log messages
 	 */
 	public String allMessages() {
-		 buffer.setLength(0);
-		 for (int i=0; i&lt;logList.size(); i++) {
-			 buffer.append(((Log)logList.get(i)).getMessage());
-		 }
-		 return buffer.toString();
-	 }
+		buffer.setLength(0);
+		for (int i = 0; i &lt; logList.size(); i++) {
+			buffer.append(((Log) logList.get(i)).getMessage());
+		}
+		return buffer.toString();
+	}
 
 	/**
 	 * trim down number of log to maximum number user wants to keep in database
+	 * 
 	 * @return number of removed logs
 	 */
 	public int purgeLogs() {
@@ -191,12 +199,12 @@
 		boolean keepOwn = Global.getPref().alwaysKeepOwnLogs;
 		int purgedLogs = 0;
 		for (int i = logList.size(); i &gt; maxKeep; i--) {
-			if (!(keepOwn &amp;&amp; getLog(i-1).isOwnLog())) {
-				this.remove(i-1);
+			if (!(keepOwn &amp;&amp; getLog(i - 1).isOwnLog())) {
+				this.remove(i - 1);
 				purgedLogs++;
 			}
 		}
 		return purgedLogs;
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/MainForm.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainForm.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MainForm.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -83,6 +83,7 @@
 		pref.setPathToConfigFile(pathtoprefxml); // in case pathtoprefxml == null the preferences will determine the path itself
 		doIt();
 	}
+	
 	protected void checkButtons() {
 		if (pref.hasCloseButton) super.checkButtons();
 	}
@@ -189,8 +190,7 @@
 
 	private void addGuiFont(){
 		Font defaultGuiFont = mApp.findFont(&quot;gui&quot;);
-		int sz = (pref.fontSize);
-		Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+		Font newGuiFont = new Font(pref.fontName, defaultGuiFont.getStyle(), pref.fontSize);
 		mApp.addFont(newGuiFont, &quot;gui&quot;);
 		mApp.fontsChanged();
 		mApp.mainApp.font = newGuiFont;

Modified: branches/r1.2/src/CacheWolf/MainMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainMenu.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MainMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.exp.ASCExporter;
@@ -32,6 +32,7 @@
 import CacheWolf.exp.KMLExporter;
 import CacheWolf.exp.LocExporter;
 import CacheWolf.exp.MSARCSVExporter;
+import CacheWolf.exp.OCLogExport;
 import CacheWolf.exp.OVLExporter;
 import CacheWolf.exp.OziExporter;
 import CacheWolf.exp.SpoilerPOIExporter;
@@ -41,12 +42,15 @@
 import CacheWolf.imp.GCVoteImporter;
 import CacheWolf.imp.GPXImporter;
 import CacheWolf.imp.LOCXMLImporter;
+import CacheWolf.imp.OCGPXfetch;
+import CacheWolf.imp.OCLinkImporter;
 import CacheWolf.imp.OCXMLImporter;
 import CacheWolf.imp.OCXMLImporterScreen;
 import CacheWolf.imp.SpiderGC;
 import CacheWolf.navi.MapImporter;
 import CacheWolf.navi.MapLoaderGui;
 import CacheWolf.navi.SelectMap;
+import CacheWolf.view.TravelbugJourneyScreenFactory;
 import ewe.filechooser.FileChooser;
 import ewe.filechooser.FileChooserBase;
 import ewe.fx.Font;
@@ -69,212 +73,198 @@
 import ewe.util.Vector;
 
 /**
- *	This class creates the menu for cachewolf. It is also responsible
- *	for reacting to user inputs in the menu.&lt;br&gt;
- *	This class id=100
- *	@see MainForm
- *	@see MainTab
- *   Last change:
- *     20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
+ * This class creates the menu for cachewolf. It is also responsible for reacting to user inputs in the menu.&lt;br&gt;
+ * This class id=100
+ * 
+ * @see MainForm
+ * @see MainTab Last change: 20061123 salzkammergut Tidied up, added MyLocale, added additional internationalisation, combine save/filter for small screens, garminConn
  */
 public class MainMenu extends MenuBar {
-	private MenuItem preferences, mnuContext,loadcaches,loadOC, /* savenexit, */ savenoxit,exit,search,searchAll,searchClr;
+	private MenuItem preferences, mnuContext, loadcaches, loadOC, loadOCFinds, savenoxit, exit, search, searchAll, searchClr;
 	private MenuItem downloadmap, kalibmap, importmap, selectMapPath;
-	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, update, chkVersion;
+	private MenuItem spider, spiderRoute, spiderQuick, spiderAllFinds, loadGCVotes, fetchOCLink, update, chkVersion;
 	private MenuItem about, wolflang, sysinfo, legend;
 	private MenuItem exportGpxNg, exporthtml, exporttop50, exportASC, exportTomTom, exportMSARCSV, exportSpoilerPOI;
-	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist;
+	private MenuItem exportOZI, exportKML, exportTPL, exportExplorist, exportOCLog;
 	private MenuItem filtCreate, filtClear, filtInvert, filtSelected, filtNonSelected, filtBlack, filtApply;
-	private MenuItem exportLOC, exportGPS, mnuSeparator=new MenuItem(&quot;-&quot;);
-	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete,orgRebuild,orgCheckNotesAndSolver;
+	private MenuItem exportLOC, exportGPS, mnuSeparator = new MenuItem(&quot;-&quot;);
+	private MenuItem orgNewWP, orgCopy, orgMove, orgDelete, orgRebuild, orgCheckNotesAndSolver;
 	public MenuItem cacheTour, orgTravelbugs, mnuForceLogin;
 	private MenuItem mnuNewProfile, mnuOpenProfile, mnuDeleteProfile, mnuRenameProfile, mnuEditCenter;
 	private Form father;
 	private TablePanel tbp;
-	private FilterScreen scnFilter=new FilterScreen();
+	private FilterScreen scnFilter = new FilterScreen();
 	private static boolean searchInDescriptionAndNotes = false;
 	private static boolean searchInLogs = false;
+	GCVoteImporter sGCV = null;
 
-	public MainMenu(Form f){
+	public MainMenu(Form f) {
 
 		Global.getPref().setgpsbabel();
 
 		father = f;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for profiles, part of &quot;Application&quot; menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mnuProfile = {
-			mnuNewProfile = new MenuItem(MyLocale.getMsg(1107,&quot;New&quot;)),
-			mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109,&quot;Open&quot;)),
-			mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125,&quot;Delete&quot;)),
-			mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126,&quot;Rename&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] mnuProfile = { mnuNewProfile = new MenuItem(MyLocale.getMsg(1107, &quot;New&quot;)), //
+				mnuOpenProfile = new MenuItem(MyLocale.getMsg(1109, &quot;Open&quot;)), //
+				mnuDeleteProfile = new MenuItem(MyLocale.getMsg(1125, &quot;Delete&quot;)), //
+				mnuRenameProfile = new MenuItem(MyLocale.getMsg(1126, &quot;Rename&quot;)), //
 		};
-		Menu profileMenu = new Menu(mnuProfile,MyLocale.getMsg(121,&quot;Profiles&quot;));
+		Menu profileMenu = new Menu(mnuProfile, MyLocale.getMsg(121, &quot;Profiles&quot;));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for import, part of &quot;Application&quot; menu below
-		///////////////////////////////////////////////////////////////////////
-		if (Global.getPref().spiderRoute) 
-			spiderRoute = new MenuItem(MyLocale.getMsg(137,&quot;Download along a Route from geocaching.com&quot;));
-		else spiderRoute = mnuSeparator;
-		MenuItem[] mnuImport = {				
-				loadcaches     = new MenuItem(MyLocale.getMsg(129,&quot;Import GPX&quot;)),
-				loadOC         = new MenuItem(MyLocale.getMsg(130,&quot;Download from opencaching&quot;)),
-				spider         = new MenuItem(MyLocale.getMsg(131,&quot;Download from geocaching.com&quot;)),
-				spiderRoute,
-				spiderAllFinds = new MenuItem(MyLocale.getMsg(217,&quot;Spider all finds from geocaching.com&quot;)),
-				spiderQuick    = new MenuItem(MyLocale.getMsg(138,&quot;from GC quick&quot;)),
-				update         = new MenuItem(MyLocale.getMsg(1014,&quot;Update cache data&quot;)),
-				mnuSeparator,
-				loadGCVotes    = new MenuItem(MyLocale.getMsg(1208,&quot;Import ratings from GCVote&quot;)),
-				mnuSeparator,
-				mnuForceLogin  = new MenuItem(MyLocale.getMsg(216,&quot;Always login to GC&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		if (Global.getPref().spiderRoute)
+			spiderRoute = new MenuItem(MyLocale.getMsg(137, &quot;Download along a Route from geocaching.com&quot;));
+		else
+			spiderRoute = mnuSeparator;
+		MenuItem[] mnuImport = { loadcaches = new MenuItem(MyLocale.getMsg(129, &quot;Import GPX&quot;)), //
+				mnuSeparator, //
+				loadOC = new MenuItem(MyLocale.getMsg(130, &quot;Download from opencaching&quot;)), //
+				loadOCFinds = new MenuItem(MyLocale.getMsg(163, &quot;Finds from opencaching&quot;)), //
+				mnuSeparator, //
+				spider = new MenuItem(MyLocale.getMsg(131, &quot;Download from geocaching.com&quot;)), //
+				spiderRoute, //
+				spiderAllFinds = new MenuItem(MyLocale.getMsg(217, &quot;Spider all finds from geocaching.com&quot;)), //
+				spiderQuick = new MenuItem(MyLocale.getMsg(138, &quot;from GC quick&quot;)), //
+				update = new MenuItem(MyLocale.getMsg(1014, &quot;Update cache data&quot;)), //
+				mnuSeparator, //
+				loadGCVotes = new MenuItem(MyLocale.getMsg(1208, &quot;Import ratings from GCVote&quot;)), //
+				fetchOCLink = new MenuItem(MyLocale.getMsg(1209, &quot;Fetch link to OC - Cache&quot;)), //
+				mnuSeparator, //
+				mnuForceLogin = new MenuItem(MyLocale.getMsg(216, &quot;Always login to GC&quot;)), //
 		};
-		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175,&quot;Import&quot;));
-		if (Global.getPref().forceLogin) mnuForceLogin.modifiers^=MenuItem.Checked;
+		Menu importMenu = new Menu(mnuImport, MyLocale.getMsg(175, &quot;Import&quot;));
+		if (Global.getPref().forceLogin)
+			mnuForceLogin.modifiers ^= MenuItem.Checked;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for export, part of &quot;Application&quot; menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] exitems = {
-				exporthtml = new MenuItem(MyLocale.getMsg(100,&quot;to HTML&quot;)),
-				exportGpxNg = new MenuItem(MyLocale.getMsg(101,&quot;to GPX Test&quot;)),
-				exporttop50 = new MenuItem(MyLocale.getMsg(102,&quot;to TOP50 ASCII&quot;)),
-				exportASC = new MenuItem(MyLocale.getMsg(104,&quot;to CSV&quot;)),
-				exportTomTom = new MenuItem(MyLocale.getMsg(105,&quot;to TomTom&quot;)),
-				exportMSARCSV = new MenuItem(MyLocale.getMsg(106,&quot;to MS AutoRoute CSV&quot;)),
-				exportLOC = new MenuItem(MyLocale.getMsg(215,&quot;to LOC&quot;)),
-				exportGPS = new MenuItem(MyLocale.getMsg(122,&quot;to GPS&quot;)),
-				exportOZI = new MenuItem(MyLocale.getMsg(124,&quot;to OZI&quot;)),
-				exportKML = new MenuItem(MyLocale.getMsg(125,&quot;to Google Earth&quot;)),
-				exportExplorist = new MenuItem(MyLocale.getMsg(132,&quot;to Explorist&quot;)),
-				exportTPL = new MenuItem(MyLocale.getMsg(128,&quot;via Template&quot;)),
-				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135,&quot;to SpoilerPOI&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] exitems = { exporthtml = new MenuItem(MyLocale.getMsg(100, &quot;to HTML&quot;)), //
+				exportGpxNg = new MenuItem(MyLocale.getMsg(101, &quot;to GPX Test&quot;)), //
+				exporttop50 = new MenuItem(MyLocale.getMsg(102, &quot;to TOP50 ASCII&quot;)), //
+				exportASC = new MenuItem(MyLocale.getMsg(104, &quot;to CSV&quot;)), //
+				exportTomTom = new MenuItem(MyLocale.getMsg(105, &quot;to TomTom&quot;)), //
+				exportMSARCSV = new MenuItem(MyLocale.getMsg(106, &quot;to MS AutoRoute CSV&quot;)), //
+				exportLOC = new MenuItem(MyLocale.getMsg(215, &quot;to LOC&quot;)), //
+				exportGPS = new MenuItem(MyLocale.getMsg(122, &quot;to GPS&quot;)), //
+				exportOZI = new MenuItem(MyLocale.getMsg(124, &quot;to OZI&quot;)), //
+				exportKML = new MenuItem(MyLocale.getMsg(125, &quot;to Google Earth&quot;)), //
+				exportExplorist = new MenuItem(MyLocale.getMsg(132, &quot;to Explorist&quot;)), //
+				exportSpoilerPOI = new MenuItem(MyLocale.getMsg(135, &quot;to SpoilerPOI&quot;)), //
+				exportTPL = new MenuItem(MyLocale.getMsg(128, &quot;via Template&quot;)), //
+				exportOCLog = new MenuItem(MyLocale.getMsg(1210, &quot;logs to OC&quot;)), //
 		};
-		if ( Global.getPref().gpsbabel == null ) {
+		if (Global.getPref().gpsbabel == null) {
 			exportGPS.modifiers = MenuItem.Disabled;
-			exportGPS.setText(MyLocale.getMsg(136,&quot;to GPS : gpsbabel missing.&quot;));
+			exportGPS.setText(MyLocale.getMsg(136, &quot;to GPS : gpsbabel missing.&quot;));
 		}
+		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107, &quot;Export&quot;));
 
-		Menu exportMenu = new Menu(exitems, MyLocale.getMsg(107,&quot;Export&quot;));
-
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// subMenu for maps, part of &quot;Application&quot; menu below
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] mapMenuItems = {
-				downloadmap = new MenuItem(MyLocale.getMsg(162,&quot;Download calibrated&quot;)),
-				importmap = new MenuItem(MyLocale.getMsg(150,&quot;Import&quot;)),
-				kalibmap = new MenuItem(MyLocale.getMsg(151,&quot;Calibrate&quot;)),
-				selectMapPath = new MenuItem(MyLocale.getMsg(4236, &quot;Change map directory$c&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] mapMenuItems = { downloadmap = new MenuItem(MyLocale.getMsg(162, &quot;Download calibrated&quot;)), //
+				importmap = new MenuItem(MyLocale.getMsg(150, &quot;Import&quot;)), //
+				kalibmap = new MenuItem(MyLocale.getMsg(151, &quot;Calibrate&quot;)), //
+				selectMapPath = new MenuItem(MyLocale.getMsg(4236, &quot;Change map directory$c&quot;)), //
 		};
 		Menu mapsMenu = new Menu(mapMenuItems, null);
 
 		// Now we start with the horizontal menu bar &quot;Application&quot;, &quot;Search&quot;, &quot;Filter&quot;, &quot;Organise&quot;, &quot;About&quot;
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the &quot;Application&quot; pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem [] appMenuItems={
-				new MenuItem(MyLocale.getMsg(121,&quot;Profile&quot;), 0, profileMenu),
-				preferences = new MenuItem(MyLocale.getMsg(108,&quot;Preferences&quot;)),
-				mnuEditCenter = new MenuItem(MyLocale.getMsg(1110,&quot;Centre&quot;)),
-				mnuContext = new MenuItem(MyLocale.getMsg(134,&quot;Current Cache&quot;)),
-				mnuSeparator,
-				new MenuItem(MyLocale.getMsg(175,&quot;Import&quot;),0,importMenu),
-				new MenuItem(MyLocale.getMsg(107,&quot;Export&quot;),0,exportMenu),
-				new MenuItem(MyLocale.getMsg(149,&quot;Maps&quot;),0,mapsMenu),
-				mnuSeparator,
-				savenoxit = new MenuItem(MyLocale.getMsg(127,&quot;Save&quot;)),
-				// savenexit = new MenuItem(MyLocale.getMsg(110,&quot;Save &amp; Exit&quot;)),
-				exit = new MenuItem(MyLocale.getMsg(111,&quot;Exit&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] appMenuItems = { new MenuItem(MyLocale.getMsg(121, &quot;Profile&quot;), 0, profileMenu), //
+				preferences = new MenuItem(MyLocale.getMsg(108, &quot;Preferences&quot;)), //
+				mnuEditCenter = new MenuItem(MyLocale.getMsg(1110, &quot;Centre&quot;)), //
+				mnuContext = new MenuItem(MyLocale.getMsg(134, &quot;Current Cache&quot;)), //
+				mnuSeparator, new MenuItem(MyLocale.getMsg(175, &quot;Import&quot;), 0, importMenu), //
+				new MenuItem(MyLocale.getMsg(107, &quot;Export&quot;), 0, exportMenu), //
+				new MenuItem(MyLocale.getMsg(149, &quot;Maps&quot;), 0, mapsMenu), //
+				mnuSeparator, //
+				savenoxit = new MenuItem(MyLocale.getMsg(127, &quot;Save&quot;)), //
+				exit = new MenuItem(MyLocale.getMsg(111, &quot;Exit&quot;)), //
 		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(120,&quot;Application&quot;),new Menu(appMenuItems,null)));
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(120, &quot;Application&quot;), new Menu(appMenuItems, null)));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the &quot;Search&quot; pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] searchMenuItems={
-				search = new MenuItem(MyLocale.getMsg(112,&quot;Search$&quot;+(char)6)),// char 6 = ctrl +f
-				searchAll = new MenuItem(MyLocale.getMsg(133,&quot;Search All&quot;)),
-				searchClr = new MenuItem(MyLocale.getMsg(113,&quot;Clear search&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] searchMenuItems = { search = new MenuItem(MyLocale.getMsg(112, &quot;Search$&quot; + (char) 6)), // char 6 = ctrl +f
+				searchAll = new MenuItem(MyLocale.getMsg(133, &quot;Search All&quot;)), //
+				searchClr = new MenuItem(MyLocale.getMsg(113, &quot;Clear search&quot;)), //
 		};
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the &quot;Filter&quot; pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterMenuItems={
-				filtApply  = new MenuItem(MyLocale.getMsg(709,&quot;Apply&quot;)),
-				filtCreate  = new MenuItem(MyLocale.getMsg(114,&quot;Create&quot;)),
-				filtInvert  = new MenuItem(MyLocale.getMsg(115,&quot;Invert&quot;)),
-				filtClear   = new MenuItem(MyLocale.getMsg(116,&quot;Clear&quot;)),
-				mnuSeparator,
-				filtSelected = new MenuItem(MyLocale.getMsg(160,&quot;Filter selected&quot;)),
-				filtNonSelected = new MenuItem(MyLocale.getMsg(1011,&quot;Filter out non selected&quot;)),
-				mnuSeparator,
-				filtBlack   = new MenuItem(MyLocale.getMsg(161,&quot;Show Blacklist&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] filterMenuItems = { filtApply = new MenuItem(MyLocale.getMsg(709, &quot;Apply&quot;)), filtCreate = new MenuItem(MyLocale.getMsg(114, &quot;Create&quot;)), filtInvert = new MenuItem(MyLocale.getMsg(115, &quot;Invert&quot;)),
+				filtClear = new MenuItem(MyLocale.getMsg(116, &quot;Clear&quot;)), //
+				mnuSeparator, //
+				filtSelected = new MenuItem(MyLocale.getMsg(160, &quot;Filter selected&quot;)), //
+				filtNonSelected = new MenuItem(MyLocale.getMsg(1011, &quot;Filter out non selected&quot;)), //
+				mnuSeparator, filtBlack = new MenuItem(MyLocale.getMsg(161, &quot;Show Blacklist&quot;)), //
 		};
-        filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+		filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers &amp; ~MenuItem.Checked;
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create a combined &quot;Filter and Search&quot; pulldown menu for devices with small screens
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] filterAndSearchMenuItems={
-				filtApply,
-				filtCreate,
-				filtInvert,
-				filtClear,
-				mnuSeparator,
-				filtSelected,
-				filtNonSelected,
-				mnuSeparator,
-				filtBlack,
-				mnuSeparator,
-				search,
-				searchClr,
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] filterAndSearchMenuItems = { filtApply, //
+				filtCreate, //
+				filtInvert, //
+				filtClear, //
+				mnuSeparator, //
+				filtSelected, //
+				filtNonSelected, //
+				mnuSeparator, //
+				filtBlack, //
+				mnuSeparator, //
+				search, //
+				searchClr, //
 		};
 
 		// Depending on screen width display either filter and search menus or the combined menu
-		if (MyLocale.getScreenWidth()&gt;300) {
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(112,&quot;Search&quot;),new Menu(searchMenuItems,null)));
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,&quot;Filter&quot;),new Menu(filterMenuItems,null)));
+		if (MyLocale.getScreenWidth() &gt; 300) {
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(112, &quot;Search&quot;), new Menu(searchMenuItems, null)));
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159, &quot;Filter&quot;), new Menu(filterMenuItems, null)));
 		} else {
-			this.addMenu(new PullDownMenu(MyLocale.getMsg(159,&quot;Filter&quot;),new Menu(filterAndSearchMenuItems,null)));
+			this.addMenu(new PullDownMenu(MyLocale.getMsg(159, &quot;Filter&quot;), new Menu(filterAndSearchMenuItems, null)));
 		}
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the &quot;Organise&quot; pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] organiseMenuItems={				
-				orgNewWP = new MenuItem(MyLocale.getMsg(214,&quot;New Waypoint&quot;)),
-				mnuSeparator,
-				orgCopy  = new MenuItem(MyLocale.getMsg(141,&quot;Copy&quot;)),
-				orgMove  = new MenuItem(MyLocale.getMsg(142,&quot;Move&quot;)),
-				orgDelete   = new MenuItem(MyLocale.getMsg(143,&quot;Delete&quot;)),
-				orgRebuild   = new MenuItem(MyLocale.getMsg(208,&quot;Rebuild Index&quot;)),
-				orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220,&quot;Check Notes/Solver&quot;)),
-				mnuSeparator,
-				orgTravelbugs = new MenuItem(MyLocale.getMsg(139,&quot;Manage travelbugs&quot;)),
-				cacheTour = new MenuItem(MyLocale.getMsg(198,&quot;Cachetour&quot;)),
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] organiseMenuItems = { orgNewWP = new MenuItem(MyLocale.getMsg(214, &quot;New Waypoint&quot;)), //
+				mnuSeparator, //
+				orgCopy = new MenuItem(MyLocale.getMsg(141, &quot;Copy&quot;)), //
+				orgMove = new MenuItem(MyLocale.getMsg(142, &quot;Move&quot;)), //
+				orgDelete = new MenuItem(MyLocale.getMsg(143, &quot;Delete&quot;)), //
+				orgRebuild = new MenuItem(MyLocale.getMsg(208, &quot;Rebuild Index&quot;)), //
+				orgCheckNotesAndSolver = new MenuItem(MyLocale.getMsg(220, &quot;Check Notes/Solver&quot;)), //
+				mnuSeparator, //
+				orgTravelbugs = new MenuItem(MyLocale.getMsg(139, &quot;Manage travelbugs&quot;)), //
+				cacheTour = new MenuItem(MyLocale.getMsg(198, &quot;Cachetour&quot;)), //
 		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(140,&quot;Organise&quot;),new Menu(organiseMenuItems,null)));
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(140, &quot;Organise&quot;), new Menu(organiseMenuItems, null)));
 
-		///////////////////////////////////////////////////////////////////////
+		// /////////////////////////////////////////////////////////////////////
 		// Create the &quot;About&quot; pulldown menu
-		///////////////////////////////////////////////////////////////////////
-		MenuItem[] aboutMenuItems={
-				about = new MenuItem(MyLocale.getMsg(117,&quot;About&quot;)),
-				legend = new MenuItem(MyLocale.getMsg(155,&quot;Legend&quot;)),
-				wolflang = new MenuItem(MyLocale.getMsg(118,&quot;WolfLanguage&quot;)),
-				sysinfo = new MenuItem(MyLocale.getMsg(157,&quot;System&quot;)),
-				chkVersion = new MenuItem(MyLocale.getMsg(158,&quot;Version Check&quot;)),
-		};
-		this.addMenu(new PullDownMenu(MyLocale.getMsg(117,&quot;About&quot;),new Menu(aboutMenuItems,null)));
+		// /////////////////////////////////////////////////////////////////////
+		MenuItem[] aboutMenuItems = { about = new MenuItem(MyLocale.getMsg(117, &quot;About&quot;)), legend = new MenuItem(MyLocale.getMsg(155, &quot;Legend&quot;)), wolflang = new MenuItem(MyLocale.getMsg(118, &quot;WolfLanguage&quot;)),
+				sysinfo = new MenuItem(MyLocale.getMsg(157, &quot;System&quot;)), chkVersion = new MenuItem(MyLocale.getMsg(158, &quot;Version Check&quot;)), };
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(117, &quot;About&quot;), new Menu(aboutMenuItems, null)));
 	}
 
-	public void setTablePanel(TablePanel t){
+	public void setTablePanel(TablePanel t) {
 		tbp = t;
 		if (mnuContext.subMenu == null) {
-			if ((&quot;,&quot;+Global.getPref().listColMap+&quot;,&quot;).indexOf(&quot;,0,&quot;)&gt;=0)
+			if ((&quot;,&quot; + Global.getPref().listColMap + &quot;,&quot;).indexOf(&quot;,0,&quot;) &gt;= 0)
 				mnuContext.subMenu = tbp.tc.getMenuFull();
 			else
 				mnuContext.subMenu = tbp.tc.getMenuSmall();
@@ -283,21 +273,17 @@
 
 	public void allowProfileChange(boolean profileChangeAllowed) {
 		if (profileChangeAllowed) {
-			mnuNewProfile.modifiers&amp;=~MenuItem.Disabled;
-			mnuOpenProfile.modifiers&amp;=~MenuItem.Disabled;
+			mnuNewProfile.modifiers &amp;= ~MenuItem.Disabled;
+			mnuOpenProfile.modifiers &amp;= ~MenuItem.Disabled;
 		} else {
-			mnuNewProfile.modifiers|=MenuItem.Disabled;
-			mnuOpenProfile.modifiers|=MenuItem.Disabled;
+			mnuNewProfile.modifiers |= MenuItem.Disabled;
+			mnuOpenProfile.modifiers |= MenuItem.Disabled;
 		}
 	}
 
-	public void setForceLogin() {
-		mnuForceLogin.modifiers=Global.getPref().forceLogin ? Global.mainTab.mnuMain.modifiers|MenuItem.Checked : Global.mainTab.mnuMain.modifiers&amp;~MenuItem.Checked;
-	}
-
 	public static void search() {
-		SearchBox inp = new SearchBox(MyLocale.getMsg(119,&quot;Search for:&quot;));
-		String srch = inp.input(null,&quot;&quot;,searchInDescriptionAndNotes,searchInLogs,10);
+		SearchBox inp = new SearchBox(MyLocale.getMsg(119, &quot;Search for:&quot;));
+		String srch = inp.input(null, &quot;&quot;, searchInDescriptionAndNotes, searchInLogs, 10);
 		MyLocale.setSIPOff();
 		if (srch != null) {
 			searchInDescriptionAndNotes = inp.useNoteDesc();
@@ -307,332 +293,352 @@
 			Global.mainTab.tbP.refreshTable();
 		}
 	}
-	public void onEvent(Event ev){
-		Preferences pref=Global.getPref();
-		Profile profile=Global.getProfile();
-		CacheDB cacheDB=profile.cacheDB;
+
+	public void onEvent(Event ev) {
+		Preferences pref = Global.getPref();
+		Profile profile = Global.getProfile();
+		CacheDB cacheDB = profile.cacheDB;
 		Global.mainTab.updatePendingChanges();
-		if (ev instanceof MenuEvent){ //&amp;&amp; ev.type == MenuEvent.PRESSED
-			MenuEvent mev = (MenuEvent)ev;
-			///////////////////////////////////////////////////////////////////////
+		if (ev instanceof MenuEvent) { // &amp;&amp; ev.type == MenuEvent.PRESSED
+			MenuEvent mev = (MenuEvent) ev;
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for profiles, part of &quot;Application&quot; menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == mnuNewProfile){
-				if (NewProfileWizard.startNewProfileWizard(getFrame()) ) {
-					tbp.myMod.numRows=0;
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == mnuNewProfile) {
+				if (NewProfileWizard.startNewProfileWizard(getFrame())) {
+					tbp.myMod.numRows = 0;
 					pref.setCurCentrePt(profile.centre);
-		            filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+					filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers &amp; ~MenuItem.Checked;
 					tbp.refreshTable();
 				}
 			}
-			if(mev.selectedItem == mnuOpenProfile){
+			if (mev.selectedItem == mnuOpenProfile) {
 				Global.mainTab.saveUnsavedChanges(true);
-				if (pref.selectProfile(profile,Preferences.PROFILE_SELECTOR_FORCED_ON,false)) {
-					tbp.myMod.sortedBy=-1;
-					tbp.myMod.numRows=0;
+				if (pref.selectProfile(profile, Preferences.PROFILE_SELECTOR_FORCED_ON, false)) {
+					tbp.myMod.sortedBy = -1;
+					tbp.myMod.numRows = 0;
 					CacheHolder.removeAllDetails();
 					profile.cacheDB.clear();
-					InfoBox infB = new InfoBox(&quot;CacheWolf&quot;,MyLocale.getMsg(5000,&quot;Loading Cache-List&quot;));
+					InfoBox infB = new InfoBox(&quot;CacheWolf&quot;, MyLocale.getMsg(5000, &quot;Loading Cache-List&quot;));
 					infB.exec();
 					infB.waitUntilPainted(1000);
 					Vm.showWait(infB, true);
 					profile.readIndex(infB);
 					Vm.showWait(infB, false);
 					pref.setCurCentrePt(profile.centre);
-                    filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
-        			Global.mainForm.setTitle(profile.name + &quot; - CW &quot;+Version.getRelease());
+					filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers &amp; ~MenuItem.Checked;
+					Global.mainForm.setTitle(profile.name + &quot; - CW &quot; + Version.getRelease());
 					infB.close(0);
 					tbp.resetModel();
 				}
 			}
-			if(mev.selectedItem == mnuDeleteProfile) {
-				pref.editProfile(2,227,226);
+			if (mev.selectedItem == mnuDeleteProfile) {
+				pref.editProfile(2, 227, 226);
 			}
-			if(mev.selectedItem == mnuRenameProfile) {
-				pref.editProfile(3,228,229);
+			if (mev.selectedItem == mnuRenameProfile) {
+				pref.editProfile(3, 228, 229);
 			}
-			if(mev.selectedItem == mnuEditCenter){
-				ProfileDataForm f=new ProfileDataForm(pref,profile);
+			if (mev.selectedItem == mnuEditCenter) {
+				ProfileDataForm f = new ProfileDataForm(pref, profile);
 				f.execute(getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 				f.close(0);
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for import, part of &quot;Application&quot; menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == spider){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == spider) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doIt();
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == spiderRoute){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			if (mev.selectedItem == spiderRoute) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doItAlongARoute();
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == spiderQuick){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			if (mev.selectedItem == spiderQuick) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doItQuickFillFromMapList();
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == spiderAllFinds){
-				SpiderGC spGC = new SpiderGC(pref, profile, true);
+			if (mev.selectedItem == spiderAllFinds) {
+				SpiderGC spGC = new SpiderGC(pref, profile);
 				Global.mainTab.saveUnsavedChanges(false);
 				spGC.doIt(true);
 				cacheDB.clear();
 				profile.readIndex();
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == loadGCVotes){
-                GCVoteImporter sGCV = new GCVoteImporter(pref, profile, true);
-                sGCV.doIt();
-                tbp.resetModel();
+			if (mev.selectedItem == loadGCVotes) {
+				if (sGCV == null)
+					sGCV = new GCVoteImporter(pref, profile);
+				sGCV.doIt();
+				tbp.resetModel();
 			}
-			if(mev.selectedItem == loadcaches){
+			if (mev.selectedItem == fetchOCLink) {
+				OCLinkImporter.doIt();
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == loadcaches) {
 				String dir = pref.getImporterPath(&quot;LocGpxImporter&quot;);
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN|FileChooserBase.MULTI_SELECT, dir);
+				FileChooser fc = new FileChooser(FileChooserBase.OPEN | FileChooserBase.MULTI_SELECT, dir);
 				fc.addMask(&quot;*.gpx,*.zip,*.loc,fieldnotes.txt,geocache_visits.txt,FieldNotes.log,newlogs.txt&quot;);
-				fc.setTitle(MyLocale.getMsg(909,&quot;Select file(s)&quot;));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.setTitle(MyLocale.getMsg(909, &quot;Select file(s)&quot;));
+				if (fc.execute() != FormBase.IDCANCEL) {
 					dir = fc.getChosenDirectory().toString();
 					pref.setImporterPath(&quot;LocGpxImporter&quot;, dir);
 					String files[] = fc.getAllChosen();
 					int how = GPXImporter.DOIT_ASK;
-					for (int i = 0; i &lt; files.length; i++){
+					for (int i = 0; i &lt; files.length; i++) {
 						String file = dir + &quot;/&quot; + files[i];
-						if (file.endsWith(&quot;txt&quot;)||file.endsWith(&quot;log&quot;)){
-							FieldnotesImporter fn=new FieldnotesImporter(pref, profile, file);
+						if (file.endsWith(&quot;txt&quot;) || file.endsWith(&quot;log&quot;)) {
+							FieldnotesImporter fn = new FieldnotesImporter(pref, profile, file);
 							fn.doIt();
-						}
-						else if (file.endsWith(&quot;loc&quot;)){
+						} else if (file.endsWith(&quot;loc&quot;)) {
 							LOCXMLImporter loc = new LOCXMLImporter(pref, profile, file);
 							loc.doIt();
-						}
-						else { //gpx + zip
+						} else { // gpx + zip
 							GPXImporter gpx = new GPXImporter(pref, profile, file);
 							gpx.doIt(how);
 							how = gpx.getHow();
 						}
 					}
 				}
-                Global.getProfile().setShowBlacklisted(false);
-                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers &amp; ~MenuItem.Checked;
 				tbp.resetModel();
+				pref.setOldGCLanguage();
 			}
-			if(mev.selectedItem == loadOC){
-				OCXMLImporter oc = new OCXMLImporter(pref,profile);
+			if (mev.selectedItem == loadOC) {
+				OCXMLImporter oc = new OCXMLImporter(pref, profile);
 				oc.doIt();
-                Global.getProfile().setShowBlacklisted(false);
-                filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers &amp; ~MenuItem.Checked;
 				tbp.resetModel();
 			}
-			if (mev.selectedItem == update)
+			if (mev.selectedItem == loadOCFinds) {
+				OCGPXfetch.doIt();
+				Global.getProfile().setShowBlacklisted(false);
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers &amp; ~MenuItem.Checked;
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == update) {
 				updateSelectedCaches(tbp);
-			if(mev.selectedItem == mnuForceLogin) {
-				mnuForceLogin.modifiers^=MenuItem.Checked;
-				Global.getPref().forceLogin=(mnuForceLogin.modifiers&amp;MenuItem.Checked)!=0;
+				pref.setOldGCLanguage();
+			}
+			if (mev.selectedItem == mnuForceLogin) {
+				mnuForceLogin.modifiers ^= MenuItem.Checked;
+				Global.getPref().forceLogin = (mnuForceLogin.modifiers &amp; MenuItem.Checked) != 0;
 				Global.getPref().savePreferences();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for export, part of &quot;Application&quot; menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == exporthtml){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == exporthtml) {
 				HTMLExporter htm = new HTMLExporter(pref, profile);
 				htm.doIt();
 			}
-			if(mev.selectedItem == exportGpxNg){
+			if (mev.selectedItem == exportGpxNg) {
 				GpxExportNg gpx = new GpxExportNg();
 				gpx.doit();
 			}
-			if(mev.selectedItem == exporttop50){
+			if (mev.selectedItem == exporttop50) {
 				OVLExporter ovl = new OVLExporter(pref, profile);
 				ovl.doIt();
 			}
-			if(mev.selectedItem == exportASC){
-				ASCExporter asc = new ASCExporter(pref,profile);
+			if (mev.selectedItem == exportASC) {
+				ASCExporter asc = new ASCExporter(pref, profile);
 				asc.doIt();
 			}
-			if(mev.selectedItem == exportTomTom){
+			if (mev.selectedItem == exportTomTom) {
 				TomTomExporter tt = new TomTomExporter();
 				tt.doIt();
 			}
-			if(mev.selectedItem == exportMSARCSV){
-				MSARCSVExporter msar = new MSARCSVExporter(pref,profile);
+			if (mev.selectedItem == exportMSARCSV) {
+				MSARCSVExporter msar = new MSARCSVExporter(pref, profile);
 				msar.doIt();
 			}
-			if(mev.selectedItem == exportLOC){
+			if (mev.selectedItem == exportLOC) {
 				LocExporter loc = new LocExporter();
 				loc.doIt();
 			}
-			if(mev.selectedItem == exportGPS){
+			if (mev.selectedItem == exportGPS) {
 				String gpsBabelCommand;
 				Vm.showWait(true);
 				LocExporter loc = new LocExporter();
-				//String tmpFileName = FileBase.getProgramDirectory() + &quot;/temp.loc&quot;;
-                //Must not contain special characters, because we don't quote below, because quoting causes problems on some platforms.
-				//Find another way, when CW can be started from outside the program directory.
+				// String tmpFileName = FileBase.getProgramDirectory() + &quot;/temp.loc&quot;;
+				// Must not contain special characters, because we don't quote below, because quoting causes problems on some platforms.
+				// Find another way, when CW can be started from outside the program directory.
 				String tmpFileName = &quot;temp.loc&quot;;
 				loc.setTmpFileName(tmpFileName);
 				loc.doIt(LocExporter.MODE_AUTO);
-				ProgressBarForm.display(MyLocale.getMsg(950,&quot;Transfer&quot;),MyLocale.getMsg(951,&quot;Sending to GPS&quot;), null);
-				gpsBabelCommand = pref.gpsbabel+&quot; &quot;+pref.garminGPSBabelOptions+&quot; -i geo -f &quot;+ tmpFileName +&quot; -o garmin -F &quot; + pref.garminConn +&quot;:&quot;;
-				pref.log(&quot;[MainMenu:onEvent] &quot;+gpsBabelCommand);
+				ProgressBarForm.display(MyLocale.getMsg(950, &quot;Transfer&quot;), MyLocale.getMsg(951, &quot;Sending to GPS&quot;), null);
+				gpsBabelCommand = pref.gpsbabel + &quot; &quot; + pref.garminGPSBabelOptions + &quot; -i geo -f &quot; + tmpFileName + &quot; -o garmin -F &quot; + pref.garminConn + &quot;:&quot;;
+				pref.log(&quot;[MainMenu:onEvent] &quot; + gpsBabelCommand);
 				try {
 					// this will *only* work with ewe.jar at the moment
-					ewe.sys.Process p = Vm.exec( gpsBabelCommand );
+					ewe.sys.Process p = Vm.exec(gpsBabelCommand);
 					p.waitFor();
-				}catch(IOException ioex){
+				} catch (IOException ioex) {
 					Vm.showWait(false);
 					(new MessageBox(&quot;Error&quot;, &quot;Garmin export unsuccessful&quot;, FormBase.OKB)).execute();
-					pref.log(&quot;Error exporting to Garmin&quot;,ioex,true);
-				};
+					pref.log(&quot;Error exporting to Garmin&quot;, ioex, true);
+				}
+				;
 				ProgressBarForm.clear();
 				Vm.showWait(false);
 			}
-			if(mev.selectedItem == exportOZI){
-				OziExporter ozi = new OziExporter( pref, profile);
+			if (mev.selectedItem == exportOZI) {
+				OziExporter ozi = new OziExporter(pref, profile);
 				ozi.doIt();
 			}
-			if(mev.selectedItem == exportKML){
-				KMLExporter kml = new KMLExporter( pref, profile);
+			if (mev.selectedItem == exportKML) {
+				KMLExporter kml = new KMLExporter(pref, profile);
 				kml.doIt();
 			}
-			if(mev.selectedItem == exportTPL){
-				FileChooser fc = new FileChooser(FileChooserBase.OPEN, FileBase.getProgramDirectory()+FileBase.separator+&quot;templates&quot;);
+			if (mev.selectedItem == exportTPL) {
+				FileChooser fc = new FileChooser(FileChooserBase.OPEN, FileBase.getProgramDirectory() + FileBase.separator + &quot;templates&quot;);
 				fc.addMask(&quot;*.tpl&quot;);
-				fc.setTitle(MyLocale.getMsg(910,&quot;Select Template file&quot;));
-				if(fc.execute() != FormBase.IDCANCEL){
-					TPLExporter tpl = new TPLExporter( pref, profile, fc.getChosenFile().toString());
+				fc.setTitle(MyLocale.getMsg(910, &quot;Select Template file&quot;));
+				if (fc.execute() != FormBase.IDCANCEL) {
+					TPLExporter tpl = new TPLExporter(pref, profile, fc.getChosenFile().toString());
 					tpl.doIt();
 				}
 			}
-			if(mev.selectedItem == exportExplorist) {
-				ExploristExporter mag = new ExploristExporter( pref, profile);
+			//
+			if (mev.selectedItem == exportOCLog) {
+				OCLogExport.doit();
+				tbp.resetModel();
+			}
+			if (mev.selectedItem == exportExplorist) {
+				ExploristExporter mag = new ExploristExporter(pref, profile);
 				mag.doIt();
 			}
-			if(mev.selectedItem == exportSpoilerPOI) {
-				SpoilerPOIExporter spoilerpoi = new SpoilerPOIExporter( pref, profile);
+			if (mev.selectedItem == exportSpoilerPOI) {
+				SpoilerPOIExporter spoilerpoi = new SpoilerPOIExporter(pref, profile);
 				spoilerpoi.doIt();
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// subMenu for maps, part of &quot;Application&quot; menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == downloadmap){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == downloadmap) {
 				MapLoaderGui mLG = new MapLoaderGui(cacheDB);
 				mLG.exec(); // .execute doesn't work because the tcp-socket uses another thread which cannot be startet if here .execute() is used!
 			}
-			if(mev.selectedItem == importmap){
+			if (mev.selectedItem == importmap) {
 
 				MapImporter map = new MapImporter(pref);
 				map.importMap();
 			}
-			if(mev.selectedItem == kalibmap){
+			if (mev.selectedItem == kalibmap) {
 				SelectMap sM = new SelectMap();
 				sM.execute();
-				if((sM.getSelectedMap()).length()&gt;0){
+				if ((sM.getSelectedMap()).length() &gt; 0) {
 					try {
-						MapImporter map = new MapImporter(pref, sM.getSelectedMap(),sM.worldfileexists);
+						MapImporter map = new MapImporter(pref, sM.getSelectedMap(), sM.worldfileexists);
 						map.execute(null, Gui.CENTER_FRAME);
 					} catch (java.lang.OutOfMemoryError e) {
-						MessageBox tmpMB=new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(156,&quot;Out of memory error, map to big&quot;), FormBase.OKB);
+						MessageBox tmpMB = new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(156, &quot;Out of memory error, map to big&quot;), FormBase.OKB);
 						tmpMB.exec();
 					}
 				}
 			}
-			if (mev.selectedItem==selectMapPath) {
+			if (mev.selectedItem == selectMapPath) {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 				fc.addMask(&quot;*.wfl&quot;);
-				fc.setTitle(MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
-				if(fc.execute() != FormBase.IDCANCEL){
+				fc.setTitle(MyLocale.getMsg(4200, &quot;Select map directory:&quot;));
+				if (fc.execute() != FormBase.IDCANCEL) {
 					Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
-					//mm.loadMaps(Global.getPref().getCustomMapsPath(), mm.posCircle.where.latDec);
-					//mm.forceMapLoad();
+					// mm.loadMaps(Global.getPref().getCustomMapsPath(), mm.posCircle.where.latDec);
+					// mm.forceMapLoad();
 				}
 
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// &quot;Application&quot; pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == preferences){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == preferences) {
 				tbp.saveColWidth(pref);
 				PreferencesScreen pfs = new PreferencesScreen(pref);
 				pfs.execute(father.getFrame(), Gui.CENTER_FRAME);
 				pref.readPrefFile();
 			}
-			if(mev.selectedItem == savenoxit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == savenoxit) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				tbp.saveColWidth(pref);
 			}
-/*
-			if(mev.selectedItem == savenexit){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
-				tbp.saveColWidth(pref);
-				ewe.sys.Vm.exit(0);
-			}
-*/
-			if(mev.selectedItem == exit){
+			/*
+			 * if(mev.selectedItem == savenexit){ profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR); tbp.saveColWidth(pref); ewe.sys.Vm.exit(0); }
+			 */
+			if (mev.selectedItem == exit) {
 				Global.mainTab.saveUnsavedChanges(true);
 				ewe.sys.Vm.exit(0);
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// &quot;Search&quot; pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == search){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == search) {
 				search();
 			}
-			if(mev.selectedItem == searchAll){
+			if (mev.selectedItem == searchAll) {
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
 				tbp.refreshTable();
-                search();
+				search();
 			}
-			if(mev.selectedItem == searchClr){
+			if (mev.selectedItem == searchClr) {
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();
 				tbp.refreshTable();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// &quot;Filter&quot; pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == filtApply){
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == filtApply) {
 				Filter flt = new Filter();
 				flt.setFilter();
 				flt.doFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtCreate){
+			if (mev.selectedItem == filtCreate) {
 				scnFilter.setData(profile.getCurrentFilter());
 				scnFilter.setPreferredSize(450, 480);
-				if(Vm.isMobile()) scnFilter.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight()); //Fullscreen
+				if (Vm.isMobile())
+					scnFilter.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight()); // Fullscreen
 				scnFilter.execute(father.getFrame(), Gui.CENTER_FRAME);
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtInvert){
+			if (mev.selectedItem == filtInvert) {
 				Filter flt = new Filter();
 				flt.invertFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtClear){
+			if (mev.selectedItem == filtClear) {
 				Filter flt = new Filter();
 				flt.clearFilter();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtSelected){ // incremental filter
+			if (mev.selectedItem == filtSelected) { // incremental filter
 				Global.getProfile().selectionChanged = true;
 				CacheHolder ch;
 				boolean filterChanged = false;
-				for(int i = cacheDB.size()-1; i&gt;=0; i--){
+				for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 					ch = cacheDB.get(i);
 					// This is an incremental filter, i.e. it keeps the existing filter
 					// status and only adds the marked caches to the filtered set
@@ -641,16 +647,16 @@
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged &amp;&amp; Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+				if (filterChanged &amp;&amp; Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
 					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
-			if (mev.selectedItem == filtNonSelected){
+			if (mev.selectedItem == filtNonSelected) {
 				Global.getProfile().selectionChanged = true;
 				CacheHolder ch;
 				boolean filterChanged = false;
-				for(int i = cacheDB.size()-1; i &gt;=0; i--){
+				for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 					ch = cacheDB.get(i);
 					// incremental filter. Keeps status of all marked caches and
 					// adds unmarked caches to filtered list
@@ -659,102 +665,104 @@
 						filterChanged = true;
 					}
 				}
-				if ( filterChanged &amp;&amp; Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
+				if (filterChanged &amp;&amp; Global.getProfile().getFilterActive() == Filter.FILTER_INACTIVE) {
 					Global.getProfile().setFilterActive(Filter.FILTER_MARKED_ONLY);
 				}
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == filtBlack){
-				//filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
+			if (mev.selectedItem == filtBlack) {
+				// filtBlack.modifiers=filtBlack.modifiers|MenuItem.Checked;
 				Global.getProfile().setShowBlacklisted(!Global.getProfile().showBlacklisted());
-				filtBlack.modifiers=Global.getProfile().showBlacklisted()?filtBlack.modifiers|MenuItem.Checked:filtBlack.modifiers&amp;~MenuItem.Checked;
+				filtBlack.modifiers = Global.getProfile().showBlacklisted() ? filtBlack.modifiers | MenuItem.Checked : filtBlack.modifiers &amp; ~MenuItem.Checked;
 				SearchCache ssc = new SearchCache(cacheDB);
 				ssc.clearSearch();// Clear search &amp; restore filter status
 				tbp.refreshTable();
 			}
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// &quot;Organise&quot; pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == orgNewWP){
-				if (Global.mainTab.tbP.getSelectedCache() &gt;= 0) 
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == orgNewWP) {
+				if (Global.mainTab.tbP.getSelectedCache() &gt;= 0)
 					Global.mainTab.lastselected = cacheDB.get(Global.mainTab.tbP.getSelectedCache()).getWayPoint();
-				else Global.mainTab.lastselected = &quot;&quot;;
+				else
+					Global.mainTab.lastselected = &quot;&quot;;
 				Global.mainTab.newWaypoint(new CacheHolder());
 			}
 
-			if(mev.selectedItem == orgCopy){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgCopy) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.copyCaches();
 				tbp.refreshTable();
 			}
 
-			if(mev.selectedItem == orgMove){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgMove) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.moveCaches();
 				tbp.refreshTable();
 			}
 
-			if(mev.selectedItem == orgDelete){
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+			if (mev.selectedItem == orgDelete) {
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				DataMover dm = new DataMover();
 				dm.deleteCaches();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgRebuild){
-				Rebuild rb=new Rebuild();
+			if (mev.selectedItem == orgRebuild) {
+				Rebuild rb = new Rebuild();
 				rb.rebuild();
 				profile.updateBearingDistance();
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgCheckNotesAndSolver){
+			if (mev.selectedItem == orgCheckNotesAndSolver) {
 				// Checking every cache if notes or solver data exist
-				CWProgressBar cwp = new CWProgressBar(MyLocale.getMsg(219,&quot;Searching...&quot;), 0, cacheDB.size(), true);
+				CWProgressBar cwp = new CWProgressBar(MyLocale.getMsg(219, &quot;Searching...&quot;), 0, cacheDB.size(), true);
 				cwp.exec();
 				cwp.allowExit(true);
-				for(int i = 0;i &lt; cacheDB.size();i++){
+				for (int i = 0; i &lt; cacheDB.size(); i++) {
 					cwp.setPosition(i);
 					CacheHolder ch = cacheDB.get(i);
-					if (ch.mainCache==null) {
+					if (ch.mainCache == null) {
 						ch.setHasNote(!ch.getCacheDetails(false).getCacheNotes().equals(&quot;&quot;));
 						ch.setHasSolver(!ch.getCacheDetails(false).getSolver().equals(&quot;&quot;));
 					}
-					if (cwp.isClosed()) break;
+					if (cwp.isClosed())
+						break;
 				} // for
 				cwp.exit(0);
 				tbp.refreshTable();
 			}
-			if(mev.selectedItem == orgTravelbugs){
-				TravelbugJourneyScreen tbs=new TravelbugJourneyScreen();
-				tbs.setPreferredSize(800,600);
-				tbs.execute(); //getFrame(), Gui.CENTER_FRAME);
+			if (mev.selectedItem == orgTravelbugs) {
+				Form tbs = TravelbugJourneyScreenFactory.createTravelbugJourneyScreen();
+				tbs.setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
+				tbs.execute();
 				tbs.close(0);
 			}
-			if(mev.selectedItem == cacheTour){
-				cacheTour.modifiers^=MenuItem.Checked;
+			if (mev.selectedItem == cacheTour) {
+				cacheTour.modifiers ^= MenuItem.Checked;
 				Global.mainForm.toggleCacheListVisible();
 			}
 
-			///////////////////////////////////////////////////////////////////////
+			// /////////////////////////////////////////////////////////////////////
 			// &quot;About&quot; pulldown menu
-			///////////////////////////////////////////////////////////////////////
-			if(mev.selectedItem == about){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile(&quot;info.html&quot;), MyLocale.getMsg(117,&quot;About&quot;),true, pref);
+			// /////////////////////////////////////////////////////////////////////
+			if (mev.selectedItem == about) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile(&quot;info.html&quot;), MyLocale.getMsg(117, &quot;About&quot;), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == legend){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile(&quot;legende.html&quot;), MyLocale.getMsg(155,&quot;Legend&quot;),true, pref);
+			if (mev.selectedItem == legend) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile(&quot;legende.html&quot;), MyLocale.getMsg(155, &quot;Legend&quot;), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == wolflang){
-				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile(&quot;wolflang.html&quot;), MyLocale.getMsg(118,&quot;WolfLanguage&quot;), true, pref);
+			if (mev.selectedItem == wolflang) {
+				InfoScreen is = new InfoScreen(MyLocale.getLocalizedFile(&quot;wolflang.html&quot;), MyLocale.getMsg(118, &quot;WolfLanguage&quot;), true, pref);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == sysinfo){
-				StringBuffer sb=new StringBuffer(400);
+			if (mev.selectedItem == sysinfo) {
+				StringBuffer sb = new StringBuffer(400);
 				Font f = mApp.guiFont;
-				sb.append(MyLocale.getMsg(121,&quot;Profile&quot;));
+				sb.append(MyLocale.getMsg(121, &quot;Profile&quot;));
 				sb.append(&quot;: &quot;);
 				sb.append(profile.dataDir);
 				sb.append(&quot;&lt;br&gt;&quot;);
@@ -781,21 +789,22 @@
 				sb.append(MyLocale.getMsg(265, &quot;Screen:&quot;));
 				sb.append(' ');
 				sb.append(MyLocale.getScreenWidth());
-				sb.append(&quot; x &quot;);	 sb.append(MyLocale.getScreenHeight());
+				sb.append(&quot; x &quot;);
+				sb.append(MyLocale.getScreenHeight());
 				sb.append(&quot;&lt;br&gt;&quot;);
 				sb.append(MyLocale.getMsg(266, &quot;Font size:&quot;));
 				sb.append(' ');
 				sb.append(f.getSize());
 				sb.append(&quot;&lt;br&gt;&quot;);
 				sb.append(MyLocale.getMsg(267, &quot;Entries in DB:&quot;));
-				sb.append (' ');
+				sb.append(' ');
 				sb.append(cacheDB.size());
 				sb.append(&quot;&lt;br&gt;&quot;);
-				sb.append(MyLocale.getMsg (268, &quot;File separator is:&quot;));
-				sb.append (&quot; \&quot;&quot;);
-				sb.append(Vm.getProperty(&quot;file.separator&quot;,&quot;def&quot;));
+				sb.append(MyLocale.getMsg(268, &quot;File separator is:&quot;));
+				sb.append(&quot; \&quot;&quot;);
+				sb.append(Vm.getProperty(&quot;file.separator&quot;, &quot;def&quot;));
 				sb.append(&quot;\&quot;&lt;br&gt;&quot;);
-				sb.append(MyLocale.getMsg (269, &quot;Programme directory is:&quot;));
+				sb.append(MyLocale.getMsg(269, &quot;Programme directory is:&quot;));
 				sb.append(' ');
 				sb.append(FileBase.getProgramDirectory());
 				sb.append(&quot;&lt;br&gt;&quot;);
@@ -811,11 +820,11 @@
 				sb.append(' ');
 				sb.append(Version.getReleaseDetailed());
 				sb.append(&quot;&lt;br&gt;&quot;);
-				InfoScreen is = new InfoScreen(sb.toString(), &quot;System&quot;, false,pref);
-				pref.log(STRreplace.replace(sb.toString(),&quot;&lt;br&gt;&quot;,Preferences.NEWLINE),null);
+				InfoScreen is = new InfoScreen(sb.toString(), &quot;System&quot;, false, pref);
+				pref.log(STRreplace.replace(sb.toString(), &quot;&lt;br&gt;&quot;, Preferences.NEWLINE), null);
 				is.execute(father.getFrame(), Gui.CENTER_FRAME);
 			}
-			if(mev.selectedItem == chkVersion){
+			if (mev.selectedItem == chkVersion) {
 				(new MessageBox(MyLocale.getMsg(178, &quot;Version Checking&quot;), Version.getUpdateMessage(), FormBase.OKB)).execute();
 			}
 
@@ -831,15 +840,17 @@
 	}
 
 	public static void updateSelectedCaches(TablePanel tablePanel) {
-		Preferences pref=Global.getPref();
-		Profile profile=Global.getProfile();
-		CacheDB cacheDB=profile.cacheDB;
+		Preferences pref = Global.getPref();
+		Profile profile = Global.getProfile();
+		CacheDB cacheDB = profile.cacheDB;
 		CacheHolder ch;
 
-		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(1014,&quot;updateSelectedCaches&quot;), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.TRAVELBUGS| OCXMLImporterScreen.MAXLOGS| OCXMLImporterScreen.ALL);
-		if (options.execute() == FormBase.IDCANCEL) {	return; }
+		OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(1014, &quot;updateSelectedCaches&quot;), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.ALL);
+		if (options.execute() == FormBase.IDCANCEL) {
+			return;
+		}
 
-		SpiderGC spider = new SpiderGC(pref, profile, false);
+		SpiderGC spider = new SpiderGC(pref, profile);
 		OCXMLImporter ocSync = new OCXMLImporter(pref, profile);
 		Vm.showWait(true);
 		boolean alreadySaid = false;
@@ -850,27 +861,23 @@
 		boolean loadAllLogs = (pref.maxLogsToSpider &gt; 5);
 
 		Vector cachesToUpdate = new Vector();
-		for(int i = 0; i &lt;	cacheDB.size(); i++){
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			if(ch.is_Checked == true &amp;&amp; ch.isVisible()) {
-				String wpStart = ch.getWayPoint().substring(0,2);
-				if ( ch.getWayPoint().length()&gt;1 &amp;&amp; (wpStart.equalsIgnoreCase(&quot;GC&quot;) || ch.isOC()))
-//					Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
-//					Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
+			if (ch.is_Checked == true &amp;&amp; ch.isVisible()) {
+				// should work even if only the wayPoint is created
+				if ((ch.getWayPoint().toUpperCase().startsWith(&quot;GC&quot;) || ch.isOC()))
+				// Notiz: Wenn es ein addi Wpt ist, sollte eigentlich der Maincache gespidert werden
+				// Alter code prft aber nur ob ein Maincache von GC existiert und versucht dann den addi direkt zu spidern, was nicht funktioniert
 				{
 					cachesToUpdate.add(new Integer(i));
 				} else {
-					if (ch.isAddiWpt() &amp;&amp; ch.mainCache!=null &amp;&amp; !ch.mainCache.is_Checked &amp;&amp; !alreadySaid2) { // Is the father ticked?
-						alreadySaid2=true;
-						(new MessageBox(MyLocale.getMsg(327,&quot;Information&quot;),
-								        MyLocale.getMsg(5001,&quot;Can't spider additional waypoint directly. Please check main cache.&quot;), FormBase.OKB)).execute();
+					if (ch.isAddiWpt() &amp;&amp; ch.mainCache != null &amp;&amp; !ch.mainCache.is_Checked &amp;&amp; !alreadySaid2) { // Is the father ticked?
+						alreadySaid2 = true;
+						(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), MyLocale.getMsg(5001, &quot;Can't spider additional waypoint directly. Please check main cache.&quot;), FormBase.OKB)).execute();
 					}
 					if (!ch.isAddiWpt() &amp;&amp; !alreadySaid) {
 						alreadySaid = true;
-						(new MessageBox(MyLocale.getMsg(327,&quot;Information&quot;),
-					        ch.getWayPoint()+ MyLocale.getMsg(5002,
-					        	&quot;: At the moment this function is only applicable for geocaching.com and opencaching.de/.cz/.org.uk .&quot;),
-					        FormBase.OKB)).execute();
+						(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), ch.getWayPoint() + MyLocale.getMsg(5002, &quot;: At the moment this function is only applicable for geocaching.com and opencaching.de/.cz/.org.uk .&quot;), FormBase.OKB)).execute();
 					}
 				}
 
@@ -878,14 +885,14 @@
 		}
 
 		int spiderErrors = 0;
-		boolean forceLogin=Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
-		for(int j = 0; j &lt;	cachesToUpdate.size(); j++){
-			int i = ((Integer)cachesToUpdate.get(j)).intValue();
+		boolean forceLogin = Global.getPref().forceLogin; // To ensure that spiderSingle only logs in once if forcedLogin=true
+		for (int j = 0; j &lt; cachesToUpdate.size(); j++) {
+			int i = ((Integer) cachesToUpdate.get(j)).intValue();
 			ch = cacheDB.get(i);
-//			infB.setInfo(&quot;Loading: &quot; + ch.wayPoint);
-			infB.setInfo(MyLocale.getMsg(5513,&quot;Loading: &quot;) + ch.getWayPoint() +&quot; (&quot; + (j+1) + &quot; / &quot; + cachesToUpdate.size() + &quot;)&quot;);
+			// infB.setInfo(&quot;Loading: &quot; + ch.wayPoint);
+			infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + ch.getWayPoint() + &quot; (&quot; + (j + 1) + &quot; / &quot; + cachesToUpdate.size() + &quot;)&quot;);
 			infB.redisplay();
-			if (ch.getWayPoint().substring(0,2).equalsIgnoreCase(&quot;GC&quot;)) {
+			if (ch.getWayPoint().substring(0, 2).equalsIgnoreCase(&quot;GC&quot;)) {
 				int test = spider.spiderSingle(i, infB, forceLogin, loadAllLogs || ch.is_found());
 				if (test == SpiderGC.SPIDER_CANCEL) {
 					infB.close(0);
@@ -893,30 +900,29 @@
 				} else if (test == SpiderGC.SPIDER_ERROR) {
 					spiderErrors++;
 				} else {
-					//profile.hasUnsavedChanges=true;
+					// profile.hasUnsavedChanges=true;
 				}
-				forceLogin=false;
-			}
-			else {
+				forceLogin = false;
+			} else {
 				if (!ocSync.syncSingle(i, infB)) {
 					infB.close(0);
 					break;
 				} else {
-					//profile.hasUnsavedChanges=true;
+					// profile.hasUnsavedChanges=true;
 				}
 			}
 
-//			cacheDB.clear();
-//			profile.readIndex();
+			// cacheDB.clear();
+			// profile.readIndex();
 		}
 		infB.close(0);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 		profile.restoreFilter();
 		profile.updateBearingDistance();
 		tablePanel.refreshTable();
 		Vm.showWait(false);
-		if ( spiderErrors &gt; 0) {
-			new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),FormBase.DEFOKB).execute();
+		if (spiderErrors &gt; 0) {
+			new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), spiderErrors + MyLocale.getMsg(5516, &quot; cache descriptions%0acould not be loaded.&quot;), FormBase.DEFOKB).execute();
 		}
 	}
 

Modified: branches/r1.2/src/CacheWolf/MainTab.java
===================================================================
--- branches/r1.2/src/CacheWolf/MainTab.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MainTab.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.GotoPanel;
@@ -41,90 +41,133 @@
 import ewe.ui.mTabbedPanel;
 
 /**
- *	This class creates the tabbed panel and sets the tabs to the respective
- *	other panels. Important is to have a look at the event handler!&lt;br&gt;
- *	Class ID = 1200
- *	@see MainForm
- *	@see MainMenu
+ * This class creates the tabbed panel and sets the tabs to the respective other panels. Important is to have a look at
+ * the event handler!&lt;br&gt;
+ * Class ID = 1200
+ * 
+ * @see MainForm
+ * @see MainMenu
  */
 public class MainTab extends mTabbedPanel {
-	DescriptionPanel descP= new DescriptionPanel();
+	static int LIST_CARD;
+	static int DETAILS_CARD;
+	static int DESCRIPTION_CARD;
+	static int IMAGES_CARD;
+	static int HINTSANDLOGS_CARD;
+	static int SOLVER_CARD;
+	static int CALC_CARD;
+	static int GOTO_CARD;
+	static int RADAR_CARD;
+	static int MAP_CARD;
+
+	TableForm listP;
+	public DetailsPanel detP = new DetailsPanel();
+	DescriptionPanel descP = new DescriptionPanel();
 	HintLogPanel hintLP = new HintLogPanel();
 	public TablePanel tbP;
-	CacheDB cacheDB;
-	public DetailsPanel detP = new DetailsPanel();
 	CalcPanel calcP;
-	Preferences pref;
-	Profile profile;
 	GotoPanel gotoP;
 	RadarPanel radarP = new RadarPanel();
 	ImagePanel imageP;
 	SolverPanel solverP;
+	ewe.ui.CellPanel mapP;
+
+	Preferences pref;
+	Profile profile;
+
+	CacheDB cacheDB;
 	String lastselected = &quot;&quot;;
-	public CacheHolder ch=null, chMain=null;
-	CacheHolderDetail chD =null;
+	public CacheHolder ch = null, chMain = null;
+	CacheHolderDetail chD = null;
 	MainMenu mnuMain;
+
 	public StatusBar statBar;
 	public MovingMap mm;
 	public Navigate nav;
-	public String mainCache=&quot;&quot;;
-	int oldCard=0;
-	boolean cacheDirty=false;
+	public String mainCache = &quot;&quot;;
+	int oldCard;
+	boolean cacheDirty = false;
 
-	public MainTab(MainMenu mainMenu,StatusBar statBar){
-		Global.mainTab=this;
-		mnuMain=mainMenu;
+	public MainTab(MainMenu mainMenu, StatusBar statBar) {
+		// Init here so that Global.MainT is already set
+		Global.mainTab = this;
+		mnuMain = mainMenu;
 		pref = Global.getPref();
-		profile=Global.getProfile();
-		if (!pref.tabsAtTop) tabLocation=SOUTH;
+		profile = Global.getProfile();
+		if (!pref.tabsAtTop)
+			tabLocation = SOUTH;
 		cacheDB = profile.cacheDB;
-		this.statBar=statBar;
+		this.statBar = statBar;
 		MyLocale.setSIPButton();
-		//Don't expand tabs if the screen is very narrow, i.e. HP IPAQ 65xx, 69xx
+		// Don't expand tabs if the screen is very narrow, i.e. HP IPAQ
+		// 65xx, 69xx
 		int sw = MyLocale.getScreenWidth();
-		if ( sw &lt;= 240) this.dontExpandTabs=true;
-		String imagesize=&quot;&quot;;
-		if (pref.useBigIcons) imagesize=&quot;_vga&quot;;
-		calcP = new CalcPanel(); // Init here so that Global.MainT is already set
+		if (sw &lt;= 480)
+			this.dontExpandTabs = true;
+		String imagesize = &quot;&quot;;
+		if (pref.useBigIcons)
+			imagesize = &quot;_vga&quot;;
+
 		tbP = new TablePanel(pref, profile, statBar);
-		Card c = this.addCard(new TableForm(tbP), MyLocale.getMsg(1200,&quot;List&quot;), null);
+		Card c = this.addCard(listP = new TableForm(tbP), MyLocale.getMsg(1200, &quot;List&quot;), null);
+		LIST_CARD = this.cardPanel.cards.size() - 1;
+		oldCard = LIST_CARD;
 
-		c = this.addCard(detP, MyLocale.getMsg(1201,&quot;Details&quot;), null);
-		c.iconize(new Image(&quot;details&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(detP, MyLocale.getMsg(1201, &quot;Details&quot;), null);
+		DETAILS_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;details&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(descP, MyLocale.getMsg(1202,&quot;Description&quot;), null);
-		c.iconize(new Image(&quot;descr&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(descP, MyLocale.getMsg(1202, &quot;Description&quot;), null);
+		DESCRIPTION_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;descr&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203,&quot;Images&quot;), null);
-		c.iconize(new Image(&quot;images&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(new MyScrollBarPanel(imageP = new ImagePanel()), MyLocale.getMsg(1203, &quot;Images&quot;), null);
+		IMAGES_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;images&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(hintLP, MyLocale.getMsg(1204,&quot;Hints &amp; Logs&quot;), null);
-		c.iconize(new Image(&quot;more&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(hintLP, MyLocale.getMsg(1204, &quot;Hints &amp; Logs&quot;), null);
+		HINTSANDLOGS_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;more&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205,&quot;Solver&quot;), null);
-		c.iconize(new Image(&quot;solver&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(solverP = new SolverPanel(pref, profile), MyLocale.getMsg(1205, &quot;Solver&quot;), null);
+		SOLVER_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;solver&quot; + imagesize + &quot;.gif&quot;), true);
 
-		c = this.addCard(calcP, MyLocale.getMsg(1206,&quot;Calc&quot;), null);
-		mImage imgCalc=new mImage(&quot;projecttab&quot;+imagesize+&quot;.gif&quot;); imgCalc.transparentColor=new Color(0,255,0);
-		c.iconize(imgCalc,true);
+		c = this.addCard(calcP = new CalcPanel(), MyLocale.getMsg(1206, &quot;Calc&quot;), null);
+		CALC_CARD = this.cardPanel.cards.size() - 1;
+		mImage imgCalc = new mImage(&quot;projecttab&quot; + imagesize + &quot;.gif&quot;);
+		imgCalc.transparentColor = new Color(0, 255, 0);
+		c.iconize(imgCalc, true);
 
 		nav = new Navigate();
-		c = this.addCard(gotoP = new GotoPanel(nav), &quot;Goto&quot;, null);
-		c.iconize(new Image(&quot;goto&quot;+imagesize+&quot;.gif&quot;),true);
+		c = this.addCard(gotoP = new GotoPanel(nav), MyLocale.getMsg(345, &quot;Goto these coordinates&quot;), null);
+		GOTO_CARD = this.cardPanel.cards.size() - 1;
+		c.iconize(new Image(&quot;goto&quot; + imagesize + &quot;.gif&quot;), true);
 		nav.setGotoPanel(gotoP);
 
-		c = this.addCard(radarP, &quot;Radar&quot;, null);
-		radarP.setMainTab(this);
-		c.iconize(new Image(&quot;radar&quot;+imagesize+&quot;.gif&quot;),true);
+		if (pref.isBigScreen || !pref.useRadar) {
+			c = this.addCard(mapP = new ewe.ui.CellPanel(), MyLocale.getMsg(347, &quot;Show map&quot;), null);
+			MAP_CARD = this.cardPanel.cards.size() - 1;
+			c.iconize(new Image(&quot;globe_small&quot; + imagesize + &quot;.gif&quot;), true);
+		}
+
+		if (pref.isBigScreen || pref.useRadar) {
+			c = this.addCard(radarP, &quot;Radar&quot;, null);
+			RADAR_CARD = this.cardPanel.cards.size() - 1;
+			radarP.setMainTab(this);
+			c.iconize(new Image(&quot;radar&quot; + imagesize + &quot;.gif&quot;), true);
+		}
+
 		mnuMain.allowProfileChange(true);
-//		if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
+		// if (pref.noTabs) top.modify(ShrinkToNothing,0);//TODO
 	}
 
-	public TablePanel getTablePanel(){
+	public TablePanel getTablePanel() {
 		return tbP;
 	}
 
-	public void selectAndActive(int rownum){// Called from myInteractivePanel.imageClicked
+	public void selectAndActive(int rownum) {// Called from
+		// myInteractivePanel.imageClicked
 		tbP.selectRow(rownum);
 		this.selectAndExpand(0);
 	}
@@ -138,79 +181,86 @@
 	}
 
 	public void onEvent(Event ev) {
-		// This section clears old data when a new line is selected in the table
+		// This section clears old data when a new line is selected in the
+		// table
 		if (ev instanceof TableEvent) {
 			clearDetails();
 		}
-		if(ev instanceof MultiPanelEvent){
-			// Check whether a profile change is allowed, if not disable the relevant options
+		if (ev instanceof MultiPanelEvent) {
+			// Check whether a profile change is allowed, if not disable the
+			// relevant options
 			checkProfileChange();
 			// Perform clean up actions for the panel we are leaving
 			onLeavingPanel(oldCard);
 			// Prepare actions for the panel we are about to enter
-			onEnteringPanel(((MultiPanelEvent)ev).selectedIndex);
-			oldCard=((MultiPanelEvent)ev).selectedIndex;
+			onEnteringPanel(((MultiPanelEvent) ev).selectedIndex);
 		}
-		super.onEvent(ev); //Make sure you call this.
-		// If we are in Listview update status
-//		if (this.getSelectedItem()==0 &amp;&amp; statBar!=null) statBar.updateDisplay();
+		super.onEvent(ev); // Make sure you call this.
 	}
 
 	/**
 	 * Code to execute when leaving a panel (oldCard is the panel number)
-	 *
+	 * 
 	 */
 	private void onLeavingPanel(int panelNo) {
-		if (panelNo==0) { // Leaving the list view
+		if (panelNo == MainTab.LIST_CARD) { // Leaving the list view
 			// Get the cache for the current line (ch)
 			// Get the details for the current line (chD)
 			// If it is Addi get details of main Wpt (chMain)
-			chMain=null;
-			cacheDirty=false;
-			if (tbP.getSelectedCache()&gt;=Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache()&lt;0) {
-				ch=null;
-				chD=null;
-				lastselected=&quot;&quot;;
+			chMain = null;
+			cacheDirty = false;
+			if (tbP.getSelectedCache() &gt;= Global.mainTab.tbP.myMod.numRows || tbP.getSelectedCache() &lt; 0) {
+				ch = null;
+				chD = null;
+				lastselected = &quot;&quot;;
 			} else {
 				ch = cacheDB.get(tbP.getSelectedCache());
-				lastselected=ch.getWayPoint();  // Used in Parser.Skeleton
+				lastselected = ch.getWayPoint(); // Used in
+				// Parser.Skeleton
 				chD = ch.getCacheDetails(true);
 			}
 		}
-		if (panelNo==1) { // Leaving the Details Panel
-			detP.evWaypointChanged=false;
+		if (panelNo == MainTab.DETAILS_CARD) { // Leaving the Details Panel
+			detP.evWaypointChanged = false;
 			// Update chD with Details
-			if(detP.isDirty()) {
-				cacheDirty=true;
+			if (detP.isDirty()) {
+				cacheDirty = true;
 				boolean needTableUpdate = detP.getNeedsTableUpdate();
 				detP.saveDirtyWaypoint();
 				if (needTableUpdate) {
-					tbP.myMod.updateRows();// This sorts the waypoint (if it is new) into the right position
+					tbP.myMod.updateRows();// This sorts the waypoint (if
+					// it is new) into the right
+					// position
 					tbP.selectRow(profile.getCacheIndex(detP.cache.getWayPoint()));
 				}
-				//was tbP.refreshTable();
+				// was tbP.refreshTable();
 				tbP.tc.update(true); // Update and repaint
-				if (statBar!=null) statBar.updateDisplay(&quot;&quot;);
+				if (statBar != null)
+					statBar.updateDisplay(&quot;&quot;);
 			}
 		}
-		if (panelNo==5) { // Leaving the Solver Panel
+		if (panelNo == MainTab.SOLVER_CARD) { // Leaving the Solver Panel
 			// Update chD or chMain with Solver
-			// If chMain is set (i.e. if it is an addi Wpt) save it immediately
-			if (chD!=null &amp;&amp; solverP.isDirty()) {
-				if (chMain==null) {
-					cacheDirty=true;
+			// If chMain is set (i.e. if it is an addi Wpt) save it
+			// immediately
+			if (chD != null &amp;&amp; solverP.isDirty()) {
+				if (chMain == null) {
+					cacheDirty = true;
 					boolean oldHasSolver = chD.getParent().hasSolver();
 					chD.setSolver(solverP.getInstructions());
-					if (oldHasSolver != chD.getParent().hasSolver()) tbP.tc.update(true);
-					// For safety reasons: Immediately save solver instructions when
+					if (oldHasSolver != chD.getParent().hasSolver())
+						tbP.tc.update(true);
+					// For safety reasons: Immediately save solver
+					// instructions when
 					// switching panels
 					updatePendingChanges();
 				} else {
 					boolean oldHasSolver = chMain.hasSolver();
 					chMain.getCacheDetails(true).setSolver(solverP.getInstructions());
-					if (oldHasSolver != chMain.hasSolver()) tbP.tc.update(true);
+					if (oldHasSolver != chMain.hasSolver())
+						tbP.tc.update(true);
 					chMain.save();
-					chMain=null;
+					chMain = null;
 				}
 			}
 		}
@@ -218,133 +268,145 @@
 
 	/**
 	 * Code to execute when entering a panel (getSelectedItem() is the panel number)
-	 *
+	 * 
 	 */
 	private void onEnteringPanel(int panelNo) {
-		switch (panelNo) {// Switch by panel number
-		case 0:  //MainPanel
-			MyLocale.setSIPOff();
+		MyLocale.setSIPOff();
+		if (panelNo == LIST_CARD) {
 			// If Solver or Details has changed, save Cache
 			updatePendingChanges();
 			if (detP.hasBlackStatusChanged()) {
 				tbP.refreshTable();
 			}
 			updateCurCentrePtFromGPS();
-			break;
-		case 1:  // DetailsPanel
+		} else if (panelNo == DETAILS_CARD) {
 			boolean newCache = false;
-			if (chD==null) { // Empty DB - show a dummy detail
-				newWaypoint(ch=new CacheHolder());
+			if (chD == null) { // Empty DB - show a dummy detail
+				newWaypoint(ch = new CacheHolder());
 				newCache = true;
 			}
-			MyLocale.setSIPOff();
 			detP.setDetails(ch, newCache);
-			break;
-		case 2: // Description Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == DESCRIPTION_CARD) {
 			descP.setText(ch);
-			break;
-		case 3: // Picture Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == IMAGES_CARD) {
 			if (ch.isAddiWpt()) {
 				imageP.setImages(ch.mainCache.getCacheDetails(true));
 			} else {
 				imageP.setImages(chD);
 			}
-			break;
-		case 4:  // Log Hint Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == HINTSANDLOGS_CARD) {
 			if (ch.isAddiWpt()) {
 				hintLP.setText(ch.mainCache.getCacheDetails(true));
 			} else {
 				hintLP.setText(chD);
 			}
-			break;
-		case 5:  // Solver Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == SOLVER_CARD) {
 			if (ch.isAddiWpt()) {
-				chMain=ch.mainCache;
+				chMain = ch.mainCache;
 				solverP.setInstructions(ch.mainCache);
 			} else {
 				solverP.setInstructions(ch);
 			}
-			break;
-		case 6:  // CalcPanel
-			MyLocale.setSIPOff();
-			if (ch != null) calcP.setFields(ch);
-			break;
-		case 7: // GotoPanel
-			MyLocale.setSIPOff();
-			break;
-		case 8:  // Cache Radar Panel
-			MyLocale.setSIPOff();
+		} else if (panelNo == CALC_CARD) {
+			if (ch != null)
+				calcP.setFields(ch);
+		} else if (panelNo == MAP_CARD) {
+			gotoP.switchToMovingMap();
+			if (oldCard == LIST_CARD) {
+				select(listP);
+			} else if (oldCard == DETAILS_CARD) {
+				select(detP);
+			} else if (oldCard == DESCRIPTION_CARD) {
+				select(descP);
+			} else if (oldCard == IMAGES_CARD) {
+				select(imageP);
+			} else if (oldCard == HINTSANDLOGS_CARD) {
+				select(hintLP);
+			} else if (oldCard == SOLVER_CARD) {
+				select(solverP);
+			} else if (oldCard == CALC_CARD) {
+				select(calcP);
+			} else if (oldCard == GOTO_CARD) {
+				select(gotoP);
+			} else if (oldCard == RADAR_CARD) {
+				select(radarP);
+			}
+		} else if (panelNo == RADAR_CARD) {
 			radarP.setParam(pref, cacheDB, ch);
 			radarP.drawThePanel();
 			updateCurCentrePtFromGPS();
-			break;
 		}
+		oldCard = panelNo;
 	}
+
 	/**
 	 * this is called from MovingMap Cache context menu
-	 * @param chi , the CacheHolder for the Cache to switch to
-	 * @param panelNo 1=DetailsPanel 2=Description Panel
+	 * 
+	 * @param chi
+	 *            ,
+	 *            the CacheHolder for the Cache to switch to
+	 * @param panelNo
+	 *            1=DetailsPanel 2=Description Panel
 	 */
 	public void openPanel(CacheHolder chi, int panelNo) {
-		MyLocale.setSIPOff();
-		// To change cache we need to be in panel 0
-		onLeavingPanel(oldCard); // is 7 or 1
-		onEnteringPanel(0); oldCard=0;
+		// To change cache we need to be in panel LIST_CARD
+		onLeavingPanel(oldCard);
+		onEnteringPanel(LIST_CARD);
 		int row = profile.getCacheIndex(chi.getWayPoint());
 		tbP.selectRow(row);
-	switch (panelNo) {// Switch by panel number
-		case 1:  // DetailsPanel
-			ch=chi; //possibly wrong (old) detail if map is called directly
-			onEnteringPanel(1);
-			oldCard=1;
+		if (panelNo == DETAILS_CARD) {
+			ch = chi; // possibly wrong (old) detail if map is called
+			// directly
+			onEnteringPanel(DETAILS_CARD);
 			select(detP);
-			break;
-		case 2: // Description Panel
+		} else if (panelNo == DESCRIPTION_CARD) {
+			onEnteringPanel(DESCRIPTION_CARD);
 			select(descP);
-			break;
-		}		
+		}
+
 	}
 
-
 	/**
-	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to
-	 * offer the user the possibility of entering an new waypoint
-	 * at a given position. pCh must already been preset with a valid
-	 * CacheHolder object
-	 *
+	 * this is called from goto / MovingMap / CalcPanel / DetailsPanel and so on to offer the user the possibility of
+	 * entering an new waypoint at a given position. pCh must already been preset with a valid CacheHolder object
+	 * 
 	 * @param pCh
 	 */
-	public void newWaypoint(CacheHolder pCh){
-		//When creating a new waypoint, simulate a change to the list view
-		//if we are currently NOT in the list view
-		if (oldCard != 0)
-		{
+	public void newWaypoint(CacheHolder pCh) {
+		// When creating a new waypoint, simulate a change to the list view
+		// if we are currently NOT in the list view
+		if (oldCard != LIST_CARD) {
 			onLeavingPanel(oldCard);
 		}
 		updatePendingChanges(); // was: onEnteringPanel(0); oldCard=0;
 
-		mainCache=lastselected;
-		int selectedIndex = profile.getCacheIndex( lastselected );
+		mainCache = lastselected;
+		int selectedIndex = profile.getCacheIndex(lastselected);
 		if (selectedIndex &gt;= 0) {
-			CacheHolder selectedCache = profile.cacheDB.get( selectedIndex );
-			if ( selectedCache.isAddiWpt() ) {
+			// why not using the target ???
+			CacheHolder selectedCache = profile.cacheDB.get(selectedIndex);
+			// try to start new waypoint with real coords
+			if (!pCh.getPos().isValid()) {
+				pCh.setPos(selectedCache.getPos());
+			}
+			if (selectedCache.isAddiWpt()) {
 				if (selectedCache.mainCache != null) {
 					mainCache = selectedCache.mainCache.getWayPoint();
+					// try to start new waypoint with real coords
+					if (!pCh.getPos().isValid()) {
+						pCh.setPos(selectedCache.mainCache.getPos());
+					}
 				} else {
 					mainCache = null;
 				}
 			}
 		}
-		if (CacheType.isAddiWpt(pCh.getType()) &amp;&amp; mainCache!=null &amp;&amp; mainCache.length()&gt;2) {
+		if (CacheType.isAddiWpt(pCh.getType()) &amp;&amp; mainCache != null &amp;&amp; mainCache.length() &gt; 2) {
 			pCh.setWayPoint(profile.getNewAddiWayPointName(mainCache));
 			profile.setAddiRef(pCh);
 		} else {
 			pCh.setWayPoint(profile.getNewWayPointName());
-			lastselected=pCh.getWayPoint();
+			lastselected = pCh.getWayPoint();
 		}
 		pCh.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 		chD = pCh.getCacheDetails(false);
@@ -353,18 +415,20 @@
 		Global.getProfile().notifyUnsavedChanges(true); // Just to be sure
 		tbP.myMod.numRows++;
 		detP.setDetails(pCh, true);
-		oldCard=1;
-		if (this.cardPanel.selectedItem != 1) select(detP);
+		oldCard = DETAILS_CARD;
+		if (this.cardPanel.selectedItem != 1)
+			select(detP);
 		solverP.setInstructions(pCh);
-		//tbP.refreshTable(); // moved this instruction to onLeavingPanel
+		// tbP.refreshTable(); // moved this instruction to onLeavingPanel
 
 	}
 
-
 	/**
 	 * sets posCircle Lat/Lon to centerTo
-	 *
-	 * @param centerTo true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the loaded map
+	 * 
+	 * @param centerTo
+	 *            true: centers centerTo on the screen and disconnects MovingMap from GPS if Gps-pos is not on the
+	 *            loaded map
 	 * @param forceCenter
 	 */
 	public void SwitchToMovingMap(CWPoint centerTo, boolean forceCenter) {
@@ -377,19 +441,29 @@
 				mm = new MovingMap(nav, profile.cacheDB);
 				nav.setMovingMap(mm);
 			}
-			
+
 			mm.myExec(centerTo, forceCenter);
-			
+
 			if (forceCenter) {
 				try {
 					int i = 0;
-					while (MapImage.screenDim.width == 0 &amp;&amp; i &lt; 10*60) { i++; ewe.sys.mThread.sleep(100);} // wait until the window size of the moving map is known note: ewe.sys.sleep() will pause the whole vm - no other thread will run
-					if (i &gt;= 10*60) {(new MessageBox(&quot;Error&quot;, &quot;MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de&quot;, FormBase.OKB)).execute(); return;}
-					//If white Areas are filled there is a problem with painting the image. We force painting here.
-					mm.repaint ();
-				}catch (InterruptedException e) {
+					while (MapImage.screenDim.width == 0 &amp;&amp; i &lt; 10 * 60) {
+						i++;
+						ewe.sys.mThread.sleep(100);
+					} // wait until the window size of the moving map is
+						// known note: ewe.sys.sleep() will pause the whole
+						// vm - no other thread will run
+					if (i &gt;= 10 * 60) {
+						(new MessageBox(&quot;Error&quot;, &quot;MovingMap cannot be displayed - this is most likely a bug - plaese report it on www.geoclub.de&quot;, FormBase.OKB)).execute();
+						return;
+					}
+					// If white Areas are filled there is a problem with
+					// painting the image. We force painting here.
+					mm.repaint();
+				} catch (InterruptedException e) {
 					Global.getPref().log(&quot;Error starting mavoing map (1): &quot;, e, true);
-					(new MessageBox(&quot;Error&quot;, &quot;This must not happen please report to pfeffer how to produce this error message&quot;, FormBase.OKB)).execute(); }
+					(new MessageBox(&quot;Error&quot;, &quot;This must not happen please report to pfeffer how to produce this error message&quot;, FormBase.OKB)).execute();
+				}
 			}
 		} catch (Exception e) { // TODO swith waiting indication clock off
 			Global.getPref().log(&quot;Error starting moving map (2): &quot;, e, true);
@@ -405,39 +479,41 @@
 		}
 	}
 
-	/** Save the index file
-	 *
-	 * @param askForConfirmation is ignored, old: If true, the save can be cancelled by user
+	/**
+	 * Save the index file
+	 * 
+	 * @param askForConfirmation
+	 *            is ignored, old: If true, the save can be cancelled by user
 	 */
 	public void saveUnsavedChanges(boolean askForConfirmation) {
-		if (oldCard!=0) {
+		if (oldCard != LIST_CARD) {
 			onLeavingPanel(oldCard);
-			onEnteringPanel(0);
-			oldCard=0;
+			onEnteringPanel(LIST_CARD);
+			oldCard = LIST_CARD;
 		}
 		updatePendingChanges();
-		if (profile.hasUnsavedChanges()) profile.saveIndex(Global.getPref(),true);
-	    this.tbP.saveColWidth(pref);
+		if (profile.hasUnsavedChanges())
+			profile.saveIndex(Global.getPref(), true);
+		this.tbP.saveColWidth(pref);
 		Global.getPref().savePreferences();
 	}
 
 	private void checkProfileChange() {
 		// A panel is selected. Could be the same panel twice
 		mnuMain.allowProfileChange(false);
-		if(this.getSelectedItem() == 0){// List view selected
+		if (this.getSelectedItem() == 0) {// List view selected
 			mnuMain.allowProfileChange(true);
 			MyLocale.setSIPOff();
 		}
 	}
 
-	private void  updateCurCentrePtFromGPS() {
-		if (pref.setCurrentCentreFromGPSPosition){
+	private void updateCurCentrePtFromGPS() {
+		if (pref.setCurrentCentreFromGPSPosition) {
 			if (nav.gpsRunning) {
 				CWPoint whereAmI = nav.gpsPos;
 				if (whereAmI.isValid()) {
 					CWPoint curCentr = pref.getCurCentrePt();
-					if (whereAmI.latDec != curCentr.latDec ||
-						whereAmI.lonDec != curCentr.lonDec ) {
+					if (whereAmI.latDec != curCentr.latDec || whereAmI.lonDec != curCentr.lonDec) {
 						pref.setCurCentrePt(whereAmI);
 					}
 				}
@@ -447,7 +523,3 @@
 }
 //
 
-
-
-
-

Modified: branches/r1.2/src/CacheWolf/MyComparer.java
===================================================================
--- branches/r1.2/src/CacheWolf/MyComparer.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/MyComparer.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,183 +1,189 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.util.Comparer;
 import ewe.util.Vector;
 
 /**
-*	This class handles the sorting for most of the sorting tasks. If a cache is 
-*	to be displayed in the table or not is handled in the table model
-*	@see MyTableModel
-*	@see DistComparer
-*/
-public class MyComparer implements Comparer{
+ * This class handles the sorting for most of the sorting tasks. If a cache is to be displayed in the table or not is handled in the table model
+ * 
+ * @see MyTableModel
+ * @see DistComparer
+ */
+public class MyComparer implements Comparer {
 	Vector cacheDB;
-	
-	public MyComparer(CacheDB cacheDB, int colToCompare, int visibleSize){
-		//visibleSize=Global.mainTab.tbP.myMod.numRows;
-		if (visibleSize&lt;2) return;
-		for (int i=visibleSize; i&lt;cacheDB.size(); i++) {
-			CacheHolder ch=cacheDB.get(i);
-			ch.sort=&quot;\uFFFF&quot;;
+
+	public MyComparer(CacheDB cacheDB, int colToCompare, int visibleSize) {
+		// visibleSize=Global.mainTab.tbP.myMod.numRows;
+		if (visibleSize &lt; 2)
+			return;
+		for (int i = visibleSize; i &lt; cacheDB.size(); i++) {
+			CacheHolder ch = cacheDB.get(i);
+			ch.sort = &quot;\uFFFF&quot;;
 		}
-		if (colToCompare==1) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getType());
+		if (colToCompare == 1) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getType());
 			}
-		} else if (colToCompare==2) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getHard());
+		} else if (colToCompare == 2) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getHard());
 			}
-		} else if (colToCompare==3) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=String.valueOf(ch.getTerrain());
+		} else if (colToCompare == 3) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = String.valueOf(ch.getTerrain());
 			}
-		} else if (colToCompare==4) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getWayPoint().toUpperCase();
+		} else if (colToCompare == 4) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getWayPoint().toUpperCase();
 			}
-		} else if (colToCompare==5) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheName().trim().toLowerCase();
+		} else if (colToCompare == 5) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheName().trim().toLowerCase();
 			}
-		} else if (colToCompare==6) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getLatLon();
+		} else if (colToCompare == 6) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getPos().toString();
 			}
-		} else if (colToCompare==7) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheOwner().toLowerCase();
+		} else if (colToCompare == 7) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheOwner().toLowerCase();
 			}
-		} else if (colToCompare==8) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getDateHidden();
+		} else if (colToCompare == 8) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getDateHidden();
 			}
-		} else if (colToCompare==9) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=ch.getCacheStatus();
+		} else if (colToCompare == 9) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getCacheStatus();
 			}
-		} else if (colToCompare==10) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
+		} else if (colToCompare == 10) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
 				// CHECK Is the formatting correctly done?
-				if (ch.kilom==-1.0) {
-					ch.sort=&quot;\uFFFF&quot;;
+				if (ch.kilom == -1.0) {
+					ch.sort = &quot;\uFFFF&quot;;
+				} else {
+					ch.sort = MyLocale.formatDouble(ch.kilom * 1000, &quot;000000000000&quot;);
 				}
-				else {
-					ch.sort = MyLocale.formatDouble(ch.kilom*1000, &quot;000000000000&quot;);
-				}
 			}
-		} else if (colToCompare==11) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
+		} else if (colToCompare == 11) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
 				if (ch.getBearing().equals(&quot;?&quot;)) {
-					ch.sort=&quot;\uFFFF&quot;;
+					ch.sort = &quot;\uFFFF&quot;;
+				} else {
+					ch.sort = ch.getBearing();
 				}
+			}
+
+		} else if (colToCompare == 12) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = Integer.toString(ch.getCacheSize());
+			}
+		} else if (colToCompare == 13) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.isOC()) {
+					ch.sort = MyLocale.formatLong(ch.recommendationScore, &quot;000&quot;) + MyLocale.formatLong(ch.getNumRecommended(), &quot;00000&quot;);
+				} else {
+					int gcVote = ch.getNumRecommended();
+					if (gcVote &lt; 100) {
+						ch.sort = MyLocale.formatLong(gcVote, &quot;000&quot;) + &quot;00000000&quot;;
+					} else {
+						int votes = gcVote / 100;
+						gcVote = gcVote - 100 * votes;
+						ch.sort = MyLocale.formatLong(gcVote, &quot;000&quot;) + MyLocale.formatLong(votes, &quot;00000000&quot;);
+					}
+				}
+			}
+		} else if (colToCompare == 14) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.getWayPoint().startsWith(&quot;GC&quot;))
+					if (ch.getOcCacheID().length() == 0)
+						ch.sort = &quot;\uFFFF&quot;;
+					else
+						ch.sort = ch.getOcCacheID();
 				else {
-					ch.sort=ch.getBearing();
-				}			
+					ch.sort = OC.getGCWayPoint(ch.getCacheOwner());
+					if (ch.sort.length() == 0)
+						ch.sort = &quot;\uFFFF&quot;; // ans Ende
+				}
 			}
-			
-		} else if (colToCompare==12) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				ch.sort=Integer.toString(ch.getCacheSize());
+		} else if (colToCompare == 15) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.hasSolver()) {
+					ch.sort = &quot;1&quot;;
+				} else {
+					ch.sort = &quot;2&quot;;
+				}
 			}
-		} else if (colToCompare==13) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				if ( ch.isOC() ) {
-  				ch.sort=MyLocale.formatLong(ch.getNumRecommended(),&quot;00000&quot;);
-        } else {
-				  int gcVote = ch.getNumRecommended();
-				  if ( gcVote &lt; 100 ) {
-				    ch.sort=MyLocale.formatLong(gcVote,&quot;00&quot;) + &quot;00000000&quot;;
-          } else {
-            int votes = gcVote / 100;
-            gcVote = gcVote - 100 * votes;
-            ch.sort = MyLocale.formatLong(gcVote,&quot;00&quot;) + MyLocale.formatLong(votes,&quot;00000000&quot;);
-          }
-        }
-			}			
-		} else if (colToCompare==14) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch=cacheDB.get(i);
-				if (ch.isOC())
-					ch.sort=MyLocale.formatLong(ch.recommendationScore,&quot;00000&quot;);
-				else
-					ch.sort=&quot;\uFFFF&quot;;
-			}			
-		} else if (colToCompare==15) {
-		    for (int i=0; i&lt;visibleSize; i++) {
-		        CacheHolder ch=cacheDB.get(i);
-		        if (ch.hasSolver()) {
-		            ch.sort=&quot;1&quot;;
-		        } else {
-		            ch.sort=&quot;2&quot;;
-		        }
-		    }
-		} else if (colToCompare==16) {
-		    for (int i=0; i&lt;visibleSize; i++) {
-		        CacheHolder ch=cacheDB.get(i);
-		        if (ch.hasNote()) {
-		            ch.sort=&quot;1&quot;;
-		        } else {
-		            ch.sort=&quot;2&quot;;
-		        }
-		    }
-		} else if (colToCompare==17) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=MyLocale.formatLong(ch.addiWpts.size(),&quot;000&quot;);
+		} else if (colToCompare == 16) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				if (ch.hasNote()) {
+					ch.sort = &quot;1&quot;;
+				} else {
+					ch.sort = &quot;2&quot;;
+				}
 			}
-		} else if (colToCompare==18) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=MyLocale.formatLong(ch.getNoFindLogs(),&quot;000&quot;);
+		} else if (colToCompare == 17) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = MyLocale.formatLong(ch.addiWpts.size(), &quot;000&quot;);
 			}
-		} else if (colToCompare==19) {
-			for (int i=0; i&lt;visibleSize; i++) {
-				CacheHolder ch =  cacheDB.get(i);
-				ch.sort=ch.getLastSync();
+		} else if (colToCompare == 18) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = MyLocale.formatLong(ch.getNoFindLogs(), &quot;000&quot;);
 			}
+		} else if (colToCompare == 19) {
+			for (int i = 0; i &lt; visibleSize; i++) {
+				CacheHolder ch = cacheDB.get(i);
+				ch.sort = ch.getLastSync();
+			}
 		}
- 	}
-	
-	public int compare(Object o1, Object o2){
-		CacheHolder oo1 = (CacheHolder)o1;
-		CacheHolder oo2 = (CacheHolder)o2;
+	}
+
+	public int compare(Object o1, Object o2) {
+		CacheHolder oo1 = (CacheHolder) o1;
+		CacheHolder oo2 = (CacheHolder) o2;
 		return oo1.sort.compareTo(oo2.sort);
 	}
 }

Modified: branches/r1.2/src/CacheWolf/OC.java
===================================================================
--- branches/r1.2/src/CacheWolf/OC.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/OC.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 public final class OC {
@@ -32,45 +32,62 @@
 		// Nothing to do
 	}
 
-	public final static int OC_HOSTNAME = 0; 
-	public final static int OC_PREFIX = 1; 
-	public final static String[][] OCSites = {
-		{&quot;www.opencaching.de&quot;, &quot;OC&quot;},
-		{&quot;www.opencaching.pl&quot;, &quot;OP&quot;},
-		{&quot;www.opencaching.cz&quot;, &quot;OZ&quot;},
-		{&quot;www.opencaching.org.uk&quot;, &quot;OK&quot;},
-		{&quot;www.opencaching.se&quot;, &quot;OS&quot;},
-		{&quot;www.opencaching.no&quot;, &quot;ON&quot;},
-		{&quot;www.opencaching.us&quot;, &quot;OU&quot;}
-		};
+	public final static int OC_HOSTNAME = 0;
+	public final static int OC_PREFIX = 1;
+	public final static String[][] OCSites = {//
+	{ &quot;www.opencaching.de&quot;, &quot;OC&quot; },// 1
+			{ &quot;www.opencaching.pl&quot;, &quot;OP&quot; },// 2
+			{ &quot;www.opencaching.cz&quot;, &quot;OZ&quot; },// 3
+			{ &quot;www.opencaching.org.uk&quot;, &quot;OK&quot; },// 4
+			{ &quot;www.opencaching.se&quot;, &quot;OS&quot; },// 5
+			{ &quot;www.opencaching.no&quot;, &quot;ON&quot; },// 6
+			{ &quot;www.opencaching.us&quot;, &quot;OU&quot; },// 7
+			{ &quot;www.opencachingspain.es&quot;, &quot;OC&quot; },// 8 !!!
+			{ &quot;www.opencaching.it&quot;, &quot;OC&quot; },// 9 !!!
+			{ &quot;www.opencaching.jp&quot;, &quot;OJ&quot; },// 10
+			{ &quot;www.opencaching.nl&quot;, &quot;OB&quot; },// 11
+	};
 
 	public final static String[] OCHostNames() {
-		String[] ret=new String[OCSites.length];
+		String[] ret = new String[OCSites.length];
 		for (int i = 0; i &lt; OCSites.length; i++) {
-			ret[i]=OCSites[i][OC_HOSTNAME];
+			ret[i] = OCSites[i][OC_HOSTNAME];
 		}
 		return ret;
 	}
-	
-	public final static String getOCHostName(String wpName){
+
+	public final static String getOCHostName(String wpName) {
 		for (int i = 0; i &lt; OCSites.length; i++) {
-			if(wpName.startsWith(OCSites[i][OC_PREFIX])) {
+			if (wpName.startsWith(OCSites[i][OC_PREFIX])) {
 				return OCSites[i][OC_HOSTNAME];
 			}
 		}
 		return null;
 	}
-	
+
 	public final static boolean isOC(String wpName) {
-		return (getOCHostName(wpName.toUpperCase()) != null);		
+		return (getOCHostName(wpName.toUpperCase()) != null);
 	}
-	
+
 	public final static int getSiteIndex(String site) {
 		for (int i = 0; i &lt; OCSites.length; i++) {
-			if(site.equalsIgnoreCase(OCSites[i][OC_HOSTNAME])) {
+			if (site.equalsIgnoreCase(OCSites[i][OC_HOSTNAME])) {
 				return i;
 			}
 		}
 		return 0; // don't get a fault
 	}
+
+	public final static String getGCWayPoint(String owner) {
+		owner = owner + &quot; &quot;;
+		int l = owner.lastIndexOf('/');
+		if (l &gt; 0) {
+			int i = owner.indexOf(&quot;GC&quot;, l);
+			if (i &gt; -1) {
+				int j = owner.indexOf(&quot; &quot;, i);
+				return owner.substring(i, j);
+			}
+		}
+		return &quot;&quot;;
+	}
 }

Modified: branches/r1.2/src/CacheWolf/Parser.java
===================================================================
--- branches/r1.2/src/CacheWolf/Parser.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Parser.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,72 +1,72 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 /* 
-A parser that parses the following grammar:
-EBNF Meta-Symbols:
-  {xx}        xx can occur any number of times incl 0
-  [xx]        xx or empty
-  |           or
-  &quot;x&quot;         x is terminal symbol
+ A parser that parses the following grammar:
+ EBNF Meta-Symbols:
+ {xx}        xx can occur any number of times incl 0
+ [xx]        xx or empty
+ |           or
+ &quot;x&quot;         x is terminal symbol
 
-command -&gt; if |
-         simplecommand
+ command -&gt; if |
+ simplecommand
 
-simplecommand -&gt; &quot;stop&quot; | &quot;st&quot; |
-		   assign
-         stringexp |
+ simplecommand -&gt; &quot;stop&quot; | &quot;st&quot; |
+ assign
+ stringexp |
 
-if -&gt; &quot;IF&quot; stringexpr compop stringexpr &quot;THEN&quot; simplecommand { &quot;;&quot; simplecommand } &quot;ENDIF&quot;          // Nested IF's not allowed
+ if -&gt; &quot;IF&quot; stringexpr compop stringexpr &quot;THEN&quot; simplecommand { &quot;;&quot; simplecommand } &quot;ENDIF&quot;          // Nested IF's not allowed
 
-compop -&gt; &quot;=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;&gt;&quot; | &quot;!=&quot; | &quot;&gt;&lt;&quot;
+ compop -&gt; &quot;=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;&gt;&quot; | &quot;!=&quot; | &quot;&gt;&lt;&quot;
 
-assign -&gt; ident = [ stringexpr ]
+ assign -&gt; ident = [ stringexpr ]
 
-stringexp -&gt; (string | expr ) {string | tailexp }
+ stringexp -&gt; (string | expr ) {string | tailexp }
 
-expr -&gt; [&quot;+&quot; | &quot;-&quot;] tailexp [ formatstring ]
+ expr -&gt; [&quot;+&quot; | &quot;-&quot;] tailexp [ formatstring ]
 
-tailexp -&gt; term { (&quot;+&quot; | &quot;-&quot;) term }
+ tailexp -&gt; term { (&quot;+&quot; | &quot;-&quot;) term }
 
-term -&gt; factor { (&quot;*&quot; | &quot;/&quot;) factor }
+ term -&gt; factor { (&quot;*&quot; | &quot;/&quot;) factor }
 
-factor -&gt; expfactor { &quot;^&quot; expfactor }
+ factor -&gt; expfactor { &quot;^&quot; expfactor }
 
-expfactor -&gt; ident |
-        number |
-        &quot;(&quot; stringexpr &quot;)&quot; |
-        function &quot;(&quot; stringexpr { &quot;,&quot; stringexpr }&quot;)&quot;
+ expfactor -&gt; ident |
+ number |
+ &quot;(&quot; stringexpr &quot;)&quot; |
+ function &quot;(&quot; stringexpr { &quot;,&quot; stringexpr }&quot;)&quot;
 
-function -&gt; &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;asin&quot; | &quot;acos&quot; | &quot;atan&quot; | &quot;goto&quot; | &quot;project&quot; | &quot;show&quot;  | &quot;crosstotal&quot; |
-          &quot;rot13&quot; | &quot;len&quot; | &quot;mid&quot;
+ function -&gt; &quot;sin&quot; | &quot;cos&quot; | &quot;tan&quot; | &quot;asin&quot; | &quot;acos&quot; | &quot;atan&quot; | &quot;goto&quot; | &quot;project&quot; | &quot;show&quot;  | &quot;crosstotal&quot; |
+ &quot;rot13&quot; | &quot;len&quot; | &quot;mid&quot;
 
-ident -&gt; valid identifier
-number -&gt; valid number
+ ident -&gt; valid identifier
+ number -&gt; valid number
 
 
-*/
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -82,196 +82,155 @@
 import ewe.util.mString;
 
 /**
-*	The wolf language parser. New version - January 2007
-*
-*   New features:
-*   - Improved error handling
-*   - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
-*   - Variables can store strings or doubles
-*   - Global variables (starting with $) are remembered across multiple calls to parser
-*   - Global variables are initialised with &quot;&quot;, local variables result in error if used before setting value
-*   - IF statement added
-*   - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
-*   - less typing
-*   	- Function aliases
-*   	- Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
-*   	- show no longer needed
-*   	- Command terminator ; no longer compulsory (only between multiple commands on same line)
-*   - New functions can easily be added
-*   - Can select whether variable names are case sensitive
-*
-*   To add a new function:
-*     1) Add its name and alias and allowed number of args to array functions
-*     2) Add a new private method in the &quot;functions&quot; section
-*     3) Add call to private method in executeFunction
-*   @author salzkammergut Januay 2007
-*/
-public class Parser{
+ * The wolf language parser. New version - January 2007
+ * 
+ * New features:
+ * - Improved error handling
+ * - Strings and doubles can be freely mixed as appropriate. Depending on context a conversion is performed,
+ * - Variables can store strings or doubles
+ * - Global variables (starting with $) are remembered across multiple calls to parser
+ * - Global variables are initialised with &quot;&quot;, local variables result in error if used before setting value
+ * - IF statement added
+ * - Many new functions (encode,format,goto,len,mid,count, substring,ucase,lcase,val,sval,replace, reverse,project)
+ * - less typing
+ * - Function aliases
+ * - Function names can be flexibly abbreviated, i.e. instead of crosstotal write cr or cross or crosst ...
+ * - show no longer needed
+ * - Command terminator ; no longer compulsory (only between multiple commands on same line)
+ * - New functions can easily be added
+ * - Can select whether variable names are case sensitive
+ * 
+ * To add a new function:
+ * 1) Add its name and alias and allowed number of args to array functions
+ * 2) Add a new private method in the &quot;functions&quot; section
+ * 3) Add call to private method in executeFunction
+ * 
+ * @author salzkammergut Januay 2007
+ */
+public class Parser {
 
 	private class fnType {
-		public String funcName; 	 // the function name in the user input
-		public String alias;         // the funcName is mapped to this alias
-		public int nargs;            // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
-									 // i.e. 1&lt;&lt;nargs ORed together
+		public String funcName; // the function name in the user input
+		public String alias; // the funcName is mapped to this alias
+		public int nargs; // bitmap for number of args, i.e. 14 = 1 or 2 or 3 args; 5 = 0 or 2 args
+							// i.e. 1&lt;&lt;nargs ORed together
+
 		fnType(String funcName, String alias, int nargs) {
-			this.funcName=funcName; this.alias=alias; this.nargs=nargs;
+			this.funcName = funcName;
+			this.alias = alias;
+			this.nargs = nargs;
 		}
-		boolean nargsValid(int testNargs){
-			return ((1&lt;&lt;testNargs)&amp;this.nargs)!=0;
+
+		boolean nargsValid(int testNargs) {
+			return ((1 &lt;&lt; testNargs) &amp; this.nargs) != 0;
 		}
 	}
-    fnType[] functions=new fnType[]{ // in alphabetical order
-    	new fnType(&quot;abs&quot;,&quot;abs&quot;,2),
-    	new fnType(&quot;acos&quot;,&quot;acos&quot;,2),
-    	new fnType(&quot;asin&quot;,&quot;asin&quot;,2),
-    	new fnType(&quot;atan&quot;,&quot;atan&quot;,2),
-      	new fnType(&quot;bearing&quot;,&quot;bearing&quot;,4),
-    	new fnType(&quot;cb&quot;,&quot;cb&quot;,16),
-     	new fnType(&quot;centre&quot;,&quot;center&quot;,3),
-    	new fnType(&quot;center&quot;,&quot;center&quot;,3),
-    	new fnType(&quot;cls&quot;,&quot;cls&quot;,1),
-    	new fnType(&quot;clearscreen&quot;,&quot;cls&quot;,1),
-    	new fnType(&quot;cos&quot;,&quot;cos&quot;,2),
-    	new fnType(&quot;count&quot;,&quot;count&quot;,4),
-     	new fnType(&quot;cp&quot;,&quot;cp&quot;,1),
-    	new fnType(&quot;crossbearing&quot;,&quot;cb&quot;,16),
-    	new fnType(&quot;crosstotal&quot;,&quot;ct&quot;,6),
-    	new fnType(&quot;ct&quot;,&quot;ct&quot;,2),
-     	new fnType(&quot;curpos&quot;,&quot;cp&quot;,1),
-     	new fnType(&quot;d2r&quot;,&quot;deg2rad&quot;,2),
-     	new fnType(&quot;deg&quot;,&quot;deg&quot;,1),
-     	new fnType(&quot;deg2rad&quot;,&quot;deg2rad&quot;,2),
-     	new fnType(&quot;distance&quot;,&quot;distance&quot;,4),
-     	new fnType(&quot;encode&quot;,&quot;encode&quot;,8),
-    	new fnType(&quot;format&quot;,&quot;format&quot;,12),
-    	new fnType(&quot;goto&quot;,&quot;goto&quot;,6),
-    	new fnType(&quot;ic&quot;,&quot;ic&quot;,3),
-    	new fnType(&quot;ignorecase&quot;,&quot;ic&quot;,3),
-    	new fnType(&quot;instr&quot;,&quot;instr&quot;,12),
-    	new fnType(&quot;int&quot;,&quot;int&quot;,2),
-    	new fnType(&quot;lcase&quot;,&quot;lc&quot;,2),
-    	new fnType(&quot;length&quot;,&quot;len&quot;,2),
-    	new fnType(&quot;mid&quot;,&quot;mid&quot;,12),
-    	new fnType(&quot;mod&quot;,&quot;mod&quot;,4),
-     	new fnType(&quot;pc&quot;,&quot;pz&quot;,3),
-     	new fnType(&quot;profilecenter&quot;,&quot;pz&quot;,3),
-     	new fnType(&quot;profilecentre&quot;,&quot;pz&quot;,3),
-     	new fnType(&quot;profilzentrum&quot;,&quot;pz&quot;,3),
-    	new fnType(&quot;project&quot;,&quot;project&quot;,8),
-     	new fnType(&quot;pz&quot;,&quot;pz&quot;,3),
-    	new fnType(&quot;quersumme&quot;,&quot;ct&quot;,6),
-    	new fnType(&quot;r2d&quot;,&quot;rad2deg&quot;,2),
-    	new fnType(&quot;rad&quot;,&quot;rad&quot;,1),
-    	new fnType(&quot;rad2deg&quot;,&quot;rad2deg&quot;,2),
-    	new fnType(&quot;replace&quot;,&quot;replace&quot;,8),
-    	new fnType(&quot;reverse&quot;,&quot;reverse&quot;,2),
-    	new fnType(&quot;rot13&quot;,&quot;rot13&quot;,2),
-    	new fnType(&quot;show&quot;,&quot;show&quot;,2),
-    	new fnType(&quot;sin&quot;,&quot;sin&quot;,2),
-    	new fnType(&quot;skeleton&quot;,&quot;skeleton&quot;,3),
-    	new fnType(&quot;sqrt&quot;,&quot;sqrt&quot;,2),
-    	new fnType(&quot;sval&quot;,&quot;sval&quot;,2),
-    	new fnType(&quot;tolowercase&quot;,&quot;lc&quot;,2),
-    	new fnType(&quot;touppercase&quot;,&quot;uc&quot;,2),
-    	new fnType(&quot;tan&quot;,&quot;tan&quot;,2),
-    	new fnType(&quot;ucase&quot;,&quot;uc&quot;,2),
-    	new fnType(&quot;val&quot;,&quot;val&quot;,2),
-     	new fnType(&quot;zentrum&quot;,&quot;center&quot;,3)
-     	    	};
+
+	fnType[] functions = new fnType[] { // in alphabetical order
+	new fnType(&quot;abs&quot;, &quot;abs&quot;, 2), new fnType(&quot;acos&quot;, &quot;acos&quot;, 2), new fnType(&quot;asin&quot;, &quot;asin&quot;, 2), new fnType(&quot;atan&quot;, &quot;atan&quot;, 2), new fnType(&quot;bearing&quot;, &quot;bearing&quot;, 4), new fnType(&quot;cb&quot;, &quot;cb&quot;, 16), new fnType(&quot;centre&quot;, &quot;center&quot;, 3),
+			new fnType(&quot;center&quot;, &quot;center&quot;, 3), new fnType(&quot;cls&quot;, &quot;cls&quot;, 1), new fnType(&quot;clearscreen&quot;, &quot;cls&quot;, 1), new fnType(&quot;cos&quot;, &quot;cos&quot;, 2), new fnType(&quot;count&quot;, &quot;count&quot;, 4), new fnType(&quot;cp&quot;, &quot;cp&quot;, 1), new fnType(&quot;crossbearing&quot;, &quot;cb&quot;, 16),
+			new fnType(&quot;crosstotal&quot;, &quot;ct&quot;, 6), new fnType(&quot;ct&quot;, &quot;ct&quot;, 2), new fnType(&quot;curpos&quot;, &quot;cp&quot;, 1), new fnType(&quot;d2r&quot;, &quot;deg2rad&quot;, 2), new fnType(&quot;deg&quot;, &quot;deg&quot;, 1), new fnType(&quot;deg2rad&quot;, &quot;deg2rad&quot;, 2), new fnType(&quot;distance&quot;, &quot;distance&quot;, 4),
+			new fnType(&quot;encode&quot;, &quot;encode&quot;, 8), new fnType(&quot;format&quot;, &quot;format&quot;, 12), new fnType(&quot;goto&quot;, &quot;goto&quot;, 6), new fnType(&quot;ic&quot;, &quot;ic&quot;, 3), new fnType(&quot;ignorecase&quot;, &quot;ic&quot;, 3), new fnType(&quot;instr&quot;, &quot;instr&quot;, 12), new fnType(&quot;int&quot;, &quot;int&quot;, 2),
+			new fnType(&quot;lcase&quot;, &quot;lc&quot;, 2), new fnType(&quot;length&quot;, &quot;len&quot;, 2), new fnType(&quot;mid&quot;, &quot;mid&quot;, 12), new fnType(&quot;mod&quot;, &quot;mod&quot;, 4), new fnType(&quot;pc&quot;, &quot;pz&quot;, 3), new fnType(&quot;profilecenter&quot;, &quot;pz&quot;, 3), new fnType(&quot;profilecentre&quot;, &quot;pz&quot;, 3),
+			new fnType(&quot;profilzentrum&quot;, &quot;pz&quot;, 3), new fnType(&quot;project&quot;, &quot;project&quot;, 8), new fnType(&quot;pz&quot;, &quot;pz&quot;, 3), new fnType(&quot;quersumme&quot;, &quot;ct&quot;, 6), new fnType(&quot;r2d&quot;, &quot;rad2deg&quot;, 2), new fnType(&quot;rad&quot;, &quot;rad&quot;, 1), new fnType(&quot;rad2deg&quot;, &quot;rad2deg&quot;, 2),
+			new fnType(&quot;replace&quot;, &quot;replace&quot;, 8), new fnType(&quot;reverse&quot;, &quot;reverse&quot;, 2), new fnType(&quot;rot13&quot;, &quot;rot13&quot;, 2), new fnType(&quot;show&quot;, &quot;show&quot;, 2), new fnType(&quot;sin&quot;, &quot;sin&quot;, 2), new fnType(&quot;skeleton&quot;, &quot;skeleton&quot;, 3), new fnType(&quot;sqrt&quot;, &quot;sqrt&quot;, 2),
+			new fnType(&quot;sval&quot;, &quot;sval&quot;, 2), new fnType(&quot;tolowercase&quot;, &quot;lc&quot;, 2), new fnType(&quot;touppercase&quot;, &quot;uc&quot;, 2), new fnType(&quot;tan&quot;, &quot;tan&quot;, 2), new fnType(&quot;ucase&quot;, &quot;uc&quot;, 2), new fnType(&quot;val&quot;, &quot;val&quot;, 2), new fnType(&quot;zentrum&quot;, &quot;center&quot;, 3) };
 	private static int scanpos = 0;
-	CWPoint cwPt=new CWPoint();
-	Vector calcStack=new Vector();
+	CWPoint cwPt = new CWPoint();
+	Vector calcStack = new Vector();
 	Hashtable symbolTable = new Hashtable(50);
 	TokenObj thisToken = new TokenObj();
 	Vector tokenStack;
 	Vector messageStack;
 
-	public Parser(){ // Global constructor
+	public Parser() { // Global constructor
 	}
 
-///////////////////////////////////////////
-//  Utility functions
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// Utility functions
+	// /////////////////////////////////////////
 
-	/* All errors are handled via function 'err'. Rather than creating many different Exceptions,
+	/*
+	 * All errors are handled via function 'err'. Rather than creating many different Exceptions,
 	 * only the standard Exception is used. err raises this exception and thereby causes the stack to be
 	 * unwound until 'parse' eventually catches the exception and returns to SolverPanel, which displays
 	 * the messageStack containing the error message.
 	 */
 
 	/**
-     * Add an error message to the message stack and raise an Exception.
-    */
+	 * Add an error message to the message stack and raise an Exception.
+	 */
 	private void err(String str) throws Exception {
-    	messageStack.add(MyLocale.getMsg(1700,&quot;Error on line: &quot;) + thisToken.line + &quot;  &quot;+MyLocale.getMsg(1701,&quot;position: &quot;) + thisToken.position);
-    	messageStack.add(str);
-    	// move cursor to error location
-    	if (Global.mainTab.solverP.mText.setSelectionRange(0,thisToken.line-1,thisToken.position+thisToken.token.length()-1,thisToken.line-1))Global.mainTab.solverP.mText.repaintNow();
-    	throw new Exception(&quot;Error &quot;+str);
-    }
+		messageStack.add(MyLocale.getMsg(1700, &quot;Error on line: &quot;) + thisToken.line + &quot;  &quot; + MyLocale.getMsg(1701, &quot;position: &quot;) + thisToken.position);
+		messageStack.add(str);
+		// move cursor to error location
+		if (Global.mainTab.solverP.mText.setSelectionRange(0, thisToken.line - 1, thisToken.position + thisToken.token.length() - 1, thisToken.line - 1))
+			Global.mainTab.solverP.mText.repaintNow();
+		throw new Exception(&quot;Error &quot; + str);
+	}
 
-    /** Shows global symbols */
-    private void showVars(boolean globals) throws Exception {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		String varName=((String)((ewe.util.Map.MapEntry) it.next()).getKey());
-    		if (globals == varName.startsWith(&quot;$&quot;)) {
-    			String value=(String) getVariable(varName);
-    			if (java.lang.Double.isNaN(toNumber(value)))
-    				messageStack.add(varName+&quot; = \&quot;&quot;+STRreplace.replace(value.toString(),&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
-    			else
-    				messageStack.add(varName+&quot; = &quot;+value);
-    		}
-    	}
-    }
+	/** Shows global symbols */
+	private void showVars(boolean globals) throws Exception {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			String varName = ((String) ((ewe.util.Map.MapEntry) it.next()).getKey());
+			if (globals == varName.startsWith(&quot;$&quot;)) {
+				String value = (String) getVariable(varName);
+				if (java.lang.Double.isNaN(toNumber(value)))
+					messageStack.add(varName + &quot; = \&quot;&quot; + STRreplace.replace(value.toString(), &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;);
+				else
+					messageStack.add(varName + &quot; = &quot; + value);
+			}
+		}
+	}
 
 	/** Clears the symbol table of all non-global symbols (those not starting with $) */
-    private void clearLocalSymbols() {
-    	Iterator it=symbolTable.entries();
-    	while (it.hasNext()) {
-    		ewe.util.Map.MapEntry sym=(ewe.util.Map.MapEntry) it.next();
-    		if (!((String)sym.getKey()).startsWith(&quot;$&quot;))
-    			symbolTable.remove(sym.getKey());
-    	}
-    	Double pi=new Double(java.lang.Math.PI);
-    	symbolTable.put(&quot;PI&quot;,pi);
-    	symbolTable.put(&quot;pi&quot;,pi); // To make it easier for the user we also add a lowercase version of pi
-    }
+	private void clearLocalSymbols() {
+		Iterator it = symbolTable.entries();
+		while (it.hasNext()) {
+			ewe.util.Map.MapEntry sym = (ewe.util.Map.MapEntry) it.next();
+			if (!((String) sym.getKey()).startsWith(&quot;$&quot;))
+				symbolTable.remove(sym.getKey());
+		}
+		Double pi = new Double(java.lang.Math.PI);
+		symbolTable.put(&quot;PI&quot;, pi);
+		symbolTable.put(&quot;pi&quot;, pi); // To make it easier for the user we also add a lowercase version of pi
+	}
 
 	private boolean isVariable(String varName) {
-		return varName.startsWith(&quot;$&quot;) ||  // Global variables exist per default
-		       symbolTable.containsKey(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
+		return varName.startsWith(&quot;$&quot;) || // Global variables exist per default
+				symbolTable.containsKey(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
 	}
 
 	private boolean isInteger(double d) {
-		return java.lang.Math.ceil(d)==d &amp;&amp; java.lang.Math.floor(d)==d;
+		return java.lang.Math.ceil(d) == d &amp;&amp; java.lang.Math.floor(d) == d;
 	}
 
-    private boolean isValidCoord(String coord) {
-    	cwPt.set(coord);
-    	return cwPt.isValid();
-    }
+	private boolean isValidCoord(String coord) {
+		cwPt.set(coord);
+		return cwPt.isValid();
+	}
 
 	private Object getVariable(String varName) throws Exception {
 		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Found it!
 				// Check whether coordinates are valid
-				cwPt.set(ch.pos);
-				if (cwPt.isValid() )
+				cwPt.set(ch.getPos());
+				if (cwPt.isValid())
 					return cwPt.toString();
 				else
 					return &quot;&quot;; // Convert invalid coordinates (N 0 0.0 E 0 0.0) into empty string
 			}
 		}
-		Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-		if(result == null) {
+		Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+		if (result == null) {
 			// If it is a global variable, add it with a default value
 			if (varName.startsWith(&quot;$&quot;)) {
-				result=&quot;&quot;;
-				symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName,&quot;&quot;);
+				result = &quot;&quot;;
+				symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, &quot;&quot;);
 			} else
-				err (MyLocale.getMsg(1702,&quot;Variable not defined: &quot;)+varName);
+				err(MyLocale.getMsg(1702, &quot;Variable not defined: &quot;) + varName);
 		}
 		return result;
 	}
@@ -281,66 +240,68 @@
 			if (MyLocale.getDigSeparator().equals(&quot;,&quot;))
 				str = str.replace('.', ',');
 			else
-				str = str.replace(',','.');
+				str = str.replace(',', '.');
 			return java.lang.Double.parseDouble(str);
 		} catch (NumberFormatException e) {
-			 return java.lang.Double.NaN;
+			return java.lang.Double.NaN;
 		}
 	}
 
 	private Double getNumber(String str) throws Exception {
-		double ret=toNumber(str);
+		double ret = toNumber(str);
 		if (java.lang.Double.isNaN(ret))
-			err(MyLocale.getMsg(1703,&quot;Not a valid number: &quot;) + str);
+			err(MyLocale.getMsg(1703, &quot;Not a valid number: &quot;) + str);
 		return new java.lang.Double(ret);
 	}
 
 	/** Get the top element of the calculation stack and try and convert it to a number if it is a string */
 	private double popCalcStackAsNumber(double defaultForEmptyString) throws Exception {
 		double num;
-		if (calcStack.get(calcStack.size()-1) instanceof String) {
-			if (((String)calcStack.get(calcStack.size()-1)).equals(&quot;&quot;))
-				num=defaultForEmptyString;
+		if (calcStack.get(calcStack.size() - 1) instanceof String) {
+			if (((String) calcStack.get(calcStack.size() - 1)).equals(&quot;&quot;))
+				num = defaultForEmptyString;
 			else
-				num = getNumber((String)calcStack.get(calcStack.size()-1)).doubleValue();
+				num = getNumber((String) calcStack.get(calcStack.size() - 1)).doubleValue();
 		} else {
-			num = ((java.lang.Double)calcStack.get(calcStack.size()-1)).doubleValue();
+			num = ((java.lang.Double) calcStack.get(calcStack.size() - 1)).doubleValue();
 		}
-		calcStack.removeElementAt(calcStack.size()-1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return num;
 	}
 
 	private String popCalcStackAsString() {
 		String s;
-		if (calcStack.get(calcStack.size()-1) instanceof Double) {
-			java.lang.Double D=((java.lang.Double)calcStack.get(calcStack.size()-1));
+		if (calcStack.get(calcStack.size() - 1) instanceof Double) {
+			java.lang.Double D = ((java.lang.Double) calcStack.get(calcStack.size() - 1));
 			// Double.toString() formats numbers &gt; 1E7 and &lt; 1E-3 with exponential notation
 			// For large integers we therefore use Longs
-			double d=D.doubleValue();
+			double d = D.doubleValue();
 			// If the double is an integer and within range of longs, use Long
-			if (java.lang.Math.floor(d)==d &amp;&amp; d&lt;java.lang.Long.MAX_VALUE &amp;&amp; d&gt;java.lang.Long.MIN_VALUE) {
-				java.lang.Long L=new java.lang.Long((long)d);
-				s=L.toString();
+			if (java.lang.Math.floor(d) == d &amp;&amp; d &lt; java.lang.Long.MAX_VALUE &amp;&amp; d &gt; java.lang.Long.MIN_VALUE) {
+				java.lang.Long L = new java.lang.Long((long) d);
+				s = L.toString();
 			} else { // Use the default Double format
-				s = D.toString().replace(',','.'); // always show numbers with decimal point;
-				if (s.endsWith(&quot;.0&quot;)) s=s.substring(0,s.length()-2);
+				s = D.toString().replace(',', '.'); // always show numbers with decimal point;
+				if (s.endsWith(&quot;.0&quot;))
+					s = s.substring(0, s.length() - 2);
 			}
 		} else
-			s = (String)calcStack.get(calcStack.size()-1);
-		calcStack.removeElementAt(calcStack.size()-1);
+			s = (String) calcStack.get(calcStack.size() - 1);
+		calcStack.removeElementAt(calcStack.size() - 1);
 		return s;
 	}
 
 	private void getToken() throws Exception {
-		if(scanpos &lt; tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		if (scanpos &lt; tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-		} else err(MyLocale.getMsg(1704,&quot;Unexpected end of source&quot;));
+		} else
+			err(MyLocale.getMsg(1704, &quot;Unexpected end of source&quot;));
 	}
 
 	private TokenObj peekToken() {
-		if(scanpos &lt; tokenStack.size()){
-			return (TokenObj)tokenStack.get(scanpos);
+		if (scanpos &lt; tokenStack.size()) {
+			return (TokenObj) tokenStack.get(scanpos);
 		} else
 			return new TokenObj();
 	}
@@ -352,54 +313,58 @@
 	}
 
 	private void skipPastEndif(TokenObj ifToken) throws Exception {
-		while(scanpos &lt; tokenStack.size()){
-			thisToken = (TokenObj)tokenStack.get(scanpos);
+		while (scanpos &lt; tokenStack.size()) {
+			thisToken = (TokenObj) tokenStack.get(scanpos);
 			scanpos++;
-			if (thisToken.tt==TokenObj.TT_ENDIF) {
+			if (thisToken.tt == TokenObj.TT_ENDIF) {
 				getToken();
 				return;
 			}
 		}
-		thisToken=ifToken;
-		err(MyLocale.getMsg(1705,&quot;Missing ENDIF&quot;));
+		thisToken = ifToken;
+		err(MyLocale.getMsg(1705, &quot;Missing ENDIF&quot;));
 	}
+
 	private TokenObj lookAheadToken() {
-		return (TokenObj)tokenStack.get(scanpos);
+		return (TokenObj) tokenStack.get(scanpos);
 	}
 
 	private boolean checkNextSymIs(String str) throws Exception {
-		if(thisToken.token.toUpperCase().equals(str)){
+		if (thisToken.token.toUpperCase().equals(str)) {
 			return true;
 		} else {
-			err(MyLocale.getMsg(1706,&quot;Expected &quot;) + str + &quot;  &quot;+MyLocale.getMsg(1707,&quot;Found: &quot;)+thisToken.token);
-			return false; //Dummy as err does not return
+			err(MyLocale.getMsg(1706, &quot;Expected &quot;) + str + &quot;  &quot; + MyLocale.getMsg(1707, &quot;Found: &quot;) + thisToken.token);
+			return false; // Dummy as err does not return
 		}
 	}
 
 	private fnType getFunctionDefinition(String str) throws Exception {
-    	fnType fnd=null;
-    	str=str.toLowerCase();
-    	for (int i=functions.length-1; i&gt;=0; i--) {
-    		// Return the function if there is an exact match
-    		if (functions[i].funcName.equals(str)) return functions[i];
-    		if (functions[i].funcName.startsWith(str)) { // Partial match?
-        		// Only one partial match allowed
-    			if (fnd!=null) err(MyLocale.getMsg(1708,&quot;Ambiguous function name: &quot;)+str);
-    			fnd=functions[i];
-    		}
-    	}
-    	if (fnd==null) err(MyLocale.getMsg(1709,&quot;Unknown function: &quot;)+str);
-    	return fnd;
-    }
+		fnType fnd = null;
+		str = str.toLowerCase();
+		for (int i = functions.length - 1; i &gt;= 0; i--) {
+			// Return the function if there is an exact match
+			if (functions[i].funcName.equals(str))
+				return functions[i];
+			if (functions[i].funcName.startsWith(str)) { // Partial match?
+				// Only one partial match allowed
+				if (fnd != null)
+					err(MyLocale.getMsg(1708, &quot;Ambiguous function name: &quot;) + str);
+				fnd = functions[i];
+			}
+		}
+		if (fnd == null)
+			err(MyLocale.getMsg(1709, &quot;Unknown function: &quot;) + str);
+		return fnd;
+	}
 
-///////////////////////////////////////////
-//  FUNCTIONS
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// FUNCTIONS
+	// /////////////////////////////////////////
 
 	/** If we are in DEGree mode, convert the argument to RADiants, if not leave it unchanged */
 	private double makeRadiant(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg*java.lang.Math.PI/180.0;
+			return arg * java.lang.Math.PI / 180.0;
 		else
 			return arg;
 	}
@@ -407,30 +372,33 @@
 	/** If we are in DEGree mode, convert the argument to degrees */
 	private double makeDegree(double arg) {
 		if (Global.getPref().solverDegMode)
-			return arg/java.lang.Math.PI*180.0;
+			return arg / java.lang.Math.PI * 180.0;
 		else
 			return arg;
 	}
 
-    /** Calculate brearing from one point to the next */
-    private double funcBearing() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
- 		if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
-	   	cwPt.set(coordA);
-	   	double angleDeg=cwPt.getBearing(new CWPoint(coordB));
-	   	// getBearing returns a result in degrees
-	   	return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI/180.0;
-    }
+	/** Calculate brearing from one point to the next */
+	private double funcBearing() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordB);
+		cwPt.set(coordA);
+		double angleDeg = cwPt.getBearing(new CWPoint(coordB));
+		// getBearing returns a result in degrees
+		return Global.getPref().solverDegMode ? angleDeg : angleDeg * java.lang.Math.PI / 180.0;
+	}
 
-    /** Get or set the current centre */
+	/** Get or set the current centre */
 	private void funcCenter(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getPref().getCurCentrePt().toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
 			Global.getPref().setCurCentrePt(new CWPoint(coordA));
 		}
 	}
@@ -442,218 +410,246 @@
 	}
 
 	private int funcCountChar(String s, char c) {
-    	int count=0;
-    	for (int i=0; i&lt;s.length(); i++)
-    		if (s.charAt(i)==c) count++;
-    	return count;
-    }
+		int count = 0;
+		for (int i = 0; i &lt; s.length(); i++)
+			if (s.charAt(i) == c)
+				count++;
+		return count;
+	}
 
-    /** count(string1,string2)
-     * */
-    private void funcCount()throws Exception {
-       	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	if (s2.length()==0) err(MyLocale.getMsg(1710,&quot;Cannot count empty string&quot;));
-    	if (s2.length()==1) {
-    		calcStack.add(new Double(funcCountChar(s1,s2.charAt(0))));
-    	} else {
-    		String res=&quot;&quot;;
-    		for(int i=0; i&lt;s2.length(); i++) {
-    			res+=s2.charAt(i)+&quot;=&quot;+funcCountChar(s1,s2.charAt(i))+&quot; &quot;;
-    		}
-    		calcStack.add(res);
-    	}
-    }
+	/**
+	 * count(string1,string2)
+	 * */
+	private void funcCount() throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		if (s2.length() == 0)
+			err(MyLocale.getMsg(1710, &quot;Cannot count empty string&quot;));
+		if (s2.length() == 1) {
+			calcStack.add(new Double(funcCountChar(s1, s2.charAt(0))));
+		} else {
+			String res = &quot;&quot;;
+			for (int i = 0; i &lt; s2.length(); i++) {
+				res += s2.charAt(i) + &quot;=&quot; + funcCountChar(s1, s2.charAt(i)) + &quot; &quot;;
+			}
+			calcStack.add(res);
+		}
+	}
 
-    private String funcCp(){
-    	return Global.mainTab.nav.gpsPos.toString();
-    }
+	private String funcCp() {
+		return Global.mainTab.nav.gpsPos.toString();
+	}
 
-    /**
-     *  Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
-     *  Warning: When the number is non-integer or &gt; 9223372036854775807, it is formatted using the E
-     *  notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
-     */
-    private double funcCrossTotal(int nargs) throws Exception {
-    	int cycles=1;
-		if (nargs==2) cycles=(int)popCalcStackAsNumber(1);
-		String aString=popCalcStackAsString().replace('-','0').trim();
-		double a=0;
-		if (cycles&lt;0) cycles=1;
-    	if (cycles&gt;5) cycles=5;
-    	while (cycles--&gt;0) {
-	    	// Cross total = Quersumme berechnen
-			a=0;
-			for (int i=0; i&lt;aString.length(); i++) {
-			   if (aString.charAt(i)&gt;='0' &amp;&amp; aString.charAt(i)&lt;='9')
-			      a += aString.charAt(i)-'0';
+	/**
+	 * Crosstotal: Works for both strings and numbers. For strings any non-numeric character is ignored
+	 * Warning: When the number is non-integer or &gt; 9223372036854775807, it is formatted using the E
+	 * notation, i.e. x.xxxxxxEyy. In this case the exponent yy is also included in the crosstotal
+	 */
+	private double funcCrossTotal(int nargs) throws Exception {
+		int cycles = 1;
+		if (nargs == 2)
+			cycles = (int) popCalcStackAsNumber(1);
+		String aString = popCalcStackAsString().replace('-', '0').trim();
+		double a = 0;
+		if (cycles &lt; 0)
+			cycles = 1;
+		if (cycles &gt; 5)
+			cycles = 5;
+		while (cycles-- &gt; 0) {
+			// Cross total = Quersumme berechnen
+			a = 0;
+			for (int i = 0; i &lt; aString.length(); i++) {
+				if (aString.charAt(i) &gt;= '0' &amp;&amp; aString.charAt(i) &lt;= '9')
+					a += aString.charAt(i) - '0';
 			}
-			aString=Convert.toString(a);
-    	}
-    	return a;
-    }
+			aString = Convert.toString(a);
+		}
+		return a;
+	}
 
-    private void funcDeg(boolean arg) {
-    	Global.getPref().solverDegMode=arg;
-    	Global.mainTab.solverP.showSolverMode();
-    }
+	private void funcDeg(boolean arg) {
+		Global.getPref().solverDegMode = arg;
+		Global.mainTab.solverP.showSolverMode();
+	}
 
-    /** Convert degrees into Radiants */
-    private double funcDeg2Rad() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a/180.0*java.lang.Math.PI;
-    }
+	/** Convert degrees into Radiants */
+	private double funcDeg2Rad() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a / 180.0 * java.lang.Math.PI;
+	}
 
-    	/** Calculate distance between 2 points */
-    private double funcDistance() throws Exception {
-    	String coordB=popCalcStackAsString();
-    	String coordA=popCalcStackAsString();
-    	double result = 0;
+	/** Calculate distance between 2 points */
+	private double funcDistance() throws Exception {
+		String coordB = popCalcStackAsString();
+		String coordA = popCalcStackAsString();
+		double result = 0;
 		// Attention: isValidCoord has sideeffect of setting cwPt
-    	if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
-		if (!isValidCoord(coordB)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordB);
-    	cwPt.set(coordA);
-    	double distKM = cwPt.getDistance(new CWPoint(coordB));
-    	result = distKM*1000.0;
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
-    	}
-    	return result;
-    }
+		if (!isValidCoord(coordA))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
+		if (!isValidCoord(coordB))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordB);
+		cwPt.set(coordA);
+		double distKM = cwPt.getDistance(new CWPoint(coordB));
+		result = distKM * 1000.0;
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			result = Metrics.convertUnit(distKM, Metrics.KILOMETER, Metrics.YARDS);
+		}
+		return result;
+	}
 
-    /**
-     * Encode a string by replacing all characters in a string with their corresponding characters in
-     * another string
-     * @throws Exception
-     */
-    private String funcEncode() throws Exception {
-    	String newChars=popCalcStackAsString();
-    	String oldChars=popCalcStackAsString();
-    	if (newChars.length()!=oldChars.length()) err(MyLocale.getMsg(1711,&quot;Replacement characters strings must be of equal length&quot;));
-    	String s=popCalcStackAsString();
-    	String encodedStr=&quot;&quot;;
-    	for (int i=0; i&lt;s.length(); i++) {
-    		int pos;
-    		if ((pos=oldChars.indexOf(s.charAt(i)))!=-1) {
-    			encodedStr+=newChars.charAt(pos);
-    		} else
-    			encodedStr+=s.charAt(i);
-    	}
-    	 return encodedStr;
-    }
+	/**
+	 * Encode a string by replacing all characters in a string with their corresponding characters in
+	 * another string
+	 * 
+	 * @throws Exception
+	 */
+	private String funcEncode() throws Exception {
+		String newChars = popCalcStackAsString();
+		String oldChars = popCalcStackAsString();
+		if (newChars.length() != oldChars.length())
+			err(MyLocale.getMsg(1711, &quot;Replacement characters strings must be of equal length&quot;));
+		String s = popCalcStackAsString();
+		String encodedStr = &quot;&quot;;
+		for (int i = 0; i &lt; s.length(); i++) {
+			int pos;
+			if ((pos = oldChars.indexOf(s.charAt(i))) != -1) {
+				encodedStr += newChars.charAt(pos);
+			} else
+				encodedStr += s.charAt(i);
+		}
+		return encodedStr;
+	}
 
-    /** Format a valid coordinate
-     *  If called with one args, format the argument on the stack to CW standard
-     *  The optional second argument is one of these strings &quot;UTM&quot;,&quot;DMS&quot;,&quot;DD&quot;,&quot;DMM&quot; or &quot;CW&quot;
-     * @param nargs 1 or 2 args
-     */
-    private String funcFormat(int nargs) throws Exception {
-    	int spart=0;
-    	if (nargs==3) spart=(int) popCalcStackAsNumber(0);
-    	String fmtStr=&quot;&quot;;
-    	if (nargs&gt;=2)fmtStr=popCalcStackAsString().toLowerCase();
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
-    	cwPt.set(coord);
-    	int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
-    	if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED) err(MyLocale.getMsg(1713,&quot;Invalid coordinate format. Allowed are cw / dd / dmm / dms / &quot;) + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), &quot; / &quot;));
-    	String ret = cwPt.toString(fmt);
-    	if (nargs==3){
-    		String[] parts=mString.split(ret, ' ');
-    		if (spart&gt;0 &amp;&amp; parts.length&gt;=spart)
-    		ret = parts[spart-1];
-    		else err(&quot;Param 3 !!! &quot;+MyLocale.getMsg(1713,&quot;Invalid coordinate format.&quot;));
-    	}
-    	return ret;
-    }
+	/**
+	 * Format a valid coordinate
+	 * If called with one args, format the argument on the stack to CW standard
+	 * The optional second argument is one of these strings &quot;UTM&quot;,&quot;DMS&quot;,&quot;DD&quot;,&quot;DMM&quot; or &quot;CW&quot;
+	 * 
+	 * @param nargs
+	 *            1 or 2 args
+	 */
+	private String funcFormat(int nargs) throws Exception {
+		int spart = 0;
+		if (nargs == 3)
+			spart = (int) popCalcStackAsNumber(0);
+		String fmtStr = &quot;&quot;;
+		if (nargs &gt;= 2)
+			fmtStr = popCalcStackAsString().toLowerCase();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
+		cwPt.set(coord);
+		int fmt = TransformCoordinates.getLocalSystemCode(fmtStr);
+		if (fmt == TransformCoordinates.LOCALSYSTEM_NOT_SUPPORTED)
+			err(MyLocale.getMsg(1713, &quot;Invalid coordinate format. Allowed are cw / dd / dmm / dms / &quot;) + Common.arrayToString(TransformCoordinates.getProjectedSystemIDs(), &quot; / &quot;));
+		String ret = cwPt.toString(fmt);
+		if (nargs == 3) {
+			String[] parts = mString.split(ret, ' ');
+			if (spart &gt; 0 &amp;&amp; parts.length &gt;= spart)
+				ret = parts[spart - 1];
+			else
+				err(&quot;Param 3 !!! &quot; + MyLocale.getMsg(1713, &quot;Invalid coordinate format.&quot;));
+		}
+		return ret;
+	}
 
-    /** Implements a goto command goto(coordinate,optionalWaypointName).
-     */
-    private void funcGoto(int nargs) throws Exception {
-    	Navigate nav=Global.mainTab.nav;
-		String waypointName=null;
-        if (nargs==2) waypointName=popCalcStackAsString();
-		String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+	/**
+	 * Implements a goto command goto(coordinate,optionalWaypointName).
+	 */
+	private void funcGoto(int nargs) throws Exception {
+		Navigate nav = Global.mainTab.nav;
+		String waypointName = null;
+		if (nargs == 2)
+			waypointName = popCalcStackAsString();
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
 		// Don't want to switch to goto panel, just set the values
 		nav.setDestination(coord);
-		if (nargs==2) { // Now set the value of the addi waypoint (it must exist already)
-    		cwPt.set(coord);
-    		CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-    		if (ch == null) {
-    			err(MyLocale.getMsg(1714,&quot;Goto: Waypoint does not exist: &quot;)+waypointName);
-    			return;
-    		}
-    		ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-    		ch.pos.set(cwPt);
-    		ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
-    		nav.setDestination(ch);
-    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-    	}
-    }
+		if (nargs == 2) { // Now set the value of the addi waypoint (it must exist already)
+			cwPt.set(coord);
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, &quot;Goto: Waypoint does not exist: &quot;) + waypointName);
+				return;
+			}
+			ch.setPos(cwPt);
+			ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance/bearing
+			nav.setDestination(ch);
+			Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+		}
+	}
 
-    /** Display or change the case sensitivity of variable names */
-    private void funcIgnoreVariableCase(int nargs) throws Exception {
-    	if (nargs==0)
-    		calcStack.add(&quot;&quot;+Global.getPref().solverIgnoreCase);
-    	else {
-    		Global.getPref().solverIgnoreCase=(popCalcStackAsNumber(0)!=0)?true:false;
-    	}
-    }
+	/** Display or change the case sensitivity of variable names */
+	private void funcIgnoreVariableCase(int nargs) throws Exception {
+		if (nargs == 0)
+			calcStack.add(&quot;&quot; + Global.getPref().solverIgnoreCase);
+		else {
+			Global.getPref().solverIgnoreCase = (popCalcStackAsNumber(0) != 0) ? true : false;
+		}
+	}
 
-    /** VB instr function
-     * instr([start],string1,string2)
-     * */
-    private int funcInstr(int nargs) throws Exception {
-    	String s2=popCalcStackAsString();
-    	String s1=popCalcStackAsString();
-    	int start=1;
-    	if (nargs==3) start=(int) popCalcStackAsNumber(1);
-    	if (start&gt;s1.length()) err(MyLocale.getMsg(1715,&quot;instr: Start position not in string&quot;));
-    	if(s2.equals(&quot;&quot;)) {
-    		if (s1.equals(&quot;&quot;))
-    			return 0;
-    		else
-    			return 1;
-    	}
-    	return s1.indexOf(s2,start-1)+1;
-    }
+	/**
+	 * VB instr function
+	 * instr([start],string1,string2)
+	 * */
+	private int funcInstr(int nargs) throws Exception {
+		String s2 = popCalcStackAsString();
+		String s1 = popCalcStackAsString();
+		int start = 1;
+		if (nargs == 3)
+			start = (int) popCalcStackAsNumber(1);
+		if (start &gt; s1.length())
+			err(MyLocale.getMsg(1715, &quot;instr: Start position not in string&quot;));
+		if (s2.equals(&quot;&quot;)) {
+			if (s1.equals(&quot;&quot;))
+				return 0;
+			else
+				return 1;
+		}
+		return s1.indexOf(s2, start - 1) + 1;
+	}
 
-    /** MID function as in Basic */
-    private String funcMid(int nargs) throws Exception {
-    	if (nargs==2) {
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
-    		if (start&lt;1 || start&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
-    		return s.substring((int)start-1);
-    	} else {
-        	double len=popCalcStackAsNumber(0);
-        	double start=popCalcStackAsNumber(0);
-    		String s=popCalcStackAsString();
-    		if (!isInteger(start) || !isInteger(len)) err(MyLocale.getMsg(1716,&quot;mid: Integer argument expected&quot;));
-    		int end=(int)(start+len-1);
-    		if (start&gt;s.length() || start&lt;1 || end&gt;s.length()) err(MyLocale.getMsg(1717,&quot;mid: Argument out of range&quot;));
-    		return s.substring((int)start-1,end);
-    	}
-    }
+	/** MID function as in Basic */
+	private String funcMid(int nargs) throws Exception {
+		if (nargs == 2) {
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start))
+				err(MyLocale.getMsg(1716, &quot;mid: Integer argument expected&quot;));
+			if (start &lt; 1 || start &gt; s.length())
+				err(MyLocale.getMsg(1717, &quot;mid: Argument out of range&quot;));
+			return s.substring((int) start - 1);
+		} else {
+			double len = popCalcStackAsNumber(0);
+			double start = popCalcStackAsNumber(0);
+			String s = popCalcStackAsString();
+			if (!isInteger(start) || !isInteger(len))
+				err(MyLocale.getMsg(1716, &quot;mid: Integer argument expected&quot;));
+			int end = (int) (start + len - 1);
+			if (start &gt; s.length() || start &lt; 1 || end &gt; s.length())
+				err(MyLocale.getMsg(1717, &quot;mid: Argument out of range&quot;));
+			return s.substring((int) start - 1, end);
+		}
+	}
 
-    /** MOD function as in Basic */
-    private Double funcMod() throws Exception {
-    	double b=popCalcStackAsNumber(0);
-    	double a=popCalcStackAsNumber(0);
-		if (b==0.0)
-			err(MyLocale.getMsg(1729,&quot;Division by 0&quot;));
+	/** MOD function as in Basic */
+	private Double funcMod() throws Exception {
+		double b = popCalcStackAsNumber(0);
+		double a = popCalcStackAsNumber(0);
+		if (b == 0.0)
+			err(MyLocale.getMsg(1729, &quot;Division by 0&quot;));
 		return new java.lang.Double(a % b);
-    }
+	}
 
 	/** Get or set the profile centre */
 	private void funcPz(int nargs) throws Exception {
-		if (nargs==0) {
+		if (nargs == 0) {
 			calcStack.add(Global.getProfile().centre.toString());
 		} else {
-	    	String coordA=popCalcStackAsString();
-			if (!isValidCoord(coordA)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordA);
+			String coordA = popCalcStackAsString();
+			if (!isValidCoord(coordA))
+				err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordA);
 			Global.getProfile().centre.set(coordA);
 		}
 	}
@@ -662,266 +658,281 @@
 	 * Calculates the crossbearing from point1 with bearing 1 and point2 with bearing2
 	 * point1 and point 2 must be different.
 	 * Not very well tested. No guarantee for correct result if any of the distance is greater than 300 kilometers and / or any of the angles in the spherical triangle id greater then 90degrees
+	 * 
 	 * @return
 	 * @throws Exception
 	 */
-	private String funcCrossBearing () throws Exception{
-		//parameters come in reversed order!
+	private String funcCrossBearing() throws Exception {
+		// parameters come in reversed order!
 		double degrees2 = popCalcStackAsNumber(-1);
 		String coordinates2 = popCalcStackAsString();
 		double degrees1 = popCalcStackAsNumber(-1);
 		String coordinates1 = popCalcStackAsString();
-		if (!isValidCoord(coordinates1)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordinates1);
- 		if (!isValidCoord(coordinates2)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coordinates2);
+		if (!isValidCoord(coordinates1))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordinates1);
+		if (!isValidCoord(coordinates2))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coordinates2);
 
-		//Check parameters: Range
-    	if (degrees1&lt;0 || degrees1&gt;360 || degrees2 &lt; 0 || degrees2 &gt; 360){
-    		if (Global.getPref().solverDegMode){
-    			err(MyLocale.getMsg(1740,&quot;Crossbearing degrees must be in interval [0;360]&quot;));
-    		}
-    		else{
-    			err(MyLocale.getMsg(1741,&quot;Crossbearing degrees must be in interval [0;2*PI]&quot;));
-    		}
-    	}
-    	double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0
-				* java.lang.Math.PI : degrees1;
-		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0
-				* java.lang.Math.PI : degrees2;
+		// Check parameters: Range
+		if (degrees1 &lt; 0 || degrees1 &gt; 360 || degrees2 &lt; 0 || degrees2 &gt; 360) {
+			if (Global.getPref().solverDegMode) {
+				err(MyLocale.getMsg(1740, &quot;Crossbearing degrees must be in interval [0;360]&quot;));
+			} else {
+				err(MyLocale.getMsg(1741, &quot;Crossbearing degrees must be in interval [0;2*PI]&quot;));
+			}
+		}
+		double rAN = Global.getPref().solverDegMode ? degrees1 / 180.0 * java.lang.Math.PI : degrees1;
+		double rBN = Global.getPref().solverDegMode ? degrees2 / 180.0 * java.lang.Math.PI : degrees2;
 
-		CWPoint point1=new CWPoint(coordinates1);
-		CWPoint point2=new CWPoint(coordinates2);
+		CWPoint point1 = new CWPoint(coordinates1);
+		CWPoint point2 = new CWPoint(coordinates2);
 
-    	//check Parameters: bearings to project must be different from the bearing between point1 and point2
-    	if (degrees1 == degrees2){
-    		double bearing1 = point1.getBearing(point2);
-    		double bearing2 = point1.getBearing(point1);
-    		if (bearing1 == degrees1 || bearing2 == degrees2){
-    			err(MyLocale.getMsg(1740,&quot;Invalid crossbearing angles&quot;));
-    		}
-    	}
+		// check Parameters: bearings to project must be different from the bearing between point1 and point2
+		if (degrees1 == degrees2) {
+			double bearing1 = point1.getBearing(point2);
+			double bearing2 = point1.getBearing(point1);
+			if (bearing1 == degrees1 || bearing2 == degrees2) {
+				err(MyLocale.getMsg(1740, &quot;Invalid crossbearing angles&quot;));
+			}
+		}
 
 		CWPoint result2 = crossbearingCalculation(point1, point2, rAN, rBN);
 		return result2.toString();
 	}
 
 	private CWPoint crossbearingCalculation(CWPoint point1, CWPoint point2, double rAN, double rBN) throws Exception {
-		//see german wikipedia keyword vorwaertsschnitt for the calculation.
-		//peilung von a-&gt;b
-		//Yes we will make an error, therefore we have to calculate the target-point iteratively.
-		//Testcode for crossbearing:
+		// see german wikipedia keyword vorwaertsschnitt for the calculation.
+		// peilung von a-&gt;b
+		// Yes we will make an error, therefore we have to calculate the target-point iteratively.
+		// Testcode for crossbearing:
 		// MP=&quot;S35 47.100 W089 43.200&quot; # MP is centre of circle, could be any waypoint
 		// A=project(MP,0,1000); B=project(MP,120,1000) # Points of equilateral triangle on circle
 		// C1=project(MP,240,1000); C2=cb(A,210 ,B,270)
-		//	C1 &quot;=&quot; C2
+		// C1 &quot;=&quot; C2
 		final int maxRadius = 6378;
-    	double distance = point1.getDistance(point2);
-    	if (Math.abs (distance) &lt;= 0.0000000001){
-    		err (MyLocale.getMsg(1742,&quot;Crossbearing: distance between points to small&quot;));
-    	}
-    	double distanceInRad = distance / maxRadius;
-	    double phiAB = point1.getBearing(point2);
-	    if (Global.getPref().solverDegMode) phiAB=phiAB / 180.0 * java.lang.Math.PI;
-	    double phiBA = point2.getBearing(point1);
-	    if (Global.getPref().solverDegMode) phiBA=phiBA / 180.0 * java.lang.Math.PI;
+		double distance = point1.getDistance(point2);
+		if (Math.abs(distance) &lt;= 0.0000000001) {
+			err(MyLocale.getMsg(1742, &quot;Crossbearing: distance between points to small&quot;));
+		}
+		double distanceInRad = distance / maxRadius;
+		double phiAB = point1.getBearing(point2);
+		if (Global.getPref().solverDegMode)
+			phiAB = phiAB / 180.0 * java.lang.Math.PI;
+		double phiBA = point2.getBearing(point1);
+		if (Global.getPref().solverDegMode)
+			phiBA = phiBA / 180.0 * java.lang.Math.PI;
 
-	    double psi = phiAB - rAN;
-	    double phi = rBN - phiBA;
+		double psi = phiAB - rAN;
+		double phi = rBN - phiBA;
 
-	    //calculate projetiondistance
-	    double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi+psi);
-	    double b = bInRad * maxRadius ;//* (1-flattening);
-	    double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi+psi);
-	    double a = aInRad * maxRadius ;//* (1-flattening);
-	    double phiAN = phiAB - psi;
-	    double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
-	    double phiBN = phiBA + phi;
-	    double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
-	    CWPoint result2 = point2.project(phiBNDegrees, a);
-	    CWPoint result = point1.project(phiANDegrees, b);
-	    double errorDistance = result.getDistance(result2);
-	    //if the distance between the points is to large, we will restart the calculation with the new points found.
-	    //since the error is mostly very small these iterations are seldom used and the needed depth is very low.
-	    //First we will make sure, that this calculation will terminate
-	    if (distance &lt; errorDistance){
-    		err (MyLocale.getMsg(1743,&quot;Crossbearing calculation failed. Please inform the developers at geoclub.de&quot;));
-	    }
-	    if (errorDistance * 1000 &gt; 1){
-	    	return crossbearingCalculation(result, result2, rAN, rBN);
-	    }
+		// calculate projetiondistance
+		double bInRad = distanceInRad * java.lang.Math.sin(phi) / java.lang.Math.sin(phi + psi);
+		double b = bInRad * maxRadius;// * (1-flattening);
+		double aInRad = distanceInRad * java.lang.Math.sin(psi) / java.lang.Math.sin(phi + psi);
+		double a = aInRad * maxRadius;// * (1-flattening);
+		double phiAN = phiAB - psi;
+		double phiANDegrees = phiAN * 180.0 / java.lang.Math.PI;
+		double phiBN = phiBA + phi;
+		double phiBNDegrees = phiBN * 180.0 / java.lang.Math.PI;
+		CWPoint result2 = point2.project(phiBNDegrees, a);
+		CWPoint result = point1.project(phiANDegrees, b);
+		double errorDistance = result.getDistance(result2);
+		// if the distance between the points is to large, we will restart the calculation with the new points found.
+		// since the error is mostly very small these iterations are seldom used and the needed depth is very low.
+		// First we will make sure, that this calculation will terminate
+		if (distance &lt; errorDistance) {
+			err(MyLocale.getMsg(1743, &quot;Crossbearing calculation failed. Please inform the developers at geoclub.de&quot;));
+		}
+		if (errorDistance * 1000 &gt; 1) {
+			return crossbearingCalculation(result, result2, rAN, rBN);
+		}
 		return result2;
 	}
 
-    /** Project a waypoint at some angle and some distance */
-    private String funcProject() throws Exception {
-    	double distance=popCalcStackAsNumber(0);
-    	if (distance&lt;0) err(MyLocale.getMsg(1718,&quot;Cannot project a negative distance&quot;));
-    	double degrees=popCalcStackAsNumber(0);
-    	// If we are not in degree mode, arg is in radiants ==&gt; convert it
-    	if (!Global.getPref().solverDegMode) degrees=degrees * 180.0 / java.lang.Math.PI;
-    	if (degrees&lt;0 || degrees&gt;360)
-    		if (Global.getPref().solverDegMode)
-    			err(MyLocale.getMsg(1719,&quot;Projection degrees must be in interval [0;360]&quot;));
-    		else
-    			err(MyLocale.getMsg(1739,&quot;Projection degrees must be in interval [0;2*PI]&quot;));
-    	String coord=popCalcStackAsString();
-		if (!isValidCoord(coord)) err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
-    	cwPt.set(coord);
-    	if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
-    		distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
-    	} else {
-    		distance = distance / 1000.0;
-    	}
-    	return cwPt.project(degrees,distance).toString();
-    }
+	/** Project a waypoint at some angle and some distance */
+	private String funcProject() throws Exception {
+		double distance = popCalcStackAsNumber(0);
+		if (distance &lt; 0)
+			err(MyLocale.getMsg(1718, &quot;Cannot project a negative distance&quot;));
+		double degrees = popCalcStackAsNumber(0);
+		// If we are not in degree mode, arg is in radiants ==&gt; convert it
+		if (!Global.getPref().solverDegMode)
+			degrees = degrees * 180.0 / java.lang.Math.PI;
+		if (degrees &lt; 0 || degrees &gt; 360)
+			if (Global.getPref().solverDegMode)
+				err(MyLocale.getMsg(1719, &quot;Projection degrees must be in interval [0;360]&quot;));
+			else
+				err(MyLocale.getMsg(1739, &quot;Projection degrees must be in interval [0;2*PI]&quot;));
+		String coord = popCalcStackAsString();
+		if (!isValidCoord(coord))
+			err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
+		cwPt.set(coord);
+		if (Global.getPref().metricSystem == Metrics.IMPERIAL) {
+			distance = Metrics.convertUnit(distance, Metrics.YARDS, Metrics.KILOMETER);
+		} else {
+			distance = distance / 1000.0;
+		}
+		return cwPt.project(degrees, distance).toString();
+	}
 
-    /** Convert Radiants into degrees */
-    private double funcRad2Deg() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	return a*180.0/java.lang.Math.PI;
-    }
+	/** Convert Radiants into degrees */
+	private double funcRad2Deg() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		return a * 180.0 / java.lang.Math.PI;
+	}
 
-    /** Replace all occurrences of a string with another string */
-    private String funcReplace() throws Exception {
-    	String replaceWith=popCalcStackAsString();
-    	String whatToReplace=popCalcStackAsString();
-    	String s=popCalcStackAsString();
-        if (whatToReplace.equals(&quot;&quot;)) return s;
-        return STRreplace.replace(s,whatToReplace,replaceWith);
-    }
+	/** Replace all occurrences of a string with another string */
+	private String funcReplace() throws Exception {
+		String replaceWith = popCalcStackAsString();
+		String whatToReplace = popCalcStackAsString();
+		String s = popCalcStackAsString();
+		if (whatToReplace.equals(&quot;&quot;))
+			return s;
+		return STRreplace.replace(s, whatToReplace, replaceWith);
+	}
 
-    /** Reverse a string */
-    private String funcReverse(String s) {
-    	String res=&quot;&quot;;
-    	for (int i=s.length()-1; i&gt;=0; i--) res+=s.charAt(i);
-    	return res;
-    }
+	/** Reverse a string */
+	private String funcReverse(String s) {
+		String res = &quot;&quot;;
+		for (int i = s.length() - 1; i &gt;= 0; i--)
+			res += s.charAt(i);
+		return res;
+	}
 
-    /** Create a skeleton for multis. This function can be called in three ways:&lt;br&gt;
-     *  &lt;pre&gt;sk()                Create skeleton for current cache (must have addi wpts)
-     *  sk(number)          Create skeleton for number variables
-     */
-    private void funcSkeleton(int nargs) throws Exception {
-   		String waypointName=Global.mainTab.lastselected;
-    	CacheHolder c=Global.getProfile().cacheDB.get(waypointName);
-    	if (c == null) return;
-    	// If it is an addi, find its main cache
-    	if (c.isAddiWpt()) {
-    		waypointName=c.mainCache.getWayPoint();
-    	}
-   		int nStages=-1;
-    	if (nargs==1) {
-    		nStages=(int)popCalcStackAsNumber(-1.0);
-    	}
-    	// Remove the sk command from the instructions
-    	Regex rex=new Regex(&quot;sk\\(.*?\\)&quot;,&quot;&quot;);
-    	Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
-		StringBuffer op=new StringBuffer(1000);
-    	// Check for sk(number)
-    	if (nStages&gt;0 &amp;&amp; nStages&lt;30) { // e.g. sk(3)
-			/*IF $01xxxx=&quot;&quot; THEN
-			   $01xxxx=&quot;&quot;
-			   &quot;Station 1 = &quot; $01xxxx
-			   goto($01xxxx); STOP
-			ENDIF*/
-			boolean didCreateWp=false;
-    		for (int i=0; i&lt;nStages; i++) {
-				String stage=MyLocale.formatLong(i,&quot;00&quot;);
-				String stageWpt=&quot;$&quot;+stage+waypointName.substring(2);
-				String stageName = &quot;Stage &quot;+(i+1);
+	/**
+	 * Create a skeleton for multis. This function can be called in three ways:&lt;br&gt;
+	 * 
+	 * &lt;pre&gt;
+	 * sk()                Create skeleton for current cache (must have addi wpts)
+	 * sk(number)          Create skeleton for number variables
+	 */
+	private void funcSkeleton(int nargs) throws Exception {
+		String waypointName = Global.mainTab.lastselected;
+		CacheHolder c = Global.getProfile().cacheDB.get(waypointName);
+		if (c == null)
+			return;
+		// If it is an addi, find its main cache
+		if (c.isAddiWpt()) {
+			waypointName = c.mainCache.getWayPoint();
+		}
+		int nStages = -1;
+		if (nargs == 1) {
+			nStages = (int) popCalcStackAsNumber(-1.0);
+		}
+		// Remove the sk command from the instructions
+		Regex rex = new Regex(&quot;sk\\(.*?\\)&quot;, &quot;&quot;);
+		Global.mainTab.solverP.mText.setText(rex.replaceFirst(Global.mainTab.solverP.mText.getText()));
+		StringBuffer op = new StringBuffer(1000);
+		// Check for sk(number)
+		if (nStages &gt; 0 &amp;&amp; nStages &lt; 30) { // e.g. sk(3)
+			/*
+			 * IF $01xxxx=&quot;&quot; THEN
+			 * $01xxxx=&quot;&quot;
+			 * &quot;Station 1 = &quot; $01xxxx
+			 * goto($01xxxx); STOP
+			 * ENDIF
+			 */
+			boolean didCreateWp = false;
+			for (int i = 0; i &lt; nStages; i++) {
+				String stage = MyLocale.formatLong(i, &quot;00&quot;);
+				String stageWpt = &quot;$&quot; + stage + waypointName.substring(2);
+				String stageName = &quot;Stage &quot; + (i + 1);
 				byte type = CacheType.CW_TYPE_STAGE;
 				if (i == nStages - 1) {
 					stageName = &quot;Final&quot;;
 					type = CacheType.CW_TYPE_FINAL;
 				}
-				didCreateWp|=createWptIfNeeded(stage+waypointName.substring(2), stageName, type);
-				op.append(&quot;IF &quot;+stageWpt+&quot;=\&quot;\&quot; THEN\n&quot;);
-				op.append(&quot;  &quot;+stageWpt+&quot; = \&quot;\&quot;\n&quot;);
-				op.append(&quot;  \&quot;&quot;+stageName+&quot; = \&quot; &quot;+stageWpt+&quot;\n&quot;);
-				op.append(&quot;  goto(&quot;+stageWpt+&quot;); STOP\n&quot;);
+				didCreateWp |= createWptIfNeeded(stage + waypointName.substring(2), stageName, type);
+				op.append(&quot;IF &quot; + stageWpt + &quot;=\&quot;\&quot; THEN\n&quot;);
+				op.append(&quot;  &quot; + stageWpt + &quot; = \&quot;\&quot;\n&quot;);
+				op.append(&quot;  \&quot;&quot; + stageName + &quot; = \&quot; &quot; + stageWpt + &quot;\n&quot;);
+				op.append(&quot;  goto(&quot; + stageWpt + &quot;); STOP\n&quot;);
 				op.append(&quot;ENDIF\n&quot;);
 			}
-			Global.mainTab.solverP.mText.appendText(op.toString(),true);
+			Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			if (didCreateWp) {
-		    	Global.mainTab.updatePendingChanges();
+				Global.mainTab.updatePendingChanges();
 				Global.mainTab.tbP.refreshTable();
 			}
-    	} else {
-	   	    CacheHolder ch=Global.getProfile().cacheDB.get(waypointName);
-	   	    if (ch == null) {
-	   	    	err(MyLocale.getMsg(1714,&quot;Goto: Waypoint does not exist: &quot;)+waypointName);
-	   	    	return;
-	   	    }
+		} else {
+			CacheHolder ch = Global.getProfile().cacheDB.get(waypointName);
+			if (ch == null) {
+				err(MyLocale.getMsg(1714, &quot;Goto: Waypoint does not exist: &quot;) + waypointName);
+				return;
+			}
 			CacheHolder addiWpt;
-	   	    if (ch.hasAddiWpt()){
-	   	    	op.append(&quot;cls()\n&quot;);
-				for (int j=0; j&lt;ch.addiWpts.getCount();j++){
-					addiWpt = (CacheHolder)ch.addiWpts.get(j);
+			if (ch.hasAddiWpt()) {
+				op.append(&quot;cls()\n&quot;);
+				for (int j = 0; j &lt; ch.addiWpts.getCount(); j++) {
+					addiWpt = (CacheHolder) ch.addiWpts.get(j);
 					op.append(&quot;IF $&quot;);
 					op.append(addiWpt.getWayPoint());
 					op.append(&quot;=\&quot;\&quot; THEN\n   $&quot;);
 					op.append(addiWpt.getWayPoint());
 					op.append(&quot;=\&quot;\&quot;&quot;);
-					//op.append(addiWpt.pos.toString());
+					// op.append(addiWpt.pos.toString());
 					op.append(&quot;\n   \&quot;Punkt &quot;);
-					op.append(addiWpt.getWayPoint().substring(0,2));
+					op.append(addiWpt.getWayPoint().substring(0, 2));
 					op.append(&quot; [&quot;);
 					op.append(addiWpt.getCacheName());
 					op.append(&quot;] = \&quot; $&quot;);
 					op.append(addiWpt.getWayPoint());
-					if (addiWpt.getCacheDetails(true).LongDescription.trim().length()&gt;0)
-						op.append(&quot;\n   \&quot;&quot;+STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription,&quot;\&quot;&quot;,&quot;\&quot;\&quot;&quot;)+&quot;\&quot;&quot;);
+					if (addiWpt.getCacheDetails(true).LongDescription.trim().length() &gt; 0)
+						op.append(&quot;\n   \&quot;&quot; + STRreplace.replace(addiWpt.getCacheDetails(true).LongDescription, &quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;) + &quot;\&quot;&quot;);
 					op.append(&quot;\n   goto($&quot;);
 					op.append(addiWpt.getWayPoint());
 					op.append(&quot;); STOP\nENDIF\n\n&quot;);
 				}
-				Global.mainTab.solverP.mText.appendText(op.toString(),true);
+				Global.mainTab.solverP.mText.appendText(op.toString(), true);
 			}// if hasAddiWpt
-    	}
-    }
+		}
+	}
 
-    private double funcSqrt() throws Exception {
-    	double a=popCalcStackAsNumber(0);
-    	if (a&lt;0) err(MyLocale.getMsg(1720,&quot;Cannot calculate square root of a negative number&quot;));
-    	return java.lang.Math.sqrt(a);
-    }
+	private double funcSqrt() throws Exception {
+		double a = popCalcStackAsNumber(0);
+		if (a &lt; 0)
+			err(MyLocale.getMsg(1720, &quot;Cannot calculate square root of a negative number&quot;));
+		return java.lang.Math.sqrt(a);
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and put result into a string */
-    private String funcSval(String s) {
-       	s=s.toLowerCase();
-    	String res=&quot;&quot;;
-       	for (int i=0; i&lt;s.length(); i++) {
-    		int pos=&quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i));
-    		if (pos&gt;=0)
-    			res+=(res==&quot;&quot;?&quot;&quot;:&quot; &quot;)+MyLocale.formatLong(pos+1,&quot;00&quot;);
-    	}
-    	return res;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and put result into a string */
+	private String funcSval(String s) {
+		s = s.toLowerCase();
+		String res = &quot;&quot;;
+		for (int i = 0; i &lt; s.length(); i++) {
+			int pos = &quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i));
+			if (pos &gt;= 0)
+				res += (res == &quot;&quot; ? &quot;&quot; : &quot; &quot;) + MyLocale.formatLong(pos + 1, &quot;00&quot;);
+		}
+		return res;
+	}
 
-    /** Replace each character by its number A=1, B=2 etc. and sum them */
-    private double funcVal(String s) {
-    	s=s.toLowerCase();
-    	int sum=0;
-    	for (int i=0; i&lt;s.length(); i++) {
-    		sum+=&quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i))+1;
-    	}
-    	return sum;
-    }
+	/** Replace each character by its number A=1, B=2 etc. and sum them */
+	private double funcVal(String s) {
+		s = s.toLowerCase();
+		int sum = 0;
+		for (int i = 0; i &lt; s.length(); i++) {
+			sum += &quot;abcdefghijklmnopqrstuvwxyz&quot;.indexOf(s.charAt(i)) + 1;
+		}
+		return sum;
+	}
 
-///////////////////////////////////////////
-//  PARSER
-///////////////////////////////////////////
+	// /////////////////////////////////////////
+	// PARSER
+	// /////////////////////////////////////////
 
+	/**
+	 * The following methods implement a recursive descent parser.
+	 * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
+	 * a valid token.
+	 */
 
-    /** The following methods implement a recursive descent parser.
-     * Each method is called with 'thisToken' containing a valid token. It must return with 'thisToken' again containing
-     * a valid token.
-     */
-
-	private void parseCommand()  throws Exception {
-		while(scanpos &lt; tokenStack.size()) {
+	private void parseCommand() throws Exception {
+		while (scanpos &lt; tokenStack.size()) {
 			getToken();
-			if (thisToken.token.equals(&quot;;&quot;)) continue;  // skip an empty command
-			if (thisToken.tt==TokenObj.TT_IF)
+			if (thisToken.token.equals(&quot;;&quot;))
+				continue; // skip an empty command
+			if (thisToken.tt == TokenObj.TT_IF)
 				parseIf();
 			else
 				parseSimpleCommand();
@@ -929,314 +940,385 @@
 		}
 	}
 
-	private void parseSimpleCommand() throws Exception{
-		if (thisToken.tt==TokenObj.TT_STOP) throw new Exception(&quot;STOP&quot;);  // Terminate without error message
+	private void parseSimpleCommand() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STOP)
+			throw new Exception(&quot;STOP&quot;); // Terminate without error message
 		if (thisToken.token.equals(&quot;$&quot;)) { // Show all global variables
 			showVars(true);
 			getToken();
 		} else if (thisToken.token.equals(&quot;?&quot;)) { // Show all local variables
 			showVars(false);
 			getToken();
-		} else if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt==TokenObj.TT_EQ)
+		} else if (thisToken.tt == TokenObj.TT_VARIABLE &amp;&amp; lookAheadToken().tt == TokenObj.TT_EQ)
 			parseAssign();
 		else {
 			parseStringExp();
-			while (calcStack.size()&gt;0) messageStack.add(popCalcStackAsString());
+			while (calcStack.size() &gt; 0)
+				messageStack.add(popCalcStackAsString());
 		}
 	}
 
-	private void parseIf() throws Exception{
+	private void parseIf() throws Exception {
 		int compOp;
-		boolean compRes=false;
-		TokenObj ifToken=thisToken;
+		boolean compRes = false;
+		TokenObj ifToken = thisToken;
 		getToken();
 		// Check for &quot;IF varName THEN&quot; construct to check whether a variable is defined
-		if (thisToken.tt==TokenObj.TT_VARIABLE &amp;&amp; peekToken().token.toUpperCase().equals(&quot;THEN&quot;)) {
-			String varName=thisToken.token;
-			getToken(); //THEN
-			Object result = symbolTable.get(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName);
-			if(result == null) { // Var not found check whether it is a waypoint
+		if (thisToken.tt == TokenObj.TT_VARIABLE &amp;&amp; peekToken().token.toUpperCase().equals(&quot;THEN&quot;)) {
+			String varName = thisToken.token;
+			getToken(); // THEN
+			Object result = symbolTable.get(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName);
+			if (result == null) { // Var not found check whether it is a waypoint
 				if (varName.startsWith(&quot;$&quot;)) { // Could be a cachename
-					varName=varName.substring(1);
-					compRes=Global.getProfile().getCacheIndex(varName)!=-1;
+					varName = varName.substring(1);
+					compRes = Global.getProfile().getCacheIndex(varName) != -1;
 				} else
-					compRes=false;
-			} else // Found the variable, it must have a value
-				compRes=true;
+					compRes = false;
+			} else
+				// Found the variable, it must have a value
+				compRes = true;
 			getNextTokenOtherThanSemi();
 		} else { // Normal: IF expression THEN
 			parseStringExp();
-			compOp=thisToken.tt;
-			if (compOp&lt;TokenObj.TT_LT || compOp&gt;TokenObj.TT_NE) err(MyLocale.getMsg(1723,&quot;Comparison operator expected&quot;));
+			compOp = thisToken.tt;
+			if (compOp &lt; TokenObj.TT_LT || compOp &gt; TokenObj.TT_NE)
+				err(MyLocale.getMsg(1723, &quot;Comparison operator expected&quot;));
 			getToken();
 			parseStringExp();
 			checkNextSymIs(&quot;THEN&quot;);
 			getNextTokenOtherThanSemi();
-			boolean compAsString=false; //calcStack.get(calcStack.size()-2) instanceof String;
+			boolean compAsString = false; // calcStack.get(calcStack.size()-2) instanceof String;
 			// If we can parse the first argument as a double, we will do a numeric comparison
 			try {
-				Common.parseDoubleException((String)calcStack.get(calcStack.size()-2) );
+				Common.parseDoubleException((String) calcStack.get(calcStack.size() - 2));
 			} catch (Exception ex) {
-				compAsString=true;
+				compAsString = true;
 			}
 			// If the first expression is not a double, compare as string.
 			if (compAsString) {
-				String b=popCalcStackAsString();
-				String a=popCalcStackAsString();
+				String b = popCalcStackAsString();
+				String a = popCalcStackAsString();
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a.equals(b); break;
-					case TokenObj.TT_NE: compRes=!a.equals(b); break;
-					case TokenObj.TT_LT: compRes=a.compareTo(b)&lt;0; break;
-					case TokenObj.TT_GT: compRes=a.compareTo(b)&gt;0; break;
-					case TokenObj.TT_LE: compRes=a.compareTo(b)&lt;=0; break;
-					case TokenObj.TT_GE: compRes=a.compareTo(b)&gt;=0; break;
+				case TokenObj.TT_EQ:
+					compRes = a.equals(b);
+					break;
+				case TokenObj.TT_NE:
+					compRes = !a.equals(b);
+					break;
+				case TokenObj.TT_LT:
+					compRes = a.compareTo(b) &lt; 0;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a.compareTo(b) &gt; 0;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a.compareTo(b) &lt;= 0;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a.compareTo(b) &gt;= 0;
+					break;
 				}
 			} else { // First expression is a number, compare as numbers
-				double b=popCalcStackAsNumber(0);
-				double a=popCalcStackAsNumber(0);
+				double b = popCalcStackAsNumber(0);
+				double a = popCalcStackAsNumber(0);
 				switch (compOp) {
-					case TokenObj.TT_EQ: compRes=a==b; break;
-					case TokenObj.TT_NE: compRes=a!=b; break;
-					case TokenObj.TT_LT: compRes=a&lt;b; break;
-					case TokenObj.TT_GT: compRes=a&gt;b; break;
-					case TokenObj.TT_LE: compRes=a&lt;=b; break;
-					case TokenObj.TT_GE: compRes=a&gt;=b; break;
+				case TokenObj.TT_EQ:
+					compRes = a == b;
+					break;
+				case TokenObj.TT_NE:
+					compRes = a != b;
+					break;
+				case TokenObj.TT_LT:
+					compRes = a &lt; b;
+					break;
+				case TokenObj.TT_GT:
+					compRes = a &gt; b;
+					break;
+				case TokenObj.TT_LE:
+					compRes = a &lt;= b;
+					break;
+				case TokenObj.TT_GE:
+					compRes = a &gt;= b;
+					break;
 				}
 			}
 		}
 		if (compRes) { // comparison resulted in TRUE
-			if (thisToken.tt!=TokenObj.TT_ENDIF) {
+			if (thisToken.tt != TokenObj.TT_ENDIF) {
 				parseSimpleCommand();
 				while (thisToken.token.equals(&quot;;&quot;)) {
 					getNextTokenOtherThanSemi(); // Now we have either an ENDIF or the start of a simpleexpression
-					if (thisToken.tt==TokenObj.TT_ENDIF) break;
+					if (thisToken.tt == TokenObj.TT_ENDIF)
+						break;
 					parseSimpleCommand();
 				}
 				checkNextSymIs(&quot;ENDIF&quot;);
 			}
 			getToken();
-		} else // comparison failed
+		} else
+			// comparison failed
 			skipPastEndif(ifToken);
 	}
 
-	private void parseAssign() throws Exception  {
-		String varName=new String(thisToken.token);
-		getToken(); //=
+	private void parseAssign() throws Exception {
+		String varName = new String(thisToken.token);
+		getToken(); // =
 		getToken();
 		// Assigns of the format A=; are ignored so that they can stay as placeholders and
 		// we can fill the data progressively during a multicache
-		if (thisToken.tt==TokenObj.TT_ENDIF || thisToken.token.equals(&quot;;&quot;)) return;
+		if (thisToken.tt == TokenObj.TT_ENDIF || thisToken.token.equals(&quot;;&quot;))
+			return;
 		parseStringExp();
 		if (varName.startsWith(&quot;$&quot;)) { // Potential coordinate
-			CacheHolder ch=Global.getProfile().cacheDB.get(varName.substring(1));
+			CacheHolder ch = Global.getProfile().cacheDB.get(varName.substring(1));
 			if (ch != null) { // Yes, is a coordinate
 				// Check whether new coordinates are valid
-				String coord=popCalcStackAsString();
+				String coord = popCalcStackAsString();
 				cwPt.set(coord);
 				if (cwPt.isValid() || coord.equals(&quot;&quot;)) { // Can clear coord with empty string
-					ch.setLatLon(cwPt.toString(TransformCoordinates.CW));
-					ch.pos.set(cwPt);
+					ch.setPos(cwPt);
 					ch.calcDistance(Global.getPref().getCurCentrePt()); // Update distance and bearing
-		    	    Global.getProfile().selectionChanged=true; // Tell moving map to updated displayed waypoints
-				    return;
+					Global.getProfile().selectionChanged = true; // Tell moving map to updated displayed waypoints
+					return;
 				} else
-					err(MyLocale.getMsg(1712,&quot;Invalid coordinate: &quot;)+coord);
+					err(MyLocale.getMsg(1712, &quot;Invalid coordinate: &quot;) + coord);
 			}
 			// Name starts with $ but is not a waypoint, fall through and set it as global variable
 		}
-		symbolTable.put(Global.getPref().solverIgnoreCase?varName.toUpperCase():varName, popCalcStackAsString());
+		symbolTable.put(Global.getPref().solverIgnoreCase ? varName.toUpperCase() : varName, popCalcStackAsString());
 	}
 
-	private void parseStringExp()throws Exception {
-		if (thisToken.tt==TokenObj.TT_STRING) {
+	private void parseStringExp() throws Exception {
+		if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 			getToken();
 		} else {
 			parseExp();
 		}
-		//calcStack.add(popCalcStackAsString());
-		while (thisToken.tt==TokenObj.TT_STRING ||
-			   thisToken.tt==TokenObj.TT_NUMBER ||
-			   thisToken.tt==TokenObj.TT_VARIABLE ||
-			   thisToken.tt==TokenObj.TT_SYMBOL &amp;&amp; thisToken.token.equals(&quot;(&quot;)) {
-			if (thisToken.tt==TokenObj.TT_STRING) {
+		// calcStack.add(popCalcStackAsString());
+		while (thisToken.tt == TokenObj.TT_STRING || thisToken.tt == TokenObj.TT_NUMBER || thisToken.tt == TokenObj.TT_VARIABLE || thisToken.tt == TokenObj.TT_SYMBOL &amp;&amp; thisToken.token.equals(&quot;(&quot;)) {
+			if (thisToken.tt == TokenObj.TT_STRING) {
 				calcStack.add(thisToken.token);
 				getToken();
 			} else {
 				parseTailExp('+');
 			}
-			String b=popCalcStackAsString();
-			String a=popCalcStackAsString();
-			calcStack.add(a+b);
+			String b = popCalcStackAsString();
+			String a = popCalcStackAsString();
+			calcStack.add(a + b);
 		}
 	}
 
-	private void parseExp()throws Exception {
-		char unaryOp='+';
-		if (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;) ) {
-			unaryOp=thisToken.token.charAt(0);
+	private void parseExp() throws Exception {
+		char unaryOp = '+';
+		if (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;)) {
+			unaryOp = thisToken.token.charAt(0);
 			getToken();
 		}
 		parseTailExp(unaryOp);
 	}
 
-	private void parseTailExp(char unaryOp)throws Exception {
+	private void parseTailExp(char unaryOp) throws Exception {
 		parseTerm();
-		if (unaryOp=='-') { // Unary minus, negate the first term
+		if (unaryOp == '-') { // Unary minus, negate the first term
 			calcStack.add(new java.lang.Double(-popCalcStackAsNumber(0)));
 		}
-		while (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;) ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals(&quot;+&quot;) || thisToken.token.equals(&quot;-&quot;)) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseTerm();
-			double b=popCalcStackAsNumber(0);
-			double a=popCalcStackAsNumber(0);
-			if (op=='+')
-				calcStack.add(new java.lang.Double(a+b));
+			double b = popCalcStackAsNumber(0);
+			double a = popCalcStackAsNumber(0);
+			if (op == '+')
+				calcStack.add(new java.lang.Double(a + b));
 			else
-				calcStack.add(new java.lang.Double(a-b));
+				calcStack.add(new java.lang.Double(a - b));
 		}
 		// If expression is followed by a formatstring, format it
-		if (thisToken.tt==TokenObj.TT_FORMATSTR) {
-			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0),thisToken.token).replace(',','.'));
+		if (thisToken.tt == TokenObj.TT_FORMATSTR) {
+			calcStack.add(MyLocale.formatDouble(popCalcStackAsNumber(0), thisToken.token).replace(',', '.'));
 			getToken();
 		}
 	}
 
-	private void parseTerm() throws Exception{
+	private void parseTerm() throws Exception {
 		parseFactor();
-		while (thisToken.token.equals(&quot;*&quot;) || thisToken.token.equals(&quot;/&quot;) ) {
-			char op=thisToken.token.charAt(0);
+		while (thisToken.token.equals(&quot;*&quot;) || thisToken.token.equals(&quot;/&quot;)) {
+			char op = thisToken.token.charAt(0);
 			getToken();
 			parseFactor();
-			double b=popCalcStackAsNumber(1);
-			double a=popCalcStackAsNumber(1);
-			if (op=='*')
-				calcStack.add(new java.lang.Double(a*b));
+			double b = popCalcStackAsNumber(1);
+			double a = popCalcStackAsNumber(1);
+			if (op == '*')
+				calcStack.add(new java.lang.Double(a * b));
+			else if (b == 0.0)
+				err(MyLocale.getMsg(1729, &quot;Division by 0&quot;));
 			else
-				if (b==0.0)
-					err(MyLocale.getMsg(1729,&quot;Division by 0&quot;));
-				else
-					calcStack.add(new java.lang.Double(a/b));
+				calcStack.add(new java.lang.Double(a / b));
 		}
 	}
 
-	private void parseFactor() throws Exception{
+	private void parseFactor() throws Exception {
 		parseExpFactor();
 		while (thisToken.token.equals(&quot;^&quot;)) {
 			getToken();
 			parseExpFactor();
-			double exp=popCalcStackAsNumber(0);
-			double base=popCalcStackAsNumber(0);
-			calcStack.add(new java.lang.Double(java.lang.Math.pow(base,exp)));
+			double exp = popCalcStackAsNumber(0);
+			double base = popCalcStackAsNumber(0);
+			calcStack.add(new java.lang.Double(java.lang.Math.pow(base, exp)));
 		}
 	}
 
 	private void parseExpFactor() throws Exception {
 		fnType funcDef;
-		if (thisToken.tt==TokenObj.TT_VARIABLE) {
-			if (isVariable(thisToken.token) &amp;&amp; !lookAheadToken().token.equals(&quot;(&quot;) )
+		if (thisToken.tt == TokenObj.TT_VARIABLE) {
+			if (isVariable(thisToken.token) &amp;&amp; !lookAheadToken().token.equals(&quot;(&quot;))
 				calcStack.add(getVariable(thisToken.token));
-			else if (!lookAheadToken().token.equals(&quot;(&quot;)) err(MyLocale.getMsg(1724,&quot;Variable not set: &quot;)+thisToken.token);
-			    else {// Must be a function definition
-				funcDef=getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
+			else if (!lookAheadToken().token.equals(&quot;(&quot;))
+				err(MyLocale.getMsg(1724, &quot;Variable not set: &quot;) + thisToken.token);
+			else {// Must be a function definition
+				funcDef = getFunctionDefinition(thisToken.token); // Does not return if function not defined or ambiguous
 				parseFunction(funcDef);
-			    }
-		} else if (thisToken.tt==TokenObj.TT_NUMBER) {
+			}
+		} else if (thisToken.tt == TokenObj.TT_NUMBER) {
 			calcStack.add(getNumber(thisToken.token));
-		} else if (thisToken.tt==TokenObj.TT_STRING) {
+		} else if (thisToken.tt == TokenObj.TT_STRING) {
 			calcStack.add(thisToken.token);
 		} else if (thisToken.token.equals(&quot;(&quot;)) {
 			getToken();
 			parseStringExp();
 			checkNextSymIs(&quot;)&quot;);
-		}
-		else err(MyLocale.getMsg(1725,&quot;Unexpected character(s): &quot;)+thisToken.token);
+		} else
+			err(MyLocale.getMsg(1725, &quot;Unexpected character(s): &quot;) + thisToken.token);
 		getToken();
 	}
 
 	private void parseFunction(fnType funcDef) throws Exception {
-		String funcName=new String(thisToken.token);
-        int nargs=0;
+		String funcName = new String(thisToken.token);
+		int nargs = 0;
 		getToken();
 		checkNextSymIs(&quot;(&quot;);
 		getToken();
 		if (!thisToken.token.equals(&quot;)&quot;)) { // at least one argument
 			parseStringExp();
-			nargs=1;
+			nargs = 1;
 			while (thisToken.token.equals(&quot;,&quot;)) {
-				if (nargs==4) err(MyLocale.getMsg(1726,&quot;Too many arguments for function &quot;)+funcName);
+				if (nargs == 4)
+					err(MyLocale.getMsg(1726, &quot;Too many arguments for function &quot;) + funcName);
 				getToken();
 				parseStringExp();
 				nargs++;
 			}
 			checkNextSymIs(&quot;)&quot;);
 		}
-		//getToken(); done in parseFactor
-		executeFunction(funcName,nargs,funcDef);
+		// getToken(); done in parseFactor
+		executeFunction(funcName, nargs, funcDef);
 	}
 
 	private void executeFunction(String funcName, int nargs, fnType funcDef) throws Exception {
-		if (!funcDef.nargsValid(nargs)) err(MyLocale.getMsg(1727,&quot;Invalid number of arguments&quot;));
-	         if (funcDef.alias.equals(&quot;asin&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
-	 	else if (funcDef.alias.equals(&quot;abs&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
-	    else if (funcDef.alias.equals(&quot;acos&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;atan&quot;)) calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;bearing&quot;)) calcStack.add(new java.lang.Double(funcBearing()));
-	    else if (funcDef.alias.equals(&quot;center&quot;)) funcCenter(nargs);
-	    else if (funcDef.alias.equals(&quot;cls&quot;)) funcCls();
-	    else if (funcDef.alias.equals(&quot;cos&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;count&quot;)) funcCount();
-	    else if (funcDef.alias.equals(&quot;cp&quot;)) calcStack.add(funcCp());
-	    else if (funcDef.alias.equals(&quot;ct&quot;)) calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
-	    else if (funcDef.alias.equals(&quot;deg&quot;)) funcDeg(true);
-	    else if (funcDef.alias.equals(&quot;deg2rad&quot;)) calcStack.add(new java.lang.Double(funcDeg2Rad()));
-	    else if (funcDef.alias.equals(&quot;distance&quot;)) calcStack.add(new java.lang.Double(funcDistance()));
-	    else if (funcDef.alias.equals(&quot;encode&quot;)) calcStack.add(funcEncode());
-	    else if (funcDef.alias.equals(&quot;format&quot;)) calcStack.add(funcFormat(nargs));
-	    else if (funcDef.alias.equals(&quot;goto&quot;)) funcGoto(nargs);
-	    else if (funcDef.alias.equals(&quot;ic&quot;)) funcIgnoreVariableCase(nargs);
-	    else if (funcDef.alias.equals(&quot;instr&quot;)) calcStack.add(new Double(funcInstr(nargs)));
-	    else if (funcDef.alias.equals(&quot;int&quot;)) calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
-	    else if (funcDef.alias.equals(&quot;lc&quot;)) calcStack.add(popCalcStackAsString().toLowerCase());
-	    else if (funcDef.alias.equals(&quot;len&quot;)) calcStack.add(new Double(popCalcStackAsString().length()));
-	    else if (funcDef.alias.equals(&quot;mid&quot;)) calcStack.add(funcMid(nargs));
-	    else if (funcDef.alias.equals(&quot;mod&quot;)) calcStack.add(funcMod());
-	    else if (funcDef.alias.equals(&quot;project&quot;)) calcStack.add(funcProject());
-	    else if (funcDef.alias.equals(&quot;pz&quot;)) funcPz(nargs);
-	    else if (funcDef.alias.equals(&quot;rad&quot;)) funcDeg(false);
-	    else if (funcDef.alias.equals(&quot;rad2deg&quot;)) calcStack.add(new java.lang.Double(funcRad2Deg()));
-	    else if (funcDef.alias.equals(&quot;replace&quot;)) calcStack.add(funcReplace());
-	    else if (funcDef.alias.equals(&quot;reverse&quot;)) calcStack.add(funcReverse(popCalcStackAsString()));
-	    else if (funcDef.alias.equals(&quot;rot13&quot;)) calcStack.add(Common.rot13(popCalcStackAsString()));
-//	    else if (funcDef.alias.equals(&quot;rs&quot;)) funcRequireSemicolon(nargs);
-	    else if (funcDef.alias.equals(&quot;show&quot;));
-	    else if (funcDef.alias.equals(&quot;sin&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;skeleton&quot;)) funcSkeleton(nargs);
-	    else if (funcDef.alias.equals(&quot;sqrt&quot;)) calcStack.add(new java.lang.Double(funcSqrt()));
-	    else if (funcDef.alias.equals(&quot;sval&quot;)) calcStack.add(funcSval(popCalcStackAsString()));
-	    else if (funcDef.alias.equals(&quot;tan&quot;)) calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
-	    else if (funcDef.alias.equals(&quot;uc&quot;)) calcStack.add(popCalcStackAsString().toUpperCase());
-	    else if (funcDef.alias.equals(&quot;val&quot;)) calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
-	    else if (funcDef.alias.equals(&quot;cb&quot;)) calcStack.add(funcCrossBearing ());
-	    else err(MyLocale.getMsg(1728,&quot;Function not yet implemented: &quot;)+funcName);
+		if (!funcDef.nargsValid(nargs))
+			err(MyLocale.getMsg(1727, &quot;Invalid number of arguments&quot;));
+		if (funcDef.alias.equals(&quot;asin&quot;))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.asin(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;abs&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.abs(popCalcStackAsNumber(0))));
+		else if (funcDef.alias.equals(&quot;acos&quot;))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.acos(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;atan&quot;))
+			calcStack.add(new java.lang.Double(makeDegree(java.lang.Math.atan(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;bearing&quot;))
+			calcStack.add(new java.lang.Double(funcBearing()));
+		else if (funcDef.alias.equals(&quot;center&quot;))
+			funcCenter(nargs);
+		else if (funcDef.alias.equals(&quot;cls&quot;))
+			funcCls();
+		else if (funcDef.alias.equals(&quot;cos&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.cos(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;count&quot;))
+			funcCount();
+		else if (funcDef.alias.equals(&quot;cp&quot;))
+			calcStack.add(funcCp());
+		else if (funcDef.alias.equals(&quot;ct&quot;))
+			calcStack.add(new java.lang.Double(funcCrossTotal(nargs)));
+		else if (funcDef.alias.equals(&quot;deg&quot;))
+			funcDeg(true);
+		else if (funcDef.alias.equals(&quot;deg2rad&quot;))
+			calcStack.add(new java.lang.Double(funcDeg2Rad()));
+		else if (funcDef.alias.equals(&quot;distance&quot;))
+			calcStack.add(new java.lang.Double(funcDistance()));
+		else if (funcDef.alias.equals(&quot;encode&quot;))
+			calcStack.add(funcEncode());
+		else if (funcDef.alias.equals(&quot;format&quot;))
+			calcStack.add(funcFormat(nargs));
+		else if (funcDef.alias.equals(&quot;goto&quot;))
+			funcGoto(nargs);
+		else if (funcDef.alias.equals(&quot;ic&quot;))
+			funcIgnoreVariableCase(nargs);
+		else if (funcDef.alias.equals(&quot;instr&quot;))
+			calcStack.add(new Double(funcInstr(nargs)));
+		else if (funcDef.alias.equals(&quot;int&quot;))
+			calcStack.add(new Double(new Double(popCalcStackAsNumber(0)).longValue()));
+		else if (funcDef.alias.equals(&quot;lc&quot;))
+			calcStack.add(popCalcStackAsString().toLowerCase());
+		else if (funcDef.alias.equals(&quot;len&quot;))
+			calcStack.add(new Double(popCalcStackAsString().length()));
+		else if (funcDef.alias.equals(&quot;mid&quot;))
+			calcStack.add(funcMid(nargs));
+		else if (funcDef.alias.equals(&quot;mod&quot;))
+			calcStack.add(funcMod());
+		else if (funcDef.alias.equals(&quot;project&quot;))
+			calcStack.add(funcProject());
+		else if (funcDef.alias.equals(&quot;pz&quot;))
+			funcPz(nargs);
+		else if (funcDef.alias.equals(&quot;rad&quot;))
+			funcDeg(false);
+		else if (funcDef.alias.equals(&quot;rad2deg&quot;))
+			calcStack.add(new java.lang.Double(funcRad2Deg()));
+		else if (funcDef.alias.equals(&quot;replace&quot;))
+			calcStack.add(funcReplace());
+		else if (funcDef.alias.equals(&quot;reverse&quot;))
+			calcStack.add(funcReverse(popCalcStackAsString()));
+		else if (funcDef.alias.equals(&quot;rot13&quot;))
+			calcStack.add(Common.rot13(popCalcStackAsString()));
+		// else if (funcDef.alias.equals(&quot;rs&quot;)) funcRequireSemicolon(nargs);
+		else if (funcDef.alias.equals(&quot;show&quot;))
+			;
+		else if (funcDef.alias.equals(&quot;sin&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.sin(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;skeleton&quot;))
+			funcSkeleton(nargs);
+		else if (funcDef.alias.equals(&quot;sqrt&quot;))
+			calcStack.add(new java.lang.Double(funcSqrt()));
+		else if (funcDef.alias.equals(&quot;sval&quot;))
+			calcStack.add(funcSval(popCalcStackAsString()));
+		else if (funcDef.alias.equals(&quot;tan&quot;))
+			calcStack.add(new java.lang.Double(java.lang.Math.tan(makeRadiant(popCalcStackAsNumber(0)))));
+		else if (funcDef.alias.equals(&quot;uc&quot;))
+			calcStack.add(popCalcStackAsString().toUpperCase());
+		else if (funcDef.alias.equals(&quot;val&quot;))
+			calcStack.add(new java.lang.Double(funcVal(popCalcStackAsString())));
+		else if (funcDef.alias.equals(&quot;cb&quot;))
+			calcStack.add(funcCrossBearing());
+		else
+			err(MyLocale.getMsg(1728, &quot;Function not yet implemented: &quot;) + funcName);
 	}
 
-	public void parse(Vector tck, Vector msgStack){
+	public void parse(Vector tck, Vector msgStack) {
 		calcStack.clear();
 		clearLocalSymbols();
 		tokenStack = tck;
 		messageStack = msgStack;
 		scanpos = 0;
-		try{
+		try {
 			parseCommand();
-		}catch(Exception ex){
+		} catch (Exception ex) {
 		}
 	}
 
-	private boolean createWptIfNeeded(String wayPoint, String name, byte type){
-	   	int ci=Global.getProfile().getCacheIndex(wayPoint);
-    	if (ci &gt;= 0) return false;
+	private boolean createWptIfNeeded(String wayPoint, String name, byte type) {
+		int ci = Global.getProfile().getCacheIndex(wayPoint);
+		if (ci &gt;= 0)
+			return false;
 
 		CacheHolder ch = new CacheHolder();
 		ch.setWayPoint(wayPoint);

Modified: branches/r1.2/src/CacheWolf/Preferences.java
===================================================================
--- branches/r1.2/src/CacheWolf/Preferences.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Preferences.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -46,34 +46,35 @@
 import ewe.ui.MessageBox;
 import ewe.ui.Window;
 import ewe.ui.WindowConstants;
+import ewe.ui.mApp;
 import ewe.util.Comparer;
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Map.MapEntry;
 import ewe.util.StringTokenizer;
 import ewe.util.Utils;
-import ewe.util.Map.MapEntry;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	A class to hold the preferences that were loaded upon start up of CacheWolf.
- *	This class is also capable of parsing the prefs.xml file as well as
- *	saving the current settings of preferences.
+ * A class to hold the preferences that were loaded upon start up of CacheWolf. This class is also capable of parsing
+ * the prefs.xml file as well as saving the current settings of preferences.
  */
-public class Preferences extends MinML{
+public class Preferences extends MinML {
 
-	public final int DEFAULT_MAX_LOGS_TO_SPIDER=250;
-	public final int DEFAULT_LOGS_PER_PAGE=5;
-	public final int DEFAULT_INITIAL_HINT_HEIGHT=10;
-	public final int DEFAULT_GPSD_PORT=2947;
-	public static final int GPSD_DISABLED   = 0; // do not use gpsd
+	public final int DEFAULT_MAX_LOGS_TO_SPIDER = 250;
+	public final int DEFAULT_LOGS_PER_PAGE = 5;
+	public final int DEFAULT_INITIAL_HINT_HEIGHT = 10;
+	public final int DEFAULT_GPSD_PORT = 2947;
+	public static final int GPSD_DISABLED = 0; // do not use gpsd
 	public static final int GPSD_FORMAT_OLD = 1; // use old protocol
-	public static final int GPSD_FORMAT_NEW = 2; // use new protocol (JSON)
+	public static final int GPSD_FORMAT_NEW = 2; // use new protocol
+	// (JSON)
 	public static final int YES = 0;
 	public static final int NO = 1;
 	public static final int ASK = 2;
-	public static String NEWLINE=&quot;\n&quot;;
+	public static String NEWLINE = &quot;\n&quot;;
 	// Hashtable is saving filter data objects the user wants to save
 	private Hashtable filterList = new Hashtable(15);
 	/** screen is big enough to hold additional information like cache notes */
@@ -81,13 +82,15 @@
 	/** display big icons. default only true for VGA PDAs */
 	// TODO: make this configurable via pref.xml
 	public boolean useBigIcons;
+	public boolean useRadar;
 
-	//////////////////////////////////////////////////////////////////////////////////////
-    // Constructor
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Constructor
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Singleton pattern - return reference to Preferences
+	 * 
 	 * @return Singleton Preferences object
 	 */
 	public static Preferences getPrefObject() {
@@ -103,82 +106,92 @@
 
 	/**
 	 * Call this method to set the path of the config file &lt;br&gt;
-	 * If you call it with null it defaults to [program-dir]/pref.xml
-	 * if p is a directory &quot;pref.xml&quot; will automatically appended
+	 * If you call it with null it defaults to [program-dir]/pref.xml if p is a directory &quot;pref.xml&quot; will automatically
+	 * appended
+	 * 
 	 * @param p
 	 */
 	public void setPathToConfigFile(String p) {
 		String p_;
 		if (p == null) {
 			/*
-			String test;
-			test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
-			log(&quot;Vm.getenv(APPDATA: &quot; + test); // this works also in win32.exe (ewe-vm on win xp)
-			test = Vm.getenv(&quot;HOME&quot;, &quot;/&quot;); // This should return on *nix system the home dir
-			log(&quot;Vm.getenv(HOME: &quot; + test);
-			test = System.getProperty(&quot;user.dir&quot;); // return in java-vm on win xp: &lt;working dir&gt; or maybe &lt;program dir&gt;
-			log(&quot;System.getProperty(user.dir: &quot; + test); // in win32.exe -&gt; null
-			test = System.getProperty(&quot;user.home&quot;); // in MS-java-VM env variable $HOME is ignored and always &lt;windir&gt;\java returned, see <A HREF="http://support.microsoft.com/kb/177181/en-us/">http://support.microsoft.com/kb/177181/en-us/</A>
-			log(&quot;System.getProperty(user.home: &quot; + test); // in win32.exe -&gt; null
-			// &quot;user.dir&quot;              User's current working directory
-			// &quot;user.home&quot;             User home directory (taken from <A HREF="http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html">http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html</A> )
+			 * String test; test = Vm.getenv(&quot;APPDATA&quot;, &quot;/&quot;);
+			 * // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt; log(&quot;Vm.getenv(APPDATA: &quot; + test);
+			 * // this works also in win32.exe (ewe-vm on win xp) test = Vm.getenv(&quot;HOME&quot;,
+			 * &quot;/&quot;); // This should return on *nix system the home dir
+			 * log(&quot;Vm.getenv(HOME: &quot; + test); test =
+			 * System.getProperty(&quot;user.dir&quot;); // return in java-vm on win
+			 * xp: &lt;working dir&gt; or maybe &lt;program dir&gt;
+			 * log(&quot;System.getProperty(user.dir: &quot; + test); // in win32.exe -&gt;
+			 * null test = System.getProperty(&quot;user.home&quot;); // in MS-java-VM
+			 * env variable $HOME is ignored and always &lt;windir&gt;\java
+			 * returned, see <A HREF="http://support.microsoft.com/kb/177181/en-us/">http://support.microsoft.com/kb/177181/en-us/</A>
+			 * log(&quot;System.getProperty(user.home: &quot; + test); // in win32.exe -&gt;
+			 * null // &quot;user.dir&quot; User's current working directory //
+			 * &quot;user.home&quot; User home directory (taken from
+			 * <A HREF="http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html">http://scv.bu.edu/Doc/Java/tutorial/java/system/properties.html</A> )
 			 */
 			p_ = FileBase.makePath(FileBase.getProgramDirectory(), &quot;pref.xml&quot;);
+		} else {
+			if (new FileBugfix(p).isDirectory())
+				p_ = FileBase.makePath(p, &quot;pref.xml&quot;);
+			else
+				p_ = p;
 		}
-		else {
-			if (new FileBugfix(p).isDirectory()) p_ = FileBase.makePath(p, &quot;pref.xml&quot;);
-			else p_ = p;
-		}
-		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;); // this is necessary in case that the root dir is the dir where the pref.xml is stored
+		// this is necessary in case that the root dir is the dir where the pref.xml is stored
+		pathToConfigFile = STRreplace.replace(p_, &quot;//&quot;, &quot;/&quot;);
 		pathToConfigFile = pathToConfigFile.replace('\\', '/');
-		p=System.getProperty(&quot;os.name&quot;);
-		if (p==null || p.indexOf(&quot;indows&quot;)!=-1) {
+		p = System.getProperty(&quot;os.name&quot;);
+		if (p == null || p.indexOf(&quot;indows&quot;) != -1) {
 			NEWLINE = &quot;\r\n&quot;;
-		} 
+		}
 	}
 
 	/**
 	 * Constructor is private for a singleton object
 	 */
-	private Preferences(){
+	private Preferences() {
 		mySPO.bits = 8;
 		mySPO.parity = SerialPort.NOPARITY;
 		mySPO.stopBits = 1;
 		mySPO.baudRate = 4800;
-		if ( ((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new ewe.fx.Rect(),0))).height &gt; 400) {
+		if (((ewe.fx.Rect) (Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new ewe.fx.Rect(), 0))).height &gt; 400) {
 			if (Vm.getPlatform().equals(&quot;Unix&quot;))
 				fontSize = 12;
-			else{
+			else {
 				// Default on VGA-PDAs: fontSize 21 + adjust ColWidth
-				if (Vm.isMobile()){
+				if (Vm.isMobile()) {
 					fontSize = 21;
-					listColWidth=&quot;20,20,30,30,92,177,144,83,60,105,50,104,22,30,30&quot;;
-				}
-				else
+					listColWidth = &quot;20,20,30,30,92,177,144,83,60,105,50,104,22,30,30&quot;;
+				} else
 					fontSize = 16;
 			}
 		} else
 			fontSize = 11;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	/** The base directory contains one subdirectory for each profile*/
+	/** The base directory contains one subdirectory for each profile */
 	private String baseDir = &quot;&quot;;
 	public String absoluteBaseDir = &quot;&quot;;
 	/** Name of last used profile */
-	public String lastProfile=&quot;&quot;;
-	/** If true, the last profile is reloaded automatically without a dialogue */
-	public boolean autoReloadLastProfile=false;
-	/** If true current cetre will be set from gps position	 */
-	public boolean setCurrentCentreFromGPSPosition=true;
+	public String lastProfile = &quot;&quot;;
+	/**
+	 * If true, the last profile is reloaded automatically without a dialogue
+	 */
+	public boolean autoReloadLastProfile = false;
+	/** If true current cetre will be set from gps position */
+	public boolean setCurrentCentreFromGPSPosition = true;
 	/** This is the login alias for geocaching.com and opencaching.de */
 	public String myAlias = &quot;&quot;;
 	/** Optional password */
-	public String password=&quot;&quot;;
-	/** This is an alternative alias used to identify found caches (i.e. if using multiple IDs) */
+	public String password = &quot;&quot;;
+	/**
+	 * This is an alternative alias used to identify found caches (i.e. if using multiple IDs)
+	 */
 	public String myAlias2 = &quot;&quot;;
 	/** The path to the browser */
 	public String browser = &quot;&quot;;
@@ -187,7 +200,7 @@
 	/** HTTP proxy port when spidering */
 	public String myproxyport = &quot;&quot;;
 	/** Flag whether proxy is to be used */
-	public boolean proxyActive=false;
+	public boolean proxyActive = false;
 	/** Serial port name and baudrate */
 	public SerialPortOptions mySPO = new SerialPortOptions();
 	/** True if the GPS data should be forwarded to an IP address */
@@ -205,67 +218,85 @@
 	/** Timer for logging GPS data */
 	public String logGPSTimer = &quot;5&quot;;
 	/** The default font size */
-	public int fontSize; 
-	// These settings govern where the menu and the tabs are displayed and whether the statusbas is shown
+	public int fontSize;
+	public String fontName;
+	// These settings govern where the menu and the tabs are displayed and
+	// whether the statusbas is shown
 	/** True if the menu is to be displayed at the top of the screen */
-	public boolean menuAtTop=true;
+	public boolean menuAtTop = true;
 	/** True if the tabs are to be displayed at the top of the screen */
-	public boolean tabsAtTop=true;
+	public boolean tabsAtTop = true;
 	/** True if the status bar is to be displayed (hidden if false) */
-	public boolean showStatus=true;
-	//public boolean noTabs=false;
-	/** True if the application can be closed by clicking on the close button in the top line.
-	 * This can be set to avoid accidental closing of the application */
-	public boolean hasCloseButton=true;
+	public boolean showStatus = true;
+	// public boolean noTabs=false;
+	/**
+	 * True if the application can be closed by clicking on the close button in the top line. This can be set to avoid
+	 * accidental closing of the application
+	 */
+	public boolean hasCloseButton = true;
 	/** True if the SIP is always visible */
 	public boolean fixSIP = false;
 	/** The list of visible columns in the list view */
-	public String listColMap=&quot;0,1,2,3,4,5,6,7,8,9,10,11,12&quot;;
+	public String listColMap = &quot;0,1,2,3,4,5,6,7,8,9,10,11,12&quot;;
 	/** The widths for each column in list view */
-	public String listColWidth=&quot;15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30&quot;;
-	/** The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney */
-	public String travelbugColMap=&quot;1,4,5,6,8,9,10,7&quot;;
+	public String listColWidth = &quot;15,20,20,25,92,177,144,83,60,105,50,104,22,30,30,30,30,30,30,30&quot;;
+	/**
+	 * The columns which are to be displayed in TravelbugsJourneyScreen. See also TravelbugJourney
+	 */
+	public String travelbugColMap = &quot;1,4,5,6,8,9,10,7&quot;;
 	/** The column widths for the travelbug journeys. */
-	public String travelbugColWidth=&quot;212,136,62,90,50,56,90,38,50,50,94,50&quot;;
-	/** If this flag is true, only non-logged travelbug journeys will be shown */
-	public boolean travelbugShowOnlyNonLogged=false;
+	public String travelbugColWidth = &quot;212,136,62,90,50,56,90,38,50,50,94,50&quot;;
+	/**
+	 * If this flag is true, only non-logged travelbug journeys will be shown
+	 */
+	public boolean travelbugShowOnlyNonLogged = false;
 	/** If this is true, deleted images are shown with a ? in the imagepanel */
-	public boolean showDeletedImages=true;
-	/** This setting determines how many logs are shown per page of hintlogs (default 5) */
-	public int logsPerPage=DEFAULT_LOGS_PER_PAGE;
+	public boolean showDeletedImages = true;
+	/**
+	 * This setting determines how many logs are shown per page of hintlogs (default 5)
+	 */
+	public int logsPerPage = DEFAULT_LOGS_PER_PAGE;
 	/** Initial height of hints field (set to 0 to hide them initially) */
-	public int initialHintHeight=DEFAULT_INITIAL_HINT_HEIGHT;
+	public int initialHintHeight = DEFAULT_INITIAL_HINT_HEIGHT;
 	/** Maximum logs to spider */
 	public int maxLogsToSpider = DEFAULT_MAX_LOGS_TO_SPIDER;
 	/** True if the Solver should ignore the case of variables */
-	public boolean solverIgnoreCase=true;
-	/** True if the solver expects arguments for trigonometric functions in degrees */
-	public boolean solverDegMode=true;
+	public boolean solverIgnoreCase = true;
+	/**
+	 * True if the solver expects arguments for trigonometric functions in degrees
+	 */
+	public boolean solverDegMode = true;
 	/** True if the description panel should show images */
-	public boolean descShowImg=true;
+	public boolean descShowImg = true;
 	/** The type of connection which GPSBABEL uses: com1 OR usb. */
-	public String garminConn=&quot;com1&quot;;
+	public String garminConn = &quot;com1&quot;;
 	/** Additional options for GPSBabel, i.e. -s to synthethise short names */
-	public String garminGPSBabelOptions=&quot;&quot;;
-	/** Max. length for Garmin waypoint names (for etrex which can only accept 6 chars) */
-	public int garminMaxLen=0;
-	public boolean downloadMissingOC = false;
-	public String lastOCSite=OC.OCSites[0][OC.OC_HOSTNAME];
-	/** The currently used centre point, can be different from the profile's centrepoint. This is used
-	 *  for spidering */
-	private CWPoint curCentrePt=new CWPoint();
+	public String garminGPSBabelOptions = &quot;&quot;;
+	/**
+	 * Max. length for Garmin waypoint names (for etrex which can only accept 6 chars)
+	 */
+	public int garminMaxLen = 0;
+	/** OC true = alle neu Laden false = wenn &#196;nderungsdatum neuer */
+	public boolean downloadAllOC = false;
+	public String lastOCSite = OC.OCSites[0][OC.OC_HOSTNAME];
+	/**
+	 * The currently used centre point, can be different from the profile's centrepoint. This is used for spidering
+	 */
+	private CWPoint curCentrePt = new CWPoint();
 	/** True if a login screen is displayed on each spider operation */
-	public boolean forceLogin=true;
+	public boolean forceLogin = true;
 	/** True if the goto panel is North centered */
 	public boolean northCenteredGoto = true;
 	/** If not null, a customs map path has been specified by the user */
-	private String customMapsPath=null;
+	private String customMapsPath = null;
 	/** Number of CacheHolder details that are kept in memory */
-	public int maxDetails=50;
-	/** Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails */
-	public int deleteDetails=5;
+	public int maxDetails = 50;
+	/**
+	 * Number of details to delete when maxDetails have been stored in cachesWithLoadedDetails
+	 */
+	public int deleteDetails = 5;
 	/** The locale code (DE, EN, ...) */
-	public String language=&quot;&quot;;
+	public String language = &quot;&quot;;
 	/** The metric system to use */
 	public int metricSystem = Metrics.METRIC;
 	/** Load updated caches while spidering */
@@ -279,24 +310,27 @@
 	/** The own GC member ID */
 	public String gcMemberId = &quot;&quot;;
 	/** Premium Member ? */
-	public boolean isPremium=true;
+	public boolean isPremium = true;
 	/** The maximum number of logs to export */
 	public int numberOfLogsToExport = 5;
 	/** Add Travelbugs when exporting */
 	public boolean exportTravelbugs = false;
 	/** Try to make a MyFinds GPX when exporting to GPX */
 	public boolean exportGpxAsMyFinds = true;
-	/** Check if lastFound is newer than saved log*/
-	public boolean checkLog=false;
-	/** Check if presence of TBs changed*/
-	public boolean checkTBs=true;
-	/** menu of spider along a route exists*/
-	public boolean spiderRoute=false;
+	/** Check if lastFound is newer than saved log */
+	public boolean checkLog = false;
+	/** Check if presence of TBs changed */
+	public boolean checkTBs = true;
+	/** Check if presence of DTS changed */
+	public boolean checkDTS = true;
+	/** menu of spider along a route exists */
+	public boolean spiderRoute = false;
 	/** Download images when loading cache data */
 	public boolean downloadPics = true;
 	/** Download TB information when loading cache data */
 	public boolean downloadTBs = true;
-	/** Last mode select in the DataMover for processing cache*/
+	public String userID = &quot;&quot;;
+	/** Last mode select in the DataMover for processing cache */
 	public int processorMode = 0;
 	/** maximum number of logs to store in cache details */
 	public int maxLogsToKeep = DEFAULT_MAX_LOGS_TO_SPIDER;
@@ -304,40 +338,51 @@
 	public boolean alwaysKeepOwnLogs = true;
 
 	/** Determines whether to fill the white areas on the map */
-	public boolean fillWhiteArea=false;
+	public boolean fillWhiteArea = false;
 
-    /** Selected Size of map tiles */
-    public int mapTileSize=1;
-    /** How many should maptiles overlap */
-    public int mapOverlapping=100;
-    /** Width and height of free defined tile size */
-    public int tilewidth;
-    public int tileheight;
-    
-    /** ShowCachesOnMap */
-    public boolean showCachesOnMap=true;
+	/** Selected Size of map tiles */
+	public int mapTileSize = 1;
+	/** How many should maptiles overlap */
+	public int mapOverlapping = 100;
+	/** Width and height of free defined tile size */
+	public int tilewidth;
+	public int tileheight;
+	/** ShowCachesOnMap */
+	public boolean showCachesOnMap = true;
+	/** SortingGroupedByCache */
+	public boolean SortingGroupedByCache = true;
+	/** useOwnSymbols */
+	public boolean useOwnSymbols = true;
+	/** TRUE if we want automatic sorting * */
+	public boolean sortAutomatic = true;
+	//
+	public String oldLanguageCtl = &quot;&quot;;
+	public boolean doNotGetFound = true;
 
-    /** SortingGroupedByCache */
-    public boolean SortingGroupedByCache=true;
-
-    /** useOwnSymbols */
-    public boolean useOwnSymbols=true;
-
-    /** TRUE if we want automatic sorting **/
-    public boolean sortAutomatic = true;
-
-	//////////////////////////////////////////////
-	/** The debug switch (Can be used to activate dormant code) by adding
-	 * the line: &lt;pre&gt;&lt;debug value=&quot;true&quot; /&gt;&lt;/pre&gt;
+	// ////////////////////////////////////////////
+	/**
+	 * The debug switch (Can be used to activate dormant code) by adding the line:
+	 * 
+	 * &lt;pre&gt;
+	 * &lt;debug value=&quot;true&quot; /&gt;
+	 * &lt;/pre&gt;
+	 * 
 	 * to the pref.xml file.
 	 */
 	public boolean debug = false;
-	//////////////////////////////////////////////
+	// ////////////////////////////////////////////
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Public fields not stored in pref.xml
-	//////////////////////////////////////////////////////////////////////////////////////
+	/**
+	 * This switches the behaviour of GUI-Element factories. If set to true, it will construct alternative Forms. It can
+	 * only be set in the Preference-File directly, not by user-interaction now. Add &lt;MobileGui value=&quot;true&quot;/&gt; to your
+	 * pref.xml
+	 */
+	public boolean mobileGUI = false;
 
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Public fields not stored in pref.xml
+	// ////////////////////////////////////////////////////////////////////////////////////
+
 	/** The height of the application */
 	public int myAppHeight = 600;
 	/** The width of the application */
@@ -347,66 +392,62 @@
 
 	private String pathToProfile;
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Read pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Read pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
-	 * Method to open and parse the config file (pref.xml). Results are stored in the
-	 * public variables of this class.
-	 * If you want to specify a non default config file call setPathToConfigFile() first.
+	 * Method to open and parse the config file (pref.xml). Results are stored in the public variables of this class. If
+	 * you want to specify a non default config file call setPathToConfigFile() first.
 	 */
-	public void readPrefFile(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
+	public void readPrefFile() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
 			ewe.io.Reader r = new ewe.io.InputStreamReader(new ewe.io.FileInputStream(pathToConfigFile));
 			parse(r);
 			r.close();
-		}catch(IOException e){
+		} catch (IOException e) {
 			log(&quot;IOException reading config file: &quot; + pathToConfigFile, e, true);
 			browser = getDefaultBrowser();
 			(new MessageBox(MyLocale.getMsg(327, &quot;Information&quot;), MyLocale.getMsg(176, &quot;First start - using default preferences \n For experts only: \n Could not read preferences file:\n&quot;) + pathToConfigFile, FormBase.OKB)).execute();
-		}catch(Exception e){
+		} catch (Exception e) {
 			if (e instanceof NullPointerException)
-				log(&quot;Error reading pref.xml: NullPointerException in Element &quot;+lastName +&quot;. Wrong attribute?&quot;,e,true);
+				log(&quot;Error reading pref.xml: NullPointerException in Element &quot; + lastName + &quot;. Wrong attribute?&quot;, e, true);
 			else
 				log(&quot;Error reading pref.xml: &quot;, e);
 		}
-		useBigIcons = Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400;
 		isBigScreen = (MyLocale.getScreenWidth() &gt;= 400) &amp;&amp; (MyLocale.getScreenHeight() &gt;= 600);
 	}
 
-/**
- * Tries to find a executable browser
- * return &quot;&quot; if no browser found
- * @return
- */
+	/**
+	 * Tries to find a executable browser return &quot;&quot; if no browser found
+	 * 
+	 * @return
+	 */
 	private String getDefaultBrowser() {
 		String pf = Vm.getPlatform();
 		String testlist[] = null;
 		if (pf.equals(&quot;Java&quot;) || pf.equals(&quot;Win32&quot;)) {
-			String progdir = Vm.getenv(&quot;ProgramFiles&quot;, null); // at least in java-Win XP this is set
-			String homedir=Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
+			// at least in java-Win XP this is set
+			String progdir = Vm.getenv(&quot;ProgramFiles&quot;, null);
+			String homedir = Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
 			if (progdir != null) {
-				String test[] = {
-						homedir+&quot;/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe&quot;,
-						progdir+&quot;/Firefox/firefox.exe&quot;,
-						progdir+&quot;/Opera/opera.exe&quot;,
-						progdir+&quot;/Internet Explorer/iexplore.exe&quot;};
+				String test[] = { homedir + &quot;/Lokale Einstellungen/Anwendungsdaten/Google/Chrome/Application/chrome.exe&quot;, progdir + &quot;/Firefox/firefox.exe&quot;, progdir + &quot;/Opera/opera.exe&quot;, progdir + &quot;/Internet Explorer/iexplore.exe&quot; };
 				testlist = test;
 			} else {
 				String test[] = { // this part is not tested
-						&quot;/opt/firefox/firefox&quot;, // default path in ubuntu
-						&quot;/usr/bin/firefox&quot;};
+				&quot;/opt/firefox/firefox&quot;, // default path in ubuntu
+						&quot;/usr/bin/firefox&quot; };
 				testlist = test;
 			}
 		}
 		if (pf.equals(&quot;WinCE&quot;)) {
-			String test[] = {&quot;/windows/iexplore.exe&quot;};
+			String test[] = { &quot;/windows/iexplore.exe&quot; };
 			testlist = test;
 		}
 		if (testlist != null) {
-			for (int i=0; i &lt; testlist.length; i++)
+			for (int i = 0; i &lt; testlist.length; i++)
 				if ((new FileBugfix(testlist[i])).exists()) {
 					return testlist[i];
 				}
@@ -415,10 +456,12 @@
 	}
 
 	/** Helper variables for XML parser */
-	private StringBuffer collectElement=null;
-	private String lastName; // The string to the last XML that was processed
+	private StringBuffer collectElement = null;
+	// The string to the last XML that was processed
+	private String lastName;
+
 	private long getLongAttr(AttributeList atts, String name) {
-		String stmp=atts.getValue(name);
+		String stmp = atts.getValue(name);
 		long ret = 0l;
 		if (stmp != null) {
 			ret = Convert.parseLong(stmp);
@@ -429,176 +472,192 @@
 	/**
 	 * Method that gets called when a new element has been identified in pref.xml
 	 */
-	public void startElement(String name, AttributeList atts){
-		lastName=name;
+	public void startElement(String name, AttributeList atts) {
+		lastName = name;
 		String tmp;
-		if(name.equals(&quot;browser&quot;)) {
+		if (name.equals(&quot;browser&quot;)) {
 			browser = atts.getValue(&quot;name&quot;);
-			if (browser == null || browser.length() == 0) browser = getDefaultBrowser();
-		}
-		else if(name.equals(&quot;fixedsip&quot;)) {
-			if(atts.getValue(&quot;state&quot;).equals(&quot;true&quot;)) {
+			if (browser == null || browser.length() == 0)
+				browser = getDefaultBrowser();
+		} else if (name.equals(&quot;fixedsip&quot;)) {
+			if (atts.getValue(&quot;state&quot;).equals(&quot;true&quot;)) {
 				fixSIP = true;
 			}
-		}
-		else if(name.equals(&quot;font&quot;)) fontSize = Convert.toInt(atts.getValue(&quot;size&quot;));
-		else if(name.equals(&quot;alias&quot;)) {
+		} else if (name.equals(&quot;font&quot;)) {
+			fontSize = Convert.toInt(atts.getValue(&quot;size&quot;));
+			fontName = atts.getValue(&quot;name&quot;);
+			if (fontName == null)
+				fontName = mApp.findFont(&quot;gui&quot;).getName();
+		} else if (name.equals(&quot;alias&quot;)) {
 			myAlias = SafeXML.cleanback(atts.getValue(&quot;name&quot;));
 			tmp = SafeXML.cleanback(atts.getValue(&quot;password&quot;));
-			if (tmp != null) password=tmp;
-		}
-		else if(name.equals(&quot;alias2&quot;)) myAlias2 = SafeXML.cleanback(atts.getValue(&quot;name&quot;));
-		else if(name.equals(&quot;gcmemberid&quot;)) {
+			if (tmp != null)
+				password = tmp;
+		} else if (name.equals(&quot;alias2&quot;))
+			myAlias2 = SafeXML.cleanback(atts.getValue(&quot;name&quot;));
+		else if (name.equals(&quot;gcmemberid&quot;)) {
 			gcMemberId = atts.getValue(&quot;name&quot;);
-			tmp=atts.getValue(&quot;Premium&quot;);
-			if (tmp != null) isPremium=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if(name.equals(&quot;location&quot;)){
-			curCentrePt.set(atts.getValue(&quot;lat&quot;)+&quot; &quot;+atts.getValue(&quot;long&quot;));
-		}
-		else if(name.equals(&quot;port&quot;)){
+			tmp = atts.getValue(&quot;Premium&quot;);
+			if (tmp != null)
+				isPremium = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;location&quot;)) {
+			curCentrePt.set(atts.getValue(&quot;lat&quot;) + &quot; &quot; + atts.getValue(&quot;long&quot;));
+		} else if (name.equals(&quot;port&quot;)) {
 			mySPO.portName = atts.getValue(&quot;portname&quot;);
 			mySPO.baudRate = Convert.toInt(atts.getValue(&quot;baud&quot;));
-		}
-		else if(name.equals(&quot;portforward&quot;)) {
+		} else if (name.equals(&quot;portforward&quot;)) {
 			forwardGPS = Convert.toBoolean(atts.getValue(&quot;active&quot;));
 			forwardGpsHost = atts.getValue(&quot;destinationHost&quot;);
-		}
-		else if(name.equals(&quot;gpsd&quot;)) {
+		} else if (name.equals(&quot;gpsd&quot;)) {
 			useGPSD = Convert.toInt(atts.getValue(&quot;active&quot;));
 			gpsdHost = atts.getValue(&quot;host&quot;);
 			gpsdPort = Convert.toInt(atts.getValue(&quot;port&quot;));
-		}
-		else if(name.equals(&quot;portlog&quot;)) {
+		} else if (name.equals(&quot;portlog&quot;)) {
 			logGPS = Convert.toBoolean(atts.getValue(&quot;active&quot;));
 			logGPSTimer = atts.getValue(&quot;logTimer&quot;);
-		}
-		else if (name.equals(&quot;lastprofile&quot;)) {
-			collectElement=new StringBuffer(50);
-			if (atts.getValue(&quot;autoreload&quot;).equals(&quot;true&quot;)) autoReloadLastProfile=true;
-		}
-		else if (name.equals(&quot;CurrentCentre&quot;)) {
-			setCurrentCentreFromGPSPosition=Boolean.valueOf(atts.getValue(&quot;FromGPSPosition&quot;)).booleanValue();
-		}
-		else if(name.equals(&quot;basedir&quot;)) {
+		} else if (name.equals(&quot;lastprofile&quot;)) {
+			collectElement = new StringBuffer(50);
+			if (atts.getValue(&quot;autoreload&quot;).equals(&quot;true&quot;))
+				autoReloadLastProfile = true;
+		} else if (name.equals(&quot;CurrentCentre&quot;)) {
+			setCurrentCentreFromGPSPosition = Boolean.valueOf(atts.getValue(&quot;FromGPSPosition&quot;)).booleanValue();
+		} else if (name.equals(&quot;basedir&quot;)) {
 			setBaseDir(atts.getValue(&quot;dir&quot;));
-		}
-		else if (name.equals(&quot;opencaching&quot;)) {
-			tmp=atts.getValue(&quot;lastSite&quot;);
-			if (!(tmp == null) &amp;&amp; OC.getSiteIndex(tmp)&gt;=0 ) lastOCSite=tmp;
-			tmp=atts.getValue(&quot;downloadMissing&quot;);
-			if (!(tmp == null)) downloadMissingOC = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;listview&quot;)) {
-			listColMap=atts.getValue(&quot;colmap&quot;);
-			listColWidth=atts.getValue(&quot;colwidths&quot;);
-			while ((new StringTokenizer(listColWidth,&quot;,&quot;)).countTokens()&lt;myTableModel.N_COLUMNS) listColWidth+=&quot;,30&quot;; // for older versions
-		}
-		else if(name.equals(&quot;proxy&quot;)) {
+		} else if (name.equals(&quot;opencaching&quot;)) {
+			tmp = atts.getValue(&quot;lastSite&quot;);
+			if (!(tmp == null) &amp;&amp; OC.getSiteIndex(tmp) &gt;= 0)
+				lastOCSite = tmp;
+			tmp = atts.getValue(&quot;downloadMissing&quot;);
+			if (!(tmp == null))
+				downloadAllOC = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;listview&quot;)) {
+			listColMap = atts.getValue(&quot;colmap&quot;);
+			listColWidth = atts.getValue(&quot;colwidths&quot;);
+			while ((new StringTokenizer(listColWidth, &quot;,&quot;)).countTokens() &lt; myTableModel.N_COLUMNS)
+				listColWidth += &quot;,30&quot;; // for older versions
+		} else if (name.equals(&quot;proxy&quot;)) {
 			myproxy = atts.getValue(&quot;prx&quot;);
 			myproxyport = atts.getValue(&quot;prt&quot;);
 			tmp = atts.getValue(&quot;active&quot;);
-			if (tmp != null) proxyActive=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;garmin&quot;)) {
-			garminConn=atts.getValue(&quot;connection&quot;);
+			if (tmp != null)
+				proxyActive = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;garmin&quot;)) {
+			garminConn = atts.getValue(&quot;connection&quot;);
 			tmp = atts.getValue(&quot;GPSBabelOptions&quot;);
-			if (tmp != null) garminGPSBabelOptions=tmp;
+			if (tmp != null)
+				garminGPSBabelOptions = tmp;
 			tmp = atts.getValue(&quot;MaxWaypointLength&quot;);
-			if (tmp != null) garminMaxLen=Convert.toInt(tmp);
+			if (tmp != null)
+				garminMaxLen = Convert.toInt(tmp);
 			tmp = atts.getValue(&quot;addDetailsToWaypoint&quot;);
-			if (tmp != null) addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				addDetailsToWaypoint = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue(&quot;addDetailsToName&quot;);
-			if (tmp != null) addDetailsToName = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;imagepanel&quot;)) {
+			if (tmp != null)
+				addDetailsToName = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;imagepanel&quot;)) {
 			showDeletedImages = Boolean.valueOf(atts.getValue(&quot;showdeletedimages&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;descpanel&quot;)) {
+		} else if (name.equals(&quot;descpanel&quot;)) {
 			descShowImg = Boolean.valueOf(atts.getValue(&quot;showimages&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;screen&quot;)) {
-			menuAtTop=Boolean.valueOf(atts.getValue(&quot;menuattop&quot;)).booleanValue();
-			tabsAtTop=Boolean.valueOf(atts.getValue(&quot;tabsattop&quot;)).booleanValue();
-			showStatus=Boolean.valueOf(atts.getValue(&quot;showstatus&quot;)).booleanValue();
-			if (atts.getValue(&quot;hasclosebutton&quot;)!=null)
-				hasCloseButton=Boolean.valueOf(atts.getValue(&quot;hasclosebutton&quot;)).booleanValue();
-			if (atts.getValue(&quot;h&quot;)!=null) {
-				myAppHeight=Convert.toInt(atts.getValue(&quot;h&quot;));
-				myAppWidth=Convert.toInt(atts.getValue(&quot;w&quot;));
+		} else if (name.equals(&quot;screen&quot;)) {
+			menuAtTop = Boolean.valueOf(atts.getValue(&quot;menuattop&quot;)).booleanValue();
+			tabsAtTop = Boolean.valueOf(atts.getValue(&quot;tabsattop&quot;)).booleanValue();
+			showStatus = Boolean.valueOf(atts.getValue(&quot;showstatus&quot;)).booleanValue();
+			if (atts.getValue(&quot;hasclosebutton&quot;) != null)
+				hasCloseButton = Boolean.valueOf(atts.getValue(&quot;hasclosebutton&quot;)).booleanValue();
+			if (atts.getValue(&quot;h&quot;) != null) {
+				myAppHeight = Convert.toInt(atts.getValue(&quot;h&quot;));
+				myAppWidth = Convert.toInt(atts.getValue(&quot;w&quot;));
 			}
-		}
-		else if (name.equals(&quot;hintlogpanel&quot;)) {
+			if (atts.getValue(&quot;useBigIcons&quot;) != null)
+				useBigIcons = Boolean.valueOf(atts.getValue(&quot;useBigIcons&quot;)).booleanValue();
+			else {
+				useBigIcons = MyLocale.getScreenWidth() &gt;= 400 &amp;&amp; Vm.isMobile();
+			}
+			if (atts.getValue(&quot;useRadar&quot;) != null)
+				useRadar = Boolean.valueOf(atts.getValue(&quot;useRadar&quot;)).booleanValue();
+			else {
+				useRadar = MyLocale.getScreenWidth() &gt;= 400 &amp;&amp; Vm.isMobile();
+			}
+		} else if (name.equals(&quot;hintlogpanel&quot;)) {
 			logsPerPage = Convert.parseInt(atts.getValue(&quot;logsperpage&quot;));
-			String strInitialHintHeight=atts.getValue(&quot;initialhintheight&quot;);
-			if (strInitialHintHeight!=null) initialHintHeight=Convert.parseInt(strInitialHintHeight);
-			String strMaxLogsToSpider=atts.getValue(&quot;maxspiderlogs&quot;);
-			if (strMaxLogsToSpider!=null) maxLogsToSpider=Convert.parseInt(strMaxLogsToSpider);
-		}
-		else if (name.equals(&quot;solver&quot;)) {
-			solverIgnoreCase=Boolean.valueOf(atts.getValue(&quot;ignorevariablecase&quot;)).booleanValue();
+			String strInitialHintHeight = atts.getValue(&quot;initialhintheight&quot;);
+			if (strInitialHintHeight != null)
+				initialHintHeight = Convert.parseInt(strInitialHintHeight);
+			String strMaxLogsToSpider = atts.getValue(&quot;maxspiderlogs&quot;);
+			if (strMaxLogsToSpider != null)
+				maxLogsToSpider = Convert.parseInt(strMaxLogsToSpider);
+		} else if (name.equals(&quot;solver&quot;)) {
+			solverIgnoreCase = Boolean.valueOf(atts.getValue(&quot;ignorevariablecase&quot;)).booleanValue();
 			tmp = atts.getValue(&quot;degMode&quot;);
-			if (tmp != null) solverDegMode=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;mapspath&quot;)) {
-			customMapsPath=SafeXML.cleanback(atts.getValue(&quot;dir&quot;)).replace('\\', '/');
-		}
-		else if (name.equals(&quot;debug&quot;)) debug=Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
+			if (tmp != null)
+				solverDegMode = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;mapspath&quot;)) {
+			customMapsPath = SafeXML.cleanback(atts.getValue(&quot;dir&quot;)).replace('\\', '/');
+		} else if (name.equals(&quot;debug&quot;))
+			debug = Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
 
-		else if (name.equals(&quot;expPath&quot;)){
-			exporterPaths.put(atts.getValue(&quot;key&quot;),atts.getValue(&quot;value&quot;));
-		}
-		else if (name.equals(&quot;impPath&quot;)) {
+		else if (name.equals(&quot;expPath&quot;)) {
+			exporterPaths.put(atts.getValue(&quot;key&quot;), atts.getValue(&quot;value&quot;));
+		} else if (name.equals(&quot;impPath&quot;)) {
 			importerPaths.put(atts.getValue(&quot;key&quot;), atts.getValue(&quot;value&quot;));
-		}
-		else if (name.equals(&quot;travelbugs&quot;)) {
-			travelbugColMap=atts.getValue(&quot;colmap&quot;);
-			travelbugColWidth=atts.getValue(&quot;colwidths&quot;);
-			travelbugShowOnlyNonLogged=Boolean.valueOf(atts.getValue(&quot;shownonlogged&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;gotopanel&quot;)) {
+		} else if (name.equals(&quot;travelbugs&quot;)) {
+			travelbugColMap = atts.getValue(&quot;colmap&quot;);
+			travelbugColWidth = atts.getValue(&quot;colwidths&quot;);
+			travelbugShowOnlyNonLogged = Boolean.valueOf(atts.getValue(&quot;shownonlogged&quot;)).booleanValue();
+		} else if (name.equals(&quot;gotopanel&quot;)) {
 			northCenteredGoto = Boolean.valueOf(atts.getValue(&quot;northcentered&quot;)).booleanValue();
-		}
-		else if (name.equals(&quot;spider&quot;)) {
+		} else if (name.equals(&quot;spider&quot;)) {
+			doNotGetFound = !Boolean.valueOf(atts.getValue(&quot;getFinds&quot;)).booleanValue();
 			forceLogin = Boolean.valueOf(atts.getValue(&quot;forcelogin&quot;)).booleanValue();
 			checkLog = Boolean.valueOf(atts.getValue(&quot;checkLog&quot;)).booleanValue();
-      tmp = atts.getValue(&quot;checkTBs&quot;);
-			if (tmp != null) Boolean.valueOf(atts.getValue(&quot;checkTBs&quot;)).booleanValue();
+			tmp = atts.getValue(&quot;checkTBs&quot;);
+			if (tmp != null)
+				checkTBs = Boolean.valueOf(atts.getValue(&quot;checkTBs&quot;)).booleanValue();
+			tmp = atts.getValue(&quot;checkDTS&quot;);
+			if (tmp != null)
+				checkDTS = Boolean.valueOf(atts.getValue(&quot;checkDTS&quot;)).booleanValue();
 			spiderRoute = Boolean.valueOf(atts.getValue(&quot;spiderRoute&quot;)).booleanValue();
 			tmp = atts.getValue(&quot;spiderUpdates&quot;);
-			if (tmp != null) spiderUpdates=Convert.parseInt(tmp);
+			if (tmp != null)
+				spiderUpdates = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;maxSpiderNumber&quot;);
-			if (tmp != null) maxSpiderNumber=Convert.parseInt(tmp);
+			if (tmp != null)
+				maxSpiderNumber = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;downloadPics&quot;);
-			if (tmp != null) downloadPics=Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				downloadPics = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue(&quot;downloadTBs&quot;);
-			if (tmp != null) downloadTBs=Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;details&quot;)) {
-			maxDetails=Common.parseInt(atts.getValue(&quot;cacheSize&quot;));
-			deleteDetails=Common.parseInt(atts.getValue(&quot;delete&quot;));
-			if (maxDetails&lt;2) maxDetails=2;
-			if (deleteDetails&lt;1) deleteDetails=1;
-		}
-		else if (name.equals(&quot;metric&quot;)) {
-			metricSystem=Common.parseInt(atts.getValue(&quot;type&quot;));
-			if (metricSystem != Metrics.METRIC &amp;&amp;
-					metricSystem != Metrics.IMPERIAL) {
+			if (tmp != null)
+				downloadTBs = Boolean.valueOf(tmp).booleanValue();
+			userID = atts.getValue(&quot;UserID&quot;);
+			if (userID == null)
+				userID = &quot;&quot;;
+		} else if (name.equals(&quot;details&quot;)) {
+			maxDetails = Common.parseInt(atts.getValue(&quot;cacheSize&quot;));
+			deleteDetails = Common.parseInt(atts.getValue(&quot;delete&quot;));
+			if (maxDetails &lt; 2)
+				maxDetails = 2;
+			if (deleteDetails &lt; 1)
+				deleteDetails = 1;
+		} else if (name.equals(&quot;metric&quot;)) {
+			metricSystem = Common.parseInt(atts.getValue(&quot;type&quot;));
+			if (metricSystem != Metrics.METRIC &amp;&amp; metricSystem != Metrics.IMPERIAL) {
 				metricSystem = Metrics.METRIC;
 			}
-		}
-		else if (name.equals(&quot;export&quot;)) {
+		} else if (name.equals(&quot;export&quot;)) {
 			tmp = atts.getValue(&quot;numberOfLogsToExport&quot;);
-			if (tmp != null) numberOfLogsToExport=Convert.parseInt(tmp);
+			if (tmp != null)
+				numberOfLogsToExport = Convert.parseInt(tmp);
 			tmp = atts.getValue(&quot;exportTravelbugs&quot;);
-			if (tmp != null) exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
+			if (tmp != null)
+				exportTravelbugs = Boolean.valueOf(tmp).booleanValue();
 			tmp = atts.getValue(&quot;exportGpxAsMyFinds&quot;);
-			if (tmp != null) exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;locale&quot;)) {
+			if (tmp != null)
+				exportGpxAsMyFinds = Boolean.valueOf(tmp).booleanValue();
+		} else if (name.equals(&quot;locale&quot;)) {
 			language = atts.getValue(&quot;language&quot;);
-		}
-		else if (name.equals(&quot;FILTERDATA&quot;)) {
+		} else if (name.equals(&quot;FILTERDATA&quot;)) {
 			// Creating a filter object and reading the saved data
 			String id = SafeXML.cleanback(atts.getValue(&quot;id&quot;));
 			FilterData data = new FilterData();
@@ -609,7 +668,7 @@
 			data.setFilterDiff(atts.getValue(&quot;diff&quot;));
 			data.setFilterTerr(atts.getValue(&quot;terr&quot;));
 			data.setFilterSize(atts.getValue(&quot;size&quot;));
-			long[] filterAttr = { 0l,0l,0l,0l };
+			long[] filterAttr = { 0l, 0l, 0l, 0l };
 			filterAttr[0] = getLongAttr(atts, &quot;attributesYes&quot;);
 			filterAttr[1] = getLongAttr(atts, &quot;attributesYes1&quot;);
 			filterAttr[2] = getLongAttr(atts, &quot;attributesNo&quot;);
@@ -620,178 +679,272 @@
 			data.setUseRegexp(Boolean.valueOf(atts.getValue(&quot;useRegexp&quot;)).booleanValue());
 			tmp = atts.getValue(&quot;noCoord&quot;);
 			if (tmp != null) {
-			  data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
-      } else {
-			  data.setFilterNoCoord(true);
-      }
+				data.setFilterNoCoord(Boolean.valueOf(tmp).booleanValue());
+			} else {
+				data.setFilterNoCoord(true);
+			}
 			// Filter object is remembered under the given ID
 			this.addFilter(id, data);
-		}
-		else if (name.equals (&quot;datamover&quot;)){
+		} else if (name.equals(&quot;datamover&quot;)) {
 			tmp = atts.getValue(&quot;processorMode&quot;);
-			if (tmp != null){
-				processorMode=Convert.parseInt(tmp);
+			if (tmp != null) {
+				processorMode = Convert.parseInt(tmp);
 			}
-		}
-		else if (name.equals(&quot;logkeeping&quot;)) {
+		} else if (name.equals(&quot;logkeeping&quot;)) {
 			tmp = atts.getValue(&quot;maximum&quot;);
 			if (tmp != null)
 				maxLogsToKeep = Convert.parseInt(tmp);
-			if (maxLogsToKeep &lt; 0) maxLogsToKeep = 0;
+			if (maxLogsToKeep &lt; 0)
+				maxLogsToKeep = 0;
 
 			tmp = atts.getValue(&quot;keepown&quot;);
 			if (tmp != null)
 				alwaysKeepOwnLogs = Boolean.valueOf(tmp).booleanValue();
-		}
-		else if (name.equals(&quot;fillWhiteArea&quot;)){
+		} else if (name.equals(&quot;fillWhiteArea&quot;)) {
 			tmp = atts.getValue(&quot;on&quot;);
 			fillWhiteArea = tmp != null &amp;&amp; tmp.equalsIgnoreCase(&quot;true&quot;);
-		}
-		else if (name.equals(&quot;mapLoader&quot;)){
-			     tmp = atts.getValue(&quot;tileSize&quot;);
-			     if (tmp == null || tmp.length() == 0) tmp = &quot;1&quot;;
-			     mapTileSize = Convert.parseInt(tmp);
-                 tmp = atts.getValue(&quot;overlapping&quot;);
-			     if (tmp == null || tmp.length() == 0) tmp = &quot;100&quot;;
-			     mapOverlapping = Convert.parseInt(tmp);
-			     tmp = atts.getValue(&quot;tilewidth&quot;);
-			     tilewidth= (tmp != null &amp;&amp; tmp.length() &gt; 0)?Convert.parseInt(tmp):0;
-			     tmp = atts.getValue(&quot;tileheight&quot;);
-			     tileheight= (tmp != null &amp;&amp; tmp.length() &gt; 0)?Convert.parseInt(tmp):0;			    	 
-		}
-		else if (name.equals(&quot;showCachesOnMap&quot;)){
+		} else if (name.equals(&quot;mapLoader&quot;)) {
+			tmp = atts.getValue(&quot;tileSize&quot;);
+			if (tmp == null || tmp.length() == 0)
+				tmp = &quot;1&quot;;
+			mapTileSize = Convert.parseInt(tmp);
+			tmp = atts.getValue(&quot;overlapping&quot;);
+			if (tmp == null || tmp.length() == 0)
+				tmp = &quot;100&quot;;
+			mapOverlapping = Convert.parseInt(tmp);
+			tmp = atts.getValue(&quot;tilewidth&quot;);
+			tilewidth = (tmp != null &amp;&amp; tmp.length() &gt; 0) ? Convert.parseInt(tmp) : 0;
+			tmp = atts.getValue(&quot;tileheight&quot;);
+			tileheight = (tmp != null &amp;&amp; tmp.length() &gt; 0) ? Convert.parseInt(tmp) : 0;
+		} else if (name.equals(&quot;showCachesOnMap&quot;)) {
 			tmp = atts.getValue(&quot;on&quot;);
 			showCachesOnMap = tmp != null &amp;&amp; tmp.equalsIgnoreCase(&quot;true&quot;);
-		}
-		else if (name.equals(&quot;SortingGroupedByCache&quot;)){
+		} else if (name.equals(&quot;SortingGroupedByCache&quot;)) {
 			tmp = atts.getValue(&quot;on&quot;);
 			SortingGroupedByCache = tmp != null &amp;&amp; tmp.equalsIgnoreCase(&quot;true&quot;);
-		}
-		else if (name.equals(&quot;Symbols&quot;)) {
-			useOwnSymbols=Boolean.valueOf(atts.getValue(&quot;useOwnSymbols&quot;)).booleanValue();
-		}
+		} else if (name.equals(&quot;Symbols&quot;)) {
+			useOwnSymbols = Boolean.valueOf(atts.getValue(&quot;useOwnSymbols&quot;)).booleanValue();
+		} else if (name.equals(&quot;MobileGui&quot;))
+			mobileGUI = Boolean.valueOf(atts.getValue(&quot;value&quot;)).booleanValue();
 	}
 
-	public void characters( char ch[], int start, int length ) {
-		if (collectElement!=null) {
-			collectElement.append(ch,start,length); // Collect the name of the last profile
+	public void characters(char ch[], int start, int length) {
+		if (collectElement != null) {
+			// Collect the name of the last profile
+			collectElement.append(ch, start, length);
 		}
 	}
 
 	/**
 	 * Method that gets called when the end of an element has been identified in pref.xml
 	 */
-	public void endElement(String tag){
+	public void endElement(String tag) {
 		if (tag.equals(&quot;lastprofile&quot;)) {
-			if (collectElement!=null) lastProfile=collectElement.toString();
+			if (collectElement != null)
+				lastProfile = collectElement.toString();
 		}
-		collectElement=null;
+		collectElement = null;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Write pref.xml file
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Write pref.xml file
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/**
 	 * Method to save current preferences in the pref.xml file
 	 */
-	public void savePreferences(){
-		if (pathToConfigFile == null) setPathToConfigFile(null); // this sets the default value
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
-			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;);
-			outp.print(&quot;&lt;preferences&gt;\n&quot;);
-			outp.print(&quot;    &lt;locale language=\&quot;&quot; + SafeXML.clean(language) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;basedir dir = \&quot;&quot; + SafeXML.clean(getBaseDir()) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;lastprofile autoreload=\&quot;&quot; + SafeXML.strxmlencode(autoReloadLastProfile) + &quot;\&quot;&gt;&quot; + SafeXML.clean(lastProfile) + &quot;&lt;/lastprofile&gt;\n&quot;); //RB
-			outp.print(&quot;    &lt;CurrentCentre FromGPSPosition=\&quot;&quot; + SafeXML.clean(Convert.toString(setCurrentCentreFromGPSPosition)) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;alias name =\&quot;&quot;+ SafeXML.clean(myAlias) +&quot;\&quot; password=\&quot;&quot;+SafeXML.clean(password)+&quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;alias2 name =\&quot;&quot;+ SafeXML.clean(myAlias2) +&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;gcmemberid name =\&quot;&quot;+ SafeXML.clean(gcMemberId) + &quot;\&quot;&quot; + &quot; Premium =\&quot;&quot;+ SafeXML.strxmlencode(isPremium) +&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;browser name = \&quot;&quot; + SafeXML.clean(browser) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;proxy prx = \&quot;&quot; + SafeXML.clean(myproxy) + &quot;\&quot; prt = \&quot;&quot; + SafeXML.clean(myproxyport) + &quot;\&quot; active = \&quot;&quot; + SafeXML.strxmlencode(proxyActive) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;port portname = \&quot;&quot; + SafeXML.clean(mySPO.portName) + &quot;\&quot; baud = \&quot;&quot; + SafeXML.strxmlencode(mySPO.baudRate) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;portforward active= \&quot;&quot; + SafeXML.clean(Convert.toString(forwardGPS)) + &quot;\&quot; destinationHost = \&quot;&quot; + SafeXML.clean(forwardGpsHost) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;gpsd active= \&quot;&quot; + SafeXML.strxmlencode(useGPSD) + &quot;\&quot; host = \&quot;&quot; + SafeXML.clean(gpsdHost) + &quot;\&quot; port = \&quot;&quot; + SafeXML.strxmlencode(gpsdPort) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;portlog active= \&quot;&quot; + SafeXML.clean(Convert.toString(logGPS)) + &quot;\&quot; logTimer = \&quot;&quot; + SafeXML.clean(logGPSTimer) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;font size =\&quot;&quot; + SafeXML.strxmlencode(fontSize) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;screen menuattop=\&quot;&quot;+menuAtTop+&quot;\&quot; tabsattop=\&quot;&quot;+tabsAtTop+&quot;\&quot; showstatus=\&quot;&quot;+showStatus+&quot;\&quot; hasclosebutton=\&quot;&quot;+hasCloseButton+
-	                &quot;\&quot; h=\&quot;&quot;+myAppHeight+&quot;\&quot; w=\&quot;&quot;+myAppWidth+&quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;fixedsip state = \&quot;&quot; + SafeXML.strxmlencode(fixSIP) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;listview colmap=\&quot;&quot; + SafeXML.clean(listColMap) + &quot;\&quot; colwidths=\&quot;&quot; + SafeXML.clean(listColWidth) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;travelbugs colmap=\&quot;&quot; + SafeXML.clean(travelbugColMap) + &quot;\&quot; colwidths=\&quot;&quot; + SafeXML.clean(travelbugColWidth) + &quot;\&quot; shownonlogged=\&quot;&quot; + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + &quot;\&quot; /&gt;\n&quot;);
+	public void savePreferences() {
+		if (pathToConfigFile == null)
+			setPathToConfigFile(null); // this sets the default value
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(pathToConfigFile)));
+			outp.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot; //
+					+ &quot;&lt;preferences&gt;\n&quot; //
+					+ &quot;    &lt;locale language=\&quot;&quot; + SafeXML.clean(language) + &quot;\&quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;basedir dir=\&quot;&quot; + SafeXML.clean(getBaseDir()) + &quot;\&quot; /&gt;\n&quot;//
+
+					+ &quot;    &lt;lastprofile&quot; //
+					+ &quot; autoreload=\&quot;&quot; + SafeXML.strxmlencode(autoReloadLastProfile) + &quot;\&quot;&quot; //
+					+ &quot;&gt;&quot; //
+					+ SafeXML.clean(lastProfile) + &quot;&lt;/ lastprofile&gt;\n&quot; //
+
+					+ &quot;    &lt;CurrentCentre&quot; //
+					+ &quot; FromGPSPosition=\&quot;&quot; + SafeXML.strxmlencode(setCurrentCentreFromGPSPosition) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;alias&quot; //
+					+ &quot; name=\&quot;&quot; + SafeXML.clean(myAlias) + &quot;\&quot;&quot; //
+					+ &quot; password=\&quot;&quot; + SafeXML.clean(password) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;alias2 name=\&quot;&quot; + SafeXML.clean(myAlias2) + &quot;\&quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;gcmemberid&quot; //
+					+ &quot; name=\&quot;&quot; + SafeXML.clean(gcMemberId) + &quot;\&quot;&quot; //
+					+ &quot; Premium=\&quot;&quot; + SafeXML.strxmlencode(isPremium) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;browser name=\&quot;&quot; + SafeXML.clean(browser) + &quot;\&quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;proxy&quot; //
+					+ &quot; prx=\&quot;&quot; + SafeXML.clean(myproxy) + &quot;\&quot;&quot; //
+					+ &quot; prt=\&quot;&quot; + SafeXML.clean(myproxyport) + &quot;\&quot;&quot; //
+					+ &quot; active=\&quot;&quot; + SafeXML.strxmlencode(proxyActive) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;port&quot; //
+					+ &quot; portname=\&quot;&quot; + SafeXML.clean(mySPO.portName) + &quot;\&quot;&quot; //
+					+ &quot; baud=\&quot;&quot; + SafeXML.strxmlencode(mySPO.baudRate) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;portforward&quot; //
+					+ &quot; active=\&quot;&quot; + SafeXML.strxmlencode(forwardGPS) + &quot;\&quot;&quot; //
+					+ &quot; destinationHost=\&quot;&quot; + SafeXML.clean(forwardGpsHost) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;gpsd&quot; //
+					+ &quot; active=\&quot;&quot; + SafeXML.strxmlencode(useGPSD) + &quot;\&quot;&quot; //
+					+ &quot; host=\&quot;&quot; + SafeXML.clean(gpsdHost) + &quot;\&quot;&quot; //
+					+ &quot; port=\&quot;&quot; + SafeXML.strxmlencode(gpsdPort) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;portlog&quot; //
+					+ &quot; active=\&quot;&quot; + SafeXML.strxmlencode(logGPS) + &quot;\&quot;&quot; //
+					+ &quot; logTimer=\&quot;&quot; + SafeXML.clean(logGPSTimer) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;font&quot; //
+					+ &quot; name=\&quot;&quot; + fontName + &quot;\&quot;&quot; //
+					+ &quot; size=\&quot;&quot; + SafeXML.strxmlencode(fontSize) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;screen&quot; //
+					+ &quot; menuattop=\&quot;&quot; + menuAtTop + &quot;\&quot;&quot; //
+					+ &quot; tabsattop=\&quot;&quot; + tabsAtTop + &quot;\&quot;&quot; //
+					+ &quot; showstatus=\&quot;&quot; + showStatus + &quot;\&quot;&quot; //
+					+ &quot; hasclosebutton=\&quot;&quot; + hasCloseButton + &quot;\&quot;&quot; //
+					+ &quot; h=\&quot;&quot; + myAppHeight + &quot;\&quot;&quot; //
+					+ &quot; w=\&quot;&quot; + myAppWidth + &quot;\&quot;&quot; //
+					+ &quot; useBigIcons=\&quot;&quot; + useBigIcons + &quot;\&quot;&quot; //
+					+ &quot; useRadar=\&quot;&quot; + useRadar + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;fixedsip state=\&quot;&quot; + SafeXML.strxmlencode(fixSIP) + &quot;\&quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;listview&quot; //
+					+ &quot; colmap=\&quot;&quot; + SafeXML.clean(listColMap) + &quot;\&quot;&quot; //
+					+ &quot; colwidths=\&quot;&quot; + SafeXML.clean(listColWidth) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot; //
+
+					+ &quot;    &lt;travelbugs&quot; //
+					+ &quot; colmap=\&quot;&quot; + SafeXML.clean(travelbugColMap) + &quot;\&quot;&quot; //
+					+ &quot; colwidths=\&quot;&quot; + SafeXML.clean(travelbugColWidth) + &quot;\&quot;&quot; //
+					+ &quot; shownonlogged=\&quot;&quot; + SafeXML.strxmlencode(travelbugShowOnlyNonLogged) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot;);
+
 			outp.print(&quot;    &lt;descpanel showimages=\&quot;&quot; + SafeXML.strxmlencode(descShowImg) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;imagepanel showdeletedimages=\&quot;&quot; + SafeXML.strxmlencode(showDeletedImages) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;hintlogpanel logsperpage=\&quot;&quot; + SafeXML.strxmlencode(logsPerPage) + &quot;\&quot; initialhintheight=\&quot;&quot; + SafeXML.strxmlencode(initialHintHeight) + &quot;\&quot;  maxspiderlogs=\&quot;&quot; + SafeXML.strxmlencode(maxLogsToSpider) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;imagepanel showdeletedimages=\&quot;&quot; + SafeXML.strxmlencode(showDeletedImages) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;hintlogpanel&quot;//
+					+ &quot; logsperpage=\&quot;&quot; + SafeXML.strxmlencode(logsPerPage) + &quot;\&quot;&quot; //
+					+ &quot; initialhintheight=\&quot;&quot; + SafeXML.strxmlencode(initialHintHeight) + &quot;\&quot;&quot; //
+					+ &quot; maxspiderlogs=\&quot;&quot; + SafeXML.strxmlencode(maxLogsToSpider) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;solver ignorevariablecase=\&quot;&quot; + SafeXML.strxmlencode(solverIgnoreCase) + &quot;\&quot; degMode=\&quot;&quot; + SafeXML.strxmlencode(solverDegMode) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;garmin connection = \&quot;&quot; + SafeXML.clean(garminConn) + &quot;\&quot; GPSBabelOptions = \&quot;&quot; + SafeXML.clean(garminGPSBabelOptions) + &quot;\&quot; MaxWaypointLength = \&quot;&quot; + SafeXML.strxmlencode(garminMaxLen) +
-					        &quot;\&quot; addDetailsToWaypoint = \&quot;&quot; + SafeXML.strxmlencode(addDetailsToWaypoint) + &quot;\&quot; addDetailsToName = \&quot;&quot; + SafeXML.strxmlencode(addDetailsToName) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;opencaching lastSite=\&quot;&quot;+lastOCSite+&quot;\&quot; downloadMissing=\&quot;&quot; + SafeXML.strxmlencode(downloadMissingOC) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;location lat = \&quot;&quot; + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + &quot;\&quot; long = \&quot;&quot; + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;spider forcelogin=\&quot;&quot; + SafeXML.strxmlencode(forceLogin) + &quot;\&quot; spiderUpdates=\&quot;&quot; + SafeXML.strxmlencode(spiderUpdates) + &quot;\&quot; checkLog=\&quot;&quot; + SafeXML.strxmlencode(checkLog) + &quot;\&quot; checkTBs=\&quot;&quot; + SafeXML.strxmlencode(checkTBs) + &quot;\&quot; spiderRoute=\&quot;&quot; + SafeXML.strxmlencode(spiderRoute) + &quot;\&quot; maxSpiderNumber=\&quot;&quot; + SafeXML.strxmlencode(maxSpiderNumber) + &quot;\&quot; downloadPics=\&quot;&quot; + SafeXML.strxmlencode(downloadPics) + &quot;\&quot; downloadTBs=\&quot;&quot; + SafeXML.strxmlencode(downloadTBs) +&quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;garmin&quot; //
+					+ &quot; connection=\&quot;&quot; + SafeXML.clean(garminConn) + &quot;\&quot;&quot; //
+					+ &quot; GPSBabelOptions=\&quot;&quot; + SafeXML.clean(garminGPSBabelOptions) + &quot;\&quot;&quot; //
+					+ &quot; MaxWaypointLength=\&quot;&quot; + SafeXML.strxmlencode(garminMaxLen) + &quot;\&quot;&quot; //
+					+ &quot; addDetailsToWaypoint=\&quot;&quot; + SafeXML.strxmlencode(addDetailsToWaypoint) + &quot;\&quot;&quot; //
+					+ &quot; addDetailsToName=\&quot;&quot; + SafeXML.strxmlencode(addDetailsToName) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;opencaching lastSite=\&quot;&quot; + lastOCSite + &quot;\&quot; downloadMissing=\&quot;&quot; + SafeXML.strxmlencode(downloadAllOC) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;location lat=\&quot;&quot; + SafeXML.clean(curCentrePt.getLatDeg(TransformCoordinates.DD)) + &quot;\&quot; long=\&quot;&quot; + SafeXML.clean(curCentrePt.getLonDeg(TransformCoordinates.DD)) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;spider&quot; //
+					+ &quot; forcelogin=\&quot;&quot; + SafeXML.strxmlencode(forceLogin) + &quot;\&quot;&quot; //
+					+ &quot; spiderUpdates=\&quot;&quot; + SafeXML.strxmlencode(spiderUpdates) + &quot;\&quot;&quot; //
+					+ &quot; checkLog=\&quot;&quot; + SafeXML.strxmlencode(checkLog) + &quot;\&quot;&quot; //
+					+ &quot; checkTBs=\&quot;&quot; + SafeXML.strxmlencode(checkTBs) + &quot;\&quot;&quot; //
+					+ &quot; checkDTS=\&quot;&quot; + SafeXML.strxmlencode(checkDTS) + &quot;\&quot;&quot; //
+					+ &quot; spiderRoute=\&quot;&quot; + SafeXML.strxmlencode(spiderRoute) + &quot;\&quot;&quot; //
+					+ &quot; maxSpiderNumber=\&quot;&quot; + SafeXML.strxmlencode(maxSpiderNumber) + &quot;\&quot;&quot; //
+					+ &quot; downloadPics=\&quot;&quot; + SafeXML.strxmlencode(downloadPics) + &quot;\&quot;&quot; //
+					+ &quot; downloadTBs=\&quot;&quot; + SafeXML.strxmlencode(downloadTBs) + &quot;\&quot;&quot; //
+					+ &quot; UserID=\&quot;&quot; + SafeXML.clean(userID) + &quot;\&quot;&quot; //
+					+ &quot; getFinds=\&quot;&quot; + SafeXML.strxmlencode(!doNotGetFound) + &quot;\&quot;&quot; //
+					+ &quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;gotopanel northcentered=\&quot;&quot; + SafeXML.strxmlencode(northCenteredGoto) + &quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;details cacheSize=\&quot;&quot; + SafeXML.strxmlencode(maxDetails) + &quot;\&quot; delete=\&quot;&quot; + SafeXML.strxmlencode(deleteDetails) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;metric type=\&quot;&quot; + SafeXML.strxmlencode(metricSystem) + &quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;export numberOfLogsToExport=\&quot;&quot; + SafeXML.strxmlencode(numberOfLogsToExport) + &quot;\&quot; exportTravelbugs=\&quot;&quot; + SafeXML.strxmlencode(exportTravelbugs) + &quot;\&quot; exportGpxAsMyFinds=\&quot;&quot; + SafeXML.strxmlencode(exportGpxAsMyFinds) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;details cacheSize=\&quot;&quot; + SafeXML.strxmlencode(maxDetails) + &quot;\&quot; delete=\&quot;&quot; + SafeXML.strxmlencode(deleteDetails) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;metric type=\&quot;&quot; + SafeXML.strxmlencode(metricSystem) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;export numberOfLogsToExport=\&quot;&quot; + SafeXML.strxmlencode(numberOfLogsToExport) + &quot;\&quot; exportTravelbugs=\&quot;&quot; + SafeXML.strxmlencode(exportTravelbugs) + &quot;\&quot; exportGpxAsMyFinds=\&quot;&quot; + SafeXML.strxmlencode(exportGpxAsMyFinds)
+					+ &quot;\&quot; /&gt;\n&quot;);
 			outp.print(&quot;    &lt;datamover processorMode=\&quot;&quot; + SafeXML.strxmlencode(processorMode) + &quot;\&quot; /&gt;\n&quot;);
-			if (customMapsPath!=null) outp.print(&quot;    &lt;mapspath dir = \&quot;&quot; + SafeXML.clean(customMapsPath.replace('\\','/')) + &quot;\&quot;/&gt;\n&quot;);
+			if (customMapsPath != null)
+				outp.print(&quot;    &lt;mapspath dir=\&quot;&quot; + SafeXML.clean(customMapsPath.replace('\\', '/')) + &quot;\&quot; /&gt;\n&quot;);
 			// Saving filters
 			String[] filterIDs = this.getFilterIDs();
-			for (int i=0; i&lt;filterIDs.length; i++){
+			for (int i = 0; i &lt; filterIDs.length; i++) {
 				outp.print(this.getFilter(filterIDs[i]).toXML(filterIDs[i]));
 			}
-			if (debug) outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;); // Keep the debug switch if it is set
+			if (debug)
+				// Keep the debug switch if it is set
+				outp.print(&quot;    &lt;debug value=\&quot;true\&quot; /&gt;\n&quot;);
 			// save last path of different exporters
 			Iterator itPath = exporterPaths.entries();
 			MapEntry entry;
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
-				outp.print(&quot;    &lt;expPath key = \&quot;&quot; + SafeXML.clean(entry.getKey().toString()) + &quot;\&quot; value = \&quot;&quot; + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
+				outp.print(&quot;    &lt;expPath key = \&quot;&quot; + SafeXML.clean(entry.getKey().toString()) + &quot;\&quot; value = \&quot;&quot; + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + &quot;\&quot; /&gt;\n&quot;);
 			}
 			itPath = importerPaths.entries();
-			while(itPath.hasNext()){
+			while (itPath.hasNext()) {
 				entry = (MapEntry) itPath.next();
-				outp.print(&quot;    &lt;impPath key = \&quot;&quot; + SafeXML.clean(entry.getKey().toString()) + &quot;\&quot; value = \&quot;&quot; + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + &quot;\&quot;/&gt;\n&quot;);
+				outp.print(&quot;    &lt;impPath key = \&quot;&quot; + SafeXML.clean(entry.getKey().toString()) + &quot;\&quot; value = \&quot;&quot; + SafeXML.clean(entry.getValue().toString().replace('\\', '/')) + &quot;\&quot; /&gt;\n&quot;);
 			}
-			outp.print(&quot;    &lt;logkeeping maximum=\&quot;&quot;+SafeXML.strxmlencode(maxLogsToKeep)+&quot;\&quot; keepown=\&quot;&quot;+SafeXML.strxmlencode(alwaysKeepOwnLogs)+&quot;\&quot; /&gt;\n&quot;);
-			outp.print(&quot;    &lt;fillWhiteArea on=\&quot;&quot;+SafeXML.strxmlencode(fillWhiteArea)+&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;mapLoader tileSize=\&quot;&quot;+SafeXML.strxmlencode(mapTileSize)+&quot;\&quot; overlapping=\&quot;&quot;+SafeXML.strxmlencode(mapOverlapping)+&quot;\&quot; tilewidth=\&quot;&quot;+SafeXML.strxmlencode(tilewidth)+&quot;\&quot; tileheight=\&quot;&quot;+SafeXML.strxmlencode(tileheight)+&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;showCachesOnMap on=\&quot;&quot;+SafeXML.strxmlencode(showCachesOnMap)+&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;SortingGroupedByCache on=\&quot;&quot;+SafeXML.strxmlencode(SortingGroupedByCache)+&quot;\&quot;/&gt;\n&quot;);
-			outp.print(&quot;    &lt;Symbols useOwnSymbols=\&quot;&quot; + SafeXML.strxmlencode(useOwnSymbols) + &quot;\&quot;/&gt;\n&quot;);
+			outp.print(&quot;    &lt;logkeeping maximum=\&quot;&quot; + SafeXML.strxmlencode(maxLogsToKeep) + &quot;\&quot; keepown=\&quot;&quot; + SafeXML.strxmlencode(alwaysKeepOwnLogs) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;fillWhiteArea on=\&quot;&quot; + SafeXML.strxmlencode(fillWhiteArea) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;mapLoader tileSize=\&quot;&quot; + SafeXML.strxmlencode(mapTileSize) + &quot;\&quot; overlapping=\&quot;&quot; + SafeXML.strxmlencode(mapOverlapping) + &quot;\&quot; tilewidth=\&quot;&quot; + SafeXML.strxmlencode(tilewidth) + &quot;\&quot; tileheight=\&quot;&quot;
+					+ SafeXML.strxmlencode(tileheight) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;showCachesOnMap on=\&quot;&quot; + SafeXML.strxmlencode(showCachesOnMap) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;SortingGroupedByCache on=\&quot;&quot; + SafeXML.strxmlencode(SortingGroupedByCache) + &quot;\&quot; /&gt;\n&quot;);
+			outp.print(&quot;    &lt;Symbols useOwnSymbols=\&quot;&quot; + SafeXML.strxmlencode(useOwnSymbols) + &quot;\&quot; /&gt;\n&quot;);
+			if (mobileGUI)
+				// Keep the vmgui switch if it is set
+				outp.print(&quot;    &lt;MobileGui value=\&quot;true\&quot; /&gt;\n&quot;);
 			outp.print(&quot;&lt;/preferences&gt;&quot;);
 			outp.close();
 		} catch (Exception e) {
-			log(&quot;Problem saving: &quot; +pathToConfigFile,e,true);
+			log(&quot;Problem saving: &quot; + pathToConfigFile, e, true);
 		}
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Maps
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Maps
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	private static final String mapsPath = &quot;maps/standard&quot;;
 
 	/**
 	 * custom = set by the user
+	 * 
 	 * @return custom Maps Path, null if not set
 	 */
 	public String getCustomMapsPath() {
-	   String rCMP = Global.getProfile().getRelativeCustomMapsPath();
-	   if (rCMP.equals(&quot;&quot;)) {
-		   return customMapsPath;
+		String rCMP = Global.getProfile().getRelativeCustomMapsPath();
+		if (rCMP.equals(&quot;&quot;)) {
+			return customMapsPath;
 		} else {
-			return absoluteBaseDir+&quot;maps&quot;+rCMP;
+			return absoluteBaseDir + &quot;maps&quot; + rCMP;
 		}
 	}
 
 	public void saveCustomMapsPath(String mapspath_) {
 		if (customMapsPath == null || !customMapsPath.equals(mapspath_)) {
-			customMapsPath=new String(mapspath_).replace('\\', '/');
+			customMapsPath = new String(mapspath_).replace('\\', '/');
 			savePreferences();
-			String s = absoluteBaseDir+&quot;maps&quot;;
-			if (customMapsPath.indexOf(s)==0) {
-				String t=customMapsPath.substring(s.length(), customMapsPath.length());
+			String s = absoluteBaseDir + &quot;maps&quot;;
+			if (customMapsPath.indexOf(s) == 0) {
+				String t = customMapsPath.substring(s.length(), customMapsPath.length());
 				Global.getProfile().setRelativeCustomMapsPath(t);
 			} else {
 				Global.getProfile().setRelativeCustomMapsPath(&quot;&quot;);
@@ -800,34 +953,38 @@
 	}
 
 	private myTableModel tableMod;
-	public void setMyTableModel(myTableModel myTableModel) {tableMod=myTableModel;}
-	public CWPoint getCurCentrePt() {return curCentrePt;}
+
+	public void setMyTableModel(myTableModel myTableModel) {
+		tableMod = myTableModel;
+	}
+
+	public CWPoint getCurCentrePt() {
+		return curCentrePt;
+	}
+
 	public void setCurCentrePt(CWPoint newCentre) {
 		Vm.showWait(true);
 		curCentrePt.set(newCentre);
 		Global.getProfile().updateBearingDistance();
 		if (tableMod != null) {
 			// corresponding column for &quot;distance&quot; is column 10
-			if (tableMod.sortedBy == 10) tableMod.isSorted = false;
+			if (tableMod.sortedBy == 10)
+				tableMod.isSorted = false;
 			if (tableMod.sortedBy == 10 &amp;&amp; this.sortAutomatic) {
 				tableMod.sortTable(tableMod.sortedBy, tableMod.sortAscending);
 				// or ??? TablePanel.refreshTable();
-			}
-			else tableMod.tcControl.repaint();
+			} else
+				tableMod.tcControl.repaint();
 		}
 		Vm.showWait(false);
 	}
 
 	/**
-	 * gets the path to the calibrated maps
-	 * it first tries if there are manually imported maps
-	 * in &lt;baseDir&gt;/maps/standard then it tries
-	 * the legacy dir: &lt;program-dir&gt;/maps
-	 * In case in both locations are no .wfl-files
-	 * it returns  &lt;baseDir&gt;/maps/expedia - the place where
-	 * the automatically downloaded maps are placed.
-	 *
-	 *
+	 * gets the path to the calibrated maps it first tries if there are manually imported maps in
+	 * &lt;baseDir&gt;/maps/standard then it tries the legacy dir: &lt;program-dir&gt;/maps In case in both locations are no
+	 * .wfl-files it returns &lt;baseDir&gt;/maps/expedia - the place where the automatically downloaded maps are placed.
+	 * 
+	 * 
 	 */
 	public String getMapLoadPath() {
 		saveCustomMapsPath(getMapLoadPathInternal());
@@ -838,18 +995,23 @@
 		// here could also a list of map-types displayed...
 		// standard dir
 		String ret = getCustomMapsPath();
-		if (ret != null) return ret;
+		if (ret != null)
+			return ret;
 		ret = getMapManuallySavePath(false);
 		File t = new FileBugfix(ret);
 		String[] f = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
-		if (f != null &amp;&amp; f.length &gt; 0) return  absoluteBaseDir + mapsPath;
+		if (f != null &amp;&amp; f.length &gt; 0)
+			return absoluteBaseDir + mapsPath;
 		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_DIRECTORIES_ONLY | FileBase.LIST_ALWAYS_INCLUDE_DIRECTORIES);
-		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of &lt;baseDir&gt;/maps/standard are .wfl files
+		if (f != null &amp;&amp; f.length &gt; 0) { // see if in a subdir of
+			// &lt;baseDir&gt;/maps/standard are
+			// .wfl files
 			String[] f2;
-			for (int i = 0; i&lt; f.length; i++) {
-				t.set(null, ret+&quot;/&quot;+f[i]);
+			for (int i = 0; i &lt; f.length; i++) {
+				t.set(null, ret + &quot;/&quot; + f[i]);
 				f2 = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
-				if (f2 != null &amp;&amp; f2.length &gt; 0) return  ret;
+				if (f2 != null &amp;&amp; f2.length &gt; 0)
+					return ret;
 			}
 		}
 		// lagacy dir
@@ -857,45 +1019,49 @@
 		t.set(null, ret);
 		f = t.list(&quot;*.wfl&quot;, FileBase.LIST_FILES_ONLY);
 		if (f != null &amp;&amp; f.length &gt; 0) {
-			MessageBox inf = new MessageBox(&quot;Information&quot;, &quot;The directory for calibrated maps \nhas moved in this program version\n to '&lt;profiles directory&gt;/maps/standard'\n Do you want to move your calibrated maps there now?&quot;, FormBase.YESB | FormBase.NOB);
+			MessageBox inf = new MessageBox(&quot;Information&quot;, &quot;The directory for calibrated maps \nhas moved in this program version\n to '&lt;profiles directory&gt;/maps/standard'\n Do you want to move your calibrated maps there now?&quot;, FormBase.YESB
+					| FormBase.NOB);
 			if (inf.execute() == FormBase.IDYES) {
 				String sp = getMapManuallySavePath(false);
 				FileBugfix spF = new FileBugfix(sp);
-				if (!spF.exists()) spF.mkdirs();
+				if (!spF.exists())
+					spF.mkdirs();
 				String image;
 				String lagacypath = ret;
-				for (int i=0; i&lt;f.length; i++) {
-					t.set(null, lagacypath+f[i]);
-					spF.set(null, sp+&quot;/&quot;+f[i]);
+				for (int i = 0; i &lt; f.length; i++) {
+					t.set(null, lagacypath + f[i]);
+					spF.set(null, sp + &quot;/&quot; + f[i]);
 					t.move(spF);
-					image = Common.getImageName(lagacypath+f[i].substring(0, f[i].lastIndexOf(&quot;.&quot;)));
+					image = Common.getImageName(lagacypath + f[i].substring(0, f[i].lastIndexOf(&quot;.&quot;)));
 					t.set(null, image);
-					spF.set(null, sp+&quot;/&quot;+t.getFileExt());
+					spF.set(null, sp + &quot;/&quot; + t.getFileExt());
 					t.move(spF);
 				}
 				t.set(null, lagacypath);
 				t.delete();
 				return sp;
-			}
-			else return  ret;
+			} else
+				return ret;
 		}
 		// expedia dir
 		// return getMapExpediaLoadPath();
 
-		//whole maps directory
+		// whole maps directory
 		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps&quot;;
 	}
 
 	/**
-	 * @param create if true the directory if it doesn't exist will be created
-	 * @return the path where manually imported maps should be stored
-	 * this should be adjustable in preferences...
+	 * @param create
+	 *            if true the directory if it doesn't exist will be created
+	 * @return the path where manually imported maps should be stored this should be adjustable in preferences...
 	 */
 	public String getMapManuallySavePath(boolean create) {
 		String mapsDir = absoluteBaseDir + mapsPath;
-		if (create &amp;&amp; !(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
-			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation failed?
-				(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+mapsDir, FormBase.OKB)).exec();
+		if (create &amp;&amp; !(new FileBugfix(mapsDir).isDirectory())) { // dir
+			// exists?
+			if (new FileBugfix(mapsDir).mkdirs() == false) {// dir creation
+				// failed?
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + mapsDir, FormBase.OKB)).exec();
 				return null;
 			}
 		}
@@ -907,113 +1073,130 @@
 	 */
 	public String getMapDownloadSavePath(String mapkind) {
 		String subdir = Global.getProfile().dataDir.substring(Global.getPref().absoluteBaseDir.length()).replace('\\', '/');
-		String mapsDir = Global.getPref().absoluteBaseDir + &quot;maps/&quot; + Common.ClearForFileName(mapkind)+ &quot;/&quot; + subdir;
+		String mapsDir = Global.getPref().absoluteBaseDir + &quot;maps/&quot; + Common.ClearForFileName(mapkind) + &quot;/&quot; + subdir;
 		if (!(new FileBugfix(mapsDir).isDirectory())) { // dir exists?
-			if (new FileBugfix(mapsDir).mkdirs() == false) // dir creation failed?
-			{(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(172,&quot;Error: cannot create maps directory: \n&quot;)+new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
-			return null;
+			if (new FileBugfix(mapsDir).mkdirs() == false) {
+				// dir creation failed?
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(172, &quot;Error: cannot create maps directory: \n&quot;) + new FileBugfix(mapsDir).getParentFile(), FormBase.OKB)).exec();
+				return null;
 			}
 		}
 		return mapsDir;
 	}
 
 	public String getMapExpediaLoadPath() {
-		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps/expedia&quot;; // baseDir has trailing /
+		// baseDir has trailing /
+		return Global.getPref().absoluteBaseDir.replace('\\', '/') + &quot;maps/expedia&quot;;
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Profile Selector
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Profile Selector
+	// ////////////////////////////////////////////////////////////////////////////////////
 
-	static protected final int PROFILE_SELECTOR_FORCED_ON=0;
-	static protected final int PROFILE_SELECTOR_FORCED_OFF=1;
-	static protected final int PROFILE_SELECTOR_ONOROFF=2;
+	static protected final int PROFILE_SELECTOR_FORCED_ON = 0;
+	static protected final int PROFILE_SELECTOR_FORCED_OFF = 1;
+	static protected final int PROFILE_SELECTOR_ONOROFF = 2;
 
 	/**
-	 * tries to get the home data dir of the user
-	 * e.g. &quot;c:\documents and...\&lt;user&gt;\my documents&quot; or &quot;/home/&lt;user&gt;&quot; in linux
-	 * if none could be identified, &quot;/&quot; is returned.
+	 * tries to get the home data dir of the user e.g. &quot;c:\documents and...\&lt;user&gt;\my documents&quot; or &quot;/home/&lt;user&gt;&quot; in
+	 * linux if none could be identified, &quot;/&quot; is returned.
+	 * 
 	 * @return
 	 */
 	public String getHomeDir() {
 		String test;
-		test = Vm.getenv(&quot;HOMEDRIVE&quot;, &quot;&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
-		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in win32.exe (ewe-vm on win xp)
-		test += Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;); // returns in java-vm on win xp: c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
-		log(&quot;[Preferences:getHomeDir]&quot; + test); // this works also in win32.exe (ewe-vm on win xp)
-		if (test.length() == 0)	test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;); // This should return on *nix system the home dir
-		if (test.length() == 0)	test = &quot;/&quot;;
+		// returns in java-vm on win xp:
+		// c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
+		test = Vm.getenv(&quot;HOMEDRIVE&quot;, &quot;&quot;);
+		log(&quot;[Preferences:getHomeDir]&quot; + test);
+		// this works also in win32.exe (ewe-vm on win xp)
+		test += Vm.getenv(&quot;HOMEPATH&quot;, &quot;&quot;);
+		// returns in java-vm on win xp:
+		// c:\&lt;dokumente und Einstellungen&gt;\&lt;username&gt;\&lt;application data&gt;
+		log(&quot;[Preferences:getHomeDir]&quot; + test);
+		// this works also in win32.exe (ewe-vm on win xp)
+		if (test.length() == 0)
+			// This should return on *nix system the home dir
+			test = Vm.getenv(&quot;HOME&quot;, &quot;&quot;);
+		if (test.length() == 0)
+			test = &quot;/&quot;;
 		return test;
 	}
 
 	private void checkAbsoluteBaseDir() {
 		// If datadir is empty, ask for one
-		if (absoluteBaseDir.length()==0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
+		if (absoluteBaseDir.length() == 0 || !(new FileBugfix(absoluteBaseDir)).exists()) {
 			do {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, getHomeDir());
-				fc.title = MyLocale.getMsg(170,&quot;Select base directory for cache data&quot;);
+				fc.title = MyLocale.getMsg(170, &quot;Select base directory for cache data&quot;);
 				// If no base directory given, terminate
-				if (fc.execute() == FormBase.IDCANCEL) ewe.sys.Vm.exit(0);
+				if (fc.execute() == FormBase.IDCANCEL)
+					ewe.sys.Vm.exit(0);
 				setBaseDir(fc.getChosenFile().toString());
-			}while (!(new FileBugfix(absoluteBaseDir)).exists());
+			} while (!(new FileBugfix(absoluteBaseDir)).exists());
 		}
 	}
 
 	/**
 	 * Open Profile selector screen
+	 * 
 	 * @param prof
 	 * @param showProfileSelector
 	 * @return True if a profile was selected
 	 */
 	public boolean selectProfile(Profile prof, int showProfileSelector, boolean hasNewButton) {
 		checkAbsoluteBaseDir();
-		boolean profileExists=true;  // Assume that the profile exists
+		boolean profileExists = true; // Assume that the profile exists
 		do {
-			if(!profileExists || (showProfileSelector==PROFILE_SELECTOR_FORCED_ON) ||
-					(showProfileSelector==PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)){ // Ask for the profile
-				ProfilesForm f = new ProfilesForm(absoluteBaseDir,lastProfile,!profileExists || hasNewButton ? 0 : 1);
+			if (!profileExists//
+					|| (showProfileSelector == PROFILE_SELECTOR_FORCED_ON)//
+					|| (showProfileSelector == PROFILE_SELECTOR_ONOROFF &amp;&amp; !autoReloadLastProfile)//
+			) {
+				ProfilesForm f = new ProfilesForm(absoluteBaseDir, lastProfile, !profileExists || hasNewButton ? 0 : 1);
 				int code = f.execute();
 				// If no profile chosen (includes a new one), terminate
-				if (code==-1) return false; // Cancel pressed
+				if (code == -1)
+					return false; // Cancel pressed
 				CWPoint savecenter = new CWPoint(prof.centre);
 				prof.clearProfile();
 				prof.setCenterCoords(savecenter);
-				//prof.hasUnsavedChanges = true;
-				//curCentrePt.set(0,0); // No centre yet
-				lastProfile=f.newSelectedProfile;
+				// prof.hasUnsavedChanges = true;
+				// curCentrePt.set(0,0);
+				// No centre yet
+				lastProfile = f.newSelectedProfile;
 			}
-			profileExists=(new FileBugfix(absoluteBaseDir+lastProfile)).exists();
-			if (!profileExists) (new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
-					           MyLocale.getMsg(171,&quot;Profile does not exist: &quot;)+lastProfile,FormBase.MBOK)).execute();
-		} while (profileExists==false);
+			profileExists = (new FileBugfix(absoluteBaseDir + lastProfile)).exists();
+			if (!profileExists)
+				(new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(171, &quot;Profile does not exist: &quot;) + lastProfile, FormBase.MBOK)).execute();
+		} while (profileExists == false);
 		// Now we are sure that baseDir exists and basDir+profile exists
-		prof.name=lastProfile;
-		prof.dataDir=absoluteBaseDir+lastProfile;
-		prof.dataDir=prof.dataDir.replace('\\','/');
-		if (!prof.dataDir.endsWith(&quot;/&quot;)) prof.dataDir+='/';
-		pathToProfile=prof.dataDir;
+		prof.name = lastProfile;
+		prof.dataDir = absoluteBaseDir + lastProfile;
+		prof.dataDir = prof.dataDir.replace('\\', '/');
+		if (!prof.dataDir.endsWith(&quot;/&quot;))
+			prof.dataDir += '/';
+		pathToProfile = prof.dataDir;
 		savePreferences();
 		return true;
 	}
 
 	static public boolean deleteDirectory(FileBugfix path) {
-	    if( path.exists() ) {
-	    	String[] files = path.list();
-	    	for(int i=0; i&lt;files.length; i++) {
-	    		FileBugfix f = new FileBugfix(path.getFullPath() + &quot;/&quot; + files[i]);
-		        if(f.isDirectory()) {
-		        	deleteDirectory(f);
-		        }
-		        else {
-		        	f.delete();
-		        }
-		     }
-		    }
-	    return( path.delete() );
+		if (path.exists()) {
+			String[] files = path.list();
+			for (int i = 0; i &lt; files.length; i++) {
+				FileBugfix f = new FileBugfix(path.getFullPath() + &quot;/&quot; + files[i]);
+				if (f.isDirectory()) {
+					deleteDirectory(f);
+				} else {
+					f.delete();
+				}
+			}
+		}
+		return (path.delete());
 	}
 
 	static public boolean renameDirectory(FileBugfix OldPath, FileBugfix NewPath) {
-	    return OldPath.renameTo(NewPath);
+		return OldPath.renameTo(NewPath);
 	}
 
 	/*
@@ -1022,147 +1205,169 @@
 	public void editProfile(int operation, int ErrorMsgActive, int ErrorMsg) {
 		checkAbsoluteBaseDir(); // perhaps not necessary
 		// select profile
-		ProfilesForm f = new ProfilesForm(absoluteBaseDir,&quot;&quot;,operation);
-		if (f.execute()==-1) return ; // no select
+		ProfilesForm f = new ProfilesForm(absoluteBaseDir, &quot;&quot;, operation);
+		if (f.execute() == -1)
+			return; // no select
 		// check selection
 		if (lastProfile.equals(f.newSelectedProfile)) {
 			// aktives Profil kann nicht gel&#246;scht / umbenannt werden;
-			new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(ErrorMsgActive,&quot;[Profile active...]&quot;),FormBase.MBOK).execute();
-		}
-		else {
-			boolean err=true;
-			if (operation==3) {
-				String newName = new InputBox(&quot;Bitte neuen Verzeichnisnamen eingeben : &quot;).input(&quot;&quot;,50);
+			new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(ErrorMsgActive, &quot;[Profile active...]&quot;), FormBase.MBOK).execute();
+		} else {
+			boolean err = true;
+			if (operation == 3) {
+				String newName = new InputBox(&quot;Bitte neuen Verzeichnisnamen eingeben : &quot;).input(&quot;&quot;, 50);
 				if (!newName.equals(null)) {
-					err=!renameDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile),new FileBugfix(absoluteBaseDir+newName));
+					err = !renameDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile), new FileBugfix(absoluteBaseDir + newName));
 				}
-			}
-			else
-			if (operation==2){
+			} else if (operation == 2) {
 				Profile p = new Profile();
-				p.dataDir=absoluteBaseDir+f.newSelectedProfile+&quot;/&quot;;
+				p.dataDir = absoluteBaseDir + f.newSelectedProfile + &quot;/&quot;;
 				p.readIndex();
-				String mapsPath=absoluteBaseDir+&quot;maps&quot;+p.getRelativeCustomMapsPath();
-				int answer=new MessageBox(&quot;&quot;,mapsPath+&quot; &quot;+MyLocale.getMsg(143,&quot;l&#246;schen ?&quot;),FormBase.MBYESNO).execute();
-				if (answer==1) {
+				String mapsPath = absoluteBaseDir + &quot;maps&quot; + p.getRelativeCustomMapsPath();
+				int answer = new MessageBox(&quot;&quot;, mapsPath + &quot; &quot; + MyLocale.getMsg(143, &quot;l&#246;schen ?&quot;), FormBase.MBYESNO).execute();
+				if (answer == 1) {
 					deleteDirectory(new FileBugfix(mapsPath));
 				}
-				err=!deleteDirectory(new FileBugfix(absoluteBaseDir+f.newSelectedProfile));
+				err = !deleteDirectory(new FileBugfix(absoluteBaseDir + f.newSelectedProfile));
 				// ? wait until deleted ?
 			}
-			if (err) {new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(ErrorMsg,&quot;[Profile Error...]&quot;),FormBase.MBOK).execute();}
+			if (err) {
+				new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(ErrorMsg, &quot;[Profile Error...]&quot;), FormBase.MBOK).execute();
+			}
 		}
 	}
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Log functions
-	//////////////////////////////////////////////////////////////////////////////////////
 
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Log functions
+	// ////////////////////////////////////////////////////////////////////////////////////
+
 	// FIXME: should use path to config file instead of program directory
 	/** Log file is in program directory and called log.txt */
-	private final String LOGFILENAME=FileBase.getProgramDirectory()+&quot;/log.txt&quot;;
+	private final String LOGFILENAME = FileBase.getProgramDirectory() + &quot;/log.txt&quot;;
 
 	/**
-	 * Method to delete an existing log file. Called on every SpiderGC.
-	 * The log file is also cleared when Preferences is created and the filesize &gt; 60KB
+	 * Method to delete an existing log file. Called on every SpiderGC. The log file is also cleared when Preferences is
+	 * created and the filesize &gt; 60KB
 	 */
-	public void logInit(){
+	public void logInit() {
 		File logFile = new FileBugfix(LOGFILENAME);
 		logFile.delete();
-		log(&quot;CW Version &quot;+Version.getReleaseDetailed(),null,true);
-		
-		if (System.getProperty(&quot;os.name&quot;)!=null) log(&quot;Operating system: &quot;+System.getProperty(&quot;os.name&quot;)+&quot;/&quot;+System.getProperty(&quot;os.arch&quot;),null,true);
-		if (System.getProperty(&quot;java.vendor&quot;)!=null) log(&quot;Java: &quot;+System.getProperty(&quot;java.vendor&quot;)+&quot;/&quot;+System.getProperty(&quot;java.version&quot;),null,true);
-		
+		log(&quot;CW Version &quot; + Version.getReleaseDetailed(), null, true);
+
+		if (System.getProperty(&quot;os.name&quot;) != null)
+			log(&quot;Operating system: &quot; + System.getProperty(&quot;os.name&quot;) + &quot;/&quot; + System.getProperty(&quot;os.arch&quot;), null, true);
+		if (System.getProperty(&quot;java.vendor&quot;) != null)
+			log(&quot;Java: &quot; + System.getProperty(&quot;java.vendor&quot;) + &quot;/&quot; + System.getProperty(&quot;java.version&quot;), null, true);
+
 	}
 
 	boolean forceLog = false;
-	
+
 	/**
-	 * Method to log messages to a file called log.txt
-	 * It will always append to an existing file.
-	 * To show the message on the console, the global variable debug must be set.
-	 * This can be done by adding
-	 * &lt;pre&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/pre&gt;
+	 * Method to log messages to a file called log.txt It will always append to an existing file. To show the message on
+	 * the console, the global variable debug must be set. This can be done by adding
+	 * 
+	 * &lt;pre&gt;
+	 * &lt;debug value=&quot;true&quot;&gt;
+	 * &lt;/pre&gt;
+	 * 
 	 * to the pref.xml file
-	 * @param text to log
+	 * 
+	 * @param text
+	 *            to log
 	 */
-	public void log(String text){
+	public void log(String text) {
 		if (debug || forceLog) {
-			if (debug) Vm.debug(text);
+			if (debug)
+				Vm.debug(text);
 			Time dtm = new Time();
 			dtm.getTime();
 			dtm.setFormat(&quot;dd.MM.yyyy'/'HH:mm:ss.SSS&quot;);
-			text = dtm.toString()+ &quot;: &quot;+ text;
+			text = dtm.toString() + &quot;: &quot; + text;
 			FileWriter logFile = null;
-			try{
+			try {
 				logFile = new FileWriter(LOGFILENAME, true);
-				//Stream strout = null;
-				//strout = logFile.toWritableStream(true);
-				logFile.print(text+NEWLINE);
-			}catch(Exception ex){
+				// Stream strout = null;
+				// strout = logFile.toWritableStream(true);
+				logFile.print(text + NEWLINE);
+			} catch (Exception ex) {
 				Vm.debug(&quot;Error writing to log file!&quot;);
-			}finally{
-				if (logFile != null) try {logFile.close(); } catch (IOException ioe) {
-					// log(&quot;Ignored Exception&quot;, ioe, true);
-				}
+			} finally {
+				if (logFile != null)
+					try {
+						logFile.close();
+					} catch (IOException ioe) {
+						// log(&quot;Ignored Exception&quot;, ioe, true);
+					}
 			}
 		}
 	}
 
-	/** Log an exception to the log file with or without a stack trace
-	 *
-	 * @param text Optional message (Can be empty string)
-	 * @param e The exception
-	 * @param withStackTrace If true and the debug switch is true, the stack trace is appended to the log
-	 * The debug switch can be set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file
-	 * or by manually setting it (i.e. in BE versions or RC versions) by including the line
-	 * &lt;pre&gt;Global.getPref().debug=true;&lt;/pre&gt;
-	 * in Version.getRelease()
+	/**
+	 * Log an exception to the log file with or without a stack trace
+	 * 
+	 * @param text
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
+	 * @param withStackTrace
+	 *            If true and the debug switch is true, the stack trace is appended to the log The debug switch can be
+	 *            set by including the line &lt;i&gt;&lt;debug value=&quot;true&quot;&gt;&lt;/debug&gt;&lt;/i&gt; in the pref.xml file or by
+	 *            manually setting it (i.e. in BE versions or RC versions) by including the line
+	 * 
+	 *            &lt;pre&gt;
+	 * Global.getPref().debug = true;
+	 * &lt;/pre&gt;
+	 * 
+	 *            in Version.getRelease()
 	 */
-	public void log(String text,Throwable e, boolean withStackTrace) {
-		if (e!=null) {
-			text+=Preferences.NEWLINE;
+	public void log(String text, Throwable e, boolean withStackTrace) {
+		if (e != null) {
+			text += Preferences.NEWLINE;
 			if (withStackTrace)
-				text+=ewe.sys.Vm.getAStackTrace(e);
+				text += ewe.sys.Vm.getAStackTrace(e);
 			else
-				text+=e.toString();
+				text += e.toString();
 		}
-		forceLog=true;
+		forceLog = true;
 		log(text);
-		forceLog=false;
+		forceLog = false;
 	}
 
-	/** Log an exception to the log file without a stack trace, i.e.
-	 * where a stack trace is not needed because the location/cause of the error is clear
-	 *
-	 * @param message Optional message (Can be empty string)
-	 * @param e The exception
+	/**
+	 * Log an exception to the log file without a stack trace, i.e. where a stack trace is not needed because the
+	 * location/cause of the error is clear
+	 * 
+	 * @param message
+	 *            Optional message (Can be empty string)
+	 * @param e
+	 *            The exception
 	 */
-	public void log(String message,Exception e) {
-		log (message,e,false);
+	public void log(String message, Exception e) {
+		log(message, e, false);
 	}
 
-    //////////////////////////////////////////////////////////////////////////////////////
-    // Exporter path functions
-	//////////////////////////////////////////////////////////////////////////////////////
+	// ////////////////////////////////////////////////////////////////////////////////////
+	// Exporter path functions
+	// ////////////////////////////////////////////////////////////////////////////////////
 
 	/** Hashtable for storing the last export path */
 	private Hashtable exporterPaths = new Hashtable();
 
-	public void setExportPath(String exporter,String path){
+	public void setExportPath(String exporter, String path) {
 		exporterPaths.put(exporter, path);
 		savePreferences();
 	}
 
-	public void setExportPathFromFileName(String exporter,String filename){
-		File tmpfile = new FileBugfix (filename);
+	public void setExportPathFromFileName(String exporter, String filename) {
+		File tmpfile = new FileBugfix(filename);
 		exporterPaths.put(exporter, tmpfile.getPath());
 		savePreferences();
 	}
 
-	public String getExportPath(String exporter){
+	public String getExportPath(String exporter) {
 		String dir = (String) exporterPaths.get(exporter);
-		if (dir == null){
+		if (dir == null) {
 			dir = Global.getProfile().dataDir;
 		}
 		return dir;
@@ -1177,14 +1382,17 @@
 
 	public String getImporterPath(String importer) {
 		String dir = (String) importerPaths.get(importer);
-		if (null == dir) dir = Global.getProfile().dataDir;
+		if (null == dir)
+			dir = Global.getProfile().dataDir;
 		return dir;
 	}
 
 	/**
-	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is
-	 * saved in the preferences.
-	 * @param filterID ID of the filter to check
+	 * &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, depending if a filter with the given ID is saved in the
+	 * preferences.
+	 * 
+	 * @param filterID
+	 *            ID of the filter to check
 	 * @return True or false
 	 */
 	public boolean hasFilter(String filterID) {
@@ -1192,29 +1400,36 @@
 	}
 
 	/**
-	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object,
-	 * so it may be resaved under another ID.
-	 * @param filterID ID of the FilterData object
+	 * Returns the FilterData object saved with the given ID. The ID is not saved in the object, so it may be resaved
+	 * under another ID.
+	 * 
+	 * @param filterID
+	 *            ID of the FilterData object
 	 * @return FilterData object
 	 */
 	public FilterData getFilter(String filterID) {
-		return (FilterData)this.filterList.get(filterID);
+		return (FilterData) this.filterList.get(filterID);
 	}
 
 	/**
-	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the
-	 * given ID, the old object is removed and the new one is set at its place.
-	 * @param filterID ID to associate with the filter object
-	 * @param filter FilterData object
+	 * Adds a FilterData object to the list. If a FilterData object is already saved unter the given ID, the old object
+	 * is removed and the new one is set at its place.
+	 * 
+	 * @param filterID
+	 *            ID to associate with the filter object
+	 * @param filter
+	 *            FilterData object
 	 */
 	public void addFilter(String filterID, FilterData filter) {
 		this.filterList.put(filterID, filter);
 	}
 
 	/**
-	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object
-	 * exists, nothing happens.
-	 * @param filterID ID of FilterData object to remove
+	 * Removed the FilterData object which is saved with the given ID. If no such FilterData object exists, nothing
+	 * happens.
+	 * 
+	 * @param filterID
+	 *            ID of FilterData object to remove
 	 */
 	public void removeFilter(String filterID) {
 		this.filterList.remove(filterID);
@@ -1222,13 +1437,14 @@
 
 	/**
 	 * Returns a alphabetically sorted array of ID of saved FilterData objects.
+	 * 
 	 * @return Array of IDs
 	 */
 	public String[] getFilterIDs() {
 		String[] result;
 		result = new String[this.filterList.size()];
 		Enumeration en = this.filterList.keys();
-		int i=0;
+		int i = 0;
 		while (en.hasMoreElements()) {
 			result[i++] = (String) en.nextElement();
 		}
@@ -1245,26 +1461,24 @@
 	public String gpsbabel = null;
 
 	public void setgpsbabel() {
-		try{
+		try {
 			ewe.sys.Process p = Vm.exec(&quot;gpsbabel -V&quot;);
 			p.waitFor();
-			gpsbabel=&quot;gpsbabel&quot;;
-		}catch(IOException ioex){
-			// Most of the time there will be an exception, so don't complain
-		}
-		if ( gpsbabel == null ) {
-			try{
+			gpsbabel = &quot;gpsbabel&quot;;
+		} catch (IOException ioex) {
+			try {
 				ewe.sys.Process p = Vm.exec(&quot;gpsbabel.exe -V&quot;);
 				p.waitFor();
 				gpsbabel = &quot;gpsbabel.exe&quot;;
-			}catch(IOException ioex){
-				// Most of the time there will be an exception, so don't complain
+			} catch (IOException io_ex) {
 			}
 		}
 	}
 
-	/** get directory where pref.xml is stored&lt;br&gt;
-	 *  use this if you need a path where the user has sufficient rights to create a file */
+	/**
+	 * get directory where pref.xml is stored&lt;br&gt;
+	 * use this if you need a path where the user has sufficient rights to create a file
+	 */
 	public String getPathToConfigFile() {
 		return pathToConfigFile;
 	}
@@ -1275,11 +1489,21 @@
 
 	public void setBaseDir(String dir) {
 		baseDir = dir;
-		baseDir=baseDir.replace('\\','/');
-		if (!baseDir.endsWith(&quot;/&quot;)) baseDir+=&quot;/&quot;;
+		baseDir = baseDir.replace('\\', '/');
+		if (!baseDir.endsWith(&quot;/&quot;))
+			baseDir += &quot;/&quot;;
 		absoluteBaseDir = new FileBugfix(baseDir).getAbsolutePath();
-		absoluteBaseDir=absoluteBaseDir.replace('\\','/');
-		if (!absoluteBaseDir.endsWith(&quot;/&quot;)) absoluteBaseDir+=&quot;/&quot;;
+		absoluteBaseDir = absoluteBaseDir.replace('\\', '/');
+		if (!absoluteBaseDir.endsWith(&quot;/&quot;))
+			absoluteBaseDir += &quot;/&quot;;
 	}
 
+	public void setOldGCLanguage() {
+		if (oldLanguageCtl.length() != 0)
+			try {
+				UrlFetcher.fetch(oldLanguageCtl);
+			} catch (IOException e) {
+				// dann halt nicht
+			}
+	}
 }

Modified: branches/r1.2/src/CacheWolf/PreferencesScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/PreferencesScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/PreferencesScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Metrics;
@@ -54,347 +54,336 @@
 import ewe.ui.mTabbedPanel;
 
 /**
-*	This class displays a user interface allowing the user to change and set
-*	preferences. It also provides a method to save the changed preferences that
-*	are saved immediatly when the user presses &quot;Apply&quot;.
-*	Class ID=600
-*/
+ * This class displays a user interface allowing the user to change and set preferences. It also provides a method to
+ * save the changed preferences that are saved immediatly when the user presses &quot;Apply&quot;. Class ID=600
+ */
 public class PreferencesScreen extends Form {
 	mButton cancelB, applyB, brwBt, gpsB;
 	mChoice inpLanguage, inpMetric, inpSpiderUpdates;
-	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontSize, 
-	       inpLogsPerPage,inpMaxLogsToSpider,inpPassword,inpGcMemberID;
-	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus,chkHasCloseButton,
-	          chkSynthShort,chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName, 
-	          chkSetCurrentCentreFromGPSPosition,chkSortingGroupedByCache,chkuseOwnSymbols,chkDebug,chkPM;
+	mInput DataDir, Proxy, ProxyPort, Alias, nLogs, Browser, fontName, fontSize, inpLogsPerPage, inpMaxLogsToSpider, inpPassword, inpGcMemberID, inpUserID;
+	mCheckBox chkAutoLoad, chkShowDeletedImg, chkMenuAtTop, chkTabsAtTop, chkShowStatus, chkHasCloseButton, chkUseBigIcons, chkUseRadar, chkSynthShort, chkProxyActive, chkDescShowImg, chkAddDetailsToWaypoint, chkAddDetailsToName,
+			chkSetCurrentCentreFromGPSPosition, chkSortingGroupedByCache, chkuseOwnSymbols, chkDebug, chkPM;
 	mTabbedPanel mTab;
 	mChoice chcGarminPort;
 	mLabel lblGarmin;
-	TableColumnChooser tccBugs,tccList;
-	
+	TableColumnChooser tccBugs, tccList;
+
 	Preferences pref;
-	
+
 	CellPanel pnlGeneral = new CellPanel();
 	CellPanel pnlDisplay = new CellPanel();
 	CellPanel pnlMore = new CellPanel();
 	CellPanel pnlTB = new CellPanel();
 
 	// ScrollBarPanel scp;
-	String [] garminPorts= new String[]{&quot;com1&quot;,&quot;com2&quot;,&quot;com3&quot;,&quot;com4&quot;,&quot;com5&quot;,&quot;com6&quot;,&quot;com7&quot;,&quot;usb&quot;};
-	
-	public PreferencesScreen (Preferences p){
+	String[] garminPorts = new String[] { &quot;com1&quot;, &quot;com2&quot;, &quot;com3&quot;, &quot;com4&quot;, &quot;com5&quot;, &quot;com6&quot;, &quot;com7&quot;, &quot;usb&quot; };
+
+	public PreferencesScreen(Preferences p) {
 		int sw = MyLocale.getScreenWidth();
 		int sh = MyLocale.getScreenHeight();
 
-		mTab=new mTabbedPanel();
-		
+		mTab = new mTabbedPanel();
+
 		pref = p;
-		this.title = MyLocale.getMsg(600,&quot;Preferences&quot;);
+		this.title = MyLocale.getMsg(600, &quot;Preferences&quot;);
 		if ((sw &gt; 240) &amp;&amp; (sh &gt; 240))
 			this.resizable = true;
-		//this.moveable = true;
-		//this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
+		// this.moveable = true;
+		// this.windowFlagsToSet = Window.FLAG_MAXIMIZE;
 
 		// set dialog-width according to fontsize
-		if((pref.fontSize &lt;= 13)||(sw &lt;= 240)||(sh &lt;= 240)){
-			setPreferredSize(240,240);
-		}
-		else if(pref.fontSize &lt;= 28){
+		if ((pref.fontSize &lt;= 13) || (sw &lt;= 240) || (sh &lt;= 240)) {
+			setPreferredSize(240, 240);
+		} else if (pref.fontSize &lt;= 28) {
 			// was for &lt;=16 setPreferredSize(288,252);
-			setPreferredSize(pref.fontSize*20,pref.fontSize*18);
+			setPreferredSize(pref.fontSize * 20, pref.fontSize * 18);
+		} else if (pref.fontSize &lt;= 20) {
+			setPreferredSize(352, 302);
+		} else if (pref.fontSize &lt;= 24) {
+			setPreferredSize(420, 350);
+		} else if (pref.fontSize &lt;= 28) {
+			setPreferredSize(480, 390);
+		} else {
+			setPreferredSize(576, 512);
 		}
-		else if(pref.fontSize &lt;= 20){
-			setPreferredSize(352,302);
-		}
-		else if(pref.fontSize &lt;= 24){
-			setPreferredSize(420,350);
-		}
-		else if(pref.fontSize &lt;= 28){
-			setPreferredSize(480,390);
-		}
-		else{
-			setPreferredSize(576,512);
-		}
-		
-		//scp = new ScrollBarPanel(pnlGeneral);
-		
-		/////////////////////////////////////////////////////////
+
+		// scp = new ScrollBarPanel(pnlGeneral);
+
+		// ///////////////////////////////////////////////////////
 		// First panel - General
-		/////////////////////////////////////////////////////////
-		CellPanel cpDataDir=new CellPanel();
-		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603,&quot;Data Directory:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		// ///////////////////////////////////////////////////////
+		CellPanel cpDataDir = new CellPanel();
+		cpDataDir.addNext(new mLabel(MyLocale.getMsg(603, &quot;Data Directory:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		DataDir = new mInput();
 		DataDir.setText(pref.getBaseDir());
-		cpDataDir.addNext(DataDir,CellConstants.STRETCH, (CellConstants.FILL|CellConstants.LEFT));
-		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604,&quot;Browse&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629,&quot;Autoload last profile&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		if (pref.autoReloadLastProfile) chkAutoLoad.setState(true);
-		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646,&quot;centre from GPS&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.RIGHT));
-		if (pref.setCurrentCentreFromGPSPosition) chkSetCurrentCentreFromGPSPosition.setState(true);
-		pnlGeneral.addLast(separator(cpDataDir),HSTRETCH,HFILL);
-		
-		CellPanel cpBrowser=new CellPanel();
-		cpBrowser.addNext(new mLabel(&quot;Browser:&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addLast(Browser = new mInput(pref.browser),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601,&quot;Your Alias:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		cpBrowser.addNext(Alias = new mInput(pref.myAlias),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594,&quot;Pwd&quot;)));
-		cpBrowser.addLast(inpPassword=new mInput(pref.password),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		inpPassword.setToolTip(MyLocale.getMsg(593,&quot;Password is optional here.\nEnter only if you want to store it in pref.xml&quot;));
-		inpPassword.isPassword=true;
-		cpBrowser.addNext(chkPM=new mCheckBox(&quot;PM&quot;));
-		if (pref.isPremium) chkPM.setState(true);
-		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650,&quot;GcMemberID:&quot;)));
-		cpBrowser.addLast(inpGcMemberID=new mInput(pref.gcMemberId),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		
-		pnlGeneral.addLast(separator(cpBrowser),HSTRETCH,HFILL);
-		
-		CellPanel cpGPS=new CellPanel();
-		cpGPS.addNext(new mLabel(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600,&quot;Preferences&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		// &quot;GPS: &quot; + (pref.useGPSD ? &quot;gpsd &quot; + pref.gpsdHost : pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate) 
-		pnlGeneral.addLast(separator(cpGPS),HSTRETCH,HFILL);
+		cpDataDir.addNext(DataDir, CellConstants.STRETCH, (CellConstants.FILL | CellConstants.LEFT));
+		cpDataDir.addLast(brwBt = new mButton(MyLocale.getMsg(604, &quot;Browse&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		cpDataDir.addNext(chkAutoLoad = new mCheckBox(MyLocale.getMsg(629, &quot;Autoload last profile&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		if (pref.autoReloadLastProfile)
+			chkAutoLoad.setState(true);
+		cpDataDir.addNext(chkSetCurrentCentreFromGPSPosition = new mCheckBox(MyLocale.getMsg(646, &quot;centre from GPS&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.RIGHT));
+		if (pref.setCurrentCentreFromGPSPosition)
+			chkSetCurrentCentreFromGPSPosition.setState(true);
+		pnlGeneral.addLast(separator(cpDataDir), HSTRETCH, HFILL);
 
+		CellPanel cpBrowser = new CellPanel();
+		cpBrowser.addNext(new mLabel(&quot;Browser:&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addLast(Browser = new mInput(pref.browser), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(601, &quot;Your Alias:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(Alias = new mInput(pref.myAlias), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(594, &quot;Pwd&quot;)));
+		cpBrowser.addLast(inpPassword = new mInput(pref.password), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		inpPassword.setToolTip(MyLocale.getMsg(593, &quot;Password is optional here.\nEnter only if you want to store it in pref.xml&quot;));
+		inpPassword.isPassword = true;
+		cpBrowser.addNext(chkPM = new mCheckBox(&quot;PM&quot;));
+		if (pref.isPremium)
+			chkPM.setState(true);
+		cpBrowser.addNext(new mLabel(MyLocale.getMsg(650, &quot;GcMemberID:&quot;)));
+		cpBrowser.addLast(inpGcMemberID = new mInput(pref.gcMemberId), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpBrowser.addNext(new mLabel(&quot;UserID&quot;));
+		cpBrowser.addLast(inpUserID = new mInput(pref.userID), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+
+		pnlGeneral.addLast(separator(cpBrowser), HSTRETCH, HFILL);
+
+		CellPanel cpGPS = new CellPanel();
+		cpGPS.addNext(new mLabel(&quot;GPS: &quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		cpGPS.addLast(gpsB = new mButton(MyLocale.getMsg(600, &quot;Preferences&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		// &quot;GPS: &quot; + (pref.useGPSD ? &quot;gpsd &quot; + pref.gpsdHost : pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate)
+		pnlGeneral.addLast(separator(cpGPS), HSTRETCH, HFILL);
+
 		// Garmin and GPSBabel
-		CellPanel cpBabel=new CellPanel();
-		cpBabel.addNext(lblGarmin=new mLabel(MyLocale.getMsg(173,&quot;Garmin:  PC Port:&quot;)),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chcGarminPort=new mChoice(garminPorts,0),DONTSTRETCH,RIGHT);
+		CellPanel cpBabel = new CellPanel();
+		cpBabel.addNext(lblGarmin = new mLabel(MyLocale.getMsg(173, &quot;Garmin:  PC Port:&quot;)), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chcGarminPort = new mChoice(garminPorts, 0), DONTSTRETCH, RIGHT);
 		chcGarminPort.selectItem(pref.garminConn);
-		cpBabel.addLast(chkSynthShort=new mCheckBox(MyLocale.getMsg(174,&quot;Short Names&quot;)),STRETCH,LEFT);
+		cpBabel.addLast(chkSynthShort = new mCheckBox(MyLocale.getMsg(174, &quot;Short Names&quot;)), STRETCH, LEFT);
 		chkSynthShort.setState(!pref.garminGPSBabelOptions.equals(&quot;&quot;));
-		cpBabel.addNext(new mLabel(MyLocale.getMsg(643,&quot;Append cache details to:&quot;)),DONTSTRETCH,LEFT);
-		cpBabel.addNext(chkAddDetailsToWaypoint=new mCheckBox(MyLocale.getMsg(644,&quot;waypoints&quot;)),DONTSTRETCH,RIGHT);
+		cpBabel.addNext(new mLabel(MyLocale.getMsg(643, &quot;Append cache details to:&quot;)), DONTSTRETCH, LEFT);
+		cpBabel.addNext(chkAddDetailsToWaypoint = new mCheckBox(MyLocale.getMsg(644, &quot;waypoints&quot;)), DONTSTRETCH, RIGHT);
 		chkAddDetailsToWaypoint.setState(pref.addDetailsToWaypoint);
-		cpBabel.addLast(chkAddDetailsToName=new mCheckBox(MyLocale.getMsg(645,&quot;names&quot;)),STRETCH,LEFT);
+		cpBabel.addLast(chkAddDetailsToName = new mCheckBox(MyLocale.getMsg(645, &quot;names&quot;)), STRETCH, LEFT);
 		chkAddDetailsToName.setState(pref.addDetailsToName);
-		pnlGeneral.addLast(cpBabel,HSTRETCH,HFILL);
-		
-		/////////////////////////////////////////////////////////
+		pnlGeneral.addLast(cpBabel, HSTRETCH, HFILL);
+
+		// ///////////////////////////////////////////////////////
 		// Second panel - Screen
-		/////////////////////////////////////////////////////////
-		
-		CellPanel pnlScreen=new CellPanel();
-		Frame frmScreen=new Frame();
-		frmScreen.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER;
-		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625,&quot;Screen (needs restart):&quot;)));
-		pnlScreen.addNext(new mLabel(&quot;Font&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlScreen.addLast(fontSize = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.HFILL|CellConstants.LEFT));
-		fontSize.maxLength=2;
-		fontSize.setPreferredSize(40,-1);
-		frmScreen.addLast(pnlScreen,HSTRETCH,HFILL);
+		// ///////////////////////////////////////////////////////
+
+		CellPanel pnlScreen = new CellPanel();
+		Frame frmScreen = new Frame();
+		frmScreen.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER;
+		pnlScreen.addNext(new mLabel(MyLocale.getMsg(625, &quot;Screen (needs restart):&quot;)));
+		pnlScreen.addNext(new mLabel(&quot;Font&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlScreen.addNext(fontName = new mInput(), CellConstants.STRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontName.maxLength = 50;
+		fontName.setText(pref.fontName);
+		pnlScreen.addLast(fontSize = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.HFILL | CellConstants.LEFT));
+		fontSize.maxLength = 2;
+		fontSize.setPreferredSize(2 * pref.fontSize, -1);
 		fontSize.setText(Convert.toString(pref.fontSize));
-		
-		frmScreen.addLast(chkHasCloseButton=new mCheckBox(MyLocale.getMsg(631,&quot;PDA has close Button&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
-    	//lblTitle.setTag(INSETS,new Insets(2,0,0,0));
-        chkHasCloseButton.setState(pref.hasCloseButton);
-		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626,&quot;Menu top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkMenuAtTop.setTag(INSETS,new Insets(0,0,2,0));
+		frmScreen.addLast(pnlScreen, HSTRETCH, HFILL);
+
+		frmScreen.addLast(chkHasCloseButton = new mCheckBox(MyLocale.getMsg(631, &quot;PDA has close Button&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkHasCloseButton.setState(pref.hasCloseButton);
+		frmScreen.addNext(chkMenuAtTop = new mCheckBox(MyLocale.getMsg(626, &quot;Menu top&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkMenuAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
 		chkMenuAtTop.setState(pref.menuAtTop);
-		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627,&quot;Tabs top&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmScreen.addNext(chkTabsAtTop = new mCheckBox(MyLocale.getMsg(627, &quot;Tabs top&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkTabsAtTop.setState(pref.tabsAtTop);
-		chkTabsAtTop.setTag(INSETS,new Insets(0,0,2,0));
-		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628,&quot;Status&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		chkTabsAtTop.setTag(INSETS, new Insets(0, 0, 2, 0));
+		frmScreen.addLast(chkShowStatus = new mCheckBox(MyLocale.getMsg(628, &quot;Status&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkShowStatus.setState(pref.showStatus);
-		chkShowStatus.setTag(INSETS,new Insets(0,0,2,0));
-		pnlDisplay.addLast(frmScreen,CellConstants.HSTRETCH,CellConstants.FILL);
-		
-		Frame frmImages=new Frame();
-		frmImages.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_TOP|UIConstants.BF_BOTTOM;
-		//frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624,&quot;Show deleted images&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		chkShowDeletedImg.setTag(INSETS,new Insets(2,0,0,0));
-		if (pref.showDeletedImages) chkShowDeletedImg.setState(true);
-		//mLabel dummy;
-		//frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		//dummy.setTag(INSETS,new Insets(0,0,2,0));
-		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638,&quot;Show pictures in description&quot;)),CellConstants.VSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
-		chkDescShowImg.setTag(INSETS,new Insets(0,0,2,0));
-		if (pref.descShowImg) chkDescShowImg.setState(true);
-		pnlDisplay.addLast(frmImages,CellConstants.STRETCH,CellConstants.FILL);
+		chkShowStatus.setTag(INSETS, new Insets(0, 0, 2, 0));
+		frmScreen.addNext(chkUseBigIcons = new mCheckBox(&quot;use big Icons&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkUseBigIcons.setState(pref.useBigIcons);
+		frmScreen.addLast(chkUseRadar = new mCheckBox(&quot;Radartab on small screen&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkUseRadar.setState(pref.useRadar);
+		pnlDisplay.addLast(frmScreen, CellConstants.HSTRETCH, CellConstants.FILL);
 
-		Frame frmHintLog=new Frame();
-		//frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630,&quot;HintLogPanel:  Logs per page &quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpLogsPerPage=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		Frame frmImages = new Frame();
+		frmImages.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_TOP | UIConstants.BF_BOTTOM;
+		// frmImages.addNext(new mLabel(MyLocale.getMsg(623,&quot;Images:&quot;)),CellConstants.VSTRETCH,
+		// (CellConstants.DONTFILL|CellConstants.LEFT));
+		frmImages.addLast(chkShowDeletedImg = new mCheckBox(MyLocale.getMsg(624, &quot;Show deleted images&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		chkShowDeletedImg.setTag(INSETS, new Insets(2, 0, 0, 0));
+		if (pref.showDeletedImages)
+			chkShowDeletedImg.setState(true);
+		// mLabel dummy;
+		// frmImages.addNext(dummy=new mLabel(&quot;&quot;),CellConstants.VSTRETCH,
+		// (CellConstants.DONTFILL|CellConstants.LEFT|CellConstants.NORTH));
+		// dummy.setTag(INSETS,new Insets(0,0,2,0));
+		frmImages.addLast(chkDescShowImg = new mCheckBox(MyLocale.getMsg(638, &quot;Show pictures in description&quot;)), CellConstants.VSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT | CellConstants.NORTH));
+		chkDescShowImg.setTag(INSETS, new Insets(0, 0, 2, 0));
+		if (pref.descShowImg)
+			chkDescShowImg.setState(true);
+		pnlDisplay.addLast(frmImages, CellConstants.STRETCH, CellConstants.FILL);
+
+		Frame frmHintLog = new Frame();
+		// frmHintLog.borderStyle=CellPanel.BDR_RAISEDOUTER|CellPanel.BDR_SUNKENINNER|CellPanel.BF_BOTTOM;
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(630, &quot;HintLogPanel:  Logs per page &quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpLogsPerPage = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpLogsPerPage.setText(Convert.toString(pref.logsPerPage));
-		inpLogsPerPage.setPreferredSize(40,-1);
-		//inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
-		//lblHlP.setTag(INSETS,new Insets(6,0,2,0));
+		inpLogsPerPage.setPreferredSize(40, -1);
+		// inpLogsPerPage.setTag(INSETS,new Insets(0,0,2,0));
+		// lblHlP.setTag(INSETS,new Insets(6,0,2,0));
 
-		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633,&quot;Max. logs to spider&quot;)),CellConstants.DONTSTRETCH,CellConstants.DONTFILL);	
-		frmHintLog.addLast(inpMaxLogsToSpider=new mInput(),CellConstants.DONTSTRETCH,CellConstants.DONTFILL|CellConstants.RIGHT);
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(633, &quot;Max. logs to spider&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		frmHintLog.addLast(inpMaxLogsToSpider = new mInput(), CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.RIGHT);
 		inpMaxLogsToSpider.setText(Convert.toString(pref.maxLogsToSpider));
-		inpMaxLogsToSpider.setPreferredSize(40,-1);
-		
-		String [] spiderUpdateOptions = { MyLocale.getMsg(640,&quot;Yes&quot;), MyLocale.getMsg(641,&quot;No&quot;), MyLocale.getMsg(642,&quot;Ask&quot;) };
-		frmHintLog.addNext(new mLabel( MyLocale.getMsg(639,&quot;Update caches when spidering?&quot;) ),DONTSTRETCH,DONTFILL|LEFT);
-		frmHintLog.addLast(inpSpiderUpdates=new mChoice(spiderUpdateOptions, pref.spiderUpdates),DONTSTRETCH,DONTFILL|LEFT);
-		pnlDisplay.addLast(frmHintLog,CellConstants.STRETCH,CellConstants.FILL);
+		inpMaxLogsToSpider.setPreferredSize(40, -1);
 
-		/////////////////////////////////////////////////////////
+		String[] spiderUpdateOptions = { MyLocale.getMsg(640, &quot;Yes&quot;), MyLocale.getMsg(641, &quot;No&quot;), MyLocale.getMsg(642, &quot;Ask&quot;) };
+		frmHintLog.addNext(new mLabel(MyLocale.getMsg(639, &quot;Update caches when spidering?&quot;)), DONTSTRETCH, DONTFILL | LEFT);
+		frmHintLog.addLast(inpSpiderUpdates = new mChoice(spiderUpdateOptions, pref.spiderUpdates), DONTSTRETCH, DONTFILL | LEFT);
+		pnlDisplay.addLast(frmHintLog, CellConstants.STRETCH, CellConstants.FILL);
+
+		// ///////////////////////////////////////////////////////
 		// Third panel - More
-		/////////////////////////////////////////////////////////
-		CellPanel pnlProxy=new CellPanel();
-		pnlProxy.addNext(new mLabel(&quot;Proxy&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(Proxy = new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.LEFT)).setTag(SPAN,new Dimension(2,1));
+		// ///////////////////////////////////////////////////////
+		CellPanel pnlProxy = new CellPanel();
+		pnlProxy.addNext(new mLabel(&quot;Proxy&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(Proxy = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.LEFT)).setTag(SPAN, new Dimension(2, 1));
 		Proxy.setText(pref.myproxy);
-		pnlProxy.addNext(new mLabel(&quot;Port&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		pnlProxy.addLast(ProxyPort = new mInput(),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		pnlProxy.addNext(new mLabel(&quot;Port&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		pnlProxy.addLast(ProxyPort = new mInput(), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		ProxyPort.setText(pref.myproxyport);
-		pnlProxy.addNext(new mLabel(&quot;&quot;),HSTRETCH,HFILL);
-		pnlProxy.addLast(chkProxyActive=new mCheckBox(MyLocale.getMsg(634,&quot;use Proxy&quot;)));
+		pnlProxy.addNext(new mLabel(&quot;&quot;), HSTRETCH, HFILL);
+		pnlProxy.addLast(chkProxyActive = new mCheckBox(MyLocale.getMsg(634, &quot;use Proxy&quot;)));
 		chkProxyActive.setState(pref.proxyActive);
-		pnlMore.addLast(pnlProxy,HSTRETCH,HFILL);
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(592,&quot;Language (needs restart)&quot;)),DONTSTRETCH,DONTFILL|LEFT);
-		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory()+&quot;/languages&quot;).list(&quot;*.cfg&quot;, FileBase.LIST_FILES_ONLY)); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
-		if (tmp == null) tmp = new String[0];
-		String [] langs = new String[tmp.length +1];
+		pnlMore.addLast(pnlProxy, HSTRETCH, HFILL);
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(592, &quot;Language (needs restart)&quot;)), DONTSTRETCH, DONTFILL | LEFT);
+		// &quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		String[] tmp = (new FileBugfix(FileBase.getProgramDirectory() + &quot;/languages&quot;).list(&quot;*.cfg&quot;, FileBase.LIST_FILES_ONLY));
+		if (tmp == null)
+			tmp = new String[0];
+		String[] langs = new String[tmp.length + 1];
 		langs[0] = &quot;auto&quot;;
 		int curlang = 0;
 		for (int i = 0; i &lt; tmp.length; i++) {
-			langs[i+1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
-			if (langs[i+1].equalsIgnoreCase(MyLocale.language)) curlang = i+1 ;
+			langs[i + 1] = tmp[i].substring(0, tmp[i].lastIndexOf('.'));
+			if (langs[i + 1].equalsIgnoreCase(MyLocale.language))
+				curlang = i + 1;
 		}
-		//ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
-		pnlMore.addLast(inpLanguage=new mChoice(langs, curlang),DONTSTRETCH,DONTFILL|LEFT);
-		//inpLanguage.setPreferredSize(20,-1);
-		inpLanguage.setToolTip(MyLocale.getMsg(591,&quot;Select \&quot;auto\&quot; for system language or select your preferred language, e.g. DE or EN&quot;));
-		String [] metriken = {MyLocale.getMsg(589, &quot;Metric (km)&quot;), 
-				              MyLocale.getMsg(590, &quot;Imperial (mi)&quot;)};
-		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, &quot;Length units&quot;)),DONTSTRETCH,DONTFILL|LEFT);
+		// ewe.sys.Vm.copyArray(tmp, 0, langs, 1, tmp.length);
+		pnlMore.addLast(inpLanguage = new mChoice(langs, curlang), DONTSTRETCH, DONTFILL | LEFT);
+		// inpLanguage.setPreferredSize(20,-1);
+		inpLanguage.setToolTip(MyLocale.getMsg(591, &quot;Select \&quot;auto\&quot; for system language or select your preferred language, e.g. DE or EN&quot;));
+		String[] metriken = { MyLocale.getMsg(589, &quot;Metric (km)&quot;), MyLocale.getMsg(590, &quot;Imperial (mi)&quot;) };
+		pnlMore.addNext(new mLabel(MyLocale.getMsg(588, &quot;Length units&quot;)), DONTSTRETCH, DONTFILL | LEFT);
 		int currMetrik = pref.metricSystem == Metrics.METRIC ? 0 : 1;
-		pnlMore.addLast(inpMetric=new mChoice(metriken, currMetrik),DONTSTRETCH,DONTFILL|LEFT);
-		pnlMore.addLast(chkSortingGroupedByCache=new mCheckBox(MyLocale.getMsg(647,&quot;Sorting grouped by Cache&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(inpMetric = new mChoice(metriken, currMetrik), DONTSTRETCH, DONTFILL | LEFT);
+		pnlMore.addLast(chkSortingGroupedByCache = new mCheckBox(MyLocale.getMsg(647, &quot;Sorting grouped by Cache&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkSortingGroupedByCache.setState(pref.SortingGroupedByCache);
-		pnlMore.addLast(chkuseOwnSymbols=new mCheckBox(MyLocale.getMsg(649,&quot;use own symbols&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkuseOwnSymbols = new mCheckBox(MyLocale.getMsg(649, &quot;use own symbols&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkuseOwnSymbols.setState(pref.useOwnSymbols);
-		pnlMore.addLast(chkDebug=new mCheckBox(MyLocale.getMsg(648,&quot;Debug Mode&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));	
+		pnlMore.addLast(chkDebug = new mCheckBox(MyLocale.getMsg(648, &quot;Debug Mode&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 		chkDebug.setState(pref.debug);
 
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 		// Fourth/Fifth panel - Listview and Travelbugs
-		/////////////////////////////////////////////////////////
+		// ///////////////////////////////////////////////////////
 
-        mTab.addCard(pnlGeneral,MyLocale.getMsg(621,&quot;General&quot;),null);
-		mTab.addCard(pnlDisplay,MyLocale.getMsg(622,&quot;Screen&quot;),null);
-		mTab.addCard(pnlMore,MyLocale.getMsg(632,&quot;More&quot;),null);
-		mTab.addCard(tccList=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(599,&quot;checkbox&quot;),
-				MyLocale.getMsg(598,&quot;type&quot;),
-				MyLocale.getMsg(606,&quot;Difficulty&quot;),
-				MyLocale.getMsg(607,&quot;Terrain&quot;),
-				MyLocale.getMsg(597,&quot;waypoint&quot;),
-				MyLocale.getMsg(596,&quot;name&quot;),
-				MyLocale.getMsg(608,&quot;Location&quot;),
-				MyLocale.getMsg(609,&quot;Owner&quot;),
-				MyLocale.getMsg(610,&quot;Hidden&quot;),
-				MyLocale.getMsg(611,&quot;Status&quot;),
-				MyLocale.getMsg(612,&quot;Distance&quot;),
-				MyLocale.getMsg(613,&quot;Bearing&quot;),
-				MyLocale.getMsg(635,&quot;Size&quot;),
-				MyLocale.getMsg(636,&quot;OC Empfehlungen&quot;),
-				MyLocale.getMsg(637,&quot;OC Index&quot;),
-				MyLocale.getMsg(1039,&quot;Solver exists&quot;),
-				MyLocale.getMsg(1041,&quot;Note exists&quot;),
-				MyLocale.getMsg(1046,&quot;# Additionals&quot;),
-				MyLocale.getMsg(1048, &quot;# DNF Logs&quot;),
-				MyLocale.getMsg(1051, &quot;Last sync date&quot;)
-				},pref.listColMap),MyLocale.getMsg(595,&quot;List&quot;),null);
+		mTab.addCard(pnlGeneral, MyLocale.getMsg(621, &quot;General&quot;), null);
+		mTab.addCard(pnlDisplay, MyLocale.getMsg(622, &quot;Screen&quot;), null);
+		mTab.addCard(pnlMore, MyLocale.getMsg(632, &quot;More&quot;), null);
+		mTab.addCard(tccList = new TableColumnChooser(new String[] { MyLocale.getMsg(599, &quot;checkbox&quot;), MyLocale.getMsg(598, &quot;type&quot;), MyLocale.getMsg(606, &quot;Difficulty&quot;), MyLocale.getMsg(607, &quot;Terrain&quot;), MyLocale.getMsg(597, &quot;waypoint&quot;),
+				MyLocale.getMsg(596, &quot;name&quot;), MyLocale.getMsg(608, &quot;Location&quot;), MyLocale.getMsg(609, &quot;Owner&quot;), MyLocale.getMsg(610, &quot;Hidden&quot;), MyLocale.getMsg(611, &quot;Status&quot;), MyLocale.getMsg(612, &quot;Distance&quot;), MyLocale.getMsg(613, &quot;Bearing&quot;),
+				MyLocale.getMsg(635, &quot;Size&quot;), MyLocale.getMsg(636, &quot;OC Empfehlungen&quot;), MyLocale.getMsg(637, &quot;OC Index&quot;), MyLocale.getMsg(1039, &quot;Solver exists&quot;), MyLocale.getMsg(1041, &quot;Note exists&quot;), MyLocale.getMsg(1046, &quot;# Additionals&quot;),
+				MyLocale.getMsg(1048, &quot;# DNF Logs&quot;), MyLocale.getMsg(1051, &quot;Last sync date&quot;) }, pref.listColMap), MyLocale.getMsg(595, &quot;List&quot;), null);
 
-		mTab.addCard(tccBugs=new TableColumnChooser(new String[] {
-				MyLocale.getMsg(6000,&quot;Guid&quot;),
-				MyLocale.getMsg(6001,&quot;Name&quot;),
-				MyLocale.getMsg(6002,&quot;track#&quot;),
-				MyLocale.getMsg(6003,&quot;Mission&quot;),
-				MyLocale.getMsg(6004,&quot;From Prof&quot;),
-				MyLocale.getMsg(6005,&quot;From Wpt&quot;),
-				MyLocale.getMsg(6006,&quot;From Date&quot;),
-				MyLocale.getMsg(6007,&quot;From Log&quot;),
-				MyLocale.getMsg(6008,&quot;To Prof&quot;),
-				MyLocale.getMsg(6009,&quot;To Wpt&quot;),
-				MyLocale.getMsg(6010,&quot;To Date&quot;),
-				MyLocale.getMsg(6011,&quot;To Log&quot;)},pref.travelbugColMap),&quot;T-bugs&quot;,null);
-		
+		mTab.addCard(tccBugs = new TableColumnChooser(new String[] { MyLocale.getMsg(6000, &quot;Guid&quot;), MyLocale.getMsg(6001, &quot;Name&quot;), MyLocale.getMsg(6002, &quot;track#&quot;), MyLocale.getMsg(6003, &quot;Mission&quot;), MyLocale.getMsg(6004, &quot;From Prof&quot;),
+				MyLocale.getMsg(6005, &quot;From Wpt&quot;), MyLocale.getMsg(6006, &quot;From Date&quot;), MyLocale.getMsg(6007, &quot;From Log&quot;), MyLocale.getMsg(6008, &quot;To Prof&quot;), MyLocale.getMsg(6009, &quot;To Wpt&quot;), MyLocale.getMsg(6010, &quot;To Date&quot;),
+				MyLocale.getMsg(6011, &quot;To Log&quot;) }, pref.travelbugColMap), &quot;T-bugs&quot;, null);
+
 		this.addLast(mTab);
-		cancelB = new mButton(MyLocale.getMsg(614,&quot;Cancel&quot;));
+		cancelB = new mButton(MyLocale.getMsg(614, &quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
-		applyB = new mButton(MyLocale.getMsg(615,&quot;Apply&quot;));
+		addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
+		applyB = new mButton(MyLocale.getMsg(615, &quot;Apply&quot;));
 		applyB.setHotKey(0, IKeys.ACTION);
-		addLast(applyB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.LEFT));
+		addLast(applyB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.LEFT));
 	}
-	
+
 	private CellPanel separator(CellPanel pnl) {
 		CellPanel outerPnl = new CellPanel();
-		pnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.borderStyle=UIConstants.BDR_RAISEDOUTER|UIConstants.BDR_SUNKENINNER|UIConstants.BF_BOTTOM;
-		outerPnl.setTag(INSETS,new Insets(0,0,2,0));
-		outerPnl.addLast(pnl,HSTRETCH,HFILL);
+		pnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.borderStyle = UIConstants.BDR_RAISEDOUTER | UIConstants.BDR_SUNKENINNER | UIConstants.BF_BOTTOM;
+		outerPnl.setTag(INSETS, new Insets(0, 0, 2, 0));
+		outerPnl.addLast(pnl, HSTRETCH, HFILL);
 		return outerPnl;
 	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB) {
 				this.close(0);
 			}
-			if (ev.target == applyB){
+			if (ev.target == applyB) {
 				pref.setBaseDir(DataDir.getText());
 				pref.fontSize = Convert.toInt(fontSize.getText());
-				if (pref.fontSize&lt;6) pref.fontSize=11;
-				pref.logsPerPage=Common.parseInt(inpLogsPerPage.getText());
-				if (pref.logsPerPage==0) pref.logsPerPage=pref.DEFAULT_LOGS_PER_PAGE;
-				pref.maxLogsToSpider=Common.parseInt(inpMaxLogsToSpider.getText());
-				if (pref.maxLogsToSpider==0) pref.maxLogsToSpider=pref.DEFAULT_MAX_LOGS_TO_SPIDER;
-				
+				if (pref.fontSize &lt; 6)
+					pref.fontSize = 11;
+				pref.fontName = fontName.getText();
+				pref.logsPerPage = Common.parseInt(inpLogsPerPage.getText());
+				if (pref.logsPerPage == 0)
+					pref.logsPerPage = pref.DEFAULT_LOGS_PER_PAGE;
+				pref.maxLogsToSpider = Common.parseInt(inpMaxLogsToSpider.getText());
+				if (pref.maxLogsToSpider == 0)
+					pref.maxLogsToSpider = pref.DEFAULT_MAX_LOGS_TO_SPIDER;
+
 				Font defaultGuiFont = mApp.findFont(&quot;gui&quot;);
 				int sz = (pref.fontSize);
-				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz); 
-				mApp.addFont(newGuiFont, &quot;gui&quot;); 
+				Font newGuiFont = new Font(defaultGuiFont.getName(), defaultGuiFont.getStyle(), sz);
+				mApp.addFont(newGuiFont, &quot;gui&quot;);
 				mApp.fontsChanged();
 				mApp.mainApp.font = newGuiFont;
-				
+
 				pref.myAlias = Alias.getText().trim();
-				pref.password= inpPassword.getText().trim();
-				pref.gcMemberId=inpGcMemberID.getText().trim();
-				MyLocale.saveLanguage(MyLocale.language=inpLanguage.getText().toUpperCase().trim());
+				pref.password = inpPassword.getText().trim();
+				pref.gcMemberId = inpGcMemberID.getText().trim();
+				pref.userID = inpUserID.getText().trim();
+				MyLocale.saveLanguage(MyLocale.language = inpLanguage.getText().toUpperCase().trim());
 				pref.browser = Browser.getText();
 				pref.myproxy = Proxy.getText();
 				pref.myproxyport = ProxyPort.getText();
-				pref.proxyActive=chkProxyActive.getState();
-				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive); // TODO generate an error message if proxy port is not a number
-				pref.autoReloadLastProfile=chkAutoLoad.getState();
-				pref.isPremium=chkPM.getState();
-				pref.setCurrentCentreFromGPSPosition=chkSetCurrentCentreFromGPSPosition.getState();
-				pref.showDeletedImages=chkShowDeletedImg.getState();
-				pref.garminConn=chcGarminPort.getSelectedItem().toString();
-				pref.garminGPSBabelOptions=chkSynthShort.state?&quot;-s&quot;:&quot;&quot;;
-				pref.menuAtTop=chkMenuAtTop.getState();
-				pref.tabsAtTop=chkTabsAtTop.getState();
-				pref.showStatus=chkShowStatus.getState();
-				pref.hasCloseButton=chkHasCloseButton.getState();
-				pref.travelbugColMap=tccBugs.getSelectedCols();
-				pref.listColMap=tccList.getSelectedCols();
-				pref.descShowImg=chkDescShowImg.getState();
+				pref.proxyActive = chkProxyActive.getState();
+				// TODO generate an error message if proxy port is not a number
+				HttpConnection.setProxy(pref.myproxy, Common.parseInt(pref.myproxyport), pref.proxyActive);
+				pref.autoReloadLastProfile = chkAutoLoad.getState();
+				pref.isPremium = chkPM.getState();
+				pref.setCurrentCentreFromGPSPosition = chkSetCurrentCentreFromGPSPosition.getState();
+				pref.showDeletedImages = chkShowDeletedImg.getState();
+				pref.garminConn = chcGarminPort.getSelectedItem().toString();
+				pref.garminGPSBabelOptions = chkSynthShort.state ? &quot;-s&quot; : &quot;&quot;;
+				pref.menuAtTop = chkMenuAtTop.getState();
+				pref.tabsAtTop = chkTabsAtTop.getState();
+				pref.showStatus = chkShowStatus.getState();
+				pref.hasCloseButton = chkHasCloseButton.getState();
+				pref.useBigIcons = chkUseBigIcons.getState();
+				pref.useRadar = chkUseRadar.getState();
+				pref.travelbugColMap = tccBugs.getSelectedCols();
+				pref.listColMap = tccList.getSelectedCols();
+				pref.descShowImg = chkDescShowImg.getState();
 				Global.mainTab.tbP.myMod.setColumnNamesAndWidths();
 				pref.metricSystem = inpMetric.getInt() == 0 ? Metrics.METRIC : Metrics.IMPERIAL;
 				pref.spiderUpdates = inpSpiderUpdates.getInt();
 				pref.addDetailsToWaypoint = chkAddDetailsToWaypoint.getState();
 				pref.addDetailsToName = chkAddDetailsToName.getState();
-				pref.SortingGroupedByCache=chkSortingGroupedByCache.getState();
-				pref.useOwnSymbols=chkuseOwnSymbols.getState();
-				pref.debug=chkDebug.getState();
+				pref.SortingGroupedByCache = chkSortingGroupedByCache.getState();
+				pref.useOwnSymbols = chkuseOwnSymbols.getState();
+				pref.debug = chkDebug.getState();
 
 				pref.savePreferences();
 				pref.dirty = true; // Need to update table in case columns were enabled/disabled
 				this.close(0);
 			}
-			if(ev.target == brwBt){
+			if (ev.target == brwBt) {
 				FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getBaseDir());
-				fc.setTitle(MyLocale.getMsg(616,&quot;Select directory&quot;));
-				if(fc.execute() != FormBase.IDCANCEL)	DataDir.setText(fc.getChosen()+&quot;/&quot;);
+				fc.setTitle(MyLocale.getMsg(616, &quot;Select directory&quot;));
+				if (fc.execute() != FormBase.IDCANCEL)
+					DataDir.setText(fc.getChosen() + &quot;/&quot;);
 			}
-			if (ev.target == gpsB){
+			if (ev.target == gpsB) {
 				GPSPortOptions gpo = new GPSPortOptions();
 				gpo.portName = pref.mySPO.portName;
 				gpo.baudRate = pref.mySPO.baudRate;
@@ -402,36 +391,36 @@
 				gpo.forwardGpsChkB.setState(pref.forwardGPS);
 				gpo.inputBoxForwardHost.setText(pref.forwardGpsHost);
 				gpo.chcUseGpsd.select(pref.useGPSD);
-				if(pref.gpsdPort!=pref.DEFAULT_GPSD_PORT){
+				if (pref.gpsdPort != pref.DEFAULT_GPSD_PORT) {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost + &quot;:&quot; + Convert.toString(pref.gpsdPort));
-				}else{
+				} else {
 					gpo.inputBoxGpsdHost.setText(pref.gpsdHost);
 				}
 				gpo.logGpsChkB.setState(pref.logGPS);
 				gpo.inputBoxLogTimer.setText(pref.logGPSTimer);
 				Gui.setOKCancel(s);
-				if (s.execute()== FormBase.IDOK) {
-					pref.mySPO.portName = gpo.portName; 
+				if (s.execute() == FormBase.IDOK) {
+					pref.mySPO.portName = gpo.portName;
 					pref.mySPO.baudRate = gpo.baudRate;
 					pref.forwardGPS = gpo.forwardGpsChkB.getState();
 					pref.forwardGpsHost = gpo.inputBoxForwardHost.getText();
 					pref.useGPSD = gpo.chcUseGpsd.getInt();
-					String gpsdHostString = gpo.inputBoxGpsdHost.getText();	// hostname[:port]
+					String gpsdHostString = gpo.inputBoxGpsdHost.getText(); // hostname[:port]
 					int posColon = gpsdHostString.indexOf(':');
-					if(posColon&gt;=0){
-						pref.gpsdHost=gpsdHostString.substring(0,posColon);
-						pref.gpsdPort=Convert.toInt(gpsdHostString.substring(posColon+1));
-					}else{
-						pref.gpsdHost=gpsdHostString;
-						pref.gpsdPort=pref.DEFAULT_GPSD_PORT;
+					if (posColon &gt;= 0) {
+						pref.gpsdHost = gpsdHostString.substring(0, posColon);
+						pref.gpsdPort = Convert.toInt(gpsdHostString.substring(posColon + 1));
+					} else {
+						pref.gpsdHost = gpsdHostString;
+						pref.gpsdPort = pref.DEFAULT_GPSD_PORT;
 					}
 					pref.logGPS = gpo.logGpsChkB.getState();
 					pref.logGPSTimer = gpo.inputBoxLogTimer.getText();
-					gpsB.setText(&quot;GPS: &quot; + pref.mySPO.portName+&quot;/&quot;+pref.mySPO.baudRate);
+					gpsB.setText(&quot;GPS: &quot; + pref.mySPO.portName + &quot;/&quot; + pref.mySPO.baudRate);
 				}
 			}
 		}
 		super.onEvent(ev);
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/Profile.java
===================================================================
--- branches/r1.2/src/CacheWolf/Profile.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Profile.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import CacheWolf.navi.Area;
@@ -44,22 +44,25 @@
 
 /**
  * This class holds a profile, i.e. a group of caches with a centre location
- *
+ * 
  * @author salzkammergut
- *
+ * 
  */
 public class Profile {
 
-	/** The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
-	 *  this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
+	/**
+	 * The list of caches (CacheHolder objects). A pointer to this object exists in many classes in parallel to
+	 * this object, i.e. the respective class contains both a {@link Profile} object and a cacheDB Vector.
 	 */
-	public CacheDB cacheDB=new CacheDB();
+	public CacheDB cacheDB = new CacheDB();
 	/** The centre point of this group of caches. Read from ans stored to index.xml file */
-	public CWPoint centre=new CWPoint();
-	/** The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
-	 *  the index.xml and cache files live. (Excuse the English spelling of centre)     */
-	public String name=&quot;&quot;;
-	/** This is the directory for the profile. It contains a closing /.   	 */
+	public CWPoint centre = new CWPoint();
+	/**
+	 * The name of the profile. The baseDir in preferences is appended this name to give the dataDir where
+	 * the index.xml and cache files live. (Excuse the English spelling of centre)
+	 */
+	public String name = &quot;&quot;;
+	/** This is the directory for the profile. It contains a closing /. */
 	public String dataDir = &quot;&quot;;
 
 	/** Last sync date for opencaching caches */
@@ -73,11 +76,11 @@
 	private String minDistGC = &quot;&quot;;
 	/** Direction for geocaching caches */
 	private String directionGC = &quot;&quot;;
-	
-	private String gpxStyle =new String(); 
-	private String gpxTarget =new String(); 
-	private String gpxId =new String(); 
 
+	private String gpxStyle = new String();
+	private String gpxTarget = new String();
+	private String gpxId = new String();
+
 	/** path to the maps of the profile relative to the maps root */
 	private String relativeCustomMapsPath = &quot;&quot;;
 
@@ -91,7 +94,8 @@
 	private boolean showSearchResult = false;
 
 	public boolean selectionChanged = true; // (&quot;H&#228;ckchen&quot;) used by movingMap to get to knao if it should update the caches in the map
-	/** True if the profile has been modified and not saved
+	/**
+	 * True if the profile has been modified and not saved
 	 * The following modifications set this flag: New profile centre, Change of waypoint data
 	 */
 	private boolean hasUnsavedChanges = false;
@@ -100,21 +104,19 @@
 	/** version number of current format for index.xml and waypoint.xml */
 	protected static int CURRENTFILEFORMAT = 3;
 
-	//TODO Add other settings, such as max. number of logs to spider
-	//TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
+	// TODO Add other settings, such as max. number of logs to spider
+	// TODO Add settings for the preferred mapper to allow for maps other than expedia and other resolutions
 
 	/**
 	 * Constructor for a profile
-	 *
+	 * 
 	 */
-	public Profile(){ // public constructor
+	public Profile() { // public constructor
 	}
 
-
 	/**
-	 * Returns &lt;code&gt;true&lt;/code&gt; if profile needs to be changed when profile is left. Returns
-	 * &lt;code&gt;false&lt;/code&gt; if no relevant changes have been made.
-	 *
+	 * Returns &lt;code&gt;true&lt;/code&gt; if profile needs to be changed when profile is left. Returns &lt;code&gt;false&lt;/code&gt; if no relevant changes have been made.
+	 * 
 	 * @return hasUnsavedChanges
 	 */
 	public boolean hasUnsavedChanges() {
@@ -125,7 +127,7 @@
 	 * Remember that profile needs to be saved. Flag is set &lt;code&gt;true&lt;/code&gt; when parameter is
 	 * true, but it's not set to &lt;code&gt;false&lt;/code&gt; when parameter is &lt;code&gt;false&lt;/code&gt;.&lt;br&gt;
 	 * This is only done internally on saving the cache.
-	 *
+	 * 
 	 * @param hasUnsavedChanges
 	 *            the hasUnsavedChanges to set
 	 */
@@ -161,58 +163,58 @@
 	}
 
 	/**
-	 *	Method to save the index.xml file that holds the total information
-	 *	on available caches in the database. The database is nothing else
-	 *	than the collection of caches in a directory.
-	 *
-	 *   Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
-	 *
-	 *   Saves the index with the filter settings from Filter
+	 * Method to save the index.xml file that holds the total information
+	 * on available caches in the database. The database is nothing else
+	 * than the collection of caches in a directory.
+	 * 
+	 * Not sure whether we need to keep 'pref' in method signature. May eventually remove it.
+	 * 
+	 * Saves the index with the filter settings from Filter
 	 */
-//	public void saveIndex(Preferences pref, boolean showprogress){
-//		saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
-//	}
+	// public void saveIndex(Preferences pref, boolean showprogress){
+	// saveIndex(pref,showprogress, Filter.filterActive,Filter.filterInverted);
+	// }
 
-
 	/** Save index with filter settings given */
 	public void saveIndex(Preferences pref, boolean showprogress) {
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
-		if(showprogress){
-			pbf.showMainTask = true;//false;
-			pbf.setTask(h,&quot;Saving Index&quot;);
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
+		if (showprogress) {
+			pbf.showMainTask = true;// false;
+			pbf.setTask(h, &quot;Saving Index&quot;);
 			pbf.exec();
 		}
 		CacheHolder.saveAllModifiedDetails(); // this must be called first as it makes some calculations
 		PrintWriter detfile;
 		CacheHolder ch;
 		try {
-			File backup=new File(dataDir+&quot;index.bak&quot;);
+			File backup = new File(dataDir + &quot;index.bak&quot;);
 			if (backup.exists()) {
 				backup.delete();
 			}
-			File index=new File(dataDir+&quot;index.xml&quot;);
+			File index = new File(dataDir + &quot;index.xml&quot;);
 			index.rename(&quot;index.bak&quot;);
 		} catch (Exception ex) {
 			pref.log(&quot;[Profile:saveIndex]Error deleting backup or renaming index.xml&quot;);
 		}
-		try{
+		try {
 			detfile = new PrintWriter(new BufferedWriter(new FileWriter(new FileBugfix(dataDir + &quot;index.xml&quot;).getAbsolutePath())));
 		} catch (Exception e) {
-			pref.log(&quot;Problem creating index.xml &quot; + dataDir,e);
+			pref.log(&quot;Problem creating index.xml &quot; + dataDir, e);
 			return;
 		}
-		CWPoint savedCentre=centre;
-		if (centre==null || !centre.isValid() || (savedCentre.latDec==0.0 &amp;&amp; savedCentre.lonDec==0.0)) savedCentre=pref.getCurCentrePt();
+		CWPoint savedCentre = centre;
+		if (centre == null || !centre.isValid() || (savedCentre.latDec == 0.0 &amp;&amp; savedCentre.lonDec == 0.0))
+			savedCentre = pref.getCurCentrePt();
 
-		try{
+		try {
 			detfile.print(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;);
 			detfile.print(&quot;&lt;CACHELIST format=\&quot;decimal\&quot;&gt;\n&quot;);
 			detfile.print(&quot;    &lt;VERSION value = \&quot;3\&quot;/&gt;\n&quot;);
 			if (savedCentre.isValid())
-				detfile.print(&quot;    &lt;CENTRE lat=\&quot;&quot;+savedCentre.latDec+&quot;\&quot; lon=\&quot;&quot;+savedCentre.lonDec+&quot;\&quot;/&gt;\n&quot;);
-			if(getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith(&quot;null&quot;) || getLast_sync_opencaching().equals(&quot;&quot;)){
+				detfile.print(&quot;    &lt;CENTRE lat=\&quot;&quot; + savedCentre.latDec + &quot;\&quot; lon=\&quot;&quot; + savedCentre.lonDec + &quot;\&quot;/&gt;\n&quot;);
+			if (getLast_sync_opencaching() == null || getLast_sync_opencaching().endsWith(&quot;null&quot;) || getLast_sync_opencaching().equals(&quot;&quot;)) {
 				setLast_sync_opencaching(&quot;20050801000000&quot;);
 			}
 			if (getDistOC() == null || getDistOC().endsWith(&quot;null&quot;) || getDistOC().equals(&quot;&quot;)) {
@@ -232,15 +234,14 @@
 			// normal filter, because after loading there is no cache tour defined
 			// which could be used as filter criterium.
 			int activeFilterForSave;
-			if (getFilterActive()==Filter.FILTER_CACHELIST) {
+			if (getFilterActive() == Filter.FILTER_CACHELIST) {
 				activeFilterForSave = Filter.FILTER_ACTIVE;
 			} else {
 				activeFilterForSave = getFilterActive();
 			}
-			detfile.print(&quot;    &lt;FILTERCONFIG status = \&quot;&quot;+activeFilterForSave+
-					(isFilterInverted()?&quot;T&quot;:&quot;F&quot;)+&quot;\&quot; showBlacklist = \&quot;&quot;+showBlacklisted()+&quot;\&quot; /&gt;\n&quot;);
+			detfile.print(&quot;    &lt;FILTERCONFIG status = \&quot;&quot; + activeFilterForSave + (isFilterInverted() ? &quot;T&quot; : &quot;F&quot;) + &quot;\&quot; showBlacklist = \&quot;&quot; + showBlacklisted() + &quot;\&quot; /&gt;\n&quot;);
 			detfile.print(this.getCurrentFilter().toXML(&quot;&quot;));
-			detfile.print(&quot;    &lt;SYNCOC date = \&quot;&quot;+getLast_sync_opencaching()+&quot;\&quot; dist = \&quot;&quot;+getDistOC()+&quot;\&quot;/&gt;\n&quot;);
+			detfile.print(&quot;    &lt;SYNCOC date = \&quot;&quot; + getLast_sync_opencaching() + &quot;\&quot; dist = \&quot;&quot; + getDistOC() + &quot;\&quot;/&gt;\n&quot;);
 			detfile.print(&quot;    &lt;SPIDERGC dist = \&quot;&quot; + getDistGC() + &quot;\&quot; mindist = \&quot;&quot; + getMinDistGC() + &quot;\&quot; direction = \&quot;&quot; + getDirectionGC() + &quot;\&quot;/&gt;\n&quot;);
 			detfile.print(&quot;    &lt;EXPORT style = \&quot;&quot; + getGpxStyle() + &quot;\&quot; target = \&quot;&quot; + getGpxTarget() + &quot;\&quot; id = \&quot;&quot; + getGpxId() + &quot;\&quot;/&gt;\n&quot;);
 			detfile.print(&quot;    &lt;mapspath relativeDir = \&quot;&quot; + SafeXML.clean(relativeCustomMapsPath) + &quot;\&quot;/&gt;\n&quot;);
@@ -248,7 +249,8 @@
 			for (int i = 0; i &lt; size; i++) {
 				if (showprogress) {
 					h.progress = (float) i / (float) size;
-					if ((i%updFrequ)==0) h.changed();
+					if ((i % updFrequ) == 0)
+						h.changed();
 				}
 				ch = cacheDB.get(i);
 				if (ch.getWayPoint().length() &gt; 0) {
@@ -257,12 +259,14 @@
 			}
 			detfile.print(&quot;&lt;/CACHELIST&gt;\n&quot;);
 			detfile.close();
-			buildReferences(); //TODO Why is this needed here?
-			if(showprogress) pbf.exit(0);
-		}catch(Exception e){
-			pref.log(&quot;Problem writing to index file &quot;,e);
+			buildReferences(); // TODO Why is this needed here?
+			if (showprogress)
+				pbf.exit(0);
+		} catch (Exception e) {
+			pref.log(&quot;Problem writing to index file &quot;, e);
 			detfile.close();
-			if(showprogress) pbf.exit(0);
+			if (showprogress)
+				pbf.exit(0);
 		}
 		resetUnsavedChanges();
 	}
@@ -270,19 +274,20 @@
 	public void readIndex() {
 		readIndex(null);
 	}
+
 	/**
-	 *	Method to read the index.xml file that holds the total information
-	 *	on available caches in the database. The database in nothing else
-	 *	than the collection of caches in a directory.
+	 * Method to read the index.xml file that holds the total information
+	 * on available caches in the database. The database in nothing else
+	 * than the collection of caches in a directory.
 	 */
 	public void readIndex(InfoBox infoBox) {
-		int updFrequ=Vm.isMobile()?10:40; // Number of caches between screen updates
+		int updFrequ = Vm.isMobile() ? 10 : 40; // Number of caches between screen updates
 		try {
 			selectionChanged = true;
 			boolean fmtDec = false;
-			String mainInfoText = MyLocale.getMsg(5000,&quot;Loading Cache-List&quot;);
-			int wptNo=1;
-			int lastShownWpt=0;
+			String mainInfoText = MyLocale.getMsg(5000, &quot;Loading Cache-List&quot;);
+			int wptNo = 1;
+			int lastShownWpt = 0;
 			char decSep = MyLocale.getDigSeparator().charAt(0);
 			char notDecSep = decSep == '.' ? ',' : '.';
 			FileBugfix indexFile = new FileBugfix(dataDir + &quot;index.xml&quot;);
@@ -290,92 +295,106 @@
 			indexXmlVersion = 1; // Initial guess
 			in.readLine(); // &lt;?xml version= ...
 			String text = in.readLine(); // &lt;CACHELIST&gt;
-			if (text!=null &amp;&amp; text.indexOf(&quot;decimal&quot;)&gt;0) fmtDec=true;
+			if (text != null &amp;&amp; text.indexOf(&quot;decimal&quot;) &gt; 0)
+				fmtDec = true;
 			Extractor ex = new Extractor(null, &quot; = \&quot;&quot;, &quot;\&quot; &quot;, 0, true);
 
-			//ewe.sys.Time startT=new ewe.sys.Time();
+			// ewe.sys.Time startT=new ewe.sys.Time();
 			boolean convertWarningDisplayed = false;
-			while ((text = in.readLine()) != null){
+			while ((text = in.readLine()) != null) {
 				// Check for Line with cache data
-				if (text.indexOf(&quot;&lt;CACHE &quot;)&gt;=0){
+				if (text.indexOf(&quot;&lt;CACHE &quot;) &gt;= 0) {
 					if (indexXmlVersion &lt; CURRENTFILEFORMAT &amp;&amp; !convertWarningDisplayed) {
 						if (indexXmlVersion &lt; CURRENTFILEFORMAT) {
 							convertWarningDisplayed = true;
-							int res=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4407, &quot;The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done.&quot;), FormBase.YESB|FormBase.NOB).execute();
+							int res = new MessageBox(
+									MyLocale.getMsg(144, &quot;Warning&quot;),
+									MyLocale.getMsg(4407,
+											&quot;The profile files are not in the current format.%0aTherefore they are now converted to the current format. Depending of the size of the profile and the computer involved this may take some minutes. Please bear with us until the conversion is done.&quot;),
+									FormBase.YESB | FormBase.NOB).execute();
 							if (res == MessageBox.NOB) {
 								ewe.sys.Vm.exit(0);
 							}
 						}
 					}
-					if (infoBox!=null) {
+					if (infoBox != null) {
 						if (wptNo - updFrequ &gt;= lastShownWpt) {
-							infoBox.setInfo(mainInfoText+&quot;\n&quot;+String.valueOf(wptNo));
+							infoBox.setInfo(mainInfoText + &quot;\n&quot; + String.valueOf(wptNo));
 							lastShownWpt = wptNo;
 						}
 						wptNo++;
 					}
-					CacheHolder ch=new CacheHolder(text,indexXmlVersion);
+					CacheHolder ch = new CacheHolder(text, indexXmlVersion);
 					cacheDB.add(ch);
-				} else if (text.indexOf(&quot;&lt;CENTRE&quot;)&gt;=0) { // lat=  lon=
+				} else if (text.indexOf(&quot;&lt;CENTRE&quot;) &gt;= 0) { // lat= lon=
 					if (fmtDec) {
-						int start=text.indexOf(&quot;lat=\&quot;&quot;)+5;
-						String lat=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)).replace(notDecSep,decSep);
-						start=text.indexOf(&quot;lon=\&quot;&quot;)+5;
-						String lon=text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)).replace(notDecSep,decSep);
-						centre.set(Convert.parseDouble(lat),Convert.parseDouble(lon));
+						int start = text.indexOf(&quot;lat=\&quot;&quot;) + 5;
+						String lat = text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)).replace(notDecSep, decSep);
+						start = text.indexOf(&quot;lon=\&quot;&quot;) + 5;
+						String lon = text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)).replace(notDecSep, decSep);
+						centre.set(Convert.parseDouble(lat), Convert.parseDouble(lon));
 					} else {
-						int start=text.indexOf(&quot;lat=\&quot;&quot;)+5;
-						String lat=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-						start=text.indexOf(&quot;long=\&quot;&quot;)+6;
-						String lon=SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-						centre.set(lat+&quot; &quot;+lon,TransformCoordinates.CW); // Fast parse
+						int start = text.indexOf(&quot;lat=\&quot;&quot;) + 5;
+						String lat = SafeXML.cleanback(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+						start = text.indexOf(&quot;long=\&quot;&quot;) + 6;
+						String lon = SafeXML.cleanback(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+						centre.set(lat + &quot; &quot; + lon, TransformCoordinates.CW); // Fast parse
 					}
-				} else if (text.indexOf(&quot;&lt;VERSION&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;value = \&quot;&quot;)+9;
-					indexXmlVersion  = Integer.valueOf(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start))).intValue();
+				} else if (text.indexOf(&quot;&lt;VERSION&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;value = \&quot;&quot;) + 9;
+					indexXmlVersion = Integer.valueOf(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start))).intValue();
 					if (indexXmlVersion &gt; CURRENTFILEFORMAT) {
 						Global.getPref().log(&quot;[Profile:readIndex]unsupported file format&quot;);
 						clearProfile();
 						return;
 					}
-				} else if (text.indexOf(&quot;&lt;SYNCOC&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;date = \&quot;&quot;)+8;
-					setLast_sync_opencaching(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;dist = \&quot;&quot;)+8;
-					setDistOC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-				} else if (text.indexOf(&quot;mapspath&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;relativeDir = \&quot;&quot;)+15;
-					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start))).replace('\\','/'));
-				} else if (text.indexOf(&quot;&lt;SPIDERGC&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;dist = \&quot;&quot;)+8;
-					setDistGC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;mindist = \&quot;&quot;)+11;
-					if (start==10) {setMinDistGC(&quot;0&quot;);}
-					else setMinDistGC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;direction = \&quot;&quot;)+13;
-					if (start==12) {setDirectionGC(&quot;&quot;);}
-					else setDirectionGC(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-				} else if (text.indexOf(&quot;&lt;EXPORT&quot;)&gt;=0) {
-					int start=text.indexOf(&quot;style = \&quot;&quot;)+9;
-					if (start==8) {setGpxStyle(&quot;0&quot;);}
-					else setGpxStyle(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;target = \&quot;&quot;)+10;
-					if (start==9) {setGpxTarget(&quot;0&quot;);}
-					else setGpxTarget(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-					start=text.indexOf(&quot;id = \&quot;&quot;)+6;
-					if (start==5) {setGpxId(&quot;0&quot;);}
-					else setGpxId(text.substring(start,text.indexOf(&quot;\&quot;&quot;,start)));
-				} else if (indexXmlVersion &lt;=2 &amp;&amp; text.indexOf(&quot;&lt;FILTER&quot;)&gt;=0){
+				} else if (text.indexOf(&quot;&lt;SYNCOC&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;date = \&quot;&quot;) + 8;
+					setLast_sync_opencaching(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;dist = \&quot;&quot;) + 8;
+					setDistOC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+				} else if (text.indexOf(&quot;mapspath&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;relativeDir = \&quot;&quot;) + 15;
+					setRelativeCustomMapsPath(SafeXML.cleanback(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start))).replace('\\', '/'));
+				} else if (text.indexOf(&quot;&lt;SPIDERGC&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;dist = \&quot;&quot;) + 8;
+					setDistGC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;mindist = \&quot;&quot;) + 11;
+					if (start == 10) {
+						setMinDistGC(&quot;0&quot;);
+					} else
+						setMinDistGC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;direction = \&quot;&quot;) + 13;
+					if (start == 12) {
+						setDirectionGC(&quot;&quot;);
+					} else
+						setDirectionGC(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+				} else if (text.indexOf(&quot;&lt;EXPORT&quot;) &gt;= 0) {
+					int start = text.indexOf(&quot;style = \&quot;&quot;) + 9;
+					if (start == 8) {
+						setGpxStyle(&quot;0&quot;);
+					} else
+						setGpxStyle(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;target = \&quot;&quot;) + 10;
+					if (start == 9) {
+						setGpxTarget(&quot;0&quot;);
+					} else
+						setGpxTarget(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+					start = text.indexOf(&quot;id = \&quot;&quot;) + 6;
+					if (start == 5) {
+						setGpxId(&quot;0&quot;);
+					} else
+						setGpxId(text.substring(start, text.indexOf(&quot;\&quot;&quot;, start)));
+				} else if (indexXmlVersion &lt;= 2 &amp;&amp; text.indexOf(&quot;&lt;FILTER&quot;) &gt;= 0) {
 					// Read filter data of file versions 1 and 2. (Legacy code)
-					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTER&quot;)));
-					String temp=ex.findNext(); // Filter status is now first, need to deal with old versions which don't have filter status
-					if (temp.length()==2) {
+					String temp = ex.findFirst(text.substring(text.indexOf(&quot;&lt;FILTER&quot;))); // Filter status is now first, need to deal with old versions which don't have filter status
+					if (temp.length() == 2) {
 						// Compatibility with previous versions
-						if (temp.charAt(0)=='T')
+						if (temp.charAt(0) == 'T')
 							setFilterActive(Filter.FILTER_ACTIVE);
 						else
-							setFilterActive(Common.parseInt(temp.substring(0,1)));
-						setFilterInverted(temp.charAt(1)=='T');
+							setFilterActive(Common.parseInt(temp.substring(0, 1)));
+						setFilterInverted(temp.charAt(1) == 'T');
 						setFilterRose(ex.findNext());
 					} else
 						setFilterRose(temp);
@@ -386,20 +405,19 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						filterAttr[2] = Convert.parseLong(attr);
 					attr = ex.findNext();
-					setFilterAttr(filterAttr);					
+					setFilterAttr(filterAttr);
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						setFilterAttrChoice(Convert.parseInt(attr));
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
-				} else if (text.indexOf(&quot;&lt;FILTERDATA&quot;)&gt;=0){
-					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTERDATA&quot;)));
-					setFilterRose(ex.findNext());
+				} else if (text.indexOf(&quot;&lt;FILTERDATA&quot;) &gt;= 0) {
+					setFilterRose(ex.findFirst(text.substring(text.indexOf(&quot;&lt;FILTERDATA&quot;))));
 					setFilterType(ex.findNext());
 					setFilterVar(ex.findNext());
 					setFilterDist(ex.findNext());
@@ -407,7 +425,7 @@
 					setFilterTerr(ex.findNext());
 					setFilterSize(ex.findNext());
 					String attr = ex.findNext();
-					long[] filterAttr = { 0l,0l,0l,0l };					
+					long[] filterAttr = { 0l, 0l, 0l, 0l };
 					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
 						filterAttr[0] = Convert.parseLong(attr);
 					attr = ex.findNext();
@@ -418,69 +436,68 @@
 					setFilterAttrChoice(Convert.parseInt(attr));
 					setFilterStatus(SafeXML.cleanback(ex.findNext()));
 					setFilterUseRegexp(Boolean.valueOf(ex.findNext()).booleanValue());
-					attr = ex.findNext();					
-	  				if (attr != null &amp;&amp; !attr.equals(&quot;&quot;)) {
-	  					setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;)) {
+						setFilterNoCoord(Boolean.valueOf(attr).booleanValue());
 
-	  				}
-	  				else {
-	  					setFilterNoCoord(true);
-	  				}
-	  				attr = ex.findNext();					
-	  				if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
-	  					filterAttr[1] = Convert.parseLong(attr);
-	  				attr = ex.findNext();
-	  				if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
-	  					filterAttr[3] = Convert.parseLong(attr);
-	  				setFilterAttr(filterAttr);
-				} else if (text.indexOf(&quot;&lt;FILTERCONFIG&quot;)&gt;=0){
-					ex.setSource(text.substring(text.indexOf(&quot;&lt;FILTERCONFIG&quot;)));
-					String temp=ex.findNext();
-					setFilterActive(Common.parseInt(temp.substring(0,1)));
-					setFilterInverted(temp.charAt(1)=='T');
+					} else {
+						setFilterNoCoord(true);
+					}
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						filterAttr[1] = Convert.parseLong(attr);
+					attr = ex.findNext();
+					if (attr != null &amp;&amp; !attr.equals(&quot;&quot;))
+						filterAttr[3] = Convert.parseLong(attr);
+					setFilterAttr(filterAttr);
+				} else if (text.indexOf(&quot;&lt;FILTERCONFIG&quot;) &gt;= 0) {
+					String temp = ex.findFirst(text.substring(text.indexOf(&quot;&lt;FILTERCONFIG&quot;)));
+					setFilterActive(Common.parseInt(temp.substring(0, 1)));
+					setFilterInverted(temp.charAt(1) == 'T');
 					setShowBlacklisted(Boolean.valueOf(ex.findNext()).booleanValue());
 				}
 			}
 			in.close();
 			// Build references between caches and addi wpts
-			if (infoBox!=null) {
-				infoBox.setInfo(MyLocale.getMsg(5004,&quot;Building references...&quot;));
+			if (infoBox != null) {
+				infoBox.setInfo(MyLocale.getMsg(5004, &quot;Building references...&quot;));
 			}
 			buildReferences();
 			if (indexXmlVersion &lt; CURRENTFILEFORMAT) {
 				saveIndex(Global.getPref(), true);
 			}
 		} catch (FileNotFoundException e) {
-			Global.getPref().log(&quot;index.xml not found in directory &quot;+dataDir,e);
-		} catch (IOException e){
-			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot;+dataDir,e,true);
+			Global.getPref().log(&quot;index.xml not found in directory &quot; + dataDir, e);
+		} catch (IOException e) {
+			Global.getPref().log(&quot;Problem reading index.xml in dir: &quot; + dataDir, e, true);
 		}
 		this.getCurrentFilter().normaliseFilters();
 		resetUnsavedChanges();
 	}
 
-	/** Restore the filter to the values stored in this profile
-	 *  Called from Main Form and MainMenu
-	 *  The values of Filter.isActive and Filter.isInactive are set by the filter
+	/**
+	 * Restore the filter to the values stored in this profile
+	 * Called from Main Form and MainMenu
+	 * The values of Filter.isActive and Filter.isInactive are set by the filter
 	 **/
 	public void restoreFilter() {
-		restoreFilter( true );
+		restoreFilter(true);
 	}
 
 	void restoreFilter(boolean clearIfInactive) {
-		boolean inverted=isFilterInverted(); // Save it as doFilter will clear filterInverted
-		Filter flt=new Filter();
-		if (getFilterActive()==Filter.FILTER_ACTIVE) {
+		boolean inverted = isFilterInverted(); // Save it as doFilter will clear filterInverted
+		Filter flt = new Filter();
+		if (getFilterActive() == Filter.FILTER_ACTIVE) {
 			flt.setFilter();
 			flt.doFilter();
 			if (inverted) {
 				flt.invertFilter();
 				setFilterInverted(true); // Needed because previous line inverts filterInverted
 			}
-		} else if (getFilterActive()==Filter.FILTER_CACHELIST) {
+		} else if (getFilterActive() == Filter.FILTER_CACHELIST) {
 			Global.mainForm.cacheList.applyCacheList();
-			//flt.filterActive=filterActive;
-		} else if (getFilterActive()==Filter.FILTER_INACTIVE) {
+			// flt.filterActive=filterActive;
+		} else if (getFilterActive() == Filter.FILTER_INACTIVE) {
 			if (clearIfInactive) {
 				flt.clearFilter();
 			}
@@ -507,8 +524,9 @@
 	}
 
 	/**
-	 *
-	 * @param forcache maincache
+	 * 
+	 * @param forcache
+	 *            maincache
 	 * @return
 	 */
 	public String getNewAddiWayPointName(String forcache) {
@@ -522,7 +540,7 @@
 
 	/**
 	 * Call this after getNewAddiWayPointName to set the references between main and addi correctly
-	 *
+	 * 
 	 * @param ch
 	 */
 	public void setAddiRef(CacheHolder ch) {
@@ -530,15 +548,15 @@
 		int mainindex = getCacheIndex(&quot;GC&quot; + mainwpt);
 		if (mainindex &lt; 0 || !cacheDB.get(mainindex).isCacheWpt()) {
 			for (int i = 0; i &lt; OC.OCSites.length; i++) {
-				mainindex=getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
-				if (mainindex &gt;= 0 &amp;&amp; cacheDB.get(mainindex).isCacheWpt()){
+				mainindex = getCacheIndex(OC.OCSites[i][OC.OC_PREFIX] + mainwpt);
+				if (mainindex &gt;= 0 &amp;&amp; cacheDB.get(mainindex).isCacheWpt()) {
 					break;
 				}
 			}
 		}
 		if (mainindex &lt; 0 || !cacheDB.get(mainindex).isCacheWpt())
 			mainindex = getCacheIndex(&quot;CW&quot; + mainwpt);
-		if (mainindex &lt; 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */ )  {
+		if (mainindex &lt; 0 /* || !cacheDB.get(mainindex)..isCacheWpt() */) {
 			ch.setIncomplete(true);
 		} else {
 			CacheHolder mainch = cacheDB.get(mainindex);
@@ -553,8 +571,7 @@
 	}
 
 	public String toString() {
-		return &quot;Profile: Name=&quot;+name+&quot;\nCentre=&quot;+centre.toString()+&quot;\ndataDir=&quot;+dataDir+&quot;\nlastSyncOC=&quot;+
-		getLast_sync_opencaching()+&quot;\ndistOC=&quot;+getDistOC()+&quot;\ndistGC=&quot;+getDistGC();
+		return &quot;Profile: Name=&quot; + name + &quot;\nCentre=&quot; + centre.toString() + &quot;\ndataDir=&quot; + dataDir + &quot;\nlastSyncOC=&quot; + getLast_sync_opencaching() + &quot;\ndistOC=&quot; + getDistOC() + &quot;\ndistGC=&quot; + getDistGC();
 	}
 
 	public void setSelectForAll(boolean selectStatus) {
@@ -570,29 +587,34 @@
 	public int numCachesInArea; // only valid after calling getSourroundingArea
 
 	public Area getSourroundingArea(boolean onlyOfSelected) {
-		if (cacheDB == null || cacheDB.size() == 0) return null;
+		if (cacheDB == null || cacheDB.size() == 0)
+			return null;
 		CacheHolder ch;
 		CWPoint topleft = null;
 		CWPoint bottomright = null;
-		CWPoint tmpca = new CWPoint();
 		numCachesInArea = 0;
 		boolean isAddi = false;
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
 			if (!onlyOfSelected || ch.is_Checked) {
-				if (ch.pos == null) { // this can not happen
-					tmpca.set(ch.getLatLon());
-					ch.pos = new CWPoint(tmpca);
-				}
-				if (ch.pos.isValid() ){ // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
+				if (ch.getPos().isValid()) { // done: &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0 TO-DO != 0 sollte rausgenommen werden sobald in der Liste vern&#252;nftig mit nicht gesetzten pos umgegangen wird
 					isAddi = ch.isAddiWpt();
-				if (!isAddi || (isAddi &amp;&amp; ch.mainCache != null &amp;&amp; ch.pos.getDistance(ch.mainCache.pos) &lt; 1000)) { // test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -&gt; ignore it // &amp;&amp; ch.mainCache != null is only necessary because the data base may be corrupted
-						if (topleft == null) topleft = new CWPoint(ch.pos);
-						if (bottomright == null) bottomright = new CWPoint(ch.pos);
-						if (topleft.latDec &lt; ch.pos.latDec) topleft.latDec = ch.pos.latDec;
-						if (topleft.lonDec &gt; ch.pos.lonDec) topleft.lonDec = ch.pos.lonDec;
-						if (bottomright.latDec &gt; ch.pos.latDec) bottomright.latDec = ch.pos.latDec;
-						if (bottomright.lonDec &lt; ch.pos.lonDec) bottomright.lonDec = ch.pos.lonDec;
+					// test for plausiblity of coordinates of Additional Waypoints: more then 1000 km away from main Waypoint is unplausible -&gt;
+					// ignore it //
+					// &amp;&amp; ch.mainCache != null is only necessary because the data base may be corrupted
+					if (!isAddi || (isAddi &amp;&amp; ch.mainCache != null &amp;&amp; ch.getPos().getDistance(ch.mainCache.getPos()) &lt; 1000)) {
+						if (topleft == null)
+							topleft = new CWPoint(ch.getPos());
+						if (bottomright == null)
+							bottomright = new CWPoint(ch.getPos());
+						if (topleft.latDec &lt; ch.getPos().latDec)
+							topleft.latDec = ch.getPos().latDec;
+						if (topleft.lonDec &gt; ch.getPos().lonDec)
+							topleft.lonDec = ch.getPos().lonDec;
+						if (bottomright.latDec &gt; ch.getPos().latDec)
+							bottomright.latDec = ch.getPos().latDec;
+						if (bottomright.lonDec &lt; ch.getPos().lonDec)
+							bottomright.lonDec = ch.getPos().lonDec;
 						numCachesInArea++;
 					}
 				}
@@ -600,35 +622,38 @@
 		}
 		if (topleft != null &amp;&amp; bottomright != null)
 			return new Area(topleft, bottomright);
-		else return null;
+		else
+			return null;
 	}
 
 	/**
-	 *	Method to calculate bearing and distance of a cache in the index
-	 *	list.
-	 *	@see	CacheHolder
-	 *	@see	Extractor
+	 * Method to calculate bearing and distance of a cache in the index
+	 * list.
+	 * 
+	 * @see CacheHolder
+	 * @see Extractor
 	 */
-	public void updateBearingDistance(){
+	public void updateBearingDistance() {
 		CWPoint centerPoint = new CWPoint(Global.getPref().getCurCentrePt()); // Clone current centre to be sure
 		int anz = cacheDB.size();
 		CacheHolder ch;
 		// Jetzt durch die CacheDaten schleifen
-		while(--anz &gt;= 0){
+		while (--anz &gt;= 0) {
 			ch = cacheDB.get(anz); // This returns a pointer to the CacheHolder object
 			ch.calcDistance(centerPoint);
 		}
 		// The following call is not very clean as it mixes UI with base classes
 		// However, calling it from here allows us to recenter the
 		// radar panel with only one call
-		if (Global.mainTab!=null) Global.mainTab.radarP.recenterRadar();
-	} //updateBearingDistance
+		if (Global.mainTab != null)
+			Global.mainTab.radarP.recenterRadar();
+	} // updateBearingDistance
 
 	/**
 	 * Method to build the reference between addi wpt
 	 * and main cache.
 	 */
-	public void buildReferences(){
+	public void buildReferences() {
 		CacheHolder ch;
 		MyComparer myComparer = new MyComparer();
 
@@ -752,6 +777,7 @@
 	/**
 	 * If &lt;code&gt;true&lt;/code&gt; then the cache list will only display the
 	 * caches that are result of a search.
+	 * 
 	 * @return &lt;code&gt;True&lt;/code&gt; if list should only display search results
 	 */
 	public boolean showSearchResult() {
@@ -761,10 +787,12 @@
 	/**
 	 * Sets parameter if cache list should only display the caches that are
 	 * results of a search.
-	 * @param showSearchResult &lt;code&gt;True&lt;/code&gt;: List should only display search
-	 * results.
+	 * 
+	 * @param showSearchResult
+	 *            &lt;code&gt;True&lt;/code&gt;: List should only display search
+	 *            results.
 	 */
-	public void setShowSearchResult(boolean showSearchResult){
+	public void setShowSearchResult(boolean showSearchResult) {
 		this.showSearchResult = showSearchResult;
 	}
 
@@ -787,31 +815,31 @@
 	}
 
 	public String getFilterStatus() {
-    	return currentFilter.getFilterStatus();
-    }
+		return currentFilter.getFilterStatus();
+	}
 
 	public void setFilterStatus(String filterStatus) {
 		this.notifyUnsavedChanges(filterStatus != this.getFilterStatus());
-    	this.currentFilter.setFilterStatus(filterStatus);
-    }
+		this.currentFilter.setFilterStatus(filterStatus);
+	}
 
 	public boolean getFilterUseRegexp() {
-    	return currentFilter.useRegexp();
-    }
+		return currentFilter.useRegexp();
+	}
 
 	public void setFilterUseRegexp(boolean useRegexp) {
 		this.notifyUnsavedChanges(useRegexp != this.getFilterUseRegexp());
-    	this.currentFilter.setUseRegexp(useRegexp);
-    }
+		this.currentFilter.setUseRegexp(useRegexp);
+	}
 
 	public boolean getFilterNoCoord() {
-    	return currentFilter.getFilterNoCoord();
-    }
+		return currentFilter.getFilterNoCoord();
+	}
 
 	public void setFilterNoCoord(boolean filterNoCoord) {
 		this.notifyUnsavedChanges(filterNoCoord != this.getFilterNoCoord());
-    	this.currentFilter.setFilterNoCoord(filterNoCoord);
-    }
+		this.currentFilter.setFilterNoCoord(filterNoCoord);
+	}
 
 	public String getLast_sync_opencaching() {
 		return last_sync_opencaching;
@@ -854,7 +882,8 @@
 	public int getGpxId() {
 		return Convert.toInt(gpxId);
 	}
-//
+
+	//
 	public void setMinDistGC(String minDistGC) {
 		this.notifyUnsavedChanges(!minDistGC.equals(this.minDistGC));
 		this.minDistGC = minDistGC;
@@ -893,23 +922,24 @@
 		this.notifyUnsavedChanges(!rCMPath.equals(this.relativeCustomMapsPath));
 		this.relativeCustomMapsPath = rCMPath;
 	}
+
 	/**
 	 * Returns the currently active FilterData object for the profile.
+	 * 
 	 * @return Object representing the setting of the filter
 	 */
 	public FilterData getCurrentFilter() {
-    	return currentFilter;
-    }
+		return currentFilter;
+	}
 
 	public void setCurrentFilter(FilterData currentFilter) {
-    	this.currentFilter = currentFilter;
-    }
+		this.currentFilter = currentFilter;
+	}
 
 	private class MyComparer implements ewe.util.Comparer {
 
 		public int compare(Object o1, Object o2) {
-			return ((CacheHolder) o1).getWayPoint().compareTo(
-			        ((CacheHolder) o2).getWayPoint());
+			return ((CacheHolder) o1).getWayPoint().compareTo(((CacheHolder) o2).getWayPoint());
 		}
 
 	}

Modified: branches/r1.2/src/CacheWolf/RadarPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/RadarPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/RadarPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Font;
@@ -40,16 +41,16 @@
 import ewe.ui.mButton;
 
 /**
-*	The radar panel. Displays the caches around a centre point.&lt;br&gt;
-*	Handles scaling as well as toggling the different views in the radar panel.&lt;br&gt;
-*	Also handles clicking on a cache.&lt;br&gt;
-*	Class ID=500
-*/
-public class RadarPanel extends CellPanel{
+ * The radar panel. Displays the caches around a centre point.&lt;br&gt;
+ * Handles scaling as well as toggling the different views in the radar panel.&lt;br&gt;
+ * Also handles clicking on a cache.&lt;br&gt;
+ * Class ID=500
+ */
+public class RadarPanel extends CellPanel {
 	mButton btMinus = new mButton(&quot;   -   &quot;);
 	mButton btToggle = new mButton(&quot;Toggle&quot;);
 	mButton btPlus = new mButton(&quot;   +   &quot;);
-	int toggleMod = 0; //0 = cacheicons, 1= cacheWP, 2 = cacheNames
+	int toggleMod = 0; // 0 = cacheicons, 1= cacheWP, 2 = cacheNames
 	Preferences pref;
 	CacheDB cacheDB;
 	myInteractivePanel iActP;
@@ -60,54 +61,55 @@
 	CacheHolder selectedWaypoint = null;
 	MainTab mt;
 	boolean penMoving = false;
-	int x1,y1,x2,y2 = 0;
-	boolean reCenterImage=true;
+	int x1, y1, x2, y2 = 0;
+	boolean reCenterImage = true;
+
 	/**
-	* Constructor for the radar panel.
-	* Loads images, sets up the interactive panel and
-	* &quot;navigation&quot; buttons.
-	*/
-	public RadarPanel(){
+	 * Constructor for the radar panel.
+	 * Loads images, sets up the interactive panel and
+	 * &quot;navigation&quot; buttons.
+	 */
+	public RadarPanel() {
 		this.addLast(iActP = new myInteractivePanel(), CellConstants.STRETCH, CellConstants.FILL);
-		CellPanel cp = new CellPanel();
-		cp.addNext(btMinus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.WEST));
-		cp.addNext(btToggle,CellConstants.HSTRETCH, CellConstants.FILL);
-		cp.addLast(btPlus,CellConstants.HSTRETCH, (CellConstants.FILL|CellConstants.EAST));
+		final CellPanel cp = new CellPanel();
+		cp.addNext(btMinus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.WEST));
+		cp.addNext(btToggle, CellConstants.HSTRETCH, CellConstants.FILL);
+		cp.addLast(btPlus, CellConstants.HSTRETCH, (CellConstants.FILL | CellConstants.EAST));
 		this.addLast(cp, CellConstants.HSTRETCH, CellConstants.FILL);
 	}
-	
-	public void setMainTab(MainTab tb){
+
+	public void setMainTab(MainTab tb) {
 		mt = tb;
 		iActP.setMainTab(tb);
 	}
-	
+
 	/**
-	* Informs the radar panel on preferences and currently loaded cache
-	* database. It also calculates the maximum size available for drawing 
-	* the radar.
-	*/
-	public void setParam(Preferences p, CacheDB db, CacheHolder sWp){
+	 * Informs the radar panel on preferences and currently loaded cache
+	 * database. It also calculates the maximum size available for drawing
+	 * the radar.
+	 */
+	public void setParam(Preferences p, CacheDB db, CacheHolder sWp) {
 		selectedWaypoint = sWp;
 		pref = p;
 		cacheDB = db;
-		height = (pref.myAppHeight)*6/5; // add 10% each at top/bottom 
-		width = (pref.myAppWidth)*6/5;
+		height = (pref.myAppHeight) * 6 / 5; // add 10% each at top/bottom
+		width = (pref.myAppWidth) * 6 / 5;
 	}
-	
+
 	// Call this after the centre has changed to re-center the radar panel
 	public void recenterRadar() {
-		reCenterImage=true;
+		reCenterImage = true;
 	}
-	
+
 	/**
-	* Public method to draw the different caches and the
-	* radar background
-	*/
-	public void drawThePanel(){
+	 * Public method to draw the different caches and the
+	 * radar background
+	 */
+	public void drawThePanel() {
 		// If there are any images remove them!
-		int anz = iActP.images.size();
-		for(int i = 0; i&lt;anz;i++){
-			iActP.removeImage((AniImage)iActP.images.get(0));
+		final int anz = iActP.images.size();
+		for (int i = 0; i &lt; anz; i++) {
+			iActP.removeImage((AniImage) iActP.images.get(0));
 		}
 		iActP.refresh();
 		drawBackground();
@@ -116,157 +118,163 @@
 		if (reCenterImage) {
 			// Hack to scroll to left origin for a defined position for subsequent
 			// scroll which centers the image
-			iActP.scroll(-1000,-1000); 
-			Dimension dispSize=getDisplayedSize(null);
-			iActP.scroll((width-dispSize.width)/2,(height-dispSize.height+btMinus.getSize(null).height)/2);
-			reCenterImage=false;
+			iActP.scroll(-1000, -1000);
+			final Dimension dispSize = getDisplayedSize(null);
+			iActP.scroll((width - dispSize.width) / 2, (height - dispSize.height + btMinus.getSize(null).height) / 2);
+			reCenterImage = false;
 		}
 	}
-	
+
 	/**
-	* Private method to draw the caches.
-	*/
-	private void drawCaches(){
-		Font radarFont = new Font(&quot;Gui&quot;, Font.BOLD,Global.getPref().fontSize);
-		FontMetrics fm = getFontMetrics(radarFont);
+	 * Private method to draw the caches.
+	 */
+	private void drawCaches() {
+		final Font radarFont = new Font(&quot;Gui&quot;, Font.BOLD, Global.getPref().fontSize);
+		final FontMetrics fm = getFontMetrics(radarFont);
 		AniImage aImg;
 		RadarPanelImage rpi;
-		int drX,drY = 0;
+		int drX, drY = 0;
 		CacheHolder holder;
 		double degrees;
-		double pi180=java.lang.Math.PI / 180.0;
-		for(int i = cacheDB.size()-1; i &gt;=0 ; i--){
+		final double pi180 = java.lang.Math.PI / 180.0;
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			holder = cacheDB.get(i);
-			if(holder.isVisible() &amp;&amp; holder.pos.isValid()) {
+			if (holder.isVisible() &amp;&amp; holder.getPos().isValid()) {
 				degrees = holder.degrees * pi180;
-				drX =new Float(holder.kilom/scale *  java.lang.Math.sin(degrees)).intValue();
-				drY = -new Float(holder.kilom/scale *  java.lang.Math.cos(degrees)).intValue();
-				if(centerX+drX&gt;=0 &amp;&amp; centerY+drY&gt;=0 &amp;&amp; centerX+drX&lt;=width &amp;&amp; centerY+drY &lt;= height){
-					if (toggleMod&gt;0) {
+				drX = new Float(holder.kilom / scale * java.lang.Math.sin(degrees)).intValue();
+				drY = -new Float(holder.kilom / scale * java.lang.Math.cos(degrees)).intValue();
+				if (centerX + drX &gt;= 0 &amp;&amp; centerY + drY &gt;= 0 &amp;&amp; centerX + drX &lt;= width &amp;&amp; centerY + drY &lt;= height) {
+					if (toggleMod &gt; 0) {
 						String s;
-						if (toggleMod==1)
-							s=holder.getWayPoint();
+						if (toggleMod == 1)
+							s = holder.getWayPoint();
 						else
-							s=holder.getCacheName();
-						if (s.length()&gt;0) { 
+							s = holder.getCacheName();
+						if (s.length() &gt; 0) {
 							int tw;
-							Image img = new Image(tw=fm.getTextWidth(s),fm.getHeight());
-							Graphics g = new Graphics(img);
+							final Image img = new Image(tw = fm.getTextWidth(s), fm.getHeight());
+							final Graphics g = new Graphics(img);
 							g.setFont(radarFont);
 							g.setColor(Color.Black);
-							g.fillRect(0,0,tw, fm.getHeight());
+							g.fillRect(0, 0, tw, fm.getHeight());
 							g.setColor(Color.White);
-							g.drawText(s, 0,0);
+							g.drawText(s, 0, 0);
 							aImg = new AniImage(img);
-							aImg.setLocation(centerX+drX+5,centerY+drY);
+							aImg.setLocation(centerX + drX + 5, centerY + drY);
 							aImg.transparentColor = Color.Black;
 							aImg.properties = mImage.IsNotHot;
 							iActP.addImage(aImg);
 						}
 					}
-					Image imgCache=GuiImageBroker.getTypeImage(holder.getType(),true);
-					// If we have no image for the cache type use a question mark
-					if (imgCache==null) imgCache=GuiImageBroker.getTypeImage(CacheType.CW_TYPE_UNKNOWN,true); 
+					Image imgCache = CacheType.getMapImage(holder);
 					rpi = new RadarPanelImage(imgCache);
 					rpi.wayPoint = holder.getWayPoint();
 					rpi.rownum = i;
-					int dx = imgCache.getWidth();
-					int dy = imgCache.getHeight();
-					rpi.setLocation(centerX+drX-dx/2,centerY+drY-dy/2);
+					final int dx = imgCache.getWidth();
+					final int dy = imgCache.getHeight();
+					rpi.setLocation(centerX + drX - dx / 2, centerY + drY - dy / 2);
 					iActP.addImage(rpi);
-					if(holder == selectedWaypoint){ // Draw red circle around selected wpt
-						int diag = (int) (java.lang.Math.sqrt(dx*dx+dy*dy)+0.5);
-						Image imgCircle = new Image(diag, diag);
-						Graphics gCircle = new Graphics(imgCircle);
+					if (holder == selectedWaypoint) { // Draw red circle around selected wpt
+						final int diag = (int) (java.lang.Math.sqrt(dx * dx + dy * dy) + 0.5);
+						final Image imgCircle = new Image(diag, diag);
+						final Graphics gCircle = new Graphics(imgCircle);
 						gCircle.setColor(Color.Black);
-						gCircle.fillRect(0,0,diag,diag);
-						gCircle.setColor(new Color(255,0,0));
-						gCircle.drawEllipse(0,0, diag,diag);
+						gCircle.fillRect(0, 0, diag, diag);
+						gCircle.setColor(new Color(255, 0, 0));
+						gCircle.drawEllipse(0, 0, diag, diag);
 						aImg = new AniImage(imgCircle);
-						aImg.setLocation(centerX+drX-diag/2,centerY+drY-diag/2);
-						aImg.transparentColor = new Color(0,0,0);
+						aImg.setLocation(centerX + drX - diag / 2, centerY + drY - diag / 2);
+						aImg.transparentColor = new Color(0, 0, 0);
 						aImg.properties = mImage.IsNotHot;
 						iActP.addImage(aImg);
 					}
-				}//if center...
+				}// if center...
 			}// if is_black...
 		}
 	}
-	
+
 	/**
-	* Private method to draw the black background and green radar.
-	* Also calculates some other parameters.
-	* Always call this before calling drawCaches().
-	*/
-	private void drawBackground(){
-		Rect r = new Rect(new Dimension(width, height));
+	 * Private method to draw the black background and green radar.
+	 * Also calculates some other parameters.
+	 * Always call this before calling drawCaches().
+	 */
+	private void drawBackground() {
+		final Rect r = new Rect(new Dimension(width, height));
 		iActP.virtualSize = r;
 		iActP.refresh();
-		Image img = new Image(width, height);
-		Graphics g = new Graphics(img);
+		final Image img = new Image(width, height);
+		final Graphics g = new Graphics(img);
 		g.setColor(Color.Black);
-		g.fillRect(0,0,width, height);
-		
-		
-		if(width &lt; height) {
-			scale = (double)scaleKm / (double)height;
+		g.fillRect(0, 0, width, height);
+
+		if (width &lt; height) {
+			scale = (double) scaleKm / (double) height;
 		} else {
-			scale = (double)scaleKm / (double)width;
+			scale = (double) scaleKm / (double) width;
 		}
 		centerX = (width / 2);
 		centerY = (height / 2);
-		//centerY = (int)(centerY-centerY*0.15);
-		g.setColor(new Color(0,255,0));
-		int radstep= 0, steps=0, radius = 0;
-		
-		if(width &gt; height){
-			radstep = (int)(10 / scale);
+		// centerY = (int)(centerY-centerY*0.15);
+		g.setColor(new Color(0, 255, 0));
+		int radstep = 0, steps = 0, radius = 0;
+
+		if (width &gt; height) {
+			radstep = (int) (10 / scale);
 			steps = (width / radstep);
-		}else{
-			radstep = (int)(10 / scale);
+		} else {
+			radstep = (int) (10 / scale);
 			steps = (height / radstep);
 		}
-		for(int i = 1; i &lt;= steps; i++){
-			radius = (radstep * i)*2;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		for (int i = 1; i &lt;= steps; i++) {
+			radius = (radstep * i) * 2;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 		}
-		g.drawLine(centerX,0,centerX,height);
-		g.drawLine(0,centerY,width,centerY);
+		g.drawLine(centerX, 0, centerX, height);
+		g.drawLine(0, centerY, width, centerY);
 
 		// Show 1 KM radius only if we have zoomed in (useful for cities with high density of caches)
-		if (scaleKm&lt;=20) {
-			g.setColor(new Color(255,255,0)); // Yellow for 1km circle
-			radius = radstep/5;
-			g.drawEllipse(centerX-radius/2,centerY-radius/2, radius,radius);
+		if (scaleKm &lt;= 20) {
+			g.setColor(new Color(255, 255, 0)); // Yellow for 1km circle
+			radius = radstep / 5;
+			g.drawEllipse(centerX - radius / 2, centerY - radius / 2, radius, radius);
 			g.free();
-		}	
-		AniImage aImg = new AniImage(img);
-		//iActP.addImage(aImg);
+		}
+		final AniImage aImg = new AniImage(img);
+		// iActP.addImage(aImg);
 		iActP.backgroundImage = img;
-		int xPos = (pref.myAppWidth/2 - width/2);
-		aImg.setLocation(xPos,0);
+		final int xPos = (pref.myAppWidth / 2 - width / 2);
+		aImg.setLocation(xPos, 0);
 		aImg.refresh();
 	}
-	
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == btPlus){
-				if (scaleKm&gt;10) scaleKm = scaleKm - 10;
-				else if (scaleKm==10) scaleKm=5;
-				else if (scaleKm==5) scaleKm=2;
-				else scaleKm=1;
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == btPlus) {
+				if (scaleKm &gt; 10)
+					scaleKm = scaleKm - 10;
+				else if (scaleKm == 10)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 2;
+				else
+					scaleKm = 1;
 				drawThePanel();
 			}
-			if (ev.target == btMinus){
-				if (scaleKm==1) scaleKm=2;
-				else if(scaleKm==2) scaleKm=5;
-				else if(scaleKm==5) scaleKm=10;
-				else scaleKm = scaleKm + 10;
+			if (ev.target == btMinus) {
+				if (scaleKm == 1)
+					scaleKm = 2;
+				else if (scaleKm == 2)
+					scaleKm = 5;
+				else if (scaleKm == 5)
+					scaleKm = 10;
+				else
+					scaleKm = scaleKm + 10;
 				drawThePanel();
 			}
-			if (ev.target == btToggle){
+			if (ev.target == btToggle) {
 				toggleMod++;
-				if(toggleMod &gt; 2) toggleMod = 0;
+				if (toggleMod &gt; 2)
+					toggleMod = 0;
 				drawThePanel();
 			}
 		}

Modified: branches/r1.2/src/CacheWolf/SafeXML.java
===================================================================
--- branches/r1.2/src/CacheWolf/SafeXML.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/SafeXML.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,155 +1,59 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
-*	A class to replace unsafe XML characters with characters that a user
-*	&quot;can read&quot;, and vice versa
-* 20061222: skg Modified cleanback to speed up the new index.xml reader
-*/
+ *	A class to replace unsafe XML characters with characters that a user
+ *	&quot;can read&quot;, and vice versa
+ * 20061222: skg Modified cleanback to speed up the new index.xml reader
+ */
 
 import ewe.util.Hashtable;
 
-public final class SafeXML{
+public final class SafeXML {
 	private static final char ENTITY_START = '&amp;';
 	private static final char ENTITY_END = ';';
-	
+
 	private final static Hashtable iso2htmlMappings = new Hashtable(300);
 	static {
 		final String[] mappingArray = new String[] {
-				&quot;&apos;&quot;,   &quot;'&quot;,		// Added 20061227 - not a valid HTML entity but used in XML
-				&quot;&quot;&quot;,   &quot;\&quot;&quot;,
-				&quot;&amp;&quot;,    &quot;&amp;&quot;,
-				&quot;&lt;&quot;,     &quot;&lt;&quot;,
-				&quot;&gt;&quot;,     &quot;&gt;&quot;,
-				&quot;&nbsp;&quot;,   &quot; &quot;,
-				&quot;&iexcl;&quot;,  &quot;&#161;&quot;,
-				&quot;&cent;&quot;,   &quot;&#162;&quot;,
-				&quot;&pound;&quot;,  &quot;&#163;&quot;,
-				&quot;&curren;&quot;, &quot;&#164;&quot;,
-				&quot;&yen;&quot;,    &quot;&#165;&quot;,
-				&quot;&brvbar;&quot;, &quot;&#166;&quot;,
-				&quot;&sect;&quot;,   &quot;&#167;&quot;,
-				&quot;&uml;&quot;,    &quot;&#168;&quot;,
-				&quot;&copy;&quot;,   &quot;&#169;&quot;,
-				&quot;&ordf;&quot;,   &quot;&#170;&quot;,
-				&quot;&laquo;&quot;,  &quot;&#171;&quot;,
-				&quot;&not;&quot;,    &quot;&#172;&quot;,
-				&quot;&shy;&quot;,    &quot;&#173;&quot;,
-				&quot;&reg;&quot;,    &quot;&#174;&quot;,
-				&quot;&macr;&quot;,   &quot;&#175;&quot;,
-				&quot;&deg;&quot;,    &quot;&#176;&quot;,
-				&quot;&plusmn;&quot;, &quot;&#177;&quot;,
-				&quot;&amp;sup2;&quot;,   &quot;&#178;&quot;,
-				&quot;&amp;sup3;&quot;,   &quot;&#179;&quot;,
-				&quot;&acute;&quot;,  &quot;&#180;&quot;,
-				&quot;&micro;&quot;,  &quot;&#181;&quot;,
-				&quot;&para;&quot;,   &quot;&#182;&quot;,
-				&quot;&middot;&quot;, &quot;&#183;&quot;,
-				&quot;&cedil;&quot;,  &quot;&#184;&quot;,
-				&quot;&amp;sup1;&quot;,   &quot;&#185;&quot;,
-				&quot;&ordm;&quot;,   &quot;&#186;&quot;,
-				&quot;&raquo;&quot;,  &quot;&#187;&quot;,
-				&quot;&amp;frac14;&quot;, &quot;&#188;&quot;,
-				&quot;&amp;frac12;&quot;, &quot;&#189;&quot;,
-				&quot;&amp;frac34;&quot;, &quot;&#190;&quot;,
-				&quot;&iquest;&quot;, &quot;&#191;&quot;,
-				&quot;&Agrave;&quot;, &quot;&#192;&quot;,
-				&quot;&Aacute;&quot;, &quot;&#193;&quot;,
-				&quot;&Acirc;&quot;,  &quot;&#194;&quot;,
-				&quot;&Atilde;&quot;, &quot;&#195;&quot;,
-				&quot;&Auml;&quot;,   &quot;&#196;&quot;,
-				&quot;&Aring;&quot;,  &quot;&#197;&quot;,
-				&quot;&AElig;&quot;,  &quot;&#198;&quot;,
-				&quot;&Ccedil;&quot;, &quot;&#199;&quot;,
-				&quot;&Egrave;&quot;, &quot;&#200;&quot;,
-				&quot;&Eacute;&quot;, &quot;&#201;&quot;,
-				&quot;&Ecirc;&quot;,  &quot;&#202;&quot;,
-				&quot;&Euml;&quot;,   &quot;&#203;&quot;,
-				&quot;&Igrave;&quot;, &quot;&#204;&quot;,
-				&quot;&Iacute;&quot;, &quot;&#205;&quot;,
-				&quot;&Icirc;&quot;,  &quot;&#206;&quot;,
-				&quot;&Iuml;&quot;,   &quot;&#207;&quot;,
-				&quot;&ETH;&quot;,    &quot;&#208;&quot;,
-				&quot;&Ntilde;&quot;, &quot;&#209;&quot;,
-				&quot;&Ograve;&quot;, &quot;&#210;&quot;,
-				&quot;&Oacute;&quot;, &quot;&#211;&quot;,
-				&quot;&Ocirc;&quot;,  &quot;&#212;&quot;,
-				&quot;&Otilde;&quot;, &quot;&#213;&quot;,
-				&quot;&Ouml;&quot;,   &quot;&#214;&quot;,
-				&quot;&times;&quot;,  &quot;&#215;&quot;,
-				&quot;&Oslash;&quot;, &quot;&#216;&quot;,
-				&quot;&Ugrave;&quot;, &quot;&#217;&quot;,
-				&quot;&Uacute;&quot;, &quot;&#218;&quot;,
-				&quot;&Ucirc;&quot;,  &quot;&#219;&quot;,
-				&quot;&Uuml;&quot;,   &quot;&#220;&quot;,
-				&quot;&Yacute;&quot;, &quot;&#221;&quot;,
-				&quot;&THORN;&quot;,  &quot;&#222;&quot;,
-				&quot;&szlig;&quot;,  &quot;&#223;&quot;,
-				&quot;&agrave;&quot;, &quot;&#224;&quot;,
-				&quot;&aacute;&quot;, &quot;&#225;&quot;,
-				&quot;&acirc;&quot;,  &quot;&#226;&quot;,
-				&quot;&atilde;&quot;, &quot;&#227;&quot;,
-				&quot;&auml;&quot;,   &quot;&#228;&quot;,
-				&quot;&aring;&quot;,  &quot;&#229;&quot;,
-				&quot;&aelig;&quot;,  &quot;&#230;&quot;,
-				&quot;&ccedil;&quot;, &quot;&#231;&quot;,
-				&quot;&egrave;&quot;, &quot;&#232;&quot;,
-				&quot;&eacute;&quot;, &quot;&#233;&quot;,
-				&quot;&ecirc;&quot;,  &quot;&#234;&quot;,
-				&quot;&euml;&quot;,   &quot;&#235;&quot;,
-				&quot;&igrave;&quot;, &quot;&#236;&quot;,
-				&quot;&iacute;&quot;, &quot;&#237;&quot;,
-				&quot;&icirc;&quot;,  &quot;&#238;&quot;,
-				&quot;&iuml;&quot;,   &quot;&#239;&quot;,
-				&quot;&eth;&quot;,    &quot;&#240;&quot;,
-				&quot;&ntilde;&quot;, &quot;&#241;&quot;,
-				&quot;&ograve;&quot;, &quot;&#242;&quot;,
-				&quot;&oacute;&quot;, &quot;&#243;&quot;,
-				&quot;&ocirc;&quot;,  &quot;&#244;&quot;,
-				&quot;&otilde;&quot;, &quot;&#245;&quot;,
-				&quot;&ouml;&quot;,   &quot;&#246;&quot;,
-				&quot;&divide;&quot;, &quot;&#247;&quot;,
-				&quot;&oslash;&quot;, &quot;&#248;&quot;,
-				&quot;&ugrave;&quot;, &quot;&#249;&quot;,
-				&quot;&uacute;&quot;, &quot;&#250;&quot;,
-				&quot;&ucirc;&quot;,  &quot;&#251;&quot;,
-				&quot;&uuml;&quot;,   &quot;&#252;&quot;,
-				&quot;&yacute;&quot;, &quot;&#253;&quot;,
-				&quot;&thorn;&quot;,  &quot;&#254;&quot;,
-				&quot;&yuml;&quot;,   &quot;&#255;&quot;,
-				&quot;&ndash;&quot;,  &quot;&#150;&quot;
-				};
+				&quot;&apos;&quot;,
+				&quot;'&quot;, // Added 20061227 - not a valid HTML entity but used in XML
+				&quot;&quot;&quot;, &quot;\&quot;&quot;, &quot;&amp;&quot;, &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&gt;&quot;, &quot;&nbsp;&quot;, &quot; &quot;, &quot;&iexcl;&quot;, &quot;&#161;&quot;, &quot;&cent;&quot;, &quot;&#162;&quot;, &quot;&pound;&quot;, &quot;&#163;&quot;, &quot;&curren;&quot;, &quot;&#164;&quot;, &quot;&yen;&quot;, &quot;&#165;&quot;, &quot;&brvbar;&quot;, &quot;&#166;&quot;, &quot;&sect;&quot;, &quot;&#167;&quot;, &quot;&uml;&quot;, &quot;&#168;&quot;, &quot;&copy;&quot;, &quot;&#169;&quot;, &quot;&ordf;&quot;, &quot;&#170;&quot;, &quot;&laquo;&quot;,
+				&quot;&#171;&quot;, &quot;&not;&quot;, &quot;&#172;&quot;, &quot;&shy;&quot;, &quot;&#173;&quot;, &quot;&reg;&quot;, &quot;&#174;&quot;, &quot;&macr;&quot;, &quot;&#175;&quot;, &quot;&deg;&quot;, &quot;&#176;&quot;, &quot;&plusmn;&quot;, &quot;&#177;&quot;, &quot;&amp;sup2;&quot;, &quot;&#178;&quot;, &quot;&amp;sup3;&quot;, &quot;&#179;&quot;, &quot;&acute;&quot;, &quot;&#180;&quot;, &quot;&micro;&quot;, &quot;&#181;&quot;, &quot;&para;&quot;, &quot;&#182;&quot;, &quot;&middot;&quot;, &quot;&#183;&quot;, &quot;&cedil;&quot;, &quot;&#184;&quot;, &quot;&amp;sup1;&quot;, &quot;&#185;&quot;, &quot;&ordm;&quot;, &quot;&#186;&quot;,
+				&quot;&raquo;&quot;, &quot;&#187;&quot;, &quot;&amp;frac14;&quot;, &quot;&#188;&quot;, &quot;&amp;frac12;&quot;, &quot;&#189;&quot;, &quot;&amp;frac34;&quot;, &quot;&#190;&quot;, &quot;&iquest;&quot;, &quot;&#191;&quot;, &quot;&Agrave;&quot;, &quot;&#192;&quot;, &quot;&Aacute;&quot;, &quot;&#193;&quot;, &quot;&Acirc;&quot;, &quot;&#194;&quot;, &quot;&Atilde;&quot;, &quot;&#195;&quot;, &quot;&Auml;&quot;, &quot;&#196;&quot;, &quot;&Aring;&quot;, &quot;&#197;&quot;, &quot;&AElig;&quot;, &quot;&#198;&quot;, &quot;&Ccedil;&quot;, &quot;&#199;&quot;, &quot;&Egrave;&quot;, &quot;&#200;&quot;,
+				&quot;&Eacute;&quot;, &quot;&#201;&quot;, &quot;&Ecirc;&quot;, &quot;&#202;&quot;, &quot;&Euml;&quot;, &quot;&#203;&quot;, &quot;&Igrave;&quot;, &quot;&#204;&quot;, &quot;&Iacute;&quot;, &quot;&#205;&quot;, &quot;&Icirc;&quot;, &quot;&#206;&quot;, &quot;&Iuml;&quot;, &quot;&#207;&quot;, &quot;&ETH;&quot;, &quot;&#208;&quot;, &quot;&Ntilde;&quot;, &quot;&#209;&quot;, &quot;&Ograve;&quot;, &quot;&#210;&quot;, &quot;&Oacute;&quot;, &quot;&#211;&quot;, &quot;&Ocirc;&quot;, &quot;&#212;&quot;, &quot;&Otilde;&quot;, &quot;&#213;&quot;, &quot;&Ouml;&quot;, &quot;&#214;&quot;, &quot;&times;&quot;,
+				&quot;&#215;&quot;, &quot;&Oslash;&quot;, &quot;&#216;&quot;, &quot;&Ugrave;&quot;, &quot;&#217;&quot;, &quot;&Uacute;&quot;, &quot;&#218;&quot;, &quot;&Ucirc;&quot;, &quot;&#219;&quot;, &quot;&Uuml;&quot;, &quot;&#220;&quot;, &quot;&Yacute;&quot;, &quot;&#221;&quot;, &quot;&THORN;&quot;, &quot;&#222;&quot;, &quot;&szlig;&quot;, &quot;&#223;&quot;, &quot;&agrave;&quot;, &quot;&#224;&quot;, &quot;&aacute;&quot;, &quot;&#225;&quot;, &quot;&acirc;&quot;, &quot;&#226;&quot;, &quot;&atilde;&quot;, &quot;&#227;&quot;, &quot;&auml;&quot;, &quot;&#228;&quot;, &quot;&aring;&quot;, &quot;&#229;&quot;,
+				&quot;&aelig;&quot;, &quot;&#230;&quot;, &quot;&ccedil;&quot;, &quot;&#231;&quot;, &quot;&egrave;&quot;, &quot;&#232;&quot;, &quot;&eacute;&quot;, &quot;&#233;&quot;, &quot;&ecirc;&quot;, &quot;&#234;&quot;, &quot;&euml;&quot;, &quot;&#235;&quot;, &quot;&igrave;&quot;, &quot;&#236;&quot;, &quot;&iacute;&quot;, &quot;&#237;&quot;, &quot;&icirc;&quot;, &quot;&#238;&quot;, &quot;&iuml;&quot;, &quot;&#239;&quot;, &quot;&eth;&quot;, &quot;&#240;&quot;, &quot;&ntilde;&quot;, &quot;&#241;&quot;, &quot;&ograve;&quot;, &quot;&#242;&quot;, &quot;&oacute;&quot;, &quot;&#243;&quot;,
+				&quot;&ocirc;&quot;, &quot;&#244;&quot;, &quot;&otilde;&quot;, &quot;&#245;&quot;, &quot;&ouml;&quot;, &quot;&#246;&quot;, &quot;&divide;&quot;, &quot;&#247;&quot;, &quot;&oslash;&quot;, &quot;&#248;&quot;, &quot;&ugrave;&quot;, &quot;&#249;&quot;, &quot;&uacute;&quot;, &quot;&#250;&quot;, &quot;&ucirc;&quot;, &quot;&#251;&quot;, &quot;&uuml;&quot;, &quot;&#252;&quot;, &quot;&yacute;&quot;, &quot;&#253;&quot;, &quot;&thorn;&quot;, &quot;&#254;&quot;, &quot;&yuml;&quot;, &quot;&#255;&quot;, &quot;&ndash;&quot;, &quot;&#150;&quot; };
 		for (int i = 0; i &lt; mappingArray.length; i = i + 2) {
-			iso2htmlMappings.put( mappingArray[i], mappingArray[i+1]);
+			iso2htmlMappings.put(mappingArray[i], mappingArray[i + 1]);
 		}
 	}
-		
-	
-	
+
 	/**
 	 * Converts a &lt;code&gt;String&lt;/code&gt; containing HTML entities to
 	 * a &lt;code&gt;String&lt;/code&gt; containing only ISO8859-1 characters.
@@ -158,47 +62,48 @@
 	 * 8859-1 table by Martin Ramsch&lt;/a&gt;.
 	 * 
 	 * @author &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">ey at inweb.de</A>&quot;&gt;Christian Ey&lt;/a&gt;
-	 *
+	 * 
 	 * @version 1.0
-	 * @param htmlString The &lt;code&gt;String&lt;/code&gt; containing HTML
-	 * 	entities
+	 * @param htmlString
+	 *            The &lt;code&gt;String&lt;/code&gt; containing HTML
+	 *            entities
 	 * @return A &lt;code&gt;String&lt;/code&gt; containing only ISO8859-1
-	 * 	characters
+	 *         characters
 	 */
-	public final static String cleanback( String htmlString) {
+	public final static String cleanback(String htmlString) {
 		int indexStart;
 		// return immediately if string is null or does not contain &amp;
-		if (htmlString != null &amp;&amp; (indexStart = htmlString.indexOf( ENTITY_START))&gt;=0) {
+		if (htmlString != null &amp;&amp; (indexStart = htmlString.indexOf(ENTITY_START)) &gt;= 0) {
 			// copy everything from the beginning to entity start into buffer
-			StringBuffer isoBuffer = new StringBuffer( htmlString.substring( 0, indexStart));
+			StringBuffer isoBuffer = new StringBuffer(htmlString.substring(0, indexStart));
 			while (indexStart &gt;= 0) {
-				int indexEnd = htmlString.indexOf( ENTITY_END, indexStart + 1);
+				int indexEnd = htmlString.indexOf(ENTITY_END, indexStart + 1);
 				if (indexEnd &gt;= 0) {
-					int alternativeStart = htmlString.indexOf( ENTITY_START, indexStart + 1);
+					int alternativeStart = htmlString.indexOf(ENTITY_START, indexStart + 1);
 					if ((alternativeStart &gt; indexStart) &amp;&amp; (alternativeStart &lt; indexEnd)) {
 						// a second index start is found inbetween current index start
 						// and index end
-						
+
 						// flush the html string inbetween
-						isoBuffer.append( htmlString.substring( indexStart, alternativeStart));
-						
+						isoBuffer.append(htmlString.substring(indexStart, alternativeStart));
+
 						// use the second index start and loop again
 						indexStart = alternativeStart;
 					} else {
-						String entity = htmlString.substring( indexStart, indexEnd + 1);
-						appendEntityAsIsoChar(entity, isoBuffer); 
-						indexStart = htmlString.indexOf( ENTITY_START, indexEnd + 1);
+						String entity = htmlString.substring(indexStart, indexEnd + 1);
+						appendEntityAsIsoChar(entity, isoBuffer);
+						indexStart = htmlString.indexOf(ENTITY_START, indexEnd + 1);
 						if (indexStart &gt;= 0) {
 							// another entity start detected, flush the html string inbetween
-							isoBuffer.append( htmlString.substring( indexEnd + 1, indexStart));
+							isoBuffer.append(htmlString.substring(indexEnd + 1, indexStart));
 						} else {
 							// no further entity start detected, flush rest of html string
-							isoBuffer.append( htmlString.substring( indexEnd + 1));
+							isoBuffer.append(htmlString.substring(indexEnd + 1));
 						}
 					}
 				} else {
 					// entity start without matching entity end detected, ignore gracefully
-					isoBuffer.append( htmlString.substring( indexStart));
+					isoBuffer.append(htmlString.substring(indexStart));
 					break;
 				}
 			}
@@ -211,17 +116,18 @@
 
 	private final static void appendEntityAsIsoChar(String entity, StringBuffer addto) {
 		if (entity.startsWith(&quot;&amp;#&quot;)) {
-			try{
-				if (entity.charAt(2)== 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
-					addto.append((char)Integer.parseInt(entity.substring(3, entity.length()-1), 16)); 
-				else // number is decimal
-					addto.append((char)Integer.parseInt(entity.substring(2, entity.length()-1)));
+			try {
+				if (entity.charAt(2) == 'x' || entity.charAt(2) == 'X') // number in hexadecimal // not tested because I don't have an XML containing hexadecimal encodings
+					addto.append((char) Integer.parseInt(entity.substring(3, entity.length() - 1), 16));
+				else
+					// number is decimal
+					addto.append((char) Integer.parseInt(entity.substring(2, entity.length() - 1)));
 			} catch (NumberFormatException e) {
 				addto.append(entity); // not a valid number, insert original text
 			}
 
 		} // number format exception
-		else { // entity with a name like &quot;&amp;quot&quot;						
+		else { // entity with a name like &quot;&amp;quot&quot;
 			String isoCharacter = (String) iso2htmlMappings.get(entity);
 			if (isoCharacter != null) {
 				// insert iso character instead of html entity
@@ -232,127 +138,136 @@
 			}
 		}
 	}
-	
+
 	/**
-     * convert a single char to its equivalent HTML entity. Ordinary chars are
-     * not changed. 160 -&gt; &nbsp;
-     *
-     * @param c Char to convert
-     *
-     * @return equivalent string eg. &amp;, null means leave char as is.
-     */
-    private final static String charToEntity( char c )
-        {
-        switch ( c ) {
-	        case '&quot;' : return &quot;&quot;&quot;;
-	        case '&amp;' : return &quot;&amp;&quot;;
-	        case '&lt;' : return &quot;&lt;&quot;;
-	        case '&gt;' : return &quot;&gt;&quot;;
-	        case '\'': return &quot;&apos;&quot;;
-            default :
-                if ( c &lt; 127 ) {
-                    // leave alone as equivalent string.
-                    return null;
-                    // faster than String.valueOf( c ).intern();
-                } else {
-                    // use the &amp;#nnn; form
-                    return &quot;&amp;#&quot; + Integer.toString( c ) + &quot;;&quot;;
-                }
-            } // end switch
-        } // end charToEntity
+	 * convert a single char to its equivalent HTML entity. Ordinary chars are
+	 * not changed. 160 -&gt; &nbsp;
+	 * 
+	 * @param c
+	 *            Char to convert
+	 * 
+	 * @return equivalent string eg. &amp;, null means leave char as is.
+	 */
+	private final static String charToEntity(char c) {
+		switch (c) {
+		case '&quot;':
+			return &quot;&quot;&quot;;
+		case '&amp;':
+			return &quot;&amp;&quot;;
+		case '&lt;':
+			return &quot;&lt;&quot;;
+		case '&gt;':
+			return &quot;&gt;&quot;;
+		case '\'':
+			return &quot;&apos;&quot;;
+		default:
+			if (c &lt; 127) {
+				// leave alone as equivalent string.
+				return null;
+				// faster than String.valueOf( c ).intern();
+			} else {
+				// use the &amp;#nnn; form
+				return &quot;&amp;#&quot; + Integer.toString(c) + &quot;;&quot;;
+			}
+		} // end switch
+	} // end charToEntity
 
-    /**
-     * Converts text to HTML by quoting dangerous characters. Text must not
-     * already contain entities. e.g. &quot; ==&gt; &quot; &lt; ==&gt; &lt; ordinary text
-     * passes unchanged. Does not convert space to &nbsp;
-     *
-     * @param text raw text to be processed. Must not be null.
-     *
-     * @return translated text, or null if input is null.
-     */
-    public final static String clean( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( originalTextLength * 110 / 100 );
-        int charsToAppend = 0;
-        for ( int i = 0; i &lt; originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = charToEntity( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
+	/**
+	 * Converts text to HTML by quoting dangerous characters. Text must not
+	 * already contain entities. e.g. &quot; ==&gt; &quot; &lt; ==&gt; &lt; ordinary text
+	 * passes unchanged. Does not convert space to &nbsp;
+	 * 
+	 * @param text
+	 *            raw text to be processed. Must not be null.
+	 * 
+	 * @return translated text, or null if input is null.
+	 */
+	public final static String clean(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(originalTextLength * 110 / 100);
+		int charsToAppend = 0;
+		for (int i = 0; i &lt; originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = charToEntity(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
 
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
-	
-	
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
 	/**
 	 * Converts a data string to something that is safe to use inside
 	 * an XML file (like prefs.xml) - entities like &amp; are *NOT*
 	 * valid XML unless declared specially, so we must use the numerical
 	 * values here.
-	 *
-	 * @param src (String) raw text to be processed
-	 *
+	 * 
+	 * @param src
+	 *            (String) raw text to be processed
+	 * 
 	 * @return (String) translated text, or null if input is null
 	 */
-	public final static String cleanGPX(String str){
-		String dummy = STRreplace.replace(str, &quot;&amp;&quot;,&quot;&amp;&quot;);
-		//&quot;&amp;#&quot; --&gt; &quot;&amp;#&quot;); //Darstellung Umlaute etc : siehe  <A HREF="http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796">http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796</A>
+	public final static String cleanGPX(String str) {
+		String dummy = STRreplace.replace(str, &quot;&amp;&quot;, &quot;&amp;&quot;);
+		// &quot;&amp;#&quot; --&gt; &quot;&amp;#&quot;); //Darstellung Umlaute etc : siehe <A HREF="http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796">http://www.geoclub.de/viewtopic.php?f=40&amp;t=50635&amp;p=798796#p798796</A>
 		// aber so etwas nicht &quot;&amp;#entry15063&quot; --&gt; !!not!! &quot;&amp;#entry15063&quot; (Cache GCPB5P export -&gt; gpx, import -&gt; mapsource)
-		int pos=0;
-		while (pos&gt;-1) {
-			pos=dummy.indexOf(&quot;&amp;#&quot;,pos);
-			int pos1=dummy.indexOf(&quot;;&quot;,pos+6);
-			int k = pos1-pos; // wann kommt das ; als Ende eines numerischen entities?
-			if (pos&gt;-1) {
-				if ( k &lt; 12) {
-					String s = dummy.substring(pos+6,pos+8).toLowerCase();
-					char c=s.charAt(0);
-					char c1=s.charAt(1);
-					if ((c=='x' &amp;&amp; ((c1&gt;='0' &amp;&amp; c1&lt;='9') || (c1&gt;='a' &amp;&amp; c1&lt;='f'))) || (c&gt;='0' &amp;&amp; c&lt;='9')) {
-						dummy=dummy.substring(0, pos+1) + dummy.substring(pos+5, dummy.length());
+		int pos = 0;
+		while (pos &gt; -1) {
+			pos = dummy.indexOf(&quot;&amp;#&quot;, pos);
+			int pos1 = dummy.indexOf(&quot;;&quot;, pos + 6);
+			int k = pos1 - pos; // wann kommt das ; als Ende eines numerischen entities?
+			if (pos &gt; -1) {
+				if (pos1 &gt; -1) {
+					if (k &lt; 12) {
+						String s = dummy.substring(pos + 6, pos + 8).toLowerCase();
+						char c = s.charAt(0);
+						char c1 = s.charAt(1);
+						if ((c == 'x' &amp;&amp; ((c1 &gt;= '0' &amp;&amp; c1 &lt;= '9') || (c1 &gt;= 'a' &amp;&amp; c1 &lt;= 'f'))) || (c &gt;= '0' &amp;&amp; c &lt;= '9')) {
+							dummy = dummy.substring(0, pos + 1) + dummy.substring(pos + 5, dummy.length());
+						}
 					}
 				}
 				pos++;
 			}
 		}
-		dummy = STRreplace.replace(dummy, &quot;&amp;amp;&quot;,&quot;&amp;&quot;); //falls schon &amp; im str war 
-			
+		dummy = STRreplace.replace(dummy, &quot;&amp;amp;&quot;, &quot;&amp;&quot;); // falls schon &amp; im str war
+
 		dummy = STRreplace.replace(dummy, &quot;&lt;&quot;, &quot;&lt;&quot;);
 		dummy = STRreplace.replace(dummy, &quot;&gt;&quot;, &quot;&gt;&quot;);
 		dummy = STRreplace.replace(dummy, &quot;\&quot;&quot;, &quot;&quot;&quot;);
-		dummy = STRreplace.replace(dummy, &quot;'&quot;,&quot;&apos;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;'&quot;, &quot;&apos;&quot;);
 		// why
-		dummy = STRreplace.replace(dummy, &quot;\u0004&quot;,&quot;&quot;);
-		// this means changing content, 
+		dummy = STRreplace.replace(dummy, &quot;\u0004&quot;, &quot;&quot;);
+		// this means changing content,
 		// but it is the easiest way of avoiding ]]&gt; to be interpreted as endmark of CDATA-section
-		dummy = STRreplace.replace(dummy, &quot;]]&gt;&quot;,&quot;]] &gt;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;]]&gt;&quot;, &quot;]] &gt;&quot;);
 		// \ in gpx is not imported by mapsource, basecamp, garmin?...(there is no replacement)
-		dummy = STRreplace.replace(dummy, &quot;\\&quot;,&quot;BkSlsh;&quot;);
+		dummy = STRreplace.replace(dummy, &quot;\\&quot;, &quot;BkSlsh;&quot;);
 
 		return dummy;
 	}
+
 	public final static String strxmlencode(boolean src) {
 		/* bools are always safe */
 		return (src ? &quot;true&quot; : &quot;false&quot;);
 	}
+
 	public final static String strxmlencode(int src) {
 		/* numbers are always safe */
 		return (Integer.toString(src));

Modified: branches/r1.2/src/CacheWolf/Travelbug.java
===================================================================
--- branches/r1.2/src/CacheWolf/Travelbug.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/Travelbug.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,59 +1,63 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
+
 /**
  * This contains the basic information of a GC travelbug.
+ * 
  * @author salzkammergut
- *
+ * 
  */
 public class Travelbug {
-	/** GC unique id or guid (both are used depending on how the TB is picked up).
+	/**
+	 * GC unique id or guid (both are used depending on how the TB is picked up).
 	 * Travelbugs retrieved from a cache use the guid, travelbugs entered manually
-	 * use the id */
-	private String guid;       //0
+	 * use the id
+	 */
+	private String guid; // 0
 	/** GC Name i.e. &quot;First Roman Geocoin&quot; */
-	private String name;       //1
+	private String name; // 1
 	/** GC tracking no i.e. 652345, needed for logging */
-	private String trackingNo; //2 
+	private String trackingNo; // 2
 	/** GC Mission */
-	private String mission;    //3
+	private String mission; // 3
 
 	/** Construct a travelbug with a given name */
 	public Travelbug(String name) {
-		this(&quot;&quot;,name,&quot;&quot;);
+		this(&quot;&quot;, name, &quot;&quot;);
 	}
 
 	/** Construct a travelbug with id, name and mission */
 	public Travelbug(String guid, String name, String mission) {
-		setGuid(guid);
-		setName(name);
-		setMission(mission);
+		this.guid = guid;
+		this.name = SafeXML.cleanback(name);
+		this.mission = mission;
 		setTrackingNo(&quot;&quot;);
 	}
-	
+
 	public String getGuid() {
 		return guid;
 	}
@@ -85,10 +89,10 @@
 	public String getMission() {
 		return this.mission;
 	}
-	
+
 	/** Return XML representation of travelbug for storing in cache.xml */
-	public String toXML(){
-		StringBuffer s=new StringBuffer(300);
+	public String toXML() {
+		StringBuffer s = new StringBuffer(300);
 		s.append(&quot;  &lt;tb guid=\&quot;&quot;);
 		s.append(guid);
 		s.append(&quot;\&quot;&gt;&lt;name&gt;&lt;![CDATA[&quot;);
@@ -98,10 +102,10 @@
 		s.append(&quot;]]&gt;&lt;/tb&gt;\n&quot;);
 		return s.toString();
 	}
-	
+
 	/** Return HTML representation of travelbug for display on screen */
-	public String toHtml(){
-		StringBuffer s=new StringBuffer(300);
+	public String toHtml() {
+		StringBuffer s = new StringBuffer(300);
 		s.append(&quot;&lt;b&gt;Name:&lt;/b&gt; &quot;);
 		s.append(name);
 		s.append(&quot;&lt;br&gt;&quot;);

Modified: branches/r1.2/src/CacheWolf/TravelbugJourneyList.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugJourneyList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugJourneyList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -40,9 +40,15 @@
 
 public class TravelbugJourneyList extends MinML {
 
-	/** The Vector holdin the travelbug journeys */
+	/** The Vector holding the travelbug journeys */
 	private Vector tbJourneyList=new Vector(10);
 	
+	/**
+	 * Public constructor
+	 */
+	public TravelbugJourneyList() {
+	}
+
 	/** Return a TravelbugJourney */
 	public TravelbugJourney getTBJourney(int i) {
 		return (TravelbugJourney) tbJourneyList.elementAt(i);
@@ -101,9 +107,6 @@
 		return count;
 	}
 	
-	TravelbugJourneyList() { // Public constructor
-	}
-	
 	/**
 	 * Return a list of the travelbugs still in my possession
 	 * @return 

Modified: branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugJourneyScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 /**
@@ -78,8 +78,8 @@
 import ewe.ui.mLabel;
 import ewe.ui.mTabbedPanel;
 
-public class TravelbugJourneyScreen extends Form  {
-	
+public class TravelbugJourneyScreen extends Form {
+
 	/** The list control */
 	private tbListControl tcTbJourneyList;
 	/** The list model */
@@ -88,588 +88,612 @@
 	private TravelbugJourneyList tblMyTravelbugJourneys;
 	/** The panel for the lower half of the screen */
 	private CellPanel lowerpane;
-	private mInput inpName,inpTrackingNo, 
-		   inpFromDate, inpFromProfile, inpFromWaypoint, 
-	       inpToDate, inpToProfile, inpToWaypoint;
+	private mInput inpName, inpTrackingNo, inpFromDate, inpFromProfile, inpFromWaypoint, inpToDate, inpToProfile, inpToWaypoint;
 	private mLabel lblId;
-	private mButton btnFromDate,btnToDate;
+	private mButton btnFromDate, btnToDate;
 	private mCheckBox chkFromLogged, chkToLogged;
 	private HtmlDisplay txtMission;
 	private mTabbedPanel pnlTab;
-    /**	 List of TBs in the current cache */
-	private TravelbugList tblSrcCache; 
+	/** List of TBs in the current cache */
+	private TravelbugList tblSrcCache;
 	/** The currently selected row */
-	private int selectedRow=-1;
-	/** A label which holds the number of currently displayed travelbug journeys*/
+	private int selectedRow = -1;
+	/** A label which holds the number of currently displayed travelbug journeys */
 	private mLabel lblNumVisibleJourneys;
-	private final Color RED=new Color(255,0,0);
-	private int exitKeys[]={75009};
-	/** A flag to track whether the current cache has to be saved because a travelbug
+	private final Color RED = new Color(255, 0, 0);
+	private int exitKeys[] = { 75009 };
+	/**
+	 * A flag to track whether the current cache has to be saved because a travelbug
 	 * was added to or taken from it.
 	 */
-	private boolean chDmodified=false;
-	
+	private boolean chDmodified = false;
+
 	/** The current cache */
 	private CacheHolderDetail chD;
 	/** The base data of the current cache */
 	private CacheHolder ch;
 	/** The name of the current waypoint */
-	private String waypoint=&quot;&quot;;
-	
+	private String waypoint = &quot;&quot;;
+
 	public TravelbugJourneyScreen() {
-		CacheDB cacheDB=Global.getProfile().cacheDB;
+		CacheDB cacheDB = Global.getProfile().cacheDB;
 		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
 		CellPanel tablepane = split.getNextPanel();
-		int curCacheNo=Global.mainTab.tbP.getSelectedCache();
-		String cache=&quot;&quot;;
-		if (curCacheNo&gt;=0 &amp;&amp; curCacheNo&lt;cacheDB.size()) {
-			ch=cacheDB.get(curCacheNo);
-			cache=MyLocale.getMsg(6022,&quot;: Current cache: &quot;)+ch.getWayPoint()+&quot; - &quot;+ch.getCacheName();
-			waypoint=ch.getWayPoint();
-			chD=ch.getCacheDetails(true);
-			tblSrcCache=ch.getCacheDetails(true).Travelbugs;
+		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+		String cache = &quot;&quot;;
+		if (curCacheNo &gt;= 0 &amp;&amp; curCacheNo &lt; cacheDB.size()) {
+			ch = cacheDB.get(curCacheNo);
+			cache = MyLocale.getMsg(6022, &quot;: Current cache: &quot;) + ch.getWayPoint() + &quot; - &quot; + ch.getCacheName();
+			waypoint = ch.getWayPoint();
+			chD = ch.getCacheDetails(true);
+			tblSrcCache = ch.getCacheDetails(true).Travelbugs;
 		}
-		title=&quot;Travelbugs&quot;+cache;
-		tcTbJourneyList=new tbListControl();
-		tcTbJourneyList.setTableModel(modTbJourneyList=new tbListTableModel());
-		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList,ScrollablePanel.AlwaysShowVerticalScrollers),STRETCH,FILL);
-	
+		title = &quot;Travelbugs&quot; + cache;
+		tcTbJourneyList = new tbListControl();
+		tcTbJourneyList.setTableModel(modTbJourneyList = new tbListTableModel());
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList, ScrollablePanel.AlwaysShowVerticalScrollers), STRETCH, FILL);
+
 		lowerpane = split.getNextPanel();
-		
-		pnlTab=new mTabbedPanel();
-		pnlTab.extraControlsRight=lblNumVisibleJourneys=new mLabel(&quot;  0&quot;);
-		//------------------------------------------------
+
+		pnlTab = new mTabbedPanel();
+		pnlTab.extraControlsRight = lblNumVisibleJourneys = new mLabel(&quot;  0&quot;);
+		// ------------------------------------------------
 		// First Tab - Name &amp; Tracking #
-		//------------------------------------------------
-		CellPanel pnlName=new CellPanel();
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6025,&quot;Name:&quot;)),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpName=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6026,&quot;Tracking #:&quot;)),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(inpTrackingNo=new mInput(),HSTRETCH,HFILL);
-		pnlName.addNext(new mLabel(MyLocale.getMsg(6027,&quot;ID/GUID:&quot;)),DONTSTRETCH,DONTFILL);
-		pnlName.addLast(lblId=new mLabel(&quot;&quot;),HSTRETCH,HFILL);
-		pnlTab.addCard(pnlName,MyLocale.getMsg(6028,&quot;Name&quot;),&quot;Name&quot;);
-		
-		//------------------------------------------------
+		// ------------------------------------------------
+		CellPanel pnlName = new CellPanel();
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6025, &quot;Name:&quot;)), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpName = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6026, &quot;Tracking #:&quot;)), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpTrackingNo = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6027, &quot;ID/GUID:&quot;)), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(lblId = new mLabel(&quot;&quot;), HSTRETCH, HFILL);
+		pnlTab.addCard(pnlName, MyLocale.getMsg(6028, &quot;Name&quot;), &quot;Name&quot;);
+
+		// ------------------------------------------------
 		// Second Tab - Where was the TB picked up from
-		//------------------------------------------------
-		CellPanel pnlFrom=new CellPanel();
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromProfile=new mInput(),HSTRETCH,HFILL);
-		pnlFrom.addLast(inpFromWaypoint=new mInput(),HSTRETCH,HFILL);
-		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030,&quot;Date found:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addNext(inpFromDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		pnlFrom.addLast(btnFromDate=new mButton(new mImage(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		btnFromDate.modify(0,ControlConstants.TakesKeyFocus);
-		
-		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlFrom.addLast(chkFromLogged=new mCheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
-		chkFromLogged.exitKeys=exitKeys;
+		// ------------------------------------------------
+		CellPanel pnlFrom = new CellPanel();
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029, &quot;Profile/Cache:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromProfile = new mInput(), HSTRETCH, HFILL);
+		pnlFrom.addLast(inpFromWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030, &quot;Date found:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate = new mButton(new mImage(&quot;calendar.png&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		btnFromDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031, &quot;Logged:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addLast(chkFromLogged = new mCheckBox(&quot;&quot;), DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged.exitKeys = exitKeys;
 		pnlFrom.addLast(new mLabel(&quot;&quot;));
-		
-		pnlTab.addCard(pnlFrom,MyLocale.getMsg(6032,&quot;From&quot;),&quot;From&quot;);
 
-		//------------------------------------------------
+		pnlTab.addCard(pnlFrom, MyLocale.getMsg(6032, &quot;From&quot;), &quot;From&quot;);
+
+		// ------------------------------------------------
 		// Third Tab - Where was the TB dropped
-		//------------------------------------------------
-		CellPanel pnlTo=new CellPanel();
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029,&quot;Profile/Cache:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToProfile=new mInput(),HSTRETCH,HFILL);
-		pnlTo.addLast(inpToWaypoint=new mInput(),HSTRETCH,HFILL);
-		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033,&quot;Date dropped:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addNext(inpToDate=new mInput(),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
-		//inpToDate.modifyAll(DisplayOnly,0);
-		pnlTo.addLast(btnToDate=new mButton(new mImage(&quot;calendar.png&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		btnToDate.modify(0,ControlConstants.TakesKeyFocus);
-		//pnlTo.addLast(new mLabel(&quot;&quot;));
-		
-		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031,&quot;Logged:&quot;)),DONTSTRETCH,DONTFILL|WEST);
-		pnlTo.addLast(chkToLogged=new mCheckBox(&quot;&quot;),DONTSTRETCH,DONTFILL|WEST);
-		chkToLogged.exitKeys=exitKeys;
+		// ------------------------------------------------
+		CellPanel pnlTo = new CellPanel();
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029, &quot;Profile/Cache:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToProfile = new mInput(), HSTRETCH, HFILL);
+		pnlTo.addLast(inpToWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033, &quot;Date dropped:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpToDate.modifyAll(DisplayOnly,0);
+		pnlTo.addLast(btnToDate = new mButton(new mImage(&quot;calendar.png&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		btnToDate.modify(0, ControlConstants.TakesKeyFocus);
+		// pnlTo.addLast(new mLabel(&quot;&quot;));
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031, &quot;Logged:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addLast(chkToLogged = new mCheckBox(&quot;&quot;), DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged.exitKeys = exitKeys;
 		pnlTo.addLast(new mLabel(&quot;&quot;));
-		
-		pnlTab.addCard(pnlTo,MyLocale.getMsg(6034,&quot;To&quot;),&quot;To&quot;);
-		
-		//------------------------------------------------
+
+		pnlTab.addCard(pnlTo, MyLocale.getMsg(6034, &quot;To&quot;), &quot;To&quot;);
+
+		// ------------------------------------------------
 		// Last Panel - TB Mission
-		//------------------------------------------------
-		CellPanel pnlDest=new CellPanel();
-		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035,&quot;Mission:&quot;)));
-		pnlDest.addLast(txtMission=new HtmlDisplay(),STRETCH,FILL);
-		txtMission.rows=3;
-		pnlTab.addCard(pnlDest,MyLocale.getMsg(6036,&quot;Mission&quot;),&quot;Mission&quot;);
+		// ------------------------------------------------
+		CellPanel pnlDest = new CellPanel();
+		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035, &quot;Mission:&quot;)));
+		pnlDest.addLast(txtMission = new HtmlDisplay(), STRETCH, FILL);
+		txtMission.rows = 3;
+		pnlTab.addCard(pnlDest, MyLocale.getMsg(6036, &quot;Mission&quot;), &quot;Mission&quot;);
 
-		
-		lowerpane.addLast(pnlTab,STRETCH,FILL);
-		
-		
-		split.setSplitter(PanelSplitter.AFTER|PanelSplitter.HIDDEN,PanelSplitter.BEFORE|PanelSplitter.HIDDEN,0);
-		addLast(split,STRETCH,FILL);
-		//setPreferredSize(MyLocale.getScreenWidth()&lt;=240?240:MyLocale.getScreenWidth()*2/3,240);
-		
-		tblMyTravelbugJourneys=new TravelbugJourneyList();
+		lowerpane.addLast(pnlTab, STRETCH, FILL);
+
+		split.setSplitter(PanelSplitter.AFTER | PanelSplitter.HIDDEN, PanelSplitter.BEFORE | PanelSplitter.HIDDEN, 0);
+		addLast(split, STRETCH, FILL);
+		// setPreferredSize(MyLocale.getScreenWidth()&lt;=240?240:MyLocale.getScreenWidth()*2/3,240);
+
+		tblMyTravelbugJourneys = new TravelbugJourneyList();
 		tblMyTravelbugJourneys.readTravelbugsFile();
-		modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
 		// Get the columns to display and their widths from preferences
-		modTbJourneyList.columnMap=
-			TableColumnChooser.str2Array(Global.getPref().travelbugColMap,0,11,0, -1);
-		modTbJourneyList.colWidth=
-			TableColumnChooser.str2Array(Global.getPref().travelbugColWidth,10,1024,50, -1);
-		modTbJourneyList.numCols=modTbJourneyList.columnMap.length;
-		
-		modTbJourneyList.select(0,12,true);
+		modTbJourneyList.columnMap = TableColumnChooser.str2Array(Global.getPref().travelbugColMap, 0, 11, 0, -1);
+		modTbJourneyList.colWidth = TableColumnChooser.str2Array(Global.getPref().travelbugColWidth, 10, 1024, 50, -1);
+		modTbJourneyList.numCols = modTbJourneyList.columnMap.length;
+
+		modTbJourneyList.select(0, 12, true);
 		/* Restore the saved setting about showing only non-logged bugs */
 		if (Global.getPref().travelbugShowOnlyNonLogged) {
 			tcTbJourneyList.toggleNonLogged();
 		}
 		updateNumBugs();
 	}
-	
+
 	/** Indicate the number of journeys currently displayed */
 	private void updateNumBugs() {
-		lblNumVisibleJourneys.setText(&quot;&quot;+modTbJourneyList.numRows);
+		lblNumVisibleJourneys.setText(&quot;&quot; + modTbJourneyList.numRows);
 		lblNumVisibleJourneys.repaint();
 	}
-	
+
 	/** The control which had the last focus */
 	private Control currentControl;
-	
-	public void onEvent(Event ev){
-		// Update the table from the input form  
-		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) &amp;&amp; selectedRow!=-1 &amp;&amp;
-				selectedRow&lt;tblMyTravelbugJourneys.size()){
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			if (currentControl==inpName) 			tbj.getTb().setName(inpName.getText());
-			else if (currentControl==inpTrackingNo)  tbj.getTb().setTrackingNo(inpTrackingNo.getText());
-			else if (currentControl==inpFromProfile) tbj.setFromProfile(inpFromProfile.getText());
-			else if (currentControl==inpFromWaypoint)tbj.setFromWaypoint(inpFromWaypoint.getText());
-			else if (currentControl==inpFromDate)    tbj.setFromDate(inpFromDate.getText());
-			else if (currentControl==chkFromLogged)  tbj.setFromLogged(chkFromLogged.state);
-			else if (currentControl==inpToProfile)   tbj.setToProfile(inpToProfile.getText());
-			else if (currentControl==inpToWaypoint)  tbj.setToWaypoint(inpToWaypoint.getText());
-			else if (currentControl==inpToDate)      tbj.setToDate(inpToDate.getText());
-			else if (currentControl==chkToLogged)    tbj.setToLogged(chkToLogged.state);
-			//else if (ev.target==txtMission)     tb.setMission(txtMission.getText());
+
+	public void onEvent(Event ev) {
+		// Update the table from the input form
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) &amp;&amp; selectedRow != -1 &amp;&amp; selectedRow &lt; tblMyTravelbugJourneys.size()) {
+			TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+			if (currentControl == inpName)
+				tbj.getTb().setName(inpName.getText());
+			else if (currentControl == inpTrackingNo)
+				tbj.getTb().setTrackingNo(inpTrackingNo.getText());
+			else if (currentControl == inpFromProfile)
+				tbj.setFromProfile(inpFromProfile.getText());
+			else if (currentControl == inpFromWaypoint)
+				tbj.setFromWaypoint(inpFromWaypoint.getText());
+			else if (currentControl == inpFromDate)
+				tbj.setFromDate(inpFromDate.getText());
+			else if (currentControl == chkFromLogged)
+				tbj.setFromLogged(chkFromLogged.state);
+			else if (currentControl == inpToProfile)
+				tbj.setToProfile(inpToProfile.getText());
+			else if (currentControl == inpToWaypoint)
+				tbj.setToWaypoint(inpToWaypoint.getText());
+			else if (currentControl == inpToDate)
+				tbj.setToDate(inpToDate.getText());
+			else if (currentControl == chkToLogged)
+				tbj.setToLogged(chkToLogged.state);
+			// else if (ev.target==txtMission) tb.setMission(txtMission.getText());
 			tcTbJourneyList.repaint();
 		}
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED &amp;&amp; selectedRow!=-1){
-			if (ev.target==inpTrackingNo) {pnlTab.selectNextTab(true,true); Gui.takeFocus(inpFromProfile,ControlConstants.ByKeyboard);pnlTab.repaint(); }
-			if (ev.target==inpFromDate) Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
-			if (ev.target==inpToDate) Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
-			if (ev.target==btnFromDate || ev.target==btnToDate) {
-				mInput inpDate=ev.target==btnFromDate ? inpFromDate : inpToDate;
-				DateTimeChooser dc=new DateTimeChooser(Vm.getLocale());
-				dc.title=MyLocale.getMsg(328,&quot;Date found&quot;); 
-				dc.setPreferredSize(240,240);
-				String foundDate=inpDate.getText();
-				Time t=new Time();
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED &amp;&amp; selectedRow != -1) {
+			if (ev.target == inpTrackingNo) {
+				pnlTab.selectNextTab(true, true);
+				Gui.takeFocus(inpFromProfile, ControlConstants.ByKeyboard);
+				pnlTab.repaint();
+			}
+			if (ev.target == inpFromDate)
+				Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+			if (ev.target == inpToDate)
+				Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+			if (ev.target == btnFromDate || ev.target == btnToDate) {
+				mInput inpDate = ev.target == btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, &quot;Date found&quot;);
+				dc.setPreferredSize(240, 240);
+				String foundDate = inpDate.getText();
+				Time t = new Time();
 				try {
-					t.parse(foundDate,&quot;y-M-d H:m&quot;);
-				} catch(IllegalArgumentException e) {
+					t.parse(foundDate, &quot;y-M-d H:m&quot;);
+				} catch (IllegalArgumentException e) {
 					try {
-						t.parse(foundDate,&quot;y-M-d&quot;);
-					} catch(IllegalArgumentException e1) {
+						t.parse(foundDate, &quot;y-M-d&quot;);
+					} catch (IllegalArgumentException e1) {
 						// Can't parse date - should not happen
 					}
-				};
+				}
+				;
 				dc.reset(t);
-				if (dc.execute()==ewe.ui.FormBase.IDOK) {
-				  inpDate.setText(Convert.toString(dc.year)+&quot;-&quot;+MyLocale.formatLong(dc.month,&quot;00&quot;)+&quot;-&quot;+MyLocale.formatLong(dc.day,&quot;00&quot;)+&quot; &quot;+dc.time);
-				  if (ev.target==btnFromDate){ 
-					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
-					  Gui.takeFocus(chkFromLogged,ControlConstants.ByKeyboard);
-				  } else {
-					  tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
-					  Gui.takeFocus(chkToLogged,ControlConstants.ByKeyboard);
-				  } tcTbJourneyList.repaint();
-				}				
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpDate.setText(Convert.toString(dc.year) + &quot;-&quot; + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot; + MyLocale.formatLong(dc.day, &quot;00&quot;) + &quot; &quot; + dc.time);
+					if (ev.target == btnFromDate) {
+						tblMyTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
+						Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+					} else {
+						tblMyTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
+						Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+					}
+					tcTbJourneyList.repaint();
+				}
 			}
 		}
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED){
-			pnlTab.selectNextTab(true,true); 
-			if (ev.target==chkFromLogged) Gui.takeFocus(inpToProfile,ControlConstants.ByKeyboard);
-			if (ev.target==chkToLogged) Gui.takeFocus(txtMission,ControlConstants.ByKeyboard);
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED) {
+			pnlTab.selectNextTab(true, true);
+			if (ev.target == chkFromLogged)
+				Gui.takeFocus(inpToProfile, ControlConstants.ByKeyboard);
+			if (ev.target == chkToLogged)
+				Gui.takeFocus(txtMission, ControlConstants.ByKeyboard);
 		}
 		// The user closed the travelbugs screen
-		if (ev instanceof FormEvent &amp;&amp; ev.type==FormEvent.CLOSED  &amp;&amp; chD!=null) {
+		if (ev instanceof FormEvent &amp;&amp; ev.type == FormEvent.CLOSED &amp;&amp; chD != null) {
 			tblMyTravelbugJourneys.saveTravelbugsFile();
 			tblMyTravelbugJourneys.clear();
 			// Save the flag about showing non-logged journeys only
-			boolean old=Global.getPref().travelbugShowOnlyNonLogged;
-			Global.getPref().travelbugShowOnlyNonLogged=(tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked;
-			String travelbugColWidth=modTbJourneyList.getColWidths();
+			boolean old = Global.getPref().travelbugShowOnlyNonLogged;
+			Global.getPref().travelbugShowOnlyNonLogged = (tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked;
+			String travelbugColWidth = modTbJourneyList.getColWidths();
 			// If the preferences changed, save the pref.xml file
 			Vm.showWait(true);
-			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) ||
-				old!=Global.getPref().travelbugShowOnlyNonLogged) {
-				Global.getPref().travelbugColWidth=travelbugColWidth;
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) || old != Global.getPref().travelbugShowOnlyNonLogged) {
+				Global.getPref().travelbugColWidth = travelbugColWidth;
 				Global.getPref().savePreferences();
 			}
 			// If the list of travelbugs in the cache was modified, we need to save the cache too
 			if (chDmodified) {
-				ch.setHas_bugs(chD.Travelbugs.size()&gt;0);
+				ch.setHas_bugs(chD.Travelbugs.size() &gt; 0);
 				ch.save();
 			}
 			Vm.showWait(false);
-			chD=null;
+			chD = null;
 		}
 		updateNumBugs();
-		currentControl=Gui.focusedControl();
+		currentControl = Gui.focusedControl();
 	}
-	
-	
-//==============================================================
-// tbListTableModel
-//==============================================================
-class tbListTableModel extends TableModel {
-	private FontMetrics fm;
-	private Image imgRed;
-	tbListTableModel() {
-		
-		fillToEqualHeights=true;
-		allRowsSameSize=true;
-		hasRowHeaders=false;
-		//shadeAlternateRows=true;
-		cursorSize=new Dimension(12,1);
-		clipData=true;
-		fm=getFontMetrics();
-		// A red dot indicates that the journey has not been completely logged
-		imgRed = new Image(&quot;red.png&quot;);
-	}
-    private int colWidth[];
-	private int columnMap[];
-	
-	public Object getCellText(int row, int col) {
-		return null;
-	}
 
-	public Object getCellData(int row, int col){
-		if(row == -1){
-			return TravelbugJourney.getElementNameByNumber(columnMap[col]);
-		} else {
-			int map=columnMap[col];
-			// If we have not yet logged the from or the to, a red dot is placed in front of the first item
-			if (col==0 &amp;&amp; (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() ||
-				!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) { 
-				// Is it a column with a checkbox?
-				if (map!=7 &amp;&amp; map!=11) 
-					return new IconAndText((IImage)imgRed,(String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map),fm);
-				else { // Checkbox - special treatment
-					IconAndText iat=new IconAndText(imgRed,&quot;&quot;,fm);
-					iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
-					return iat;
-				}
-			} else 
-				return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
-		}	
-	}
-	public int calculateRowHeight(int row) {
-		return charHeight+2;
-	}
-	
-	public int calculateColWidth(int col){
-		if(col == -1) 
-        	return 0;
-        else if (col&lt;numCols)
-        	return colWidth[columnMap[col]];
-        else return 0;
-	}
-	
-	public TableCellAttributes getCellAttributes(int row,int col,boolean isSelected,TableCellAttributes ta) {
-		ta=super.getCellAttributes(row,col,isSelected,ta);
-		ta.alignment = CellConstants.LEFT;
-		ta.anchor = CellConstants.LEFT;
-		// Color the elements red, if we have not yet logged
-		if (row&gt;=0)
-		switch (columnMap[col]) {
-		case 6: // fromDate
-				if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged()) ta.foreground=RED;
-				break;
-		case 10: // toDate
-				if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged()) ta.foreground=RED;
-				break;
+	// ==============================================================
+	// tbListTableModel
+	// ==============================================================
+	class tbListTableModel extends TableModel {
+		private FontMetrics fm;
+		private Image imgRed;
+
+		tbListTableModel() {
+
+			fillToEqualHeights = true;
+			allRowsSameSize = true;
+			hasRowHeaders = false;
+			// shadeAlternateRows=true;
+			cursorSize = new Dimension(12, 1);
+			clipData = true;
+			fm = getFontMetrics();
+			// A red dot indicates that the journey has not been completely logged
+			imgRed = new Image(&quot;red.png&quot;);
 		}
-		return ta;
-	}
 
-	private void showFields(TravelbugJourney tbj) {
-	   	inpName.setText(tbj.getTb().getName());
-		inpTrackingNo.setText(tbj.getTb().getTrackingNo());
-		lblId.setText(tbj.getTb().getGuid());
-		inpFromProfile.setText(tbj.getFromProfile());
-		inpFromWaypoint.setText(tbj.getFromWaypoint());
-		inpFromDate.setText(tbj.getFromDate());
-		chkFromLogged.setState(tbj.getFromLogged());
-		inpToProfile.setText(tbj.getToProfile());
-		inpToWaypoint.setText(tbj.getToWaypoint());
-		inpToDate.setText(tbj.getToDate());
-		chkToLogged.setState(tbj.getToLogged());
-		txtMission.setHtml(tbj.getTb().getMission());
-	}
-	
-	private boolean sortAsc=false;
-	private int sortedBy = -1;
-	private int lastRow=-1;
-	public int penEventModifiers; 
+		private int colWidth[];
+		private int columnMap[];
 
-	public boolean penPressed(Point onTable,Point cell){
-		boolean retval=false;
-		if(cell!=null &amp;&amp; cell.y == -1){ // Hit a header =&gt; sort the table accordingly
-			Vm.showWait(true);
-			if (cell.x == sortedBy) sortAsc=!sortAsc;
-			else sortAsc = false;
-			sortedBy = cell.x;
-			// Check whether the list only shows non-logged journeys. If so, a subset
-			// of the table must be sorted
-			if ((tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
-				tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc,modTbJourneyList.numRows);
-			} else { // Showing all journeys - sort the full table
-				tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+		public Object getCellText(int row, int col) {
+			return null;
+		}
+
+		public Object getCellData(int row, int col) {
+			if (row == -1) {
+				return TravelbugJourney.getElementNameByNumber(columnMap[col]);
+			} else {
+				int map = columnMap[col];
+				// If we have not yet logged the from or the to, a red dot is placed in front of the first item
+				if (col == 0 &amp;&amp; (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged() || !tblMyTravelbugJourneys.getTBJourney(row).getToLogged())) {
+					// Is it a column with a checkbox?
+					if (map != 7 &amp;&amp; map != 11)
+						return new IconAndText((IImage) imgRed, (String) tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map), fm);
+					else { // Checkbox - special treatment
+						IconAndText iat = new IconAndText(imgRed, &quot;&quot;, fm);
+						iat.addColumn(tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+						return iat;
+					}
+				} else
+					return tblMyTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
 			}
-			tcTbJourneyList.repaint();
-			Vm.showWait(false);
-			retval = true;
-		} else if (cell!=null &amp;&amp; cell.y&gt;=0 &amp;&amp; (penEventModifiers &amp; IKeys.SHIFT)&gt;0) {
-			// A range of rows can be marked by shift-click on the first and last row
-			if (lastRow!=-1) { // Second row being marked with shift key pressed
-				if (lastRow&lt;cell.y)
-					toggleSelect(lastRow,cell.y);
-				else
-					toggleSelect(cell.y,lastRow);
-				lastRow=-1;
-				retval=true;
-			} else { // Remember this row as start of range, but don't toggle yet
-				lastRow=cell.y;
-			}
-		} else { // Single row marked
-			lastRow=-1;
 		}
-		return retval;
-	}
 
-	/** Select a range of rows */
-	private void toggleSelect(int fromRow, int toRow) {
-		tcTbJourneyList.clearSelection(null);
-		tcTbJourneyList.addToSelection(new Rect(0,fromRow,numCols,toRow-fromRow+1),false,true);
-	}
-	
-	/**
-	 * Return the column widths as a comma delimited string for storing in the preferences
-	 * @return
-	 */
-	private String getColWidths() {
-		// Update the list with the current widths
-		for (int col=0; col&lt;numCols; col++) {
-			colWidth[columnMap[col]]=getColWidth(col);
+		public int calculateRowHeight(int row) {
+			return charHeight + 2;
 		}
-		// Convert to string
-		StringBuffer sb=new StringBuffer(40);
-		for (int i=0; i&lt;colWidth.length; i++) {
-			if (sb.length()!=0) sb.append(',');
-			sb.append(colWidth[i]);
-		}
-		return sb.toString();
-	}
-}
 
-//==============================================================
-//tbListControl
-//==============================================================
-class tbListControl extends TableControl {
-	private MenuItem mnuNewTB, mnuDeleteTB,mnuGetMission,mnuOpenOnline,mnuDropTB,mnuPickupTB,mnuDeleteTBs;
-	public MenuItem mnuToggleList;
-	private Menu mnuFullMenu,mnuDeleteMenu;
-	
-	tbListControl() {
-		MenuItem[] TBMenuItems=new MenuItem[10];
-		TBMenuItems[0]= mnuPickupTB = new MenuItem(MyLocale.getMsg(6040,&quot;Pick up TB from current cache&quot;));
-		TBMenuItems[1]= mnuDropTB = new MenuItem(MyLocale.getMsg(6041,&quot;Drop TB in cache&quot;));
-		TBMenuItems[2]= new MenuItem(&quot;-&quot;);
-		TBMenuItems[3]= mnuNewTB = new MenuItem(MyLocale.getMsg(6042,&quot;New Travelbug&quot;));
-		TBMenuItems[4]= mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043,&quot;Delete Travelbug&quot;));
-		TBMenuItems[5]= new MenuItem(&quot;-&quot;);
-		TBMenuItems[6]= mnuGetMission = new MenuItem(MyLocale.getMsg(6044,&quot;Get Mission&quot;));
-		TBMenuItems[7]= mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045,&quot;Open on-line&quot;));
-		TBMenuItems[8]= new MenuItem(&quot;-&quot;);
-		TBMenuItems[9]= mnuToggleList = new MenuItem(MyLocale.getMsg(6046,&quot;Show only not logged&quot;));
-		mnuFullMenu=new Menu(TBMenuItems,&quot;&quot;);
-		// A second pop-up menu with only one entry, if a range of rows is selected
-		MenuItem[] TBMenuItemsDel=new MenuItem[1];
-		TBMenuItemsDel[0]=mnuDeleteTBs=new MenuItem(MyLocale.getMsg(6047,&quot;Delete selected Travelbugs&quot;));
-		mnuDeleteMenu=new Menu(TBMenuItemsDel,&quot;&quot;);
-		mnuDropTB.modifiers|=MenuItem.Disabled;
-		mnuDeleteTB.modifiers|=MenuItem.Disabled;
-		mnuGetMission.modifiers|=MenuItem.Disabled;
-		mnuOpenOnline.modifiers|=MenuItem.Disabled;
-	}
-	
-	public void onEvent(Event ev) {
-		Rect sel=getSelection(null);
-		if (sel.y&lt;tblMyTravelbugJourneys.size()) {
-			mnuDeleteTB.modifiers&amp;=~MenuItem.Disabled;
-			mnuGetMission.modifiers&amp;=~MenuItem.Disabled;
-			mnuOpenOnline.modifiers&amp;=~MenuItem.Disabled;
-			if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession()) 
-				mnuDropTB.modifiers&amp;=~MenuItem.Disabled;
+		public int calculateColWidth(int col) {
+			if (col == -1)
+				return 0;
+			else if (col &lt; numCols)
+				return colWidth[columnMap[col]];
 			else
-				mnuDropTB.modifiers|=MenuItem.Disabled;
-		} else {
-			mnuDeleteTB.modifiers|=MenuItem.Disabled;
-			mnuGetMission.modifiers|=MenuItem.Disabled;
-			mnuOpenOnline.modifiers|=MenuItem.Disabled;
+				return 0;
 		}
-		// If more than one row is selected, show the limited pop-up menu
-		if (sel.height&gt;1)
-			setMenu(mnuDeleteMenu);
-		else
-			setMenu(mnuFullMenu);
-	    if (ev instanceof PenEvent) modTbJourneyList.penEventModifiers=((PenEvent)ev).modifiers;
-		super.onEvent(ev);
-	}
 
-	public void penRightReleased(Point p){
-		menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
-	}
+		public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
+			ta = super.getCellAttributes(row, col, isSelected, ta);
+			ta.alignment = CellConstants.LEFT;
+			ta.anchor = CellConstants.LEFT;
+			// Color the elements red, if we have not yet logged
+			if (row &gt;= 0)
+				switch (columnMap[col]) {
+				case 6: // fromDate
+					if (!tblMyTravelbugJourneys.getTBJourney(row).getFromLogged())
+						ta.foreground = RED;
+					break;
+				case 10: // toDate
+					if (!tblMyTravelbugJourneys.getTBJourney(row).getToLogged())
+						ta.foreground = RED;
+					break;
+				}
+			return ta;
+		}
 
-	public void penHeld(Point p){
-		menuState.doShowMenu(p,true,null); 
-	}
+		private void showFields(TravelbugJourney tbj) {
+			inpName.setText(tbj.getTb().getName());
+			inpTrackingNo.setText(tbj.getTb().getTrackingNo());
+			lblId.setText(tbj.getTb().getGuid());
+			inpFromProfile.setText(tbj.getFromProfile());
+			inpFromWaypoint.setText(tbj.getFromWaypoint());
+			inpFromDate.setText(tbj.getFromDate());
+			chkFromLogged.setState(tbj.getFromLogged());
+			inpToProfile.setText(tbj.getToProfile());
+			inpToWaypoint.setText(tbj.getToWaypoint());
+			inpToDate.setText(tbj.getToDate());
+			chkToLogged.setState(tbj.getToLogged());
+			txtMission.setHtml(tbj.getTb().getMission());
+		}
 
-	public void popupMenuEvent(Object selectedItem){
-		if (selectedItem==mnuPickupTB) {
-			Travelbug tb=TravelbugPickup.pickupTravelbug(tblSrcCache);	
-			if (tb!=null) {
-				chDmodified=true;
-				tblMyTravelbugJourneys.addTbPickup(tb,Global.getProfile().name,waypoint);
-				modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+		private boolean sortAsc = false;
+		private int sortedBy = -1;
+		private int lastRow = -1;
+		public int penEventModifiers;
+
+		public boolean penPressed(Point onTable, Point cell) {
+			boolean retval = false;
+			if (cell != null &amp;&amp; cell.y == -1) { // Hit a header =&gt; sort the table accordingly
+				Vm.showWait(true);
+				if (cell.x == sortedBy)
+					sortAsc = !sortAsc;
+				else
+					sortAsc = false;
+				sortedBy = cell.x;
+				// Check whether the list only shows non-logged journeys. If so, a subset
+				// of the table must be sorted
+				if ((tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+					tblMyTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc, modTbJourneyList.numRows);
+				} else { // Showing all journeys - sort the full table
+					tblMyTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+				}
 				tcTbJourneyList.repaint();
+				Vm.showWait(false);
+				retval = true;
+			} else if (cell != null &amp;&amp; cell.y &gt;= 0 &amp;&amp; (penEventModifiers &amp; IKeys.SHIFT) &gt; 0) {
+				// A range of rows can be marked by shift-click on the first and last row
+				if (lastRow != -1) { // Second row being marked with shift key pressed
+					if (lastRow &lt; cell.y)
+						toggleSelect(lastRow, cell.y);
+					else
+						toggleSelect(cell.y, lastRow);
+					lastRow = -1;
+					retval = true;
+				} else { // Remember this row as start of range, but don't toggle yet
+					lastRow = cell.y;
+				}
+			} else { // Single row marked
+				lastRow = -1;
 			}
+			return retval;
 		}
-		if (selectedItem==mnuDropTB) {
-			if (selectedRow&gt;=0 &amp;&amp; selectedRow&lt;modTbJourneyList.numRows) {
-				Travelbug tb=tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
-				chD.Travelbugs.add(tb);
-				tblMyTravelbugJourneys.addTbDrop(tb,Global.getProfile().name,waypoint);
-				chDmodified=true;
-				ch.setHas_bugs(true);
+
+		/** Select a range of rows */
+		private void toggleSelect(int fromRow, int toRow) {
+			tcTbJourneyList.clearSelection(null);
+			tcTbJourneyList.addToSelection(new Rect(0, fromRow, numCols, toRow - fromRow + 1), false, true);
+		}
+
+		/**
+		 * Return the column widths as a comma delimited string for storing in the preferences
+		 * 
+		 * @return
+		 */
+		private String getColWidths() {
+			// Update the list with the current widths
+			for (int col = 0; col &lt; numCols; col++) {
+				colWidth[columnMap[col]] = getColWidth(col);
 			}
-			repaint();
+			// Convert to string
+			StringBuffer sb = new StringBuffer(40);
+			for (int i = 0; i &lt; colWidth.length; i++) {
+				if (sb.length() != 0)
+					sb.append(',');
+				sb.append(colWidth[i]);
+			}
+			return sb.toString();
 		}
-		if (selectedItem==mnuNewTB) {
-			TravelbugJourney tbj=new TravelbugJourney(&quot;New&quot;);
-			tbj.setFromProfile(Global.getProfile().name);
-			tbj.setFromWaypoint(waypoint);
-			tblMyTravelbugJourneys.add(tbj);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			cursorTo(tblMyTravelbugJourneys.size()-1,1,true);
-			tcTbJourneyList.repaint();
+	}
+
+	// ==============================================================
+	// tbListControl
+	// ==============================================================
+	class tbListControl extends TableControl {
+		private MenuItem mnuNewTB, mnuDeleteTB, mnuGetMission, mnuOpenOnline, mnuDropTB, mnuPickupTB, mnuDeleteTBs;
+		public MenuItem mnuToggleList;
+		private Menu mnuFullMenu, mnuDeleteMenu;
+
+		tbListControl() {
+			MenuItem[] TBMenuItems = new MenuItem[10];
+			TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, &quot;Pick up TB from current cache&quot;));
+			TBMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6041, &quot;Drop TB in cache&quot;));
+			TBMenuItems[2] = new MenuItem(&quot;-&quot;);
+			TBMenuItems[3] = mnuNewTB = new MenuItem(MyLocale.getMsg(6042, &quot;New Travelbug&quot;));
+			TBMenuItems[4] = mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043, &quot;Delete Travelbug&quot;));
+			TBMenuItems[5] = new MenuItem(&quot;-&quot;);
+			TBMenuItems[6] = mnuGetMission = new MenuItem(MyLocale.getMsg(6044, &quot;Get Mission&quot;));
+			TBMenuItems[7] = mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045, &quot;Open on-line&quot;));
+			TBMenuItems[8] = new MenuItem(&quot;-&quot;);
+			TBMenuItems[9] = mnuToggleList = new MenuItem(MyLocale.getMsg(6046, &quot;Show only not logged&quot;));
+			mnuFullMenu = new Menu(TBMenuItems, &quot;&quot;);
+			// A second pop-up menu with only one entry, if a range of rows is selected
+			MenuItem[] TBMenuItemsDel = new MenuItem[1];
+			TBMenuItemsDel[0] = mnuDeleteTBs = new MenuItem(MyLocale.getMsg(6047, &quot;Delete selected Travelbugs&quot;));
+			mnuDeleteMenu = new Menu(TBMenuItemsDel, &quot;&quot;);
+			mnuDropTB.modifiers |= MenuItem.Disabled;
+			mnuDeleteTB.modifiers |= MenuItem.Disabled;
+			mnuGetMission.modifiers |= MenuItem.Disabled;
+			mnuOpenOnline.modifiers |= MenuItem.Disabled;
 		}
-		if (selectedItem==mnuDeleteTB &amp;&amp; selectedRow&gt;=0) {
-			tblMyTravelbugJourneys.remove(selectedRow);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			if (selectedRow&gt;0) 
-				cursorTo(selectedRow-1,0,true);
+
+		public void onEvent(Event ev) {
+			Rect sel = getSelection(null);
+			if (sel.y &lt; tblMyTravelbugJourneys.size()) {
+				mnuDeleteTB.modifiers &amp;= ~MenuItem.Disabled;
+				mnuGetMission.modifiers &amp;= ~MenuItem.Disabled;
+				mnuOpenOnline.modifiers &amp;= ~MenuItem.Disabled;
+				if (tblMyTravelbugJourneys.getTBJourney(sel.y).inMyPosession())
+					mnuDropTB.modifiers &amp;= ~MenuItem.Disabled;
+				else
+					mnuDropTB.modifiers |= MenuItem.Disabled;
+			} else {
+				mnuDeleteTB.modifiers |= MenuItem.Disabled;
+				mnuGetMission.modifiers |= MenuItem.Disabled;
+				mnuOpenOnline.modifiers |= MenuItem.Disabled;
+			}
+			// If more than one row is selected, show the limited pop-up menu
+			if (sel.height &gt; 1)
+				setMenu(mnuDeleteMenu);
 			else
-				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
-			tcTbJourneyList.repaint();
+				setMenu(mnuFullMenu);
+			if (ev instanceof PenEvent)
+				modTbJourneyList.penEventModifiers = ((PenEvent) ev).modifiers;
+			super.onEvent(ev);
 		}
-		/* Delete a group of travelbugs which have been marked with Shift-Click */
-		if (selectedItem==mnuDeleteTBs) {  
-			Rect sel=getSelection(null);
-			for (int i=0; i&lt;sel.height; i++)
-				tblMyTravelbugJourneys.remove(sel.y);
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
-			if (sel.y&lt;modTbJourneyList.numRows) 
-				cursorTo(sel.y,0,true);
-			else
-				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
-			tcTbJourneyList.repaint();
+
+		public void penRightReleased(Point p) {
+			menuState.doShowMenu(p, true, null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 		}
-		if (selectedItem==mnuGetMission &amp;&amp; selectedRow&gt;-1) {
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
-			Vm.showWait(true);
-			
-			//if we have an ID, get mission by ID
-			if (tbj.getTb().getGuid().length()!=0) {
-				tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
-			} else {
-				//try to get mission and name by tracking number
-				boolean suceeded = false;
-				if (tbj.getTb().getTrackingNo().length() != 0) {
-					suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+
+		public void penHeld(Point p) {
+			menuState.doShowMenu(p, true, null);
+		}
+
+		public void popupMenuEvent(Object selectedItem) {
+			if (selectedItem == mnuPickupTB) {
+				Travelbug tb = TravelbugPickup.pickupTravelbug(tblSrcCache);
+				if (tb != null) {
+					chDmodified = true;
+					tblMyTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, waypoint);
+					modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+					tcTbJourneyList.repaint();
 				}
-				//if this has't worked, try to get ID by name
-				if (!suceeded) {
-					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
-					//if we have an ID now, get mission by ID
-					if (tbj.getTb().getGuid().length()!=0) {
-						tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+			}
+			if (selectedItem == mnuDropTB) {
+				if (selectedRow &gt;= 0 &amp;&amp; selectedRow &lt; modTbJourneyList.numRows) {
+					Travelbug tb = tblMyTravelbugJourneys.getTBJourney(selectedRow).getTb();
+					chD.Travelbugs.add(tb);
+					tblMyTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, waypoint);
+					chDmodified = true;
+					ch.setHas_bugs(true);
+				}
+				repaint();
+			}
+			if (selectedItem == mnuNewTB) {
+				TravelbugJourney tbj = new TravelbugJourney(&quot;New&quot;);
+				tbj.setFromProfile(Global.getProfile().name);
+				tbj.setFromWaypoint(waypoint);
+				tblMyTravelbugJourneys.add(tbj);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				cursorTo(tblMyTravelbugJourneys.size() - 1, 1, true);
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuDeleteTB &amp;&amp; selectedRow &gt;= 0) {
+				tblMyTravelbugJourneys.remove(selectedRow);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				if (selectedRow &gt; 0)
+					cursorTo(selectedRow - 1, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+				tcTbJourneyList.repaint();
+			}
+			/* Delete a group of travelbugs which have been marked with Shift-Click */
+			if (selectedItem == mnuDeleteTBs) {
+				Rect sel = getSelection(null);
+				for (int i = 0; i &lt; sel.height; i++)
+					tblMyTravelbugJourneys.remove(sel.y);
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+				if (sel.y &lt; modTbJourneyList.numRows)
+					cursorTo(sel.y, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuGetMission &amp;&amp; selectedRow &gt; -1) {
+				TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+
+				// if we have an ID, get mission by ID
+				if (tbj.getTb().getGuid().length() != 0) {
+					tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+				} else {
+					// try to get mission and name by tracking number
+					boolean suceeded = false;
+					if (tbj.getTb().getTrackingNo().length() != 0) {
+						suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
 					}
+					// if this has't worked, try to get ID by name
+					if (!suceeded) {
+						tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+						// if we have an ID now, get mission by ID
+						if (tbj.getTb().getGuid().length() != 0) {
+							tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+						}
+					}
 				}
+
+				Vm.showWait(false);
+				tcTbJourneyList.repaint();
+				txtMission.setHtml(tbj.getTb().getMission());
+				inpName.setText(tbj.getTb().getName());
+				lblId.setText(tbj.getTb().getGuid());
+				lowerpane.repaint();
+				Global.getPref().setOldGCLanguage();
 			}
-			
-			Vm.showWait(false);
-			tcTbJourneyList.repaint();
-			txtMission.setHtml(tbj.getTb().getMission());
-			inpName.setText(tbj.getTb().getName());
-			lblId.setText(tbj.getTb().getGuid());
-			lowerpane.repaint();
-		}
-		if (selectedItem==mnuOpenOnline &amp;&amp; selectedRow&gt;=0) {
-			TravelbugJourney tbj=tblMyTravelbugJourneys.getTBJourney(selectedRow);
-			SpiderGC spider=new SpiderGC(Global.getPref(),Global.getProfile(),false);
-			Vm.showWait(true);
-			// First check whether ID is set, if not get it
-			if (tbj.getTb().getGuid().length()==0) tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
-			if (tbj.getTb().getGuid().length()!=0) {
-				Vm.showWait(false);
-				try {
-					String s;
-					if (tbj.getTb().getGuid().length()&gt;10)
-						s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot;+tbj.getTb().getGuid();
-					else
-						s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot;+tbj.getTb().getGuid();
+			if (selectedItem == mnuOpenOnline &amp;&amp; selectedRow &gt;= 0) {
+				TravelbugJourney tbj = tblMyTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+				// First check whether ID is set, if not get it
+				if (tbj.getTb().getGuid().length() == 0)
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+				if (tbj.getTb().getGuid().length() != 0) {
+					Vm.showWait(false);
+					try {
+						String s;
+						if (tbj.getTb().getGuid().length() &gt; 10)
+							s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot; + tbj.getTb().getGuid();
+						else
+							s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot; + tbj.getTb().getGuid();
 
-					CWWrapper.exec(Global.getPref().browser, s);
-					Global.getPref().log(&quot;Executed: \&quot;&quot;+Global.getPref().browser+&quot;\&quot; \&quot;&quot;+s+&quot;\&quot;&quot;);
-				} catch (Exception ioex) {
-					// Global.getPref().log(&quot;Ignored Exception&quot;, ioex, true);
+						CWWrapper.exec(Global.getPref().browser, s);
+						Global.getPref().log(&quot;Executed: \&quot;&quot; + Global.getPref().browser + &quot;\&quot; \&quot;&quot; + s + &quot;\&quot;&quot;);
+					} catch (Exception ioex) {
+						// Global.getPref().log(&quot;Ignored Exception&quot;, ioex, true);
+					}
 				}
+				Global.getPref().setOldGCLanguage();
 			}
+			if (selectedItem == mnuToggleList) {
+				toggleNonLogged();
+			}
+			updateNumBugs();
 		}
-		if (selectedItem==mnuToggleList) {
-			toggleNonLogged();
+
+		/** Toggle between displaying all journeys or just those which still need to be logged */
+		public void toggleNonLogged() {
+			mnuToggleList.modifiers ^= MenuItem.Checked;
+			if ((mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+				// First sort the non-logged items to the top
+				tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
+				// modListTable.numRows=tblMyTravelbugJourneys.size();
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.countNonLogged();
+			} else {
+				modTbJourneyList.numRows = tblMyTravelbugJourneys.size();
+			}
+			tcTbJourneyList.repaint();
 		}
-		updateNumBugs();
-	}
-	
-	/** Toggle between displaying all journeys or just those which still need to be logged */
-	public void toggleNonLogged() {
-		mnuToggleList.modifiers^=MenuItem.Checked;
-		if ((mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
-			// First sort the non-logged items to the top
-			tblMyTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
-			// 		modListTable.numRows=tblMyTravelbugJourneys.size();
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.countNonLogged();
-		} else {
-			modTbJourneyList.numRows=tblMyTravelbugJourneys.size();
+
+		public void cursorTo(int row, int col, boolean selectNew) {
+			super.cursorTo(row, col, selectNew);
+			selectedRow = row;
+			if (row &gt;= 0) {
+				modTbJourneyList.showFields(tblMyTravelbugJourneys.getTBJourney(row));
+			} else {
+				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+			}
 		}
-		tcTbJourneyList.repaint();
 	}
-	
-	
-	public void cursorTo(int row,int col,boolean selectNew) {
-		super.cursorTo(row,col,selectNew);
-		selectedRow=row;
-		if (row&gt;=0) { 
-			modTbJourneyList.showFields(tblMyTravelbugJourneys.getTBJourney(row));
-		} else {
-			modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
-		}
-	}
-}
 
 }

Modified: branches/r1.2/src/CacheWolf/TravelbugPickup.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugPickup.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugPickup.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,59 +1,66 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import CacheWolf.view.ITravelbugScreen;
+import CacheWolf.view.TravelBugScreenFactory;
 import ewe.ui.InputBox;
 
 public class TravelbugPickup {
 
 	/**
-	 * Choose a travelbug from those listed in the travelbug list and delete it, if
-	 * the operation was not cancelled.
-	 * @param tbl List of travelbugs from where a bug is picked up
+	 * Choose a travelbug from those listed in the travelbug list and delete it,
+	 * if the operation was not cancelled.
+	 * 
+	 * @param tbl
+	 *            List of travelbugs from where a bug is picked up
 	 */
 	public static Travelbug pickupTravelbug(TravelbugList tbl) {
-		Travelbug tb=null;
-		TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,&quot;Pick up travelbug&quot;),true);
+		Travelbug tb = null;
+		// TravelbugScreen tbs=new TravelbugScreen(tbl,MyLocale.getMsg(6016,&quot;Pick up travelbug&quot;),true);
+		ITravelbugScreen tbs = TravelBugScreenFactory.createTravelbugScreen(tbl, MyLocale.getMsg(6016, &quot;Pick up travelbug&quot;), new Boolean(true));
 		tbs.execute(); // Select TB to pick up
-		if (tbs.selectedItem&gt;=0) { // Was a TB selected ?
+		if (tbs.getSelectedItem() &gt;= 0) { // Was a TB selected ?
 			// If the returned item is bigger than number of bugs in cache
-			// we have found a new unlisted bug. 
-			if (tbs.selectedItem==tbl.size()) {
-				InputBox ibox=new InputBox(MyLocale.getMsg(6018,&quot;Travelbug name&quot;));
-				String name=ibox.input(&quot;&quot;,240);
-				if (name==null) return null; // No name given
-				tb=new Travelbug(name);
+			// we have found a new unlisted bug.
+			if (tbs.getSelectedItem() == tbl.size()) {
+				InputBox ibox = new InputBox(MyLocale.getMsg(6018, &quot;Travelbug name&quot;));
+				String name = ibox.input(&quot;&quot;, 240);
+				if (name == null)
+					return null; // No name given
+				tb = new Travelbug(name);
 			} else { // A bug in the list was chosen
-				tb=tbl.getTB(tbs.selectedItem);
+				tb = tbl.getTB(tbs.getSelectedItem());
 				// Remove the tb from the list
-				tbl.remove(tbs.selectedItem);
+				tbl.remove(tbs.getSelectedItem());
 			}
-			InputBox ibox=new InputBox(MyLocale.getMsg(6019,&quot;Tracking number&quot;));
-			String trackingNo=ibox.input(&quot;&quot;,240);
-			if (trackingNo==null) trackingNo=&quot;&quot;;
+			InputBox ibox = new InputBox(MyLocale.getMsg(6019, &quot;Tracking number&quot;));
+			String trackingNo = ibox.input(&quot;&quot;, 240);
+			if (trackingNo == null)
+				trackingNo = &quot;&quot;;
 			tb.setTrackingNo(trackingNo);
 		}
 		return tb;

Modified: branches/r1.2/src/CacheWolf/TravelbugScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/TravelbugScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/TravelbugScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -25,6 +25,7 @@
     */
 package CacheWolf;
 
+import CacheWolf.view.ITravelbugScreen;
 import ewe.ui.CellConstants;
 import ewe.ui.ControlEvent;
 import ewe.ui.Event;
@@ -40,19 +41,23 @@
  * Choose a travelbug to pick up or drop
  * @author salzkammergut
  */ 
-public class TravelbugScreen extends Form {
+public class TravelbugScreen extends Form implements ITravelbugScreen {
 	private myList disp;
 	private mButton btCancel,btAccept;
 	/** The index into the list of travelbugs indicating the selected bug */
 	public int selectedItem=-1;
 	
+	public int getSelectedItem() {
+		return selectedItem;
+	}
+
 	/**
 	 * A screen to choose a travelbug from a list of bugs
 	 * @param tbl The list of travelbugs from which to choose
 	 * @param title The title of the screen
 	 * @param allowNew True if a travelbug not on the list can be selected
 	 */
-	TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
+	public TravelbugScreen(TravelbugList tbl, String title,boolean allowNew) {
 		this.setTitle(title);
 		this.setPreferredSize(240, -1);
 		disp=new myList(tbl,allowNew);
@@ -104,7 +109,4 @@
 				return SafeXML.cleanback(tbl.getTB(idx).getName());
 		}
 	}
-
-
-
 }

Modified: branches/r1.2/src/CacheWolf/UrlFetcher.java
===================================================================
--- branches/r1.2/src/CacheWolf/UrlFetcher.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/UrlFetcher.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,143 +1,232 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import ewe.data.PropertyList;
 import ewe.io.AsciiCodec;
-import ewe.io.ByteArrayInputStream;
+import ewe.io.File;
+import ewe.io.FileBase;
+import ewe.io.FileOutputStream;
 import ewe.io.IOException;
 import ewe.io.JavaUtf8Codec;
-import ewe.net.Socket;
-import ewe.net.URL;
-import ewe.sys.Handle;
-import ewe.sys.HandleStoppedException;
 import ewe.util.ByteArray;
 import ewe.util.CharArray;
-import ewe.util.Properties;
 
 public class UrlFetcher {
-	public static String fetchString(String address) throws IOException
-	{
-		ByteArray daten = fetchByteArray(address, null);
+	static HttpConnection conn;
+	static int maxRedirections = 5;
+	static PropertyList requestorProperties = null;
+	static PropertyList permanentRequestorProperties = null;
+	static String postData = null;
+	static String urltmp = null;
+	static String realUrl = null;
+	static boolean forceRedirect = false;
+
+	public static PropertyList getDocumentProperties() {
+		if (conn != null)
+			return conn.documentProperties;
+		else
+			return null;
+	}
+
+	public static String getRealUrl() {
+		return realUrl;
+	};
+
+	public static void setMaxRedirections(int value) {
+		maxRedirections = value;
+	};
+
+	public static void setForceRedirect() {
+		forceRedirect = true;
+	};
+
+	public static void setRequestorProperties(PropertyList value) {
+		requestorProperties = value;
+	};
+
+	public static void setRequestorProperty(String name, String property) {
+		if (requestorProperties == null)
+			requestorProperties = new PropertyList();
+		requestorProperties.set(name, property);
+	}
+
+	private static void initPermanentRequestorProperty() {
+		permanentRequestorProperties = new PropertyList();
+		permanentRequestorProperties.add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
+		// permanentRequestorProperties.add(&quot;Connection&quot;, &quot;close&quot;);
+		permanentRequestorProperties.add(&quot;Connection&quot;, &quot;keep-alive&quot;);
+	}
+
+	public static void setPermanentRequestorProperty(String name, String property) {
+		if (permanentRequestorProperties == null)
+			initPermanentRequestorProperty();
+		if (property != null)
+			permanentRequestorProperties.set(name, property);
+		else {
+			int index = permanentRequestorProperties.find(name);
+			if (index &gt;= 0)
+				permanentRequestorProperties.del(index);
+		}
+	}
+
+	public static void setpostData(String value) {
+		postData = value;
+	};
+
+	public static String fetch(String address) throws IOException {
+		ByteArray daten = fetchByteArray(address);
 		JavaUtf8Codec codec = new JavaUtf8Codec();
 		CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
 		return c_data.toString();
 	}
 
-	public static Properties fetchPropertyList(String url) throws IOException {
-		CharArray t = new CharArray();
-		ByteArray doc = fetchByteArray(url, t);
-		Properties props = new Properties();
-		props.load(new ByteArrayInputStream(doc));
-		return props; 
+	public static ByteArray fetchData(String address) throws IOException {
+		return fetchByteArray(address);
 	}
 
-	public static ByteArray fetchByteArray(String url, CharArray realurl) throws IOException {
-		Handle[] hndl = new Handle[1];
-		try {
-		return fetchByteArray(url, realurl, hndl);
-		} catch ( InterruptedException e) {
-			throw new IOException(&quot;Error reading data. i :&quot;+url);
-		} catch ( HandleStoppedException e) {
-			throw new IOException(&quot;Error reading data. s :&quot;+url);
-		}
+	public static void fetchDataFile(String address, String target) throws IOException {
+		FileOutputStream outp = new FileOutputStream(new File(target));
+		outp.write(fetchByteArray(address).toBytes());
+		outp.close();
 	}
 
 	/**
-	 * @param url - if url-not-allowed chars are contained, they will be automatically encoded
-	 * @param if non null, realurl will be filled with the real url, which can differ from the given url, in case url returns a http-redirect
-	 * @return
+	 * @param url
+	 * @return ByteArray
 	 * @throws IOException
-	 * @throws InterruptedException 
-	 * @throws HandleStoppedException 
 	 */
-	public static ByteArray fetchByteArray(String url, CharArray realurl, Handle[] hndl) 
-	throws IOException, HandleStoppedException, InterruptedException {	
-		final int maxRedirections = 5;
-		HttpConnection conn = null;
-		Socket sock = null;
-		int i=0;
-		String urltmp = new String(url);
-		do  { // allow max 5 redirections (http 302 location)
-			if (realurl != null) realurl.copyFrom(new String(urltmp));
+	public static ByteArray fetchByteArray(String url) throws IOException {
+		int i = 0;
+		conn = new HttpConnection(url); // todo reuse: don#t reuse, some params are not correctly reset with SetUrl
+		urltmp = url;
+		do { // allow max 5 redirections (http 302 location)
 			i++;
-			conn = new HttpConnection(urltmp);
-			conn.setRequestorProperty(&quot;USER_AGENT&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
+			if (urltmp == null) {
+				// hack for expedia, doing the original url again.
+				// expedia always must redirect &gt;=1 time, but sometimes that is missed
+				// see also: <A HREF="http://www.geoclub.de/viewtopic.php?p=305071#305071">http://www.geoclub.de/viewtopic.php?p=305071#305071</A>
+				urltmp = url;
+				i = i - 1;
+			}
+			realUrl = urltmp;
+			if (!urltmp.startsWith(&quot;http&quot;)) {
+				url = FileBase.fixupPath(url);
+				String uu = url.toLowerCase();
+				String host;
+				uu = url.replace('\\', '/');
+				host = uu.substring(7);
+				int first = host.indexOf('/');
+				if (first != -1) {
+					host = host.substring(0, first);
+				}
+				if (!urltmp.startsWith(&quot;/&quot;))
+					host = host + &quot;/&quot;;
+				urltmp = &quot;<A HREF="http://">http://</A>&quot; + host + urltmp;
+			}
+			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
-			hndl[0] = conn.connectAsync();
-			hndl[0].waitOn(Handle.Success);
-			sock = (Socket)hndl[0].returnValue; //&quot;Could not connect.&quot;);
-			if (conn.responseCode &gt;= 400) throw new IOException(&quot;URL: &quot;+ urltmp + &quot;\nhttp response code: &quot; + conn.responseCode);
+			if (permanentRequestorProperties == null)
+				initPermanentRequestorProperty();
+			if (postData != null) {
+				conn.setPostData(postData);
+				conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
+			}
+			conn.setRequestorProperty(permanentRequestorProperties);
+			if (requestorProperties != null)
+				conn.setRequestorProperty(requestorProperties);
+			conn.connect();
+			if (conn.responseCode &gt;= 400) {
+				maxRedirections = 5;
+				requestorProperties = null;
+				postData = null;
+				forceRedirect = false;
+				throw new IOException(&quot;URL: &quot; + urltmp + &quot;\nhttp response code: &quot; + conn.responseCode);
+			}
 			urltmp = conn.getRedirectTo();
-			if(urltmp!=null){
-				URL eweUrl = new URL(url);
-				if(urltmp.indexOf(eweUrl.getHost())&lt;0){
-					urltmp = new URL(eweUrl.getProtocol(), eweUrl.getHost(),eweUrl.getPort(), urltmp).url;
+			if (urltmp != null) {
+				conn.disconnect();
+				// mainly implemented for opencaching.de ... login
+				final PropertyList pl = UrlFetcher.getDocumentProperties();
+				if (pl != null) {
+					String cookie = (String) pl.getValue(&quot;Set-Cookie&quot;, &quot;&quot;);
+					if (cookie.length() &gt; 0) {
+						if (postData == null)
+							// do not overwrite existing cookie (mostly for geocaching.com)
+							// normally a cookie exists for a website
+							// we do not handle that correct
+							setRequestorProperty(&quot;Cookie&quot;, cookie);
+						else
+							// needed for opencaching.de ... login
+							setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
+					}
 				}
-				urltmp = STRreplace.replace(urltmp, eweUrl.getHost() + &quot;/\\.\\./&quot;, eweUrl.getHost() + &quot;/&quot;);
+				conn = conn.getRedirectedConnection(urltmp);
+				forceRedirect = false; // one time or more redirected
 			}
-		} while (urltmp != null &amp;&amp; i &lt;= maxRedirections ); 
-		if (i &gt; maxRedirections) throw new IOException(&quot;too many http redirections while trying to fetch: &quot;+url + &quot; only &quot;+maxRedirections+&quot; are allowed&quot;);
-		hndl[0] = conn.readInData();
+		} while (((urltmp != null) || (urltmp == null) &amp;&amp; forceRedirect) &amp;&amp; i &lt;= maxRedirections);
+		if (i &gt; maxRedirections)
+			throw new IOException(&quot;too many http redirections while trying to fetch: &quot; + url + &quot; only &quot; + maxRedirections + &quot; are allowed&quot;);
 		ByteArray daten;
-		try{
-			hndl[0].waitOn(Handle.Success);
-		}finally {
-			sock.close();
-		}
-		daten = (ByteArray)hndl[0].returnValue;
-		// ByteArray daten = conn.readData(sock);
+		if (conn.isOpen()) {
+			daten = conn.readData();
+			conn.disconnect();
+		} else
+			daten = null;
+		maxRedirections = 5;
+		requestorProperties = null;
+		postData = null;
+		forceRedirect = false;
 		return daten;
 	}
 
 	/**
 	 * @param url
-	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false otherwise
+	 * @return true, if the string seems to be already URL encoded (that is, it contains only url-allowd chars), false
+	 *         otherwise
 	 */
-	public static boolean isUrlEncoded(String url) {
-		final String allowed = new String (&quot;-_.~!*'();:@&amp;=+$,/?%#[]&quot;);
-		char [] src = ewe.sys.Vm.getStringChars(url);
+	private static boolean isUrlEncoded(String url) {
+		final String allowed = new String(&quot;-_.~!*'();:@&amp;=+$,/?%#[]&quot;);
+		char[] src = ewe.sys.Vm.getStringChars(url);
 		char c;
-		for (int i = 0; i&lt;src.length; i++){
+		for (int i = 0; i &lt; src.length; i++) {
 			c = src[i];
-			if (       (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') 
-					|| (c &gt;= 'a' &amp;&amp; c &lt;= 'z') 
-					|| (c &gt;= '0' &amp;&amp; c &lt;= '9')
-					|| (allowed.indexOf(c) &gt;= 0)
-			) continue;
-			else return false;
+			if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || (allowed.indexOf(c) &gt;= 0))
+				continue;
+			else
+				return false;
 		}
 		return true;
 	}
+
 	/**
-	 * This method encodes an URL containing special characters
-	 * using the UTF-8 codec in %nn%nn notation&lt;br&gt;
-	 * Note that the encoding for URLs is not generally defined. Usually
-	 * cp1252 or UTF-8 is used. It depends on what the server expects,
-	 * what encoding you must use.
+	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation&lt;br&gt;
+	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the
+	 * server expects, what encoding you must use.
+	 * 
 	 * @param cc
 	 * @return
 	 * @throws IOException
@@ -149,36 +238,40 @@
 		AsciiCodec asciicod = new AsciiCodec();
 		CharArray utf8bytes = new CharArray();
 		asciicod.decodeText(utf8.data, 0, utf8.length, true, utf8bytes);
-		return encodeURL(utf8bytes.toString(), false);
+		return encodeURL(utf8bytes.toString(), true);
 	}
-	
+
 	final static String hex = ewe.util.TextEncoder.hex;
+
 	/**
-	 * Encode the URL using %## notation.
-	 * Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine
-	 * assumes all chars to be &lt; 127.
-	 * This method is mainly copied from there
-	 * @param url The unencoded URL.
-	 * @param spaceToPlus true if you wish a space to be encoded as a '+', false to encode it as %20
+	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all
+	 * chars to be &lt; 127. This method is mainly copied from there
+	 * 
+	 * @param url
+	 *            The unencoded URL.
+	 * @param spaceToPlus
+	 *            true if you wish a space to be encoded as a '+', false to encode it as %20
 	 * @return The encoded URL.
 	 */
-	//===================================================================
+	// ===================================================================
 	public static String encodeURL(String url, boolean spaceToPlus)
-	//===================================================================
+	// ===================================================================
 	{
-		char [] what = ewe.sys.Vm.getStringChars(url);
+		char[] what = ewe.sys.Vm.getStringChars(url);
 		int max = what.length;
-		char [] dest = new char[max+max/2];
+		char[] dest = new char[max + max / 2];
 		char d = 0;
-		for (int i = 0; i&lt;max; i++){
-			if (d &gt;= dest.length-2) {
-				char [] n = new char[dest.length+dest.length/2+3];
-				ewe.sys.Vm.copyArray(dest,0,n,0,d);
+		for (int i = 0; i &lt; max; i++) {
+			if (d &gt;= dest.length - 2) {
+				char[] n = new char[dest.length + dest.length / 2 + 3];
+				ewe.sys.Vm.copyArray(dest, 0, n, 0, d);
 				dest = n;
 			}
 			char c = what[i];
-			if (spaceToPlus &amp;&amp; c == ' ') c = '+';
-			else if (c &lt;= ' ' || c &gt;= 127 || c == '+' || c == '&amp;' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}'){
+			// added || c == '$' || c == '/' || c == ','
+			if (spaceToPlus &amp;&amp; c == ' ')
+				c = '+';
+			else if (c &lt;= ' ' || c &gt;= 127 || c == '+' || c == '&amp;' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c == '$' || c == '/' || c == ',') {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
 				dest[d++] = hex.charAt(c &amp; 0xf);
@@ -186,7 +279,7 @@
 			}
 			dest[d++] = c;
 		}
-		return new String(dest,0,d);
+		return new String(dest, 0, d);
 	}
 
 }
\ No newline at end of file

Modified: branches/r1.2/src/CacheWolf/exp/DistanceComparer.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/DistanceComparer.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/DistanceComparer.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -30,21 +30,21 @@
 import ewe.util.Comparer;
 
 public class DistanceComparer implements Comparer {
-	
+
 	CWPoint centre;
-	
+
 	public DistanceComparer(CWPoint centre) {
 		this.centre = centre;
 	}
 
 	public int compare(Object one, Object two) {
-		if ((! (one instanceof CacheHolder)) &amp;&amp; (!(two instanceof CacheHolder))) {
+		if ((!(one instanceof CacheHolder)) &amp;&amp; (!(two instanceof CacheHolder))) {
 			return 0;
 		} else {
 			CacheHolder a = (CacheHolder) one;
 			CacheHolder b = (CacheHolder) two;
-			return (int) ((a.pos.getDistance(centre) - b.pos.getDistance(centre)) * 1000);
+			return (int) ((a.getPos().getDistance(centre) - b.getPos().getDistance(centre)) * 1000);
 		}
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/exp/ExploristExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/ExploristExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/ExploristExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -95,19 +95,19 @@
 	public void doIt() {
 		File configFile = new File(&quot;magellan.cfg&quot;);
 		if (configFile.exists()) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName+&quot;Dir&quot;));
+			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, pref.getExportPath(expName + &quot;Dir&quot;));
 			fc.setTitle(MyLocale.getMsg(2104, &quot;Choose directory for exporting .gs files&quot;));
 			String targetDir;
-			if(fc.execute() != FormBase.IDCANCEL){
+			if (fc.execute() != FormBase.IDCANCEL) {
 				targetDir = fc.getChosen() + &quot;/&quot;;
-				pref.setExportPath(expName+&quot;Dir&quot;, targetDir);
+				pref.setExportPath(expName + &quot;Dir&quot;, targetDir);
 
 				CWPoint centre = profile.centre;
 				try {
 					LineNumberReader reader = new LineNumberReader(new BufferedReader(new FileReader(configFile)));
 					String line, fileName, coordinate;
-					while ((line = reader.readLine()) != null)  {
-						StringTokenizer tokenizer = new StringTokenizer(line,&quot;=&quot;);
+					while ((line = reader.readLine()) != null) {
+						StringTokenizer tokenizer = new StringTokenizer(line, &quot;=&quot;);
 						fileName = targetDir + tokenizer.nextToken().trim() + &quot;.gs&quot;;
 						coordinate = tokenizer.nextToken().trim();
 						CWPoint point = new CWPoint(coordinate);
@@ -117,17 +117,16 @@
 					}
 					reader.close();
 				} catch (FileNotFoundException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;),MyLocale.getMsg(2101, &quot;Failure at loading magellan.cfg\n&quot; + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;), MyLocale.getMsg(2101, &quot;Failure at loading magellan.cfg\n&quot; + e.getMessage()));
 					info.show();
 				} catch (IOException e) {
-					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;),MyLocale.getMsg(2103, &quot;Failure at reading magellan.cfg\n&quot; + e.getMessage()));
+					InfoBox info = new InfoBox(MyLocale.getMsg(2100, &quot;Explorist Exporter&quot;), MyLocale.getMsg(2103, &quot;Failure at reading magellan.cfg\n&quot; + e.getMessage()));
 					info.show();
 				} finally {
-					cacheDB.sort(new DistanceComparer(centre),false);
+					cacheDB.sort(new DistanceComparer(centre), false);
 				}
 			}
-		}
-		else {
+		} else {
 			doIt(null);
 		}
 	}
@@ -164,18 +163,14 @@
 
 		try {
 			// Set initial value for outp to calm down compiler
-			PrintWriter outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + &quot;.gs&quot;))));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + &quot;.gs&quot;))));
 			for (int i = 0; i &lt; cacheDB.size(); i++) {
 				ch = cacheDB.get(i);
 				if (ch.isVisible()) {
 					// all 200 caches we need a new file
 					if (expCount % 200 == 0 &amp;&amp; expCount &gt; 0) {
 						outp.close();
-						outp = new PrintWriter(new BufferedWriter(
-								new FileWriter(new File(fileBaseName + expCount
-										/ 200 + &quot;.gs&quot;))));
+						outp = new PrintWriter(new BufferedWriter(new FileWriter(new File(fileBaseName + expCount / 200 + &quot;.gs&quot;))));
 					}
 
 					expCount++;
@@ -195,20 +190,19 @@
 			outp.close();
 			pbf.exit(0);
 		} catch (IOException ioE) {
-			pref.log(&quot;Error opening &quot; + outFile.getName(),ioE);
+			pref.log(&quot;Error opening &quot; + outFile.getName(), ioE);
 		}
 		// try
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
-	 *
+	 * 
 	 * @return
 	 */
 	public File getOutputFile() {
 		File file;
-		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref
-				.getExportPath(expName));
+		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle(MyLocale.getMsg(2102, &quot;Select target file:&quot;));
 		fc.addMask(mask);
 		if (fc.execute() != FormBase.IDCANCEL) {
@@ -222,7 +216,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @param ch
 	 *            cachedata
 	 * @return formated cache data
@@ -230,21 +224,21 @@
 	public String record(CacheHolder ch) {
 		CacheHolderDetail det = ch.getCacheDetails(true);
 		/*
-		static protected final int GC_AW_PARKING = 50;
-		static protected final int GC_AW_STAGE_OF_MULTI = 51;
-		static protected final int GC_AW_QUESTION = 52;
-		static protected final int GC_AW_FINAL = 53;
-		static protected final int GC_AW_TRAILHEAD = 54;
-		static protected final int GC_AW_REFERENCE = 55;
-		*/
+		 * static protected final int GC_AW_PARKING = 50;
+		 * static protected final int GC_AW_STAGE_OF_MULTI = 51;
+		 * static protected final int GC_AW_QUESTION = 52;
+		 * static protected final int GC_AW_FINAL = 53;
+		 * static protected final int GC_AW_TRAILHEAD = 54;
+		 * static protected final int GC_AW_REFERENCE = 55;
+		 */
 		StringBuffer sb = new StringBuffer();
 		sb.append(&quot;$PMGNGEO,&quot;);
-		sb.append(ch.pos.getLatDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLatMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLatDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLatMin(CWPoint.DMM));
 		sb.append(&quot;,&quot;);
 		sb.append(&quot;N,&quot;);
-		sb.append(ch.pos.getLonDeg(CWPoint.DMM));
-		sb.append(ch.pos.getLonMin(CWPoint.DMM));
+		sb.append(ch.getPos().getLonDeg(CWPoint.DMM));
+		sb.append(ch.getPos().getLonMin(CWPoint.DMM));
 		sb.append(&quot;,&quot;);
 		sb.append(&quot;E,&quot;);
 		sb.append(&quot;0000,&quot;); // Height
@@ -281,11 +275,11 @@
 			sb.append(CacheType.type2GSTypeTag(ch.getType()));
 		}
 		sb.append(&quot;,&quot;);
-		sb.append(toGsDateFormat(ch.getDateHidden()));  // created - DDMMYYY, YYY = year - 1900
+		sb.append(toGsDateFormat(ch.getDateHidden())); // created - DDMMYYY, YYY = year - 1900
 		sb.append(&quot;,&quot;);
 		String lastFound = &quot;0000&quot;;
 		for (int i = 0; i &lt; det.CacheLogs.size(); i++) {
-			if (det.CacheLogs.getLog(i).isFoundLog() &amp;&amp; det.CacheLogs.getLog(i).getDate().compareTo(lastFound) &gt; 0 ) {
+			if (det.CacheLogs.getLog(i).isFoundLog() &amp;&amp; det.CacheLogs.getLog(i).getDate().compareTo(lastFound) &gt; 0) {
 				lastFound = det.CacheLogs.getLog(i).getDate();
 			}
 		}
@@ -301,7 +295,7 @@
 
 	/**
 	 * this method can be overided by an exporter class
-	 *
+	 * 
 	 * @return formated trailer data
 	 */
 	public String trailer() {
@@ -310,6 +304,7 @@
 
 	/**
 	 * Changes &quot;,&quot; in &quot;.&quot; in the input String
+	 * 
 	 * @param input
 	 * @return changed String
 	 */
@@ -319,14 +314,15 @@
 
 	/**
 	 * change the Dateformat from &quot;yyyy-mm-dd&quot; to ddmmyyy, where yyy is years after 1900
-	 * @param input Date in yyyy-mm-dd
- 	 * @return Date in ddmmyyy
+	 * 
+	 * @param input
+	 *            Date in yyyy-mm-dd
+	 * @return Date in ddmmyyy
 	 */
 	private String toGsDateFormat(String input) {
 		if (input.length() &gt;= 10) {
 			return input.substring(8, 10) + input.substring(5, 7) + &quot;1&quot; + input.substring(2, 4);
-		}
-		else {
+		} else {
 			return &quot;&quot;;
 		}
 	}

Modified: branches/r1.2/src/CacheWolf/exp/Exporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/Exporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/Exporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -48,11 +48,11 @@
 
 /**
  * @author Kalle
- * Base class for exporter, handles basic things like selecting
- * outputfile, display a counter etc.
- * A new Exporter must only override the header(), record() and 
- * trailer() methods. The member howManyParams must be set to identify
- * which ethod should be called  
+ *         Base class for exporter, handles basic things like selecting
+ *         outputfile, display a counter etc.
+ *         A new Exporter must only override the header(), record() and
+ *         trailer() methods. The member howManyParams must be set to identify
+ *         which ethod should be called
  */
 
 public class Exporter {
@@ -60,12 +60,12 @@
 	final static int TMP_FILE = 0;
 	// brings up a screen to select a file
 	final static int ASK_FILE = 1;
-	
+
 	// selection, which method should be called
-	final static int NO_PARAMS 	= 0;
-	final static int LAT_LON 	= 1;
-	final static int COUNT 		= 2;
-	
+	final static int NO_PARAMS = 0;
+	final static int LAT_LON = 1;
+	final static int COUNT = 2;
+
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
@@ -74,97 +74,100 @@
 	// file name, if no file chooser is used
 	String tmpFileName;
 	// decimal separator for lat- and lon-String
-	char decimalSeparator='.';
-	// if  true, the complete cache details are read
-	// before a call to the record method is made 
+	char decimalSeparator = '.';
+	// if true, the complete cache details are read
+	// before a call to the record method is made
 	boolean needCacheDetails = false;
 	// selection, which method should be called
 	int howManyParams = 0;
-	
-	//name of exporter for saving pathname
+
+	// name of exporter for saving pathname
 	String expName;
-	
+
 	public Exporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 		howManyParams = LAT_LON;
-		expName = this.getClass().getName(); 
+		expName = this.getClass().getName();
 		// remove package
 		expName = expName.substring(expName.indexOf(&quot;.&quot;) + 1);
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		this.doIt(ASK_FILE);
 	}
 
 	/**
 	 * Does the most work for exporting data
-	 * @param variant 0, if no filechooser
-	 *                1, if filechooser
+	 * 
+	 * @param variant
+	 *            0, if no filechooser
+	 *            1, if filechooser
 	 */
-	public void doIt(int variant){
+	public void doIt(int variant) {
 		File outFile;
 		String str;
 		CacheHolder ch;
 		ProgressBarForm pbf = new ProgressBarForm();
 		Handle h = new Handle();
 
-
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
-			if (outFile == null) return;
+			if (outFile == null)
+				return;
 		} else {
 			outFile = new File(tmpFileName);
 		}
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.setTask(h, &quot;Exporting ...&quot;);
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			int incompleteWaypoints = 0;
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
 			str = this.header();
-			if (str != null) outp.print(str);
-			for(int i = 0; i&lt;cacheDB.size(); i++){
-				ch=cacheDB.get(i);
-				if(ch.isVisible()){
+			if (str != null)
+				outp.print(str);
+			for (int i = 0; i &lt; cacheDB.size(); i++) {
+				ch = cacheDB.get(i);
+				if (ch.isVisible()) {
 					if (ch.is_incomplete()) {
-						Global.getPref().log(&quot;skipping export of incomplete waypoint &quot;+ch.getWayPoint());
+						Global.getPref().log(&quot;skipping export of incomplete waypoint &quot; + ch.getWayPoint());
 						incompleteWaypoints++;
 						continue;
 					}
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
 					switch (this.howManyParams) {
 					case NO_PARAMS:
 						str = record(ch);
 						break;
 					case LAT_LON:
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
 						break;
-					case LAT_LON|COUNT: 
-						if (ch.pos.isValid() == false) continue;
-						str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-									 ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											 i);
+					case LAT_LON | COUNT:
+						if (ch.getPos().isValid() == false)
+							continue;
+						str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator), i);
 						break;
 					default:
 						str = null;
 						break;
 					}
-					if (str != null) outp.print(str);
-				}//if
-			}//for
+					if (str != null)
+						outp.print(str);
+				}// if
+			}// for
 			switch (this.howManyParams &amp; COUNT) {
-			case NO_PARAMS: 
+			case NO_PARAMS:
 				str = trailer();
 				break;
 			case COUNT:
@@ -174,64 +177,75 @@
 				str = null;
 				break;
 			}
-			if (str != null) outp.print(str);
+			if (str != null)
+				outp.print(str);
 			outp.close();
 			pbf.exit(0);
 			if (incompleteWaypoints &gt; 0) {
-				new MessageBox(&quot;Export Error&quot;, incompleteWaypoints+&quot; incomplete waypoints have not been exported. See log for details.&quot;, FormBase.OKB).execute();
+				new MessageBox(&quot;Export Error&quot;, incompleteWaypoints + &quot; incomplete waypoints have not been exported. See log for details.&quot;, FormBase.OKB).execute();
 			}
-		} catch (IOException ioE){
-			pref.log(&quot;Error opening &quot; + outFile.getName(),ioE);
+		} catch (IOException ioE) {
+			pref.log(&quot;Error opening &quot; + outFile.getName(), ioE);
 		}
-		//try
+		// try
 	}
+
 	/**
 	 * sets mask for filechooser
-	 * @param mask 
+	 * 
+	 * @param mask
 	 */
-	public void setMask(String mask){
+	public void setMask(String mask) {
 		this.mask = mask;
 	}
+
 	/**
 	 * sets decimal separator for lat/lon-string
+	 * 
 	 * @param sep
 	 */
-	public void setDecimalSeparator (char sep){
+	public void setDecimalSeparator(char sep) {
 		this.decimalSeparator = sep;
 	}
+
 	/**
-	 *  sets needCacheDetails
+	 * sets needCacheDetails
+	 * 
 	 * @param how
 	 */
-	public void setNeedCacheDetails(boolean how){
+	public void setNeedCacheDetails(boolean how) {
 		this.needCacheDetails = how;
 	}
-	
+
 	/**
 	 * sets howManyParams
+	 * 
 	 * @param paramBits
 	 */
-	public void setHowManyParams(int paramBits){
+	public void setHowManyParams(int paramBits) {
 		this.howManyParams = paramBits;
 	}
+
 	/**
 	 * sets tmpFileName
+	 * 
 	 * @param fName
 	 */
-	public void setTmpFileName(String fName){
+	public void setTmpFileName(String fName) {
 		this.tmpFileName = fName;
 	}
 
 	/**
 	 * uses a filechooser to get the name of the export file
+	 * 
 	 * @return
 	 */
-	public File getOutputFile (){
+	public File getOutputFile() {
 		File file;
 		FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 		fc.setTitle(&quot;Select target file:&quot;);
 		fc.addMask(mask);
-		if(fc.execute() != FormBase.IDCANCEL){
+		if (fc.execute() != FormBase.IDCANCEL) {
 			file = fc.getChosenFile();
 			pref.setExportPath(expName, file.getPath());
 			return file;
@@ -239,226 +253,145 @@
 			return null;
 		}
 	}
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated header data
-	 */	
-	public String header () {
+	 */
+	public String header() {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
+	 * 
+	 * @param ch
+	 *            cachedata
 	 * @return formated cache data
-	 */	
-	public String record(CacheHolder chD){
+	 */
+	public String record(CacheHolder chD) {
 		return null;
 	}
 
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon){
+	public String record(CacheHolder ch, String lat, String lon) {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param ch	cachedata
-	 * @param lat	
+	 * 
+	 * @param ch
+	 *            cachedata
+	 * @param lat
 	 * @param lon
-	 * @param count of actual record
+	 * @param count
+	 *            of actual record
 	 * @return formated cache data
 	 */
-	public String record(CacheHolder ch, String lat, String lon, int count){
+	public String record(CacheHolder ch, String lat, String lon, int count) {
 		return null;
 	}
-	
+
 	/**
 	 * this method can be overided by an exporter class
+	 * 
 	 * @return formated trailer data
-	 */	
-	public String trailer(){
+	 */
+	public String trailer() {
 		return null;
 	}
+
 	/**
 	 * this method can be overided by an exporter class
-	 * @param total count of exported caches
+	 * 
+	 * @param total
+	 *            count of exported caches
 	 * @return
 	 */
-	public String trailer(int total){
+	public String trailer(int total) {
 		return null;
 	}
 
-///////////////////////////////////////////////////
-//  Helper functions for string sanitisation
-///////////////////////////////////////////////////
-	
+	// /////////////////////////////////////////////////
+	// Helper functions for string sanitisation
+	// /////////////////////////////////////////////////
+
 	private static Hashtable iso2simpleMappings = new Hashtable(250);
 	static {
-		String[] mappingArray = new String[] {
-				&quot;34&quot;,  &quot;'&quot;,
-				&quot;160&quot;, &quot; &quot;,
-				&quot;161&quot;, &quot;i&quot;,
-				&quot;162&quot;, &quot;c&quot;,
-				&quot;163&quot;, &quot;$&quot;,
-				&quot;164&quot;, &quot;o&quot;,
-				&quot;165&quot;, &quot;$&quot;,
-				&quot;166&quot;, &quot;!&quot;,
-				&quot;167&quot;, &quot;$&quot;,
-				&quot;168&quot;, &quot; &quot;,
-				&quot;169&quot;, &quot; &quot;,
-				&quot;170&quot;, &quot; &quot;,
-				&quot;171&quot;, &quot;&lt;&quot;,
-				&quot;172&quot;, &quot; &quot;,
-				&quot;173&quot;, &quot;-&quot;,
-				&quot;174&quot;, &quot; &quot;,
-				&quot;175&quot;, &quot;-&quot;,
-				&quot;176&quot;, &quot; &quot;,
-				&quot;177&quot;, &quot;+/-&quot;,
-				&quot;178&quot;, &quot;2&quot;,
-				&quot;179&quot;, &quot;3&quot;,
-				&quot;180&quot;, &quot;'&quot;,
-				&quot;181&quot;, &quot; &quot;,
-				&quot;182&quot;, &quot; &quot;,
-				&quot;183&quot;, &quot; &quot;,
-				&quot;184&quot;, &quot;,&quot;,
-				&quot;185&quot;, &quot;1&quot;,
-				&quot;186&quot;, &quot; &quot;,
-				&quot;187&quot;, &quot;&gt;&quot;,
-				&quot;188&quot;, &quot;1/4&quot;,
-				&quot;189&quot;, &quot;1/2&quot;,
-				&quot;190&quot;, &quot;3/4&quot;,
-				&quot;191&quot;, &quot;?&quot;,
-				&quot;192&quot;, &quot;A&quot;,
-				&quot;193&quot;, &quot;A&quot;,
-				&quot;194&quot;, &quot;A&quot;,
-				&quot;195&quot;, &quot;A&quot;,
-				&quot;196&quot;, &quot;Ae&quot;,
-				&quot;197&quot;, &quot;A&quot;,
-				&quot;198&quot;, &quot;AE&quot;,
-				&quot;199&quot;, &quot;C&quot;,
-				&quot;200&quot;, &quot;E&quot;,
-				&quot;201&quot;, &quot;E&quot;,
-				&quot;202&quot;, &quot;E&quot;,
-				&quot;203&quot;, &quot;E&quot;,
-				&quot;204&quot;, &quot;I&quot;,
-				&quot;205&quot;, &quot;I&quot;,
-				&quot;206&quot;, &quot;I&quot;,
-				&quot;207&quot;, &quot;I&quot;,
-				&quot;208&quot;, &quot;D&quot;,
-				&quot;209&quot;, &quot;N&quot;,
-				&quot;210&quot;, &quot;O&quot;,
-				&quot;211&quot;, &quot;O&quot;,
-				&quot;212&quot;, &quot;O&quot;,
-				&quot;213&quot;, &quot;O&quot;,
-				&quot;214&quot;, &quot;Oe&quot;,
-				&quot;215&quot;, &quot;x&quot;,
-				&quot;216&quot;, &quot;O&quot;,
-				&quot;217&quot;, &quot;U&quot;,
-				&quot;218&quot;, &quot;U&quot;,
-				&quot;219&quot;, &quot;U&quot;,
-				&quot;220&quot;, &quot;Ue&quot;,
-				&quot;221&quot;, &quot;Y&quot;,
-				&quot;222&quot;, &quot; &quot;,
-				&quot;223&quot;, &quot;ss&quot;,
-				&quot;224&quot;, &quot;a&quot;,
-				&quot;225&quot;, &quot;a&quot;,
-				&quot;226&quot;, &quot;a&quot;,
-				&quot;227&quot;, &quot;a&quot;,
-				&quot;228&quot;, &quot;ae&quot;,
-				&quot;229&quot;, &quot;a&quot;,
-				&quot;230&quot;, &quot;ae&quot;,
-				&quot;231&quot;, &quot;c&quot;,
-				&quot;232&quot;, &quot;e&quot;,
-				&quot;233&quot;, &quot;e&quot;,
-				&quot;234&quot;, &quot;e&quot;,
-				&quot;235&quot;, &quot;e&quot;,
-				&quot;236&quot;, &quot;i&quot;,
-				&quot;237&quot;, &quot;i&quot;,
-				&quot;238&quot;, &quot;i&quot;,
-				&quot;239&quot;, &quot;i&quot;,
-				&quot;240&quot;, &quot;o&quot;,
-				&quot;241&quot;, &quot;n&quot;,
-				&quot;242&quot;, &quot;o&quot;,
-				&quot;243&quot;, &quot;o&quot;,
-				&quot;244&quot;, &quot;o&quot;,
-				&quot;245&quot;, &quot;o&quot;,
-				&quot;246&quot;, &quot;oe&quot;,
-				&quot;247&quot;, &quot;/&quot;,
-				&quot;248&quot;, &quot;o&quot;,
-				&quot;249&quot;, &quot;u&quot;,
-				&quot;250&quot;, &quot;u&quot;,
-				&quot;251&quot;, &quot;u&quot;,
-				&quot;252&quot;, &quot;ue&quot;,
-				&quot;253&quot;, &quot;y&quot;,
-				&quot;254&quot;, &quot;p&quot;,
-				&quot;255&quot;, &quot;y&quot;
-		};
+		String[] mappingArray = new String[] { &quot;34&quot;, &quot;'&quot;, &quot;160&quot;, &quot; &quot;, &quot;161&quot;, &quot;i&quot;, &quot;162&quot;, &quot;c&quot;, &quot;163&quot;, &quot;$&quot;, &quot;164&quot;, &quot;o&quot;, &quot;165&quot;, &quot;$&quot;, &quot;166&quot;, &quot;!&quot;, &quot;167&quot;, &quot;$&quot;, &quot;168&quot;, &quot; &quot;, &quot;169&quot;, &quot; &quot;, &quot;170&quot;, &quot; &quot;, &quot;171&quot;, &quot;&lt;&quot;, &quot;172&quot;, &quot; &quot;, &quot;173&quot;, &quot;-&quot;, &quot;174&quot;, &quot; &quot;, &quot;175&quot;, &quot;-&quot;,
+				&quot;176&quot;, &quot; &quot;, &quot;177&quot;, &quot;+/-&quot;, &quot;178&quot;, &quot;2&quot;, &quot;179&quot;, &quot;3&quot;, &quot;180&quot;, &quot;'&quot;, &quot;181&quot;, &quot; &quot;, &quot;182&quot;, &quot; &quot;, &quot;183&quot;, &quot; &quot;, &quot;184&quot;, &quot;,&quot;, &quot;185&quot;, &quot;1&quot;, &quot;186&quot;, &quot; &quot;, &quot;187&quot;, &quot;&gt;&quot;, &quot;188&quot;, &quot;1/4&quot;, &quot;189&quot;, &quot;1/2&quot;, &quot;190&quot;, &quot;3/4&quot;, &quot;191&quot;, &quot;?&quot;, &quot;192&quot;, &quot;A&quot;, &quot;193&quot;, &quot;A&quot;, &quot;194&quot;, &quot;A&quot;,
+				&quot;195&quot;, &quot;A&quot;, &quot;196&quot;, &quot;Ae&quot;, &quot;197&quot;, &quot;A&quot;, &quot;198&quot;, &quot;AE&quot;, &quot;199&quot;, &quot;C&quot;, &quot;200&quot;, &quot;E&quot;, &quot;201&quot;, &quot;E&quot;, &quot;202&quot;, &quot;E&quot;, &quot;203&quot;, &quot;E&quot;, &quot;204&quot;, &quot;I&quot;, &quot;205&quot;, &quot;I&quot;, &quot;206&quot;, &quot;I&quot;, &quot;207&quot;, &quot;I&quot;, &quot;208&quot;, &quot;D&quot;, &quot;209&quot;, &quot;N&quot;, &quot;210&quot;, &quot;O&quot;, &quot;211&quot;, &quot;O&quot;, &quot;212&quot;, &quot;O&quot;, &quot;213&quot;, &quot;O&quot;, &quot;214&quot;,
+				&quot;Oe&quot;, &quot;215&quot;, &quot;x&quot;, &quot;216&quot;, &quot;O&quot;, &quot;217&quot;, &quot;U&quot;, &quot;218&quot;, &quot;U&quot;, &quot;219&quot;, &quot;U&quot;, &quot;220&quot;, &quot;Ue&quot;, &quot;221&quot;, &quot;Y&quot;, &quot;222&quot;, &quot; &quot;, &quot;223&quot;, &quot;ss&quot;, &quot;224&quot;, &quot;a&quot;, &quot;225&quot;, &quot;a&quot;, &quot;226&quot;, &quot;a&quot;, &quot;227&quot;, &quot;a&quot;, &quot;228&quot;, &quot;ae&quot;, &quot;229&quot;, &quot;a&quot;, &quot;230&quot;, &quot;ae&quot;, &quot;231&quot;, &quot;c&quot;, &quot;232&quot;, &quot;e&quot;, &quot;233&quot;, &quot;e&quot;,
+				&quot;234&quot;, &quot;e&quot;, &quot;235&quot;, &quot;e&quot;, &quot;236&quot;, &quot;i&quot;, &quot;237&quot;, &quot;i&quot;, &quot;238&quot;, &quot;i&quot;, &quot;239&quot;, &quot;i&quot;, &quot;240&quot;, &quot;o&quot;, &quot;241&quot;, &quot;n&quot;, &quot;242&quot;, &quot;o&quot;, &quot;243&quot;, &quot;o&quot;, &quot;244&quot;, &quot;o&quot;, &quot;245&quot;, &quot;o&quot;, &quot;246&quot;, &quot;oe&quot;, &quot;247&quot;, &quot;/&quot;, &quot;248&quot;, &quot;o&quot;, &quot;249&quot;, &quot;u&quot;, &quot;250&quot;, &quot;u&quot;, &quot;251&quot;, &quot;u&quot;, &quot;252&quot;, &quot;ue&quot;, &quot;253&quot;,
+				&quot;y&quot;, &quot;254&quot;, &quot;p&quot;, &quot;255&quot;, &quot;y&quot; };
 		for (int i = 0; i &lt; mappingArray.length; i = i + 2) {
-			iso2simpleMappings.put( Integer.valueOf( mappingArray[i]), mappingArray[i+1]);
+			iso2simpleMappings.put(Integer.valueOf(mappingArray[i]), mappingArray[i + 1]);
 		}
 	}
 
-	
-	protected static String char2simpleChar( char c )
-    {
-        if ( c &lt; 127 ) {
-            // leave alone as equivalent string.
-            return null;
-        } else {
-            String s=(String) iso2simpleMappings.get( new Integer(c));
-            if (s==null) // not in table, replace with empty string just to be sure
-            	return &quot;&quot;;
-            else
-            	return s;
-        }
-    } // end charToEntity
-	
-    public static String simplifyString( String text ) {
-        if ( text == null ) return null;
-        int originalTextLength = text.length();
-        StringBuffer sb = new StringBuffer( 50 );
-        int charsToAppend = 0;
-        for ( int i = 0; i &lt; originalTextLength; i++ ) {
-            char c = text.charAt( i );
-            String entity = char2simpleChar( c );
-            if ( entity == null ) {
-                // we could sb.append( c ), but that would be slower
-                // than saving them up for a big append.
-                charsToAppend++;
-            } else {
-                if ( charsToAppend != 0 ) {
-                    sb.append( text.substring( i - charsToAppend, i ) );
-                    charsToAppend = 0;
-                }
-                sb.append( entity );
-            }
-        } // end for
-        // append chars to the right of the last entity.
-        if ( charsToAppend != 0 ) {
-            sb.append( text.substring( originalTextLength - charsToAppend,
-                                       originalTextLength ) );
-        }
-        // if result is not longer, we did not do anything. Save RAM.
-        return ( sb.length() == originalTextLength ) ? text : sb.toString();
-    } // end insertEntities
+	protected static String char2simpleChar(char c) {
+		if (c &lt; 127) {
+			// leave alone as equivalent string.
+			return null;
+		} else {
+			String s = (String) iso2simpleMappings.get(new Integer(c));
+			if (s == null) // not in table, replace with empty string just to be sure
+				return &quot;&quot;;
+			else
+				return s;
+		}
+	} // end charToEntity
 
-    public static String getShortDetails( CacheHolder ch ) {
-    	StringBuffer strBuf = new StringBuffer(7);
-    	strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());			
-    	if (!ch.isAddiWpt()) {
-   			strBuf.append(ch.getHard());
-   			strBuf.append(&quot;/&quot;);
-   			strBuf.append(ch.getTerrain());
-    		strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
-    	}
+	public static String simplifyString(String text) {
+		if (text == null)
+			return null;
+		int originalTextLength = text.length();
+		StringBuffer sb = new StringBuffer(50);
+		int charsToAppend = 0;
+		for (int i = 0; i &lt; originalTextLength; i++) {
+			char c = text.charAt(i);
+			String entity = char2simpleChar(c);
+			if (entity == null) {
+				// we could sb.append( c ), but that would be slower
+				// than saving them up for a big append.
+				charsToAppend++;
+			} else {
+				if (charsToAppend != 0) {
+					sb.append(text.substring(i - charsToAppend, i));
+					charsToAppend = 0;
+				}
+				sb.append(entity);
+			}
+		} // end for
+			// append chars to the right of the last entity.
+		if (charsToAppend != 0) {
+			sb.append(text.substring(originalTextLength - charsToAppend, originalTextLength));
+		}
+		// if result is not longer, we did not do anything. Save RAM.
+		return (sb.length() == originalTextLength) ? text : sb.toString();
+	} // end insertEntities
 
-    	return strBuf.toString();
-    }
+	public static String getShortDetails(CacheHolder ch) {
+		StringBuffer strBuf = new StringBuffer(7);
+		strBuf.append(CacheType.getExportShortId(ch.getType()).toLowerCase());
+		if (!ch.isAddiWpt()) {
+			strBuf.append(ch.getHard());
+			strBuf.append(&quot;/&quot;);
+			strBuf.append(ch.getTerrain());
+			strBuf.append(CacheSize.getExportShortId(ch.getCacheSize()));
+		}
 
+		return strBuf.toString();
+	}
+
 }

Modified: branches/r1.2/src/CacheWolf/exp/GpxExportNg.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/GpxExportNg.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/GpxExportNg.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.Attribute;
@@ -85,12 +85,11 @@
 import ewe.util.zip.ZipFile;
 
 /**
- * experimental GPX exporter that should better handle the various tasks that
- * can be accomplished with GPX
+ * experimental GPX exporter that should better handle the various tasks that can be accomplished with GPX
  */
 public class GpxExportNg {
 	/** new line */
-	final static String newLine=&quot;\r\n&quot;;
+	final static String newLine = &quot;\r\n&quot;;
 	/** decimal separator for lat- and lon-String */
 	// final static char decimalSeparator='.';
 	/** export is in compact format */
@@ -119,7 +118,7 @@
 	final static String FALSE = &quot;False&quot;;
 	/** object used to determine custom symbols and POI categories */
 	private static GarminMap poiMapper = new GarminMap();
-	/** maximum number of logs to export. can be overwritten with preferences, default unlimited*/
+	/** maximum number of logs to export. can be overwritten with preferences, default unlimited */
 	private int maxLogs = ewe.math.Number.INTEGER_MAX_VALUE;
 	/** number of errors / warnings during export */
 	private int exportErrors = 0;
@@ -127,35 +126,48 @@
 	private String finderid;
 
 	// we need to fake desc to make clients like GSAK accept additional waypoints together with caches
-	final static String GPXHEADER = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;+(newLine)
-			+(&quot;&lt;gpx xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot; version=\&quot;1.0\&quot; creator=\&quot;CacheWolf\&quot; xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> <A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> <A HREF="http://www.groundspeak.com/cache/1/0">http://www.groundspeak.com/cache/1/0</A> <A HREF="http://www.groundspeak.com/cache/1/0/cache.xsd\">http://www.groundspeak.com/cache/1/0/cache.xsd\</A>&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&gt;&quot;)+(newLine)
-			+(&quot;&lt;name&gt;@@NAME@@&lt;/name&gt;&quot;)+(newLine)
-			+(&quot;&lt;desc&gt;This is an individual cache generated from Geocaching.com&lt;/desc&gt;&quot;)+(newLine)
-			+(&quot;&lt;author&gt;Various users from geocaching.com and/or opencaching.de&lt;/author&gt;&quot;)+(newLine)
-			+(&quot;&lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">contact at cachewolf.de</A>&lt;/email&gt;&quot;)+(newLine)
-			+(&quot;&lt;url&gt;<A HREF="http://www.cachewolf.de/&lt;/url">http://www.cachewolf.de/&lt;/url</A>&gt;&quot;)+(newLine)
-			+(&quot;&lt;urlname&gt;CacheWolf - Paperless Geocaching&lt;/urlname&gt;&quot;)+(newLine)
-			+(&quot;&lt;time&gt;@@CREATEDATE@@T07:00:00Z&lt;/time&gt;&quot;)+(newLine)
-			+(&quot;&lt;keywords&gt;cache, geocache, waypoints&lt;/keywords&gt;&quot;)+(newLine)
+	final static String GPXHEADER = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot; + (newLine)//
+			+ (&quot;&lt;gpx&quot;)//
+			+ (&quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot;&quot;)//
+			+ (&quot; xmlns:xsd=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema\">http://www.w3.org/2001/XMLSchema\</A>&quot;&quot;)//
+			+ (&quot; version=\&quot;1.0\&quot;&quot;)//
+			+ (&quot; creator=\&quot;CacheWolf\&quot;&quot;)//
+			+ (&quot; xsi:schemaLocation=\&quot;&quot;)//
+			+ (&quot;<A HREF="http://www.topografix.com/GPX/1/0">http://www.topografix.com/GPX/1/0</A> &quot;)//
+			+ (&quot;<A HREF="http://www.topografix.com/GPX/1/0/gpx.xsd">http://www.topografix.com/GPX/1/0/gpx.xsd</A> &quot;)//
+			+ (&quot;<A HREF="http://www.groundspeak.com/cache/1/0/1">http://www.groundspeak.com/cache/1/0/1</A> &quot;)//
+			+ (&quot;<A HREF="http://www.groundspeak.com/cache/1/0/1/cache.xsd">http://www.groundspeak.com/cache/1/0/1/cache.xsd</A>&quot;)//
+			+ (&quot;\&quot;&quot;)//
+			+ (&quot; xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/0\">http://www.topografix.com/GPX/1/0\</A>&quot;&quot;)//
+			+ (&quot;&gt;&quot;)//
+			+ (newLine)//
+			+ (&quot;&lt;name&gt;@@NAME@@&lt;/name&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;desc&gt;This is an individual cache generated from Geocaching.com&lt;/desc&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;author&gt;Various users from geocaching.com and/or opencaching.de&lt;/author&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">contact at cachewolf.de</A>&lt;/email&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;url&gt;<A HREF="http://www.cachewolf.de/&lt;/url">http://www.cachewolf.de/&lt;/url</A>&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;urlname&gt;CacheWolf - Paperless Geocaching&lt;/urlname&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;time&gt;@@CREATEDATE@@T07:00:00Z&lt;/time&gt;&quot;) + (newLine)//
+			+ (&quot;&lt;keywords&gt;cache, geocache, waypoints&lt;/keywords&gt;&quot;) + (newLine)//
 	// TODO: is it worth a second loop?
 	// +(&quot;&lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot; maxlon=\&quot;6.918817\&quot; /&gt;&quot;)
 	;
 
-	final static String GPXLOG = &quot;\t\t\t\t&lt;groundspeak:log id=\&quot;@@LOGID@@\&quot;&gt;&quot;+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:date&gt;@@LOGDATE@@T00:00:00&lt;/groundspeak:date&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:type&gt;@@LOGTYPE@@&lt;/groundspeak:type&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:finder id=\&quot;@@LOGFINDERID@@\&quot;&gt;@@LOGFINDER@@&lt;/groundspeak:finder&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:text encoded=\&quot;@@LOGENCODE@@\&quot;&gt;@@LOGTEXT@@&lt;/groundspeak:text&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t&lt;/groundspeak:log&gt;&quot;)+(newLine);
+	final static String GPXLOG = &quot;\t\t\t\t&lt;groundspeak:log id=\&quot;@@LOGID@@\&quot;&gt;&quot; + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:date&gt;@@LOGDATE@@T00:00:00&lt;/groundspeak:date&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:type&gt;@@LOGTYPE@@&lt;/groundspeak:type&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:finder id=\&quot;@@LOGFINDERID@@\&quot;&gt;@@LOGFINDER@@&lt;/groundspeak:finder&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:text encoded=\&quot;@@LOGENCODE@@\&quot;&gt;@@LOGTEXT@@&lt;/groundspeak:text&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t&lt;/groundspeak:log&gt;&quot;) + (newLine);//
 
-	final static String GPXTB = &quot;\t\t\t\t&lt;groundspeak:travelbug id=\&quot;@@TBID@@\&quot; ref=\&quot;@@TBREF@@\&quot;&gt;&quot;+(newLine)
-			+(&quot;\t\t\t\t\t&lt;groundspeak:name&gt;@@TBNAME@@&lt;/groundspeak:name&gt;&quot;)+(newLine)
-			+(&quot;\t\t\t\t&lt;/groundspeak:travelbug&gt;&quot;)+(newLine);
+	final static String GPXTB = &quot;\t\t\t\t&lt;groundspeak:travelbug id=\&quot;@@TBID@@\&quot; ref=\&quot;@@TBREF@@\&quot;&gt;&quot; + (newLine)//
+			+ (&quot;\t\t\t\t\t&lt;groundspeak:name&gt;@@TBNAME@@&lt;/groundspeak:name&gt;&quot;) + (newLine)//
+			+ (&quot;\t\t\t\t&lt;/groundspeak:travelbug&gt;&quot;) + (newLine);//
 
 	// FIXME: don't use this until GPX import can strip this off as well
-	final static String GPXADDIINMAIN = &quot;@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@&quot;
-			+(&quot;@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@&quot;)
-			+(&quot;@@ADDILONG@@@@ADDIDELIM@@&quot;);
+	final static String GPXADDIINMAIN = &quot;@@ADDIID@@ - @@ADDISHORT@@@@ADDIDELIM@@&quot;//
+			+ (&quot;@@ADDILAT@@ @@ADDILON@@@@ADDIDELIM@@&quot;)//
+			+ (&quot;@@ADDILONG@@@@ADDIDELIM@@&quot;);//
 
 	private static boolean customIcons;
 	private static boolean sendToGarmin;
@@ -171,16 +183,18 @@
 	private static String bitmapFileName;
 
 	public GpxExportNg() {
-		bitmapFileName = FileBase.getProgramDirectory() + &quot;/exporticons/GarminPOI.zip&quot;; //own version
-		if (!(hasBitmaps=new File(bitmapFileName).exists())) {
-			bitmapFileName=FileBase.getProgramDirectory() + &quot;/exporticons/exporticons/GarminPOI.zip&quot;; //cw default version
-			hasBitmaps=new File(bitmapFileName).exists();			
+		bitmapFileName = FileBase.getProgramDirectory() + &quot;/exporticons/GarminPOI.zip&quot;; // own version
+		if (!(hasBitmaps = new File(bitmapFileName).exists())) {
+			// cw default version
+			bitmapFileName = FileBase.getProgramDirectory() + &quot;/exporticons/exporticons/GarminPOI.zip&quot;;
+			hasBitmaps = new File(bitmapFileName).exists();
 		}
 
 		hasGpsbabel = Global.getPref().gpsbabel != null;
 
 		finderid = Global.getPref().gcMemberId;
-		if (finderid.equals(&quot;&quot;)) Global.getPref().log(&quot;GPX Export: warning gcmemberid not set, check pref.xml&quot;,null);
+		if (finderid.equals(&quot;&quot;))
+			Global.getPref().log(&quot;GPX Export: warning gcmemberid not set, check pref.xml&quot;, null);
 	}
 
 	public void doit() {
@@ -211,11 +225,9 @@
 			ZipFile poiZip = null;
 
 			if (exportTarget == OUTPUT_POI) {
-				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,
-						Global.getPref().getExportPath(expName + &quot;-POI&quot;));
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getExportPath(expName + &quot;-POI&quot;));
 			} else {
-				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT,
-						Global.getPref().getExportPath(expName + &quot;-GPI&quot;));
+				fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getExportPath(expName + &quot;-GPI&quot;));
 			}
 
 			fc.setTitle(&quot;Select target directory:&quot;);
@@ -231,9 +243,8 @@
 			}
 
 			if (!poiMapper.exists) {
-				Global.getPref().log(&quot;GPX Export: unable to load garminmap.xml&quot;,null);
-				new MessageBox(&quot;Export Error&quot;, &quot;unable to load garminmap.xml&quot;,
-						FormBase.OKB).execute();
+				Global.getPref().log(&quot;GPX Export: unable to load garminmap.xml&quot;, null);
+				new MessageBox(&quot;Export Error&quot;, &quot;unable to load garminmap.xml&quot;, FormBase.OKB).execute();
 				return;
 			}
 
@@ -245,12 +256,12 @@
 				tempDir = outDir;
 				String tmp[] = new FileBugfix(tempDir).list(prefix + &quot;*.gpx&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 				for (int i = 0; i &lt; tmp.length; i++) {
-					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+					FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 					tmpFile.delete();
 				}
 				tmp = new FileBugfix(tempDir).list(prefix + &quot;*.bmp&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 				for (int i = 0; i &lt; tmp.length; i++) {
-					FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+					FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 					tmpFile.delete();
 				}
 			}
@@ -273,30 +284,22 @@
 					if (!ch.isVisible()) {
 						continue;
 					} else if (ch.is_incomplete()) {
-						Global.getPref().log(
-								&quot;skipping export of incomplete waypoint &quot;
-								+ ch.getWayPoint(),null);
+						Global.getPref().log(&quot;skipping export of incomplete waypoint &quot; + ch.getWayPoint(), null);
 					} else {
 						String poiId = poiMapper.getPoiId(ch);
 						if (null == poiId) {
-							Global.getPref().log(
-									&quot;GPX Export: unmatched POI ID for &quot;
-									+ ch.getWayPoint() + &quot; of type &quot;
-									+ ch.getType(),null);
+							Global.getPref().log(&quot;GPX Export: unmatched POI ID for &quot; + ch.getWayPoint() + &quot; of type &quot; + ch.getType(), null);
 							exportErrors++;
 						} else {
 							PrintWriter writer;
 							if (fileHandles.containsKey(poiId)) {
 								writer = (PrintWriter) fileHandles.get(poiId);
 							} else {
-								writer = new PrintWriter(new BufferedWriter(
-										new FileWriter(new File(tempDir
-												+ FileBase.separator + prefix
-												+ poiId + &quot;.gpx&quot;))));
+								writer = new PrintWriter(new BufferedWriter(new FileWriter(new File(tempDir + FileBase.separator + prefix + poiId + &quot;.gpx&quot;))));
 								fileHandles.put(poiId, writer);
 								writer.print(formatHeader());
 							}
-							String strOut=formatCache(ch);
+							String strOut = formatCache(ch);
 							if (!strOut.equals(&quot;&quot;)) {
 								writer.print(strOut);
 							}
@@ -318,16 +321,15 @@
 				if (exportTarget == OUTPUT_POI) {
 					// only clean up output directory if user has chosen non empty prefix,
 					// since otherwise all present POI would be deleted
-					if (! prefix.equals(&quot;&quot;)) {
-						String tmp[] = new FileBugfix(outDir).list(
-								prefix + &quot;*.gpi&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
+					if (!prefix.equals(&quot;&quot;)) {
+						String tmp[] = new FileBugfix(outDir).list(prefix + &quot;*.gpi&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 						for (int i = 0; i &lt; tmp.length; i++) {
 							FileBugfix tmpFile = new FileBugfix(outDir + FileBase.separator + tmp[i]);
 							tmpFile.delete();
 						}
 					}
 					pbf.exit(0);
-					poiCategories=fileHandles.size();
+					poiCategories = fileHandles.size();
 					pbf.setTask(h, &quot;Transfer&quot;);
 					pbf.exec();
 				}
@@ -338,7 +340,7 @@
 					String key = (String) keys.nextElement();
 					PrintWriter writer = (PrintWriter) fileHandles.get(key);
 
-					writer.print(&quot;&lt;/gpx&gt;&quot;+newLine);
+					writer.print(&quot;&lt;/gpx&gt;&quot; + newLine);
 					writer.close();
 					if (exportTarget == OUTPUT_POI) {
 						poiCounter++;
@@ -353,42 +355,35 @@
 
 						if (exportTarget == OUTPUT_POI) {
 							String[] cmdStack = new String[9];
-							cmdStack[0]=Global.getPref().gpsbabel;
-							cmdStack[1]=&quot;-i&quot;;
-							cmdStack[2]=&quot;gpx&quot;;
-							cmdStack[3]=&quot;-f&quot;;
-							cmdStack[4]=tempDir + FileBase.separator + prefix + key + &quot;.gpx&quot;;
-							cmdStack[5]=&quot;-o&quot;;
-							cmdStack[6]=&quot;garmin_gpi,sleep=1,category=&quot;+prefix + key+&quot;,bitmap=&quot;+tempDir + FileBase.separator + prefix + key	+ &quot;.bmp&quot;;
-							cmdStack[7]=&quot;-F&quot;;
-							cmdStack[8]=outDir + FileBase.separator + prefix + key + &quot;.gpi&quot;;
+							cmdStack[0] = Global.getPref().gpsbabel;
+							cmdStack[1] = &quot;-i&quot;;
+							cmdStack[2] = &quot;gpx&quot;;
+							cmdStack[3] = &quot;-f&quot;;
+							cmdStack[4] = tempDir + FileBase.separator + prefix + key + &quot;.gpx&quot;;
+							cmdStack[5] = &quot;-o&quot;;
+							cmdStack[6] = &quot;garmin_gpi,sleep=1,category=&quot; + prefix + key + &quot;,bitmap=&quot; + tempDir + FileBase.separator + prefix + key + &quot;.bmp&quot;;
+							cmdStack[7] = &quot;-F&quot;;
+							cmdStack[8] = outDir + FileBase.separator + prefix + key + &quot;.gpi&quot;;
 
-							Process babelProcess = startProcess(cmdStack);
+							Process babelProcess = null;
+							babelProcess = startProcess(cmdStack);
 							StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
-							while (errorStream.isOpen()) {
-								String errorMsg = errorStream.readALine();
-								if (errorMsg != null) {
-									Global.getPref().log(&quot;GPX Export: &quot; + errorMsg,null);
-									exportErrors++;
-								}
-								try {
-									babelProcess.exitValue();
-									errorStream.close();
-								} catch (IllegalThreadStateException e) {
-									// still running
-								}
+							babelProcess.waitFor();
+							String errorMsg = errorStream.readALine();
+							if (errorMsg != null) {
+								Global.getPref().log(&quot;GPX Export: &quot; + errorMsg, null);
+								exportErrors++;
 							}
+							errorStream.close();
 						}
-
 					}
 				}
 
 				if (exportTarget == OUTPUT_POI) {
 					FileBugfix tmpdir = new FileBugfix(tempDir);
-					String tmp[] = new FileBugfix(tempDir).list(prefix + &quot;*.*&quot;,
-							ewe.io.FileBase.LIST_FILES_ONLY);
+					String tmp[] = new FileBugfix(tempDir).list(prefix + &quot;*.*&quot;, ewe.io.FileBase.LIST_FILES_ONLY);
 					for (int i = 0; i &lt; tmp.length; i++) {
-						FileBugfix tmpFile = new FileBugfix(tempDir	+ FileBase.separator + tmp[i]);
+						FileBugfix tmpFile = new FileBugfix(tempDir + FileBase.separator + tmp[i]);
 						tmpFile.delete();
 					}
 					tmpdir.delete();
@@ -405,7 +400,7 @@
 			if (customIcons) {
 				if (!poiMapper.exists) {
 					customIcons = false;
-					Global.getPref().log(&quot;unable to load garminmap.xml&quot;,null);
+					Global.getPref().log(&quot;unable to load garminmap.xml&quot;, null);
 				}
 			}
 
@@ -420,8 +415,7 @@
 			final File file;
 
 			if (!sendToGarmin) {
-				final FileChooser fc = new FileChooser(FileChooserBase.SAVE,
-						Global.getPref().getExportPath(expName + &quot;-GPX&quot;));
+				final FileChooser fc = new FileChooser(FileChooserBase.SAVE, Global.getPref().getExportPath(expName + &quot;-GPX&quot;));
 
 				fc.setTitle(&quot;Select target GPX file:&quot;);
 				fc.addMask(&quot;*.gpx&quot;);
@@ -430,8 +424,7 @@
 					return;
 
 				file = fc.getChosenFile();
-				Global.getPref()
-						.setExportPath(expName + &quot;-GPX&quot;, file.getPath());
+				Global.getPref().setExportPath(expName + &quot;-GPX&quot;, file.getPath());
 			} else {
 				file = new File(&quot;&quot;).createTempFile(&quot;gpxexport&quot;, null, null);
 			}
@@ -446,12 +439,12 @@
 
 				outp.print(formatHeader());
 
-				//pbf.showMainTask = false;
-				//pbf.setTask(h, &quot;Exporting ...&quot;);
-				//pbf.exec();
-				//h.progressResolution=0;
+				// pbf.showMainTask = false;
+				// pbf.setTask(h, &quot;Exporting ...&quot;);
+				// pbf.exec();
+				// h.progressResolution=0;
 
-				Global.getPref().log(&quot;start: &quot;+new Time().getTime());
+				Global.getPref().log(&quot;start: &quot; + new Time().getTime());
 				CacheDB cDB = Global.getProfile().cacheDB;
 				for (int i = 0; i &lt; cDB.size(); i++) {
 					CacheHolder ch = cDB.get(i);
@@ -459,68 +452,60 @@
 						continue;
 					} else if (ch.is_incomplete()) {
 						exportErrors++;
-						Global.getPref().log(&quot;GPX Export: skipping export of incomplete waypoint &quot; + ch.getWayPoint(),null);
+						Global.getPref().log(&quot;GPX Export: skipping export of incomplete waypoint &quot; + ch.getWayPoint(), null);
 					} else {
-						String strOut=formatCache(ch);
+						String strOut = formatCache(ch);
 						if (!strOut.equals(&quot;&quot;)) {
 							outp.print(strOut);
 							expCount++;
 						}
 					}
-					
-					//h.progress = expCount / totalCount;
-					//h.changed();
-					
-					if (Global.mainTab.statBar!=null) Global.mainTab.statBar.updateDisplay(&quot; &quot;+((expCount * 100) / totalCount)+&quot;% &quot;);
+
+					// h.progress = expCount / totalCount;
+					// h.changed();
+
+					if (Global.mainTab.statBar != null)
+						Global.mainTab.statBar.updateDisplay(&quot; &quot; + ((expCount * 100) / totalCount) + &quot;% &quot;);
 				}
 
-				Global.getPref().log(&quot;stop: &quot;+new Time().getTime());
-				if (Global.mainTab.statBar!=null) Global.mainTab.statBar.updateDisplay(&quot;done:&quot;+expCount);
+				Global.getPref().log(&quot;stop: &quot; + new Time().getTime());
+				if (Global.mainTab.statBar != null)
+					Global.mainTab.statBar.updateDisplay(&quot;done:&quot; + expCount);
 				// pbf.exit(0);
 
-				outp.print(&quot;&lt;/gpx&gt;&quot;+newLine);
+				outp.print(&quot;&lt;/gpx&gt;&quot; + newLine);
 				outp.close();
 			} catch (Exception ex) {
 				exportErrors++;
 				Global.getPref().log(&quot;GPX Export: unable to write output to &quot; + file.toString(), ex, true);
-				new MessageBox(&quot;Export Error&quot;, &quot;unable to write output to &quot;	+ file.toString(), FormBase.OKB).execute();
+				new MessageBox(&quot;Export Error&quot;, &quot;unable to write output to &quot; + file.toString(), FormBase.OKB).execute();
 				return;
-			}
-			finally {
+			} finally {
 				Vm.showWait(false);
 			}
 
-
 			if (sendToGarmin) {
 				try {
 					String[] cmdStack = new String[9];
-					cmdStack[0]=Global.getPref().gpsbabel;
-					cmdStack[1]=&quot;-i&quot;;
-					cmdStack[2]=&quot;gpx&quot;;
-					cmdStack[3]=&quot;-f&quot;;
-					cmdStack[4]=file.getCreationName();
-					cmdStack[5]=&quot;-o&quot;;
-					cmdStack[6]=&quot;garmin&quot;;
-					cmdStack[7]=&quot;-F&quot;;
-					cmdStack[8]=Global.getPref().garminConn+(&quot;:&quot;);
-
-					Process babelProcess = this.startProcess(cmdStack);
-					if (babelProcess != null) {
-						StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
-						while (errorStream.isOpen()) {
-							String errorMsg = errorStream.readALine();
-							if (errorMsg != null) {
-								Global.getPref().log(&quot;[GPX Export:sendToGarmin] &quot; + errorMsg,null);
-								exportErrors++;
-							}
-							try {
-								babelProcess.exitValue();
-								errorStream.close();
-							} catch (IllegalThreadStateException e) {
-								// still running
-							}
-						}
+					cmdStack[0] = Global.getPref().gpsbabel;
+					cmdStack[1] = &quot;-i&quot;;
+					cmdStack[2] = &quot;gpx&quot;;
+					cmdStack[3] = &quot;-f&quot;;
+					cmdStack[4] = file.getCreationName();
+					cmdStack[5] = &quot;-o&quot;;
+					cmdStack[6] = &quot;garmin&quot;;
+					cmdStack[7] = &quot;-F&quot;;
+					cmdStack[8] = Global.getPref().garminConn + (&quot;:&quot;);
+					Process babelProcess = null;
+					babelProcess = startProcess(cmdStack);
+					StreamReader errorStream = new StreamReader(babelProcess.getErrorStream());
+					babelProcess.waitFor();
+					String errorMsg = errorStream.readALine();
+					if (errorMsg != null) {
+						Global.getPref().log(&quot;GPX Export: &quot; + errorMsg, null);
+						exportErrors++;
 					}
+					errorStream.close();
 				} catch (Exception ex) {
 					Global.getPref().log(&quot;GPX Export error :&quot;, ex, true);
 				}
@@ -528,13 +513,13 @@
 			}
 		}
 		if (exportErrors &gt; 0) {
-			new MessageBox(&quot;Export Error&quot;, exportErrors	+ &quot; errors during export. Check log for details.&quot;,
-					FormBase.OKB).execute();
+			new MessageBox(&quot;Export Error&quot;, exportErrors + &quot; errors during export. Check log for details.&quot;, FormBase.OKB).execute();
 		}
 	}
 
 	/**
 	 * wrapper for formatting a cache. will call some subroutines to do the actual work
+	 * 
 	 * @param ch
 	 * @return
 	 */
@@ -543,7 +528,7 @@
 		if ((STYLE_GPX_MYFINDS == exportStyle) &amp;&amp; (ch.isCustomWpt() || ch.isAddiWpt() || !ch.is_found()))
 			return &quot;&quot;;
 
-		if (!ch.pos.isValid()) {
+		if (!ch.getPos().isValid()) {
 			Global.getPref().log(&quot;[GPX Export:formatCache] &quot; + ch.getWayPoint() + &quot; has invalid coords.&quot;);
 			return &quot;&quot;;
 		}
@@ -560,12 +545,12 @@
 			ret.append(&quot;  &lt;/wpt&gt;&quot;).append(newLine);
 		} catch (IllegalArgumentException e) {
 			exportErrors++;
-			ch.checkIncomplete();  // ch.setIncomplete(true);
-			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; check incomplete &quot;,	e, true);
+			ch.checkIncomplete(); // ch.setIncomplete(true);
+			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; check incomplete &quot;, e, true);
 			return &quot;&quot;;
 		} catch (Exception e) {
 			exportErrors++;
-			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; caused &quot;, e,	true);
+			Global.getPref().log(&quot;GPX Export: &quot; + ch.getWayPoint() + &quot; caused &quot;, e, true);
 			return &quot;&quot;;
 		}
 
@@ -574,6 +559,7 @@
 
 	/**
 	 * generate minimal waypoint information according to GPX specification
+	 * 
 	 * @param ch
 	 * @return
 	 */
@@ -581,23 +567,23 @@
 
 		StringBuffer ret = new StringBuffer();
 
-//			.append(&quot;\t\t&lt;desc&gt;@@WPDESC@@&lt;/desc&gt;&quot;).append(newLine)
+		// .append(&quot;\t\t&lt;desc&gt;@@WPDESC@@&lt;/desc&gt;&quot;).append(newLine)
 
-		ret.append(&quot;  &lt;wpt lat=\&quot;&quot;+ch.pos.getLatDeg(CWPoint.DD)+&quot;\&quot; lon=\&quot;&quot;+ch.pos.getLonDeg(CWPoint.DD)+&quot;\&quot;&gt;&quot;).append(newLine);
+		ret.append(&quot;  &lt;wpt lat=\&quot;&quot; + ch.getPos().getLatDeg(CWPoint.DD) + &quot;\&quot; lon=\&quot;&quot; + ch.getPos().getLonDeg(CWPoint.DD) + &quot;\&quot;&gt;&quot;).append(newLine);
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
 			if (ch.isAddiWpt()) {
 				try {
-					ret.append(&quot;    &lt;time&gt;&quot;+ch.mainCache.getDateHidden()+&quot;T07:00:00Z&lt;/time&gt;&quot;).append(newLine);
+					ret.append(&quot;    &lt;time&gt;&quot; + ch.mainCache.getDateHidden() + &quot;T07:00:00Z&lt;/time&gt;&quot;).append(newLine);
 				} catch (Exception e) {
-					Global.getPref().log(ch.getWayPoint() + &quot; has no parent&quot;,null);
+					Global.getPref().log(ch.getWayPoint() + &quot; has no parent&quot;, null);
 					exportErrors++;
 					ret.append(&quot;    &lt;time&gt;1970-01-01T00:00:00&lt;/time&gt;&quot;).append(newLine);
 				}
 			} else if (ch.isCustomWpt()) {
 				ret.append(&quot;    &lt;time&gt;1970-01-01T00:00:00&lt;/time&gt;&quot;).append(newLine);
 			} else {
-				ret.append(&quot;    &lt;time&gt;&quot;+ch.getDateHidden()+&quot;T00:00:00&lt;/time&gt;&quot;).append(newLine);
+				ret.append(&quot;    &lt;time&gt;&quot; + ch.getDateHidden() + &quot;T00:00:00&lt;/time&gt;&quot;).append(newLine);
 			}
 		}
 
@@ -607,13 +593,13 @@
 			} else if (ch.isCustomWpt()) {
 				ret.append(&quot;    &lt;name&gt;&quot;).append(SafeXML.cleanGPX(ch.getWayPoint())).append(&quot;&lt;/name&gt;&quot;).append(newLine);
 			} else {
-				ret.append(&quot;    &lt;name&gt;&quot;).append(SafeXML.cleanGPX(ch.getWayPoint()))
-						.append(&quot; &quot;)
-						.append(CacheType.getExportShortId(ch.getType()))
-						.append(String.valueOf(ch.getHard()))
-						.append(String.valueOf(ch.getTerrain()))
-						.append(CacheSize.getExportShortId(ch.getCacheSize()))
-						.append(String.valueOf(ch.getNoFindLogs()))
+				ret.append(&quot;    &lt;name&gt;&quot;).append(SafeXML.cleanGPX(ch.getWayPoint()))//
+						.append(&quot; &quot;)//
+						.append(CacheType.getExportShortId(ch.getType()))//
+						.append(String.valueOf(ch.getHard()))//
+						.append(String.valueOf(ch.getTerrain()))//
+						.append(CacheSize.getExportShortId(ch.getCacheSize()))//
+						.append(String.valueOf(ch.getNoFindLogs()))//
 						.append(&quot;&lt;/name&gt;&quot;).append(newLine);
 			}
 		} else if (exportIds == WPNAME_NAME_SMART) {
@@ -642,17 +628,17 @@
 		if (ch.isAddiWpt() || ch.isCustomWpt()) {
 			ret.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName())).append(&quot;&lt;/desc&gt;&quot;).append(newLine);
 		} else {
-			ret.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName()))
-					.append(&quot; by &quot;)
-					.append(SafeXML.cleanGPX(ch.getCacheOwner()))
-					.append(&quot;, &quot;)
-					.append(CacheType.type2GSTypeTag(ch.getType()))
-					.append(&quot; (&quot;)
-					.append(CacheTerrDiff.shortDT(ch.getHard()))
-					.append(&quot;/&quot;)
-					.append(CacheTerrDiff.shortDT(ch.getTerrain()))
-					.append(&quot;)&quot;)
-					.append(&quot;&lt;/desc&gt;&quot;).append(newLine);					
+			ret.append(&quot;    &lt;desc&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName()))//
+					.append(&quot; by &quot;)//
+					.append(SafeXML.cleanGPX(ch.getCacheOwner()))//
+					.append(&quot;, &quot;)//
+					.append(CacheType.type2GSTypeTag(ch.getType()))//
+					.append(&quot; (&quot;)//
+					.append(CacheTerrDiff.shortDT(ch.getHard()))//
+					.append(&quot;/&quot;)//
+					.append(CacheTerrDiff.shortDT(ch.getTerrain()))//
+					.append(&quot;)&quot;)//
+					.append(&quot;&lt;/desc&gt;&quot;).append(newLine);
 		}
 
 		if (exportStyle != STYLE_GPX_COMPACT) {
@@ -685,40 +671,47 @@
 
 	/**
 	 * format gc.com extended cache information as found in a PQ
-	 * @param ch cacheholder
-	 * @return formatted cache information for cache waypoints or emty string for all other waypoints (additional / custom)
+	 * 
+	 * @param ch
+	 *            cacheholder
+	 * @return formatted cache information for cache waypoints or emty string for all other waypoints (additional /
+	 *         custom)
 	 */
 	private String formatPqExtensions(CacheHolder ch) {
 
-		// no  details for addis or custom waypoints
+		// no details for addis or custom waypoints
 		if (ch.isCustomWpt() || ch.isAddiWpt())
 			return &quot;&quot;;
 		StringBuffer ret = new StringBuffer();
-		ret.append(&quot;    &lt;groundspeak:cache id=\&quot;&quot;).append(ch.GetCacheID()).append(&quot;\&quot; available=\&quot;&quot;).append(ch.is_available() ? TRUE : FALSE).append(&quot;\&quot; archived=\&quot;&quot;).append(ch.is_archived() ? TRUE : FALSE).append(&quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:name&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName())).append(&quot;&lt;/groundspeak:name&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:placed_by&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:owner id=\&quot;&quot;).append(&quot;31415&quot;).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:owner&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.type2GSTypeTag(ch.getType())).append(&quot;&lt;/groundspeak:type&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(CacheSize.cw2ExportString(ch.getCacheSize())).append(&quot;&lt;/groundspeak:container&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:attributes&gt;&quot;).append(newLine)
-		.append(formatAttributes(ch))
-		.append(&quot;      &lt;/groundspeak:attributes&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getHard())).append(&quot;&lt;/groundspeak:difficulty&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:terrain&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getTerrain())).append(&quot;&lt;/groundspeak:terrain&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:country&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).Country)).append(&quot;&lt;/groundspeak:country&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:state&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).State)).append(&quot;&lt;/groundspeak:state&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:short_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&lt;/groundspeak:short_description&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:long_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(formatLongDescription(ch))).append(&quot;&lt;/groundspeak:long_description&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:encoded_hints&gt;&quot;).append(SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints))).append(&quot;&lt;/groundspeak:encoded_hints&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:logs&gt;&quot;).append(newLine)
-		.append(formatLogs(ch))
-		.append(&quot;      &lt;/groundspeak:logs&gt;&quot;).append(newLine)
-		.append(&quot;      &lt;groundspeak:travelbugs&gt;&quot;).append(newLine)
-		.append(formatTbs(ch))
-		.append(&quot;      &lt;/groundspeak:travelbugs&gt;&quot;).append(newLine)
-		.append(&quot;    &lt;/groundspeak:cache&gt;&quot;).append(newLine);
+		ret.append(&quot;    &lt;groundspeak:cache id=\&quot;&quot;).append(ch.GetCacheID())//
+				.append(&quot;\&quot; available=\&quot;&quot;).append(ch.is_available() ? TRUE : FALSE)//
+				.append(&quot;\&quot; archived=\&quot;&quot;).append(ch.is_archived() ? TRUE : FALSE)//
+				.append(&quot;\&quot; xmlns:groundspeak=\&quot;<A HREF="http://www.groundspeak.com/cache/1/0\">http://www.groundspeak.com/cache/1/0\</A>&quot;&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:name&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheName())).append(&quot;&lt;/groundspeak:name&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:placed_by&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:placed_by&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:owner id=\&quot;&quot;).append(&quot;31415&quot;).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheOwner())).append(&quot;&lt;/groundspeak:owner&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:type&gt;&quot;).append(CacheType.type2GSTypeTag(ch.getType())).append(&quot;&lt;/groundspeak:type&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:container&gt;&quot;).append(CacheSize.cw2ExportString(ch.getCacheSize())).append(&quot;&lt;/groundspeak:container&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:attributes&gt;&quot;).append(newLine)//
+				.append(formatAttributes(ch))//
+				.append(&quot;      &lt;/groundspeak:attributes&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:difficulty&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getHard())).append(&quot;&lt;/groundspeak:difficulty&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:terrain&gt;&quot;).append(CacheTerrDiff.shortDT(ch.getTerrain())).append(&quot;&lt;/groundspeak:terrain&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:country&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).Country)).append(&quot;&lt;/groundspeak:country&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:state&gt;&quot;).append(SafeXML.cleanGPX(ch.getCacheDetails(true).State)).append(&quot;&lt;/groundspeak:state&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:short_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&lt;/groundspeak:short_description&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:long_description html=\&quot;&quot;).append(ch.is_HTML() ? TRUE : FALSE).append(&quot;\&quot;&gt;&quot;).append(SafeXML.cleanGPX(formatLongDescription(ch))).append(&quot;&lt;/groundspeak:long_description&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:encoded_hints&gt;&quot;).append(SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints))).append(&quot;&lt;/groundspeak:encoded_hints&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:logs&gt;&quot;).append(newLine)//
+				.append(formatLogs(ch))//
+				.append(&quot;      &lt;/groundspeak:logs&gt;&quot;).append(newLine)//
+				.append(&quot;      &lt;groundspeak:travelbugs&gt;&quot;).append(newLine)//
+				.append(formatTbs(ch))//
+				.append(&quot;      &lt;/groundspeak:travelbugs&gt;&quot;).append(newLine)//
+				.append(&quot;    &lt;/groundspeak:cache&gt;&quot;).append(newLine);//
 		return ret.toString();
 	}
+
 	/**
 	 * 
 	 */
@@ -726,93 +719,97 @@
 		StringBuffer ret = new StringBuffer();
 		Travelbug Tb;
 		for (int i = 0; i &lt; ch.getCacheDetails(true).Travelbugs.size(); i++) {
-			Tb=ch.getCacheDetails(true).Travelbugs.getTB(i);
-			ret.append(&quot;        &lt;groundspeak:travelbug id=\&quot;&quot;).
-			append(Integer.toString(i)).
-			append(&quot;\&quot; ref=\&quot;TB\&quot;&gt;&quot;).
-			// append(newLine).
-			// append(&quot;          &lt;groundspeak:name&gt;&quot;).
-			append(&quot;&lt;groundspeak:name&gt;&quot;).
-			append(SafeXML.cleanGPX(Tb.getName())).
-			append(&quot;&lt;/groundspeak:name&gt;&quot;).
-			// append(newLine).
-			// append(&quot;        &lt;/groundspeak:travelbug&gt;\r\n&quot;);
-			append(&quot;&lt;/groundspeak:travelbug&gt;\r\n&quot;);
+			Tb = ch.getCacheDetails(true).Travelbugs.getTB(i);
+			ret.append(&quot;        &lt;groundspeak:travelbug id=\&quot;&quot;).//
+					append(Integer.toString(i)).//
+					append(&quot;\&quot; ref=\&quot;TB\&quot;&gt;&quot;).//
+					// append(newLine).//
+					// append(&quot; &lt;groundspeak:name&gt;&quot;).//
+					append(&quot;&lt;groundspeak:name&gt;&quot;).//
+					append(SafeXML.cleanGPX(Tb.getName())).//
+					append(&quot;&lt;/groundspeak:name&gt;&quot;).//
+					// append(newLine).//
+					// append(&quot; &lt;/groundspeak:travelbug&gt;\r\n&quot;);//
+					append(&quot;&lt;/groundspeak:travelbug&gt;\r\n&quot;);//
 		}
 		return ret.toString();
 	}
+
 	/**
 	 * 
 	 */
-	private String formatAttributes(CacheHolder ch){
+	private String formatAttributes(CacheHolder ch) {
 		StringBuffer ret = new StringBuffer();
 		Attribute attrib;
 		for (int i = 0; i &lt; ch.getCacheDetails(true).attributes.count(); i++) {
 			// &lt;groundspeak:attribute id=&quot;X&quot; inc=&quot;Y&quot;&gt;text f&#252;r X&lt;/groundspeak:attribute&gt;
-			attrib=ch.getCacheDetails(true).attributes.getAttribute(i);
-			ret.append(&quot;        &lt;groundspeak:attribute id=\&quot;&quot;).
-			append(attrib.getGCId()).
-			append(&quot;\&quot; inc=\&quot;&quot;).
-			append(attrib.getInc()).
-			append(&quot;\&quot;&gt;&quot;).
-			append(attrib.getGCText()).
-			append(&quot;&lt;/groundspeak:attribute&gt;&quot;).
-			append(newLine);
+			attrib = ch.getCacheDetails(true).attributes.getAttribute(i);
+			if (attrib.getGCId().length() &gt; 0) {
+				ret.append(&quot;        &lt;groundspeak:attribute id=\&quot;&quot;).//
+						append(attrib.getGCId()).//
+						append(&quot;\&quot; inc=\&quot;&quot;).//
+						append(attrib.getInc()).//
+						append(&quot;\&quot;&gt;&quot;).//
+						append(attrib.getGCText()).//
+						append(&quot;&lt;/groundspeak:attribute&gt;&quot;).//
+						append(newLine);//
+			}
 		}
 		return ret.toString();
 	}
+
 	/**
 	 * format cache logs as found in a gc.com GPX file
-	 * @param ch CacheHolder containing the logs
+	 * 
+	 * @param ch
+	 *            CacheHolder containing the logs
 	 * @return formatted logs or empty string if no logs are present
 	 */
 	private String formatLogs(CacheHolder ch) {
-		CacheHolderDetail chD=ch.getCacheDetails(false);
+		CacheHolderDetail chD = ch.getCacheDetails(false);
 		LogList logs = chD.CacheLogs;
 		StringBuffer ret = new StringBuffer();
 		int exportlogs;
-		if (exportStyle == STYLE_GPX_PQLIKE &amp;&amp; maxLogs &lt; logs.size())
-			{exportlogs = maxLogs;}
-		else {exportlogs = logs.size();}
+		if (exportStyle == STYLE_GPX_PQLIKE &amp;&amp; maxLogs &lt; logs.size()) {
+			exportlogs = maxLogs;
+		} else {
+			exportlogs = logs.size();
+		}
 		if (exportStyle == STYLE_GPX_MYFINDS) {
 			// only own log
 			if (chD.OwnLogId.equals(&quot;&quot;) || chD.OwnLog == null) {
-				Global.getPref().log(chD.getParent().getWayPoint()+&quot; missing own LogID&quot;, null);
-				return &quot;&quot;;				
+				Global.getPref().log(chD.getParent().getWayPoint() + &quot; missing own LogID&quot;, null);
+				return &quot;&quot;;
 			}
-			addLog(chD.OwnLogId, chD.OwnLog, finderid ,ret);
-		}
-		else {
+			addLog(chD.OwnLogId, chD.OwnLog, finderid, ret);
+		} else {
 			// add log with attributes
-			if (attrib2Log){
-				addLog (ch.GetCacheID()+Integer.toString(exportlogs), createAttrLog(ch),&quot;&quot;,ret);
+			if (attrib2Log) {
+				addLog(ch.GetCacheID() + Integer.toString(exportlogs), createAttrLog(ch), &quot;&quot;, ret);
 			}
 			for (int i = 0; i &lt; exportlogs; i++) {
-				addLog(ch.GetCacheID()+Integer.toString(i), logs.getLog(i),&quot;&quot; ,ret);
+				addLog(ch.GetCacheID() + Integer.toString(i), logs.getLog(i), &quot;&quot;, ret);
 			}
 		}
 		return ret.toString();
 	}
+
 	private Log createAttrLog(CacheHolder ch) {
 		Attribute attrib;
 		StringBuffer logText = new StringBuffer();
 		for (int i = 0; i &lt; ch.getCacheDetails(true).attributes.count(); i++) {
-			attrib=ch.getCacheDetails(true).attributes.getAttribute(i);
-			logText.append(attrib.getInc()==1?&quot;Yes: &quot;:&quot;No: &quot;).
-			append(attrib.getMsg()).
-			append(&quot;&lt;br /&gt;&quot;).
-			append(newLine);
+			attrib = ch.getCacheDetails(true).attributes.getAttribute(i);
+			logText.append(attrib.getInc() == 1 ? &quot;Yes: &quot; : &quot;No: &quot;).append(attrib.getMsg()).append(&quot;&lt;br /&gt;&quot;).append(newLine);
 		}
 		if (ch.hasNote()) {
-			logText.append(SafeXML.cleanGPX(ch.getCacheDetails(true).getCacheNotes())).
-			append(&quot;&lt;br /&gt;&quot;).
-			append(newLine);
+			logText.append(SafeXML.cleanGPX(ch.getCacheDetails(true).getCacheNotes())).append(&quot;&lt;br /&gt;&quot;).append(newLine);
 		}
-		if (logText.length() == 0 &amp;&amp; !ch.getLastSync().equals(&quot;&quot;)) logText.append(MyLocale.getMsg(1051,&quot;Last sync date&quot;));
+		if (logText.length() == 0 &amp;&amp; !ch.getLastSync().equals(&quot;&quot;))
+			logText.append(MyLocale.getMsg(1051, &quot;Last sync date&quot;));
 		Log log = new Log(&quot;icon_note.gif&quot;, DateFormat.yyyyMMddHHmmss2gpxLogdate(ch.getLastSync()), &quot;CacheWolf&quot;, logText.toString());
 		return log;
 	}
-	
+
 	private StringBuffer addLog(String logId, Log log, String FinderID, StringBuffer ret) {
 		Transformer trans = new Transformer(true);
 		trans.add(new Regex(&quot;@@LOGID@@&quot;, logId));
@@ -828,29 +825,35 @@
 
 	/**
 	 * format the header of the GPX file
+	 * 
 	 * @return
 	 */
 	private String formatHeader() {
-		//FIXME: extend profile to add &lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot; maxlon=\&quot;6.918817\&quot; /&gt;
-		//Global.getProfile().getSourroundingArea(false);
+		// FIXME: extend profile to add &lt;bounds minlat=\&quot;50.91695\&quot; minlon=\&quot;6.876383\&quot; maxlat=\&quot;50.935183\&quot;
+		// maxlon=\&quot;6.918817\&quot; /&gt;
+		// Global.getProfile().getSourroundingArea(false);
 		Transformer trans = new Transformer(true);
 		trans.add(new Regex(&quot;@@CREATEDATE@@&quot;, new Date().setToCurrentTime().setFormat(&quot;yyyy-MM-dd&quot;).toString()));
-		if (exportStyle==STYLE_GPX_MYFINDS)
-			 {trans.add(new Regex(&quot;@@NAME@@&quot;,&quot;My Finds Pocket Query&quot;));}
-		else {trans.add(new Regex(&quot;@@NAME@@&quot;,&quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;));}
+		if (exportStyle == STYLE_GPX_MYFINDS) {
+			trans.add(new Regex(&quot;@@NAME@@&quot;, &quot;My Finds Pocket Query&quot;));
+		} else {
+			trans.add(new Regex(&quot;@@NAME@@&quot;, &quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;));
+		}
 		return trans.replaceFirst(GPXHEADER);
 		/*
-		String ret = STRreplace.replace(GPXHEADER,&quot;@@CREATEDATE@@&quot;, new Date().setToCurrentTime().setFormat(&quot;yyyy-MM-dd&quot;).toString());
-		if (exportStyle==STYLE_GPX_MYFINDS)
-			 { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;My Finds Pocket Query&quot;);}
-		else { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;);}
-		return ret;
-		*/
+		 * String ret = STRreplace.replace(GPXHEADER,&quot;@@CREATEDATE@@&quot;, new Date().setToCurrentTime().setFormat(&quot;yyyy-MM-dd&quot;).toString());
+		 * if (exportStyle==STYLE_GPX_MYFINDS)
+		 * { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;My Finds Pocket Query&quot;);}
+		 * else { ret=STRreplace.replace(ret,&quot;@@NAME@@&quot;,&quot;Waypoints for Cache Listings, Generated by CacheWolf&quot;);}
+		 * return ret;
+		 */
 	}
 
 	/**
 	 * format a long description as found in the gc.com GPX files
-	 * @param ch CacheHolder to format
+	 * 
+	 * @param ch
+	 *            CacheHolder to format
 	 * @return formatted output
 	 */
 	private String formatLongDescription(CacheHolder ch) {
@@ -881,9 +884,9 @@
 					trans.add(new Regex(&quot;@@ADDIID@@&quot;, addi.getWayPoint()));
 					trans.add(new Regex(&quot;@@ADDISHORT@@&quot;, addi.getCacheName()));
 					trans.add(new Regex(&quot;@@ADDIDELIM@@&quot;, delim));
-					trans.add(new Regex(&quot;@@ADDILAT@@&quot;,formatAddiLatLon(addi.pos)));
+					trans.add(new Regex(&quot;@@ADDILAT@@&quot;, formatAddiLatLon(addi.getPos())));
 					trans.add(new Regex(&quot;@@ADDILON@@&quot;, &quot;&quot;));
-					trans.add(new Regex(&quot;@@ADDILONG@@&quot;,addi.getCacheDetails(true).LongDescription));
+					trans.add(new Regex(&quot;@@ADDILONG@@&quot;, addi.getCacheDetails(true).LongDescription));
 					ret.append(trans.replaceAll(GPXADDIINMAIN));
 				}
 				ret.append(delim).append(newLine);
@@ -894,11 +897,10 @@
 
 	/**
 	 * create a position information suitable for a gc.com PQlike export
-	 *
+	 * 
 	 * @param pos
 	 *            position
-	 * @return if position is valid return the cachewolf formatted position,
-	 *         otherwise return teh string used in PQs
+	 * @return if position is valid return the cachewolf formatted position, otherwise return teh string used in PQs
 	 */
 	private String formatAddiLatLon(CWPoint pos) {
 		if (pos.isValid()) {
@@ -910,6 +912,7 @@
 
 	/**
 	 * copy the bitmap identified by &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; from &lt;code&gt;poiZip&lt;/code&gt; to &lt;code&gt;outdir&lt;/code&gt;
+	 * 
 	 * @param outdir
 	 * @param type
 	 * @param prefix
@@ -928,7 +931,7 @@
 
 			buff = new byte[icon.getSize()];
 			InputStream fis = poiZip.getInputStream(icon);
-			FileOutputStream fos = new FileOutputStream(outdir+(FileBase.separator)+prefix+type+&quot;.bmp&quot;);
+			FileOutputStream fos = new FileOutputStream(outdir + (FileBase.separator) + prefix + type + &quot;.bmp&quot;);
 			while (0 &lt; (len = fis.read(buff)))
 				fos.write(buff, 0, len);
 			fos.flush();
@@ -946,28 +949,31 @@
 
 	/**
 	 * Execute the command defined by cmd
-	 * @param cmd command and options to execute. if command or options include a space quatation marks are added. this will not wirk with the java version on unix systems
+	 * 
+	 * @param cmd
+	 *            command and options to execute. if command or options include a space quatation marks are added. this
+	 *            will not wirk with the java version on unix systems
 	 * @return a handle to the process on success or null otherwise
 	 */
 	Process startProcess(String[] cmd) {
 		String command = &quot;&quot;;
 		if (cmd.length == 0) {
 			exportErrors++;
-			Global.getPref().log(&quot;GPX Export: empty gpsbabel command&quot;,null);
+			Global.getPref().log(&quot;GPX Export: empty gpsbabel command&quot;, null);
 			return null;
 		}
 
 		for (int i = 0; i &lt; cmd.length; i++) {
 			if (cmd[i].indexOf(&quot; &quot;) &gt; -1) {
-				cmd[i]=&quot;\&quot;&quot;+cmd[i]+&quot;\&quot;&quot;;
+				cmd[i] = &quot;\&quot;&quot; + cmd[i] + &quot;\&quot;&quot;;
 			}
-			command = command+cmd[i]+&quot; &quot;;
+			command = command + cmd[i] + &quot; &quot;;
 		}
 
 		try {
 			return Vm.exec(command);
 		} catch (IOException e) {
-			Global.getPref().log(&quot;error excuting &quot;+command, e, true);
+			Global.getPref().log(&quot;error excuting &quot; + command, e, true);
 			exportErrors++;
 			return null;
 		}
@@ -1005,32 +1011,32 @@
 			this.setTitle(&quot;GPX Export&quot;);
 			this.resizable = false;
 
-			btnOk = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
-			btnCancel = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+			btnOk = new mButton(MyLocale.getMsg(1605, &quot;OK&quot;));
+			btnCancel = new mButton(MyLocale.getMsg(1604, &quot;Cancel&quot;));
 
 			chIds = new mChoice();
 			chIds.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chIds.addItem(MyLocale.getMsg(31415,&quot;Classic IDs&quot;)); // index 0
-			chIds.addItem(MyLocale.getMsg(31415,&quot;Smart IDs&quot;)); // index 1
-//			chIds.addItem(MyLocale.getMsg(31415,&quot;Smart Names&quot;)); // index 2
+			chIds.addItem(MyLocale.getMsg(31415, &quot;Classic IDs&quot;)); // index 0
+			chIds.addItem(MyLocale.getMsg(31415, &quot;Smart IDs&quot;)); // index 1
+			// chIds.addItem(MyLocale.getMsg(31415,&quot;Smart Names&quot;)); // index 2
 			chIds.select(chosenIds);
 
 			chStyle = new mChoice();
 			chStyle.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chStyle.addItem(MyLocale.getMsg(31415,&quot;Compact&quot;)); // index 0
-			chStyle.addItem(MyLocale.getMsg(31415,&quot;PQ like&quot;)); // index 1
-			chStyle.addItem(MyLocale.getMsg(31415,&quot;MyFinds&quot;)); // index 2
+			chStyle.addItem(MyLocale.getMsg(31415, &quot;Compact&quot;)); // index 0
+			chStyle.addItem(MyLocale.getMsg(31415, &quot;PQ like&quot;)); // index 1
+			chStyle.addItem(MyLocale.getMsg(31415, &quot;MyFinds&quot;)); // index 2
 			chStyle.select(chosenStyle);
 
 			chTarget = new mChoice();
 			chTarget.dontSearchForKeys = true;
 			// if you change the order of strings make sure to fix the event handler as well
-			chTarget.addItem(MyLocale.getMsg(31415,&quot;Single GPX&quot;)); // index 0
-			chTarget.addItem(MyLocale.getMsg(31415,&quot;Separate GPX&quot;)); // index 1
+			chTarget.addItem(MyLocale.getMsg(31415, &quot;Single GPX&quot;)); // index 0
+			chTarget.addItem(MyLocale.getMsg(31415, &quot;Separate GPX&quot;)); // index 1
 			if (hasBitmaps &amp;&amp; hasGarminMap &amp;&amp; hasGpsbabel) {
-				chTarget.addItem(MyLocale.getMsg(31415,&quot;POI&quot;)); // index 2
+				chTarget.addItem(MyLocale.getMsg(31415, &quot;POI&quot;)); // index 2
 			}
 			chTarget.select(chosenTarget);
 
@@ -1040,39 +1046,41 @@
 			ibMaxLogs = new mInput(String.valueOf(Global.getPref().numberOfLogsToExport));
 			ibMaxLogs.modify(ControlConstants.Disabled, 0);
 
-			cbSeperateHints = new mCheckBox(MyLocale.getMsg(31415,&quot;Separate Hints&quot;));
+			cbSeperateHints = new mCheckBox(MyLocale.getMsg(31415, &quot;Separate Hints&quot;));
 			cbSeperateHints.modify(ControlConstants.Disabled, 0);
 
-			cbSendToGarmin = new mCheckBox(MyLocale.getMsg(31415,&quot;send to Garmin&quot;));
-			if (!hasGpsbabel) cbSendToGarmin.modify(ControlConstants.Disabled, 0);
+			cbSendToGarmin = new mCheckBox(MyLocale.getMsg(31415, &quot;send to Garmin&quot;));
+			if (!hasGpsbabel)
+				cbSendToGarmin.modify(ControlConstants.Disabled, 0);
 
-			cbCustomIcons = new mCheckBox(MyLocale.getMsg(31415,&quot;Custom Icons&quot;));
-			if (!hasGarminMap) cbCustomIcons.modify(ControlConstants.Disabled, 0);
+			cbCustomIcons = new mCheckBox(MyLocale.getMsg(31415, &quot;Custom Icons&quot;));
+			if (!hasGarminMap)
+				cbCustomIcons.modify(ControlConstants.Disabled, 0);
 
-			cbAttrib2Log = new mCheckBox(MyLocale.getMsg(31415,&quot;Attrib.-&gt;Log&quot;));
-			
-			addNext(new mLabel(MyLocale.getMsg(31415,&quot;GPX Style&quot;)));
+			cbAttrib2Log = new mCheckBox(MyLocale.getMsg(31415, &quot;Attrib.-&gt;Log&quot;));
+
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;GPX Style&quot;)));
 			addLast(chStyle);
 
-			addNext(new mLabel(MyLocale.getMsg(31415,&quot;WP Names&quot;)));
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;WP Names&quot;)));
 			addLast(chIds);
 
-			addNext(new mLabel(MyLocale.getMsg(31415,&quot;Output&quot;)));
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;Output&quot;)));
 			addLast(chTarget);
 
 			addNext(cbCustomIcons);
 			addLast(cbSendToGarmin);
 
-//			addLast(cbSeperateHints);
+			// addLast(cbSeperateHints);
 
-            addNext(new mLabel(MyLocale.getMsg(31415,&quot;Prefix&quot;)));
-            addLast(ibPrefix);
-            
-            addLast(cbAttrib2Log);
-            
-            addNext(new mLabel(MyLocale.getMsg(31415,&quot;Max Logs&quot;)));
-            addLast(ibMaxLogs);
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;Prefix&quot;)));
+			addLast(ibPrefix);
 
+			addLast(cbAttrib2Log);
+
+			addNext(new mLabel(MyLocale.getMsg(31415, &quot;Max Logs&quot;)));
+			addLast(ibMaxLogs);
+
 			addButton(btnOk);
 			addButton(btnCancel);
 
@@ -1080,10 +1088,9 @@
 			checkTarget();
 			checkIds();
 		}
-		
+
 		/**
-		 * in  : chStyle.selectedIndex;
-		 * out : chosenStyle
+		 * in : chStyle.selectedIndex; out : chosenStyle
 		 */
 		private void checkStyle() {
 			if (chStyle.selectedIndex == 2) { // my finds export
@@ -1112,7 +1119,7 @@
 				cbAttrib2Log.state = false;
 				if (cbAttrib2Log.change(ControlConstants.Disabled, 0))
 					cbAttrib2Log.repaint();
-				
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1138,7 +1145,7 @@
 
 				if (cbAttrib2Log.change(0, ControlConstants.Disabled))
 					cbAttrib2Log.repaint();
-				
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1163,7 +1170,7 @@
 
 				if (cbAttrib2Log.change(ControlConstants.Disabled, 0))
 					cbAttrib2Log.repaint();
-		
+
 				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
@@ -1177,8 +1184,7 @@
 		}
 
 		/**
-		 * in : chTarget.selectedIndex
-		 * out: chosenTarget
+		 * in : chTarget.selectedIndex out: chosenTarget
 		 */
 		private void checkTarget() {
 			if (chTarget.selectedIndex == 2) { // POI
@@ -1215,7 +1221,7 @@
 				if (hasGarminMapFrm &amp;&amp; cbCustomIcons.change(0, ControlConstants.Disabled))
 					cbCustomIcons.repaint();
 
-				cbSeperateHints.state=false;
+				cbSeperateHints.state = false;
 				if (cbSeperateHints.change(ControlConstants.Disabled, 0))
 					cbSeperateHints.repaint();
 
@@ -1232,10 +1238,10 @@
 			chosenTarget = chTarget.selectedIndex;
 			chosenIds = chIds.selectedIndex;
 		}
-		
+
 		/**
-		 * react to GUI events and toogle access to the checkboxes according to
-		 * radio button settings pass everything else to &lt;code&gt;super()&lt;/code&gt;
+		 * react to GUI events and toogle access to the checkboxes according to radio button settings pass everything
+		 * else to &lt;code&gt;super()&lt;/code&gt;
 		 */
 		public void onEvent(Event ev) {
 			if (ev instanceof DataChangeEvent &amp;&amp; ev.type == DataChangeEvent.DATA_CHANGED) {
@@ -1279,14 +1285,16 @@
 
 		/**
 		 * amount of data to be exported
+		 * 
 		 * @return 0 Compact, 1 PQ like, 2 MyFinds
 		 */
-		private int getExportStyle () {
+		private int getExportStyle() {
 			return chosenStyle;
 		}
 
 		/**
 		 * style of waypoint identifiers
+		 * 
 		 * @return 0 Classic IDs, 1 Smart IDs, 3 Smart Names (should only be used with gpsbabel)
 		 */
 		private int getWpNameStyle() {
@@ -1295,6 +1303,7 @@
 
 		/**
 		 * what kind of output should be generated
+		 * 
 		 * @return 0 single file, 1 separate files, 2 POI (GPI) files
 		 */
 		private int getOutputTarget() {
@@ -1303,7 +1312,7 @@
 
 		/**
 		 * check if user wants to send output straight to a Garmin GPSr
-		 *
+		 * 
 		 * @return true for GPSr transfer, false otherwise
 		 */
 		private boolean getSendToGarmin() {
@@ -1312,7 +1321,7 @@
 
 		/**
 		 * check if user wants custom icons
-		 *
+		 * 
 		 * @return true if user wants custom icons, false otherwise
 		 */
 		private boolean getCustomIcons() {
@@ -1321,7 +1330,7 @@
 
 		/**
 		 * get the number of logs to export. used in PQlike export.
-		 *
+		 * 
 		 * @return number of logs to export
 		 */
 		private int getMaxLogs() {
@@ -1330,19 +1339,19 @@
 
 		/**
 		 * get prefix for separate file export
-		 *
+		 * 
 		 * @return prefix for separate file export
 		 */
 		private String getPrefix() {
 			return ibPrefix.getText();
 		}
-		
+
 		/**
 		 * check if user wants to export attributes as log
 		 * 
 		 * @return true if attributes should exported as log, false otherwise
 		 */
-		private boolean getAttrib2Log (){
+		private boolean getAttrib2Log() {
 			return cbAttrib2Log.state;
 		}
 	}

Modified: branches/r1.2/src/CacheWolf/exp/KMLExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/KMLExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/KMLExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -45,49 +45,40 @@
 import ewe.ui.ProgressBarForm;
 import ewe.util.Hashtable;
 import ewe.util.Iterator;
+import ewe.util.Map.MapEntry;
 import ewe.util.Vector;
-import ewe.util.Map.MapEntry;
 import ewe.util.zip.ZipEntry;
 import ewe.util.zip.ZipException;
 import ewe.util.zip.ZipFile;
 
 /**
-*	Class to export the cache database (index) to an KML-File
-*	which can be read by Google Earth
-*
-*/
+ * Class to export the cache database (index) to an KML-File
+ * which can be read by Google Earth
+ * 
+ */
 public class KMLExporter extends Exporter {
 	private static final String COLOR_FOUND = &quot;ff98fb98&quot;;
 	private static final String COLOR_OWNED = &quot;ffffaa55&quot;;
 	private static final String COLOR_AVAILABLE = &quot;ffffffff&quot;;
 	private static final String COLOR_NOT_AVAILABLE = &quot;ff0000ff&quot;;
 
-
 	static final int AVAILABLE = 0;
 	static final int FOUND = 1;
 	static final int OWNED = 2;
 	static final int NOT_AVAILABLE = 3;
 	static final int UNKNOWN = 4;
 
-
-	String []categoryNames = {&quot;Available&quot;,&quot;Found&quot;, &quot;Owned&quot;, &quot;Not Available&quot;, &quot;UNKNOWN&quot;};
-	Hashtable [] outCacheDB = new Hashtable[categoryNames.length];
+	String[] categoryNames = { &quot;Available&quot;, &quot;Found&quot;, &quot;Owned&quot;, &quot;Not Available&quot;, &quot;UNKNOWN&quot; };
+	Hashtable[] outCacheDB = new Hashtable[categoryNames.length];
 	private Profile prof;
 
-	public KMLExporter(){
+	public KMLExporter(Preferences p, Profile _prof) {
 		super();
 		this.setMask(&quot;*.kml&quot;);
-		this.setHowManyParams(LAT_LON);
+		prof = _prof;
 	}
 
-
-	public KMLExporter(Preferences p, Profile _prof){
-			super();
-			this.setMask(&quot;*.kml&quot;);
-			prof=_prof;
-	}
-
-	public void doIt(int variant){
+	public void doIt(int variant) {
 		File outFile;
 		String str;
 		CacheHolder ch;
@@ -97,13 +88,14 @@
 
 		if (variant == ASK_FILE) {
 			outFile = getOutputFile();
-			if (outFile == null) return;
+			if (outFile == null)
+				return;
 		} else {
 			outFile = new File(tmpFileName);
 		}
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.setTask(h, &quot;Exporting ...&quot;);
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
@@ -111,51 +103,55 @@
 		copyIcons(outFile.getParent());
 		buildOutDB();
 
-		try{
-			PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
-			str = STRreplace.replace(this.header(),&quot;CacheWolf&quot;,prof.name);
-			if (str != null) outp.print(str);
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));
+			str = STRreplace.replace(this.header(), &quot;CacheWolf&quot;, prof.name);
+			if (str != null)
+				outp.print(str);
 			for (int cat = 0; cat &lt; categoryNames.length; cat++) {
 				// skip over empty categories
-				if (outCacheDB[cat]==null) continue;
+				if (outCacheDB[cat] == null)
+					continue;
 
 				Iterator outLoop = outCacheDB[cat].entries();
 				outp.print(startFolder(categoryNames[cat]));
 
 				Vector tmp;
 				MapEntry entry;
-				while (outLoop.hasNext()){
+				while (outLoop.hasNext()) {
 					entry = (MapEntry) outLoop.next();
-					tmp = (Vector)entry.getValue();
+					tmp = (Vector) entry.getValue();
 					// skip over empty cachetypes
-					if (tmp.size() == 0) continue;
+					if (tmp.size() == 0)
+						continue;
 					outp.print(startFolder(CacheType.type2Gui(Integer.valueOf(entry.getKey().toString()).byteValue())));
 
-					for(int i = 0; i&lt;tmp.size(); i++){
+					for (int i = 0; i &lt; tmp.size(); i++) {
 						ch = (CacheHolder) tmp.get(i);
-						if (ch.isAddiWpt()) continue;
+						if (ch.isAddiWpt())
+							continue;
 						expCount++;
-						h.progress = (float)expCount/(float)counter;
+						h.progress = (float) expCount / (float) counter;
 						h.changed();
 
-						if (ch.pos.isValid()){
-							str = record(ch, ch.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-								     ch.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
-							if (str != null) outp.print(str);
+						if (ch.getPos().isValid()) {
+							str = record(ch, ch.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), ch.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+							if (str != null)
+								outp.print(str);
 						}
-						if (ch.hasAddiWpt()){
+						if (ch.hasAddiWpt()) {
 							boolean createdAdditionalWaypointsFolder = false;
-							for(int j = 0; j&lt;ch.addiWpts.size(); j++){
+							for (int j = 0; j &lt; ch.addiWpts.size(); j++) {
 								addiWpt = (CacheHolder) ch.addiWpts.get(j);
 								expCount++;
-								if (ch.pos.isValid() &amp;&amp;  addiWpt.isVisible()){
-									if (! createdAdditionalWaypointsFolder) {
+								if (ch.getPos().isValid() &amp;&amp; addiWpt.isVisible()) {
+									if (!createdAdditionalWaypointsFolder) {
 										outp.print(startFolder(&quot;Additional Waypoints&quot;, false));
 										createdAdditionalWaypointsFolder = true;
 									}
-									str = record(addiWpt, addiWpt.pos.getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator),
-											addiWpt.pos.getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
-									if (str != null) outp.print(str);
+									str = record(addiWpt, addiWpt.getPos().getLatDeg(CWPoint.DD).replace('.', this.decimalSeparator), addiWpt.getPos().getLonDeg(CWPoint.DD).replace('.', this.decimalSeparator));
+									if (str != null)
+										outp.print(str);
 								}
 
 							}
@@ -170,17 +166,18 @@
 			}
 
 			str = trailer();
-			if (str != null) outp.print(str);
+			if (str != null)
+				outp.print(str);
 			outp.close();
 			pbf.exit(0);
-		} catch (IOException ioE){
-			pref.log(&quot;Error opening &quot; + outFile.getName(),ioE);
+		} catch (IOException ioE) {
+			pref.log(&quot;Error opening &quot; + outFile.getName(), ioE);
 		}
-		//try
+		// try
 
 	}
 
-	private void buildOutDB(){
+	private void buildOutDB() {
 		CacheHolder ch;
 		Vector tmp;
 		Iterator categoryLoop;
@@ -197,49 +194,54 @@
 		}
 
 		// fill structure with data from cacheDB
-		for(int i = 0; i&lt;cacheDB.size(); i++){
-			ch=cacheDB.get(i);
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
+			ch = cacheDB.get(i);
 			// TODO Das Argument nach STring zu casten gef&#239;&#191;&#189;llt mir nicht ganz...
-			if(ch.isVisible() &amp;&amp; !ch.isAddiWpt()){
-				if (ch.is_found()) { tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));}
-				else if (ch.is_owned()) { tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));}
-				else if (ch.is_archived() || !ch.is_available()){ tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.getType()));}
-				else if (ch.is_available()){ tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.getType()));}
-				else { tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.getType()));}
-
+			if (ch.isVisible() &amp;&amp; !ch.isAddiWpt()) {
+				if (ch.is_found()) {
+					tmp = (Vector) outCacheDB[FOUND].get(String.valueOf(ch.getType()));
+				} else if (ch.is_owned()) {
+					tmp = (Vector) outCacheDB[OWNED].get(String.valueOf(ch.getType()));
+				} else if (ch.is_archived() || !ch.is_available()) {
+					tmp = (Vector) outCacheDB[NOT_AVAILABLE].get(String.valueOf(ch.getType()));
+				} else if (ch.is_available()) {
+					tmp = (Vector) outCacheDB[AVAILABLE].get(String.valueOf(ch.getType()));
+				} else {
+					tmp = (Vector) outCacheDB[UNKNOWN].get(String.valueOf(ch.getType()));
+				}
 				tmp.add(ch);
 			}
 		}
 
-		//eleminate empty categories
+		// eleminate empty categories
 		for (int i = 0; i &lt; categoryNames.length; i++) {
 			categoryLoop = outCacheDB[i].entries();
 			foundOne = false;
-			//look if all vectors for cachetypes are filled
-			while (categoryLoop.hasNext()){
+			// look if all vectors for cachetypes are filled
+			while (categoryLoop.hasNext()) {
 				entry = (MapEntry) categoryLoop.next();
-				tmp = (Vector)entry.getValue();
-				if (tmp.size()&gt; 0){
+				tmp = (Vector) entry.getValue();
+				if (tmp.size() &gt; 0) {
 					foundOne = true;
 					break;
 				}
 			}
 			// set hashtable for that category to null
-			if (!foundOne)outCacheDB[i] = null;
+			if (!foundOne)
+				outCacheDB[i] = null;
 		}
 
-
 	}
 
-	private String startFolder(String name){
+	private String startFolder(String name) {
 		return startFolder(name, true);
 	}
 
-	private String startFolder(String name, boolean open){
+	private String startFolder(String name, boolean open) {
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append(&quot;&lt;Folder&gt;\r\n&quot;);
 		strBuf.append(&quot;&lt;name&gt;&quot; + name + &quot;&lt;/name&gt;\r\n&quot;);
-		strBuf.append(&quot;&lt;open&gt;&quot; + (open?&quot;1&quot;:&quot;0&quot;) + &quot;&lt;/open&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;open&gt;&quot; + (open ? &quot;1&quot; : &quot;0&quot;) + &quot;&lt;/open&gt;\r\n&quot;);
 
 		return strBuf.toString();
 	}
@@ -249,15 +251,15 @@
 		return &quot;&lt;/Folder&gt;\r\n&quot;;
 	}
 
-	public void copyIcons(String dir){
-		ZipFile zif=null;
+	public void copyIcons(String dir) {
+		ZipFile zif = null;
 		try {
-			zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;GoogleEarth.zip&quot;);
+			zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;GoogleEarth.zip&quot;);
 		} catch (IOException e) {
 		}
 		try {
-      if (zif == null) {
-			  zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;GoogleEarth.zip&quot;);
+			if (zif == null) {
+				zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;GoogleEarth.zip&quot;);
 			}
 			ZipEntry zipEnt;
 			int len;
@@ -266,27 +268,29 @@
 			for (int i = 0; i &lt; CacheType.guiTypeStrings().length; i++) {
 				fileName = CacheType.typeImageForId(CacheType.guiSelect2Cw(i));
 				zipEnt = zif.getEntry(fileName);
-				if (zipEnt == null) continue;
-			    byte[] buff = new byte[ zipEnt.getSize() ];
-			    InputStream  fis = zif.getInputStream(zipEnt);
-			    FileOutputStream fos = new FileOutputStream( dir + &quot;/&quot; + fileName);
-			    while( 0 &lt; (len = fis.read( buff )) )
-			      fos.write( buff, 0, len );
-			    fos.flush();
-			    fos.close();
-			    fis.close();
+				if (zipEnt == null)
+					continue;
+				byte[] buff = new byte[zipEnt.getSize()];
+				InputStream fis = zif.getInputStream(zipEnt);
+				FileOutputStream fos = new FileOutputStream(dir + &quot;/&quot; + fileName);
+				while (0 &lt; (len = fis.read(buff)))
+					fos.write(buff, 0, len);
+				fos.flush();
+				fos.close();
+				fis.close();
 			}
 
-			} catch (ZipException e) {
-				pref.log(&quot;Problem copying Icon&quot;,e,true);
-			} catch (IOException e) {
-				pref.log(&quot;Problem copying Icon&quot;,e,true);
-			}
+		} catch (ZipException e) {
+			pref.log(&quot;Problem copying Icon&quot;, e, true);
+		} catch (IOException e) {
+			pref.log(&quot;Problem copying Icon&quot;, e, true);
+		}
 	}
 
+	StringBuffer strBuf = new StringBuffer(200);
 
-	public String header () {
-		StringBuffer strBuf = new StringBuffer(200);
+	public String header() {
+		strBuf.setLength(0);
 
 		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\r\n&quot;);
 		strBuf.append(&quot;&lt;kml xmlns=\&quot;<A HREF="http://earth.google.com/kml/2.0\">http://earth.google.com/kml/2.0\</A>&quot;&gt;\r\n&quot;);
@@ -297,29 +301,28 @@
 		return strBuf.toString();
 	}
 
-
-	public String record(CacheHolder ch, String lat, String lon){
-		StringBuffer strBuf = new StringBuffer(200);
+	public String record(CacheHolder ch, String lat, String lon) {
+		strBuf.setLength(0);
 		CacheHolderDetail det = ch.getCacheDetails(true);
 
 		strBuf.append(&quot;   &lt;Placemark&gt;\r\n&quot;);
-		if (det.URL != null){
-			strBuf.append(&quot;      &lt;description&gt;&quot;+SafeXML.clean(det.URL)+&quot;&lt;/description&gt;\r\n&quot;);
+		if (det.URL != null) {
+			strBuf.append(&quot;      &lt;description&gt;&quot; + SafeXML.clean(det.URL) + &quot;&lt;/description&gt;\r\n&quot;);
 		}
-		strBuf.append(&quot;      &lt;name&gt;&quot;+ ch.getWayPoint() + &quot; - &quot; + SafeXML.clean(ch.getCacheName()) +&quot;&lt;/name&gt;\r\n&quot;);
+		strBuf.append(&quot;      &lt;name&gt;&quot; + ch.getWayPoint() + &quot; - &quot; + SafeXML.clean(ch.getCacheName()) + &quot;&lt;/name&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;LookAt&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;latitude&gt;&quot; + lat + &quot;&lt;/latitude&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;longitude&gt;&quot; + lon + &quot;&lt;/longitude&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;range&gt;10000&lt;/range&gt;&lt;tilt&gt;0&lt;/tilt&gt;&lt;heading&gt;0&lt;/heading&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;/LookAt&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;Point&gt;\r\n&quot;);
-		strBuf.append(&quot;         &lt;coordinates&gt;&quot;  + lon + &quot;,&quot; + lat + &quot;&lt;/coordinates&gt;\r\n&quot;);
+		strBuf.append(&quot;         &lt;coordinates&gt;&quot; + lon + &quot;,&quot; + lat + &quot;&lt;/coordinates&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;/Point&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;Style&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;IconStyle&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;Icon&gt;\r\n&quot;);
-//		strBuf.append(&quot;            &lt;href&gt;&quot;+ File.getProgramDirectory()+ &quot;/&quot; + CacheType.type2pic(Convert.parseInt(ch.type))+ &quot;&lt;/href&gt;\r\n&quot;);
-		strBuf.append(&quot;            &lt;href&gt;&quot;+ CacheType.typeImageForId(ch.getType())+ &quot;&lt;/href&gt;\r\n&quot;);
+		// strBuf.append(&quot;            &lt;href&gt;&quot;+ File.getProgramDirectory()+ &quot;/&quot; + CacheType.type2pic(Convert.parseInt(ch.type))+ &quot;&lt;/href&gt;\r\n&quot;);
+		strBuf.append(&quot;            &lt;href&gt;&quot; + CacheType.typeImageForId(ch.getType()) + &quot;&lt;/href&gt;\r\n&quot;);
 		strBuf.append(&quot;         &lt;/Icon&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;/IconStyle&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;LabelStyle&gt;\r\n&quot;);
@@ -331,8 +334,8 @@
 		return strBuf.toString();
 	}
 
-	public String trailer(){
-		StringBuffer strBuf = new StringBuffer(50);
+	public String trailer() {
+		strBuf.setLength(0);
 
 		strBuf.append(&quot;&lt;/Folder&gt;\r\n&quot;);
 		strBuf.append(&quot;&lt;/kml&gt;\r\n&quot;);
@@ -340,10 +343,13 @@
 		return strBuf.toString();
 	}
 
-	private String getColor(CacheHolder ch){
-		if (ch.is_found()) return COLOR_FOUND;
-		if (ch.is_owned()) return COLOR_OWNED;
-		if (ch.is_archived() || !ch.is_available()) return COLOR_NOT_AVAILABLE;
+	private String getColor(CacheHolder ch) {
+		if (ch.is_found())
+			return COLOR_FOUND;
+		if (ch.is_owned())
+			return COLOR_OWNED;
+		if (ch.is_archived() || !ch.is_available())
+			return COLOR_NOT_AVAILABLE;
 
 		return COLOR_AVAILABLE;
 	}

Modified: branches/r1.2/src/CacheWolf/exp/LocExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/LocExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/LocExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,104 +1,106 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CWPoint;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheHolderDetail;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import ewe.io.File;
-import ewe.io.FileBase;
 
-
 /**
-*	Class to export the cache database into an geocaching .loc file that may be exported
-*	by GPSBabel to a Garmin GPS.
-*
-*	Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
-*/
-public class LocExporter extends Exporter{
+ * Class to export the cache database into an geocaching .loc file that may be exported
+ * by GPSBabel to a Garmin GPS.
+ * 
+ * Now includes mapping of cachetypes to user defined icons (as defined in file garminmap.xml).
+ */
+public class LocExporter extends Exporter {
 	public static int MODE_AUTO = TMP_FILE;
 	/**
 	 * Defines how certain cachetypes are mapped to user icons
 	 */
-	private static GarminMap gm=null;
+	private static GarminMap gm = null;
 
-	public LocExporter(){
+	public LocExporter() {
 		super();
 		this.setMask(&quot;*.loc&quot;);
 		this.setHowManyParams(NO_PARAMS);
 		if (Global.getPref().addDetailsToName) {
 			this.setNeedCacheDetails(true);
 		}
-		gm=new GarminMap();
+		gm = new GarminMap();
 	}
 
-	public String header () {
+	public String header() {
 		return &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;loc version=\&quot;1.0\&quot; src=\&quot;EasyGPS\&quot;&gt;\r\n&quot;;
 	}
 
-	public String record(CacheHolder ch){
+	public String record(CacheHolder ch) {
 
 		// filter out not valid coords
-		if (!ch.pos.isValid()) return null;
+		if (!ch.getPos().isValid())
+			return null;
 		StringBuffer strBuf = new StringBuffer(200);
 		strBuf.append(&quot;&lt;waypoint&gt;\r\n   &lt;name id=\&quot;&quot;);
-		String wptName=simplifyString(ch.getWayPoint());
+		String wptName = simplifyString(ch.getWayPoint());
 		if (Global.getPref().addDetailsToWaypoint) {
-			wptName += getShortDetails( ch );
+			wptName += getShortDetails(ch);
 		}
-		if (Global.getPref().garminMaxLen==0)
+		if (Global.getPref().garminMaxLen == 0)
 			strBuf.append(wptName);
 		else {
 			try {
-				strBuf.append(wptName.substring(wptName.length()-Global.getPref().garminMaxLen));
-			} catch (Exception ex){ pref.log(&quot;[LocExporter:record]Invalid value for garmin.MaxWaypointLength&quot;,ex); }
+				strBuf.append(wptName.substring(wptName.length() - Global.getPref().garminMaxLen));
+			} catch (Exception ex) {
+				pref.log(&quot;[LocExporter:record]Invalid value for garmin.MaxWaypointLength&quot;, ex);
+			}
 		}
 		strBuf.append(&quot;\&quot;&gt;&lt;![CDATA[&quot;);
 		strBuf.append(simplifyString(ch.getCacheName()));
 		if (Global.getPref().addDetailsToName) {
-			if ( !Global.getPref().addDetailsToWaypoint ) {
-				strBuf.append( getShortDetails( ch ) );
+			if (!Global.getPref().addDetailsToWaypoint) {
+				strBuf.append(getShortDetails(ch));
 			}
 			CacheHolderDetail det = ch.getCacheDetails(true);
-			if ( (!det.Hints.equals(&quot;null&quot;)) &amp;&amp; (det.Hints.length() &gt; 0) ) {
+			if ((!det.Hints.equals(&quot;null&quot;)) &amp;&amp; (det.Hints.length() &gt; 0)) {
 				strBuf.append(&quot;:&quot;);
-				strBuf.append( simplifyString(Common.rot13(det.Hints)) );
+				strBuf.append(simplifyString(Common.rot13(det.Hints)));
 			}
 		}
 		strBuf.append(&quot;]]&gt;&lt;/name&gt;\r\n   &lt;coord lat=\&quot;&quot;);
-		strBuf.append(ch.pos.getLatDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLatDeg(CWPoint.DD));
 		strBuf.append(&quot;\&quot; lon=\&quot;&quot;);
-		strBuf.append(ch.pos.getLonDeg(CWPoint.DD));
+		strBuf.append(ch.getPos().getLonDeg(CWPoint.DD));
 		strBuf.append(&quot;\&quot;/&gt;\r\n   &lt;type&gt;&quot;);
 		strBuf.append(gm.getIcon(ch));
 		strBuf.append(&quot;&lt;/type&gt;\r\n&lt;/waypoint&gt;\r\n&quot;);
 		return strBuf.toString();
 	}
-	public String trailer(){
+
+	public String trailer() {
 		return &quot;&lt;/loc&gt;\r\n&quot;;
 	}
 }

Added: branches/r1.2/src/CacheWolf/exp/OCLogExport.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/OCLogExport.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/exp/OCLogExport.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,100 @@
+package CacheWolf.exp;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.CacheType;
+import CacheWolf.DateFormat;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import CacheWolf.OC;
+import CacheWolf.UrlFetcher;
+import CacheWolf.imp.OCGPXfetch;
+import CacheWolf.imp.OCLinkImporter;
+import ewe.io.IOException;
+import ewe.sys.Handle;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.ProgressBarForm;
+
+public final class OCLogExport {
+	private static boolean loggedIn = false;
+	private static CacheDB cacheDB = null;
+
+	public static void doit() {
+
+		if (cacheDB == null)
+			cacheDB = Global.getProfile().cacheDB;
+		int totalWaypoints = cacheDB.countVisible();
+		int updated = 0;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h, &quot;logging opencaching ...&quot;);
+		pbf.exec();
+		if (OCGPXfetch.login()) {
+			for (int o = 0; o &lt; cacheDB.size(); o += 1) {
+				if (pbf.exitValue == -1)
+					break;
+				CacheHolder ch = cacheDB.get(o);
+				if (ch.isVisible()) {
+					doOneLog(ch);
+					updated++;
+					h.progress = (float) updated / (float) totalWaypoints;
+					h.changed();
+				}
+			}
+		}
+		pbf.exit(0);
+	}
+
+	public static void doOneLog(CacheHolder ch) {
+		if (!ch.is_found())
+			return;
+		// take GC log direct to OC, needs valid ch
+		Vm.showWait(true);
+		String wpName = ch.getOcCacheID();
+		if (wpName.length() &gt; 1) {
+			if (!loggedIn)
+				loggedIn = OCGPXfetch.login();
+			if (loggedIn) {
+				if (wpName.charAt(0) &lt; 65) {
+					// noch nicht bei OC gelogged
+					wpName = ch.getOcCacheID().substring(1);
+					String url = &quot;<A HREF="http://">http://</A>&quot; + OC.getOCHostName(wpName) + &quot;/log.php?wp=&quot; + wpName;
+					String page = &quot;&quot;;
+					try {
+						CacheHolderDetail chD = ch.getCacheDetails(false);
+						if (chD.OwnLog != null) {
+							page = UrlFetcher.fetch(url);
+							loggedIn = page.indexOf(&quot;Eingeloggt als&quot;) &gt; -1; // next time perhaps
+							String ocCacheId = new Extractor(page, &quot;viewcache.php?cacheid=&quot;, &quot;\&quot;&gt;&quot;, 0, true).findNext();
+							String postData = &quot;cacheid=&quot; + ocCacheId + &quot;&amp;version3=1&amp;descMode=3&quot;;
+							if (ch.getType() == CacheType.CW_TYPE_EVENT || ch.getType() == CacheType.CW_TYPE_EVENT)
+								postData = postData + &quot;&amp;logtype=7&quot;;
+							else
+								postData = postData + &quot;&amp;logtype=1&quot;;
+							Time logDate = DateFormat.toDate(chD.OwnLog.getDate());
+							postData += &quot;&amp;logday=&quot; + logDate.day;
+							postData += &quot;&amp;logmonth=&quot; + logDate.month;
+							postData += &quot;&amp;logyear=&quot; + logDate.year;
+							postData += &quot;&amp;logtext=&quot; + UrlFetcher.toUtf8Url(chD.OwnLog.getMessage());
+							postData += &quot;&amp;submitform=Log+eintragen&quot;; // todo for other opencaching sites
+							UrlFetcher.setpostData(postData);
+							page = UrlFetcher.fetch(url);
+							OCLinkImporter.updateOCLink(ch);
+							if (ch.getOcCacheID().startsWith(&quot;-&quot;)) {
+								ch.setOcCacheID(&quot;!&quot; + ch.getOcCacheID().substring(1));
+								ch.save();
+							}
+						}
+					} catch (IOException e) {
+						// dann nicht
+					}
+				}
+			}
+		}
+		Vm.showWait(false);
+	}
+}

Modified: branches/r1.2/src/CacheWolf/exp/OziExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/OziExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/OziExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -29,8 +29,6 @@
 import CacheWolf.CacheType;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
-import ewe.io.File;
-import ewe.io.FileBase;
 
 /**
 *	Class to export the cache database (index) to an OziExplorer File

Modified: branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/SpoilerPOIExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
+
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheImages;
 import CacheWolf.Common;
@@ -35,18 +36,18 @@
 import ewe.sys.Time;
 import ewe.ui.FormBase;
 
-/** 
+/**
  * 
  * @author Kalle
- * Class to create a gpx-File with links to the pictures of a 
- * cache, which is used as input for the POILoader from Garmin.
+ *         Class to create a gpx-File with links to the pictures of a
+ *         cache, which is used as input for the POILoader from Garmin.
  */
 
 public class SpoilerPOIExporter extends Exporter {
 	private SpoilerPOIExporterScreen infoScreen;
 	private boolean onlySpoiler;
-	
-	public SpoilerPOIExporter(Preferences p, Profile prof){
+
+	public SpoilerPOIExporter(Preferences p, Profile prof) {
 		super();
 		this.setMask(&quot;*.gpx&quot;);
 		this.setHowManyParams(LAT_LON);
@@ -55,19 +56,19 @@
 
 	public void doIt() {
 		infoScreen = new SpoilerPOIExporterScreen(&quot;SpoilerPOIExport&quot;);
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		onlySpoiler = infoScreen.getOnlySpoiler();
 		super.doIt();
 	}
-	
-	public String header () {
+
+	public String header() {
 		StringBuffer strBuf = new StringBuffer(200);
 		Time tim = new Time();
 
 		strBuf.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; standalone=\&quot;no\&quot; ?&gt;\r\n&quot;);
-		strBuf.append(&quot;&lt;gpx xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/1\">http://www.topografix.com/GPX/1/1\</A>&quot; creator=\&quot;CacheWolf\&quot; version=\&quot;1.1\&quot;&quot; +
-				      &quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; &quot; +
-				      &quot;xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/1">http://www.topografix.com/GPX/1/1</A> <A HREF="http://www.topografix.com/GPX/1/1/gpx.xsd\">http://www.topografix.com/GPX/1/1/gpx.xsd\</A>&quot;&gt;\r\n&quot;);
+		strBuf.append(&quot;&lt;gpx xmlns=\&quot;<A HREF="http://www.topografix.com/GPX/1/1\">http://www.topografix.com/GPX/1/1\</A>&quot; creator=\&quot;CacheWolf\&quot; version=\&quot;1.1\&quot;&quot; + &quot; xmlns:xsi=\&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance\">http://www.w3.org/2001/XMLSchema-instance\</A>&quot; &quot;
+				+ &quot;xsi:schemaLocation=\&quot;<A HREF="http://www.topografix.com/GPX/1/1">http://www.topografix.com/GPX/1/1</A> <A HREF="http://www.topografix.com/GPX/1/1/gpx.xsd\">http://www.topografix.com/GPX/1/1/gpx.xsd\</A>&quot;&gt;\r\n&quot;);
 		strBuf.append(&quot;  &lt;metadata&gt;\r\n&quot;);
 		strBuf.append(&quot;    &lt;link href=\&quot;<A HREF="http://www.cachewolf.de\">http://www.cachewolf.de\</A>&quot;&gt;\r\n&quot;);
 		strBuf.append(&quot;      &lt;text&gt;CacheWolf&lt;/text&gt;\r\n&quot;);
@@ -78,48 +79,54 @@
 		strBuf.append(&quot;  &lt;/metadata&gt;\r\n&quot;);
 		return strBuf.toString();
 	}
-	
+
 	public String record(CacheHolder ch, String lat, String lon) {
 		StringBuffer strBuf = new StringBuffer(1000);
-		String comment,filename, url;
+		String comment, filename, url;
 		CacheImages images;
 		int picCounter;
-		
+
 		// Makes only sense for main waypoints
-		if (ch.isAddiWpt()) return null;
-		
+		if (ch.isAddiWpt())
+			return null;
+
 		// First check, if there a any pictures in the db for the wpt
 		ch.getCacheDetails(true);
-		if (! ch.detailsLoaded()) return null;
-		if (ch.getCacheDetails(true).images.size() == 0) return null;
-		
+		if (!ch.detailsLoaded())
+			return null;
+		if (ch.getCacheDetails(true).images.size() == 0)
+			return null;
+
 		images = ch.getCacheDetails(true).images.getDisplayImages(ch.getWayPoint());
 		picCounter = 0;
-		for (int i=0; i &lt; images.size(); i++ ) {
+		for (int i = 0; i &lt; images.size(); i++) {
 			filename = images.get(i).getFilename();
 			comment = images.get(i).getTitle();
 			url = profile.dataDir + filename;
-			
+
 			// POILoader can only work with JPG-Files
-			if ( !filename.endsWith(&quot;.jpg&quot;)) continue;
+			if (!filename.endsWith(&quot;.jpg&quot;))
+				continue;
 			// Try to export only Spoiler
-			if ( onlySpoiler &amp;&amp; (comment.indexOf(&quot;oiler&quot;) &lt; 1)) continue;
+			if (onlySpoiler &amp;&amp; (comment.indexOf(&quot;oiler&quot;) &lt; 1))
+				continue;
 			// check if the file is not deleted
-			if (!(new FileBugfix(url)).exists()) continue;
-			
+			if (!(new FileBugfix(url)).exists())
+				continue;
+
 			picCounter++;
 			strBuf.append(&quot;&lt;wpt lat=\&quot;&quot; + lat + &quot;\&quot; lon=\&quot;&quot; + lon + &quot;\&quot;&gt;\r\n&quot;);
-			strBuf.append(&quot;  &lt;name&gt;Sp &quot; + picCounter + &quot;: &quot; + SafeXML.cleanGPX(ch.cacheName) + &quot;&lt;/name&gt;\r\n&quot;);
+			strBuf.append(&quot;  &lt;name&gt;Sp &quot; + picCounter + &quot;: &quot; + SafeXML.cleanGPX(ch.getCacheName()) + &quot;&lt;/name&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;cmt&gt;\r\n&quot;);
-			if (ch.getCacheDetails(true).Hints.length()&gt; 0){
+			if (ch.getCacheDetails(true).Hints.length() &gt; 0) {
 				strBuf.append(&quot;  Hint: &quot; + SafeXML.cleanGPX(Common.rot13(ch.getCacheDetails(true).Hints)) + &quot;\r\n&quot;);
 			}
-			if (comment != null){
+			if (comment != null) {
 				strBuf.append(&quot;  Comment: &quot; + SafeXML.cleanGPX(SafeXML.cleanback(comment)) + &quot;\r\n&quot;);
 			}
 			strBuf.append(&quot;  &lt;/cmt&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;desc&gt;GCcode: &quot; + ch.getWayPoint() + &quot; &lt;/desc&gt;\r\n&quot;);
-			strBuf.append(&quot;   &lt;link href=\&quot;&quot; + URLUTF8Encoder.encode(url, false)  + &quot;\&quot;/&gt;\r\n&quot;);
+			strBuf.append(&quot;   &lt;link href=\&quot;&quot; + URLUTF8Encoder.encode(url, false) + &quot;\&quot;/&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;sym&gt;Scenic Area&lt;/sym&gt;\r\n&quot;);
 			strBuf.append(&quot;  &lt;extensions&gt;\r\n&quot;);
 			strBuf.append(&quot;     &lt;gpxx:WaypointExtension xmlns:gpxx=\&quot;<A HREF="http://www.garmin.com/xmlschemas/GpxExtensions/v3\">http://www.garmin.com/xmlschemas/GpxExtensions/v3\</A>&quot;&gt;\r\n&quot;);
@@ -129,10 +136,10 @@
 			strBuf.append(&quot;&lt;/wpt&gt;\r\n&quot;);
 			strBuf.append(&quot;\r\n&quot;);
 		}
-	
+
 		return strBuf.toString();
 	}
-	
+
 	public String trailer() {
 		return &quot;&lt;/gpx&gt;\r\n&quot;;
 	}

Modified: branches/r1.2/src/CacheWolf/exp/TPLExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/TPLExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/TPLExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -21,11 +21,12 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
+import CacheWolf.CacheType;
 import CacheWolf.Global;
 import CacheWolf.InfoBox;
 import CacheWolf.Preferences;
@@ -54,31 +55,29 @@
 import ewe.util.Vector;
 
 /**
- * @author Kalle
- * class to export cachedata using a template
+ * @author Kalle class to export cachedata using a template
  */
-class TplFilter implements HTML.Tmpl.Filter
-{
-	private int type=SCALAR;
-	private String newLine=&quot;\n&quot;;
+class TplFilter implements HTML.Tmpl.Filter {
+	private int type = SCALAR;
+	private String newLine = &quot;\n&quot;;
 	TextCodec codec = new AsciiCodec(); // codec = new AsciiCodec(AsciiCodec.STRIP_CR);
 	String badChars;
 	String decSep = &quot;.&quot;;
-	int shortNameLength=30;
-	int shortWaypointLength=3;
-	int noOfLogs=-1; // means all
+	int shortNameLength = 30;
+	int shortWaypointLength = 3;
+	int noOfLogs = -1; // means all
 	boolean single = true;
 	int formatModifier = 0;
 	int sortedBy = -1;
-	boolean getAddiWp = true;
-	boolean getMainWp = true;
+	boolean getAddiWp = false;
+	boolean getMainWp = false;
+	boolean getParking = false;
 	boolean copyCacheImages = false;
 	Hashtable additionalVarParams = new Hashtable();
 	String userValue = &quot;&quot;;
-	String out=&quot;*.gpx&quot;;
+	String out = &quot;*.gpx&quot;;
 
-
-	public TplFilter(){
+	public TplFilter() {
 		return;
 	}
 
@@ -94,7 +93,7 @@
 		// search for parameters
 		rex = new Regex(&quot;(?i)&lt;tmpl_par.*&gt;&quot;);
 		rex.search(t);
-		if (rex.didMatch()){
+		if (rex.didMatch()) {
 			// get parameter
 			rex1 = new Regex(&quot;(?i)name=\&quot;(.*)\&quot;\\svalue=\&quot;(.*)\&quot;[?\\s&gt;]&quot;);
 			rex1.search(t);
@@ -102,83 +101,77 @@
 			value = rex1.stringMatched(2);
 
 			if (param.equals(&quot;charset&quot;)) {
-				if (value.equals(&quot;ASCII&quot;)) {codec = new AsciiCodec();}
-				else if (value.equals(&quot;UTF8&quot;)) {codec = new JavaUtf8Codec();}
-				else {codec = new NoCodec();}
-			}
-			else if (param.equals(&quot;badchars&quot;)) {
+				if (value.equals(&quot;ASCII&quot;)) {
+					codec = new AsciiCodec();
+				} else if (value.equals(&quot;UTF8&quot;)) {
+					codec = new JavaUtf8Codec();
+				} else {
+					codec = new NoCodec();
+				}
+			} else if (param.equals(&quot;badchars&quot;)) {
 				badChars = value;
-			}
-			else if (param.equals(&quot;newline&quot;)){
+			} else if (param.equals(&quot;newline&quot;)) {
 				newLine = &quot;&quot;;
-				if (value.indexOf(&quot;CR&quot;) &gt;= 0) newLine += &quot;\r&quot;;
-				if (value.indexOf(&quot;LF&quot;) &gt;= 0) newLine += &quot;\n&quot;;
-			}
-			else if (param.equals(&quot;decsep&quot;)) {
+				if (value.indexOf(&quot;CR&quot;) &gt;= 0)
+					newLine += &quot;\r&quot;;
+				if (value.indexOf(&quot;LF&quot;) &gt;= 0)
+					newLine += &quot;\n&quot;;
+			} else if (param.equals(&quot;decsep&quot;)) {
 				decSep = value;
-			}
-			else if (param.equals(&quot;ShortNameLength&quot;)) {
+			} else if (param.equals(&quot;ShortNameLength&quot;)) {
 				shortNameLength = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals(&quot;WaypointLength&quot;)) {
+			} else if (param.equals(&quot;WaypointLength&quot;)) {
 				shortWaypointLength = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals(&quot;NrLogs&quot;)) {
+			} else if (param.equals(&quot;NrLogs&quot;)) {
 				noOfLogs = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals(&quot;singleFile&quot;)) {
-				single = value.equals(&quot;yes&quot;) ? true : false ;
-			}
-			else if (param.equals(&quot;formatModifier&quot;)) {
+			} else if (param.equals(&quot;singleFile&quot;)) {
+				single = value.equals(&quot;yes&quot;) ? true : false;
+			} else if (param.equals(&quot;formatModifier&quot;)) {
 				formatModifier = Integer.valueOf(value).intValue();
-			}
-			else if (param.equals(&quot;Out&quot;)) {
+			} else if (param.equals(&quot;Out&quot;)) {
 				out = value;
-			}
-			else if (param.equals(&quot;takeOnlyWp&quot;)) {
+			} else if (param.equals(&quot;takeOnlyWp&quot;)) {
 				if (value.equals(&quot;main&quot;)) {
-					getAddiWp=false;
+					getMainWp = true;
+				} else if (value.equals(&quot;addi&quot;)) {
+					getAddiWp = true;
+				} else if (value.equals(&quot;parking&quot;)) {
+					getParking = true;
 				}
-				else if (value.equals(&quot;addi&quot;)) {
-					getMainWp=false;
-				}
-			}
-			else if (param.equals(&quot;sortedBy&quot;)) {
-				sortedBy=Integer.valueOf(value).intValue();
-			}
-			else if (param.equals(&quot;CopyCacheImages&quot;)) {
-				if (value.equals(&quot;yes&quot;)) copyCacheImages=true;
-			}
-			else if (param.startsWith(&quot;input&quot;)) {
+			} else if (param.equals(&quot;sortedBy&quot;)) {
+				sortedBy = Integer.valueOf(value).intValue();
+			} else if (param.equals(&quot;CopyCacheImages&quot;)) {
+				if (value.equals(&quot;yes&quot;))
+					copyCacheImages = true;
+			} else if (param.startsWith(&quot;input&quot;)) {
 				String par = param.substring(5);
 				InfoBox inf = new InfoBox(&quot;Eingabe&quot;, par, InfoBox.INPUT);
 				inf.feedback.setText(value);
 				String res;
 				if (inf.execute() == FormBase.IDOK) {
 					res = inf.getInput();
-					additionalVarParams.put(par,res);
+					additionalVarParams.put(par, res);
 				}
+			} else if (param.startsWith(&quot;const&quot;)) {
+				additionalVarParams.put(param.substring(5), value);
 			}
-			else if (param.startsWith(&quot;const&quot;)) {
-				additionalVarParams.put(param.substring(5),value);
-			}
 			return &quot;&quot;;
 		}
 
 		if (formatModifier == 0) {
 			// for gpx output
 			// Filter newlines
-			rex = new Regex(&quot;(?m)\n$&quot;,&quot;&quot;);
+			rex = new Regex(&quot;(?m)\n$&quot;, &quot;&quot;);
 			t = rex.replaceAll(t);
 
 			// Filter comments &lt;#-- and --&gt;
-			rex = new Regex(&quot;&lt;#--.*--&gt;&quot;,&quot;&quot;);
+			rex = new Regex(&quot;&lt;#--.*--&gt;&quot;, &quot;&quot;);
 			t = rex.replaceAll(t);
 
 			// replace &lt;br&gt; or &lt;br /&gt; with newline
-			rex = new Regex(&quot;&lt;br.*&gt;&quot;,&quot;&quot;);
+			rex = new Regex(&quot;&lt;br.*&gt;&quot;, &quot;&quot;);
 			rex.search(t);
-			if (rex.didMatch()){
+			if (rex.didMatch()) {
 				t = rex.replaceAll(t);
 				t += newLine;
 			}
@@ -187,46 +180,44 @@
 		return t;
 	}
 
-
-	public String [] parse(String [] t) {
+	public String[] parse(String[] t) {
 		throw new UnsupportedOperationException();
 	}
 }
 
-
 public class TPLExporter {
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
 	String tplFile;
 	String expName;
-	Regex rex=null;
-	private static GarminMap gm=null;
+	Regex rex = null;
+	private static GarminMap gm = null;
 
-	public TPLExporter(Preferences p, Profile prof, String tpl){
+	public TPLExporter(Preferences p, Profile prof, String tpl) {
 		pref = p;
-		profile=prof;
+		profile = prof;
 		cacheDB = profile.cacheDB;
 		tplFile = tpl;
 		File tmpFile = new File(tpl);
 		expName = tmpFile.getName();
 		expName = expName.substring(0, expName.indexOf(&quot;.&quot;));
-		gm=new GarminMap();
+		gm = new GarminMap();
 	}
 
-	public void doIt(){
+	public void doIt() {
 
 		ProgressBarForm pbf = new ProgressBarForm();
 		ewe.sys.Handle h = new ewe.sys.Handle();
 		int counter = cacheDB.countVisible();
 		pbf.showMainTask = false;
-		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.setTask(h, &quot;Exporting ...&quot;);
 		pbf.exec();
 
 		try {
-			TplFilter myFilter = new TplFilter();			
+			TplFilter myFilter = new TplFilter();
 			Hashtable args = new Hashtable();
-			//args.put(&quot;debug&quot;, &quot;true&quot;);
+			// args.put(&quot;debug&quot;, &quot;true&quot;);
 			args.put(&quot;filename&quot;, tplFile);
 			args.put(&quot;case_sensitive&quot;, &quot;true&quot;);
 			args.put(&quot;loop_context_vars&quot;, Boolean.TRUE);
@@ -237,50 +228,64 @@
 			FileChooser fc = new FileChooser(FileChooserBase.SAVE, pref.getExportPath(expName));
 			fc.setTitle(&quot;Select target file:&quot;);
 			fc.addMask(myFilter.out);
-			if(fc.execute() == FormBase.IDCANCEL) {pbf.exit(0); return; }
+			if (fc.execute() == FormBase.IDCANCEL) {
+				pbf.exit(0);
+				return;
+			}
 			File saveTo = fc.getChosenFile();
 			pref.setExportPath(expName, saveTo.getPath());
 
-			if (myFilter.sortedBy!=-1) {
+			if (myFilter.sortedBy != -1) {
 				Global.mainTab.tbP.myMod.sortTable(myFilter.sortedBy, true);
 			}
-			
-			Regex dec = new Regex(&quot;[,.]&quot;,myFilter.decSep);
-			if (myFilter.badChars != null) rex = new Regex(&quot;[&quot;+myFilter.badChars+&quot;]&quot;,&quot;&quot;);
-			
+
+			Regex dec = new Regex(&quot;[,.]&quot;, myFilter.decSep);
+			if (myFilter.badChars != null)
+				rex = new Regex(&quot;[&quot; + myFilter.badChars + &quot;]&quot;, &quot;&quot;);
+
 			Vector cache_index = new Vector();
-			String imgExpName=&quot;&quot;;
-			if (myFilter.copyCacheImages) imgExpName=expName;
-			for(int i = 0; i&lt;counter;i++){
+			String imgExpName = &quot;&quot;;
+			if (myFilter.copyCacheImages)
+				imgExpName = expName;
+			for (int i = 0; i &lt; counter; i++) {
 				CacheHolder ch = cacheDB.get(i);
-				if (ch.isVisible() &amp;&amp; (ch.pos.isValid() || myFilter.formatModifier&gt;0) ){
-					if (myFilter.getAddiWp == ch.isAddiWpt() || myFilter.getMainWp == !ch.isAddiWpt()) {
-						h.progress = (float)i/(float)counter;
+				if (ch.isVisible() &amp;&amp; (ch.getPos().isValid() || myFilter.formatModifier &gt; 0)) {
+					boolean get = true;
+					if (myFilter.getAddiWp) {
+						get = ch.isAddiWpt();
+					} else if (myFilter.getMainWp) {
+						get = !ch.isAddiWpt();
+					} else if (myFilter.getParking) {
+						get = (ch.getType() == CacheType.CW_TYPE_PARKING)// parking
+								|| (!ch.isAddiWpt() &amp;&amp; !hasParking(ch));// oder main ohne Parkplatz
+					}
+					if (get) {
+						h.progress = (float) i / (float) counter;
 						h.changed();
 						try {
-							Hashtable varParams=ch.toHashtable(dec, rex, myFilter.shortWaypointLength, myFilter.shortNameLength, myFilter.noOfLogs, myFilter.codec, gm, false, myFilter.formatModifier, imgExpName);
-							
+							Hashtable varParams = ch.toHashtable(dec, rex, myFilter.shortWaypointLength, myFilter.shortNameLength, myFilter.noOfLogs, myFilter.codec, gm, false, myFilter.formatModifier, imgExpName);
+
 							Enumeration e = myFilter.additionalVarParams.keys();
-							while(e.hasMoreElements()) {
-								String key = (String)e.nextElement();
+							while (e.hasMoreElements()) {
+								String key = (String) e.nextElement();
 								Object value = myFilter.additionalVarParams.get(key);
 								varParams.put(key, value);
 							}
-							
+
 							if (myFilter.single) {
 								cache_index.add(varParams);
 							}
 
 							else {
 								tpl.setParams(varParams);
-								String ext = (myFilter.out.substring(myFilter.out.lastIndexOf(&quot;.&quot;)).toLowerCase()+&quot;    &quot;).trim();
+								String ext = (myFilter.out.substring(myFilter.out.lastIndexOf(&quot;.&quot;)).toLowerCase() + &quot;    &quot;).trim();
 								FileWriter fw = new FileWriter(saveTo.getPath() + ch.getWayPoint() + ext);
 								fw.codec = myFilter.codec;
 								PrintWriter detfile = new PrintWriter(new BufferedWriter(fw));
 								tpl.printTo(detfile);
 								detfile.close();
 							}
-						}catch(Exception e){
+						} catch (Exception e) {
 							pref.log(&quot;[TplExporter:doIt]&quot; + ch.getWayPoint(), e, true);
 						}
 					}
@@ -298,91 +303,106 @@
 		} catch (Exception e) {
 			pref.log(&quot;[TplExporter:doIt]&quot;, e, true);
 		} catch (OutOfMemoryError e) {
-			(new MessageBox(&quot;Error&quot;, &quot;Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now&quot;, FormBase.OKB)).execute();
+			(new MessageBox(&quot;Error&quot;, &quot;Not enough memory available to load all cache data (incl. description and logs)\nexport aborted\nFilter caches to minimise memory needed for TPL-Export\nWe recommend to restart CacheWolf now&quot;, FormBase.OKB))
+					.execute();
 		}
 		pbf.exit(0);
 	}
+
+	private boolean hasParking(CacheHolder ch) {
+		boolean ret = false;
+		if (ch.hasAddiWpt()) {
+			for (int i = 0; i &lt; ch.addiWpts.size(); i++) {
+				CacheHolder chwp = (CacheHolder) ch.addiWpts.get(i);
+				if (chwp.getType() == CacheType.CW_TYPE_PARKING)
+					return true;
+			}
+		}
+		return ret;
+	}
 }
 
-//##################################################################
-class NoCodec implements TextCodec{
-//##################################################################
+// ##################################################################
+class NoCodec implements TextCodec {
+	// ##################################################################
 
-/**
-* This is a creation option. It specifies that CR characters should be removed when
-* encoding text into UTF.
-**/
-public static final int STRIP_CR_ON_DECODE = 0x1;
-/**
-* This is a creation option. It specifies that CR characters should be removed when
-* decoding text from UTF.
-**/
-public static final int STRIP_CR_ON_ENCODE = 0x2;
-/**
-* This is a creation option. It specifies that CR characters should be removed when
-* decoding text from UTF AND encoding text to UTF.
-**/
-public static final int STRIP_CR = STRIP_CR_ON_DECODE|STRIP_CR_ON_ENCODE;
+	/**
+	 * This is a creation option. It specifies that CR characters should be removed when encoding text into UTF.
+	 */
+	public static final int STRIP_CR_ON_DECODE = 0x1;
+	/**
+	 * This is a creation option. It specifies that CR characters should be removed when decoding text from UTF.
+	 */
+	public static final int STRIP_CR_ON_ENCODE = 0x2;
+	/**
+	 * This is a creation option. It specifies that CR characters should be removed when decoding text from UTF AND encoding text to UTF.
+	 */
+	public static final int STRIP_CR = STRIP_CR_ON_DECODE | STRIP_CR_ON_ENCODE;
 
-private int flags = 0;
+	private int flags = 0;
 
-//===================================================================
-public NoCodec(int options)
-//===================================================================
-{
-	flags = options;
-}
-//===================================================================
-public NoCodec()
-//===================================================================
-{
-	this(0);
-}
-//===================================================================
-public ByteArray encodeText(char [] text, int start, int length, boolean endOfData, ByteArray dest) throws IOException
-//===================================================================
-{
-	if (dest == null) dest = new ByteArray();
-	int size = length == 0 ? 2 : 2+text.length*2;
-	if (dest.data == null || dest.data.length &lt; size)
-		dest.data = new byte[size];
-	byte [] destination = dest.data;
-	int s = 0;
-	if (length&gt;0){
-		destination[s++] = (byte) 0xFF;
-		destination[s++] = (byte) 0xFE;
+	// ===================================================================
+	public NoCodec(int options)
+	// ===================================================================
+	{
+		flags = options;
 	}
-	for (int i = 0; i&lt;length; i++){
-		char c = text[i+start];
-		if (c == 13 &amp;&amp; ((flags &amp; STRIP_CR_ON_ENCODE) != 0)) continue;
-		destination[s++] = (byte)(c &amp; 0xFF);
-		destination[s++] = (byte)((c&gt;&gt;8) &amp; 0xFF);
+
+	// ===================================================================
+	public NoCodec()
+	// ===================================================================
+	{
+		this(0);
 	}
-	dest.length = s;
-	return dest;
-}
 
-//===================================================================
-public CharArray decodeText(byte [] encoded, int start, int length, boolean endOfData, CharArray dest) throws IOException
-//===================================================================
-{
-	if (dest == null) dest = new CharArray();
-	dest.length = 0;
-	return dest;
-}
+	// ===================================================================
+	public ByteArray encodeText(char[] text, int start, int length, boolean endOfData, ByteArray dest) throws IOException
+	// ===================================================================
+	{
+		if (dest == null)
+			dest = new ByteArray();
+		int size = length == 0 ? 2 : 2 + text.length * 2;
+		if (dest.data == null || dest.data.length &lt; size)
+			dest.data = new byte[size];
+		byte[] destination = dest.data;
+		int s = 0;
+		if (length &gt; 0) {
+			destination[s++] = (byte) 0xFF;
+			destination[s++] = (byte) 0xFE;
+		}
+		for (int i = 0; i &lt; length; i++) {
+			char c = text[i + start];
+			if (c == 13 &amp;&amp; ((flags &amp; STRIP_CR_ON_ENCODE) != 0))
+				continue;
+			destination[s++] = (byte) (c &amp; 0xFF);
+			destination[s++] = (byte) ((c &gt;&gt; 8) &amp; 0xFF);
+		}
+		dest.length = s;
+		return dest;
+	}
 
-//===================================================================
-public void closeCodec() throws IOException
-//===================================================================
-{
-}
+	// ===================================================================
+	public CharArray decodeText(byte[] encoded, int start, int length, boolean endOfData, CharArray dest) throws IOException
+	// ===================================================================
+	{
+		if (dest == null)
+			dest = new CharArray();
+		dest.length = 0;
+		return dest;
+	}
 
-//===================================================================
-public Object getCopy()
-//===================================================================
-{
-	return new NoCodec(flags);
+	// ===================================================================
+	public void closeCodec() throws IOException
+	// ===================================================================
+	{
+	}
+
+	// ===================================================================
+	public Object getCopy()
+	// ===================================================================
+	{
+		return new NoCodec(flags);
+	}
+	// ##################################################################
 }
-//##################################################################
-}
-//##################################################################
+// ##################################################################

Modified: branches/r1.2/src/CacheWolf/exp/TomTomExporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/exp/TomTomExporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/exp/TomTomExporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.exp;
 
 import CacheWolf.CWPoint;
@@ -60,46 +60,51 @@
 	CacheDB cacheDB;
 	Preferences pref;
 	Profile profile;
-	
+
 	public TomTomExporter() {
 		profile = Global.getProfile();
 		pref = Global.getPref();
 		cacheDB = profile.cacheDB;
 	}
-	
-	public void doIt(){
+
+	public void doIt() {
 		String fileName, dirName, prefix;
 		int fileFormat;
 
 		TomTomExporterScreen infoScreen = new TomTomExporterScreen(&quot;TomTomExport&quot;);
-		if (infoScreen.execute() == FormBase.IDCANCEL) return;
+		if (infoScreen.execute() == FormBase.IDCANCEL)
+			return;
 		fileFormat = infoScreen.getFormat();
 
 		dirName = pref.getExportPath(expName);
-		
-		if (infoScreen.oneFilePerType()){
+
+		if (infoScreen.oneFilePerType()) {
 			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, dirName);
 			fc.setTitle(&quot;Select target dir:&quot;);
-			if(fc.execute() == FormBase.IDCANCEL) return;
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			dirName = fc.getChosen();
 			pref.setExportPath(expName, dirName);
 			prefix = infoScreen.getPrefix();
 			writeOneFilePerType(fileFormat, dirName, prefix);
-		} else{
+		} else {
 			FileChooser fc = new FileChooser(FileChooserBase.SAVE, dirName);
 			fc.setTitle(&quot;Select target file:&quot;);
-	
-			if (fileFormat == TT_ASC) fc.addMask(&quot;*.asc&quot;);
-			else fc.addMask(&quot;*.ov2&quot;);
-			
-			if(fc.execute() == FormBase.IDCANCEL) return;
+
+			if (fileFormat == TT_ASC)
+				fc.addMask(&quot;*.asc&quot;);
+			else
+				fc.addMask(&quot;*.ov2&quot;);
+
+			if (fc.execute() == FormBase.IDCANCEL)
+				return;
 			fileName = fc.getChosen();
 			pref.setExportPathFromFileName(expName, fileName);
 			writeSingleFile(fileFormat, fileName);
 		}
 	}
-	
-	public void writeOneFilePerType(int format, String dirName, String prefix){
+
+	public void writeOneFilePerType(int format, String dirName, String prefix) {
 		RandomAccessFile out = null;
 		File dfile;
 		String ext, fileName = null;
@@ -108,63 +113,64 @@
 		ProgressBarForm progressForm = new ProgressBarForm();
 		Handle h = new Handle();
 		int currExp, counter;
-		
+
 		progressForm.showMainTask = false;
-		progressForm.setTask(h,&quot;Exporting ...&quot;);
+		progressForm.setTask(h, &quot;Exporting ...&quot;);
 		progressForm.exec();
-		
+
 		currExp = 0;
 		counter = cacheDB.countVisible();
-		
-		ext = format==TT_ASC?&quot;.asc&quot;:&quot;.ov2&quot;;
 
-		try{
-			//loop through type
-			for(int j = 0; j &lt; CacheType.guiTypeStrings().length; j++){
+		ext = format == TT_ASC ? &quot;.asc&quot; : &quot;.ov2&quot;;
+
+		try {
+			// loop through type
+			for (int j = 0; j &lt; CacheType.guiTypeStrings().length; j++) {
 				/*
-				String typeName = CacheType.guiTypeStrings()[j];
-				if (typeName.startsWith(&quot;Addi: &quot;)) {
-					typeName = typeName.substring(6);
-				}
-				*/
+				 * String typeName = CacheType.guiTypeStrings()[j];
+				 * if (typeName.startsWith(&quot;Addi: &quot;)) {
+				 * typeName = typeName.substring(6);
+				 * }
+				 */
 				String typeName = CacheType.typeImageForId(CacheType.guiSelect2Cw(j));
-				typeName=typeName.substring(0, typeName.length()-4);		
-				
+				typeName = typeName.substring(0, typeName.length() - 4);
+
 				fileName = dirName + &quot;/&quot; + prefix + typeName + ext;
 				dfile = new File(fileName);
 				dfile.delete();
-				out =  new RandomAccessFile(fileName,&quot;rw&quot;);
-				for(int i = 0; i&lt;cacheDB.size(); i++){
-					holder=cacheDB.get(i);
+				out = new RandomAccessFile(fileName, &quot;rw&quot;);
+				for (int i = 0; i &lt; cacheDB.size(); i++) {
+					holder = cacheDB.get(i);
 
-					if(holder.getType() == CacheType.guiSelect2Cw(j) &amp;&amp; holder.isVisible()){
+					if (holder.getType() == CacheType.guiSelect2Cw(j) &amp;&amp; holder.isVisible()) {
 						currExp++;
-						h.progress = (float)currExp/(float)counter;
+						h.progress = (float) currExp / (float) counter;
 						h.changed();
-						if (holder.pos.isValid() == false) continue;
-						if (format == TT_ASC){
-							writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						if (holder.getPos().isValid() == false)
+							continue;
+						if (format == TT_ASC) {
+							writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						} else {
-							writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+							writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 						}
-					}//if
-				}//for cacheDB
+					}// if
+				}// for cacheDB
 				out.close();
 				// check for empty files and delete them
 				dfile = new File(fileName);
-				if (dfile.length()==0) {
+				if (dfile.length() == 0) {
 					dfile.delete();
 				} else {
-					copyIcon(j, dirName + &quot;/&quot; + prefix,typeName); 
+					copyIcon(j, dirName + &quot;/&quot; + prefix, typeName);
 				}
-			}//for wayType
+			}// for wayType
 			progressForm.exit(0);
-		} catch (IOException e){
-			pref.log(&quot;Problem creating file! &quot; + fileName,e,true);
-		}//try
+		} catch (IOException e) {
+			pref.log(&quot;Problem creating file! &quot; + fileName, e, true);
+		}// try
 	}
-	
-	public void writeSingleFile(int format, String fileName){
+
+	public void writeSingleFile(int format, String fileName) {
 		RandomAccessFile out = null;
 		File dfile;
 
@@ -173,53 +179,53 @@
 		Handle h = new Handle();
 
 		pbf.showMainTask = false;
-		pbf.setTask(h,&quot;Exporting ...&quot;);
+		pbf.setTask(h, &quot;Exporting ...&quot;);
 		pbf.exec();
 
 		int counter = cacheDB.countVisible();
 		int expCount = 0;
 
-		try{
+		try {
 			dfile = new File(fileName);
 			dfile.delete();
-			out =  new RandomAccessFile(fileName,&quot;rw&quot;);
-			for(int i = 0; i&lt;cacheDB.size(); i++){
-				holder=cacheDB.get(i);
-				if(holder.isVisible()){
+			out = new RandomAccessFile(fileName, &quot;rw&quot;);
+			for (int i = 0; i &lt; cacheDB.size(); i++) {
+				holder = cacheDB.get(i);
+				if (holder.isVisible()) {
 					expCount++;
-					h.progress = (float)expCount/(float)counter;
+					h.progress = (float) expCount / (float) counter;
 					h.changed();
-					if (holder.pos.isValid() == false) continue;
-					if (format == TT_ASC){
-						writeRecordASCII(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+					if (holder.getPos().isValid() == false)
+						continue;
+					if (format == TT_ASC) {
+						writeRecordASCII(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					} else {
-						writeRecordBinary(out, holder,holder.pos.getLatDeg(CWPoint.DD),holder.pos.getLonDeg(CWPoint.DD));
+						writeRecordBinary(out, holder, holder.getPos().getLatDeg(CWPoint.DD), holder.getPos().getLonDeg(CWPoint.DD));
 					}
-				}//if
-			}//for
+				}// if
+			}// for
 			out.close();
-			copyIcon(0, fileName.substring(0,fileName.indexOf(&quot;.&quot;)),&quot;&quot;);
+			copyIcon(0, fileName.substring(0, fileName.indexOf(&quot;.&quot;)), &quot;&quot;);
 			pbf.exit(0);
-		}catch (Exception e){
-			pref.log(&quot;Problem writing to file! &quot; + fileName,e,true);
-		}//try
+		} catch (Exception e) {
+			pref.log(&quot;Problem writing to file! &quot; + fileName, e, true);
+		}// try
 	}
-	
-	
-	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
+
+	public void writeRecordASCII(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
 		try {
 			outp.writeBytes(lon);
 			outp.writeBytes(&quot;,&quot;);
 			outp.writeBytes(lat);
 			outp.writeBytes(&quot;,&quot;);
-			//outp.writeBytes(&quot;\&quot;&quot; + ch.CacheName.replace(',',' ') + &quot;\&quot;\r\n&quot;);
+			// outp.writeBytes(&quot;\&quot;&quot; + ch.CacheName.replace(',',' ') + &quot;\&quot;\r\n&quot;);
 			outp.writeBytes(&quot;\&quot;&quot;);
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(&quot; - &quot;);
-			outp.writeBytes(ch.getCacheName().replace(',',' '));
+			outp.writeBytes(ch.getCacheName().replace(',', ' '));
 			outp.writeBytes(&quot; by &quot;);
 			outp.writeBytes(ch.getCacheOwner());
-			outp.writeBytes(&quot;- &quot;);             
+			outp.writeBytes(&quot;- &quot;);
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes(&quot;/&quot;);
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
@@ -227,52 +233,53 @@
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			outp.writeBytes(&quot;\&quot;\r\n&quot;);
 		} catch (IOException e) {
-			pref.log(&quot;Error writing to file&quot;,e,true);
+			pref.log(&quot;Error writing to file&quot;, e, true);
 		}
 		return;
 	}
 
-	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon){
-		int d,data;
+	public void writeRecordBinary(RandomAccessFile outp, CacheHolder ch, String lat, String lon) {
+		int d, data;
 		double latlon;
-		
+
 		try {
 			d = 2;
-			outp.writeByte((byte)d);
-			data = ch.getWayPoint().length()+ch.getCacheName().length()+ch.getCacheOwner().length()+String.valueOf(ch.getHard()).length()+String.valueOf(ch.getTerrain()).length()+CacheSize.cw2ExportString(ch.getCacheSize()).length()+27;
+			outp.writeByte((byte) d);
+			data = ch.getWayPoint().length() + ch.getCacheName().length() + ch.getCacheOwner().length() + String.valueOf(ch.getHard()).length() + String.valueOf(ch.getTerrain()).length() + CacheSize.cw2ExportString(ch.getCacheSize()).length() + 27;
 			writeIntBinary(outp, data);
 			latlon = Common.parseDouble(lon);
-			latlon *=100000;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
-			latlon = Common.parseDouble(lat);;
-			latlon *=100000;
+			latlon = Common.parseDouble(lat);
+			;
+			latlon *= 100000;
 			writeIntBinary(outp, (int) latlon);
 			outp.writeBytes(ch.getWayPoint());
 			outp.writeBytes(&quot; - &quot;);
 			outp.writeBytes(ch.getCacheName());
 			outp.writeBytes(&quot; by &quot;);
 			outp.writeBytes(ch.getCacheOwner());
-			//Wenn Leerzeichen am Ende von Cache.Owner entfernt: 
-			//Hier wieder einf&#252;gen
-			//und data = holder.wayPoint.length()+holder.CacheName.length()+.....
-			//wider um 1 erh&#246;hen
-			outp.writeBytes(&quot;- &quot;);             
+			// Wenn Leerzeichen am Ende von Cache.Owner entfernt:
+			// Hier wieder einf&#252;gen
+			// und data = holder.wayPoint.length()+holder.CacheName.length()+.....
+			// wider um 1 erh&#246;hen
+			outp.writeBytes(&quot;- &quot;);
 			outp.writeBytes(String.valueOf(ch.getHard()));
 			outp.writeBytes(&quot;/&quot;);
 			outp.writeBytes(String.valueOf(ch.getTerrain()));
 			outp.writeBytes(&quot; - &quot;);
 			outp.writeBytes(CacheSize.cw2ExportString(ch.getCacheSize()));
 			d = 0;
-			outp.writeByte((byte)d);
+			outp.writeByte((byte) d);
 		} catch (IOException e) {
-			pref.log(&quot;Error writing to file&quot;,e,true);
+			pref.log(&quot;Error writing to file&quot;, e, true);
 		}
 
 		return;
 	}
 
-	public void writeIntBinary(RandomAccessFile outp, int data){
-		
+	public void writeIntBinary(RandomAccessFile outp, int data) {
+
 		ByteArray buf = new ByteArray();
 		buf.appendInt(data);
 		try {
@@ -281,42 +288,44 @@
 			outp.writeByte(buf.data[1]);
 			outp.writeByte(buf.data[0]);
 		} catch (IOException e) {
-			pref.log(&quot;Error writing to file&quot;,e,true);
+			pref.log(&quot;Error writing to file&quot;, e, true);
 		}
 
 		return;
 	}
-	
-	public void copyIcon(int intWayType, String prefix, String typeName){
-		ZipFile zif=null;
+
+	public void copyIcon(int intWayType, String prefix, String typeName) {
+		ZipFile zif = null;
 		try {
-			zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+&quot;exporticons&quot;+FileBase.separator+&quot;TomTom.zip&quot;);
-		} catch (IOException e) {}
+			zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;TomTom.zip&quot;);
+		} catch (IOException e) {
+		}
 		try {
 			if (zif == null) {
-				zif = new ZipFile (FileBase.getProgramDirectory() + FileBase.separator+&quot;exporticons&quot;+ FileBase.separator+&quot;exporticons&quot;+FileBase.separator+&quot;TomTom.zip&quot;);
+				zif = new ZipFile(FileBase.getProgramDirectory() + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;exporticons&quot; + FileBase.separator + &quot;TomTom.zip&quot;);
 			}
 			ZipEntry zipEnt;
 			int len;
-			String entName; 
-			
+			String entName;
+
 			entName = &quot;GC-&quot; + typeName + &quot;.bmp&quot;;
 			zipEnt = zif.getEntry(entName);
-			if (zipEnt == null) return;
-			
-		    byte[] buff = new byte[ zipEnt.getSize() ];
-		    InputStream  fis = zif.getInputStream(zipEnt);
-		    FileOutputStream fos = new FileOutputStream( prefix + typeName + &quot;.bmp&quot;);
-		    while( 0 &lt; (len = fis.read( buff )) )
-		      fos.write( buff, 0, len );
-		    fos.flush();
-		    fos.close();
-		    fis.close();
+			if (zipEnt == null)
+				return;
+
+			byte[] buff = new byte[zipEnt.getSize()];
+			InputStream fis = zif.getInputStream(zipEnt);
+			FileOutputStream fos = new FileOutputStream(prefix + typeName + &quot;.bmp&quot;);
+			while (0 &lt; (len = fis.read(buff)))
+				fos.write(buff, 0, len);
+			fos.flush();
+			fos.close();
+			fis.close();
 		} catch (ZipException e) {
-			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot; ,e,true);
+			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot;, e, true);
 		} catch (IOException e) {
-			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot; ,e,true);
+			pref.log(&quot;Problem copying Icon &quot; + &quot;GC-&quot; + typeName + &quot;.bmp&quot;, e, true);
 		}
 	}
-	
+
 }

Modified: branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/GCVoteImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -28,21 +28,16 @@
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.Common;
-import CacheWolf.HttpConnection;
 import CacheWolf.MyLocale;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
-import CacheWolf.imp.SpiderGC.SpiderProperties;
-import ewe.io.IOException;
-import ewe.io.JavaUtf8Codec;
+import CacheWolf.UrlFetcher;
 import ewe.io.Reader;
 import ewe.io.StringReader;
-import ewe.net.Socket;
 import ewe.sys.Handle;
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
 import ewe.ui.ProgressBarForm;
-import ewe.util.CharArray;
 import ewesoft.xml.MinML;
 import ewesoft.xml.sax.AttributeList;
 
@@ -58,19 +53,15 @@
 	private String GCVWaypoints;
 	private String GCVResults;
 	private static Preferences pref;
-	private static SpiderProperties p=null;
 
 	/**
 	*	Constructor initalizing profile and cacheDB
 	*/
-	public GCVoteImporter(Preferences prf, Profile _profile, boolean bypass){
+	public GCVoteImporter(Preferences prf, Profile _profile){
 		this.profile=_profile;
 		this.cacheDB = profile.cacheDB;
 		pref = prf;
-		if (p == null) {
-			pref.logInit();
-		}
-		// initialiseProperties();
+		// pref.logInit();
 	}
 
 	/**
@@ -108,9 +99,7 @@
 
 			try {
 				pref.log(&quot;[GCVote]:Requesting ratings&quot;);
-
-				// request web page <A HREF="http://gcvote.de/getVotes.php">http://gcvote.de/getVotes.php</A>
-				GCVResults = getResponse(GCVURL);
+				GCVResults = UrlFetcher.fetch(GCVURL);
 				if (GCVResults.equals(&quot;&quot;)) {
 					(new MessageBox(MyLocale.getMsg(0,&quot;Error&quot;), MyLocale.getMsg(0,&quot;Error loading GCVote page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 					pref.log(&quot;[GCVote]:Could not fetch: getVotes.php page&quot;,null);
@@ -143,34 +132,4 @@
 			cb.setNumRecommended( 100*voteCnt + (int)(voteAvg + 0.5));
 		}
 	}
-
-	/**
-	*	Perform an request to fetch the GCVote results
-	*/
-	public static String getResponse(String address) {
-		CharArray c_data;
-		try{
-			HttpConnection conn;
-			if(pref.myproxy.length() &gt; 0 &amp;&amp; pref.proxyActive){
-				pref.log(&quot;[GCVote]:Using proxy: &quot; + pref.myproxy + &quot; / &quot; +pref.myproxyport);
-			}
-			conn = new HttpConnection(address);
-			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (compatible; Cachewolf; GCVoteImporter)&quot;);
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			conn.documentIsEncoded = true;
-			pref.log(&quot;[GCVote]:Connecting &quot;+address);
-			Socket sock = conn.connect();
-			pref.log(&quot;[GCVote]:Connect ok! &quot;+address);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			c_data = conn.readText(sock, codec);
-			sock.close();
-			pref.log(&quot;[GCVote]:Read data ok &quot;+address);
-			return c_data.toString();
-		}catch(IOException ioex){
-			pref.log(&quot;IOException in fetch&quot;, ioex);
-		}finally{
-			//continue
-		}
-		return &quot;&quot;;
-	}
 }

Modified: branches/r1.2/src/CacheWolf/imp/GPXImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/GPXImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/GPXImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,32 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-import com.stevesoft.ewe_pat.Regex;
-
+import CacheWolf.Attribute;
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheSize;
@@ -35,20 +34,31 @@
 import CacheWolf.Common;
 import CacheWolf.Extractor;
 import CacheWolf.Filter;
+import CacheWolf.ImageInfo;
 import CacheWolf.InfoBox;
 import CacheWolf.Log;
 import CacheWolf.MyLocale;
+import CacheWolf.OC;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
 import CacheWolf.STRreplace;
 import CacheWolf.SafeXML;
 import CacheWolf.Travelbug;
+import CacheWolf.UrlFetcher;
 import CacheWolf.imp.SpiderGC.SpiderProperties;
+import CacheWolf.navi.TrackPoint;
+import CacheWolf.utils.FileBugfix;
+
+import com.stevesoft.ewe_pat.Regex;
+
+import ewe.io.File;
 import ewe.io.FileInputStream;
+import ewe.io.IOException;
+import ewe.net.MalformedURLException;
+import ewe.net.URL;
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
-import ewe.ui.MessageBox;
 import ewe.util.Enumeration;
 import ewe.util.Vector;
 import ewe.util.zip.ZipEntry;
@@ -58,12 +68,12 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
-*	Class to import Data from an GPX File. If cache data exists, the data from 
-*	the GPX-File is ignored.
-*	Class ID = 4000
-*/
+ * Class to import Data from an GPX File. If cache data exists, the data from
+ * the GPX-File is ignored.
+ * Class ID = 4000
+ */
 public class GPXImporter extends MinML {
-	
+
 	static Preferences pref;
 	Profile profile;
 	CacheDB cacheDB;
@@ -72,7 +82,7 @@
 	boolean inWpt, inCache, inLogs, inBug;
 	public XMLElement document;
 	private Vector files = new Vector();
-	private boolean debugGPX = false; 
+	private boolean debugGPX = false;
 	InfoBox infB;
 	boolean spiderOK = true;
 	boolean doSpider = false;
@@ -88,16 +98,17 @@
 	SpiderProperties propsSpider;
 	StringBuffer strBuf;
 	private int doitHow;
-	
-	public GPXImporter(Preferences p, Profile prof, String f )
-	{
-		profile=prof;
+	private String attID;
+	private String attInc;
+
+	public GPXImporter(Preferences p, Profile prof, String f) {
+		profile = prof;
 		pref = p;
 		cacheDB = profile.cacheDB;
-		//file = f;
+		// file = f;
 		files.add(f);
 		saveDir = profile.dataDir;
-		//msgA = msgArea;
+		// msgA = msgArea;
 		inWpt = false;
 		inCache = false;
 		inLogs = false;
@@ -105,17 +116,19 @@
 		doitHow = DOIT_ASK;
 	}
 
-	public void doIt(int how){
+	public void doIt(int how) {
 		doitHow = how;
 		Filter flt = new Filter();
-		boolean wasFiltered = (profile.getFilterActive()==Filter.FILTER_ACTIVE);
+		boolean wasFiltered = (profile.getFilterActive() == Filter.FILTER_ACTIVE);
 		flt.clearFilter();
-		try{
+		try {
 			ewe.io.Reader r;
 			String file;
 			if (how == DOIT_ASK) {
-				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510,&quot;Spider Options&quot;), OCXMLImporterScreen.IMAGES| OCXMLImporterScreen.ISGC);
-				if (options.execute() == FormBase.IDCANCEL) { return; }
+				OCXMLImporterScreen options = new OCXMLImporterScreen(MyLocale.getMsg(5510, &quot;Spider Options&quot;), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ISGC);
+				if (options.execute() == FormBase.IDCANCEL) {
+					return;
+				}
 				doSpider = options.imagesCheckBox.getState();
 				options.close(0);
 			} else if (how == DOIT_NOSPOILER) {
@@ -124,28 +137,27 @@
 				doSpider = true;
 			}
 			if (doSpider) {
-				imgSpider = new SpiderGC(pref, profile, false);
+				imgSpider = new SpiderGC(pref, profile);
 				doitHow = DOIT_WITHSPOILER;
 			} else {
 				doitHow = DOIT_NOSPOILER;
 			}
-			
+
 			Vm.showWait(true);
-			for (int i=0; i&lt;files.size();i++){
-				//Test for zip.file
-				file = (String)files.get(i);
-				if (file.indexOf(&quot;.zip&quot;) &gt; 0){
-					ZipFile zif = new ZipFile (file);
+			for (int i = 0; i &lt; files.size(); i++) {
+				// Test for zip.file
+				file = (String) files.get(i);
+				if (file.indexOf(&quot;.zip&quot;) &gt; 0) {
+					ZipFile zif = new ZipFile(file);
 					ZipEntry zipEnt;
 					Enumeration zipEnum = zif.entries();
 					// there could be more than one file in the archive
-					while (zipEnum.hasMoreElements())
-					{
+					while (zipEnum.hasMoreElements()) {
 						zipEnt = (ZipEntry) zipEnum.nextElement();
 						// skip over PRC-files
-						if (zipEnt.getName().endsWith(&quot;gpx&quot;)){
+						if (zipEnt.getName().endsWith(&quot;gpx&quot;)) {
 							r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
-							infB = new InfoBox(zipEnt.toString(),(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+							infB = new InfoBox(zipEnt.toString(), (MyLocale.getMsg(4000, &quot;Loaded caches: &quot;) + zaehlerGel));
 							infB.exec();
 							if (r.read() != 65279)
 								r = new ewe.io.InputStreamReader(zif.getInputStream(zipEnt));
@@ -154,11 +166,11 @@
 							infB.close(0);
 						}
 					}
-				}
-				else {
+					zif.close();
+				} else {
 					FileInputStream rFIS = new ewe.io.FileInputStream(file);
 					r = new ewe.io.InputStreamReader(rFIS);
-					infB = new InfoBox(&quot;Info&quot;,(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel));
+					infB = new InfoBox(&quot;Info&quot;, (MyLocale.getMsg(4000, &quot;Loaded caches: &quot;) + zaehlerGel));
 					infB.show();
 					if (r.read() != 65279) {
 						r.close();
@@ -171,47 +183,59 @@
 					rFIS.close();
 					infB.close(0);
 				}
-				// save Index 
-				profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+				// save Index
+				profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 				infB.close(0);
 			}
-				Vm.showWait(false);
-			}catch(Exception e){
-				pref.log(&quot;[GPXExporter:DoIt]&quot;,e,true);
-				Vm.showWait(false);
+			Vm.showWait(false);
+		} catch (Exception e) {
+			if (holder.getWayPoint().length() &gt; 0) {
+				pref.log(&quot;[GPXImporter:DoIt] &quot; + holder.getWayPoint() + &quot; LogID=&quot; + logId, e, true);
+			} else {
+				pref.log(&quot;[GPXImporter:DoIt] &quot; + holder.getPos().toString() + &quot; LogID=&quot; + logId, e, true);
 			}
-		if(wasFiltered){
+			infB.close(0);
+			Vm.showWait(false);
+		}
+		if (wasFiltered) {
 			flt.setFilter();
 			flt.doFilter();
 		}
 	}
-	public void startElement(String name, AttributeList atts){
-		strBuf=new StringBuffer(300);
-		if(infB.isClosed)  return;
-		if (name.equals(&quot;gpx&quot;)){
+
+	public void startElement(String name, AttributeList atts) {
+		strBuf = new StringBuffer(300);
+		if (infB.isClosed)
+			return;
+		if (name.equals(&quot;gpx&quot;)) {
 			// check for opencaching
-			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;)&gt; 0) fromOC = true;
-			else fromOC = false;
-			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;)) fromTC = true;
-			else fromTC = false;
+			if (atts.getValue(&quot;creator&quot;).indexOf(&quot;opencaching&quot;) &gt; 0)
+				fromOC = true;
+			else
+				fromOC = false;
+			if (atts.getValue(&quot;creator&quot;).startsWith(&quot;TerraCaching&quot;))
+				fromTC = true;
+			else
+				fromTC = false;
 
-			if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001, &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
+			// if (fromOC &amp;&amp; doSpider) (new MessageBox(&quot;Warnung&quot;, MyLocale.getMsg(4001,
+			// &quot;GPX files from opencaching don't contain information of images, they cannot be laoded. Best you get caches from opencaching by menu /Application/Import/Download from Opencaching&quot;), FormBase.OKB)).execute();
 			zaehlerGel = 0;
 		}
 		if (name.equals(&quot;wpt&quot;)) {
 			holder = new CacheHolder();
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)),Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;))));
 			inWpt = true;
 			inLogs = false;
 			inBug = false;
 			nameFound = false;
 			zaehlerGel++;
-			infB.setInfo(MyLocale.getMsg(4000,&quot;Loaded caches: &quot;) + zaehlerGel);
+			infB.setInfo(MyLocale.getMsg(4000, &quot;Loaded caches: &quot;) + zaehlerGel);
+			logId = &quot;&quot;;
 			return;
 		}
-		
-		if (name.equals(&quot;link&quot;)&amp;&amp; inWpt){
+
+		if (name.equals(&quot;link&quot;) &amp;&amp; inWpt) {
 			holder.getCacheDetails(false).URL = atts.getValue(&quot;href&quot;);
 			return;
 		}
@@ -220,42 +244,51 @@
 			inCache = true;
 			holder.setAvailable(atts.getValue(&quot;available&quot;).equals(&quot;True&quot;));
 			holder.setArchived(atts.getValue(&quot;archived&quot;).equals(&quot;True&quot;));
+			// OC now has GC - Format, get CacheID -- missing p.ex. on GcTour gpx
+			for (int i = 0; i &lt; atts.getLength(); i++) {
+				if (atts.getName(i).equals(&quot;id&quot;)) {
+					holder.setOcCacheID(atts.getValue(&quot;id&quot;));
+					break;
+				}
+			}
 			return;
 		}
 		// OC
-		if (name.equals(&quot;geocache&quot;)|| name.equals(&quot;cache&quot;)) {
+		if (name.equals(&quot;geocache&quot;) || name.equals(&quot;cache&quot;)) {
 			boolean available = false;
-			boolean archived  = false;
-			inCache=true;
+			boolean archived = false;
+			inCache = true;
 			// get CacheID -- missing p.ex. on GcTour gpx
 			for (int i = 0; i &lt; atts.getLength(); i++) {
 				if (atts.getName(i).equals(&quot;id&quot;)) {
-					String ocCacheID = atts.getValue(&quot;id&quot;);
-					holder.setOcCacheID(ocCacheID);
+					holder.setOcCacheID(atts.getValue(&quot;id&quot;));
 					break;
 				}
 			}
 			// get status
-			String status = new String(atts.getValue(&quot;status&quot;));
-			if (status.equals(&quot;Available&quot;)) available = true;
-			else if (status.equals(&quot;Unavailable&quot;)) available = false;
-			else if (status.equals(&quot;Draft&quot;)) available = false;
-			else if (status.equals(&quot;Archived&quot;)) archived = true;
+			String status = atts.getValue(&quot;status&quot;);
+			if (status.equals(&quot;Available&quot;))
+				available = true;
+			else if (status.equals(&quot;Unavailable&quot;))
+				available = false;
+			else if (status.equals(&quot;Draft&quot;))
+				available = false;
+			else if (status.equals(&quot;Archived&quot;))
+				archived = true;
 			holder.setArchived(archived);
 			holder.setAvailable(available);
 			return;
 		}
-		
+
 		if (name.equals(&quot;terra:terracache&quot;)) {
-			inCache=true;
+			inCache = true;
 		}
 
-		
 		if (name.indexOf(&quot;long_description&quot;) &gt; -1) {
 			holder.setHTML(atts.getValue(&quot;html&quot;).toLowerCase().equals(&quot;true&quot;));
 		}
-		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;) ) {
-			//set HTML always to true if from oc.de or TC
+		if (name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;)) {
+			// set HTML always to true if from oc.de or TC
 			holder.setHTML(true);
 		}
 
@@ -273,105 +306,105 @@
 			holder.getCacheDetails(false).Travelbugs.clear();
 			return;
 		}
-		if (debugGPX){
+		if (name.equals(&quot;groundspeak:attribute&quot;)) {
+			attID = atts.getValue(&quot;id&quot;);
+			attInc = atts.getValue(&quot;inc&quot;);
+			return;
+		}
+		if (debugGPX) {
 			for (int i = 0; i &lt; atts.getLength(); i++) {
-				pref.log(&quot;[GPXExporter:startElement]Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i),null);
+				pref.log(&quot;[GPXExporter:startElement]Type: &quot; + atts.getType(i) + &quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i), null);
 			}
-		}	
-		if (name.equals(&quot;groundspeak:attribute&quot;)) {
-			int id = Integer.parseInt(atts.getValue(&quot;id&quot;));
-			holder.getCacheDetails(false).attributes.add(id,atts.getValue(&quot;inc&quot;)); // from GC!
-			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
+		}
+	}
+
+	public void endElement(String name) {
+		strData = strBuf.toString();
+		if (infB.isClosed)
 			return;
-		}		
-	}
-	
-	public void endElement(String name){
-		strData=strBuf.toString();
-		if(infB.isClosed) return;
 		// logs
-		if (inLogs){
-			if (name.equals(&quot;groundspeak:date&quot;)|| name.equals(&quot;time&quot;)|| name.equals(&quot;date&quot;)|| name.equals(&quot;terra:date&quot;))  {
-				logDate = new String(strData.substring(0,10));
+		if (inLogs) {
+			if (name.equals(&quot;groundspeak:date&quot;) || name.equals(&quot;time&quot;) || name.equals(&quot;date&quot;) || name.equals(&quot;terra:date&quot;)) {
+				logDate = new String(strData.substring(0, 10));
 				return;
 			}
-			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)){
+			if (name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:type&quot;)) {
 				logIcon = new String(Log.typeText2Image(strData));
 				return;
 			}
-			if (name.equals(&quot;groundspeak:finder&quot;)|| name.equals(&quot;geocacher&quot;)|| name.equals(&quot;finder&quot;)|| name.equals(&quot;terra:user&quot;)){
+			if (name.equals(&quot;groundspeak:finder&quot;) || name.equals(&quot;geocacher&quot;) || name.equals(&quot;finder&quot;) || name.equals(&quot;terra:user&quot;)) {
 				logFinder = new String(strData);
 				return;
 			}
-			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)){ 
+			if (name.equals(&quot;groundspeak:text&quot;) || name.equals(&quot;text&quot;) || name.equals(&quot;terra:entry&quot;)) {
 				logData = new String(strData);
 				return;
 			}
-			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;) ) {
-				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon,logDate,logFinder,logData));
-				if((logIcon.equals(&quot;icon_smile.gif&quot;) || logIcon.equals(&quot;icon_camera.gif&quot;) || logIcon.equals(&quot;icon_attended.gif&quot;)) &amp;&amp; 
-						  (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
-							holder.setCacheStatus(logDate);
-							holder.setFound(true);
-							holder.getCacheDetails(false).OwnLogId = logId;
-							holder.getCacheDetails(false).OwnLog = new Log(logIcon,logDate,logFinder,logData);
+			if (name.equals(&quot;groundspeak:log&quot;) || name.equals(&quot;log&quot;) || name.equals(&quot;terra:log&quot;)) {
+				holder.getCacheDetails(false).CacheLogs.add(new Log(logIcon, logDate, logFinder, logData));
+				if ((logIcon.equals(&quot;icon_smile.gif&quot;) || logIcon.equals(&quot;icon_camera.gif&quot;) || logIcon.equals(&quot;icon_attended.gif&quot;))
+						&amp;&amp; (SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() &gt; 0 &amp;&amp; SafeXML.cleanback(logFinder).equalsIgnoreCase(pref.myAlias2)))) {
+					holder.setCacheStatus(logDate);
+					holder.setFound(true);
+					holder.getCacheDetails(false).OwnLogId = logId;
+					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData);
 				}
 				return;
 			}
 		}
-		
-		if (name.equals(&quot;wpt&quot;)){
-			
-			int index=cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){// Add cache Data only, if waypoint not already in database
+
+		if (name.equals(&quot;wpt&quot;)) {
+
+			int index = cacheDB.getIndex(holder.getWayPoint());
+			if (index == -1) {// Add cache Data only, if waypoint not already in database
 				holder.setNoFindLogs(holder.getCacheDetails(false).CacheLogs.countNotFoundLogs());
 				holder.setNew(true);
 				cacheDB.add(holder);
 				// don't spider additional waypoints, so check
 				// if waypoint starts with &quot;GC&quot;
-				if(doSpider) {
-					if(spiderOK &amp;&amp; holder.is_archived() == false){
-							if(holder.getLatLon().length() &gt; 1){
+				if (doSpider) {
+					if (spiderOK &amp;&amp; holder.is_archived() == false) {
+						// spiderImages();
+						spiderImagesUsingSpider();
+						// Rename image sources
+						String text;
+						String orig;
+						String imgName;
+						orig = holder.getCacheDetails(false).LongDescription;
+
+						Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
+						int num = 0;
+						while ((text = ex.findNext()).length() &gt; 0 &amp;&amp; spiderOK) {
+							if (num &gt;= holder.getCacheDetails(false).images.size())
+								break;
+							imgName = holder.getCacheDetails(false).images.get(num).getTitle();
+							holder.getCacheDetails(false).LongDescription = STRreplace.replace(holder.getCacheDetails(false).LongDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
+							num++;
 						}
-						if(holder.getWayPoint().startsWith(&quot;GC&quot;)|| fromTC) {
-							//spiderImages();
-							spiderImagesUsingSpider();
-							//Rename image sources
-							String text;
-							String orig;
-							String imgName;
-							orig = holder.getCacheDetails(false).LongDescription;
-							Extractor ex = new Extractor(orig, &quot;&lt;img src=\&quot;&quot;, &quot;&gt;&quot;, 0, false);
-							text = ex.findNext();
-							int num = 0;
-							while(ex.endOfSearch() == false &amp;&amp; spiderOK){
-								if (num &gt;= holder.getCacheDetails(false).images.size())break;
-								imgName = holder.getCacheDetails(false).images.get(num).getTitle();
-								holder.getCacheDetails(false).LongDescription = STRreplace.replace(holder.getCacheDetails(false).LongDescription, text, &quot;[[Image: &quot; + imgName + &quot;]]&quot;);
-								num++;
-								text = ex.findNext();
-							}
-						}
 					}
 				}
 				holder.save();
-				//crw.saveIndex(cacheDB,saveDir);
+				// crw.saveIndex(cacheDB,saveDir);
 			}
-			//Update cache data
+			// Update cache data
 			else {
-				CacheHolder oldCh= cacheDB.get(index);
+				CacheHolder oldCh = cacheDB.get(index);
 				// Preserve images: Copy images from old cache version because here we didn't add
 				// any image information to the holder object.
-				holder.getCacheDetails(false).images = oldCh.getCacheDetails(true).images;
+				if (pref.downloadPics &amp;&amp; holder.isOC()) {
+					spiderImagesUsingSpider();
+				} else {
+					holder.getCacheDetails(false).images = oldCh.getCacheDetails(true).images;
+				}
 				oldCh.initStates(false);
 				oldCh.update(holder);
 				oldCh.save();
 			}
-			
+
 			inWpt = false;
 			return;
 		}
-		if (name.equals(&quot;sym&quot;)&amp;&amp; strData.endsWith(&quot;Found&quot;)) {
+		if (name.equals(&quot;sym&quot;) &amp;&amp; strData.endsWith(&quot;Found&quot;)) {
 			holder.setFound(true);
 			holder.setCacheStatus(holder.getFoundText());
 			return;
@@ -381,88 +414,86 @@
 			return;
 		}
 
-		if (name.equals(&quot;groundspeak:name&quot;)&amp;&amp; inBug) {
-			Travelbug tb=new Travelbug(strData);
+		if (name.equals(&quot;groundspeak:name&quot;) &amp;&amp; inBug) {
+			Travelbug tb = new Travelbug(strData);
 			holder.getCacheDetails(false).Travelbugs.add(tb);
 			holder.setHas_bugs(true);
 			return;
 		}
-		
-		if (name.equals(&quot;time&quot;) &amp;&amp; !inWpt) {		    
+
+		if (name.equals(&quot;time&quot;) &amp;&amp; !inWpt) {
 			try {
-			    gpxDate.parse(strData.substring(0,19),&quot;yyyy-MM-dd'T'HH:mm:ss&quot;);
+				gpxDate.parse(strData.substring(0, 19), &quot;yyyy-MM-dd'T'HH:mm:ss&quot;);
 			} catch (IllegalArgumentException e) {
-			    gpxDate.setTime(0);
-			    pref.log(&quot;[GPXImporter:endElement]Error parsing Element time: '&quot;+strData+&quot;'. Ignoring.&quot;);
+				gpxDate.setTime(0);
+				pref.log(&quot;[GPXImporter:endElement]Error parsing Element time: '&quot; + strData + &quot;'. Ignoring.&quot;);
 			}
 			return;
 		}
 
 		if (name.equals(&quot;time&quot;) &amp;&amp; inWpt) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
 		// cache information
-		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;)|| name.equals(&quot;cache&quot;)|| name.equals(&quot;terra:terracache&quot;)) {
+		if (name.equals(&quot;groundspeak:cache&quot;) || name.equals(&quot;geocache&quot;) || name.equals(&quot;cache&quot;) || name.equals(&quot;terra:terracache&quot;)) {
 			inCache = false;
 		}
-		
+
 		if (name.equals(&quot;name&quot;) &amp;&amp; inWpt &amp;&amp; !inCache) {
 			holder.setWayPoint(strData);
-			if (gpxDate.getTime()!=0) {
-			    holder.setLastSync(gpxDate.format(&quot;yyyyMMddHHmmss&quot;));
+			if (gpxDate.getTime() != 0) {
+				holder.setLastSync(gpxDate.format(&quot;yyyyMMddHHmmss&quot;));
 			} else {
-			    holder.setLastSync(&quot;&quot;);
-			}    
-			//msgA.setText(&quot;import &quot; + strData);
+				holder.setLastSync(&quot;&quot;);
+			}
+			// msgA.setText(&quot;import &quot; + strData);
 			return;
 		}
 
 		// fill name with contents of &lt;desc&gt;, in case of gc.com the name is
 		// later replaced by the contents of &lt;groundspeak:name&gt; which is shorter
-		if (name.equals(&quot;desc&quot;)&amp;&amp; inWpt ) {
+		if (name.equals(&quot;desc&quot;) &amp;&amp; inWpt) {
 			holder.setCacheName(strData);
-			//msgA.setText(&quot;import &quot; + strData);
+			// msgA.setText(&quot;import &quot; + strData);
 			return;
 		}
-		if (name.equals(&quot;url&quot;)&amp;&amp; inWpt){
+		if (name.equals(&quot;url&quot;) &amp;&amp; inWpt) {
 			holder.getCacheDetails(false).URL = strData;
 			return;
 		}
-		
+
 		// Text for additional waypoints, no HTML
-		if (name.equals(&quot;cmt&quot;)&amp;&amp; inWpt){
+		if (name.equals(&quot;cmt&quot;) &amp;&amp; inWpt) {
 			holder.getCacheDetails(false).LongDescription = strData;
 			holder.setHTML(false);
 			return;
 		}
-		
+
 		// aditional wapypoint
-		if (name.equals(&quot;type&quot;)&amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)){
+		if (name.equals(&quot;type&quot;) &amp;&amp; inWpt &amp;&amp; !inCache &amp;&amp; strData.startsWith(&quot;Waypoint&quot;)) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
 			holder.setHard(CacheTerrDiff.CW_DT_UNSET);
 			holder.setTerrain(CacheTerrDiff.CW_DT_UNSET);
 			holder.setLastSync(&quot;&quot;);
 		}
-		
-		if (name.indexOf(&quot;name&quot;)&gt;-1 &amp;&amp; inCache) {
+
+		if (name.indexOf(&quot;name&quot;) &gt; -1 &amp;&amp; inCache) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;)||name.equals(&quot;terra:owner&quot;)) {
+		if (name.equals(&quot;groundspeak:owner&quot;) || name.equals(&quot;owner&quot;) || name.equals(&quot;terra:owner&quot;)) {
 			holder.setCacheOwner(strData);
-			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-				(pref.myAlias2.length()&gt;0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+			if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
 				holder.setOwned(true);
 			return;
 		}
 		if (name.equals(&quot;groundspeak:placed_by&quot;)) {
-			if(holder.getCacheOwner().equals(&quot;&quot;)) {
+			if (holder.getCacheOwner().equals(&quot;&quot;)) {
 				holder.setCacheOwner(strData);
-				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || 
-						(pref.myAlias2.length()&gt;0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
-						holder.setOwned(true);
+				if (pref.myAlias.equals(SafeXML.cleanback(strData)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; SafeXML.cleanback(strData).equalsIgnoreCase(pref.myAlias2)))
+					holder.setOwned(true);
 			}
 			return;
 		}
@@ -470,11 +501,11 @@
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if (name.equals(&quot;groundspeak:terrain&quot;)|| name.equals(&quot;terrain&quot;)|| name.equals(&quot;terra:physical_challenge&quot;)) {
+		if (name.equals(&quot;groundspeak:terrain&quot;) || name.equals(&quot;terrain&quot;) || name.equals(&quot;terra:physical_challenge&quot;)) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;)|| name.equals(&quot;terra:style&quot;))&amp;&amp; inCache){
+		if ((name.equals(&quot;groundspeak:type&quot;) || name.equals(&quot;type&quot;) || name.equals(&quot;terra:style&quot;)) &amp;&amp; inCache) {
 			holder.setType(CacheType.gpxType2CwType(strData));
 			if (holder.isCustomWpt()) {
 				holder.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
@@ -483,95 +514,258 @@
 			}
 			return;
 		}
-		if (name.equals(&quot;groundspeak:container&quot;)|| name.equals(&quot;container&quot;)){
+		if (name.equals(&quot;groundspeak:container&quot;) || name.equals(&quot;container&quot;)) {
 			holder.setCacheSize(CacheSize.gcGpxString2Cw(strData));
 			return;
 		}
-		if (name.equals(&quot;groundspeak:country&quot;)|| name.equals(&quot;country&quot;)){
+		if (name.equals(&quot;groundspeak:country&quot;) || name.equals(&quot;country&quot;)) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
-		if (name.equals(&quot;groundspeak:state&quot;)|| name.equals(&quot;state&quot;)){
+		if (name.equals(&quot;groundspeak:state&quot;) || name.equals(&quot;state&quot;)) {
 			holder.getCacheDetails(false).State = strData;
 			return;
 		}
-		if (name.equals(&quot;terra:size&quot;)){
+		if (name.equals(&quot;terra:size&quot;)) {
 			holder.setCacheSize(CacheSize.tcGpxString2Cw(strData));
 		}
 
-		if (name.indexOf(&quot;short_description&quot;) &gt; -1|| name.equals(&quot;summary&quot;)) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription =SafeXML.cleanback(strData)+&quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
-			else holder.getCacheDetails(false).LongDescription =strData+&quot;\n&quot;;
+		if (name.indexOf(&quot;short_description&quot;) &gt; -1 || name.equals(&quot;summary&quot;)) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription = SafeXML.cleanback(strData) + &quot;&lt;br&gt;&quot;; // &lt;br&gt; needed because we also use a &lt;br&gt; in SpiderGC. Without it the comparison in ch.update fails
+			else
+				holder.getCacheDetails(false).LongDescription = strData + &quot;\n&quot;;
 			return;
 		}
 
-		if (name.indexOf(&quot;long_description&quot;) &gt; -1 || name.equals(&quot;description&quot;)|| name.equals(&quot;terra:description&quot;)) {
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.indexOf(&quot;long_description&quot;) &gt; -1 || name.equals(&quot;description&quot;) || name.equals(&quot;terra:description&quot;)) {
+			if (holder.is_HTML())
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
 		if (name.indexOf(&quot;encoded_hints&quot;) &gt; -1 || name.equals(&quot;hints&quot;)) {
-			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData),&quot;\n&quot;,&quot;&lt;br&gt;&quot;),&quot;\t&quot;,&quot;&quot;);
+			holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData), &quot;\n&quot;, &quot;&lt;br&gt;&quot;), &quot;\t&quot;, &quot;&quot;);
 			return;
 		}
-		
+
 		if (name.equals(&quot;terra:hint&quot;)) {
 			// remove &quot;&lt;br&gt;&lt;br&gt;&quot; from the end
 			int indexTrash = strData.indexOf(&quot;&lt;br&gt;&lt;br&gt;&quot;);
-			if (indexTrash &gt; 0)	holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0,indexTrash)),&quot;\n&quot;,&quot;&lt;br&gt;&quot;),&quot;\t&quot;,&quot;&quot;);
+			if (indexTrash &gt; 0)
+				holder.getCacheDetails(false).Hints = STRreplace.replace(STRreplace.replace(Common.rot13(strData.substring(0, indexTrash)), &quot;\n&quot;, &quot;&lt;br&gt;&quot;), &quot;\t&quot;, &quot;&quot;);
 			return;
 		}
 
+		if (name.equals(&quot;groundspeak:attribute&quot;)) {
+			if (attID.equals(&quot;&quot;)) {
+				attID = Attribute.getIdFromGCText(strData);
+			}
+			int id = Integer.parseInt(attID);
+			holder.getCacheDetails(false).attributes.add(id, attInc);
+			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
+			return;
+		}
 
 	}
-	public void characters(char[] ch,int start,int length){
-		strBuf.append(ch,start,length);
-		if (debugGPX) pref.log(&quot;Char: &quot; + strBuf.toString(),null);
+
+	public void characters(char[] ch, int start, int length) {
+		strBuf.append(ch, start, length);
+		if (debugGPX)
+			pref.log(&quot;Char: &quot; + strBuf.toString(), null);
 	}
-	
-	public static String TCSizetoText(String size){
-		if (size.equals(&quot;1&quot;)) return &quot;Micro&quot;;
-		if (size.equals(&quot;2&quot;)) return &quot;Medium&quot;;
-		if (size.equals(&quot;3&quot;)) return &quot;Regular&quot;;
-		if (size.equals(&quot;4&quot;)) return &quot;Large&quot;;
-		if (size.equals(&quot;5&quot;)) return &quot;Very Large&quot;;
 
+	public static String TCSizetoText(String size) {
+		if (size.equals(&quot;1&quot;))
+			return &quot;Micro&quot;;
+		if (size.equals(&quot;2&quot;))
+			return &quot;Medium&quot;;
+		if (size.equals(&quot;3&quot;))
+			return &quot;Regular&quot;;
+		if (size.equals(&quot;4&quot;))
+			return &quot;Large&quot;;
+		if (size.equals(&quot;5&quot;))
+			return &quot;Very Large&quot;;
+
 		return &quot;None&quot;;
 	}
-	
-	private void spiderImagesUsingSpider(){
-		String addr;
+
+	private void spiderImagesUsingSpider() {
+		String addresse;
 		String cacheText;
-		
+
 		// just to be sure to have a spider object
-		if (imgSpider == null) imgSpider = new SpiderGC(pref, profile, false);
-		if (propsSpider == null) {propsSpider = imgSpider.new SpiderProperties();	}
-		
+		if (imgSpider == null)
+			imgSpider = new SpiderGC(pref, profile);
+		if (propsSpider == null) {
+			propsSpider = imgSpider.new SpiderProperties();
+		}
+
 		try {
-				if (fromTC) {
-						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
-				}
-				else {
-					addr = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + holder.getWayPoint() ;
-					cacheText = SpiderGC.fetchText(addr,false);
+			if (fromTC) {
+				imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+			} else {
+				if (fromOC) {
+					holder.getCacheDetails(false).images.clear();
+					addresse = holder.getCacheDetails(false).URL;
+					cacheText = UrlFetcher.fetch(addresse);
+					Extractor exBeschreibung = new Extractor(cacheText, &quot;&lt;!-- Beschreibung --&gt;&quot;, &quot;&lt;!-- End Beschreibung --&gt;&quot;, 0, false);
+					String beschreibung = exBeschreibung.findNext();
+					getOCPictures(beschreibung);
+					Extractor exBilder = new Extractor(cacheText, &quot;&lt;!-- Bilder --&gt;&quot;, &quot;&lt;!-- End Bilder --&gt;&quot;, 0, false);
+					String bilder = exBilder.findNext();
+					getOCPictures(bilder);
+				} else {
+					addresse = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + holder.getWayPoint();
+					cacheText = UrlFetcher.fetch(addresse);
 					if (cacheText.indexOf(propsSpider.getProp(&quot;premiumCachepage&quot;)) &gt; 0) {
 						// Premium cache spidered by non premium member
-						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false),false);
+						imgSpider.getImages(holder.getCacheDetails(false).LongDescription, holder.getCacheDetails(false), false);
+					} else {
+						imgSpider.getImages(cacheText, holder.getCacheDetails(false), true);
 					}
-					else {
-						imgSpider.getImages(cacheText, holder.getCacheDetails(false),true);
-					}
 					try {
 						imgSpider.getAttributes(cacheText, holder.getCacheDetails(false));
 					} catch (Exception e) {
-						pref.log(&quot;unable to fetch attrivbutes for&quot;+holder.getWayPoint(), e);
+						pref.log(&quot;unable to fetch attributes for&quot; + holder.getWayPoint(), e);
 					}
 				}
+			}
 		} catch (Exception e1) {
 			// e1.printStackTrace();
 		}
 	}
-	
+
+	private void getOCPictures(String html) {
+		Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;);
+		imgRegexUrl.setIgnoreCase(true);
+		int descIndex = 0;
+		while (imgRegexUrl.searchFrom(html, descIndex)) {
+			descIndex = imgRegexUrl.matchedTo();
+			String fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anf&#252;hrungszeichen in (2)
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			} // falls ohne in (3)
+			if (fetchUrl == null) {
+				continue;
+			} // schlechtes html
+				// fetchUrl ist auf jeden Fall ohne Anf&#252;hrungszeichen
+			if (fetchUrl.startsWith(&quot;resource&quot;))
+				continue; //
+			if (fetchUrl.startsWith(&quot;images&quot;)) // z.B. Flaggen
+				if (!fetchUrl.startsWith(&quot;images/uploads&quot;))
+					continue;
+			if (fetchUrl.startsWith(&quot;thumbs&quot;))
+				continue; // z.B. Flaggen
+			try {
+				// TODO this is not quite correct: actually the &quot;base&quot; URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
+				String hostname = OC.getOCHostName(holder.getWayPoint());
+				if (!fetchUrl.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) {
+					fetchUrl = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/&quot;), fetchUrl).toString();
+				}
+			} catch (MalformedURLException e) {
+				continue;
+			} // auch egal
+			ImageInfo imageInfo = new ImageInfo();
+			imageInfo.setURL(fetchUrl);
+			imageInfo.setTitle(makeTitle(imgRegexUrl.stringMatched(1), fetchUrl));
+			getPic(imageInfo);
+		}
+
+		Extractor exHref = new Extractor(html, &quot;&lt;a href=&quot;, &quot;&lt;/a&gt;&quot;, 0, true);
+		String href = &quot;&quot;;
+		Extractor exHttp = new Extractor(href, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while ((href = exHref.findNext()).length() &gt; 0) {
+			exHttp.set(href, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+			String fetchUrl = exHttp.findNext();
+			if (fetchUrl.length() &gt; 0) {
+				try {
+					String imgType = (fetchUrl.substring(fetchUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+					fetchUrl = &quot;<A HREF="http://">http://</A>&quot; + fetchUrl.substring(0, fetchUrl.lastIndexOf('.') + imgType.length());
+					if (imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+						ImageInfo imageInfo = new ImageInfo();
+						imageInfo.setURL(fetchUrl);
+						imageInfo.setTitle(makeTitle(href, fetchUrl));
+						getPic(imageInfo);
+					}
+				} catch (IndexOutOfBoundsException e) {
+				}
+			}
+		}
+	}
+
+	private String makeTitle(String imgTag, String fetchUrl) {
+		Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;);
+		imgRegexAlt.setIgnoreCase(true);
+		String imgAltText;
+		if (imgRegexAlt.search(imgTag)) {
+			imgAltText = imgRegexAlt.stringMatched(1);
+			if (imgAltText == null)
+				imgAltText = imgRegexAlt.stringMatched(2);
+		} else { // no alternative text as image title -&gt; use --- or filename
+			// wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+			if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0)
+				imgAltText = &quot;---&quot;; // no image title
+			else
+				imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
+		}
+		return imgAltText;
+	}
+
+	private void getPic(ImageInfo imageInfo) {
+		String fileName = holder.getWayPoint() + &quot;_&quot; + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
+		fileName = Common.ClearForFileName(fileName).toLowerCase();
+		String target = profile.dataDir + fileName;
+		imageInfo.setFilename(fileName);
+		try {
+			File ftest = new FileBugfix(target);
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
+				if (pref.downloadPics) {
+					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
+					ftest = new FileBugfix(target);
+					if (ftest.exists()) {
+						if (ftest.length() &gt; 0) {
+							holder.getCacheDetails(false).images.add(imageInfo);
+						} else {
+							ftest.delete();
+						}
+					}
+				}
+			}
+		} catch (IOException e) {
+			String ErrMessage;
+			String wp, n;
+			if (holder != null &amp;&amp; holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = &quot;WP???&quot;;
+			if (holder != null &amp;&amp; holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = &quot;name???&quot;;
+
+			if (e == null)
+				ErrMessage = &quot;Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: &quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
+			else {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) || e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) {
+					// is there a better way to find out what happened?
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;)&quot; + MyLocale.getMsg(1619, &quot;: could not download image from URL: &quot;) + imageInfo.getURL();
+				} else
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;): ignoring IOException: &quot; + e.getMessage() + &quot; while downloading picture:&quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
+			}
+			pref.log(ErrMessage, e, true);
+		}
+
+	}
+
 	public int getHow() {
 		return doitHow;
 	}

Modified: branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/LOCXMLImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
-
 import CacheWolf.CacheDB;
 import CacheWolf.CacheHolder;
 import CacheWolf.CacheSize;
@@ -34,6 +33,7 @@
 import CacheWolf.Common;
 import CacheWolf.Preferences;
 import CacheWolf.Profile;
+import CacheWolf.navi.TrackPoint;
 import ewe.io.FileReader;
 import ewe.io.Reader;
 import ewe.sys.Vm;
@@ -80,7 +80,7 @@
 	public void startElement(String name, AttributeList atts) {
 		if (debugXML) {
 			for (int i = 0; i &lt; atts.getLength(); i++) {
-				pref.log(&quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i),null);
+				pref.log(&quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i), null);
 			}
 		}
 		strData = &quot;&quot;;
@@ -89,8 +89,7 @@
 			return;
 		}
 		if (name.equals(&quot;coord&quot;)) {
-			holder.pos.set(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;)));
-			holder.setLatLon(holder.pos.toString());
+			holder.setPos(new TrackPoint(Common.parseDouble(atts.getValue(&quot;lat&quot;)), Common.parseDouble(atts.getValue(&quot;lon&quot;))));
 			return;
 		}
 	}
@@ -127,7 +126,7 @@
 		String chars = new String(ch, start, length);
 		strData += chars;
 		if (debugXML)
-			pref.log(strData,null);
+			pref.log(strData, null);
 	}
 
 	private CacheHolder getHolder(String wpt) {

Added: branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/imp/OCGPXfetch.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,82 @@
+package CacheWolf.imp;
+
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.Profile;
+import CacheWolf.UrlFetcher;
+import CacheWolf.utils.FileBugfix;
+import ewe.io.File;
+import ewe.io.IOException;
+import ewe.ui.FormBase;
+
+public class OCGPXfetch {
+	static Preferences pref = Global.getPref();
+	static Profile prof = Global.getProfile();;
+
+	public static void doIt() {
+		String hostname = pref.lastOCSite;
+		boolean oldDownloadAllOC = pref.downloadAllOC;
+		boolean onlyListedAtOC = false;
+		OCXMLImporterScreen importOpt = new OCXMLImporterScreen(MyLocale.getMsg(130, &quot;Download from opencaching&quot;), OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.ALL | OCXMLImporterScreen.HOST);
+		importOpt.missingCheckBox.setText(MyLocale.getMsg(164, &quot;only listed at OC&quot;));
+		importOpt.missingCheckBox.setState(onlyListedAtOC);
+		if (importOpt.execute() == FormBase.IDCANCEL) {
+			return;
+		}
+		onlyListedAtOC = pref.downloadAllOC;
+		pref.downloadAllOC = oldDownloadAllOC;
+		if (importOpt.domains.getSelectedItem() != null) {
+			hostname = (String) importOpt.domains.getSelectedItem();
+			pref.lastOCSite = hostname;
+		}
+
+		try {
+			String address = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/search.php?&quot;;
+			address += &quot;searchto=searchbyfinder&quot;; // searchbydistance
+			address += &quot;&amp;showresult=1&amp;expert=0&amp;sort=bydistance&amp;orderRatingFirst=0&quot;;
+			address += &quot;&amp;f_userowner=0&amp;f_userfound=0&amp;f_inactive=0&amp;f_ignored=0&quot;;
+			address += &quot;&amp;f_otherPlatforms=&quot;; // 0 = all 1 = nur OC
+			if (onlyListedAtOC)
+				address += &quot;1&quot;;
+			else
+				address += &quot;0&quot;;
+			address += &quot;&amp;country=&amp;difficultymin=0&amp;difficultymax=0&amp;terrainmin=0&amp;terrainmax=0&amp;cachetype=1;2;3;4;5;6;7;8;9;10&amp;cachesize=1;2;3;4;5;6;7&amp;cache_attribs=&amp;cache_attribs_not=&quot;;
+			address += &quot;&amp;logtype=1,7&quot;;
+			address += &quot;&amp;utf8=1&amp;output=gpx&amp;zip=1&quot;;
+			address += &quot;&amp;count=max&quot;;
+			address += &quot;&amp;finder=&quot; + pref.myAlias;
+			String tmpFile = prof.dataDir + &quot;dummy.zip&quot;;
+			login();
+			UrlFetcher.fetchDataFile(address, tmpFile);
+			File ftmp = new FileBugfix(tmpFile);
+			if (ftmp.exists() &amp;&amp; ftmp.length() &gt; 0) {
+				GPXImporter gpx = new GPXImporter(pref, prof, tmpFile);
+				if (pref.downloadPics)
+					gpx.doIt(GPXImporter.DOIT_WITHSPOILER);
+				else
+					gpx.doIt(GPXImporter.DOIT_NOSPOILER);
+			}
+			ftmp.delete();
+		} catch (IOException e) {
+		}
+	}
+
+	public static boolean login() {
+		// TODO this is only a preliminary Version of login
+		// todo for other opencaching sites
+		boolean loggedIn = false;
+		String page;
+		try {
+			String loginDaten = &quot;target=myhome.php&amp;action=login&amp;email=&quot; + pref.myAlias + &quot;&amp;password=&quot; + pref.password;
+			UrlFetcher.setpostData(loginDaten);
+			page = UrlFetcher.fetch(&quot;<A HREF="http://www.opencaching.de/login.php">http://www.opencaching.de/login.php</A>&quot;);
+			// final PropertyList pl = UrlFetcher.getDocumentProperties();
+			page = UrlFetcher.fetch(&quot;<A HREF="http://www.opencaching.de/myhome.php">http://www.opencaching.de/myhome.php</A>&quot;);
+			loggedIn = page.indexOf(&quot;Eingeloggt als&quot;) &gt; -1;
+		} catch (IOException e) {
+			pref.log(&quot;Fehler&quot;, e);
+		}
+		return loggedIn;
+	}
+}

Added: branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/imp/OCLinkImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,152 @@
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
+
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+package CacheWolf.imp;
+
+import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.Common;
+import CacheWolf.Extractor;
+import CacheWolf.Global;
+import CacheWolf.OC;
+import CacheWolf.SafeXML;
+import CacheWolf.UrlFetcher;
+import ewe.sys.Handle;
+import ewe.sys.Vm;
+import ewe.ui.ProgressBarForm;
+
+public final class OCLinkImporter {
+	private static CacheDB cacheDB = null;
+
+	public static void doIt() {
+
+		if (cacheDB == null)
+			cacheDB = Global.getProfile().cacheDB;
+		int totalWaypoints = cacheDB.countVisible();
+		int updated = 0;
+		ProgressBarForm pbf = new ProgressBarForm();
+		Handle h = new Handle();
+
+		pbf.showMainTask = false;
+		pbf.setTask(h, &quot;Import OC names ...&quot;);
+		pbf.exec();
+		if (OCGPXfetch.login()) {
+			for (int o = 0; o &lt; cacheDB.size(); o += 1) {
+				if (pbf.exitValue == -1)
+					break;
+				CacheHolder ch = cacheDB.get(o);
+				if (ch.isVisible()) {
+					updateOCLink(ch);
+					updated++;
+					h.progress = (float) updated / (float) totalWaypoints;
+					h.changed();
+				}
+			}
+		}
+		pbf.exit(0);
+	}
+
+	public static void updateOCLink(CacheHolder ch) {
+		// todo other OC sites
+		Vm.showWait(true);
+		boolean save = false;
+		String wp = ch.getWayPoint();
+		if (wp.startsWith(&quot;GC&quot;)) {
+			String wpName = ch.getOcCacheID();
+			if (wpName.length() &gt; 0) {
+				if (wpName.charAt(0) &lt; 65)
+					wp = wpName.substring(1);
+				else {
+					if (wpName.startsWith(&quot;OC&quot;)) // other OC sites
+						wp = wpName;
+				}
+				if (!wp.startsWith(&quot;OC&quot;)) {
+					// other OC sites
+					ch.setOcCacheID(&quot;&quot;); // there may be a value from gpx - import
+					save = true;
+				}
+			}
+			// other OC sites
+			String baseurl = &quot;<A HREF="http://">http://</A>&quot; + OC.getOCHostName(&quot;OC&quot;) + &quot;/map2.php?&quot;;
+			boolean hasOC = false;
+			try {
+				String url = baseurl + &quot;mode=wpsearch&amp;wp=&quot; + wp;
+				String result = UrlFetcher.fetch(url);
+				if (result.indexOf(&quot;wpoc=\&quot;&quot;) &gt; -1)
+					hasOC = true;
+				else {
+					// check over coordinates
+					// getting a cache next to the coordinates
+					String nLat = ch.getPos().getLatDeg(CWPoint.DD);
+					String nLon = ch.getPos().getLonDeg(CWPoint.DD);
+					url = baseurl + &quot;mode=locate&amp;lat=&quot; + nLat + &quot;&amp;lon=&quot; + nLon;
+					result = SafeXML.cleanback(UrlFetcher.fetch(url));
+					String ocCacheName = new Extractor(result, &quot;name=\&quot;&quot;, &quot;\&quot;&quot;, 0, true).findNext();
+					if (ch.getCacheName().equals(ocCacheName)) {
+						hasOC = true;
+					} else {
+						int start = result.indexOf(&quot;coords=\&quot;&quot;) + 8;
+						int lonend = result.indexOf(&quot;,&quot;, start);
+						int latend = result.indexOf(&quot;\&quot;&quot;, lonend);
+						double lon = Common.parseDouble(result.substring(start, lonend));
+						double lat = Common.parseDouble(result.substring(lonend + 1, latend));
+						boolean sameCoord = lon == ch.getPos().lonDec &amp;&amp; lat == ch.getPos().latDec;
+						if (sameCoord) {
+							start = result.indexOf(&quot;username=\&quot;&quot;) + 10;
+							int end = result.indexOf(&quot;\&quot;&quot;, start);
+							if (ch.getCacheOwner().toLowerCase().equals(result.substring(start, end).toLowerCase()))
+								hasOC = true;
+						}
+					}
+				}
+				if (hasOC) {
+					boolean found = false;
+					if (result.substring(result.indexOf(&quot;found=\&quot;&quot;) + 7).startsWith(&quot;1&quot;))
+						found = true;
+					int start = result.indexOf(&quot;wpoc=\&quot;&quot;) + 6;
+					if (start &gt; 5) {
+						int idend = result.indexOf(&quot;\&quot;&quot;, start);
+						String ocwp = result.substring(start, idend);
+						if (!found)
+							ocwp = &quot;-&quot; + ocwp;
+						if (!ocwp.equals(ch.getOcCacheID())) {
+							ch.setOcCacheID(ocwp);
+							save = true;
+						}
+					}
+				}
+				if (save)
+					ch.save();
+
+			} catch (Exception e) {
+				// dann halt nicht
+			}
+		}
+		// return ch;
+		Vm.showWait(false);
+	}
+
+}

Modified: branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/OCXMLImporter.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
 import CacheWolf.CWPoint;
@@ -41,6 +41,7 @@
 import CacheWolf.Profile;
 import CacheWolf.SafeXML;
 import CacheWolf.UrlFetcher;
+import CacheWolf.navi.TrackPoint;
 import CacheWolf.navi.TransformCoordinates;
 import CacheWolf.utils.FileBugfix;
 
@@ -48,7 +49,6 @@
 
 import ewe.io.BufferedReader;
 import ewe.io.File;
-import ewe.io.FileOutputStream;
 import ewe.io.IO;
 import ewe.io.IOException;
 import ewe.io.InputStreamReader;
@@ -60,8 +60,6 @@
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
-import ewe.util.ByteArray;
-import ewe.util.CharArray;
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.zip.ZipEntry;
@@ -71,11 +69,11 @@
 import ewesoft.xml.sax.AttributeList;
 
 /**
- *	Class to import Data from opencaching.
- *	It uses the lastmodified parameter to identify new or changed caches.
- *	See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
- *   See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
- *	for more information.
+ * Class to import Data from opencaching.
+ * It uses the lastmodified parameter to identify new or changed caches.
+ * See here: <A HREF="http://www.opencaching.com/phpBB2/viewtopic.php?t=281">http://www.opencaching.com/phpBB2/viewtopic.php?t=281</A> (out-dated)
+ * See here: <A HREF="http://www.opencaching.de/doc/xml/xml11.htm">http://www.opencaching.de/doc/xml/xml11.htm</A> and <A HREF="http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0">http://develforum.opencaching.de/viewtopic.php?t=135&amp;postdays=0&amp;postorder=asc&amp;start=0</A>
+ * for more information.
  */
 public class OCXMLImporter extends MinML {
 	static protected final int STAT_INIT = 0;
@@ -87,12 +85,13 @@
 	String hostname;
 
 	int state = STAT_INIT;
-	int numCacheImported, numDescImported, numLogImported= 0;
+	int numCacheImported, numDescImported, numLogImported = 0;
+	int numCacheUpdated, numDescUpdated, numLogUpdated = 0;
 
 	boolean debugGPX = false;
 	CacheDB cacheDB;
 	InfoBox inf;
-	//CacheHolder ch;
+	// CacheHolder ch;
 	CacheHolder holder;
 	Preferences pref;
 	Profile profile;
@@ -100,12 +99,13 @@
 	String strData = &quot;&quot;;
 	int picCnt;
 	boolean incUpdate = true; // complete or incremental Update
+	boolean incFinds = true;
 	Hashtable DBindexID = new Hashtable();
 
 	String picUrl = &quot;&quot;;
-	String picTitle =  &quot;&quot;;
-	String picID = new String();
-	String cacheID = new String();
+	String picTitle = &quot;&quot;;
+	String picID;
+	String cacheID;
 
 	String logData, logIcon, logDate, logFinder, logId;
 	boolean loggerRecommended;
@@ -116,116 +116,119 @@
 	double longitude;
 	/** Temporarly save the values from XML: set to the language of the description which is currently parsed */
 	String processingDescLang;
+	boolean isHTML;
+	boolean isSyncSingle; // to load archieved
 
-	public OCXMLImporter(Preferences p,Profile prof)
-	{
+	public OCXMLImporter(Preferences p, Profile prof) {
 		pref = p;
-		profile=prof;
+		profile = prof;
 		cacheDB = profile.cacheDB;
-		if(profile.getLast_sync_opencaching() == null ||
-				profile.getLast_sync_opencaching().length() &lt; 12){
+		incUpdate = true;
+		if (profile.getLast_sync_opencaching() == null || profile.getLast_sync_opencaching().length() &lt; 12) {
 			profile.setLast_sync_opencaching(&quot;20050801000000&quot;);
 			incUpdate = false;
 		}
 		user = p.myAlias.toLowerCase();
 		CacheHolder ch;
-		for(int i = 0; i&lt;cacheDB.size();i++){
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
 			if (!ch.getOcCacheID().equals(&quot;&quot;))
-				DBindexID.put(ch.getOcCacheID(), new Integer(i));
-		}//for
+				DBindexID.put(ch.getOcCacheID(), ch.getWayPoint());
+		}// for
 
 	}
 
 	/**
-	 *
+	 * 
 	 * @param number
 	 * @param infB
 	 * @return true, if some change was made to the cacheDB
 	 */
 	public boolean syncSingle(int number, InfoBox infB) {
+
 		CacheHolder ch;
 		ch = cacheDB.get(number);
-		hostname=OC.getOCHostName(ch.getWayPoint());
-		holder= null;
+		hostname = OC.getOCHostName(ch.getWayPoint());
+		holder = null;
 
 		if (infB.isClosed) {
 			// there could have been an update before
 			return true;
 		}
 
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from &quot; + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608, &quot;downloading data\n from &quot; + hostname), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
 		String lastS;
-		/** pref.downloadmissingOC = true, if not the last syncdate shall be used,
-		 *  but the caches shall be reloaded
-		 *  only used in syncSingle  */
-		if (pref.downloadMissingOC)  lastS = &quot;20050801000000&quot;;
+		/**
+		 * pref.downloadmissingOC = true, if not the last syncdate shall be used,
+		 * but the caches shall be reloaded
+		 * only used in syncSingle
+		 */
+		incUpdate = false;
+		if (pref.downloadAllOC)
+			lastS = &quot;20050801000000&quot;;
 		else {
-			if (ch.getLastSync().length() &lt; 14) lastS = &quot;20050801000000&quot;;
-			else lastS = ch.getLastSync();
+			if (ch.getLastSync().length() &lt; 14)
+				lastS = &quot;20050801000000&quot;;
+			else {
+				lastS = ch.getLastSync();
+				incUpdate = true;
+			}
 		}
 		dateOfthisSync = new Time();
 		dateOfthisSync.parse(lastS, &quot;yyyyMMddHHmmss&quot;);
 
-
-		String url = new String();
 		picCnt = 0;
-		//Build url
-		url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
+		// Build url
+		String url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot; + &quot;modifiedsince=&quot; + lastS + &quot;&amp;cache=1&quot; + &quot;&amp;cachedesc=1&quot;;
 
-		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;wp=&quot; + ch.getWayPoint()
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
+		if (pref.downloadPics)
+			url += &quot;&amp;picture=1&quot;;
+		else
+			url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot; + &quot;&amp;removedobject=0&quot; + &quot;&amp;wp=&quot; + ch.getWayPoint() + &quot;&amp;charset=utf-8&quot; + &quot;&amp;cdata=0&quot; + &quot;&amp;session=0&quot;;
 		ch.setUpdated(false);
+		isSyncSingle = true;
 		syncOC(url);
 		inf.close(0);
 		return true;
 	}
 
-	public void doIt(){
-		boolean success=true;
+	public void doIt() {
+		boolean success = true;
 		String finalMessage;
 
-		String url = new String();
-
-		String lastS =  profile.getLast_sync_opencaching();
-		CWPoint centre = pref.getCurCentrePt(); // No need to clone curCentrePt as centre is only read
+		String lastS = profile.getLast_sync_opencaching();
+		final CWPoint centre = pref.getCurCentrePt(); // No need to clone curCentrePt as centre is only read
 		if (!centre.isValid()) {
 			(new MessageBox(&quot;Error&quot;, &quot;Coordinates for centre must be set&quot;, FormBase.OKB)).execute();
 			return;
 		}
-		OCXMLImporterScreen importOpt = new OCXMLImporterScreen( MyLocale.getMsg(130,&quot;Download from opencaching&quot;),
-																 OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES
-																 | OCXMLImporterScreen.HOST);
-		if (importOpt.execute() == FormBase.IDCANCEL) {	return; }
+		final OCXMLImporterScreen importOpt = new OCXMLImporterScreen(MyLocale.getMsg(130, &quot;Download from opencaching&quot;), OCXMLImporterScreen.ALL | OCXMLImporterScreen.DIST | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.INCLUDEFOUND
+				| OCXMLImporterScreen.HOST);
+		if (importOpt.execute() == FormBase.IDCANCEL) {
+			return;
+		}
 		Vm.showWait(true);
 		String dist = importOpt.maxDistanceInput.getText();
-
-		if (importOpt.domains.getSelectedItem()!=null) {
-			hostname = (String)importOpt.domains.getSelectedItem();
-			pref.lastOCSite=hostname;
+		incFinds = !importOpt.foundCheckBox.getState();
+		if (importOpt.domains.getSelectedItem() != null) {
+			hostname = (String) importOpt.domains.getSelectedItem();
+			pref.lastOCSite = hostname;
 		}
 
-		if (dist.length()== 0) return;
+		if (dist.length() == 0)
+			return;
 
-		Double distDouble = new Double();
+		final Double distDouble = new Double();
 		distDouble.value = Common.parseDouble(dist);
 		dist = distDouble.toString(0, 1, 0).replace(',', '.');
-		//check, if distance is greater than before
-		if (Convert.toInt(dist) &gt; Convert.toInt(profile.getDistOC()) ||
-				pref.downloadMissingOC  ){
+		// check, if distance is greater than before
+		incUpdate = true;
+		if (Convert.toInt(dist) &gt; Convert.toInt(profile.getDistOC()) || pref.downloadAllOC) {
 			// resysnc
 			lastS = &quot;20050801000000&quot;;
 			incUpdate = false;
@@ -233,135 +236,130 @@
 		profile.setDistOC(dist);
 		// Clear status of caches in db
 		CacheHolder ch;
-		for(int i = cacheDB.size()-1; i&gt;=0 ;i--){
+		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
 			ch.setUpdated(false);
 			ch.setNew(false);
 			ch.setLog_updated(false);
 		}
 		picCnt = 0;
-		//Build url
-		url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot;
-			+ &quot;modifiedsince=&quot; + lastS
-			+ &quot;&amp;cache=1&quot;
-			+ &quot;&amp;cachedesc=1&quot;;
-		if (pref.downloadPics) url += &quot;&amp;picture=1&quot;;
-		else url += &quot;&amp;picture=0&quot;;
-		url += &quot;&amp;cachelog=1&quot;
-			+ &quot;&amp;removedobject=0&quot;
-			+ &quot;&amp;lat=&quot; + centre.getLatDeg(TransformCoordinates.DD)
-			+ &quot;&amp;lon=&quot; + centre.getLonDeg(TransformCoordinates.DD)
-			+ &quot;&amp;distance=&quot; + dist
-			+ &quot;&amp;charset=utf-8&quot;
-			+ &quot;&amp;cdata=0&quot;
-			+ &quot;&amp;session=0&quot;;
-		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// Build url
+		String url = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/xml/ocxml11.php?&quot; + &quot;modifiedsince=&quot; + lastS + &quot;&amp;cache=1&quot; + &quot;&amp;cachedesc=1&quot;;
+		if (pref.downloadPics)
+			url += &quot;&amp;picture=1&quot;;
+		else
+			url += &quot;&amp;picture=0&quot;;
+		url += &quot;&amp;cachelog=1&quot; + &quot;&amp;removedobject=0&quot; + &quot;&amp;lat=&quot; + centre.getLatDeg(TransformCoordinates.DD) + &quot;&amp;lon=&quot; + centre.getLonDeg(TransformCoordinates.DD) + &quot;&amp;distance=&quot; + dist + &quot;&amp;charset=utf-8&quot; + &quot;&amp;cdata=0&quot; + &quot;&amp;session=0&quot;;
+		inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608, &quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
 		inf.setPreferredSize(220, 300);
 		inf.relayout(false);
 		inf.exec();
 
+		isSyncSingle = false;
 		success = syncOC(url);
-		profile.saveIndex(pref,Profile.SHOW_PROGRESS_BAR);
+		profile.saveIndex(pref, Profile.SHOW_PROGRESS_BAR);
 		Vm.showWait(false);
 		if (success) {
 			profile.setLast_sync_opencaching(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
-			//pref.savePreferences();
-			finalMessage = MyLocale.getMsg(1607,&quot;Update from opencaching successful&quot;);
-			inf.addWarning(&quot;\nNumber of&quot;+
-			&quot;\n...caches new/updated: &quot; + numCacheImported +
-			&quot;\n...cache descriptions new/updated: &quot; + numDescImported +
-			&quot;\n...logs new/updated: &quot; + numLogImported);
+			// pref.savePreferences();
+			finalMessage = MyLocale.getMsg(1607, &quot;Update from opencaching successful&quot;);
+			inf.addWarning(&quot;\nNumber of&quot; + &quot;\n...caches new/updated: &quot; + numCacheImported + &quot; / &quot; + numCacheUpdated + &quot;\n...cache descriptions new/updated: &quot; + numDescImported + &quot;\n...logs new/updated: &quot; + numLogImported);
 			inf.setInfo(finalMessage);
 		}
 		inf.addOkButton();
 	}
 
-	private boolean syncOC(String url) {
-		String finalMessage = new String();
-		boolean success=true;
+	private boolean syncOC(String address) {
+		boolean success = true;
 		File tmpFile = null;
 		BufferedReader r;
-		String file = new String();
 
-		//inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
+		// inf = new InfoBox(&quot;Opencaching download&quot;, MyLocale.getMsg(1608,&quot;downloading data\n from opencaching&quot;), InfoBox.PROGRESS_WITH_WARNINGS, false);
 
 		picCnt = 0;
-		try{
+		String finalMessage = &quot;&quot;;
+		try {
 			holder = null;
-			pref.log(url+&quot;fetching&quot;);
-			file = fetch(url, &quot;dummy&quot;);
+			final String target = profile.dataDir + &quot;dummy.zip&quot;;
+			UrlFetcher.fetchDataFile(address, target);
 
-			//parse
-			tmpFile = new FileBugfix(profile.dataDir + file);
-			if (tmpFile.getLength() == 0 ) {
+			// parse
+			tmpFile = new FileBugfix(target);
+			if (tmpFile.getLength() == 0) {
 				throw new IOException(&quot;no updates available&quot;);
 			}
 
-			ZipFile zif = new ZipFile (profile.dataDir + file);
+			final ZipFile zif = new ZipFile(target);
 			ZipEntry zipEnt;
-			Enumeration zipEnum = zif.entries();
+			final Enumeration zipEnum = zif.entries();
 			inf.setInfo(&quot;...unzipping update file&quot;);
-			while (zipEnum.hasMoreElements())
-			{
+			while (zipEnum.hasMoreElements()) {
 				zipEnt = (ZipEntry) zipEnum.nextElement();
 				// skip over PRC-files and empty files
-				if (zipEnt.getSize()&gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)){
-					r = new BufferedReader (new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
+				if (zipEnt.getSize() &gt; 0 &amp;&amp; zipEnt.getName().endsWith(&quot;xml&quot;)) {
+					r = new BufferedReader(new InputStreamReader(zif.getInputStream(zipEnt), IO.JAVA_UTF8_CODEC));
 					parse(r);
 					r.close();
 				}
 			}
 			zif.close();
-		}catch (ZipException e){
-			finalMessage = MyLocale.getMsg(1614,&quot;Error while unzipping udpate file&quot;);
+		} catch (final ZipException e) {
+			finalMessage = MyLocale.getMsg(1614, &quot;Error while unzipping udpate file&quot;);
 			success = false;
-		}catch (IOException e){
-			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) { finalMessage = &quot;No updates available&quot;; success = false; }
-			else {
-				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
-						e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
-					finalMessage = MyLocale.getMsg(1616,&quot;Error: could not download update file from &quot; + hostname);
-				} else { finalMessage = &quot;IOException: &quot;+e.getMessage(); }
+		} catch (final IOException e) {
+			if (e.getMessage().equalsIgnoreCase(&quot;no updates available&quot;)) {
+				finalMessage = &quot;No updates available&quot;;
 				success = false;
+			} else {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) || e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) { // is there a better way to find out what happened?
+					finalMessage = MyLocale.getMsg(1616, &quot;Error: could not download update file from &quot; + hostname);
+				} else {
+					finalMessage = &quot;IOException: &quot; + e.getMessage();
+				}
+				success = false;
 			}
-		}catch (IllegalArgumentException e) {
-			finalMessage = MyLocale.getMsg(1621,&quot;Error parsing update file\n this is likely a bug in &quot; + hostname + &quot;\nplease try again later\n, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
+		} catch (final IllegalArgumentException e) {
+			finalMessage = MyLocale.getMsg(1621, &quot;Error parsing update file\n this is likely a bug in &quot; + hostname + &quot;\nplease try again later\n, state:&quot;) + &quot; &quot; + state + &quot;, waypoint: &quot; + holder.getWayPoint();
 			success = false;
-			pref.log(&quot;Parse error: &quot; + state + &quot; &quot; + holder.getWayPoint(),e,true);
-		}catch (Exception e){ // here should be used the correct exception
-			if (holder != null)	finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &quot;+ holder.getWayPoint();
-			else finalMessage = MyLocale.getMsg(1615,&quot;Error parsing update file, state:&quot;)+&quot; &quot;+state+&quot;, waypoint: &lt;unkown&gt;&quot;;
+			pref.log(&quot;Parse error: &quot; + state + &quot; &quot; + holder.getWayPoint(), e, true);
+		} catch (final Exception e) { // here should be used the correct exception
+			if (holder != null)
+				finalMessage = MyLocale.getMsg(1615, &quot;Error parsing update file, state:&quot;) + &quot; &quot; + state + &quot;, waypoint: &quot; + holder.getWayPoint();
+			else
+				finalMessage = MyLocale.getMsg(1615, &quot;Error parsing update file, state:&quot;) + &quot; &quot; + state + &quot;, waypoint: &lt;unkown&gt;&quot;;
 			success = false;
-			pref.log(&quot;&quot;,e,true);
+			pref.log(&quot;&quot;, e, true);
 		} finally {
-			if (tmpFile != null) tmpFile.delete();
+			if (tmpFile != null)
+				tmpFile.delete();
 		}
 		/*
-		for (int i=cacheDB.size()-1; i &gt;=0; i--) {
-			ch = (CacheHolder)cacheDB.get(i);
-			if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
-				ch.calcRecommendationScore();
-			}
-		} */
+		 * for (int i=cacheDB.size()-1; i &gt;=0; i--) {
+		 * ch = (CacheHolder)cacheDB.get(i);
+		 * if (ch.wayPoint.toUpperCase().startsWith(&quot;OC&quot;)) { //TODO only handle changed caches
+		 * ch.calcRecommendationScore();
+		 * }
+		 * }
+		 */
 		inf.setInfo(finalMessage);
 
 		return success;
 	}
 
-	public void startElement(String name, AttributeList atts){
-		if (debugGPX){
+	public void startElement(String name, AttributeList atts) {
+		if (debugGPX) {
 			for (int i = 0; i &lt; atts.getLength(); i++) {
-				pref.log(&quot; Name: &quot; + atts.getName(i)+ &quot; Value: &quot;+atts.getValue(i));
+				pref.log(&quot; Name: &quot; + atts.getName(i) + &quot; Value: &quot; + atts.getValue(i));
 			}
 		}
-		strData =&quot;&quot;;
+		strData = &quot;&quot;;
 
-		if (name.equals(&quot;oc11xml&quot;)){
-			Time lastSync = new Time();
+		if (name.equals(&quot;oc11xml&quot;)) {
+			final Time lastSync = new Time();
 			try {
-				lastSync.parse(atts.getValue(&quot;date&quot;),&quot;yyyy-MM-dd HH:mm:ss&quot;);
-			}catch (IllegalArgumentException e){
-				pref.log(&quot;&quot;,e,true);
+				lastSync.parse(atts.getValue(&quot;date&quot;), &quot;yyyy-MM-dd HH:mm:ss&quot;);
+			} catch (final IllegalArgumentException e) {
+				pref.log(&quot;&quot;, e, true);
 			}
 			// reduce time at 1 second to avoid sync problems
 			lastSync.setTime(lastSync.getTime() - 1000);
@@ -370,96 +368,140 @@
 		}
 
 		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		{ state = STAT_CACHE; numCacheImported++;}
-		if (name.equals(&quot;cachedesc&quot;)) 	{ state = STAT_CACHE_DESC; numDescImported++;}
-		if (name.equals(&quot;cachelog&quot;)) 	{ state = STAT_CACHE_LOG; numLogImported++; logtype = 0;}
-		if (name.equals(&quot;picture&quot;)) 	{ state = STAT_PICTURE; }
+		if (name.equals(&quot;cache&quot;)) {
+			state = STAT_CACHE;
+		}
+		if (name.equals(&quot;cachedesc&quot;)) {
+			state = STAT_CACHE_DESC;
+		}
+		if (name.equals(&quot;cachelog&quot;)) {
+			state = STAT_CACHE_LOG;
+			logtype = 0;
+		}
+		if (name.equals(&quot;picture&quot;)) {
+			state = STAT_PICTURE;
+		}
 
-		//examine data
+		// examine data
 		switch (state) {
-		case STAT_CACHE: startCache(name, atts); break;
-		case STAT_CACHE_DESC: startCacheDesc(name, atts); break;
-		case STAT_CACHE_LOG: startCacheLog(name, atts); break;
-		case STAT_PICTURE: startPicture(name,atts); break;
+		case STAT_CACHE:
+			startCache(name, atts);
+			break;
+		case STAT_CACHE_DESC:
+			startCacheDesc(name, atts);
+			break;
+		case STAT_CACHE_LOG:
+			startCacheLog(name, atts);
+			break;
+		case STAT_PICTURE:
+			startPicture(name, atts);
+			break;
 		}
 
 	}
 
-	public void endElement(String name){
-		//examine data
+	public void endElement(String name) {
+		// examine data
 		switch (state) {
-		case STAT_CACHE: endCache(name); break;
-		case STAT_CACHE_DESC: endCacheDesc(name);break;
-		case STAT_CACHE_LOG: endCacheLog(name); break;
-		case STAT_PICTURE: endPicture(name); break;
+		case STAT_CACHE:
+			endCache(name);
+			break;
+		case STAT_CACHE_DESC:
+			endCacheDesc(name);
+			break;
+		case STAT_CACHE_LOG:
+			endCacheLog(name);
+			break;
+		case STAT_PICTURE:
+			endPicture(name);
+			break;
 		}
 
 		// look for changes in the state
-		if (name.equals(&quot;cache&quot;)) 		state = STAT_INIT;
-		if (name.equals(&quot;cachedesc&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;cachelog&quot;)) 	state = STAT_INIT;
-		if (name.equals(&quot;picture&quot;)) 	state = STAT_INIT;
+		if (name.equals(&quot;cache&quot;))
+			state = STAT_INIT;
+		if (name.equals(&quot;cachedesc&quot;))
+			state = STAT_INIT;
+		if (name.equals(&quot;cachelog&quot;))
+			state = STAT_INIT;
+		if (name.equals(&quot;picture&quot;))
+			state = STAT_INIT;
 
 	}
 
-	public void characters(char[] ch2,int start,int length){
-		String chars = new String(ch2,start,length);
+	public void characters(char[] ch2, int start, int length) {
+		final String chars = new String(ch2, start, length);
 		strData += chars;
-		if (debugGPX) pref.log(strData,null);
+		if (debugGPX)
+			pref.log(strData, null);
 	}
 
-	private void startCache(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1609,&quot;Importing Cache:&quot;)+&quot; &quot; + numCacheImported + &quot;\n&quot;);
-		if(name.equals(&quot;id&quot;)){
+	private void startCache(String name, AttributeList atts) {
+		if (name.equals(&quot;id&quot;)) {
 			cacheID = atts.getValue(&quot;id&quot;);
+			return;
 		}
-		if(name.equals(&quot;type&quot;)){
+		if (holder == null)
+			return;
+		inf.setInfo(MyLocale.getMsg(1609, &quot;Importing Cache:&quot;) + &quot; &quot; + numCacheImported + &quot; / &quot; + numCacheUpdated + &quot;\n&quot;);
+		if (name.equals(&quot;type&quot;)) {
 			holder.setType(CacheType.ocType2CwType(atts.getValue(&quot;id&quot;)));
 			holder.getCacheDetails(false).attributes.clear();
 			return;
 		}
-		if(name.equals(&quot;status&quot;)){
-            // meaning of OC status :
-			//  1=Kann gesucht werden ;
-			//  2=Momentan nicht verf&#252;gbar ;
-			//  3=Archiviert ;
-			//  4= ;
-			//  5= ;
-			//  6=Gesperrt ;
-			//  are there more ? ;
+		if (name.equals(&quot;status&quot;)) {
+			// meaning of OC status :
+			// 1=Kann gesucht werden ;
+			// 2=Momentan nicht verf&#252;gbar ;
+			// 3=Archiviert ;
+			// 4= ;
+			// 5= ;
+			// 6=Gesperrt ;
+			// are there more ? ;
 			if (atts.getValue(&quot;id&quot;).equals(&quot;1&quot;)) {
 				holder.setAvailable(true);
+				holder.setArchived(false);
 			} else {
 				holder.setAvailable(false);
-				if( (atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) || (atts.getValue(&quot;id&quot;).equals(&quot;6&quot;)) ) {
-					holder.setArchived(true);
+				if ((atts.getValue(&quot;id&quot;).equals(&quot;3&quot;)) || (atts.getValue(&quot;id&quot;).equals(&quot;6&quot;)) || (atts.getValue(&quot;id&quot;).equals(&quot;7&quot;))) {
+					if (!isSyncSingle) {
+						holder = null;
+						numCacheImported--;
+					} else {
+						// Umsetzung wie in gpx f&#252;r Status 6
+						if (atts.getValue(&quot;id&quot;).equals(&quot;6&quot;)) {
+							holder.setArchived(false);
+						} else {
+							holder.setArchived(true);
+						}
+					}
 				}
 			}
 			return;
 		}
-		if(name.equals(&quot;size&quot;)){
+		if (name.equals(&quot;size&quot;)) {
 			holder.setCacheSize(CacheSize.ocXmlString2Cw(atts.getValue(&quot;id&quot;)));
 			return;
 		}
 
-		if(name.equals(&quot;waypoints&quot;)){
+		if (name.equals(&quot;waypoints&quot;)) {
 			holder.setWayPoint(atts.getValue(&quot;oc&quot;));
-			String CName = atts.getValue(&quot;nccom&quot;) + &quot; &quot; + atts.getValue(&quot;gccom&quot;);
+			final String CName = atts.getValue(&quot;nccom&quot;) + &quot; &quot; + atts.getValue(&quot;gccom&quot;);
 			if (!CName.equals(&quot; &quot;)) {
 				holder.setCacheOwner(holder.getCacheOwner() + &quot; / &quot; + CName.trim());
 				holder.getCacheDetails(false).attributes.add(7); // wwwlink
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
-			}
-			else {
+			} else {
 				holder.getCacheDetails(false).attributes.add(6); // oconly
 				holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			}
-			if (holder.getWayPoint().length()==0) throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
+			if (holder.getWayPoint().length() == 0)
+				throw new IllegalArgumentException(&quot;empty waypointname&quot;); // this should not happen - it is likey a bug in opencaching / it happens on 27-12-2006 on cache OC143E
 			return;
 		}
-		
+
 		if (name.equals(&quot;attribute&quot;)) {
-			int id = Integer.parseInt(atts.getValue(&quot;id&quot;));
+			final int id = Integer.parseInt(atts.getValue(&quot;id&quot;));
 			holder.getCacheDetails(false).attributes.add(id);
 			holder.setAttribsAsBits(holder.getCacheDetails(false).attributes.getAttribsAsBits());
 			return;
@@ -467,74 +509,97 @@
 
 	}
 
+	private void startCacheDesc(String name, AttributeList atts) {
+		inf.setInfo(MyLocale.getMsg(1611, &quot;Importing cache description:&quot;) + &quot; &quot; + numDescImported);
 
-	private void startCacheDesc(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported);
-		if (name.equals(&quot;cacheid&quot;)){
-			String ocCacheID = new String(atts.getValue(&quot;id&quot;));
-			holder.setOcCacheID(ocCacheID);
+		if (name.equals(&quot;cacheid&quot;)) {
+			cacheID = atts.getValue(&quot;id&quot;);
+			holder = getHolder(cacheID, false);
+			return;
 		}
 
-		if (name.equals(&quot;desc&quot;)){
-			holder.setHTML(atts.getValue(&quot;html&quot;).equals(&quot;1&quot;)?true:false);
+		if (name.equals(&quot;desc&quot;)) {
+			isHTML = atts.getValue(&quot;html&quot;).equals(&quot;1&quot;) ? true : false;
+			return;
 		}
 
 		if (name.equals(&quot;language&quot;)) {
 			processingDescLang = atts.getValue(&quot;id&quot;);
+			return;
 		}
 	}
 
-	private void startPicture(String name, AttributeList atts){
-		if(name.equals(&quot;picture&quot;)){
-			inf.setInfo(MyLocale.getMsg(1613,&quot;Pictures:&quot;)+&quot; &quot; + ++picCnt);
+	private void startCacheLog(String name, AttributeList atts) {
+		if (name.equals(&quot;id&quot;)) {
+			logId = atts.getValue(&quot;id&quot;);
+			return;
 		}
-	}
 
-	private void startCacheLog(String name, AttributeList atts){
-		inf.setInfo(MyLocale.getMsg(1612,&quot;Importing Cachlog:&quot;)+&quot; &quot; + numLogImported);
-		if (name.equals(&quot;logtype&quot;)){
+		if (name.equals(&quot;cacheid&quot;)) {
+			holder = getHolder(atts.getValue(&quot;id&quot;), false);
+			return;
+		}
+		if (holder == null)
+			return;
+
+		inf.setInfo(MyLocale.getMsg(1612, &quot;Importing Cachlog:&quot;) + &quot; &quot; + numLogImported);
+
+		if (name.equals(&quot;logtype&quot;)) {
 			logtype = Convert.toInt(atts.getValue(&quot;id&quot;));
 			switch (logtype) {
 			case 1:
 				logIcon = Log.typeText2Image(&quot;Found&quot;);
 				break;
-			case 2:	
+			case 2:
 				logIcon = Log.typeText2Image(&quot;Not Found&quot;);
-				holder.setNoFindLogs((byte)(holder.getNoFindLogs()+1));
+				holder.setNoFindLogs((byte) (holder.getNoFindLogs() + 1));
 				break;
-			case 3: 
+			case 3:
 				logIcon = Log.typeText2Image(&quot;Note&quot;);
 			}
 			loggerRecommended = atts.getValue(&quot;recommended&quot;).equals(&quot;1&quot;);
 			return;
 		}
+	}
 
-		if (name.equals(&quot;id&quot;)){
-			logId = atts.getValue(&quot;id&quot;);
+	private void startPicture(String name, AttributeList atts) {
+		if (name.equals(&quot;object&quot;)) {
+			cacheID = atts.getValue(&quot;id&quot;); // are there picture without cacheID?
+			holder = getHolder(cacheID, false);
+			return;
 		}
 	}
 
-	private void endCache(String name){
-		if (name.equals(&quot;cache&quot;)){
+	private void endCache(String name) {
+		if (name.equals(&quot;id&quot;)) { // &lt;/id&gt;
+			// the guid (=strData) is not part of gpx , so we use id of cacheID
+			holder = getHolder(cacheID, true); // Allocate a new CacheHolder object
+			holder.setOcCacheID(cacheID);
+			holder.getCacheDetails(false).URL = &quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/viewcache.php?cacheid=&quot; + cacheID;
+			return;
+		}
+		if (holder == null)
+			return; // id should always be the first for a &lt;cache&gt;
+		if (name.equals(&quot;cache&quot;)) {
 			holder.setLastSync(dateOfthisSync.format(&quot;yyyyMMddHHmmss&quot;));
 			int index;
 			index = cacheDB.getIndex(holder.getWayPoint());
-			if (index == -1){
+			if (index == -1) {
+				numCacheImported++;
 				holder.setNew(true);
 				cacheDB.add(holder);
-				Integer indexInt = new Integer(cacheDB.size()-1);
-				DBindexID.put(holder.getOcCacheID(), indexInt);
+				DBindexID.put(holder.getOcCacheID(), holder.getWayPoint());
 			}
 			// update (overwrite) data
 			else {
+				numCacheUpdated++;
 				holder.setNew(false);
 				holder.setIncomplete(false);
 				cacheDB.get(index).update(holder);
-				// save ocCacheID, in case, the previous data is from GPX
-				DBindexID.put(holder.getOcCacheID(), new Integer(index));
+				DBindexID.put(holder.getOcCacheID(), holder.getWayPoint());
 			}
 			// clear data (picture, logs) if we do a complete Update
-			if (incUpdate == false){
+			if (!incUpdate) {
 				holder.getCacheDetails(false).CacheLogs.clear();
 				holder.getCacheDetails(false).images.clear();
 			}
@@ -543,277 +608,289 @@
 			holder.getCacheDetails(false).hasUnsavedChanges = true; // this makes CachHolder save the details in case that they are unloaded from memory
 			// chD.saveCacheDetails(profile.dataDir);
 			// profile.saveIndex(pref,Profile.NO_SHOW_PROGRESS_BAR); // this is done after .xml is completly processed
+
+			holder = null;
 			return;
 		}
-		if(name.equals(&quot;id&quot;)){ // &lt;/id&gt;
-			holder = getHolder(strData); // Allocate a new CacheHolder object
-			holder.setOcCacheID(strData);
-			String ocSeekUrl = new String(&quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/viewcache.php?cacheid=&quot;);
-			holder.getCacheDetails(false).URL = ocSeekUrl + cacheID;
-			return;
-		}
 
-		if(name.equals(&quot;name&quot;)){
+		if (name.equals(&quot;name&quot;)) {
 			holder.setCacheName(strData);
 			return;
 		}
-		if(name.equals(&quot;userid&quot;)) {
+		if (name.equals(&quot;userid&quot;)) {
 			holder.setCacheOwner(strData);
-			if(holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length()&gt;0 &amp;&amp; holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2))) holder.setOwned(true);
+			if (holder.getCacheOwner().equalsIgnoreCase(pref.myAlias) || (pref.myAlias2.length() &gt; 0 &amp;&amp; holder.getCacheOwner().equalsIgnoreCase(pref.myAlias2)))
+				holder.setOwned(true);
 			return;
 		}
 
-		if(name.equals(&quot;longitude&quot;)){
+		if (name.equals(&quot;longitude&quot;)) {
 			longitude = Common.parseDouble(strData);
 			return;
 		}
-		if(name.equals(&quot;latitude&quot;)) {
-			holder.pos.set(Common.parseDouble(strData),longitude);
-			holder.setLatLon(holder.pos.toString());
+		if (name.equals(&quot;latitude&quot;)) {
+			holder.setPos(new TrackPoint(Common.parseDouble(strData), longitude));
 			return;
 		}
-		if(name.equals(&quot;difficulty&quot;)) {
+		if (name.equals(&quot;difficulty&quot;)) {
 			holder.setHard(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals(&quot;terrain&quot;)) {
+		if (name.equals(&quot;terrain&quot;)) {
 			holder.setTerrain(CacheTerrDiff.v1Converter(strData));
 			return;
 		}
-		if(name.equals(&quot;datehidden&quot;)) {
-			holder.setDateHidden(strData.substring(0,10)); //Date;
+		if (name.equals(&quot;datehidden&quot;)) {
+			holder.setDateHidden(strData.substring(0, 10)); // Date;
 			return;
 		}
-		if (name.equals(&quot;country&quot;)){
+		if (name.equals(&quot;country&quot;)) {
 			holder.getCacheDetails(false).Country = strData;
 			return;
 		}
 	}
 
-	private void endCacheDesc(String name){
-		if (name.equals(&quot;cachedesc&quot;)){
-			if (pref.downloadPics &amp;&amp; holder.is_HTML()) {
-				String fetchUrl, imgTag, imgAltText;
-				Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); //  Ergebnis enthlt keine Anfhrungszeichen
-				Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;); // get alternative text for Pic
-				imgRegexAlt.setIgnoreCase(true);
-				imgRegexUrl.setIgnoreCase(true);
-				int descIndex=0;
-				int numDownloaded=1;
-				while (imgRegexUrl.searchFrom(holder.getCacheDetails(false).LongDescription, descIndex)) { // &quot;img&quot; found
-					imgTag=imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte &lt;img ...&gt;-tag
-					fetchUrl=imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
-					if (fetchUrl==null) { fetchUrl=imgRegexUrl.stringMatched(3); }
-					if (fetchUrl==null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
-						inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot;+holder.getWayPoint()));
-						continue;
-					}
-					inf.setInfo(MyLocale.getMsg(1611,&quot;Importing cache description:&quot;)+&quot; &quot; + numDescImported + &quot;\n&quot;+MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
-					if (imgRegexAlt.search(imgTag)) {
-						imgAltText=imgRegexAlt.stringMatched(1);
-						if (imgAltText==null)	imgAltText=imgRegexAlt.stringMatched(2);
-						// no alternative text as image title -&gt; use filename
-					} else {
-						if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) //wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
-							imgAltText = new String(&quot;No image title&quot;);
-						else imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/')+1);
-					}
-					descIndex = imgRegexUrl.matchedTo();
-					getPic(fetchUrl, imgAltText);
-				}
+	private void endCacheDesc(String name) {
+		if (holder == null)
+			return;
+		if (name.equals(&quot;cachedesc&quot;)) {
+			numDescImported++;
+			holder.setHTML(isHTML);
+			if (pref.downloadPics &amp;&amp; isHTML) {
+				getImageNamesFromDescription();
 			}
 			holder.getCacheDetails(false).hasUnsavedChanges = true;
 			return;
 		}
 
+		if (name.equals(&quot;shortdesc&quot;)) {
+			String linebraek;
 
-		if (name.equals(&quot;cacheid&quot;)){
-			// load cachedata
-			holder = getHolder(strData);
-			return;
-		}
+			if (isHTML)
+				linebraek = &quot;&lt;br&gt;\n&quot;;
+			else
+				linebraek = &quot;\n&quot;;
 
-		if (name.equals(&quot;shortdesc&quot;)){
-			String linebraek;
-
-			if (holder.is_HTML())	linebraek = &quot;&lt;br&gt;\n&quot;;
-			else 					linebraek = &quot;\n&quot;;
-			
-			     // this is set by &quot;hint&quot; a few lines down: if a long description is already updated, then this one is likely to be in another language
-			if (holder.is_updated())	holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + &quot;:&quot; +  linebraek + strData  +  linebraek;
-			else 					 	holder.getCacheDetails(false).LongDescription =              processingDescLang + &quot;:&quot; +  linebraek + strData  +  linebraek;
+			// this is set by &quot;hint&quot; a few lines down: if a long description is already updated, then this one is likely to be in another language
+			if (holder.is_updated())
+				holder.getCacheDetails(false).LongDescription += linebraek + processingDescLang + &quot;:&quot; + linebraek + strData + linebraek;
+			else
+				holder.getCacheDetails(false).LongDescription = processingDescLang + &quot;:&quot; + linebraek + strData + linebraek;
 			return;
 		}
 
-		if (name.equals(&quot;desc&quot;)){ // &lt;/desc&gt;
-			if (holder.is_HTML())	holder.getCacheDetails(false).LongDescription +=SafeXML.cleanback(strData);
-			else holder.getCacheDetails(false).LongDescription +=strData;
+		if (name.equals(&quot;desc&quot;)) { // &lt;/desc&gt;
+			if (isHTML)
+				holder.getCacheDetails(false).LongDescription += SafeXML.cleanback(strData);
+			else
+				holder.getCacheDetails(false).LongDescription += strData;
 			return;
 		}
-		if (name.equals(&quot;hint&quot;)){
+		if (name.equals(&quot;hint&quot;)) {
 			String linebreak;
-			if (holder.is_HTML())	linebreak = &quot;&lt;br&gt;\n&quot;;
-			else 					linebreak = &quot;\n&quot;;
-			if (holder.is_updated())	holder.getCacheDetails(false).Hints += linebreak + &quot;[&quot; + processingDescLang + &quot;:]&quot; +  linebreak + Common.rot13(strData)  +  linebreak;
-			else 					 	holder.getCacheDetails(false).Hints =              &quot;[&quot; + processingDescLang + &quot;:]&quot; +  linebreak + Common.rot13(strData)  +  linebreak;
+			if (isHTML)
+				linebreak = &quot;&lt;br&gt;\n&quot;;
+			else
+				linebreak = &quot;\n&quot;;
+			if (holder.is_updated())
+				holder.getCacheDetails(false).Hints += linebreak + &quot;[&quot; + processingDescLang + &quot;:]&quot; + linebreak + Common.rot13(strData) + linebreak;
+			else
+				holder.getCacheDetails(false).Hints = &quot;[&quot; + processingDescLang + &quot;:]&quot; + linebreak + Common.rot13(strData) + linebreak;
 			holder.setUpdated(true); // remark: this is used in &quot;shortdesc&quot; to decide weather the description should be appended or replaced
 			return;
 		}
 	}
 
-	private String createPicFilename(String fetchURL) {
-		String fileName = holder.getWayPoint() + &quot;_&quot; + fetchURL.substring(fetchURL.lastIndexOf('/')+1);
-		return Common.ClearForFileName(fileName).toLowerCase();
-	}
-
-	private void getPic(String fetchURL, String picDesc) { // TODO handling of relativ URLs
-		try {
-			//TODO this is not quite correct: actually the &quot;base&quot; URL must be known...
-			// but anyway a different baseURL should not happen very often  - it doesn't in my area
-			if (!fetchURL.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) fetchURL = new URL(
-				new URL(&quot;<A HREF="http://">http://</A>&quot; + hostname+&quot;/&quot;), fetchURL).toString();
-			String fileName = createPicFilename(fetchURL);
-			ImageInfo imageInfo = new ImageInfo();
-			imageInfo.setURL(fetchURL);
-			// add title
-			imageInfo.setTitle(picDesc);
-			holder.getCacheDetails(false).images.add(imageInfo);
-			try {
-				File ftest = new FileBugfix(profile.dataDir + fileName);
-				if (ftest.exists()){
-					imageInfo.setFilename(fileName);
+	private void endCacheLog(String name) {
+		if (holder == null)
+			return;
+		if (name.equals(&quot;cachelog&quot;)) { // &lt;/cachelog&gt;
+			if (holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended)) &gt; -1) {
+				numLogImported++;
+				holder.getCacheDetails(false).hasUnsavedChanges = true; // chD.saveCacheDetails(profile.dataDir);
+			}
+			//
+			if ((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1) {
+				if (incFinds || !holder.is_new()) {
+					// aber vorhandene werden mit gefunden aktualisiert
+					holder.setCacheStatus(logDate);
+					holder.setFound(true);
+					holder.getCacheDetails(false).OwnLogId = logId;
+					holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
+				} else {
+					// if (holder.is_new())
+					cacheDB.removeElementAt(cacheDB.getIndex(holder));
+					DBindexID.remove(holder.GetCacheID());
+					// und Dateien l&#246;schen?
+					final File tmpFile = new File(profile.dataDir + holder.getWayPoint() + &quot;.xml&quot;);
+					tmpFile.delete();
+					// todo: was ist mit den schon heruntergeladenen Bildern?
 				}
-				else {
-					if (pref.downloadPics) {
-						imageInfo.setFilename(fetch(fetchURL, fileName));
-					}
-				}
-			} catch (IOException e) {
-				String ErrMessage;
-				String wp, n;
-				if (holder != null &amp;&amp; holder.getWayPoint() != null) wp = holder.getWayPoint();
-				else 												wp = new String(&quot;WP???&quot;);
-				if (holder != null &amp;&amp; holder.getCacheName() != null) n = holder.getCacheName();
-				else 												 n = new String(&quot;name???&quot;);
-
-				if (e == null) ErrMessage = &quot;Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: &quot;+fileName+&quot; from URL:&quot;+fetchURL;
-				else {
-					if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) ||
-							e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) {
-						// is there a better way to find out what happened?
-						ErrMessage = MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+ n + &quot; (&quot;+wp+&quot;)&quot;+MyLocale.getMsg(1619,&quot;: could not download image from URL: &quot;)+fetchURL;
-					} else
-						ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;)+ n + &quot; (&quot;+wp+&quot;): ignoring IOException: &quot;+e.getMessage()+ &quot; while downloading picture:&quot;+fileName+&quot; from URL:&quot;+fetchURL);
-				}
-				inf.addWarning(&quot;\n&quot;+ErrMessage);
-				pref.log(ErrMessage,e,true);
 			}
-		} catch (MalformedURLException e) {
-			String ErrMessage = new String (MyLocale.getMsg(1618,&quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage()+ &quot; while downloading from URL:&quot; + fetchURL);
-			inf.addWarning(&quot;\n&quot;+ErrMessage);
-			pref.log(ErrMessage,e);
-		}
-
-	}
-
-
-	private void endPicture(String name){
-
-		if(name.equals(&quot;id&quot;)){
-			picID = strData;
 			return;
 		}
 
-		if (name.equals(&quot;url&quot;)){
-			picUrl = strData;
+		if (name.equals(&quot;date&quot;)) {
+			logDate = strData;
 			return;
 		}
-		if (name.equals(&quot;title&quot;)){
-			picTitle = strData;
+		if (name.equals(&quot;userid&quot;)) {
+			logFinder = strData;
 			return;
 		}
-		if(name.equals(&quot;object&quot;)){
-			// get cachedata
-			holder = getHolder(strData);
+		if (name.equals(&quot;text&quot;)) {
+			logData = strData;
 			return;
 		}
-		if(name.equals(&quot;picture&quot;)){
-			//String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
-			getPic(picUrl,picTitle);
-			holder.getCacheDetails(false).hasUnsavedChanges = true; //saveCacheDetails(profile.dataDir);
-			return;
-		}
+
 	}
 
-	private void endCacheLog(String name){
-		if (name.equals(&quot;cachelog&quot;)){ // &lt;/cachelog&gt;
-			holder.getCacheDetails(false).CacheLogs.merge(new Log(logIcon, logDate, logFinder, logData, loggerRecommended));
-			if((logFinder.toLowerCase().compareTo(user) == 0 || logFinder.equalsIgnoreCase(pref.myAlias2)) &amp;&amp; logtype == 1) {
-						holder.setCacheStatus(logDate);
-						holder.setFound(true);
-						holder.getCacheDetails(false).OwnLogId = logId;
-						holder.getCacheDetails(false).OwnLog = new Log(logIcon, logDate, logFinder, logData, loggerRecommended);
-			}
-			holder.getCacheDetails(false).hasUnsavedChanges = true; //chD.saveCacheDetails(profile.dataDir);
+	private void endPicture(String name) {
+		if (holder == null)
 			return;
-		}
 
-		if (name.equals(&quot;cacheid&quot;)){ // &lt;/cacheid&gt;
-			// load cachedata
-			holder = getHolder(strData);
+		if (name.equals(&quot;id&quot;)) {
+			picID = strData;
 			return;
 		}
 
-		if (name.equals(&quot;date&quot;))  {
-			logDate = new String(strData);
+		if (name.equals(&quot;url&quot;)) {
+			picUrl = strData;
 			return;
 		}
-		if (name.equals(&quot;userid&quot;)){
-			logFinder = new String(strData);
+		if (name.equals(&quot;title&quot;)) {
+			picTitle = strData;
 			return;
 		}
-		if (name.equals(&quot;text&quot;)){
-			logData = new String(strData);
+		if (name.equals(&quot;picture&quot;)) {
+			inf.setInfo(MyLocale.getMsg(1613, &quot;Pictures:&quot;) + &quot; &quot; + ++picCnt);
+			// String fileName = holder.wayPoint + &quot;_&quot; + picUrl.substring(picUrl.lastIndexOf(&quot;/&quot;)+1);
+			final ImageInfo ii = new ImageInfo();
+			ii.setTitle(picTitle);
+			ii.setURL(picUrl);
+			getPic(ii);
+			holder.getCacheDetails(false).hasUnsavedChanges = true; // saveCacheDetails(profile.dataDir);
 			return;
 		}
-
 	}
 
-	private String fetch(String addr, String fileName ) throws IOException
-	{
-		CharArray realurl = new CharArray();
-		ByteArray daten = UrlFetcher.fetchByteArray(addr, realurl);
-		FileOutputStream outp =  new FileOutputStream(profile.dataDir + fileName);
-		outp.write(daten.toBytes());
-		outp.close();
-		return fileName;
+	private CacheHolder getHolder(String guid, boolean create) {// See also LOCXMLImporter
+		CacheHolder ch = null;
+		// Integer INTR = (Integer)DBindexID.get(guid);
+		final String wp = (String) DBindexID.get(guid);
+		// if(INTR != null){
+		if (wp != null) {
+			// ch = cacheDB.get(INTR.intValue());
+			ch = cacheDB.get(wp);
+		} else {
+			if (create)
+				ch = new CacheHolder();
+		}
+		return ch;
 	}
 
-
-	/**
-	 * Method to iterate through cache database and look for cacheID.
-	 * Returns value &gt;= 0 if cacheID is found, else -1
-	 */
-	private int searchID(String cacxheID){
-		Integer INTR = (Integer)DBindexID.get(cacxheID);
-		if(INTR != null){
-			return INTR.intValue();
-		} else return -1;
+	private void getImageNamesFromDescription() {
+		String fetchUrl;
+		String imgTag;
+		String imgAltText;
+		final Regex imgRegexUrl = new Regex(&quot;(&lt;img[^&gt;]*src=[\&quot;\']([^&gt;^\&quot;^\']*)[^&gt;]*&gt;|&lt;img[^&gt;]*src=([^&gt;^\&quot;^\'^ ]*)[^&gt;]*&gt;)&quot;); // Ergebnis enthlt keine Anfhrungszeichen
+		final Regex imgRegexAlt = new Regex(&quot;(?:alt=[\&quot;\']([^&gt;^\&quot;^\']*)|alt=([^&gt;^\&quot;^\'^ ]*))&quot;); // get alternative text for Pic
+		imgRegexAlt.setIgnoreCase(true);
+		imgRegexUrl.setIgnoreCase(true);
+		int descIndex = 0;
+		int numDownloaded = 1;
+		while (imgRegexUrl.searchFrom(holder.getCacheDetails(false).LongDescription, descIndex)) { // &quot;img&quot; found
+			imgTag = imgRegexUrl.stringMatched(1); // (1) enthlt das gesamte &lt;img ...&gt;-tag
+			fetchUrl = imgRegexUrl.stringMatched(2); // URL in Anfhrungszeichen in (2) falls ohne in (3) Ergebnis ist auf jeden Fall ohne Anfhrungszeichen
+			if (fetchUrl == null) {
+				fetchUrl = imgRegexUrl.stringMatched(3);
+			}
+			if (fetchUrl == null) { // TODO Fehler ausgeben: nicht abgedeckt ist der Fall, dass in einem Cache Links auf Bilder mit unterschiedlichen URL, aber gleichem Dateinamen sind.
+				inf.addWarning(MyLocale.getMsg(1617, &quot;Ignoriere Fehler in html-Cache-Description: \&quot;&lt;img\&quot; without \&quot;src=\&quot; in cache &quot; + holder.getWayPoint()));
+				continue;
+			}
+			inf.setInfo(MyLocale.getMsg(1611, &quot;Importing cache description:&quot;) + &quot; &quot; + numDescImported + &quot;\n&quot; + MyLocale.getMsg(1620, &quot;downloading embedded images: &quot;) + numDownloaded++);
+			if (imgRegexAlt.search(imgTag)) {
+				imgAltText = imgRegexAlt.stringMatched(1);
+				if (imgAltText == null)
+					imgAltText = imgRegexAlt.stringMatched(2);
+				// no alternative text as image title -&gt; use filename
+			} else {
+				if (fetchUrl.toLowerCase().indexOf(&quot;opencaching.&quot;) &gt; 0 || fetchUrl.toLowerCase().indexOf(&quot;geocaching.com&quot;) &gt; 0) // wenn von Opencaching oder geocaching ist Dateiname doch nicht so toll, weil nur aus Nummer bestehend
+					imgAltText = &quot;No image title&quot;;
+				else
+					imgAltText = fetchUrl.substring(fetchUrl.lastIndexOf('/') + 1);
+			}
+			descIndex = imgRegexUrl.matchedTo();
+			try {
+				// TODO this is not quite correct: actually the &quot;base&quot; URL must be known...
+				// but anyway a different baseURL should not happen very often - it doesn't in my area
+				if (!fetchUrl.startsWith(&quot;<A HREF="http://">http://</A>&quot;)) {
+					fetchUrl = new URL(new URL(&quot;<A HREF="http://">http://</A>&quot; + hostname + &quot;/&quot;), fetchUrl).toString();
+				}
+			} catch (final MalformedURLException e) {
+				final String ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + holder.getWayPoint() + &quot;: ignoring MalformedUrlException: &quot; + e.getMessage() + &quot; while downloading from URL:&quot; + fetchUrl;
+				inf.addWarning(&quot;\n&quot; + ErrMessage);
+				pref.log(ErrMessage, e);
+			}
+			final ImageInfo imageInfo = new ImageInfo();
+			imageInfo.setURL(fetchUrl);
+			imageInfo.setTitle(imgAltText);
+			getPic(imageInfo);
+		}
 	}
 
+	private void getPic(ImageInfo imageInfo) { // TODO handling of relativ URLs
+		String fileName = holder.getWayPoint() + &quot;_&quot; + imageInfo.getURL().substring(imageInfo.getURL().lastIndexOf('/') + 1);
+		fileName = Common.ClearForFileName(fileName).toLowerCase();
+		final String target = profile.dataDir + fileName;
+		imageInfo.setFilename(fileName);
+		try {
+			File ftest = new FileBugfix(target);
+			if (ftest.exists()) {
+				if (ftest.length() == 0) {
+					ftest.delete();
+				} else {
+					holder.getCacheDetails(false).images.add(imageInfo);
+				}
+			} else {
+				if (pref.downloadPics) {
+					UrlFetcher.fetchDataFile(imageInfo.getURL(), target);
+					ftest = new FileBugfix(target);
+					if (ftest.exists()) {
+						if (ftest.length() &gt; 0) {
+							holder.getCacheDetails(false).images.add(imageInfo);
+						} else {
+							ftest.delete();
+						}
+					}
+				}
+			}
+		} catch (final IOException e) {
+			String ErrMessage;
+			String wp, n;
+			if (holder != null &amp;&amp; holder.getWayPoint() != null)
+				wp = holder.getWayPoint();
+			else
+				wp = &quot;WP???&quot;;
+			if (holder != null &amp;&amp; holder.getCacheName() != null)
+				n = holder.getCacheName();
+			else
+				n = &quot;name???&quot;;
 
-	private CacheHolder getHolder(String wpt){// See also LOCXMLImporter
-		CacheHolder chx;
-		int index;
+			if (e == null)
+				ErrMessage = &quot;Ignoring error: OCXMLImporter.getPic: IOExeption == null, while downloading picture: &quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
+			else {
+				if (e.getMessage().equalsIgnoreCase(&quot;could not connect&quot;) || e.getMessage().equalsIgnoreCase(&quot;unkown host&quot;)) {
+					// is there a better way to find out what happened?
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;)&quot; + MyLocale.getMsg(1619, &quot;: could not download image from URL: &quot;) + imageInfo.getURL();
+				} else
+					ErrMessage = MyLocale.getMsg(1618, &quot;Ignoring error in cache: &quot;) + n + &quot; (&quot; + wp + &quot;): ignoring IOException: &quot; + e.getMessage() + &quot; while downloading picture:&quot; + fileName + &quot; from URL:&quot; + imageInfo.getURL();
+			}
+			inf.addWarning(&quot;\n&quot; + ErrMessage);
+			pref.log(ErrMessage, e, true);
+		}
 
-		index = cacheDB.getIndex(wpt);
-		if (index == -1) index = searchID(wpt);
-		if (index == -1) {
-			chx = new CacheHolder();
-		} else {
-			chx = cacheDB.get(index);
-		}
-		return chx;
 	}
 
 }

Modified: branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/OCXMLImporterScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.imp;
 
 import CacheWolf.CacheType;
@@ -49,9 +49,9 @@
 
 /**
  * @author pfeffer
- * This Class is the Dialog for Download from Opencaching.de
- * is called from OCXMLImporter
- * 20061209 Bugfix: Checking for uninitialised missingCheckBox
+ *         This Class is the Dialog for Download from Opencaching.de
+ *         is called from OCXMLImporter
+ *         20061209 Bugfix: Checking for uninitialised missingCheckBox
  */
 public class OCXMLImporterScreen extends Form {
 	mButton cancelB, okB;
@@ -63,7 +63,7 @@
 	mInput maxNumberInput;
 	mInput maxNumberUpdates;
 	mInput maxLogsInput;
-	mCheckBox imagesCheckBox, /*mapsCheckBox, */ missingCheckBox, foundCheckBox, travelbugsCheckBox;
+	mCheckBox imagesCheckBox, /* mapsCheckBox, */missingCheckBox, foundCheckBox, travelbugsCheckBox;
 	ewe.ui.mChoice domains;
 	String fileName;
 
@@ -86,7 +86,6 @@
 	public static final int MAXUPDATE = 4096;
 	public static final int FILENAME = 8192; // track or route gpx
 
-
 	public OCXMLImporterScreen(String title, int options) {
 		super();
 		pref = Global.getPref(); // myPreferences sollte sp&#228;ter auch diese Einstellungen speichern
@@ -95,39 +94,28 @@
 
 		this.title = title;
 
-		if((options &amp; HOST) &gt; 0){
-			domains = new mChoice(OC.OCHostNames(),OC.getSiteIndex(pref.lastOCSite));
+		if ((options &amp; HOST) &gt; 0) {
+			domains = new mChoice(OC.OCHostNames(), OC.getSiteIndex(pref.lastOCSite));
 			domains.setTextSize(25, 1);
-			this.addLast(domains, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(domains, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options &amp; TYPE) &gt; 0) {
-			this.addLast( chcType = new mChoice(new String[] {
-					MyLocale.getMsg(1627,&quot;All caches&quot;),
-					MyLocale.getMsg(2,&quot;Tradi&quot;),
-					MyLocale.getMsg(3,&quot;Multi&quot;),
-					MyLocale.getMsg(4,&quot;Virtual&quot;),
-					MyLocale.getMsg(5,&quot;Letterbox&quot;),
-					MyLocale.getMsg(6,&quot;Event&quot;),
-					MyLocale.getMsg(14,&quot;Mega Event&quot;),
-					MyLocale.getMsg(11,&quot;Webcam&quot;),
-					MyLocale.getMsg(8,&quot;Mysterie&quot;),
-					MyLocale.getMsg(13,&quot;CITO&quot;),
-					MyLocale.getMsg(18,&quot;Earth&quot;),
-					MyLocale.getMsg(15,&quot;WhereIGo&quot;),
-				},0), CellConstants.STRETCH, (CellConstants.FILL|CellConstants.WEST));
+			this.addLast(chcType = new mChoice(new String[] { MyLocale.getMsg(1627, &quot;All caches&quot;), MyLocale.getMsg(2, &quot;Tradi&quot;), MyLocale.getMsg(3, &quot;Multi&quot;), MyLocale.getMsg(4, &quot;Virtual&quot;), MyLocale.getMsg(5, &quot;Letterbox&quot;), MyLocale.getMsg(6, &quot;Event&quot;),
+					MyLocale.getMsg(14, &quot;Mega Event&quot;), MyLocale.getMsg(11, &quot;Webcam&quot;), MyLocale.getMsg(8, &quot;Mysterie&quot;), MyLocale.getMsg(13, &quot;CITO&quot;), MyLocale.getMsg(18, &quot;Earth&quot;), MyLocale.getMsg(15, &quot;WhereIGo&quot;), }, 0), CellConstants.STRETCH,
+					(CellConstants.FILL | CellConstants.WEST));
 		}
 
 		if ((options &amp; MINDIST) &gt; 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1628,&quot;min. Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1628, &quot;min. Distance:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			minDistanceInput = new mInput();
 			minDistanceInput.setText(Global.getProfile().getMinDistGC());
-			this.addNext(minDistanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(new mLabel(&quot; km/mi.&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(minDistanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(&quot; km/mi.&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options &amp; DIST) &gt; 0) {
-			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601,&quot;Distance:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(distLbl = new mLabel(MyLocale.getMsg(1601, &quot;Distance:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxDistanceInput = new mInput();
 			String dist1;
 			String dist2;
@@ -138,150 +126,154 @@
 				dist1 = Global.getProfile().getDistOC();
 				dist2 = Global.getProfile().getDistGC();
 			}
-			if ( dist1.equals(&quot;&quot;) || dist1.equals(&quot;0&quot;) || dist1.equals(&quot;0.0&quot;) ) {
+			if (dist1.equals(&quot;&quot;) || dist1.equals(&quot;0&quot;) || dist1.equals(&quot;0.0&quot;)) {
 				dist1 = dist2;
 			}
 			maxDistanceInput.setText(dist1);
-			this.addNext(maxDistanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast(distUnit = new mLabel(&quot; km/mi.&quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxDistanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(distUnit = new mLabel(&quot; km/mi.&quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options &amp; DIRECTION) &gt; 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1629,&quot;Richtung:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1629, &quot;Richtung:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			directionInput = new mInput();
 			directionInput.setText(Global.getProfile().getDirectionGC());
-			directionInput.toolTip=MyLocale.getMsg(1630,&quot;z.B. leer oder von-bis (Grad)&quot;);
-			this.addLast(directionInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			directionInput.toolTip = MyLocale.getMsg(1630, &quot;z.B. leer oder von-bis (Grad)&quot;);
+			this.addLast(directionInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options &amp; MAXNUMBER) &gt; 0) {
-			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623,&quot;Max. number:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberLbl = new mLabel(MyLocale.getMsg(1623, &quot;Max. number:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxNumberInput = new mInput();
-			if ( pref.maxSpiderNumber &lt; 0 || pref.maxSpiderNumber == Integer.MAX_VALUE) {
+			if (pref.maxSpiderNumber &lt; 0 || pref.maxSpiderNumber == Integer.MAX_VALUE) {
 				maxNumberInput.setText(&quot;&quot;);
 			} else {
 				maxNumberInput.setText(Integer.toString(pref.maxSpiderNumber));
 			}
-			this.addNext(maxNumberInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast( new mLabel(MyLocale.getMsg(1624,&quot; caches&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(MyLocale.getMsg(1624, &quot; caches&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options &amp; MAXUPDATE) &gt; 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1631,&quot;Max. Updates:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1631, &quot;Max. Updates:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxNumberUpdates = new mInput();
 			maxNumberUpdates.setText(&quot;&quot;);
-			this.addNext(maxNumberUpdates,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-			this.addLast( new mLabel(MyLocale.getMsg(1624,&quot; caches&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(maxNumberUpdates, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+			this.addLast(new mLabel(MyLocale.getMsg(1624, &quot; caches&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options &amp; MAXLOGS) &gt; 0) {
-			this.addNext(new mLabel(MyLocale.getMsg(1626,&quot;Max. logs:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addNext(new mLabel(MyLocale.getMsg(1626, &quot;Max. logs:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 			maxLogsInput = new mInput();
 			maxLogsInput.setText(Convert.toString(pref.maxLogsToSpider));
-			this.addLast(maxLogsInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+			this.addLast(maxLogsInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		}
 
 		if ((options &amp; IMAGES) &gt; 0) {
 			imagesCheckBox = new mCheckBox();
-			imagesCheckBox.setText(MyLocale.getMsg(1602,&quot;Download Images&quot;));
+			imagesCheckBox.setText(MyLocale.getMsg(1602, &quot;Download Images&quot;));
 			imagesCheckBox.setState(pref.downloadPics);
-			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(imagesCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options &amp; TRAVELBUGS) &gt; 0) {
 			travelbugsCheckBox = new mCheckBox();
-			travelbugsCheckBox.setText(MyLocale.getMsg(1625,&quot;Download TBs&quot;));
+			travelbugsCheckBox.setText(MyLocale.getMsg(1625, &quot;Download TBs&quot;));
 			travelbugsCheckBox.setState(pref.downloadTBs);
-			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			this.addLast(travelbugsCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
-		if((options &amp; INCLUDEFOUND) &gt; 0){
+		if ((options &amp; INCLUDEFOUND) &gt; 0) {
 			foundCheckBox = new mCheckBox();
-			foundCheckBox.setText(MyLocale.getMsg(1622,&quot;Exclude found caches&quot;));
-			foundCheckBox.setState(true);
-			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			foundCheckBox.setText(MyLocale.getMsg(1622, &quot;Exclude found caches&quot;));
+			foundCheckBox.setState(pref.doNotGetFound);
+			this.addLast(foundCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
-		if((options &amp; ALL) &gt; 0){
+		if ((options &amp; ALL) &gt; 0) {
 			missingCheckBox = new mCheckBox();
-			missingCheckBox.setText(MyLocale.getMsg(1606,&quot;Alle erneut downloaden&quot;));
-			missingCheckBox.setState(pref.downloadMissingOC);
-			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
+			missingCheckBox.setText(MyLocale.getMsg(1606, &quot;Alle erneut downloaden&quot;));
+			missingCheckBox.setState(pref.downloadAllOC);
+			this.addLast(missingCheckBox, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
 		}
 
 		if ((options &amp; FILENAME) &gt; 0) {
 			String dir = pref.getImporterPath(&quot;LocGpxImporter&quot;);
 			FileChooser fc = new FileChooser(FileChooserBase.OPEN, dir);
 			fc.addMask(&quot;*.gpx&quot;);
-			fc.setTitle(MyLocale.getMsg(909,&quot;Select file(s)&quot;));
-			if(fc.execute() != FormBase.IDCANCEL){
+			fc.setTitle(MyLocale.getMsg(909, &quot;Select file(s)&quot;));
+			if (fc.execute() != FormBase.IDCANCEL) {
 				dir = fc.getChosenDirectory().toString();
 				pref.setImporterPath(&quot;LocGpxImporter&quot;, dir);
-				//String files[] = fc.getAllChosen();
-				fileName=fc.file;
+				// String files[] = fc.getAllChosen();
+				fileName = fc.file;
+			} else {
+				fileName = &quot;&quot;;
 			}
-			else {
-				fileName=&quot;&quot;;
-			}
 		}
 
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB = new mButton(MyLocale.getMsg(1604, &quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		this.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okB = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		this.addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		okB = new mButton(MyLocale.getMsg(1605, &quot;OK&quot;));
 		okB.setHotKey(0, IKeys.ACTION);
 		okB.setHotKey(0, IKeys.ENTER);
-		this.addLast(okB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		this.addLast(okB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 	}
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB){
+
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB) {
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okB){
-				    // distOC wird hier noch nicht in Pref eingetragen, damit noch gepr&#252;ft werden kann, ob es gr&#246;&#223;er oder kleiner ist als vorher
-					if (missingCheckBox!=null) pref.downloadMissingOC = missingCheckBox.state;
-					if (imagesCheckBox!=null) pref.downloadPics = imagesCheckBox.state;
-					if (travelbugsCheckBox!=null) pref.downloadTBs = travelbugsCheckBox.state;
-					if (maxLogsInput!=null) pref.maxLogsToSpider=Common.parseInt(maxLogsInput.getText());
-					pref.savePreferences();
+			if (ev.target == okB) {
+				// distOC wird hier noch nicht in Pref eingetragen, damit noch gepr&#252;ft werden kann, ob es gr&#246;&#223;er oder kleiner ist als vorher
+				if (missingCheckBox != null)
+					pref.downloadAllOC = missingCheckBox.state;
+				if (imagesCheckBox != null)
+					pref.downloadPics = imagesCheckBox.state;
+				if (travelbugsCheckBox != null)
+					pref.downloadTBs = travelbugsCheckBox.state;
+				if (maxLogsInput != null)
+					pref.maxLogsToSpider = Common.parseInt(maxLogsInput.getText());
+				pref.savePreferences();
 				this.close(FormBase.IDOK);
-				}
+			}
 		}
 		super.onEvent(ev);
 	}
 
-	public String getCacheTypeRestriction(SpiderProperties p){
+	public String getCacheTypeRestriction(SpiderProperties p) {
 		String cacheTypeRestriction = &quot;&quot;;
 
-		if (chcType!=null){
+		if (chcType != null) {
 			try {
 				switch (chcType.getInt()) {
-				case  0:
+				case 0:
 					cacheTypeRestriction = &quot;&quot;;
 					break;
-				case  1:
+				case 1:
 					cacheTypeRestriction = p.getProp(&quot;onlyTraditional&quot;);
 					break;
-				case  2:
+				case 2:
 					cacheTypeRestriction = p.getProp(&quot;onlyMulti&quot;);
 					break;
-				case  3:
-					cacheTypeRestriction = p.getProp(&quot;onlyVirtual&quot;) ;
+				case 3:
+					cacheTypeRestriction = p.getProp(&quot;onlyVirtual&quot;);
 					break;
-				case  4:
+				case 4:
 					cacheTypeRestriction = p.getProp(&quot;onlyLetterboxHybrid&quot;);
 					break;
-				case  5:
+				case 5:
 					cacheTypeRestriction = p.getProp(&quot;onlyEvent&quot;);
 					break;
-				case  6:
+				case 6:
 					cacheTypeRestriction = p.getProp(&quot;onlyMegaEvent&quot;);
 					break;
-				case  7:
+				case 7:
 					cacheTypeRestriction = p.getProp(&quot;onlyWebcam&quot;);
 					break;
-				case  8:
+				case 8:
 					cacheTypeRestriction = p.getProp(&quot;onlyUnknown&quot;);
 					break;
 				case 9:
@@ -296,43 +288,43 @@
 				default:
 					cacheTypeRestriction = &quot;&quot;;
 				}
-			}catch (Exception ex) { // Some tag missing from spider.def
+			} catch (Exception ex) { // Some tag missing from spider.def
 			}
 		}
 		return cacheTypeRestriction;
 	}
 
-	public byte getRestrictedCacheType(SpiderProperties p){
+	public byte getRestrictedCacheType(SpiderProperties p) {
 		byte RestrictedType = CacheType.CW_TYPE_ERROR;
 
-		if (chcType!=null){
+		if (chcType != null) {
 			try {
 				switch (chcType.getInt()) {
-				case  0:
+				case 0:
 					RestrictedType = CacheType.CW_TYPE_ERROR;
 					break;
-				case  1:
+				case 1:
 					RestrictedType = CacheType.CW_TYPE_TRADITIONAL;
 					break;
-				case  2:
+				case 2:
 					RestrictedType = CacheType.CW_TYPE_MULTI;
 					break;
-				case  3:
+				case 3:
 					RestrictedType = CacheType.CW_TYPE_VIRTUAL;
 					break;
-				case  4:
+				case 4:
 					RestrictedType = CacheType.CW_TYPE_LETTERBOX;
 					break;
-				case  5:
+				case 5:
 					RestrictedType = CacheType.CW_TYPE_EVENT;
 					break;
-				case  6:
+				case 6:
 					RestrictedType = CacheType.CW_TYPE_MEGA_EVENT;
 					break;
-				case  7:
+				case 7:
 					RestrictedType = CacheType.CW_TYPE_WEBCAM;
 					break;
-				case  8:
+				case 8:
 					RestrictedType = CacheType.CW_TYPE_UNKNOWN;
 					break;
 				case 9:
@@ -347,7 +339,7 @@
 				default:
 					RestrictedType = CacheType.CW_TYPE_ERROR;
 				}
-			}catch (Exception ex) { // Some tag missing from spider.def
+			} catch (Exception ex) { // Some tag missing from spider.def
 			}
 		}
 		return RestrictedType;

Modified: branches/r1.2/src/CacheWolf/imp/SpiderGC.java
===================================================================
--- branches/r1.2/src/CacheWolf/imp/SpiderGC.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/imp/SpiderGC.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -37,7 +37,6 @@
 import CacheWolf.DateFormat;
 import CacheWolf.Extractor;
 import CacheWolf.Global;
-import CacheWolf.HttpConnection;
 import CacheWolf.ImageInfo;
 import CacheWolf.InfoBox;
 import CacheWolf.Log;
@@ -48,6 +47,7 @@
 import CacheWolf.STRreplace;
 import CacheWolf.SafeXML;
 import CacheWolf.Travelbug;
+import CacheWolf.UrlFetcher;
 import CacheWolf.navi.Area;
 import CacheWolf.navi.Metrics;
 import CacheWolf.navi.MovingMap;
@@ -61,14 +61,10 @@
 import ewe.data.Property;
 import ewe.data.PropertyList;
 import ewe.fx.Image;
-import ewe.io.File;
 import ewe.io.FileBase;
 import ewe.io.FileInputStream;
-import ewe.io.FileOutputStream;
 import ewe.io.IOException;
 import ewe.io.InputStreamReader;
-import ewe.io.JavaUtf8Codec;
-import ewe.net.Socket;
 import ewe.net.URL;
 import ewe.net.UnknownHostException;
 import ewe.sys.Convert;
@@ -77,7 +73,6 @@
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
 import ewe.util.ByteArray;
-import ewe.util.CharArray;
 import ewe.util.Enumeration;
 import ewe.util.Hashtable;
 import ewe.util.Properties;
@@ -111,19 +106,23 @@
 	/** no probs, but exmpl found und not want this */
 	public static int SPIDER_IGNORE = 2;
 
+	/**
+	 * This is the pattern for inlined smilies
+	 */
+	private static final String string = &quot;&lt;img src=\&quot;/images/icons/&quot;;
+
 	private static int ERR_LOGIN = -10;
 	private static Preferences pref;
-	private Profile profile;
+	private final Profile profile;
 
-	private static String cookieID = &quot;&quot;;
-	private static String cookieSession = &quot;&quot;;
+	private static String cookie = &quot;&quot;;
 	private static double minDistance = 0;
 	private static double maxDistance = 0;
 	private static String direction = &quot;&quot;;
 	private static String[] directions;
 
-	private CacheDB cacheDB;
-	private Vector cachesToLoad = new Vector();
+	private final CacheDB cacheDB;
+	private final Vector cachesToLoad = new Vector();
 	private InfoBox infB;
 	private static SpiderProperties p = null;
 	// following filled at doit
@@ -137,13 +136,16 @@
 	private byte restrictedCacheType = 0;
 	private String fileName = &quot;&quot;;
 	private String userToken = &quot;&quot;;
+	private String sessionToken = &quot;&quot;;
 
 	private static String propFirstPage;
 	private static String propFirstPage2;
 	private static String propFirstPageFinds;
 	private static String gotoNextPage = &quot;ctl00$ContentBody$pgrTop$ctl08&quot;;
-	private static String gotoNextBlock = &quot;ctl00$ContentBody$pgrTop$ctl06&quot;;  // change to the block (10pages) of the wanted page
-	private static String gotoPage = &quot;ctl00$ContentBody$pgrTop$lbGoToPage_&quot;; // add pagenumber
+	// change to the block (10pages) of the wanted page
+	private static String gotoNextBlock = &quot;ctl00$ContentBody$pgrTop$ctl06&quot;;
+	// add pagenumber
+	private static String gotoPage = &quot;ctl00$ContentBody$pgrTop$lbGoToPage_&quot;;
 	private static String propMaxDistance;
 	private static String propShowOnlyFound;
 	private static Regex RexPropListBlock;
@@ -182,10 +184,8 @@
 	private int numPrivate = 0;
 	private int page_number = 1;
 	private int num_added = 0;
-	
-	private static HttpConnection conn;
 
-	public SpiderGC(Preferences prf, Profile profile, boolean bypass) {
+	public SpiderGC(Preferences prf, Profile profile) {
 		this.profile = profile;
 		this.cacheDB = profile.cacheDB;
 		pref = prf;
@@ -205,15 +205,16 @@
 	public void doIt(boolean _spiderAllFinds) {
 		cachesToLoad.clear();
 		spiderAllFinds = _spiderAllFinds;
-		origin = pref.getCurCentrePt(); // No need to copy curCentrePt as it is only read and not written
+		// No need to copy curCentrePt as it is only read and not written
+		origin = pref.getCurCentrePt();
 		if (!spiderAllFinds &amp;&amp; !origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;), MyLocale.getMsg(5509,&quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
 			return;
 		}
 
 		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
@@ -224,29 +225,23 @@
 			infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502, &quot;Fetching first page...&quot;));
 			infB.exec();
 
-			pref.log(&quot;ListPages Properties : &quot; + Preferences.NEWLINE
-					+ &quot;minDistance: &quot; + minDistance + Preferences.NEWLINE
-					+ &quot;maxDistance: &quot; + maxDistance + Preferences.NEWLINE
-					+ &quot;directions: &quot; + direction + Preferences.NEWLINE
-					+ &quot;maxNew: &quot; + pref.maxSpiderNumber + Preferences.NEWLINE
-					+ &quot;maxUpdate: &quot; + maxUpdate + Preferences.NEWLINE
-					+ &quot;with Founds       : &quot; + (doNotgetFound ? &quot;no&quot; : &quot;yes&quot;)
-					+ Preferences.NEWLINE + &quot;alias is premium m: &quot;
-					+ (!pref.isPremium ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE
-					+ &quot;Update if new Logs: &quot; + (!pref.checkLog ? &quot;no&quot; : &quot;yes&quot;)
-					+ Preferences.NEWLINE, null);
+			pref.log(&quot;ListPages Properties : &quot; + Preferences.NEWLINE + &quot;minDistance          : &quot; + minDistance + Preferences.NEWLINE + &quot;maxDistance          : &quot; + maxDistance + Preferences.NEWLINE + &quot;directions           : &quot; + direction
+					+ Preferences.NEWLINE + &quot;maxNew               : &quot; + pref.maxSpiderNumber + Preferences.NEWLINE + &quot;maxUpdate            : &quot; + maxUpdate + Preferences.NEWLINE + &quot;with Founds          : &quot; + (doNotgetFound ? &quot;no&quot; : &quot;yes&quot;)
+					+ Preferences.NEWLINE + &quot;alias is premium memb: &quot; + (!pref.isPremium ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE + &quot;Update if new Log    : &quot; + (pref.checkLog ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE + &quot;Update if TB changed : &quot;
+					+ (pref.checkTBs ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE + &quot;Update if DTS changed: &quot; + (pref.checkDTS ? &quot;yes&quot; : &quot;no&quot;) + Preferences.NEWLINE, null);
 
 			Hashtable cachesToUpdate = new Hashtable(cacheDB.size());
 
-			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate,
-					maxDistance, minDistance, directions, cachesToUpdate);
-			if (cachesToUpdate == null) { cachesToUpdate = new Hashtable(); };
+			cachesToUpdate = fillDownloadLists(pref.maxSpiderNumber, maxUpdate, maxDistance, minDistance, directions, cachesToUpdate);
+			if (cachesToUpdate == null) {
+				cachesToUpdate = new Hashtable();
+			}
+			;
 			if (!infB.isClosed) {
-				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;)
-						+ cachesToLoad.size()
-						+ MyLocale.getMsg(5512, &quot; caches&quot;));
+				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;) + cachesToLoad.size() + MyLocale.getMsg(5512, &quot; caches&quot;));
 			}
-			// continue to update index to changed cache.xml things (size,terrain,difficulty,...?) 
+			// continue to update index to changed cache.xml things
+			// (size,terrain,difficulty,...?)
 
 			// =======
 			// Now ready to spider each cache in the lists
@@ -258,7 +253,7 @@
 					cachesToUpdate.clear();
 					break;
 				case Preferences.ASK:
-					MessageBox mBox = new MessageBox(MyLocale.getMsg(5517,&quot;Spider Updates?&quot;), cachesToUpdate.size() + MyLocale.getMsg(5518,&quot; caches in database need an update. Update now?&quot;) , FormBase.IDYES |FormBase.IDNO);
+					final MessageBox mBox = new MessageBox(MyLocale.getMsg(5517, &quot;Spider Updates?&quot;), cachesToUpdate.size() + MyLocale.getMsg(5518, &quot; caches in database need an update. Update now?&quot;), FormBase.IDYES | FormBase.IDNO);
 					if (mBox.execute() != FormBase.IDOK) {
 						cachesToUpdate.clear();
 					}
@@ -267,17 +262,10 @@
 			}
 
 			int spiderErrors = 0;
-			int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
-			boolean loadAllLogs = (pref.maxLogsToSpider &gt; 5) || spiderAllFinds;
-			pref.log(&quot;Download properties : &quot; + Preferences.NEWLINE
-					+ &quot;maxLogs: &quot;
-					+ (loadAllLogs ? &quot;completepage &quot; : &quot;shortpage&quot;) + &quot;nr.:&quot;
-					+ pref.maxLogsToSpider + Preferences.NEWLINE
-					+ &quot;with pictures     : &quot;
-					+ (!pref.downloadPics ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE
-					+ &quot;with tb           : &quot;
-					+ (!pref.downloadTBs ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE,
-					null);
+			final int totalCachesToLoad = cachesToLoad.size() + cachesToUpdate.size();
+			final boolean loadAllLogs = (pref.maxLogsToSpider &gt; 5) || spiderAllFinds;
+			pref.log(&quot;Download properties : &quot; + Preferences.NEWLINE + &quot;maxLogs: &quot; + (loadAllLogs ? &quot;completepage &quot; : &quot;shortpage&quot;) + &quot;nr.:&quot; + pref.maxLogsToSpider + Preferences.NEWLINE + &quot;with pictures     : &quot; + (!pref.downloadPics ? &quot;no&quot; : &quot;yes&quot;)
+					+ Preferences.NEWLINE + &quot;with tb           : &quot; + (!pref.downloadTBs ? &quot;no&quot; : &quot;yes&quot;) + Preferences.NEWLINE, null);
 
 			if (Global.mainTab.statBar != null)
 				Global.mainTab.statBar.updateDisplay(&quot;&quot;);
@@ -288,14 +276,11 @@
 			}
 
 			if (spiderErrors &gt; 0) {
-				new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), spiderErrors + MyLocale.getMsg(5516, &quot; cache descriptions%0acould not be loaded.&quot;), FormBase.DEFOKB).execute();
 			}
 			if (maxNumberAbort) {
-				new MessageBox(MyLocale.getMsg(5519, &quot;Information&quot;),
-						MyLocale.getMsg(5520,&quot;Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated.&quot;),
-						FormBase.DEFOKB).execute();
+				new MessageBox(MyLocale.getMsg(5519, &quot;Information&quot;), MyLocale.getMsg(5520, &quot;Only the given maximum of caches were loaded.%0aRepeat spidering later to load more caches.%0aNo already existing caches were updated.&quot;), FormBase.DEFOKB)
+						.execute();
 			}
 			Global.getProfile().restoreFilter();
 			Global.getProfile().saveIndex(Global.getPref(), true);
@@ -310,81 +295,77 @@
 	public void doItAlongARoute() {
 		Area sq;
 		Vector points = null;
-		Navigate nav=Global.mainTab.nav;
-		MovingMap mm=Global.mainTab.mm;
+		final Navigate nav = Global.mainTab.nav;
+		MovingMap mm = Global.mainTab.mm;
 
 		if (!doDownloadGui(1))
 			return;
 
 		CWPoint startPos = pref.getCurCentrePt();
 		if (!fileName.equals(&quot;&quot;)) {
-			RouteImporter ri = new RouteImporter(fileName);
-			points = ri.doIt();			
+			final RouteImporter ri = new RouteImporter(fileName);
+			points = ri.doIt();
 			if (points.size() &gt; 0) {
-				if (nav!=null) {
-					if (mm==null) {
+				if (nav != null) {
+					if (mm == null) {
 						Global.mainTab.mm = new MovingMap(nav, profile.cacheDB);
-						mm=Global.mainTab.mm;
+						mm = Global.mainTab.mm;
 						nav.setMovingMap(Global.mainTab.mm);
 					}
 					if (nav.curTrack == null) {
-						nav.curTrack=new Track(nav.trackColor);
+						nav.curTrack = new Track(nav.trackColor);
 						mm.addTrack(nav.curTrack);
 					}
 					for (int i = 0; i &lt; points.size(); i++) {
 						try {
 							nav.curTrack.add((TrackPoint) points.get(i));
-						} catch (IndexOutOfBoundsException e) { // track full -&gt; create a new one
-							nav.curTrack=new Track(nav.trackColor);
+						} catch (final IndexOutOfBoundsException e) {
+							// track full -&gt; create a new one
+							nav.curTrack = new Track(nav.trackColor);
 							nav.curTrack.add((TrackPoint) points.get(i));
-							if (mm != null) mm.addTrack(nav.curTrack);
+							if (mm != null)
+								mm.addTrack(nav.curTrack);
 						}
 
 					}
 				}
-				TrackPoint tp = (TrackPoint) points.get(0);
+				final TrackPoint tp = (TrackPoint) points.get(0);
 				startPos = new CWPoint(tp.latDec, tp.lonDec);
 			} else
 				startPos = null;
 		}
 
-		int answer = new MessageBox(MyLocale.getMsg(651, &quot;Question&quot;),
-				MyLocale.getMsg(652,&quot;Update caches with all details?&quot;),
-				MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
-		boolean complete = answer == MessageBox.YESB;
-		if ( answer == MessageBox.IDCANCEL) {
-			if (startPos != null) pref.setCurCentrePt(startPos);
+		final int answer = new MessageBox(MyLocale.getMsg(651, &quot;Question&quot;), MyLocale.getMsg(652, &quot;Update caches with all details?&quot;), MessageBox.YESB | MessageBox.NOB | MessageBox.CANCELB).execute();
+		final boolean complete = answer == MessageBox.YESB;
+		if (answer == MessageBox.IDCANCEL) {
+			if (startPos != null)
+				pref.setCurCentrePt(startPos);
 			return;
 		}
 
 		if (startPos != null &amp;&amp; !startPos.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB))
-					.execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
 			return; //
 		}
 
 		Vm.showWait(true);
-		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502,&quot;Fetching pages...&quot;));
+		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(5502, &quot;Fetching pages...&quot;));
 		infB.exec();
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		// Reset states for all caches when spidering
 		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
 		double lateralDistance = maxDistance; // Seitenabstand in km
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			lateralDistance = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 		cachesToLoad.clear();
 
@@ -396,9 +377,8 @@
 				nextPos = nextRoutePoint(startPos, lateralDistance);
 			} else {
 				double tmpDistance = 0;
-				while (tmpDistance &lt; lateralDistance
-						&amp;&amp; pointsIndex &lt; points.size()) {
-					TrackPoint tp = (TrackPoint) points.get(pointsIndex);
+				while (tmpDistance &lt; lateralDistance &amp;&amp; pointsIndex &lt; points.size()) {
+					final TrackPoint tp = (TrackPoint) points.get(pointsIndex);
 					nextPos = new CWPoint(tp.latDec, tp.lonDec);
 					tmpDistance = nextPos.getDistance(startPos);
 					pointsIndex++;
@@ -407,33 +387,24 @@
 					nextPos = null;
 				else {
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot;
-								+ page_number + &quot; Caches added to CW: &quot;
-								+ num_added + &quot; at &quot;
-								+ pointsIndex+&quot;(&quot;+points.size()+&quot;)&quot;
-								+ nextPos
-								);
+						Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot; + page_number + &quot; Caches added to CW: &quot; + num_added + &quot; at &quot; + pointsIndex + &quot;(&quot; + points.size() + &quot;)&quot; + nextPos);
 				}
 			}
 
-
 			if (nextPos != null) {
 				sq = getSquare(startPos, lateralDistance);
-				getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-						sq.buttomright.latDec, sq.buttomright.lonDec, complete);
+				getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 				// pref.log(&quot;next WP = &quot; + startPos.toString(), null);
 
-				double degrees = startPos.getBearing(nextPos);
-				double distanceToNextCache = startPos.getDistance(nextPos);
-				double anzCheckPoints = distanceToNextCache / lateralDistance;
+				final double degrees = startPos.getBearing(nextPos);
+				final double distanceToNextCache = startPos.getDistance(nextPos);
+				final double anzCheckPoints = distanceToNextCache / lateralDistance;
 				for (int i = 1; i &lt; anzCheckPoints; i++) {
-					CWPoint nextCheckPoint = startPos.project(degrees,
-							lateralDistance);
+					final CWPoint nextCheckPoint = startPos.project(degrees, lateralDistance);
 					startPos = nextCheckPoint;
 					origin = nextCheckPoint;
 					sq = getSquare(origin, lateralDistance);
-					getCaches(sq.topleft.latDec, sq.topleft.lonDec,
-							sq.buttomright.latDec, sq.buttomright.lonDec, complete);
+					getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 					// pref.log(&quot;next CP = &quot; + origin.toString(), null);
 					if (infB.isClosed) {
 						break;
@@ -446,42 +417,36 @@
 			}
 		}
 		sq = getSquare(startPos, lateralDistance);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.buttomright.latDec,
-				sq.buttomright.lonDec, complete);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, complete);
 		// pref.log(&quot;last WP = &quot; + startPos.toString(), null);
 		if (infB.isClosed) {
 			Vm.showWait(false);
 			return;
 		} // or ask for download of intermediate result
-		
+
 		int spiderErrors = 0;
 		if (complete) {
 			for (int i = 0; i &lt; cachesToLoad.size(); i++) {
 				String wpt = (String) cachesToLoad.get(i);
-				boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
+				final boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
 				if (is_found)
 					wpt = wpt.substring(0, wpt.indexOf(&quot;found&quot;));
-				int j = cacheDB.getIndex(wpt);
+				final int j = cacheDB.getIndex(wpt);
 				if (j != -1)
 					cacheDB.removeElementAt(j);
 			}
 			spiderErrors = downloadCaches(cachesToLoad, spiderErrors, cachesToLoad.size(), true);
 
+		} else {
 		}
-		else {
-		}
 
 		infB.close(0);
 		Vm.showWait(false);
 		if (spiderErrors &gt; 0) {
-			new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					spiderErrors + MyLocale.getMsg(5516,&quot; cache descriptions%0acould not be loaded.&quot;),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), spiderErrors + MyLocale.getMsg(5516, &quot; cache descriptions%0acould not be loaded.&quot;), FormBase.DEFOKB).execute();
 		}
 		if (maxNumberAbort) {
-			new MessageBox(MyLocale.getMsg(5519,&quot;Information&quot;),
-					MyLocale.getMsg(5520,&quot;Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated.&quot;),
-					FormBase.DEFOKB).execute();
+			new MessageBox(MyLocale.getMsg(5519, &quot;Information&quot;), MyLocale.getMsg(5520, &quot;Only the given maximum of caches were loaded.\nRepeat spidering later to load more caches.\nNo already existing caches were updated.&quot;), FormBase.DEFOKB).execute();
 		}
 		Global.getProfile().restoreFilter();
 		Global.getProfile().saveIndex(Global.getPref(), true);
@@ -495,9 +460,9 @@
 		CacheHolder ch = null;
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
 			ch = cacheDB.get(i);
-			if (ch.is_Checked &amp;&amp; ch.pos.isValid()) {
-				CWPoint tmpPos = ch.pos;
-				double tmpDistance = tmpPos.getDistance(startPos);
+			if (ch.is_Checked &amp;&amp; ch.getPos().isValid()) {
+				final CWPoint tmpPos = ch.getPos();
+				final double tmpDistance = tmpPos.getDistance(startPos);
 				if (nextDistance == 0) {
 					// Startwert
 					index = i;
@@ -519,38 +484,36 @@
 			}
 		}
 		if (index &gt; -1) {
-			return cacheDB.get(index).pos;
+			return cacheDB.get(index).getPos();
 		} else
 			return null;
 	}
 
 	private Area getSquare(CWPoint centre, double halfSideLengthKm) {
-		int north = 0;
-		int east = 1;
-		int south = 2;
-		int west = 3;
-		double halfSideLength = halfSideLengthKm * 1000.0; // in meters
-		Area ret = new Area();
+		final int north = 0;
+		final int east = 1;
+		final int south = 2;
+		final int west = 3;
+		final double halfSideLength = halfSideLengthKm * 1000.0; // in meters
+		final Area ret = new Area();
 		ret.topleft.latDec = centre.latDec;
 		ret.topleft.lonDec = centre.lonDec;
 		ret.topleft.shift(halfSideLength, north);
 		ret.topleft.shift(halfSideLength, west);
 
-		ret.buttomright.latDec = centre.latDec;
-		ret.buttomright.lonDec = centre.lonDec;
-		ret.buttomright.shift(halfSideLength, south);
-		ret.buttomright.shift(halfSideLength, east);
+		ret.bottomright.latDec = centre.latDec;
+		ret.bottomright.lonDec = centre.lonDec;
+		ret.bottomright.shift(halfSideLength, south);
+		ret.bottomright.shift(halfSideLength, east);
 
 		return ret;
 	}
 
-	public void doItQuickFillFromMapList() {
+	public void doItQuickFillFromOldMapList() {
 
-		CWPoint origin = pref.getCurCentrePt();
+		final CWPoint origin = pref.getCurCentrePt();
 		if (!origin.isValid()) {
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
 			return; //
 		}
 		if (!doDownloadGui(2))
@@ -560,31 +523,27 @@
 		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(1609, &quot;getting the caches.&quot;));
 		infB.exec();
 
-		// Reset states for all caches when spidering
-		// (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
+		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
 		for (int i = 0; i &lt; cacheDB.size(); i++) {
-			CacheHolder ch = cacheDB.get(i);
+			final CacheHolder ch = cacheDB.get(i);
 			if (ch.mainCache == null)
 				ch.initStates(false);
 		}
 
-		double halfSideLength = maxDistance; // halbe Seitenl&#228;nge eines Quadrats ums Zentrum in km
+		// halbe Seitenl&#228;nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance;
 		if (pref.metricSystem == Metrics.IMPERIAL) {
-			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES,
-					Metrics.KILOMETER);
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
 		}
 
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return;
-		}
+		if (!login())
+			return;
 
 		page_number = 0;
 		num_added = 0;
 
-		Area sq = getSquare(origin, halfSideLength);
-		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.buttomright.latDec,
-				sq.buttomright.lonDec, false);
+		final Area sq = getSquare(origin, halfSideLength);
+		getCaches(sq.topleft.latDec, sq.topleft.lonDec, sq.bottomright.latDec, sq.bottomright.lonDec, false);
 
 		if (!infB.isClosed)
 			infB.close(0);
@@ -595,22 +554,24 @@
 
 	}
 
-	private void getCaches(double north, double west, double south,
-			double east, boolean setCachesToLoad) {
+	private void getCaches(double north, double west, double south, double east, boolean setCachesToLoad) {
 		if (infB.isClosed)
 			return;
-		double lm = (north + south) / 2.0;
-		CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
-		CWPoint rm = new CWPoint(lm, east);
-		double len = middle.getDistance(rm) * 2.0;
+		final double lm = (north + south) / 2.0;
+		final CWPoint middle = new CWPoint(lm, (west + east) / 2.0);
+		final CWPoint rm = new CWPoint(lm, east);
+		final double len = middle.getDistance(rm) * 2.0;
 		page_number++;
-		String listPage = getMapListPage(middle, north, west, south, east);
-		int i = listPage.indexOf(&quot;\&quot;count\\\&quot;:&quot;); // \&quot;count\&quot;:
+		final String listPage = getMapListPage(middle, north, west, south, east);
+		final int i = listPage.indexOf(&quot;\&quot;count\\\&quot;:&quot;); // \&quot;count\&quot;:
+		if (i == -1) {
+			pref.log(&quot;[getCaches:getMapListPage]got nothing!&quot; + listPage, null);
+			return;
+		}
 		pref.log(&quot;&quot; + north + &quot; &quot; + west + &quot; &quot; + south + &quot; &quot; + east + &quot; &quot; + listPage.substring(i) + &quot;\n len=&quot; + len);
-		if ((listPage.indexOf(&quot;\&quot;count\\\&quot;:501&quot;) &gt; -1)
-		||  (listPage.indexOf(&quot;\&quot;count\\\&quot;:0&quot;) &gt; -1 &amp;&amp; len &gt; 30)) {
-			double northsouthmiddle = (north + south) / 2.0;
-			double westeastmiddle = (west + east) / 2.0;
+		if ((listPage.indexOf(&quot;\&quot;count\\\&quot;:501&quot;) &gt; -1) || (listPage.indexOf(&quot;\&quot;count\\\&quot;:0&quot;) &gt; -1 &amp;&amp; len &gt; 30)) {
+			final double northsouthmiddle = (north + south) / 2.0;
+			final double westeastmiddle = (west + east) / 2.0;
 			getCaches(north, west, northsouthmiddle, westeastmiddle, setCachesToLoad);
 			getCaches(north, westeastmiddle, northsouthmiddle, east, setCachesToLoad);
 			getCaches(northsouthmiddle, west, south, westeastmiddle, setCachesToLoad);
@@ -621,51 +582,55 @@
 	}
 
 	private void addCaches(String listPage, boolean setCachesToLoad) {
-		String[] caches = mString.split(listPage, '{');
-		//int posId=0;        //id egal
-		//int posName=1;      //nn
-		
-		//positions decreased by 2, because we cut away the name to prevent parsing errors
-		int posWP=0;        //gc 
-		int posLat=1;       //lat
-		int posLon=2;       //lon
-		int posType=3;      //ctid
-		int posFound=4;     //f
-		int posOwn=5;       //o
-		int posAvailable=6; //ia
+		final String[] caches = mString.split(listPage, '{');
+		// int posId=0; //id egal
+		// int posName=1; //nn
+
+		// positions decreased by 2, because we cut away the name to prevent
+		// parsing errors
+		final int posWP = 0; // gc
+		final int posLat = 1; // lat
+		final int posLon = 2; // lon
+		final int posType = 3; // ctid
+		final int posFound = 4; // f
+		final int posOwn = 5; // o
+		final int posAvailable = 6; // ia
 		// ignoring first 3 lines
 		for (int i = 4; i &lt; caches.length; i++) {
-			if (infB.isClosed) return;
-			
-			//cut away name to prevent parsing errors			
-			int WpIndex = caches[i].indexOf(&quot;\&quot;gc\\\&quot;&quot;);
-			String elements[] = mString.split(caches[i].substring(WpIndex), ',');
-			
-			boolean found = (elements[posFound].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
-			if (found &amp;&amp; doNotgetFound)	continue;
-			
-			byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
+			if (infB.isClosed)
+				return;
+
+			// cut away name to prevent parsing errors
+			final int WpIndex = caches[i].indexOf(&quot;\&quot;gc\\\&quot;&quot;);
+			final String elements[] = mString.split(caches[i].substring(WpIndex), ',');
+
+			final boolean found = (elements[posFound].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
+			if (found &amp;&amp; doNotgetFound)
+				continue;
+
+			final byte cacheType = CacheType.gcSpider2CwType(mString.split(elements[posType], ':')[1]);
 			if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
-				if (restrictedCacheType != cacheType) continue;
+				if (restrictedCacheType != cacheType)
+					continue;
 			}
 
 			String wp = mString.split(elements[posWP], '\&quot;')[3];
-			wp=wp.substring(0, wp.length()-1);
+			wp = wp.substring(0, wp.length() - 1);
 			CacheHolder ch = cacheDB.get(wp);
 			if (ch == null) {
 
-				String lat = mString.split(elements[posLat], ':')[1];
-				String lon = mString.split(elements[posLon], ':')[1];
-				String own = mString.split(elements[posOwn], ':')[1];
-				boolean available = (elements[posAvailable].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
-				
-				int NameIndex = caches[i].indexOf(&quot;\&quot;nn\\\&quot;&quot;);
-				String cacheName = caches[i].substring (NameIndex + 8, WpIndex - 4 );
-				cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot; );
+				final String lat = mString.split(elements[posLat], ':')[1];
+				final String lon = mString.split(elements[posLon], ':')[1];
+				final String own = mString.split(elements[posOwn], ':')[1];
+				final boolean available = (elements[posAvailable].indexOf(&quot;true&quot;) &gt; -1 ? true : false);
 
+				final int NameIndex = caches[i].indexOf(&quot;\&quot;nn\\\&quot;&quot;);
+				String cacheName = caches[i].substring(NameIndex + 8, WpIndex - 4);
+				cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
+
 				ch = new CacheHolder();
 				ch.setWayPoint(wp);
-				ch.setLatLon(lat + &quot; &quot; + lon);
+				ch.setPos(new CWPoint(lat + &quot; &quot; + lon));
 				ch.setType(cacheType);
 				if (own.equals(&quot;true&quot;)) {
 					ch.setOwned(true);
@@ -682,13 +647,11 @@
 				if (setCachesToLoad) {
 					cachesToLoad.add(wp + &quot;found&quot;);
 				} else {
-					ch.getCacheDetails(false).URL=&quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot;+wp;
+					ch.getCacheDetails(false).URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + wp;
 					ch.save();
 				}
 				if (Global.mainTab.statBar != null)
-					Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot;
-							+ page_number + &quot; Caches added to CW: &quot;
-							+ num_added);
+					Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot; + page_number + &quot; Caches added to CW: &quot; + num_added);
 			} else {
 			}
 		}
@@ -699,13 +662,8 @@
 		OCXMLImporterScreen options;
 		direction = &quot;&quot;;
 		if (menu == 0 &amp;&amp; spiderAllFinds) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(217,
-					&quot;Spider all finds from geocaching.com&quot;),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER
-							| OCXMLImporterScreen.MAXUPDATE
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.MAXLOGS);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(217, &quot;Spider all finds from geocaching.com&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.IMAGES
+					| OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS);
 			// setting defaults for input
 			options.maxNumberUpdates.setText(&quot;0&quot;);
 			// doing the input
@@ -716,16 +674,8 @@
 			maxDistance = 1.0;
 			minDistance = 0.0;
 		} else if (menu == 0) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(131,
-					&quot;Download from geocaching.com&quot;), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.MAXNUMBER
-					| OCXMLImporterScreen.MAXUPDATE
-					| OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.DIRECTION
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.IMAGES
-					| OCXMLImporterScreen.TRAVELBUGS
-					| OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(131, &quot;Download from geocaching.com&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.MAXNUMBER | OCXMLImporterScreen.MAXUPDATE | OCXMLImporterScreen.MINDIST | OCXMLImporterScreen.DIST
+					| OCXMLImporterScreen.DIRECTION | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.TRAVELBUGS | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.TYPE);
 			// setting defaults for input
 			if (pref.spiderUpdates == Preferences.NO) {
 				options.maxNumberUpdates.setText(&quot;0&quot;);
@@ -736,29 +686,21 @@
 			}
 			// setting default values for options not used (if necessary)
 
-			String minDist = options.minDistanceInput.getText();
+			final String minDist = options.minDistanceInput.getText();
 			minDistance = Common.parseDouble(minDist);
 			profile.setMinDistGC(Double.toString(minDistance).replace(',', '.'));
 
 			direction = options.directionInput.getText();
 			directions = mString.split(direction, '-');
-			
+
 			doNotgetFound = options.foundCheckBox.getState();
 			profile.setDirectionGC(direction);
 
-		} else if (menu == 1) { // menu = 1 input values for get Caches along a
-								// route
-			options = new OCXMLImporterScreen(MyLocale.getMsg(137,
-					&quot;Download along a Route from geocaching.com&quot;),
-					OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST
-							| OCXMLImporterScreen.INCLUDEFOUND
-							| OCXMLImporterScreen.TRAVELBUGS
-							| OCXMLImporterScreen.IMAGES
-							| OCXMLImporterScreen.MAXLOGS
-							| OCXMLImporterScreen.FILENAME
-							| OCXMLImporterScreen.TYPE);
-			// setting defaults for input
-			// doing the input
+		} else if (menu == 1) {
+			// menu = 1 input values for get Caches along a route
+			options = new OCXMLImporterScreen(MyLocale.getMsg(137, &quot;Download along a Route from geocaching.com&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TRAVELBUGS
+					| OCXMLImporterScreen.IMAGES | OCXMLImporterScreen.MAXLOGS | OCXMLImporterScreen.FILENAME | OCXMLImporterScreen.TYPE);
+			// setting defaults for input doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
 				return false;
 			}
@@ -768,22 +710,18 @@
 			maxUpdate = 0;
 			fileName = options.fileName;
 		} else { // if (menu == 2) {
-			options = new OCXMLImporterScreen(MyLocale.getMsg(138,
-					&quot;Qick Import&quot;), OCXMLImporterScreen.ISGC
-					| OCXMLImporterScreen.DIST
-					| OCXMLImporterScreen.INCLUDEFOUND
-					| OCXMLImporterScreen.TYPE);
+			options = new OCXMLImporterScreen(MyLocale.getMsg(138, &quot;Qick Import&quot;), OCXMLImporterScreen.ISGC | OCXMLImporterScreen.DIST | OCXMLImporterScreen.INCLUDEFOUND | OCXMLImporterScreen.TYPE);
 			// setting defaults for input doing the input
 			if (options.execute() == FormBase.IDCANCEL) {
 				return false;
 			}
 			doNotgetFound = options.foundCheckBox.getState();
 		}
-
+		pref.doNotGetFound = doNotgetFound;
 		if (menu == 0) {
 
 			int maxNew = -1;
-			String maxNumberString = options.maxNumberInput.getText();
+			final String maxNumberString = options.maxNumberInput.getText();
 			if (maxNumberString.length() != 0) {
 				maxNew = Common.parseInt(maxNumberString);
 			}
@@ -796,7 +734,7 @@
 			}
 
 			maxUpdate = -1;
-			String maxUpdateString = options.maxNumberUpdates.getText();
+			final String maxUpdateString = options.maxNumberUpdates.getText();
 			if (maxUpdateString.length() != 0) {
 				maxUpdate = Common.parseInt(maxUpdateString);
 			}
@@ -807,10 +745,14 @@
 		// options for all
 
 		if (options.maxDistanceInput != null) {
-			String maxDist = options.maxDistanceInput.getText();
+			final String maxDist = options.maxDistanceInput.getText();
 			maxDistance = Common.parseDouble(maxDist);
-			if (maxDistance == 0) return false;
-			if (maxDistance &lt; 0.5) maxDistance = 0.5; // zur Sicherheit bei &quot;along the route&quot; mindenstens 500 meter Umkreis
+			if (maxDistance == 0)
+				return false;
+			// zur Sicherheit bei &quot;along the route&quot;
+			// mindenstens 500 meter Umkreis
+			if (maxDistance &lt; 0.5)
+				maxDistance = 0.5;
 			profile.setDistGC(Double.toString(maxDistance));
 		}
 
@@ -824,13 +766,9 @@
 
 	}
 
-	private Hashtable fillDownloadLists(int maxNew, int maxUpdate,
-			double toDistance, double fromDistance, String[] directions,
-			Hashtable cExpectedForUpdate) {
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK)
-				return null;
-		}
+	private Hashtable fillDownloadLists(int maxNew, int maxUpdate, double toDistance, double fromDistance, String[] directions, Hashtable cExpectedForUpdate) {
+		if (!login())
+			return null;
 
 		int numFinds;
 		int startPage = 1;
@@ -839,27 +777,25 @@
 			// distance in miles for URL
 			int fromDistanceInMiles = (int) java.lang.Math.ceil(fromDistance);
 			if (pref.metricSystem != Metrics.IMPERIAL) {
-				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics
-						.convertUnit(fromDistance, Metrics.KILOMETER,
-								Metrics.MILES));
+				fromDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(fromDistance, Metrics.KILOMETER, Metrics.MILES));
 			}
 			// - a mile to be save to get a page with fromDistance
 			getFirstListPage(java.lang.Math.max(fromDistanceInMiles - 1, 1));
-			numFinds = getNumFound(htmlListPage); // Number of caches from gc Listpage
-			// calc the number of the startpage
+			// Number of caches from gc Listpage calc the number of the startpage
+			numFinds = getNumFound(htmlListPage);
 			startPage = (int) java.lang.Math.ceil(numFinds / 20);
 		}
 
 		// max distance in miles for URL, so we can get more than 80km
 		int toDistanceInMiles = (int) java.lang.Math.ceil(toDistance);
 		if (pref.metricSystem != Metrics.IMPERIAL) {
-			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(
-					toDistance, Metrics.KILOMETER, Metrics.MILES));
+			toDistanceInMiles = (int) java.lang.Math.ceil(Metrics.convertUnit(toDistance, Metrics.KILOMETER, Metrics.MILES));
 		}
 		// add a mile to be save from different distance calculations in CW and at GC
 		toDistanceInMiles++;
 		getFirstListPage(toDistanceInMiles);
-		numFinds = getNumFound(htmlListPage); // Number of caches from gc first Listpage
+		// Number of caches from gcfirst Listpage
+		numFinds = getNumFound(htmlListPage);
 
 		if (fromDistance &gt; 0) {
 			// skip (most of) the pages with distance &lt; fromDistance
@@ -873,9 +809,7 @@
 		int numFoundInDB = 0; // Number of GC-founds already in this profile
 		if (spiderAllFinds) {
 			numFoundInDB = getFoundInDB();
-			pref.log((spiderAllFinds ? &quot;all Finds (DB/GC)&quot; + numFoundInDB + &quot;/&quot;
-					+ numFinds : &quot;new and update Caches&quot;)
-					+ Preferences.NEWLINE, null);
+			pref.log((spiderAllFinds ? &quot;all Finds (DB/GC)&quot; + numFoundInDB + &quot;/&quot; + numFinds : &quot;new and update Caches&quot;) + Preferences.NEWLINE, null);
 			maxNew = java.lang.Math.min(numFinds - numFoundInDB, maxNew);
 			if (maxUpdate == 0 &amp;&amp; maxNew == 0) {
 				Vm.showWait(false);
@@ -887,36 +821,28 @@
 		if (maxUpdate &gt; 0) {
 			double distanceInKm = toDistance;
 			if (pref.metricSystem == Metrics.IMPERIAL) {
-				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES,
-						Metrics.KILOMETER);
+				distanceInKm = Metrics.convertUnit(toDistance, Metrics.MILES, Metrics.KILOMETER);
 			}
 			// expecting all are changed (archived caches remain always)
 			for (int i = 0; i &lt; cacheDB.size(); i++) {
-				CacheHolder ch = cacheDB.get(i);
+				final CacheHolder ch = cacheDB.get(i);
 				if (spiderAllFinds) {
-					if ((ch.getWayPoint().substring(0, 2)
-							.equalsIgnoreCase(&quot;GC&quot;))
-							&amp;&amp; !ch.is_black()) {
+					if ((ch.getWayPoint().substring(0, 2).equalsIgnoreCase(&quot;GC&quot;)) &amp;&amp; !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				} else {
-					if ((!ch.is_archived())
-							&amp;&amp; (ch.kilom &lt;= distanceInKm)
-							&amp;&amp; !(doNotgetFound &amp;&amp; (ch.is_found() || ch
-									.is_owned()))
-							&amp;&amp; (ch.getWayPoint().substring(0, 2)
-									.equalsIgnoreCase(&quot;GC&quot;))
-							&amp;&amp; ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch
-									.getType() == restrictedCacheType))
-							&amp;&amp; !ch.is_black()) {
+					if ((!ch.is_archived()) &amp;&amp; (ch.kilom &lt;= distanceInKm) &amp;&amp; !(doNotgetFound &amp;&amp; (ch.is_found() || ch.is_owned())) &amp;&amp; (ch.getWayPoint().substring(0, 2).equalsIgnoreCase(&quot;GC&quot;))
+							&amp;&amp; ((restrictedCacheType == CacheType.CW_TYPE_ERROR) || (ch.getType() == restrictedCacheType)) &amp;&amp; !ch.is_black()) {
 						cExpectedForUpdate.put(ch.getWayPoint(), ch);
 					}
 				}
 			}
 		}
-		int startSize = cExpectedForUpdate.size(); // for save reasons
+		// for save reasons
+		final int startSize = cExpectedForUpdate.size();
 
-		Hashtable cFoundForUpdate = new Hashtable(cacheDB.size()); // for don't loose the already done work
+		// for don't loose the already done work
+		final Hashtable cFoundForUpdate = new Hashtable(cacheDB.size());
 		page_number = 1;
 		int found_on_page = 0;
 		try {
@@ -927,41 +853,41 @@
 				if (RexPropListBlock.didMatch()) {
 					tableOfHtmlListPage = RexPropListBlock.stringMatched(1);
 				} else {
-					pref.log(&quot;check listBlockRex in spider.def&quot; + Preferences.NEWLINE + htmlListPage);
+					pref.log(&quot;[SpiderGC.java:fillDownloadLists]check listBlockRex!&quot;);
 					tableOfHtmlListPage = &quot;&quot;;
 				}
 				RexPropLine.search(tableOfHtmlListPage);
 				while (toDistance &gt; 0) {
 					if (!RexPropLine.didMatch()) {
 						if (page_number == 1 &amp;&amp; found_on_page == 0)
-							pref.log(&quot;check lineRex in spider.def&quot;);
+							pref.log(&quot;[SpiderGC.java:fillDownloadLists]check lineRex!&quot;);
 						break;
 					}
 					found_on_page++;
 					if (Global.mainTab.statBar != null)
-						Global.mainTab.statBar.updateDisplay(&quot;working &quot;
-								+ page_number + &quot; / &quot; + found_on_page);
-					String CacheDescriptionGC = RexPropLine.stringMatched(1);
-					double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
+						Global.mainTab.statBar.updateDisplay(&quot;working &quot; + page_number + &quot; / &quot; + found_on_page);
+					final String CacheDescriptionGC = RexPropLine.stringMatched(1);
+					final double[] DistanceAndDirection = getDistanceAndDirection(CacheDescriptionGC);
 					String chWaypoint = getWP(CacheDescriptionGC);
 					if (DistanceAndDirection[0] &lt;= toDistance) {
-						CacheHolder ch = cacheDB.get(chWaypoint);
+						final CacheHolder ch = cacheDB.get(chWaypoint);
 						if (ch == null) { // not in DB
-							if (DistanceAndDirection[0] &gt;= fromDistance
-									&amp;&amp; directionOK(directions, DistanceAndDirection[1])
-									&amp;&amp; doPMCache(chWaypoint, CacheDescriptionGC)
-									&amp;&amp; cachesToLoad.size() &lt; maxNew) {
-								if (CacheDescriptionGC.indexOf(propFound) != -1) chWaypoint = chWaypoint + &quot;found&quot;;
-								if (!cachesToLoad.contains(chWaypoint)) { cachesToLoad.add(chWaypoint);	}
+							if (DistanceAndDirection[0] &gt;= fromDistance &amp;&amp; directionOK(directions, DistanceAndDirection[1]) &amp;&amp; doPMCache(chWaypoint, CacheDescriptionGC) &amp;&amp; cachesToLoad.size() &lt; maxNew) {
+								if (CacheDescriptionGC.indexOf(propFound) != -1)
+									chWaypoint = chWaypoint + &quot;found&quot;;
+								if (!cachesToLoad.contains(chWaypoint)) {
+									cachesToLoad.add(chWaypoint);
+								}
 							} else {
-								// pref.log(&quot;no load of (Premium Cache/other direction/short Distance ?) &quot; + chWaypoint);
+								// pref.log(&quot;no load of (Premium Cache/other direction/short
+								// Distance ?) &quot; + chWaypoint);
 								cExpectedForUpdate.remove(chWaypoint);
 							}
 						} else {
-							if (maxUpdate &gt; 0) { // regardless of fromDistance
+							if (maxUpdate &gt; 0) {
+								// regardless of fromDistance
 								if (!ch.is_black()) {
-									if (doPMCache(chWaypoint, CacheDescriptionGC)
-										&amp;&amp; updateExists(ch, CacheDescriptionGC)) {
+									if (doPMCache(chWaypoint, CacheDescriptionGC) &amp;&amp; updateExists(ch, CacheDescriptionGC)) {
 										if (cFoundForUpdate.size() &lt; maxUpdate) {
 											cFoundForUpdate.put(chWaypoint, ch);
 										} else
@@ -977,25 +903,21 @@
 								toDistance = 0;
 								cExpectedForUpdate.clear();
 							} else {
-								if (cExpectedForUpdate.size() &lt;= cFoundForUpdate
-										.size()) {
+								if (cExpectedForUpdate.size() &lt;= cFoundForUpdate.size()) {
 									toDistance = 0;
 								}
 							}
 						}
 					} else
-						toDistance = 0; // finish listing
-					// get next row of table (next Cache Description) of this htmlListPage
-					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine
-							.matchedTo());
+						// finish listing get next row of table (next Cache Description) of this htmlListPage
+						toDistance = 0;
+					RexPropLine.searchFrom(tableOfHtmlListPage, RexPropLine.matchedTo());
 					if (infB.isClosed) {
 						toDistance = 0;
 						break;
 					}
 				} // next Cache
-				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;)
-						+ cachesToLoad.size() + &quot; / &quot; + cFoundForUpdate.size()
-						+ MyLocale.getMsg(5512, &quot; caches&quot;));
+				infB.setInfo(MyLocale.getMsg(5511, &quot;Found &quot;) + cachesToLoad.size() + &quot; / &quot; + cFoundForUpdate.size() + MyLocale.getMsg(5512, &quot; caches&quot;));
 				if (found_on_page &lt; 20) {
 					if (spiderAllFinds) {
 						// check all pages ( seen a gc-account with found_on_page less 20 and not on end )
@@ -1012,53 +934,42 @@
 				}
 			} // loop pages
 		} // try
-		catch (Exception ex) {
+		catch (final Exception ex) {
 			pref.log(&quot;Download error : &quot;, ex, true);
 			infB.close(0);
 			Vm.showWait(false);
 			cExpectedForUpdate.clear();
 		}
-		pref.log(&quot;Checked &quot; + page_number + &quot; pages&quot;+Preferences.NEWLINE+
-				&quot;with &quot; + ((page_number-1)*20+found_on_page) + &quot; caches&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + cachesToLoad.size() + &quot; new caches&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + cExpectedForUpdate.size() + &quot;/&quot; + cFoundForUpdate.size() + &quot; caches for update&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + numAvailableUpdates + &quot; caches with changed available status.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + numLogUpdates + &quot; caches with new found in log.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + (cExpectedForUpdate.size()-numAvailableUpdates-numLogUpdates) + &quot; caches possibly archived.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + cFoundForUpdate.size() + &quot;?=&quot; + (numFoundUpdates+numArchivedUpdates+numAvailableUpdates+numArchivedUpdates) + &quot; caches to update.&quot;+Preferences.NEWLINE+
-				&quot;Found &quot; + numPrivate + &quot; Premium Caches (for non Premium Member.)&quot;,null);
-		if(spiderAllFinds){
-			pref.log(&quot;Found &quot; + numFoundUpdates + &quot; caches with no found in profile.&quot;+Preferences.NEWLINE+
-			&quot;Found &quot; + numArchivedUpdates + &quot; caches with changed archived status.&quot;+Preferences.NEWLINE,null);
+		pref.log(&quot;Checked &quot; + page_number + &quot; pages&quot; + Preferences.NEWLINE + &quot;with &quot; + ((page_number - 1) * 20 + found_on_page) + &quot; caches&quot; + Preferences.NEWLINE + &quot;Found &quot; + cachesToLoad.size() + &quot; new caches&quot; + Preferences.NEWLINE + &quot;Found &quot;
+				+ cExpectedForUpdate.size() + &quot;/&quot; + cFoundForUpdate.size() + &quot; caches for update&quot; + Preferences.NEWLINE + &quot;Found &quot; + numAvailableUpdates + &quot; caches with changed available status.&quot; + Preferences.NEWLINE + &quot;Found &quot; + numLogUpdates
+				+ &quot; caches with new found in log.&quot; + Preferences.NEWLINE + &quot;Found &quot; + (cExpectedForUpdate.size() - numAvailableUpdates - numLogUpdates) + &quot; caches possibly archived.&quot; + Preferences.NEWLINE + &quot;Found &quot; + cFoundForUpdate.size() + &quot; ?= &quot;
+				+ (numFoundUpdates + numArchivedUpdates + numAvailableUpdates + numArchivedUpdates) + &quot; caches to update.&quot; + Preferences.NEWLINE + &quot;Found &quot; + numPrivate + &quot; Premium Caches (for non Premium Member.)&quot;, null);
+		if (spiderAllFinds) {
+			pref.log(&quot;Found &quot; + numFoundUpdates + &quot; caches with no found in profile.&quot; + Preferences.NEWLINE + &quot;Found &quot; + numArchivedUpdates + &quot; caches with changed archived status.&quot; + Preferences.NEWLINE, null);
 		}
 
 		if (cExpectedForUpdate.size() == startSize)
 			cExpectedForUpdate.clear(); // there must be something wrong
-		if (cExpectedForUpdate.size() == 0
-				|| cExpectedForUpdate.size() &gt; maxUpdate)
+		if (cExpectedForUpdate.size() == 0 || cExpectedForUpdate.size() &gt; maxUpdate)
 			cExpectedForUpdate = cFoundForUpdate;
 		return cExpectedForUpdate;
 
 	}
 
-	private int downloadCaches(Vector cachesToLoad, int spiderErrors,
-			int totalCachesToLoad, boolean loadAllLogs) {
+	private int downloadCaches(Vector cachesToLoad, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		for (int i = 0; i &lt; cachesToLoad.size(); i++) {
 			if (infB.isClosed)
 				break;
 			String wpt = (String) cachesToLoad.get(i);
-			boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
+			final boolean is_found = wpt.indexOf(&quot;found&quot;) != -1;
 			if (is_found)
 				wpt = wpt.substring(0, wpt.indexOf(&quot;found&quot;));
 			// Get only caches not already available in the DB
 			if (cacheDB.getIndex(wpt) == -1) {
-				infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + wpt + &quot; (&quot;
-						+ (i + 1) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
-				CacheHolder holder = new CacheHolder();
+				infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + wpt + &quot; (&quot; + (i + 1) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
+				final CacheHolder holder = new CacheHolder();
 				holder.setWayPoint(wpt);
-				int test = getCacheByWaypointName(holder, false,
-						pref.downloadPics, pref.downloadTBs, doNotgetFound,
-						loadAllLogs || is_found |!doNotgetFound);
+				final int test = getCacheByWaypointName(holder, false, pref.downloadPics, pref.downloadTBs, doNotgetFound, loadAllLogs || is_found | !doNotgetFound);
 				if (test == SPIDER_CANCEL) {
 					infB.close(0);
 					break;
@@ -1067,8 +978,7 @@
 				} else if (test == SPIDER_OK) {
 					cacheDB.add(holder);
 					holder.save();
-				} // For test == SPIDER_IGNORE_PREMIUM and SPIDER_IGNORE there
-					// is nothing to do
+				} // For test == SPIDER_IGNORE_PREMIUM and SPIDER_IGNORE there is nothing to do
 			}
 		}
 		return spiderErrors;
@@ -1076,18 +986,15 @@
 
 	private int updateCaches(Hashtable cachesToUpdate, int spiderErrors, int totalCachesToLoad, boolean loadAllLogs) {
 		int j = 1;
-		for (Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
+		for (final Enumeration e = cachesToUpdate.elements(); e.hasMoreElements(); j++) {
 			if (infB.isClosed)
 				break;
-			CacheHolder ch = (CacheHolder) e.nextElement();
-			infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + ch.getWayPoint()
-					+ &quot; (&quot; + (cachesToLoad.size() + j) + &quot; / &quot;
-					+ totalCachesToLoad + &quot;)&quot;);
-			int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
+			final CacheHolder ch = (CacheHolder) e.nextElement();
+			infB.setInfo(MyLocale.getMsg(5513, &quot;Loading: &quot;) + ch.getWayPoint() + &quot; (&quot; + (cachesToLoad.size() + j) + &quot; / &quot; + totalCachesToLoad + &quot;)&quot;);
+			final int test = spiderSingle(cacheDB.getIndex(ch), infB, false, loadAllLogs);
 			if (test == SPIDER_CANCEL) {
 				break;
-			} 
-			else {
+			} else {
 				if (test == SPIDER_ERROR) {
 					spiderErrors++;
 					pref.log(&quot;[updateCaches] could not spider &quot; + ch.getWayPoint(), null);
@@ -1100,60 +1007,47 @@
 	}
 
 	/**
-	 * Method to spider a single cache. It assumes a login has already been
-	 * performed!
+	 * Method to spider a single cache. It assumes a login has already been performed!
 	 * 
-	 * @return 1 if spider was successful, -1 if spider was cancelled by closing
-	 *         the infobox, 0 error, but continue with next cache
+	 * @return 1 if spider was successful, -1 if spider was cancelled by closing the infobox, 0 error, but continue with
+	 *         next cache
 	 */
-	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin,
-			boolean loadAllLogs) {
+	public int spiderSingle(int number, InfoBox pInfB, boolean forceLogin, boolean loadAllLogs) {
 		int ret = -1;
 		this.infB = pInfB;
-		CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
+		final CacheHolder ch = new CacheHolder(); // cacheDB.get(number);
 		ch.setWayPoint(cacheDB.get(number).getWayPoint());
 		if (ch.isAddiWpt())
-			return -1; // No point re-spidering an addi waypoint, comes with
-						// parent
+			return -1; // No point re-spidering an addi waypoint, comes with parent
 
-		// check if we need to login
-		if (!loggedIn || forceLogin) {
-			if (this.login() != FormBase.IDOK)
-				return -1;
-			// loggedIn is already set by this.login()
-		}
+		if (!login())
+			return -1;
 		try {
 			// Read the cache data from GC.COM and compare to old data
-			ret = getCacheByWaypointName(ch, true, pref.downloadPics,
-					pref.downloadTBs, false, loadAllLogs);
+			ret = getCacheByWaypointName(ch, true, pref.downloadPics, pref.downloadTBs, false, loadAllLogs);
 			// Save the spidered data
 			if (ret == SPIDER_OK) {
-				CacheHolder cacheInDB = cacheDB.get(number);
+				final CacheHolder cacheInDB = cacheDB.get(number);
 				cacheInDB.initStates(false);
 				if (cacheInDB.is_found() &amp;&amp; !ch.is_found() &amp;&amp; !loadAllLogs) {
-					// If the number of logs to spider is 5 or less, then the
-					// &quot;not found&quot; information
-					// of the spidered cache is not credible. In this case it
-					// should not overwrite
-					// the &quot;found&quot; state of an existing cache.
+					// If the number of logs to spider is 5 or less,
+					// then the &quot;not found&quot; information of the spidered cache is not credible.
+					// In this case it should not overwrite the &quot;found&quot; state of an existing cache.
 					ch.setFound(true);
 				}
 				// preserve rating information
 				ch.setNumRecommended(cacheInDB.getNumRecommended());
 				if (pref.downloadPics) {
 					// delete obsolete images when we have current set
-					CacheImages.cleanupOldImages(cacheInDB
-							.getCacheDetails(true).images, ch
-							.getCacheDetails(false).images);
+					CacheImages.cleanupOldImages(cacheInDB.getCacheDetails(true).images, ch.getCacheDetails(false).images);
 				} else {
 					// preserve images if not downloaded
-					ch.getCacheDetails(false).images = cacheInDB
-							.getCacheDetails(true).images;
+					ch.getCacheDetails(false).images = cacheInDB.getCacheDetails(true).images;
 				}
 				cacheInDB.update(ch);
 				cacheInDB.save();
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[spiderSingle] Error spidering &quot; + ch.getWayPoint() + &quot; in spiderSingle&quot;, ex);
 		}
 		return ret;
@@ -1168,21 +1062,18 @@
 	 */
 	public String getCacheCoordinates(String wayPoint) {
 		String completeWebPage;
-		// Check whether spider definitions could be loaded, if not issue
-		// appropriate message and terminate
+		// Check whether spider definitions could be loaded,
+		// if not issue appropriate message and terminate
 		// Try to login. If login fails, issue appropriate message and terminate
-		if (!loggedIn || pref.forceLogin) {
-			if (login() != FormBase.IDOK) {
-				return &quot;&quot;;
-			}
-		}
-		InfoBox localInfB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
+		if (!login())
+			return &quot;&quot;;
+		final InfoBox localInfB = new InfoBox(&quot;Info&quot;, &quot;Loading&quot;, InfoBox.PROGRESS_WITH_WARNINGS);
 		localInfB.exec();
 		try {
-			String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
-			completeWebPage = fetchText(doc, false);
+			final String doc = p.getProp(&quot;waypoint&quot;) + wayPoint;
+			completeWebPage = UrlFetcher.fetch(doc);
 			pref.log(&quot;Fetched &quot; + wayPoint);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
 			pref.log(&quot;[getCacheCoordinates] Could not fetch &quot; + wayPoint, ex);
 			return &quot;&quot;;
@@ -1190,31 +1081,47 @@
 		localInfB.close(0);
 		try {
 			return getLatLon(completeWebPage);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			return &quot;????&quot;;
 		}
 	} // getCacheCoordinates
 
 	/**
-	 * Method to login the user to gc.com It will request a password and use the
-	 * alias defined in preferences If the login page cannot be fetched, the
-	 * password is cleared. If the login fails, an appropriate message is
-	 * displayed.
+	 * Method to login the user to gc.com It will request a password and use the alias defined in preferences If the
+	 * login page cannot be fetched, the password is cleared. If the login fails, an appropriate message is displayed.
 	 */
-	private int login() {
-		String passwort = pref.password;
+	private boolean login() {
+		if (loggedIn &amp;&amp; !pref.forceLogin) {
+			return true;
+		}
+		if (pref.userID.length() &gt; 0) {
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
+			loggedIn = switchToEnglish();
+			if (loggedIn)
+				return true;
+			else {
+				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences | Einstellungen.\nsee <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A>&quot;, FormBase.OKB)).execute();
+				return false;
+			}
+		} else {
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, null);
+			if (true) {
+				(new MessageBox(&quot;Login&quot;, &quot;Check UserID in preferences| Einstellungen.\nsee <A HREF="http://cachewolf.aldos.de/userid.html">http://cachewolf.aldos.de/userid.html</A>&quot;, FormBase.OKB)).execute();
+				return false; // until SSL/https works
+			}
+		}
 		loggedIn = false;
-		String loginPage, loginPageUrl, loginSuccess, nextPage;
+		String loginPage, loginPageUrl, loginSuccess;
 		try {
 			loginPageUrl = p.getProp(&quot;loginPage&quot;);
 			loginSuccess = p.getProp(&quot;loginSuccess&quot;);
-			nextPage = p.getProp(&quot;nextPage&quot;);
-		} catch (Exception ex) { // Tag not found in spider.def
-			return ERR_LOGIN;
+		} catch (final Exception ex) { // Tag not found in spider.def
+			return false;
 		}
-		// Get password
-		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, &quot;Password&quot;),
-				MyLocale.getMsg(5505, &quot;Enter Password&quot;), InfoBox.INPUT);
+
+		// **0 Get password
+		String passwort = pref.password;
+		InfoBox localInfB = new InfoBox(MyLocale.getMsg(5506, &quot;Password&quot;), MyLocale.getMsg(5505, &quot;Enter Password&quot;), InfoBox.INPUT);
 		localInfB.feedback.setText(passwort);
 		localInfB.feedback.isPassword = true;
 		int code = FormBase.IDOK;
@@ -1224,174 +1131,215 @@
 		}
 		localInfB.close(0);
 		if (code != FormBase.IDOK)
-			return code;
-		// Now start the login proper
+			return false;
+
+		// **1 now we have user and password for login
 		localInfB = new InfoBox(MyLocale.getMsg(5507, &quot;Status&quot;), MyLocale.getMsg(5508, &quot;Logging in...&quot;));
 		localInfB.exec();
 		try {
-			// Access the page once to get a viewstate
-			loginPage = fetchText(loginPageUrl, false); // <A HREF="http://www.geocaching.com/login/Default.aspx">http://www.geocaching.com/login/Default.aspx</A>
-			pref.log(&quot;[login]:Fetched login page &quot; + loginPageUrl);
+			loginPage = UrlFetcher.fetch(loginPageUrl); // <A HREF="http://www.geocaching.com/login/default.aspx">http://www.geocaching.com/login/default.aspx</A>
 			if (loginPage.equals(&quot;&quot;)) {
 				localInfB.close(0);
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(5499,&quot;Error loading login page.%0aPlease check your internet connection.&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 				pref.log(&quot;[login]:Could not fetch: gc.com login page &quot; + loginPageUrl, null);
-				return ERR_LOGIN;
+				return false;
 			}
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			localInfB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-					MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
 			pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
-			return ERR_LOGIN;
+			return false;
 		}
-		if (!localInfB.isClosed) { // If user has not aborted, we continue
-			Regex rexCookieID = new Regex(&quot;(?i)Set-Cookie: userid=(.*?);.*&quot;);
-			Regex rexViewstate = new Regex(
-					&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			// Regex rexViewstate1 = new
-			// Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			// Regex rexEventvalidation = new
-			// Regex(&quot;id=\&quot;__EVENTVALIDATION\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
-			Regex rexCookieSession = new Regex(
-					&quot;(?i)Set-Cookie: ASP.NET_SessionId=(.*?);.*&quot;);
-			String viewstate = &quot;&quot;;
-			rexViewstate.search(loginPage);
-			if (rexViewstate.didMatch()) {
-				viewstate = rexViewstate.stringMatched(1);
-			} else {
-				pref.log(&quot;[login]:rexViewstate not found before login&quot;, null);
-			}
 
-			if (loginPage.indexOf(loginSuccess) &gt; 0)
-				pref.log(&quot;[login]:Already logged in&quot; + pref.myAlias);
-			else {
-				/*
-				 * rexEventvalidation.search(loginPage);
-				 * if(rexEventvalidation.didMatch()){ // eventvalidation =
-				 * rexEventvalidation.stringMatched(1); } else
-				 * pref.log(&quot;[login]:rexEventvalidation not found before login&quot;
-				 * ,null); //Ok now login!
-				 */
+		// **2 now we can check the loginpage if logged in else log in
+		if (!localInfB.isClosed) {
+			if (loginPage.indexOf(loginSuccess) &gt; 0) {
+				if (loginPage.indexOf(pref.myAlias) &gt; 0) {
+					loggedIn = true;
+					// assume language is already set to EN
+					pref.log(&quot;[login]:Already logged in as &quot; + pref.myAlias);
+				} else {
+					// it is another user, whom we should logout
+					try {
+						loginPage = UrlFetcher.fetch(&quot;<A HREF="http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y">http://www.geocaching.com/login/default.aspx?RESETCOMPLETE=Y</A>&quot;);
+					} catch (final Exception ex) {
+						localInfB.close(0);
+						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5499, &quot;Error loading login page.%0aPlease check your internet connection.&quot;), FormBase.OKB)).execute();
+						pref.log(&quot;[login]:Could not fetch: gc.com login page&quot;, ex);
+						return false;
+					}
+
+				}
+			}
+			if (!loggedIn) {
 				try {
-					StringBuffer sb = new StringBuffer(1000);
-					sb.append(URL.encodeURL(&quot;__VIEWSTATE&quot;, false));
-					sb.append(&quot;=&quot;);
-					sb.append(URL.encodeURL(viewstate, false));
+					final Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+					String viewstate = &quot;&quot;;
+					rexViewstate.search(loginPage);
+					if (rexViewstate.didMatch()) {
+						viewstate = rexViewstate.stringMatched(1);
+					} else {
+						localInfB.close(0);
+						pref.log(&quot;[login]:__VIEWSTATE not found (before login): no login possible.&quot;, null);
+						// we need the __VIEWSTATE for sending loginData, so we should abort here
+						return false;
+					}
+					final StringBuffer sb = new StringBuffer(1000);
+					sb.append(&quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false));
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(URL.encodeURL(&quot;myUsername&quot;, false));
-					sb.append(&quot;=&quot;);
-					sb.append(encodeUTF8URL(Utils
-							.encodeJavaUtf8String(pref.myAlias)));
+					sb.append(&quot;myUsername=&quot; + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias)));
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(URL.encodeURL(&quot;myPassword&quot;, false));
-					sb.append(&quot;=&quot;);
-					sb.append(encodeUTF8URL(Utils
-							.encodeJavaUtf8String(passwort)));
+					sb.append(&quot;myPassword=&quot; + encodeUTF8URL(Utils.encodeJavaUtf8String(passwort)));
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(URL.encodeURL(&quot;cookie&quot;, false));
-					sb.append(&quot;=&quot;);
-					sb.append(URL.encodeURL(&quot;on&quot;, false));
+					sb.append(&quot;cookie=on&quot;);
 					sb.append(&quot;&amp;ctl00%24ContentBody%24&quot;);
-					sb.append(URL.encodeURL(&quot;Button1&quot;, false));
-					sb.append(&quot;=&quot;);
-					sb.append(URL.encodeURL(&quot;Login&quot;, false));
-					// sb.append(&quot;&amp;&quot;);
-					// sb.append(URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false));
-					// sb.append(&quot;=&quot;);
-					// sb.append(URL.encodeURL(eventvalidation,false));
-					loginPage = fetch_post(loginPageUrl, sb.toString(), true);
-					if (loginPage.indexOf(loginSuccess) &gt; 0)
+					sb.append(&quot;Button1=Login&quot;);
+					UrlFetcher.setpostData(sb.toString());
+					loginPage = UrlFetcher.fetch(loginPageUrl);
+					if (loginPage.indexOf(loginSuccess) &gt; 0) {
 						pref.log(&quot;Login successful: &quot; + pref.myAlias);
-					else {
+						// **3 now we are logged in and get the Cookie (there are two)
+						final PropertyList pl = UrlFetcher.getDocumentProperties();
+						String docprops = &quot;&quot;;
+						for (int i = 0; i &lt; pl.size(); i++) {
+							final Property p = (Property) pl.get(i);
+							if (p.name.equalsIgnoreCase(&quot;Set-Cookie&quot;)) {
+								docprops += p.value;
+							}
+						}
+						final Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
+						rexCookieSession.search(docprops);
+						if (rexCookieSession.didMatch()) {
+							cookie = &quot;ASP.NET_SessionId=&quot; + rexCookieSession.stringMatched(1);
+						} else {
+							localInfB.close(0);
+							pref.log(&quot;[login]:SessionID not found.&quot;, null);
+							return false;
+						}
+						final Regex rexCookieID = new Regex(&quot;(?i)userid=(.*?);.*&quot;);
+						rexCookieID.search(docprops);
+						if (rexCookieID.didMatch()) {
+							cookie += &quot;; userid=&quot; + rexCookieID.stringMatched(1);
+						} else {
+							localInfB.close(0);
+							pref.log(&quot;[login]:userID not found.&quot;, null);
+							return false;
+						}
+						UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
+					} else {
 						pref.log(&quot;Login failed. Wrong Account or Password? &quot; + pref.myAlias, null);
-						pref.log(&quot;[login.LoginUrl]:&quot; + sb.toString(), null);
+						pref.log(&quot;[login.url]:&quot; + loginPageUrl, null);
+						pref.log(&quot;[login.postData]:&quot; + sb.toString(), null);
 						pref.log(&quot;[login.Answer]:&quot; + loginPage, null);
 						localInfB.close(0);
-						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-								MyLocale.getMsg(5501,&quot;Login failed! Wrong account or password?&quot;),
-								FormBase.OKB)).execute();
-						return ERR_LOGIN;
+						(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed! Wrong account or password?&quot;), FormBase.OKB)).execute();
+						return false;
 					}
-				} catch (Exception ex) {
+					if (!this.switchToEnglish())
+						return false;
+				} catch (final Exception ex) {
 					pref.log(&quot;[login]:Login failed with exception.&quot;, ex);
 					localInfB.close(0);
-					(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-							MyLocale.getMsg(5501,&quot;Login failed. Error loading page after login.&quot;),
-							FormBase.OKB)).execute();
-					return ERR_LOGIN;
+					(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5501, &quot;Login failed. Error loading page after login.&quot;), FormBase.OKB)).execute();
+					return false;
 				}
 			}
-
-			rexViewstate.search(loginPage);
-			if (!rexViewstate.didMatch()) {
-				pref.log(&quot;[login]:check rexViewstate in SpiderGC.java --&gt; not found after login&quot;
-						+ Preferences.NEWLINE + loginPage, null);
-			}
-			viewstate = rexViewstate.stringMatched(1);
-
-			rexCookieID.search(loginPage);
-			if (!rexCookieID.didMatch()) {
-				pref.log(&quot;[login]:check rexCookieID in SpiderGC.java --&gt; CookieID not found. Using old one.&quot;, null);
-			} else
-				cookieID = rexCookieID.stringMatched(1);
-			rexCookieSession.search(loginPage);
-			if (!rexCookieSession.didMatch()) {
-				pref.log(&quot;[login]:check rexCookieSession in SpiderGC.java --&gt; CookieSession not found. Using old one.&quot;
-						+ Preferences.NEWLINE + loginPage);
-			} else
-				cookieSession = rexCookieSession.stringMatched(1);
-
-			/*
-			 * String viewstate1; rexViewstate1.search(loginPage);
-			 * if(rexViewstate1.didMatch()){ viewstate1 =
-			 * rexViewstate1.stringMatched(1); } else { viewstate1 = &quot;&quot;;
-			 * pref.log(
-			 * &quot;[login]:check rexViewstate1 in SpiderGC.java --&gt; not found after login&quot;
-			 * +Preferences.NEWLINE+loginPage); }
-			 */
-
-			/*
-			 * rexEventvalidation.search(htmlPage);
-			 * if(rexEventvalidation.didMatch()){ eventvalidation =
-			 * rexEventvalidation.stringMatched(1); } else { eventvalidation =
-			 * &quot;&quot;; }
-			 */
-
-			String strEnglishPage = &quot;ctl00$uxLocaleList$uxLocaleList$ctl01$uxLocaleItem&quot;;
-			String postStr = URL.encodeURL(&quot;__EVENTTARGET&quot;, false) + &quot;=&quot;
-					+ URL.encodeURL(strEnglishPage, false) + &quot;&amp;&quot;
-					+ URL.encodeURL(&quot;__EVENTARGUMENT&quot;, false) + &quot;=&quot;
-					+ URL.encodeURL(&quot;&quot;, false)
-					// + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATEFIELDCOUNT&quot;,false)
-					// +&quot;=2&quot;
-					+ &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE&quot;, false) + &quot;=&quot;
-					+ URL.encodeURL(viewstate, false);
-			// + &quot;&amp;&quot; + URL.encodeURL(&quot;__VIEWSTATE1&quot;,false) +&quot;=&quot;+
-			// URL.encodeURL(viewstate1,false);
-			// + &quot;&amp;&quot; + URL.encodeURL(&quot;__EVENTVALIDATION&quot;,false) +&quot;=&quot;+
-			// URL.encodeURL(eventvalidation,false);
-			try {
-				loginPage = fetch_post(loginPageUrl, postStr, true);
-				pref.log(&quot;Switched to English&quot;);
-			} catch (Exception ex) {
-				pref.log(&quot;Error switching to English: check/n&quot; + loginPageUrl
-						+ &quot;/n&quot; + postStr + &quot;/n&quot; + nextPage + &quot;/n&quot;, ex);
-			}
 		}
-		boolean loginAborted = localInfB.isClosed;
+
+		final boolean loginAborted = localInfB.isClosed;
 		localInfB.close(0);
 		if (loginAborted)
-			return FormBase.IDCANCEL;
+			return false;
 		else {
 			loggedIn = true;
-			return FormBase.IDOK;
+			return true;
 		}
 	}
 
+	private boolean switchToEnglish() {
+		// change language to EN , further operations relay on English
+		String url = &quot;<A HREF="http://www.geocaching.com/account/ManagePreferences.aspx">http://www.geocaching.com/account/ManagePreferences.aspx</A>&quot;;
+		String page = &quot;&quot;;
+		String userID = &quot;userid=&quot; + pref.userID;
+		try {
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, userID);
+			page = UrlFetcher.fetch(url); // getting the sessionid
+			if (page.length() == 0)
+				return false;
+		} catch (final Exception ex) {
+			return false;
+		}
+		PropertyList pl = UrlFetcher.getDocumentProperties();
+		String docprops = &quot;&quot;;
+		for (int i = 0; i &lt; pl.size(); i++) {
+			final Property p = (Property) pl.get(i);
+			if (p.name.equalsIgnoreCase(&quot;Set-Cookie&quot;)) {
+				docprops += p.value;
+			}
+		}
+		final Regex rexCookieSession = new Regex(&quot;(?i)ASP.NET_SessionId=(.*?);.*&quot;);
+		rexCookieSession.search(docprops);
+		if (rexCookieSession.didMatch()) {
+			cookie = &quot;ASP.NET_SessionId=&quot; + rexCookieSession.stringMatched(1) + &quot;; &quot; + userID;
+			UrlFetcher.setPermanentRequestorProperty(&quot;Cookie&quot;, cookie);
+		} else {
+			pref.log(&quot;[switchToEnglish]:SessionID not found.&quot;, null);
+			return false;
+		}
+		try {
+			page = UrlFetcher.fetch(url);
+			if (page.length() == 0)
+				return false;
+		} catch (IOException e) {
+			return false;
+		}
+		Extractor ext = new Extractor(page, &quot;ctl00$ContentBody$uxLanguagePreference&quot;, &quot;&lt;/select&gt;&quot;, 0, true);
+		String languageBlock = ext.findNext();
+		ext.set(ext.findNext(&quot;ctl00$ContentBody$uxDateTimeFormat&quot;), &quot;selected\&quot; value=\&quot;&quot;, &quot;\&quot;&gt;&quot;, 0, true);
+		DateFormat.GCDateFormat = ext.findNext();
+		// &lt;option selected=&quot;selected&quot; value=&quot;de-DE&quot;&gt;Deutsch&lt;/option&gt;
+		ext.set(languageBlock, &quot;&lt;option selected=&quot;, &quot;/option&gt;&quot;, 0, true);
+		ext.set(ext.findNext(), &quot;&gt;&quot;, &quot;&lt;&quot;, 0, true);
+		String oldLanguage = ext.findNext();
+		if (oldLanguage.equals(&quot;English&quot;)) {
+			pref.log(&quot;already English&quot;);
+			pref.oldLanguageCtl = &quot;&quot;; // nothing to reset
+			return true;
+		}
+		// switch to english now goes into gc account Display Preferences
+		// (is permanent, must be reset)
+		// todo as long as Textfile Encoding is CP1252 we compare with
+		// substring(1) and think koreanisch if no merge at all
+		String languages[] = { &quot;English&quot;, &quot;Deutsch&quot;, &quot;Fran&#231;ais&quot;, &quot;Portugu&#234;s&quot;, &quot;Ce&#154;tina&quot;, &quot;Svenska&quot;, &quot;Nederlands&quot;, &quot;Catal&#224;&quot;, &quot;Polski&quot;, &quot;Eesti&quot;, &quot;Norsk, Bokm&#229;l&quot;, &quot;???&quot;, &quot;Espa&#241;ol&quot; };
+		for (int i = 0; i &lt; languages.length; i++) {
+			if (oldLanguage.substring(1).equals(languages[i].substring(1))) {
+				pref.oldLanguageCtl = url + &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(&quot;ctl00$uxLocaleList$uxLocaleList$ctl&quot; + MyLocale.formatLong(i, &quot;00&quot;) + &quot;$uxLocaleItem&quot;, false);
+				break;
+			}
+		}
+		if (pref.oldLanguageCtl.length() == 0) {
+			// koreanisch
+			pref.oldLanguageCtl = url + &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(&quot;ctl00$uxLocaleList$uxLocaleList$ctl&quot; + &quot;11&quot; + &quot;$uxLocaleItem&quot;, false);
+		}
+		final String strEnglishPage = &quot;ctl00$uxLocaleList$uxLocaleList$ctl00$uxLocaleItem&quot;;
+		url += &quot;?__EVENTTARGET=&quot; + UrlFetcher.encodeURL(strEnglishPage, false);
+		try {
+			page = UrlFetcher.fetch(url);
+			ext.set(page, &quot;&lt;a href=\&quot;#\&quot;&gt;&quot;, &quot;&#9660;&quot;, 0, true);
+			if (ext.findFirst(page).equals(&quot;English&quot;)) {
+				pref.log(&quot;Switched to English&quot;);
+				return true;
+			} else {
+				pref.log(&quot;couldn't switch to english&quot;, null);
+				return false;
+			}
+		} catch (final Exception ex) {
+			pref.log(&quot;[SpiderGC.java:switchToEnglish]Error switching to English: check &quot; + url, ex);
+			return false;
+		}
+
+	}
+
 	/*
 	 *
 	 */
@@ -1430,7 +1378,7 @@
 			icon_camera = p.getProp(&quot;icon_camera&quot;);
 			icon_attended = p.getProp(&quot;icon_attended&quot;);
 			RexCacheType = new Regex(p.getProp(&quot;cacheTypeRex&quot;));
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;Error fetching Properties.&quot;, ex);
 		}
 	}
@@ -1445,25 +1393,20 @@
 		if (spiderAllFinds) {
 			url = propFirstPageFinds + encodeUTF8URL(Utils.encodeJavaUtf8String(pref.myAlias));
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
-		
+
 		try {
-			htmlListPage = fetchText(url, false);
+			htmlListPage = UrlFetcher.fetch(url);
 			pref.log(&quot;[getFirstListPage] Got first page &quot; + url);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getFirstListPage] Error fetching first list page &quot; + url, ex, true);
 			Vm.showWait(false);
 			infB.close(0);
-			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), 
-					MyLocale.getMsg(5503, &quot;Error fetching first list page.&quot;),
-					FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5503, &quot;Error fetching first list page.&quot;), FormBase.OKB)).execute();
 			return;
 		}
 	}
@@ -1476,52 +1419,39 @@
 		if (spiderAllFinds) {
 			url = propFirstPage;
 		} else {
-			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD)
-				+ propFirstPage2
-				+ origin.getLonDeg(TransformCoordinates.DD)
-				+ propMaxDistance + Integer.toString(distance);
+			url = propFirstPage + origin.getLatDeg(TransformCoordinates.DD) + propFirstPage2 + origin.getLonDeg(TransformCoordinates.DD) + propMaxDistance + Integer.toString(distance);
 			if (doNotgetFound)
 				url = url + propShowOnlyFound;
 		}
 		url = url + cacheTypeRestriction;
 
-		Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+		final Regex rexViewstate = new Regex(&quot;id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
 		String viewstate;
 		rexViewstate.search(htmlListPage);
 		if (rexViewstate.didMatch()) {
 			viewstate = rexViewstate.stringMatched(1);
 		} else {
 			viewstate = &quot;&quot;;
-			pref.log(&quot;[getAListPage] check rexViewstate in SpiderGC.java&quot; + Preferences.NEWLINE + htmlListPage);
+			pref.log(&quot;[SpiderGC.java:getAListPage] check rexViewstate!&quot;, null);
 		}
 
-		Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
+		final Regex rexViewstate1 = new Regex(&quot;id=\&quot;__VIEWSTATE1\&quot; value=\&quot;(.*?)\&quot; /&gt;&quot;);
 		String viewstate1;
 		rexViewstate1.search(htmlListPage);
 		if (rexViewstate1.didMatch()) {
 			viewstate1 = rexViewstate1.stringMatched(1);
 		} else {
 			viewstate1 = &quot;&quot;;
-			pref.log(&quot;[getAListPage] check rexViewstate1 in SpiderGC.java&quot; + Preferences.NEWLINE + htmlListPage);
+			pref.log(&quot;[SpiderGC.java:getAListPage] check rexViewstate1!&quot;, null);
 		}
 
-		/*
-		 * rexEventvalidation.search(htmlPage);
-		 * if(rexEventvalidation.didMatch()){ 
-		 * eventvalidation = rexEventvalidation.stringMatched(1); } 
-		 * else { eventvalidation = &quot;&quot;; }
-		 */
-
-		String postData = &quot;__EVENTTARGET=&quot; + URL.encodeURL(whatPage, false) + &quot;&amp;&quot; +
-						  &quot;__EVENTARGUMENT=&quot; + &quot;&amp;&quot; +
-						  &quot;__VIEWSTATEFIELDCOUNT=2&quot; + &quot;&amp;&quot; +
-						  &quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false) + &quot;&amp;&quot; +
-						  &quot;__VIEWSTATE1=&quot; + URL.encodeURL(viewstate1, false); // + &quot;&amp;&quot; +
-						  //&quot;__EVENTVALIDATION=&quot; + URL.encodeURL(eventvalidation,false);
+		final String postData = &quot;__EVENTTARGET=&quot; + URL.encodeURL(whatPage, false) + &quot;&amp;&quot; + &quot;__EVENTARGUMENT=&quot; + &quot;&amp;&quot; + &quot;__VIEWSTATEFIELDCOUNT=2&quot; + &quot;&amp;&quot; + &quot;__VIEWSTATE=&quot; + URL.encodeURL(viewstate, false) + &quot;&amp;&quot; + &quot;__VIEWSTATE1=&quot;
+				+ URL.encodeURL(viewstate1, false);
 		try {
-			htmlListPage = fetch_post(url, postData, true);
-			pref.log(&quot;[getAListPage] Got list page: &quot; + URL.encodeURL(whatPage, false));
-		} catch (Exception ex) {
+			UrlFetcher.setpostData(postData);
+			htmlListPage = UrlFetcher.fetch(url);
+			pref.log(&quot;[getAListPage] Got list page: &quot; + url);
+		} catch (final Exception ex) {
 			pref.log(&quot;[getAListPage] Error getting a list page&quot; + url, ex);
 		}
 	}
@@ -1529,79 +1459,292 @@
 	/* */
 	private String getMapListPage(CWPoint middle, double north, double west, double south, double east) {
 		String ret;
-		
-		String referer = &quot;<A HREF="http://www.geocaching.com/map/default.aspx">http://www.geocaching.com/map/default.aspx</A>&quot; + 
-		&quot;?lat=&quot;	+ middle.getLatDeg(TransformCoordinates.DD) + 
-		&quot;&amp;lng=&quot;	+ middle.getLonDeg(TransformCoordinates.DD);
 
+		final String referer = &quot;<A HREF="http://www.geocaching.com/map/default.aspx">http://www.geocaching.com/map/default.aspx</A>&quot; + &quot;?lat=&quot; + middle.getLatDeg(TransformCoordinates.DD) + &quot;&amp;lng=&quot; + middle.getLonDeg(TransformCoordinates.DD);
+
 		if (userToken.equals(&quot;&quot;)) {
-			ret = fetchText(referer, false);
+			try {
+				ret = UrlFetcher.fetch(referer);
+			} catch (final IOException e) {
+				ret = &quot;&quot;;
+			}
 			int i = ret.indexOf(&quot;userToken = '&quot;);
-			i=i+13;
-			int j = ret.indexOf(&quot;'&quot;, i);
-			userToken = ret.substring(i,j);
+			i = i + 13;
+			final int j = ret.indexOf(&quot;'&quot;, i);
+			userToken = ret.substring(i, j);
 		}
-		
-		String url = &quot;<A HREF="http://www.geocaching.com/map/default.aspx/MapAction">http://www.geocaching.com/map/default.aspx/MapAction</A>&quot;;
 
-		String strLeft = MyLocale.formatDouble(west, &quot;#0.00000&quot;).replace(',','.');
-		String strUp = MyLocale.formatDouble(north, &quot;#0.00000&quot;).replace(',','.');
-		String strRight = MyLocale.formatDouble(east, &quot;#0.00000&quot;).replace(',','.');
-		String strDown = MyLocale.formatDouble(south, &quot;#0.00000&quot;).replace(',','.');
-		String param1 = &quot;{\&quot;dto\&quot;:{\&quot;data\&quot;:{\&quot;c\&quot;:1,\&quot;m\&quot;:\&quot;\&quot;,\&quot;d\&quot;:\&quot;&quot;;
-		String param2 = strUp + &quot;|&quot; + strDown + &quot;|&quot; + strRight + &quot;|&quot; + strLeft;
-		String param3 = &quot;\&quot;},\&quot;ut\&quot;:\&quot;&quot;;
-		String param4 = &quot;\&quot;}}&quot;;
-		String postData = param1+param2+param3+userToken+param4;
+		final String url = &quot;<A HREF="http://www.geocaching.com/map/default.aspx/MapAction">http://www.geocaching.com/map/default.aspx/MapAction</A>&quot;;
 
+		final String strLeft = MyLocale.formatDouble(west, &quot;#0.00000&quot;).replace(',', '.');
+		final String strUp = MyLocale.formatDouble(north, &quot;#0.00000&quot;).replace(',', '.');
+		final String strRight = MyLocale.formatDouble(east, &quot;#0.00000&quot;).replace(',', '.');
+		final String strDown = MyLocale.formatDouble(south, &quot;#0.00000&quot;).replace(',', '.');
+		final String param1 = &quot;{\&quot;dto\&quot;:{\&quot;data\&quot;:{\&quot;c\&quot;:1,\&quot;m\&quot;:\&quot;\&quot;,\&quot;d\&quot;:\&quot;&quot;;
+		final String param2 = strUp + &quot;|&quot; + strDown + &quot;|&quot; + strRight + &quot;|&quot; + strLeft;
+		final String param3 = &quot;\&quot;},\&quot;ut\&quot;:\&quot;&quot;;
+		final String param4 = &quot;\&quot;}}&quot;;
+		final String postData = param1 + param2 + param3 + userToken + param4;
+
 		try {
-		ret = post(url, postData, referer, false);
-		} catch (Exception ex) {
+			UrlFetcher.setpostData(postData);
+			UrlFetcher.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
 			ret = &quot;&quot;;
 			pref.log(&quot;[SpiderGC:getMapListPage] Error getting map Cachepage&quot; + url + postData, ex);
 		}
 		return ret;
- 	}
+	}
 
-	private static String post(String url, String postData, String referer, boolean withResponseHeaders) {
-		HttpConnection conn;
+	/* */
+	public void doItQuickFillFromMapList() {
+
+		final CWPoint origin = pref.getCurCentrePt();
+		if (!origin.isValid()) {
+			(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5509, &quot;Coordinates for centre must be set&quot;), FormBase.OKB)).execute();
+			return; //
+		}
+		if (!doDownloadGui(2))
+			return;
+
+		Vm.showWait(true);
+		infB = new InfoBox(&quot;Status&quot;, MyLocale.getMsg(1609, &quot;getting the caches.&quot;));
+		infB.exec();
+
+		// Reset states for all caches when spidering (<A HREF="http://tinyurl.com/dzjh7p">http://tinyurl.com/dzjh7p</A>)
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
+			final CacheHolder ch = cacheDB.get(i);
+			if (ch.mainCache == null)
+				ch.initStates(false);
+		}
+
+		// halbe Seitenl&#228;nge eines Quadrats ums Zentrum in km
+		double halfSideLength = maxDistance;
+		if (pref.metricSystem == Metrics.IMPERIAL) {
+			halfSideLength = Metrics.convertUnit(maxDistance, Metrics.MILES, Metrics.KILOMETER);
+		}
+		if (!login())
+			return;
+
+		page_number = 0;
+		num_added = 0;
+
+		final Area sq = getSquare(origin, halfSideLength);
+
+		getCachesNewMap(sq, false);
+
+		if (!infB.isClosed)
+			infB.close(0);
+		Vm.showWait(false);
+
+		Global.getProfile().restoreFilter();
+		Global.getProfile().saveIndex(Global.getPref(), true);
+
+	}
+
+	private void getCachesNewMap(Area square, boolean setCachesToLoad) {
+
+		if (userToken.equals(&quot;&quot;)) {
+			String url;
+			String ret;
+			try {
+				page_number++;
+				url = &quot;<A HREF="http://www.geocaching.com/map/beta/default.aspx">http://www.geocaching.com/map/beta/default.aspx</A>&quot; + &quot;?lat=&quot; + square.topleft.getLatDeg(TransformCoordinates.DD) + &quot;&amp;lng=&quot; + square.topleft.getLonDeg(TransformCoordinates.DD) + &quot;&amp;z=15&quot;;
+				ret = UrlFetcher.fetch(url);
+			} catch (final IOException e) {
+				ret = &quot;&quot;;
+			}
+			int i = ret.indexOf(&quot;GSPK.UserSession('&quot;);
+			i = i + 18;
+			int j = ret.indexOf(&quot;'&quot;, i);
+			userToken = ret.substring(i, j);
+			i = ret.indexOf(&quot;sessionToken:'&quot;, i);
+			i = i + 14;
+			j = ret.indexOf(&quot;'&quot;, i);
+			sessionToken = ret.substring(i, j);
+		}
+		TrackPoint tl;
+		TrackPoint br;
+		int lonmin;
+		int lonmax;
+		int latmin;
+		int latmax;
+		int scale = 19;
+		do {
+			scale = scale - 1;
+			tl = getKachelLatLon(square.topleft, scale);
+			br = getKachelLatLon(square.bottomright, scale);
+			lonmin = (int) tl.lonDec;
+			lonmax = (int) br.lonDec;
+			latmin = (int) tl.latDec;
+			latmax = (int) br.latDec;
+		} while ((lonmax - lonmin &gt; 1) &amp;&amp; (latmax - latmin &gt; 1) &amp;&amp; (scale &gt; 10));
+
+		String cachelist;
+
+		for (int i = lonmin; i &lt;= lonmax; i++) {
+			for (int j = latmin; j &lt;= latmax; j++) {
+				cachelist = getNewMapListPage(&quot;&quot; + j, &quot;&quot; + i, scale);
+				if (cachelist.length() &gt; 0) {
+					final String[] caches = mString.split(cachelist, '{');
+					final double baseX = Common.parseDouble(caches[1].substring(8, caches[1].indexOf(',')));
+					final double baseY = Common.parseDouble(caches[1].substring(caches[1].indexOf(',') + 1, caches[1].indexOf(']')));
+					for (int k = 2; k &lt; caches.length; k++) {
+						final String[] cacheInfos = mString.split(STRreplace.replace(caches[k], &quot;\\\&quot;&quot;, &quot;&quot;), '\&quot;');
+						final String cacheID = cacheInfos[3];
+						final String cacheXY = cacheInfos[10];
+						final String[] xy = mString.split(cacheXY, ',');
+						final int cacheX = Common.parseInt(xy[0].substring(2));
+						final int cacheY = Common.parseInt(xy[1].substring(0, xy[1].indexOf(']')));
+						final CWPoint p = getLatLon(baseX, baseY, cacheX, cacheY, scale);
+						if (square.isInBound(p)) {
+							String cachePage = getCacheInfoNewMap(cacheID);
+							addCacheNewMap(cachePage, p, setCachesToLoad);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	private TrackPoint getKachelLatLon(CWPoint p, int scale) {
+		double lat = p.latDec;
+		double lon = p.lonDec;
+		if (lon &gt; 180.0) {
+			lon -= 360.0;
+		}
+		lat = 0.5 - Math.log(Math.tan((Math.PI / 4.0) + ((Math.PI * lat) / (2.0 * 180.0)))) / (2.0 * Math.PI);
+		lon = (180.0 + lon) / 360.0;
+
+		final int f = 1 &lt;&lt; scale; // 2**scale
+		lat = lat * f;
+		lon = lon * f;
+		return new TrackPoint(lat, lon); // TrackPoint only for returning
+		// values
+	}
+
+	private CWPoint getLatLon(double basex, double basey, int offsetx, int offsety, int scale) {
+
+		double anzPixelX = basex + offsetx;
+		double anzPixelY = basey + offsety;
+
+		final CWPoint p = new CWPoint();
+
+		final double maxPixels = 1 &lt;&lt; (scale + 8); // 2**scale*256
+		final double gpp = 360.0 / maxPixels; // Grad pro Pixel
+		final double leftLon = (anzPixelX * gpp); // Grad
+		p.lonDec = leftLon - 180.0; // 0 ist bei greenwich
+
+		final double lat = 1.0 / maxPixels;
+		final double latM = Math.PI * (1.0 + 2.0 * anzPixelY * lat);
+		p.latDec = (180.0 / Math.PI) * ((2.0 * Math.atan(Math.exp(latM))) - (Math.PI / 2.0));
+
+		return p;
+	}
+
+	private String getNewMapListPage(String strLat, String strLon, int scale) {
+		String ret;
+		String url = &quot;&quot;;
+
 		try {
-			conn = new HttpConnection(url);
-			JavaUtf8Codec codec = new ewe.io.JavaUtf8Codec();
-			conn.documentIsEncoded = true;
-			conn.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 6.0; de; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12&quot;);
-			conn.setRequestorProperty(&quot;Accept&quot;,&quot;application/json, text/javascript, */*; q=0.01&quot;);
-			conn.setRequestorProperty(&quot;Accept-Language&quot;,&quot;de-de,de;q=0.8,en-us;q=0.5,en;q=0.3&quot;);
-			conn.setRequestorProperty(&quot;Accept-Encoding&quot;,&quot;gzip,deflate&quot;);
-			conn.setRequestorProperty(&quot;Accept-Charset&quot;,&quot;ISO-8859-1,utf-8;q=0.7,*;q=0.7&quot;);
-			conn.setRequestorProperty(&quot;Keep-Alive&quot;,&quot;115&quot;);
-			conn.setRequestorProperty(&quot;Proxy-Connection&quot;,&quot;keep-alive&quot;);
-			conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
-			conn.setRequestorProperty(&quot;X-Requested-With&quot;,&quot;XMLHttpRequest&quot;);
-			conn.setRequestorProperty(&quot;Referer&quot;,referer);
-			conn.setRequestorProperty(&quot;Pragma&quot;,&quot;no-cache&quot;);
-			conn.setRequestorProperty(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
-			// if (cookieSession.length() &gt; 0) { conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot; + cookieSession + &quot;; userid=&quot; + cookieID); }
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			//conn.setPostData(codec.encodeText(postData.toCharArray(), 0, postData.length(), true, null));
-			conn.setPostData(postData);
-			Socket sock = conn.connect();
-			// CharArray c_data = conn.readText(sock, codec);
-			ByteArray daten = conn.readData(sock);
-			CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			
-			sock.close();
-			
-			if (withResponseHeaders)
-				return getResponseHeaders(conn) + c_data.toString();
-			else
-				return c_data.toString();
-		} catch (Exception e) {
-			pref.log(&quot;[fetch_post] Ignored Exception&quot;, e, true);
+			page_number++;
+			url = &quot;<A HREF="http://www.geocaching.com/map/beta/map.info?">http://www.geocaching.com/map/beta/map.info?</A>&quot; + &quot;x=&quot; + strLon + &quot;&amp;y=&quot; + strLat + &quot;&amp;z=&quot; + scale + &quot;&amp;k=&quot; + userToken + &quot;&amp;st=&quot; + sessionToken + &quot;&amp;ep=1&quot;;
+			if (doNotgetFound) {
+				url = url + &quot;&amp;hf=1&quot;; // do not get finds
+			}
+			url = url + &quot;&amp;hh=1&quot;; // do not get own
+			UrlFetcher.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = &quot;&quot;;
+			pref.log(&quot;[SpiderGC:getMapListPage] Error getting map Cachepage&quot; + url + ex);
 		}
-		return &quot;&quot;;
+		return ret;
 	}
 
+	private String getCacheInfoNewMap(String cacheID) {
+		String ret;
+		String url = &quot;&quot;;
+
+		try {
+			page_number++;
+			url = &quot;<A HREF="http://www.geocaching.com/map/beta/map.details?">http://www.geocaching.com/map/beta/map.details?</A>&quot; + &quot;wptid=&quot; + cacheID + &quot;&amp;k=&quot; + userToken + &quot;&amp;st=&quot; + sessionToken + &quot;&amp;ep=1&quot;;
+			UrlFetcher.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);
+			ret = UrlFetcher.fetch(url);
+
+		} catch (final Exception ex) {
+			ret = &quot;&quot;;
+			pref.log(&quot;[SpiderGC:getCacheInfoNewMap] Error getting map Cachepage&quot; + url + ex);
+		}
+		return ret;
+	}
+
+	private void addCacheNewMap(String page, CWPoint p, boolean setCachesToLoad) {
+
+		Extractor ext = new Extractor(page, &quot;{\&quot;name\&quot;:\&quot;&quot;, &quot;\&quot;,&quot;, 0, true);
+		String cacheName = ext.findNext(); // Text
+		String wp = ext.findNext(&quot;\&quot;gc\&quot;:\&quot;&quot;); // Text
+		String disabled = ext.findNext(&quot;\&quot;disabled\&quot;:&quot;, &quot;,&quot;); // true/false
+		String subrOnly = ext.findNext(&quot;\&quot;subrOnly\&quot;:&quot;); // true/false
+		ext.findNext(&quot;\&quot;li\&quot;:&quot;); // true/false (not used, what is that)
+		ext.findNext(&quot;\&quot;fp\&quot;:&quot;); // int (favorite points)
+		String difficulty = ext.findNext(&quot;\&quot;text\&quot;:&quot;); // double
+		String terrain = ext.findNext(); // double;
+		String hidden = ext.findNext(&quot;\&quot;hidden\&quot;:\&quot;&quot;, &quot;\&quot;,&quot;); // string Datum
+		String container = ext.findNext(&quot;\&quot;text\&quot;:\&quot;&quot;); // Text (Micro,...)
+		ext.findNext(&quot;\&quot;value\&quot;:&quot;, &quot;}&quot;); // int dont remove
+		String type = ext.findNext(&quot;\&quot;value\&quot;:&quot;, &quot;}&quot;); // int
+		String owner = ext.findNext(&quot;text\&quot;:\&quot;&quot;, &quot;\&quot;,&quot;); // Text
+
+		final byte cacheType = CacheType.gcSpider2CwType(type);
+		if (restrictedCacheType != CacheType.CW_TYPE_ERROR) {
+			if (restrictedCacheType != cacheType)
+				return;
+		}
+		CacheHolder ch = cacheDB.get(wp);
+		if (ch == null) {
+			ch = new CacheHolder();
+			ch.setWayPoint(wp);
+			boolean pm = subrOnly.equals(&quot;false&quot;) ? false : true;
+			if (pm &amp;&amp; !pref.isPremium)
+				ch.setCacheStatus(&quot;PM&quot;);
+			ch.setPos(p);
+			ch.setCacheOwner(owner);
+			// wird nicht mehr geliefert , todo aus Grafik extrahieren.
+			if (owner.equals(pref.myAlias) || owner.equals(pref.myAlias2)) {
+				ch.setOwned(true);
+			}
+			// DEAD CODE commented out
+			// else if (false) {
+			// ch.setFound(true);
+			// ch.setCacheStatus(ch.getFoundText());
+			// }
+
+			cacheName = STRreplace.replace(cacheName, &quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
+			ch.setCacheName(cacheName);
+			ch.setAvailable(disabled.equals(&quot;true&quot;) ? false : true);
+			ch.setDateHidden(DateFormat.toYYMMDD(hidden));
+			ch.setHard(CacheTerrDiff.v1Converter(difficulty));
+			ch.setTerrain(CacheTerrDiff.v1Converter(terrain));
+			ch.setCacheSize(CacheSize.gcGpxString2Cw(container));
+			ch.setType(cacheType);
+			num_added++;
+			cacheDB.add(ch);
+			if (setCachesToLoad) {
+				cachesToLoad.add(wp + &quot;found&quot;);
+			} else {
+				ch.getCacheDetails(false).URL = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + wp;
+				ch.save();
+			}
+			if (Global.mainTab.statBar != null)
+				Global.mainTab.statBar.updateDisplay(&quot;GC pages: &quot; + page_number + &quot; Caches added to CW: &quot; + num_added);
+		} else {
+		}
+	}
+
 	/**
 	 * check if new Update exists
 	 * 
@@ -1616,7 +1759,7 @@
 		boolean save = false;
 		boolean is_archived_GC = false;
 		boolean is_found_GC = false;
-		CacheHolderDetail chd = ch.getCacheDetails(false);
+		final CacheHolderDetail chd = ch.getCacheDetails(false);
 		if (spiderAllFinds) {
 			if (!ch.is_found()) {
 				ch.setFound(true);
@@ -1642,8 +1785,7 @@
 		if (ch.is_found() &amp;&amp; chd.OwnLogId.equals(&quot;&quot;)) {
 			ret = true;
 		} // missing ownLogID
-		boolean is_available_GC = !is_archived_GC
-				&amp;&amp; CacheDescription.indexOf(propAvailable) == -1;
+		final boolean is_available_GC = !is_archived_GC &amp;&amp; CacheDescription.indexOf(propAvailable) == -1;
 		if (is_available_GC != ch.is_available()) {
 			ch.setAvailable(is_available_GC);
 			save = true;
@@ -1654,28 +1796,29 @@
 			save = true;
 			ret = true;
 		}
-		String dts[]=mString.split(getDTS(CacheDescription),'/');
-		if (dts.length == 3) {
-			if (difficultyChanged(ch,  CacheTerrDiff.v1Converter(dts[0]))) {
-				save = true;
-				ret = true;
-				pref.log(&quot;difficultyChanged&quot;);
+		if (pref.checkDTS) {
+			final String dts[] = mString.split(getDTS(CacheDescription), '/');
+			if (dts.length == 3) {
+				if (difficultyChanged(ch, CacheTerrDiff.v1Converter(dts[0]))) {
+					save = true;
+					ret = true;
+					pref.log(&quot;difficultyChanged&quot;);
+				}
+				if (terrainChanged(ch, CacheTerrDiff.v1Converter(dts[1]))) {
+					save = true;
+					ret = true;
+					pref.log(&quot;terrainChanged&quot;);
+				}
+				if (sizeChanged(ch, (byte) Common.parseInt(dts[2]))) {
+					save = true;
+					ret = true;
+					pref.log(&quot;sizeChanged&quot;);
+				}
+			} else {
+				pref.log(&quot;[SpiderGC.java:updateExists]check DTS calculation!&quot;, null);
 			}
-			if (terrainChanged(ch, CacheTerrDiff.v1Converter(dts[1]))) {
-				save = true;
-				ret = true;
-				pref.log(&quot;terrainChanged&quot;);
-			}
-			if (sizeChanged(ch, (byte) Common.parseInt(dts[2]))) {
-				save = true;
-				ret = true;
-				pref.log(&quot;sizeChanged&quot;);
-			}
 		}
-		else {
-			pref.log(&quot;check DTS calculation&quot;, null);
-		}
-		if (newFoundExists(ch,  CacheDescription)) {
+		if (newFoundExists(ch, CacheDescription)) {
 			numLogUpdates++;
 			ret = true;
 		}
@@ -1699,8 +1842,7 @@
 		if (RexNumFinds.didMatch()) {
 			return Common.parseInt(RexNumFinds.stringMatched(1));
 		} else {
-			pref.log(&quot;check RexNumFinds in SpiderGC.java / initialiseProperties&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getNumFound]check RexNumFinds!&quot;, null);
 			return 0;
 		}
 	}
@@ -1717,48 +1859,56 @@
 		}
 		return counter;
 	}
-	
+
 	private String decodeXor(String input, String key) {
-	  byte ctmp[] = input.getBytes();
-		byte ckey[] = key.getBytes();
-		int codeLength = input.length();
-		int keyLength = key.length();
-		for (int i=0; i&lt;codeLength; i++) {
-		  ctmp[i]^=ckey[i%keyLength];
-    }
+		final byte ctmp[] = input.getBytes();
+		final byte ckey[] = key.getBytes();
+		final int codeLength = input.length();
+		final int keyLength = key.length();
+		for (int i = 0; i &lt; codeLength; i++) {
+			ctmp[i] ^= ckey[i % keyLength];
+		}
 		return new String(ctmp);
-  }
+	}
+
 	private double[] getDistanceAndDirection(String doc) {
-		double[] distanceAndDirection={(0.0),(0.0)};
-		if (spiderAllFinds) return distanceAndDirection;
+		final double[] distanceAndDirection = { (0.0), (0.0) };
+		if (spiderAllFinds)
+			return distanceAndDirection;
 		RexPropDistanceCode.search(doc);
 		if (!RexPropDistanceCode.didMatch()) {
-			pref.log(&quot;check distRex&quot; + Preferences.NEWLINE + doc);
-			distanceAndDirection[0]=-1.0; // Abbruch
+			pref.log(&quot;[SpiderGC.java:getDistanceAndDirection]check distRex!&quot;, null);
+			distanceAndDirection[0] = -1.0; // Abbruch
 			return distanceAndDirection;
 		}
-		String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-		String ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
-		RexPropDistance.search(ret); // km oder mi oder ft		
+		final String stmp = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+		String ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
+		RexPropDistance.search(ret); // km oder mi oder ft
 		if (!RexPropDistance.didMatch()) {
-			if (ret.indexOf(&quot;ere&quot;) &gt; -1) return distanceAndDirection; // zur Zeit &quot; Here -1&quot;
+			if (ret.indexOf(&quot;ere&quot;) &gt; -1)
+				return distanceAndDirection; // zur Zeit &quot; Here -1&quot;
 			// Versuch den DistanceCodeKey automatisch zu bestimmen
-			// da dieser von gc mal wieder ge&#228;ndert wurde.
+			// da dieser von gc mal wieder ge&#195;&#131;&#194;&#164;ndert wurde.
 			// todo Ben&#246;tigt ev noch weitere Anpassungen: | am Anfang, and calc of keylength
-
 			// String thereitis=&quot;|0.34 km|102.698&quot;;
-			// String page = fetchText(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1">http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1</A>&quot;,false);
-			String thereitis=&quot;|0.08 km|223.968&quot;;
-			String page = fetchText(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=45.29152&amp;lng=-122.41262&amp;dist=1">http://www.geocaching.com/seek/nearest.aspx?lat=45.29152&amp;lng=-122.41262&amp;dist=1</A>&quot;,false);
-			//  
+			// String page =
+			// fetchText(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1">http://www.geocaching.com/seek/nearest.aspx?lat=48.48973&amp;lng=009.26313&amp;dist=2&amp;f=1</A>&quot;,false);
+			final String thereitis = &quot;|0.08 km|223.968&quot;;
+			String page;
+			try {
+				page = UrlFetcher.fetch(&quot;<A HREF="http://www.geocaching.com/seek/nearest.aspx?lat=45.292&amp;lng=-122.41262&amp;dist=1">http://www.geocaching.com/seek/nearest.aspx?lat=45.292&amp;lng=-122.41262&amp;dist=1</A>&quot;);
+			} catch (final IOException e) {
+				page = &quot;&quot;;
+			}
+			//
 			RexPropListBlock.search(page);
-			String table=&quot;&quot;;
+			String table = &quot;&quot;;
 			if (RexPropListBlock.didMatch()) {
 				table = RexPropListBlock.stringMatched(1);
 			}
-			
+
 			RexPropLine.search(table);
-			String row=&quot;&quot;;
+			String row = &quot;&quot;;
 			if (RexPropLine.didMatch()) {
 				row = RexPropLine.stringMatched(1);
 			}
@@ -1768,34 +1918,35 @@
 				pref.log(&quot;Didn't get DistanceCodeKey automaticly.&quot; + Preferences.NEWLINE);
 				return distanceAndDirection;
 			}
-			String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
-			String newkey=decodeXor(coded,thereitis);
-			int keylength=13; // wenn nicht 13 dann newkey auf wiederholung pr&#252;fen
-			DistanceCodeKey=newkey.substring(0, keylength);
-			ret = decodeXor( stmp, DistanceCodeKey).replace('|', ' ');
+			final String coded = ewe.net.URL.decodeURL(RexPropDistanceCode.stringMatched(1));
+			final String newkey = decodeXor(coded, thereitis);
+			final int keylength = 13;
+			// wenn nicht 13 dann newkey auf wiederholung pr&#195;&#131;&#194;&#188;fen
+			DistanceCodeKey = newkey.substring(0, keylength);
+			ret = decodeXor(stmp, DistanceCodeKey).replace('|', ' ');
+			pref.log(&quot;Automatic key: &quot; + DistanceCodeKey + &quot; result: &quot; + ret + Preferences.NEWLINE);
 			RexPropDistance.search(ret); // km oder mi
 		}
 
 		if (RexPropDistance.didMatch()) {
 			if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
 				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1).replace('.', ','));
-				String r = RexPropDistance.right(1).substring(3);  //3 expexts 2 char which are at moment &quot;km&quot; or &quot;mi&quot;
+				final String r = RexPropDistance.right(1).substring(3);
+				// 3 expexts 2 char which are at moment &quot;km&quot; or &quot;mi&quot;
 				distanceAndDirection[1] = Convert.toDouble(r.replace('.', ','));
-			}
-			else {
-				distanceAndDirection[0] =  Convert.toDouble(RexPropDistance.stringMatched(1));
-				String r = RexPropDistance.right(1).substring(3);
+			} else {
+				distanceAndDirection[0] = Convert.toDouble(RexPropDistance.stringMatched(1));
+				final String r = RexPropDistance.right(1).substring(3);
 				distanceAndDirection[1] = Convert.toDouble(r);
 			}
-			if (ret.indexOf(&quot;ft&quot;)&gt;0) {
+			if (ret.indexOf(&quot;ft&quot;) &gt; 0) {
 				// Umrechnung in miles
-				distanceAndDirection[0]=distanceAndDirection[0] / 5280.0;				
+				distanceAndDirection[0] = distanceAndDirection[0] / 5280.0;
 			}
+		} else {
+			pref.log(&quot;[SpiderGC.java:getDistanceAndDirection](gc Code change ?) check distCodeKey!&quot;, null);
 		}
-		else {
-			pref.log(&quot;(gc Code change ?) check distCodeKey in spider.def&quot; + Preferences.NEWLINE + doc);
-		}
-		
+
 		return distanceAndDirection;
 	}
 
@@ -1809,7 +1960,7 @@
 	private String getWP(String doc) throws Exception {
 		RexPropWaypoint.search(doc);
 		if (!RexPropWaypoint.didMatch()) {
-			pref.log(&quot;check waypointRex in spider.def&quot; + Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getWP]check waypointRex!&quot;, null);
 			return &quot;???&quot;;
 		}
 		return &quot;GC&quot; + RexPropWaypoint.stringMatched(1);
@@ -1826,7 +1977,7 @@
 		} else {
 			numPrivate = numPrivate + 1;
 			if (spiderAllFinds) {
-				pref.log(chWaypoint+&quot; is private.&quot;,null);
+				pref.log(chWaypoint + &quot; is private.&quot;, null);
 			}
 			return false;
 		}
@@ -1850,167 +2001,90 @@
 				return true;
 			}
 		}
-		pref.log(&quot;check TypeRex in spider.def&quot; + Preferences.NEWLINE + toCheck);
+		pref.log(&quot;[SpiderGC.java:typeChanged]check TypeRex!&quot;, null);
 		return false;
 	}
-	
+
 	private String getDTS(String toCheck) {
 		RexPropDTS.search(toCheck);
 		if (RexPropDTS.didMatch()) {
-			String code=RexPropDTS.stringMatched(1);
+			final String code = RexPropDTS.stringMatched(1);
 			/* */
-			String url = &quot;<A HREF="http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=">http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=</A>&quot;+code;
-			ByteArray doc=fetch(url);
-			Image idoc = new Image(doc,0,null,0,0);
-			/*
-			FileOutputStream fos;
+			final String address = &quot;<A HREF="http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=">http://www.geocaching.com/ImgGen/seek/CacheInfo.ashx?v=</A>&quot; + code;
+			ByteArray doc;
 			try {
-				fos = new FileOutputStream(new File(&quot;temp.png&quot;));
-				fos.write(doc.toBytes());
-				fos.close();
-			} catch (IOException e) {
+				doc = UrlFetcher.fetchData(address);
+			} catch (final IOException e) {
+				return &quot;&quot;;
 			}
-			finally {
-			}
-			*/
-			String ret = getDTfromImage(idoc) + &quot;/&quot; + getSizeFromImage(idoc);
-			return ret; 
-			//*/
+			final Image idoc = new Image(doc, 0, null, 0, 0);
+			/*
+			 * FileOutputStream fos; try { fos = new FileOutputStream(new File(&quot;temp.png&quot;)); fos.write(doc.toBytes());
+			 * fos.close(); } catch (IOException e) { } finally { }
+			 */
+			final String ret = getDTfromImage(idoc) + &quot;/&quot; + getSizeFromImage(idoc);
+			return ret;
+			// */
 
 			/*
-			int decoded = 0;
-			int pwr = 1;
-			for (int i = code.length()-1 ; i &gt;= 0; i--) {
-				decoded = decoded + DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr;
-				pwr = pwr * 42;
-			}
-			decoded = (decoded - 131586) % 16777216;
-			// size 0=not choosen 1=Micro 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small
-			int sizecode = decoded / 74088; // 42 ^ 3
-			int sizeremove;
-			byte size;
-			switch (sizecode) {
-			case 0: size=CacheSize.CW_SIZE_NOTCHOSEN; sizeremove=0; break;
-			case 1: size=CacheSize.CW_SIZE_MICRO; sizeremove=131072; break;
-			case 3: size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break;
-			case 5: size=CacheSize.CW_SIZE_LARGE; sizeremove=393217; break;
-			case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break;
-			case 8: size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break;
-			case 12: size=CacheSize.CW_SIZE_SMALL; sizeremove=917504; break;
-			default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break;
-			}
-			decoded = decoded - sizeremove;
-			int terraincode = decoded / 252;
-			// terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String terrain = &quot;&quot; + (1 + terraincode / 2.0 ); 
-			// difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
-			String difficulty = &quot;&quot; + (1+((decoded % 42) - (terraincode * 4)) / 2.0);
-			if (difficulty.equals(&quot;0.5&quot;)) {
-				difficulty = &quot;5&quot;;
-			}
-			return difficulty+&quot;/&quot;+terrain+&quot;/&quot;+size;
-			*/
+			 * int decoded = 0; int pwr = 1; for (int i = code.length()-1 ; i &gt;= 0; i--) { decoded = decoded +
+			 * DTSCodeKey.indexOf(code.substring(i,i+1)) * pwr; pwr = pwr * 42; } decoded = (decoded - 1386) % 16777216; //
+			 * size 0=not choosen 1=Micro 3=Regular 5=Large 7=Virtual 8=Unknown 12=Small int sizecode = decoded / 74088; //
+			 * 42 ^ 3 int sizeremove; byte size; switch (sizecode) { case 0: size=CacheSize.CW_SIZE_NOTCHOSEN;
+			 * sizeremove=0; break; case 1: size=CacheSize.CW_SIZE_MICRO; sizeremove=131072; break; case 3:
+			 * size=CacheSize.CW_SIZE_REGULAR; sizeremove=262144; break; case 5: size=CacheSize.CW_SIZE_LARGE;
+			 * sizeremove=393217; break; case 7: size=CacheSize.CW_SIZE_VIRTUAL; sizeremove=524288; break; case 8:
+			 * size=CacheSize.CW_SIZE_OTHER; sizeremove=655360; break; case 12: size=CacheSize.CW_SIZE_SMALL;
+			 * sizeremove=917504; break; default: size=CacheSize.CW_SIZE_ERROR; sizeremove=0; break; } decoded = decoded -
+			 * sizeremove; int terraincode = decoded / 252; // terrain 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
+			 * String terrain = &quot;&quot; + (1 + terraincode / 2.0 ); // difficulty 0=1 1=1.5 2=2 3=2.5 4=3 5=3.5 6=4 7=4.5 8=5
+			 * String difficulty = &quot;&quot; + (1+((decoded % 42) - (terraincode * 4)) / 2.0); if (difficulty.equals(&quot;0.5&quot;)) {
+			 * difficulty = &quot;5&quot;; } return difficulty+&quot;/&quot;+terrain+&quot;/&quot;+size;
+			 */
 		}
-		pref.log(&quot;check DTSRex in spider.def&quot; + Preferences.NEWLINE + toCheck);
+		pref.log(&quot;[SpiderGC.java:getDTS]check DTSRex!&quot;, null);
 		return &quot;&quot;;
 	}
 
 	static Hashtable validChars = new Hashtable();
-	
+
 	static {
-		validChars.put(&quot;.&quot;, new int[][] {
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 0, 0 },
-				{0, 1, 0 },
-				{0, 1, 0 }
-		});
-		validChars.put(&quot;/&quot;, new int[][] {
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0}
-		});
-		validChars.put(&quot;1&quot;, new int[][] {
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{0, 0, 1, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put(&quot;2&quot;, new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 1, 0},
-				{0, 0, 1, 0, 0},
-				{0, 1, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 1}
-		});
-		validChars.put(&quot;3&quot;, new int[][] {
-				{0, 1, 1, 1, 0},
-				{1, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{0, 0, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
-		validChars.put(&quot;4&quot;, new int[][] {
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 1, 1, 0},
-				{0, 0, 1, 0, 1, 0},
-				{0, 1, 0, 0, 1, 0},
-				{1, 0, 0, 0, 1, 0},
-				{1, 1, 1, 1, 1, 1},
-				{0, 0, 0, 0, 1, 0},
-				{0, 0, 0, 0, 1, 0}
-		});
-		validChars.put(&quot;5&quot;, new int[][] {
-				{1, 1, 1, 1, 1},
-				{1, 0, 0, 0, 0},
-				{1, 0, 0, 0, 0},
-				{1, 1, 1, 1, 0},
-				{0, 0, 0, 0, 1},
-				{0, 0, 0, 0, 1},
-				{1, 0, 0, 0, 1},
-				{0, 1, 1, 1, 0}
-		});
+		validChars.put(&quot;.&quot;, new int[][] { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 1, 0 }, { 0, 1, 0 } });
+		validChars.put(&quot;/&quot;, new int[][] { { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 } });
+		validChars.put(&quot;1&quot;, new int[][] { { 0, 0, 1, 0, 0 }, { 1, 1, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 1, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put(&quot;2&quot;, new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 } });
+		validChars.put(&quot;3&quot;, new int[][] { { 0, 1, 1, 1, 0 }, { 1, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
+		validChars.put(&quot;4&quot;, new int[][] { { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 1, 1, 0 }, { 0, 0, 1, 0, 1, 0 }, { 0, 1, 0, 0, 1, 0 }, { 1, 0, 0, 0, 1, 0 }, { 1, 1, 1, 1, 1, 1 }, { 0, 0, 0, 0, 1, 0 }, { 0, 0, 0, 0, 1, 0 } });
+		validChars.put(&quot;5&quot;, new int[][] { { 1, 1, 1, 1, 1 }, { 1, 0, 0, 0, 0 }, { 1, 0, 0, 0, 0 }, { 1, 1, 1, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 1 }, { 0, 1, 1, 1, 0 } });
 	}
 
 	private static byte getSizeFromImage(Image bild) {
 		int[] argb = bild.getPixels(null, 0, 5, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_MICRO;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_MICRO;
 		argb = bild.getPixels(null, 0, 10, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_SMALL;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_SMALL;
 		argb = bild.getPixels(null, 0, 17, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_REGULAR;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_REGULAR;
 		argb = bild.getPixels(null, 0, 26, 23, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_LARGE;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_LARGE;
 		argb = bild.getPixels(null, 0, 40, 23, 1, 1, 0);
-		if (argb[0] == -6735302) return CacheSize.CW_SIZE_NOTCHOSEN;
+		if (argb[0] == -6735302)
+			return CacheSize.CW_SIZE_NOTCHOSEN;
 		argb = bild.getPixels(null, 0, 41, 24, 1, 1, 0);
-		if (argb[0] == -7005927) return CacheSize.CW_SIZE_OTHER;
+		if (argb[0] == -7005927)
+			return CacheSize.CW_SIZE_OTHER;
 		return CacheSize.CW_SIZE_ERROR;
 	}
 
 	private static String getDTfromImage(Image bild) {
-		StringBuffer sb = new StringBuffer();
+		final StringBuffer sb = new StringBuffer();
 		for (int startX = 0; startX &lt; bild.getWidth(); startX++) {
-			for (Enumeration e = validChars.keys(); e.hasMoreElements();) {
-				String key=(String) e.nextElement();
+			for (final Enumeration e = validChars.keys(); e.hasMoreElements();) {
+				final String key = (String) e.nextElement();
 				if (testValidChar(bild, startX, 4, (int[][]) validChars.get(key))) {
 					sb.append(key);
 				}
@@ -2021,17 +2095,16 @@
 
 	private static boolean testValidChar(Image bild, int startX, int startY, int[][] validChar) {
 		for (int y = 0; y &lt; validChar.length; y++) {
-			if (bild.getHeight() &gt; startY+y) {
+			if (bild.getHeight() &gt; startY + y) {
 				for (int x = 0; x &lt; validChar[0].length; x++) {
-					if (bild.getWidth() &gt; startX+x) {
+					if (bild.getWidth() &gt; startX + x) {
 						// int[] alpha = bild.getAlphaRaster().getPixel(startX+x, startY+y, new int[1]);
-						int[] argb = bild.getPixels(null, 0, startX+x, startY+y, 1, 1, 0);
-						if ((argb[0] == 0 &amp;&amp; validChar[y][x] == 0) ||
-								(argb[0] != 0 &amp;&amp; validChar[y][x] &gt; 0)) {
+						final int[] argb = bild.getPixels(null, 0, startX + x, startY + y, 1, 1, 0);
+						if ((argb[0] == 0 &amp;&amp; validChar[y][x] == 0) || (argb[0] != 0 &amp;&amp; validChar[y][x] &gt; 0)) {
 							// matches
 						} else {
 							return false;
-						} 
+						}
 					} else {
 						return false;
 					}
@@ -2054,6 +2127,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed Terrain
 	 */
@@ -2065,6 +2139,7 @@
 			return true;
 		}
 	}
+
 	/*
 	 * check for changed CacheSize
 	 */
@@ -2083,18 +2158,21 @@
 	private boolean directionOK(String[] directions, double toCheck) {
 		if (directions == null || directions.length == 0)
 			return true; // nothing means all
-		int lowerLimit = Common.parseInt(directions[0]);
-		int upperLimit = Common.parseInt(directions[1]);
+		final int lowerLimit = Common.parseInt(directions[0]);
+		final int upperLimit = Common.parseInt(directions[1]);
 		if (lowerLimit &lt;= upperLimit) {
-			if ((toCheck&gt;=lowerLimit) &amp;&amp; (toCheck&lt;=upperLimit))
-			{return true;}
-			else {return false;}
+			if ((toCheck &gt;= lowerLimit) &amp;&amp; (toCheck &lt;= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
+		} else {
+			if ((toCheck &gt;= lowerLimit) || (toCheck &lt;= upperLimit)) {
+				return true;
+			} else {
+				return false;
+			}
 		}
-		else {
-			if ((toCheck&gt;=lowerLimit) || (toCheck&lt;=upperLimit))
-			{return true;}
-			else {return false;}
-		}
 	}
 
 	/*
@@ -2105,102 +2183,75 @@
 	 * @return boolean newLogExists
 	 */
 	private boolean newFoundExists(CacheHolder ch, String cacheDescription) {
-		if (!pref.checkLog || pref.maxLogsToSpider==0)
+		if (!pref.checkLog || pref.maxLogsToSpider == 0)
 			return false;
-		Time lastLogCW = new Time();
-		Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
+		final Time lastLogCW = new Time();
+		final Log lastLog = ch.getCacheDetails(true).CacheLogs.getLog(0);
 		if (lastLog == null)
 			return true;
-		String slastLogCW = lastLog.getDate();
+		final String slastLogCW = lastLog.getDate();
 		if (slastLogCW.equals(&quot;&quot;) || slastLogCW.equals(&quot;1900-00-00&quot;))
 			return true; // or check cacheDescGC also no log?
 		lastLogCW.parse(slastLogCW, &quot;yyyy-MM-dd&quot;);
 
-		Time lastLogGC = new Time(); // is current time
-		lastLogGC.hour = 0;
-		lastLogGC.minute = 0;
-		lastLogGC.second = 0;
-		lastLogGC.millis = 0;
-		String[] SDate;
 		String stmp = &quot;&quot;;
 		RexPropLogDate.search(cacheDescription);
 		if (RexPropLogDate.didMatch()) {
 			stmp = RexPropLogDate.stringMatched(1);
 		} else {
-			pref.log(&quot;check logDateRex in spider.def&quot; + Preferences.NEWLINE + cacheDescription);
+			pref.log(&quot;[SpiderGC.java:newFoundExists]check logDateRex!&quot;, null);
 			return false;
 		}
-		if (stmp.indexOf(&quot;day&quot;) &gt; 0) {
-			// simplyfied (update if not newer than last week)
-			lastLogGC.setTime(lastLogGC.getTime() - 691200000L); 
-		} else if (stmp.equals(&quot;&quot;)) {
-			return false; // no log yet
-		} else {
-			final String monthNames[] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;,
-					&quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;,
-					&quot;October&quot;, &quot;November&quot;, &quot;December&quot; };
-			SDate = mString.split(stmp, ' ');
-			lastLogGC.day = Common.parseInt(SDate[0]);
-			for (int m = 0; m &lt; 12; m++) {
-				if (monthNames[m].startsWith(SDate[1])) {
-					lastLogGC.month = m + 1;
-					m = 12;
-				}
-			}
-			lastLogGC.year = 2000 + Common.parseInt(SDate[2].substring(0, 2));
-		}
-		boolean ret = lastLogCW.compareTo(lastLogGC) &lt; 0;
+		final Time lastLogGC = DateFormat.toDate(stmp);
+		// String timecheck = DateFormat.toYYMMDD(lastLogGC);
+		final boolean ret = lastLogCW.compareTo(lastLogGC) &lt; 0;
 		return ret;
 	}
+
 	private boolean TBchanged(CacheHolder ch, String cacheDescription) {
-		// simplified Version: only presence is checked 
-		if (pref.downloadTBs &amp;&amp; pref.checkTBs ) {
-			boolean hasTB=cacheDescription.indexOf(&quot;data-tbcount&quot;) &gt; -1;
+		// simplified Version: only presence is checked
+		if (pref.downloadTBs &amp;&amp; pref.checkTBs) {
+			final boolean hasTB = cacheDescription.indexOf(&quot;data-tbcount&quot;) &gt; -1;
 			return ch.has_bugs() != (hasTB);
 		}
 		return false;
 	}
 
 	/**
-	 * Read a complete cachepage from geocaching.com including all logs. This is
-	 * used both when updating already existing caches (via spiderSingle) and
-	 * when spidering around a centre. It is also used when reading a GPX file
+	 * Read a complete cachepage from geocaching.com including all logs. This is used both when updating already
+	 * existing caches (via spiderSingle) and when spidering around a centre. It is also used when reading a GPX file
 	 * and fetching the images.
 	 * 
 	 * This is the workhorse function of the spider.
 	 * 
 	 * @param CacheHolderDetail
 	 *            chD The element wayPoint must be set to the name of a waypoint
-	 * @param boolean isUpdate True if an existing cache is being updated, false
-	 *        if it is a new cache
-	 * @param boolean fetchImages True if the pictures are to be fetched
-	 * @param boolean fetchTBs True if the TBs are to be fetched
-	 * @param boolean doNotGetFound True if the cache is not to be spidered if
-	 *        it has already been found
-	 * @param boolean fetchAllLogs True if all logs are to be fetched (by adding
-	 *        option '&amp;logs=y' to command line). This is normally false when
-	 *        spidering from GPXImport as the logs are part of the GPX file, and
-	 *        true otherwise
-	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was
-	 *         an error (continue with next cache), 1 if everything ok
+	 * @param boolean
+	 *        isUpdate True if an existing cache is being updated, false if it is a new cache
+	 * @param boolean
+	 *        fetchImages True if the pictures are to be fetched
+	 * @param boolean
+	 *        fetchTBs True if the TBs are to be fetched
+	 * @param boolean
+	 *        doNotGetFound True if the cache is not to be spidered if it has already been found
+	 * @param boolean
+	 *        fetchAllLogs True if all logs are to be fetched (by adding option '&amp;logs=y' to command line). This is
+	 *        normally false when spidering from GPXImport as the logs are part of the GPX file, and true otherwise
+	 * @return -1 if the infoBox was closed (cancel spidering), 0 if there was an error (continue with next cache), 1 if
+	 *         everything ok
 	 */
-	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate,
-			boolean fetchImages, boolean fetchTBs, boolean doNotGetFound,
-			boolean fetchAllLogs) {
+	private int getCacheByWaypointName(CacheHolder ch, boolean isUpdate, boolean fetchImages, boolean fetchTBs, boolean doNotGetFound, boolean fetchAllLogs) {
 		int ret = SPIDER_OK; // initialize value;
 		while (true) { // retry even if failure
 			pref.log(&quot;&quot;); // new line for more overview
 			String completeWebPage;
 			int spiderTrys = 0;
-			int MAX_SPIDER_TRYS = 3;
+			final int MAX_SPIDER_TRYS = 3;
 			while (spiderTrys++ &lt; MAX_SPIDER_TRYS) {
 				ret = SPIDER_OK; // initialize value;
 				try {
-					String doc = p.getProp(&quot;getPageByName&quot;)
-							+ ch.getWayPoint()
-							+ ((fetchAllLogs || ch.is_found()) ? p
-									.getProp(&quot;fetchAllLogs&quot;) : &quot;&quot;);
-					completeWebPage = fetchText(doc, false);
+					final String doc = p.getProp(&quot;getPageByName&quot;) + ch.getWayPoint() + ((fetchAllLogs || ch.is_found()) ? p.getProp(&quot;fetchAllLogs&quot;) : &quot;&quot;);
+					completeWebPage = UrlFetcher.fetch(doc);
 					pref.log(&quot;Fetched: &quot; + ch.getWayPoint());
 					if (completeWebPage.equals(&quot;&quot;)) {
 						pref.log(&quot;Could not fetch &quot; + ch.getWayPoint(), null);
@@ -2211,7 +2262,7 @@
 							return SPIDER_CANCEL;
 						}
 					}
-				} catch (Exception ex) {
+				} catch (final Exception ex) {
 					pref.log(&quot;Could not fetch &quot; + ch.getWayPoint(), ex);
 					if (!infB.isClosed) {
 						continue;
@@ -2220,18 +2271,15 @@
 						return SPIDER_CANCEL;
 					}
 				}
-				// Only analyse the cache data and fetch pictures if user has
-				// not closed the progress window
+				// Only analyse the cache data and fetch pictures if user has not closed the progress window
 				if (!infB.isClosed) {
 					try {
 						ch.initStates(!isUpdate);
 
-						// first check if coordinates are available to prevent
-						// deleting existing coordinates
-						String latLon = getLatLon(completeWebPage);
+						// first check if coordinates are available to prevent deleting existing coordinates
+						final String latLon = getLatLon(completeWebPage);
 						if (latLon.equals(&quot;???&quot;)) {
-							if (completeWebPage.indexOf(p
-									.getProp(&quot;premiumCachepage&quot;)) &gt; 0) {
+							if (completeWebPage.indexOf(p.getProp(&quot;premiumCachepage&quot;)) &gt; 0) {
 								// Premium cache spidered by non premium member
 								pref.log(&quot;Ignoring premium member cache: &quot; + ch.getWayPoint());
 								spiderTrys = MAX_SPIDER_TRYS;
@@ -2239,7 +2287,7 @@
 								continue;
 							} else {
 								if (spiderTrys == MAX_SPIDER_TRYS)
-									pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot; + completeWebPage, null);
+									pref.log(&quot;&gt;&gt;&gt;&gt; Failed to spider Cache. Retry.&quot;, null);
 								ret = SPIDER_ERROR;
 								continue; // Restart the spider
 							}
@@ -2247,24 +2295,20 @@
 
 						ch.setHTML(true);
 						ch.setIncomplete(true);
-						// Save size of logs to be able to check whether any new
-						// logs were added
+						// Save size of logs to be able to check whether any new logs were added
 						// int logsz = chD.CacheLogs.size();
 						// chD.CacheLogs.clear();
 						ch.addiWpts.clear();
 						ch.getCacheDetails(false).images.clear();
 
-						ch.setAvailable(!(completeWebPage.indexOf(p
-								.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0));
-						ch.setArchived(completeWebPage.indexOf(p
-								.getProp(&quot;cacheArchived&quot;)) &gt;= 0);
+						ch.setAvailable(!(completeWebPage.indexOf(p.getProp(&quot;cacheUnavailable&quot;)) &gt;= 0));
+						ch.setArchived(completeWebPage.indexOf(p.getProp(&quot;cacheArchived&quot;)) &gt;= 0);
 						// ==========
 						// Logs first (for check early for break)
 						// ==========
 						getLogs(completeWebPage, ch.getCacheDetails(false));
 						pref.log(&quot;Got logs&quot;);
-						// If the switch is set to not store found caches and we
-						// found the cache =&gt; return
+						// If the switch is set to not store found caches and we found the cache =&gt; return
 						if (ch.is_found() &amp;&amp; doNotGetFound) {
 							if (infB.isClosed) {
 								return SPIDER_CANCEL;
@@ -2275,30 +2319,24 @@
 						// ==========
 						// General Cache Data
 						// ==========
-						ch.setLatLon(latLon);
-						pref.log(&quot;LatLon: &quot; + ch.getLatLon());
+						ch.setPos(new CWPoint(latLon));
+						pref.log(&quot;LatLon: &quot; + ch.getPos().toString());
 
-						String longDesc = getLongDesc(completeWebPage);
+						final String longDesc = getLongDesc(completeWebPage);
 						ch.getCacheDetails(false).setLongDescription(longDesc);
 						pref.log(&quot;Got description&quot;);
 
-						ch.setCacheName(SafeXML
-								.cleanback(getName(completeWebPage)));
+						ch.setCacheName(SafeXML.cleanback(getName(completeWebPage)));
 						pref.log(&quot;Name: &quot; + ch.getCacheName());
 
-						String location = getLocation(completeWebPage);
+						final String location = getLocation(completeWebPage);
 						if (location.length() != 0) {
-							int countryStart = location.indexOf(&quot;,&quot;);
+							final int countryStart = location.indexOf(&quot;,&quot;);
 							if (countryStart &gt; -1) {
-								ch.getCacheDetails(false).Country = SafeXML
-										.cleanback(location.substring(
-												countryStart + 1).trim());
-								ch.getCacheDetails(false).State = SafeXML
-										.cleanback(location.substring(0,
-												countryStart).trim());
+								ch.getCacheDetails(false).Country = SafeXML.cleanback(location.substring(countryStart + 1).trim());
+								ch.getCacheDetails(false).State = SafeXML.cleanback(location.substring(0, countryStart).trim());
 							} else {
-								ch.getCacheDetails(false).Country = location
-										.trim();
+								ch.getCacheDetails(false).Country = location.trim();
 								ch.getCacheDetails(false).State = &quot;&quot;;
 							}
 							pref.log(&quot;Got location (country/state)&quot;);
@@ -2310,31 +2348,23 @@
 						String owner = getOwner(completeWebPage);
 						owner = SafeXML.cleanback(owner).trim();
 						ch.setCacheOwner(owner);
-						if (ch.getCacheOwner().equals(pref.myAlias)
-							|| (pref.myAlias2.length() &gt; 0 &amp;&amp; ch.getCacheOwner().equals(pref.myAlias2)))
+						if (ch.getCacheOwner().equals(pref.myAlias) || (pref.myAlias2.length() &gt; 0 &amp;&amp; ch.getCacheOwner().equals(pref.myAlias2)))
 							ch.setOwned(true);
-						pref.log(&quot;Owner: &quot; + ch.getCacheOwner()
-								+ &quot;; is_owned = &quot; + ch.is_owned()
-								+ &quot;;  alias1,2 = [&quot; + pref.myAlias + &quot;|&quot;
-								+ pref.myAlias2 + &quot;]&quot;);
+						pref.log(&quot;Owner: &quot; + ch.getCacheOwner() + &quot;; is_owned = &quot; + ch.is_owned() + &quot;;  alias1,2 = [&quot; + pref.myAlias + &quot;|&quot; + pref.myAlias2 + &quot;]&quot;);
 
-						ch.setDateHidden(DateFormat
-								.MDY2YMD(getDateHidden(completeWebPage)));
+						ch.setDateHidden(DateFormat.toYYMMDD(getDateHidden(completeWebPage)));
 						pref.log(&quot;Hidden: &quot; + ch.getDateHidden());
 
-						ch.getCacheDetails(false).setHints(
-								getHints(completeWebPage));
+						ch.getCacheDetails(false).setHints(getHints(completeWebPage));
 						pref.log(&quot;Hints: &quot; + ch.getCacheDetails(false).Hints);
 
-						ch.setCacheSize(CacheSize
-								.gcSpiderString2Cw(getSize(completeWebPage)));
+						ch.setCacheSize(CacheSize.gcSpiderString2Cw(getSize(completeWebPage)));
 						pref.log(&quot;Size: &quot; + ch.getCacheSize());
 
 						ch.setHard(CacheTerrDiff.v1Converter(getDiff(completeWebPage)));
 						pref.log(&quot;Hard: &quot; + ch.getHard());
 
-						ch.setTerrain(CacheTerrDiff
-								.v1Converter(getTerr(completeWebPage)));
+						ch.setTerrain(CacheTerrDiff.v1Converter(getTerr(completeWebPage)));
 						pref.log(&quot;Terr: &quot; + ch.getTerrain());
 
 						ch.setType(getType(completeWebPage));
@@ -2344,27 +2374,24 @@
 						// ==========
 						if (fetchTBs)
 							getBugs(ch.getCacheDetails(false), completeWebPage);
-						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs
-								.size() &gt; 0);
+						ch.setHas_bugs(ch.getCacheDetails(false).Travelbugs.size() &gt; 0);
 						pref.log(&quot;Got TBs&quot;);
 						// ==========
 						// Images
 						// ==========
 						if (fetchImages) {
-							getImages(completeWebPage, ch.getCacheDetails(false),true);
+							getImages(completeWebPage, ch.getCacheDetails(false), true);
 							pref.log(&quot;Got images&quot;);
 						}
 						// ==========
 						// Addi waypoints
 						// ==========
-						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch
-								.is_found());
+						getAddWaypoints(completeWebPage, ch.getWayPoint(), ch.is_found());
 						pref.log(&quot;Got additional waypoints&quot;);
 						// ==========
 						// Attributes
 						// ==========
-						getAttributes(completeWebPage, ch
-								.getCacheDetails(false));
+						getAttributes(completeWebPage, ch.getCacheDetails(false));
 						pref.log(&quot;Got attributes&quot;);
 						// ==========
 						// Last sync date
@@ -2373,7 +2400,7 @@
 						ch.setIncomplete(false);
 						pref.log(&quot;ready &quot; + ch.getWayPoint() + &quot; : &quot; + ch.getLastSync());
 						break;
-					} catch (Exception ex) {
+					} catch (final Exception ex) {
 						pref.log(&quot;[getCacheByWaypointName: ]Error reading cache: &quot; + ch.getWayPoint(), ex);
 					}
 				} else {
@@ -2382,10 +2409,7 @@
 			} // spiderTrys
 			if ((spiderTrys &gt;= MAX_SPIDER_TRYS) &amp;&amp; (ret == SPIDER_OK)) {
 				pref.log(&quot;&gt;&gt;&gt; Failed to spider cache. Number of retrys exhausted.&quot;, null);
-				int decision = (new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(5515,&quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;),
-						FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB))
-						.execute();
+				final int decision = (new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(55, &quot;Failed to load cache.%0aPleas check your internet connection.%0aRetry?&quot;), FormBase.DEFOKB | FormBase.NOB | FormBase.CANCELB)).execute();
 				if (decision == FormBase.IDOK) {
 					continue; // retry even if failure
 				} else if (decision == FormBase.IDNO) {
@@ -2396,8 +2420,8 @@
 			}
 			break;
 		}// while(true) // retry even if failure
-		if (infB.isClosed) {// If the infoBox was closed before getting here, we
-							// return -1
+		if (infB.isClosed) {
+			// If the infoBox was closed before getting here, we return -1
 			return SPIDER_CANCEL;
 		}
 		return ret;
@@ -2411,11 +2435,10 @@
 	 * @return Cache coordinates
 	 */
 	private String getLatLon(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;latLonRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check latLonRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getLatLon]check latLonRex!&quot;, null);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2432,13 +2455,13 @@
 	 */
 	private String getLongDesc(String doc) throws Exception {
 		String res = &quot;&quot;;
-		Regex shortDescRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
-		Regex longDescRex = new Regex(p.getProp(&quot;longDescRex&quot;));
+		final Regex shortDescRex = new Regex(p.getProp(&quot;shortDescRex&quot;));
+		final Regex longDescRex = new Regex(p.getProp(&quot;longDescRex&quot;));
 		shortDescRex.search(doc);
 		if (!shortDescRex.didMatch()) {
 			if (shortDescRex_not_yet_found)
-				pref.log(&quot;no shortDesc or check shortDescRex in spider.def&quot;);
-				//		+ Preferences.NEWLINE + doc);
+				pref.log(&quot;[SpiderGC.java:getLongDesc]no shortDesc or check shortDescRex!&quot;, null);
+			// + Preferences.NEWLINE + doc);
 		} else {
 			res = shortDescRex.stringMatched(1);
 			shortDescRex_not_yet_found = false;
@@ -2446,18 +2469,16 @@
 		res += &quot;&lt;br&gt;&quot;;
 		longDescRex.search(doc);
 		if (!longDescRex.didMatch()) {
-			pref.log(&quot;check longDescRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getLongDesc]check longDescRex!&quot;, null);
 		} else {
 			res += longDescRex.stringMatched(1);
 		}
-		int spanEnd = res.lastIndexOf(&quot;&lt;/span&gt;&quot;);
+		final int spanEnd = res.lastIndexOf(&quot;&lt;/span&gt;&quot;);
 		if (spanEnd &gt;= 0) {
 			res = res.substring(0, spanEnd);
 		}
-		return SafeXML.cleanback(res); // since internal viewer doesn't show
-										// html-entities that are now in
-										// cacheDescription
+		// since internal viewer doesn't show html-entities that are now in cacheDescription
+		return SafeXML.cleanback(res);
 	}
 
 	/**
@@ -2468,11 +2489,10 @@
 	 * @return the location (country and state) of the cache
 	 */
 	private String getLocation(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;cacheLocationRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;cacheLocationRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check cacheLocationRex in spider.def&quot;
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getLocation]check cacheLocationRex!&quot;, null);
 			return &quot;&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2486,11 +2506,10 @@
 	 * @return the name of the cache
 	 */
 	private String getName(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;cacheNameRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check cacheNameRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getName]check cacheNameRex!&quot;, null);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2504,11 +2523,10 @@
 	 * @return the cache owner
 	 */
 	private String getOwner(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;cacheOwnerRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check cacheOwnerRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getOwner]check cacheOwnerRex!&quot;, null);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2522,11 +2540,10 @@
 	 * @return Hidden date
 	 */
 	private String getDateHidden(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;dateHiddenRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check dateHiddenRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getDateHidden]check dateHiddenRex!&quot;, null);
 			return &quot;???&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2540,11 +2557,10 @@
 	 * @return Cachehints
 	 */
 	private String getHints(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;hintsRex&quot;));
 		inRex.search(doc);
 		if (!inRex.didMatch()) {
-			pref.log(&quot;check hintsRex in spider.def&quot;
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getHints]check hintsRex!&quot;, null);
 			return &quot;&quot;;
 		}
 		return inRex.stringMatched(1);
@@ -2558,13 +2574,12 @@
 	 * @return Cache size
 	 */
 	private String getSize(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;sizeRex&quot;));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log(&quot;check sizeRex in spider.def&quot;
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getSize]check sizeRex!&quot;, null);
 			return &quot;None&quot;;
 		}
 	}
@@ -2577,13 +2592,12 @@
 	 * @return The cache difficulty
 	 */
 	private String getDiff(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;difficultyRex&quot;));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log(&quot;check difficultyRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getDiff]check difficultyRex!&quot;, null);
 			return &quot;-1&quot;;
 		}
 	}
@@ -2596,13 +2610,12 @@
 	 * @return Terrain rating
 	 */
 	private String getTerr(String doc) throws Exception {
-		Regex inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
+		final Regex inRex = new Regex(p.getProp(&quot;terrainRex&quot;));
 		inRex.search(doc);
 		if (inRex.didMatch())
 			return inRex.stringMatched(1);
 		else {
-			pref.log(&quot;check terrainRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getTerr]check terrainRex!&quot;, null);
 			return &quot;-1&quot;;
 		}
 	}
@@ -2619,8 +2632,7 @@
 		if (RexCacheType.didMatch())
 			return CacheType.gcSpider2CwType(RexCacheType.stringMatched(1));
 		else {
-			pref.log(&quot;check cacheTypeRex in spider.def&quot; 
-					+ Preferences.NEWLINE + doc);
+			pref.log(&quot;[SpiderGC.java:getType]check cacheTypeRex!&quot;, null);
 			return 0;
 		}
 	}
@@ -2634,44 +2646,41 @@
 	 *            Cache Details
 	 * @return A HTML string containing the logs
 	 */
-	private void getLogs(String completeWebPage, CacheHolderDetail chD)
-			throws Exception {
+	private void getLogs(String completeWebPage, CacheHolderDetail chD) throws Exception {
 		String icon = &quot;&quot;;
 		String name = &quot;&quot;;
 		String logText = &quot;&quot;;
 		String logId = &quot;&quot;;
 		String singleLog = &quot;&quot;;
-		LogList reslts = chD.CacheLogs;
+		final LogList reslts = chD.CacheLogs;
 		RexLogBlock.search(completeWebPage);
 		if (!RexLogBlock.didMatch()) {
-			pref.log(&quot;check blockRex in spider.def&quot; 
-					+ Preferences.NEWLINE + completeWebPage);
+			pref.log(&quot;[SpiderGC.java:getLogs]check blockRex!&quot;, null);
 		}
-		String LogBlock = RexLogBlock.stringMatched(1);
-		exSingleLog.setSource(LogBlock);
-		singleLog = exSingleLog.findNext();
-		exIcon.setSource(singleLog);
-		exNameTemp.setSource(singleLog);
-		exName.setSource(exNameTemp.findNext());
-		exDate.setSource(singleLog);
-		exLog.setSource(singleLog);
-		exLogId.setSource(singleLog);
+		final String LogBlock = RexLogBlock.stringMatched(1);
+
+		exSingleLog.set(LogBlock);
 		int nLogs = 0;
 		boolean foundown = false;
-		while (!exSingleLog.endOfSearch()) {
-			// pref.log(singleLog);
+		while ((singleLog = exSingleLog.findNext()).length() &gt; 0) {
 			nLogs++;
-			icon = exIcon.findNext();
-			icon=icon.substring(0, icon.length() - 1); // ' changes to &quot; in UMTS-connection! first char in iconExEnd.
-			name = exName.findNext();
-			logText = exLog.findNext();
-			logId = exLogId.findNext();
-			String d = DateFormat.logdate2YMD(exDate.findNext());
-			// pref.log(&quot;Lognr:&quot;+nLogs+&quot;|&quot;+icon+&quot;|&quot;+name+&quot;-|-&quot;+SafeXML.clean(pref.myAlias)+&quot;|&quot;+logId,null);
+
+			icon = exIcon.findFirst(singleLog);
+			// ' changes to &quot; in UMTS-connection! first char in iconExEnd.
+			icon = icon.substring(0, icon.length() - 1);
+
+			name = exName.findFirst(exNameTemp.findFirst(singleLog));
+
+			logText = exLog.findFirst(singleLog);
+			logText = correctSmilies(logText);
+
+			logId = exLogId.findFirst(singleLog);
+
+			final String ed = exDate.findFirst(singleLog);
+			final String d = DateFormat.toYYMMDD(ed);
+
 			// if this log says this Cache is found by me
-			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended))	&amp;&amp;
-					(name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) ||
-					( pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
+			if ((icon.equals(icon_smile) || icon.equals(icon_camera) || icon.equals(icon_attended)) &amp;&amp; (name.equalsIgnoreCase(SafeXML.clean(pref.myAlias)) || (pref.myAlias2.length() &gt; 0 &amp;&amp; name.equalsIgnoreCase(SafeXML.clean(pref.myAlias2))))) {
 				chD.getParent().setFound(true);
 				chD.getParent().setCacheStatus(d);
 				chD.OwnLogId = logId;
@@ -2686,13 +2695,6 @@
 					break;
 				}
 			}
-			singleLog = exSingleLog.findNext();
-			exIcon.setSource(singleLog);
-			exNameTemp.setSource(singleLog);
-			exName.setSource(exNameTemp.findNext());
-			exDate.setSource(singleLog);
-			exLog.setSource(singleLog);
-			exLogId.setSource(singleLog);
 		}
 		if (nLogs &gt; pref.maxLogsToSpider) {
 			reslts.add(Log.maxLog());
@@ -2703,70 +2705,83 @@
 	}
 
 	/**
-	 * Read the travelbug names from a previously fetched Cache page and then
-	 * read the travelbug purpose for each travelbug
+	 * This methods cleans up the path for inlined smilies in logtexts.
 	 * 
+	 * @param logText
+	 * @return
+	 */
+	private String correctSmilies(String logText) {
+		int indexOf = logText.indexOf(string);
+		while (indexOf &gt;= 0) {
+			final String prefix = logText.substring(0, indexOf);
+			final String postFix = logText.substring(indexOf + string.length());
+			logText = prefix + &quot;&lt;img src=\&quot;&quot; + postFix;
+			indexOf = logText.indexOf(string);
+		}
+		return logText;
+	}
+
+	/**
+	 * Read the travelbug names from a previously fetched Cache page and then read the travelbug purpose for each
+	 * travelbug
+	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
 	 * @return A HTML formatted string with bug names and there purpose
 	 */
 	public void getBugs(CacheHolderDetail chD, String doc) throws Exception {
-		Extractor exBlock = new Extractor(doc, 
-				p.getProp(&quot;blockExStart&quot;), 
-				p.getProp(&quot;blockExEnd&quot;), 
-				0, Extractor.EXCLUDESTARTEND);
-		String bugBlock = exBlock.findNext();
-		Extractor exBug = new Extractor(bugBlock, 
-				p.getProp(&quot;bugExStart&quot;), 
-				p.getProp(&quot;bugExEnd&quot;), 
-				0, Extractor.EXCLUDESTARTEND);
-		String link, bug, linkPlusBug, bugDetails;
-		String oldInfoBox = infB.getInfo();
 		chD.Travelbugs.clear();
-		while (!exBug.endOfSearch()) {
-			if (infB.isClosed)
-				break; // Allow user to cancel by closing progress form
-			linkPlusBug = exBug.findNext();
-			int idx = linkPlusBug.indexOf(p.getProp(&quot;bugLinkEnd&quot;));
-			if (idx &lt; 0)
-				break; // No link/bug pair found
-			link = linkPlusBug.substring(0, idx);
-			Extractor exBugName = new Extractor(linkPlusBug, 
-					p.getProp(&quot;bugNameExStart&quot;), 
-					p.getProp(&quot;bugNameExEnd&quot;), 
-					0, Extractor.EXCLUDESTARTEND);
-			bug = exBugName.findNext();
-			if (bug.length() &gt; 0) { // Found a bug, get its details
-				Travelbug tb = new Travelbug(bug);
-				try {
-					infB.setInfo(oldInfoBox
-							+ MyLocale.getMsg(5514, &quot;\nGetting bug: &quot;)
-							+ SafeXML.cleanback(bug));
-					bugDetails = fetchText(link, false);
-					pref.log(&quot;[getBugs] Fetched TB details: &quot; + bug);
-					Extractor exDetails = new Extractor(bugDetails, p
-							.getProp(&quot;bugDetailsStart&quot;), p
-							.getProp(&quot;bugDetailsEnd&quot;),
-							0, Extractor.EXCLUDESTARTEND);
-					tb.setMission(exDetails.findNext());
-					Extractor exGuid = new Extractor(bugDetails,
-							&quot;action=\&quot;details.aspx?guid=&quot;,
-							&quot;\&quot; id=\&quot;aspnetForm&quot;,
-							0, Extractor.EXCLUDESTARTEND);
-					tb.setGuid(exGuid.findNext());
-					chD.Travelbugs.add(tb);
-				} catch (Exception ex) {
-					pref.log(&quot;[getBugs] Could not fetch bug details&quot;, ex);
+		if (doc.indexOf(&quot;ctl00_ContentBody_uxTravelBugList_uxNoTrackableItemsLabel&quot;) &gt;= 0) {
+			return; // there are no trackables
+		}
+		final Extractor exBlock = new Extractor(doc, p.getProp(&quot;blockExStart&quot;), p.getProp(&quot;blockExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBug = new Extractor(&quot;&quot;, p.getProp(&quot;bugExStart&quot;), p.getProp(&quot;bugExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
+		final Extractor exBugName = new Extractor(&quot;&quot;, &quot;&quot;, &quot;&quot;, 0, Extractor.EXCLUDESTARTEND);
+		final String bugBlock;
+		bugBlock = exBlock.findNext();
+		int blockLength = bugBlock.length();
+		if (blockLength &gt; 0) {
+			String link, bug, linkPlusBug, bugDetails;
+			final String oldInfoBox = infB.getInfo();
+			boolean exBugWrong = true;
+			exBug.set(bugBlock);
+			while ((linkPlusBug = exBug.findNext()).length() &gt; 0) {
+				exBugWrong = false;
+				if (infB.isClosed)
+					break;
+				final int idx = linkPlusBug.indexOf(p.getProp(&quot;bugLinkEnd&quot;));
+				if (idx &lt; 0) {
+					pref.log(&quot;[SpiderGC.java:getBugs]check TBs bugLinkEnd!&quot;, null);
+					break; // No link/bug pair found
 				}
+				link = linkPlusBug.substring(0, idx);
+				exBugName.set(linkPlusBug, p.getProp(&quot;bugNameExStart&quot;), p.getProp(&quot;bugNameExEnd&quot;), idx, Extractor.EXCLUDESTARTEND);
+				if ((bug = exBugName.findNext()).length() &gt; 0) {
+					// Found a bug, get its mission
+					try {
+						infB.setInfo(oldInfoBox + MyLocale.getMsg(5514, &quot;\nGetting bug: &quot;) + SafeXML.cleanback(bug));
+						bugDetails = UrlFetcher.fetch(link);
+						exBugName.set(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND); // reusing
+						// exBugName
+						chD.Travelbugs.add(new Travelbug(link.substring(1 + link.indexOf(&quot;=&quot;)), bug, exBugName.findNext()));
+					} catch (final Exception ex) {
+						pref.log(&quot;[SpiderGC.java:getBugs] Could not fetch buginfo from &quot; + link, ex);
+					}
+				}
 			}
+			infB.setInfo(oldInfoBox);
+			if (exBugWrong) {
+				if (blockLength &gt; 200)
+					pref.log(&quot;[SpiderGC.java:getBugs]check TBs bugExStart / bugExEnd! blockLength = &quot; + blockLength + &quot; for &quot; + chD.URL, null);
+			}
+		} else {
+			pref.log(&quot;[SpiderGC.java:getBugs]check TBs blockExStart / blockExEnd! &quot;, null);
 		}
-		infB.setInfo(oldInfoBox);
 	}
 
 	/**
-	 * Get the images for a previously fetched cache page. Images are extracted
-	 * from two areas: The long description and the pictures section (including
-	 * the spoiler)
+	 * Get the images for a previously fetched cache page. Images are extracted from two areas: The long description and
+	 * the pictures section (including the spoiler)
 	 * 
 	 * @param doc
 	 *            The previously fetched cachepage
@@ -2777,222 +2792,178 @@
 		int imgCounter = 0;
 		int spiderCounter = 0;
 		String fileName, imgName, imgType, imgUrl, imgComment;
-		Vector spideredUrls = new Vector(15);
+		final Vector spideredUrls = new Vector();
 		ImageInfo imageInfo = null;
 		Extractor exImgBlock, exImgComment;
 		int idxUrl; // Index of already spidered Url in list of spideredUrls
 		CacheImages lastImages = null;
 
 		// First: Get current image object of waypoint before spidering images.
-		CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
+		final CacheHolder oldCh = Global.getProfile().cacheDB.get(chD.getParent().getWayPoint());
 		if (oldCh != null) {
 			lastImages = oldCh.getCacheDetails(false).images;
 		}
-
 		// ========
-		// In the long description
+		// In the long Description
 		// ========
-		String longDesc = &quot;&quot;;
+		String longDesc = doc;
 		try {
-			if (chD.getParent().getWayPoint().startsWith(&quot;TC&quot;) || !extractLongDesc)
-				longDesc = doc;
-			else
+			if (chD.getParent().getWayPoint().startsWith(&quot;GC&quot;) || extractLongDesc)
 				longDesc = getLongDesc(doc);
 			longDesc = STRreplace.replace(longDesc, &quot;&lt;img&quot;, &quot;&lt;IMG&quot;);
 			longDesc = STRreplace.replace(longDesc, &quot;src=&quot;, &quot;SRC=&quot;);
 			longDesc = STRreplace.replace(longDesc, &quot;'&quot;, &quot;\&quot;&quot;);
-			exImgBlock = new Extractor(longDesc, 
-					p.getProp(&quot;imgBlockExStart&quot;),
-					p.getProp(&quot;imgBlockExEnd&quot;), 
-					0, false);
-		} catch (Exception ex) {// Missing property in spider.def
+			exImgBlock = new Extractor(longDesc, p.getProp(&quot;imgBlockExStart&quot;), p.getProp(&quot;imgBlockExEnd&quot;), 0, false);
+		} catch (final Exception ex) {// Missing property in spider.def
 			return;
 		}
 		String tst;
-		tst = exImgBlock.findNext();
-		Extractor exImgSrc = new Extractor(tst, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while (exImgBlock.endOfSearch() == false) {
-			imgUrl = exImgSrc.findNext();
-			if (imgUrl.length() &gt; 0) {
-				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(&quot;.png&quot;)
-							|| imgType.startsWith(&quot;.jpg&quot;)
-							|| imgType.startsWith(&quot;.gif&quot;)) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + &quot;_&quot;
-								+ Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl &lt; 0) { // New image
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ &quot;_&quot; + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl,
-										fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ &quot;_&quot; + Convert.toString(idxUrl);
-							pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+		Extractor exImgSrc = new Extractor(&quot;&quot;, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while ((tst = exImgBlock.findNext()).length() &gt; 0) {
+			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for better caching purposes)
+			imgUrl = exImgSrc.findFirst(tst);
+			imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+					// Check whether image was already spidered for this cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl &lt; 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(imgName);
-						imageInfo.setComment(null);
-						imgCounter++;
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
+						pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
+					imageInfo.setTitle(imgName);
+					imageInfo.setComment(null);
+					imgCounter++;
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 			}
-			exImgSrc.setSource(exImgBlock.findNext());
 		}
 		// ========
 		// In the image span
 		// ========
 		Extractor spanBlock, exImgName;
 		try {
-			spanBlock = new Extractor(doc, p.getProp(&quot;imgSpanExStart&quot;), 
-					p.getProp(&quot;imgSpanExEnd&quot;), 0, true);
+			spanBlock = new Extractor(doc, p.getProp(&quot;imgSpanExStart&quot;), p.getProp(&quot;imgSpanExEnd&quot;), 0, true);
 			tst = spanBlock.findNext();
-			exImgName = new Extractor(tst, p.getProp(&quot;imgNameExStart&quot;), 
-					p.getProp(&quot;imgNameExEnd&quot;), 0, true);
-			exImgSrc = new Extractor(tst, p.getProp(&quot;imgSrcExStart&quot;), 
-					p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
-			exImgComment = new Extractor(tst, p.getProp(&quot;imgCommentExStart&quot;), 
-					p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
-		} catch (Exception ex) {
+			exImgName = new Extractor(tst, p.getProp(&quot;imgNameExStart&quot;), p.getProp(&quot;imgNameExEnd&quot;), 0, true);
+			exImgSrc = new Extractor(tst, p.getProp(&quot;imgSrcExStart&quot;), p.getProp(&quot;imgSrcExEnd&quot;), 0, true);
+			exImgComment = new Extractor(tst, p.getProp(&quot;imgCommentExStart&quot;), p.getProp(&quot;imgCommentExEnd&quot;), 0, true);
+		} catch (final Exception ex) {
 			return;
 		}
-		while (!exImgSrc.endOfSearch()) {
-			imgUrl = exImgSrc.findNext();
+		while ((imgUrl = exImgSrc.findNext()).length() &gt; 0) {
 			imgComment = exImgComment.findNext();
-			if (imgUrl.length() &gt; 0) {
-				imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with .
-					if (imgType.startsWith(&quot;.png&quot;)
-							|| imgType.startsWith(&quot;.jpg&quot;)
-							|| imgType.startsWith(&quot;.gif&quot;)) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						imgName = chD.getParent().getWayPoint() + &quot;_&quot;
-								+ Convert.toString(imgCounter);
-						imageInfo = null;
-						if (idxUrl &lt; 0) { // New image
-							fileName = chD.getParent().getWayPoint()
-									.toLowerCase()
-									+ &quot;_&quot; + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl,
-										fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-						} else { // Image already spidered as wayPoint_'idxUrl'
-							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
-							pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+			imgUrl = &quot;<A HREF="http://">http://</A>&quot; + imgUrl;
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				if (imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+					// Check whether image was already spidered for this cache
+					idxUrl = spideredUrls.find(imgUrl);
+					imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+					imageInfo = null;
+					if (idxUrl &lt; 0) { // New image
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
+						}
+						if (imageInfo == null) {
 							imageInfo = new ImageInfo();
+							pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
 							imageInfo.setFilename(fileName + imgType);
 							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
 						}
-						imageInfo.setTitle(exImgName.findNext());
-						while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;))
-							imgComment = imgComment.substring(6);
-						while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;))
-							imgComment = imgComment.substring(0, imgComment.length() - 6);
-						imageInfo.setComment(imgComment);
-						chD.images.add(imageInfo);
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+					} else { // Image already spidered as wayPoint_'idxUrl'
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(idxUrl);
+						pref.log(&quot;[getImages] Already loaded image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+						imageInfo = new ImageInfo();
+						imageInfo.setFilename(fileName + imgType);
+						imageInfo.setURL(imgUrl);
 					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log(&quot;[getImages] IndexOutOfBoundsException in image span. imgURL:&quot; + imgUrl, e);
+					imageInfo.setTitle(exImgName.findNext());
+					while (imgComment.startsWith(&quot;&lt;br /&gt;&quot;))
+						imgComment = imgComment.substring(6);
+					while (imgComment.endsWith(&quot;&lt;br /&gt;&quot;))
+						imgComment = imgComment.substring(0, imgComment.length() - 6);
+					imageInfo.setComment(imgComment);
+					chD.images.add(imageInfo);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log(&quot;[getImages] IndexOutOfBoundsException in image span. imgURL:&quot; + imgUrl, e);
 			}
+
 		}
 		// ========
 		// Final sweep to check for images in hrefs
 		// ========
-		Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
-		while (!exFinal.endOfSearch()) {
-			imgUrl = exFinal.findNext();
-			if (imgUrl.length() &gt; 0) {
-				// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for
-				// better caching purposes)
-				imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
-				try {
-					imgType = (imgUrl.substring(imgUrl.lastIndexOf('.'))
-							.toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
-					// imgType is now max 4 chars, starting with . Delete
-					// characters in URL after the image extension
-					imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.')
-							+ imgType.length());
-					if (imgType.startsWith(&quot;.jpg&quot;)
-							|| imgType.startsWith(&quot;.bmp&quot;)
-							|| imgType.startsWith(&quot;.png&quot;)
-							|| imgType.startsWith(&quot;.gif&quot;)) {
-						// Check whether image was already spidered for this
-						// cache
-						idxUrl = spideredUrls.find(imgUrl);
-						if (idxUrl &lt; 0) { // New image
-							imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
-							fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
-							if (lastImages != null) {
-								imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
-							}
-							if (imageInfo == null) {
-								imageInfo = new ImageInfo();
-								pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
-								spiderImage(imgUrl, fileName + imgType);
-								imageInfo.setFilename(fileName + imgType);
-								imageInfo.setURL(imgUrl);
-							} else {
-								pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
-							}
-							spideredUrls.add(imgUrl);
-							spiderCounter++;
-							imageInfo.setTitle(imgName);
-							imgCounter++;
-							chD.images.add(imageInfo);
+		final Extractor exFinal = new Extractor(longDesc, &quot;<A HREF="http://">http://</A>&quot;, &quot;\&quot;&quot;, 0, true);
+		while ((imgUrl = exFinal.findNext()).length() &gt; 0) {
+			// Optimize: img.groundspeak.com -&gt; img.geocaching.com (for better caching purposes)
+			imgUrl = CacheImages.optimizeLink(&quot;<A HREF="http://">http://</A>&quot; + imgUrl);
+			try {
+				imgType = (imgUrl.substring(imgUrl.lastIndexOf('.')).toLowerCase() + &quot;    &quot;).substring(0, 4).trim();
+				// imgType is now max 4 chars, starting with .
+				// Delete characters in URL after the image extension
+				imgUrl = imgUrl.substring(0, imgUrl.lastIndexOf('.') + imgType.length());
+				if (imgType.startsWith(&quot;.jpg&quot;) || imgType.startsWith(&quot;.bmp&quot;) || imgType.startsWith(&quot;.png&quot;) || imgType.startsWith(&quot;.gif&quot;)) {
+					// Check whether image was already spidered for this cache
+					idxUrl = spideredUrls.find(imgUrl);
+					if (idxUrl &lt; 0) { // New image
+						imgName = chD.getParent().getWayPoint() + &quot;_&quot; + Convert.toString(imgCounter);
+						fileName = chD.getParent().getWayPoint().toLowerCase() + &quot;_&quot; + Convert.toString(spiderCounter);
+						if (lastImages != null) {
+							imageInfo = lastImages.needsSpidering(imgUrl, fileName + imgType);
 						}
+						if (imageInfo == null) {
+							imageInfo = new ImageInfo();
+							pref.log(&quot;[getImages] Loading image: &quot; + imgUrl + &quot; as &quot; + fileName + imgType);
+							spiderImage(imgUrl, fileName + imgType);
+							imageInfo.setFilename(fileName + imgType);
+							imageInfo.setURL(imgUrl);
+						} else {
+							pref.log(&quot;[getImages] Already exising image: &quot; + imgUrl + &quot; as &quot; + imageInfo.getFilename());
+						}
+						spideredUrls.add(imgUrl);
+						spiderCounter++;
+						imageInfo.setTitle(imgName);
+						imgCounter++;
+						chD.images.add(imageInfo);
 					}
-				} catch (IndexOutOfBoundsException e) {
-					pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 				}
+			} catch (final IndexOutOfBoundsException e) {
+				pref.log(&quot;[getImages] Problem loading image. imgURL:&quot; + imgUrl, e);
 			}
+
 		}
 	}
 
@@ -3004,45 +2975,14 @@
 	 * @param target
 	 *            The bytes of the image
 	 */
-	private void spiderImage(String imgUrl, String target) {
-		// TODO implement a fetch(URL, filename) in HttpConnection and use that one
-		HttpConnection connImg;
-		Socket sockImg;
-		// InputStream is;
-		FileOutputStream fos;
-		// int bytes_read;
-		// byte[] buffer = new byte[9000];
-		ByteArray daten;
-		String datei = &quot;&quot;;
-		datei = profile.dataDir + target;
-		connImg = new HttpConnection(imgUrl);
-		if (imgUrl.indexOf('%') &gt;= 0)
-			connImg.documentIsEncoded = true;
-		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-		// connImg.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12&quot;);
-		// connImg.setRequestorProperty(&quot;Accept&quot;,&quot;text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5&quot;);
+	private void spiderImage(String address, String fn) {
 		try {
-			pref.log(&quot;[spiderImage] Trying to fetch image from: &quot; + imgUrl);
-			String redirect = null;
-			do {
-				sockImg = connImg.connect();
-				redirect = connImg.getRedirectTo();
-				if (redirect != null) {
-					connImg = connImg.getRedirectedConnection(redirect);
-					pref.log(&quot;[spiderImage] Redirect to &quot; + redirect);
-				}
-			} while (redirect != null); 
-			// TODO this can end up in an endless loop if trying to load from a malicous site
-			daten = connImg.readData(sockImg);
-			fos = new FileOutputStream(new File(datei));
-			fos.write(daten.toBytes());
-			fos.close();
-			sockImg.close();
-		} catch (UnknownHostException e) {
+			UrlFetcher.fetchDataFile(address, profile.dataDir + fn);
+		} catch (final UnknownHostException e) {
 			pref.log(&quot;[spiderImage] Host not there...&quot;, e);
-		} catch (IOException ioex) {
+		} catch (final IOException ioex) {
 			pref.log(&quot;[spiderImage] File not found!&quot;, ioex);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[spiderImage] Some other problem while fetching image&quot;, ex);
 		} finally {
 			// Continue with the spider
@@ -3057,252 +2997,122 @@
 	 * @param wayPoint
 	 *            The name of the cache
 	 * @param is_found
-	 *            Found status of the cached (is inherited by the additional
-	 *            waypoints)
+	 *            Found status of the cached (is inherited by the additional waypoints)
 	 */
 	boolean koords_not_yet_found = true;
 
-	private void getAddWaypoints(String doc, String wayPoint, boolean is_found)
-			throws Exception {
-		Extractor exWayBlock = new Extractor(doc, 
-				p.getProp(&quot;wayBlockExStart&quot;),
-				p.getProp(&quot;wayBlockExEnd&quot;), 
-				0, false);
-		String wayBlock = &quot;&quot;;
-		String rowBlock = &quot;&quot;;
-		wayBlock = exWayBlock.findNext();
-		Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
-		Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
-		Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
-		Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
-		int counter = 0;
-		if (!exWayBlock.endOfSearch()
-				&amp;&amp; wayBlock.indexOf(&quot;No additional waypoints to display.&quot;) &lt; 0) {
-			Extractor exRowBlock = new Extractor(wayBlock, 
-					p.getProp(&quot;rowBlockExStart&quot;), 
-					p.getProp(&quot;rowBlockExEnd&quot;),
-					0, false);
-			rowBlock = exRowBlock.findNext();
-			rowBlock = exRowBlock.findNext();
-			while (!exRowBlock.endOfSearch()) {
-				CacheHolder hd = null;
+	private void getAddWaypoints(String doc, String wayPoint, boolean is_found) throws Exception {
+		final Extractor exWayBlock = new Extractor(doc, p.getProp(&quot;wayBlockExStart&quot;), p.getProp(&quot;wayBlockExEnd&quot;), 0, false);
+		String wayBlock;
+		if ((wayBlock = exWayBlock.findNext()).length() &gt; 0) {
+			if (wayBlock.indexOf(&quot;No additional waypoints to display.&quot;) &lt; 0) {
+				final Regex nameRex = new Regex(p.getProp(&quot;nameRex&quot;));
+				final Regex koordRex = new Regex(p.getProp(&quot;koordRex&quot;));
+				final Regex descRex = new Regex(p.getProp(&quot;descRex&quot;));
+				final Regex typeRex = new Regex(p.getProp(&quot;typeRex&quot;));
+				int counter = 0;
+				final Extractor exRowBlock = new Extractor(wayBlock, p.getProp(&quot;rowBlockExStart&quot;), p.getProp(&quot;rowBlockExEnd&quot;), 0, false);
+				String rowBlock;
+				rowBlock = exRowBlock.findNext();
+				while ((rowBlock = exRowBlock.findNext()).length() &gt; 0) {
+					CacheHolder hd = null;
 
-				/*
-				 * String[] AddiBlock=mString.split(rowBlock,'\n'); int
-				 * linePrefix=8; if(AddiBlock.length &lt; linePrefix + 1) { (new
-				 * MessageBox(MyLocale.getMsg(5500,&quot;Error&quot;),
-				 * &quot;GC changed table output \nCW must be changed too!&quot;,
-				 * FormBase.OKB)).execute(); break; } String
-				 * prefix=AddiBlock[linePrefix].trim();
-				 */
+					final Extractor exPrefix = new Extractor(rowBlock, p.getProp(&quot;prefixExStart&quot;), p.getProp(&quot;prefixExEnd&quot;), 0, true);
+					final String prefix = exPrefix.findNext();
+					String adWayPoint;
+					if (prefix.length() == 2)
+						adWayPoint = prefix + wayPoint.substring(2);
+					else
+						adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;) + wayPoint.substring(2);
+					counter++;
+					final int idx = profile.getCacheIndex(adWayPoint);
+					if (idx &gt;= 0) {
+						// Creating new CacheHolder, but accessing old cache.xml file
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+						// Accessing Details reads file if not yet done
+						hd.getCacheDetails(true);
+					} else {
+						hd = new CacheHolder();
+						hd.setWayPoint(adWayPoint);
+					}
+					hd.initStates(idx &lt; 0);
 
-				// Extractor exPrefix=new
-				// Extractor(AddiBlock[linePrefix].trim(),p.getProp(&quot;prefixExStart&quot;),p.getProp(&quot;prefixExEnd&quot;),0,true);
-				Extractor exPrefix = new Extractor(rowBlock, 
-						p.getProp(&quot;prefixExStart&quot;),
-						p.getProp(&quot;prefixExEnd&quot;), 
-						0, true);
-				String prefix = exPrefix.findNext();
+					nameRex.search(rowBlock);
+					if (nameRex.didMatch()) {
+						hd.setCacheName(nameRex.stringMatched(1));
+					} else {
+						pref.log(&quot;check nameRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					}
 
-				String adWayPoint;
-				if (prefix.length() == 2)
-					adWayPoint = prefix + wayPoint.substring(2);
-				else
-					adWayPoint = MyLocale.formatLong(counter, &quot;00&quot;)
-							+ wayPoint.substring(2);
-				counter++;
-				int idx = profile.getCacheIndex(adWayPoint);
-				if (idx &gt;= 0) {
-					// Creating new CacheHolder, but accessing old cache.xml
-					// file
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-					hd.getCacheDetails(true); // Accessing Details reads file if
-												// not yet done
-				} else {
-					hd = new CacheHolder();
-					hd.setWayPoint(adWayPoint);
-				}
-				hd.initStates(idx &lt; 0);
-				nameRex.search(rowBlock);
-				if (nameRex.didMatch()) {
-					hd.setCacheName(nameRex.stringMatched(1));
-				} else {
-					pref.log(&quot;check nameRex in spider.def&quot;
-							+ Preferences.NEWLINE + rowBlock);
-				}
-				koordRex.search(rowBlock);
-				typeRex.search(rowBlock);
-				if (koordRex.didMatch()) {
-					hd.setLatLon(koordRex.stringMatched(1));
-					koords_not_yet_found = false;
-				} else {
-					if (koords_not_yet_found)
-						pref.log(&quot;check koordRex in spider.def&quot;
-								+ Preferences.NEWLINE + rowBlock);
-				}
-				if (typeRex.didMatch()) {
-					hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot;
-							+ typeRex.stringMatched(1)));
-				} else {
-					pref.log(&quot;check typeRex in spider.def&quot;
-							+ Preferences.NEWLINE + rowBlock);
-				}
-				rowBlock = exRowBlock.findNext();
-				descRex.search(rowBlock);
-				if (descRex.didMatch()) {
-					hd.getCacheDetails(false).setLongDescription(
-							descRex.stringMatched(1).trim());
-				} else {
-					pref.log(&quot;check descRex in spider.def&quot;
-							+ Preferences.NEWLINE + rowBlock);
-				}
-				hd.setFound(is_found);
-				hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
-				hd.setHard(CacheTerrDiff.CW_DT_UNSET);
-				hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
-				if (idx &lt; 0) {
-					cacheDB.add(hd);
-					hd.save();
-				} else {
-					CacheHolder cx = cacheDB.get(idx);
-					boolean checked = cx.is_Checked;
-					cx.initStates(false);
-					cx.update(hd);
-					cx.is_Checked = checked;
-					cx.save();
-				}
-				rowBlock = exRowBlock.findNext();
+					koordRex.search(rowBlock);
+					if (koordRex.didMatch()) {
+						hd.setPos(new CWPoint(koordRex.stringMatched(1)));
+						koords_not_yet_found = false;
+					} else {
+						if (koords_not_yet_found) {
+							koords_not_yet_found = false;
+							pref.log(&quot;check koordRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+						}
+					}
 
+					typeRex.search(rowBlock);
+					if (typeRex.didMatch()) {
+						hd.setType(CacheType.gpxType2CwType(&quot;Waypoint|&quot; + typeRex.stringMatched(1)));
+					} else {
+						pref.log(&quot;check typeRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					}
+
+					rowBlock = exRowBlock.findNext();
+					descRex.search(rowBlock);
+					if (descRex.didMatch()) {
+						hd.getCacheDetails(false).setLongDescription(descRex.stringMatched(1).trim());
+					} else {
+						pref.log(&quot;check descRex in spider.def&quot; + Preferences.NEWLINE + rowBlock);
+					}
+					hd.setFound(is_found);
+					hd.setCacheSize(CacheSize.CW_SIZE_NOTCHOSEN);
+					hd.setHard(CacheTerrDiff.CW_DT_UNSET);
+					hd.setTerrain(CacheTerrDiff.CW_DT_UNSET);
+
+					if (idx &lt; 0) {
+						cacheDB.add(hd);
+						hd.save();
+					} else {
+						final CacheHolder cx = cacheDB.get(idx);
+						final boolean checked = cx.is_Checked;
+						cx.initStates(false);
+						cx.update(hd);
+						cx.is_Checked = checked;
+						cx.save();
+					}
+				}
 			}
 		}
 	}
 
-	public void getAttributes(String doc, CacheHolderDetail chD)
-			throws Exception {
-		Extractor attBlock = new Extractor(doc, p.getProp(&quot;attBlockExStart&quot;), 
-				p.getProp(&quot;attBlockExEnd&quot;), 0, true);
-		String atts = attBlock.findNext();
-		Extractor attEx = new Extractor(atts, p.getProp(&quot;attExStart&quot;), 
-				p.getProp(&quot;attExEnd&quot;), 0, true);
-		String attribute = attEx.findNext();
+	public void getAttributes(String doc, CacheHolderDetail chD) throws Exception {
+		final Extractor attBlock = new Extractor(doc, p.getProp(&quot;attBlockExStart&quot;), p.getProp(&quot;attBlockExEnd&quot;), 0, true);
+		final String atts = attBlock.findNext();
+		final Extractor attEx = new Extractor(atts, p.getProp(&quot;attExStart&quot;), p.getProp(&quot;attExEnd&quot;), 0, true);
+		String attribute;
 		chD.attributes.clear();
-		while (!attEx.endOfSearch()) {
+		while ((attribute = attEx.findNext()).length() &gt; 0) {
 			chD.attributes.add(attribute);
-			attribute = attEx.findNext();
 		}
 		chD.getParent().setAttribsAsBits(chD.attributes.getAttribsAsBits());
 	}
 
-	public static String fetchText(String address, boolean withResponseHeaders) {
-		ByteArray daten = fetch(address);
-		if (daten == null) return &quot;&quot;;
-		try {
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			CharArray c_data;
-			c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			if (withResponseHeaders)
-				return getResponseHeaders(conn) + c_data.toString();
-			else
-				return c_data.toString();
-		} catch (IOException e) {
-			pref.log(&quot;IOException in fetch&quot;, e);
-			return null;
-		}
-	}
-
-	/**
-	 * Performs an initial fetch to a given address. 
-	 */
-	private static ByteArray fetch(String address) {
-		try {
-			if (pref.myproxy.length() &gt; 0 &amp;&amp; pref.proxyActive) {
-				pref.log(&quot;[fetch]:Using proxy: &quot; + pref.myproxy + &quot; / &quot; + pref.myproxyport);
-			}
-			if (conn == null) { conn = new HttpConnection(address); }
-			else { conn.setUrl(address); }
-			conn.setRequestorProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-			if (cookieSession.length() &gt; 0) {conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot; + cookieSession + &quot;; userid=&quot; + cookieID);};
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			conn.documentIsEncoded = true;
-			conn.connect();
-			if (conn.isOpen()) {
-				pref.log(&quot;[fetch]:Connect ok! &quot; + address);
-				ByteArray daten = conn.readData();
-				conn.disconnect();
-				return daten;
-			}
-			pref.log(&quot;[fetch]:Connect not opened! &quot; + address, null);
-			return null;
-		} catch (IOException ioex) {
-			pref.log(&quot;IOException in fetch&quot;, ioex);
-			return null;
-		}
-	}
-
-	/**
-	 * After a fetch to gc.com the next fetches have to use the post method.
-	 * This method does exactly that. Actually this method is generic in the
-	 * sense that it can be used to post to a URL using http post.
-	 */
-	private static String fetch_post(String address, String postData, boolean withResponseHeaders) {
-		try {
-			HttpConnection conn = new HttpConnection(address);
-			JavaUtf8Codec codec = new JavaUtf8Codec();
-			conn.documentIsEncoded = true;
-			conn.setRequestorProperty(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-			conn.setPostData(codec.encodeText(postData.toCharArray(), 0, postData.length(), true, null));
-			conn.setRequestorProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
-			if (cookieSession.length() &gt; 0) { conn.setRequestorProperty(&quot;Cookie&quot;, &quot;ASP.NET_SessionId=&quot; + cookieSession + &quot;; userid=&quot; + cookieID);};
-			conn.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-			Socket sock = conn.connect();
-			pref.log(&quot;[fetch_post]:Connect ok! &quot; + address);
-			// ByteArray daten = conn.readData(sock);
-			CharArray c_data = conn.readText(sock, codec);
-			pref.log(&quot;[fetch_post]:Read data ok &quot; + address);
-			// CharArray c_data = codec.decodeText(daten.data, 0, daten.length, true, null);
-			sock.close();
-			if (withResponseHeaders)
-				return getResponseHeaders(conn) + c_data.toString();
-			else
-				return c_data.toString();
-		} catch (Exception e) {
-			pref.log(&quot;[fetch_post] Ignored Exception&quot;, e, true);
-		}
-		return &quot;&quot;;
-	}
-
-	private static String getResponseHeaders(HttpConnection conn) {
-		PropertyList pl = conn.documentProperties;
-		if (pl != null) {
-			StringBuffer sb = new StringBuffer(1000);
-			boolean gotany = false;
-
-			for (int i = 0; i &lt; pl.size(); i++) {
-				Property currProp = (Property) pl.get(i);
-				if (currProp.value != null) {
-					sb.append(currProp.name).append(&quot;: &quot;)
-							.append(currProp.value).append(&quot;\r\n&quot;);
-					gotany = true;
-				}
-			}
-			if (gotany)
-				return sb.toString() + &quot;\r\n&quot;;
-		}
-		return &quot;&quot;;
-	}
-
 	final static String hex = ewe.util.TextEncoder.hex;
 
 	public String encodeUTF8URL(byte[] what) {
-		int max = what.length;
-		char[] dest = new char[6 * max]; // Assume each char is a UTF char and
-											// encoded into 6 chars
+		final int max = what.length;
+		// Assume each char is a UTF char and encoded into 6 chars
+		final char[] dest = new char[6 * max];
 		char d = 0;
 		for (int i = 0; i &lt; max; i++) {
-			char c = (char) what[i];
-			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '='
-					|| c == '|' || c == '{' || c == '}' || c &gt; 0x7f) {
+			final char c = (char) what[i];
+			if (c &lt;= ' ' || c == '+' || c == '&amp;' || c == '%' || c == '=' || c == '|' || c == '{' || c == '}' || c &gt; 0x7f) {
 				dest[d++] = '%';
 				dest[d++] = hex.charAt((c &gt;&gt; 4) &amp; 0xf);
 				dest[d++] = hex.charAt(c &amp; 0xf);
@@ -3313,9 +3123,8 @@
 	}
 
 	/**
-	 * Load the bug id for a given name. This method is not ideal, as there are
-	 * sometimes several bugs with identical names but different IDs. Normally
-	 * the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
+	 * Load the bug id for a given name. This method is not ideal, as there are sometimes several bugs with identical
+	 * names but different IDs. Normally the bug GUID is used which can be obtained from the cache page.&lt;br&gt;
 	 * Note that each bug has both an ID and a GUID.
 	 * 
 	 * @param name
@@ -3326,42 +3135,33 @@
 		String bugList;
 		try {
 			// infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
-			bugList = fetchText(p.getProp(&quot;getBugByName&quot;) + STRreplace.replace(SafeXML.clean(name), &quot; &quot;, &quot;+&quot;), false);
+			bugList = UrlFetcher.fetch(p.getProp(&quot;getBugByName&quot;) + STRreplace.replace(SafeXML.clean(name), &quot; &quot;, &quot;+&quot;));
 			pref.log(&quot;[getBugId] Fetched bugId: &quot; + name);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugId] Could not fetch bug list&quot; + name, ex);
 			bugList = &quot;&quot;;
 		}
 		try {
-			if (bugList.equals(&quot;&quot;)
-					|| bugList.indexOf(p.getProp(&quot;bugNotFound&quot;)) &gt;= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), 
-						MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;),
-						FormBase.OKB)).execute();
+			if (bugList.equals(&quot;&quot;) || bugList.indexOf(p.getProp(&quot;bugNotFound&quot;)) &gt;= 0) {
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
 				return &quot;&quot;;
 			}
 			if (bugList.indexOf(p.getProp(&quot;bugTotalRecords&quot;)) &lt; 0) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(6021, &quot;More than one travelbug found. Specify name more precisely.&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(6021, &quot;More than one travelbug found. Specify name more precisely.&quot;), FormBase.OKB)).execute();
 				return &quot;&quot;;
 			}
-			Extractor exGuid = new Extractor(bugList, 
-					p.getProp(&quot;bugGuidExStart&quot;), 
-					p.getProp(&quot;bugGuidExEnd&quot;), 
-					0, Extractor.EXCLUDESTARTEND); 
+			final Extractor exGuid = new Extractor(bugList, p.getProp(&quot;bugGuidExStart&quot;), p.getProp(&quot;bugGuidExEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			// TODO Replace with spider.def
 			return exGuid.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugId] Error getting TB&quot;, ex);
 			return &quot;&quot;;
 		}
 	}
 
 	/**
-	 * Fetch a bug's mission for a given GUID or ID. If the guid String is
-	 * longer than 10 characters it is assumed to be a GUID, otherwise it is an
-	 * ID.
+	 * Fetch a bug's mission for a given GUID or ID. If the guid String is longer than 10 characters it is assumed to be
+	 * a GUID, otherwise it is an ID.
 	 * 
 	 * @param guid
 	 *            the guid or id of the travelbug
@@ -3372,27 +3172,22 @@
 		try {
 			// infB.setInfo(oldInfoBox+&quot;\nGetting bug: &quot;+bug);
 			if (guid.length() &gt; 10)
-				bugDetails = fetchText(p.getProp(&quot;getBugByGuid&quot;) + guid, false);
+				bugDetails = UrlFetcher.fetch(p.getProp(&quot;getBugByGuid&quot;) + guid);
 			else
-				bugDetails = fetchText(p.getProp(&quot;getBugById&quot;) + guid, false);
+				bugDetails = UrlFetcher.fetch(p.getProp(&quot;getBugById&quot;) + guid);
 			pref.log(&quot;[getBugMissionByGuid] Fetched TB detailsById: &quot; + guid);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByGuid] Could not fetch TB details &quot; + guid, ex);
 			bugDetails = &quot;&quot;;
 		}
 		try {
 			if (bugDetails.indexOf(p.getProp(&quot;bugNotFound&quot;)) &gt;= 0) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(6020, &quot;Travelbug not found.&quot;), FormBase.OKB)).execute();
 				return &quot;&quot;;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp(&quot;bugDetailsStart&quot;), 
-					p.getProp(&quot;bugDetailsEnd&quot;),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByGuid] Error getting TB &quot; + guid, ex);
 			return &quot;&quot;;
 		}
@@ -3408,9 +3203,9 @@
 	public String getBugMissionByTrackNr(String trackNr) {
 		String bugDetails;
 		try {
-			bugDetails = fetchText(p.getProp(&quot;getBugByTrackNr&quot;) + trackNr, false);
+			bugDetails = UrlFetcher.fetch(p.getProp(&quot;getBugByTrackNr&quot;) + trackNr);
 			pref.log(&quot;[getBugMissionByTrackNr] Fetched bug detailsByTrackNr: &quot; + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByTrackNr] getBugByTrackNr &quot; + trackNr, ex);
 			bugDetails = &quot;&quot;;
 		}
@@ -3422,12 +3217,9 @@
 				// MessageBox.OKB)).execute();
 				return &quot;&quot;;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp(&quot;bugDetailsStart&quot;), 
-					p.getProp(&quot;bugDetailsEnd&quot;),
-					0, Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			return exDetails.findNext();
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionByTrackNr] TB Details, bugNotFound &quot; + trackNr, ex);
 			return &quot;&quot;;
 		}
@@ -3442,11 +3234,11 @@
 	 */
 	public boolean getBugMissionAndNameByTrackNr(Travelbug TB) {
 		String bugDetails;
-		String trackNr = TB.getTrackingNo();
+		final String trackNr = TB.getTrackingNo();
 		try {
-			bugDetails = fetchText(p.getProp(&quot;getBugByTrackNr&quot;) + trackNr, false);
+			bugDetails = UrlFetcher.fetch(p.getProp(&quot;getBugByTrackNr&quot;) + trackNr);
 			pref.log(&quot;[getBugMissionAndNameByTrackNr] Fetched TB getBugByTrackNr: &quot; + trackNr);
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionAndNameByTrackNr] Could not fetch bug details: &quot; + trackNr, ex);
 			bugDetails = &quot;&quot;;
 		}
@@ -3458,16 +3250,12 @@
 				// MessageBox.OKB)).execute();
 				return false;
 			}
-			Extractor exDetails = new Extractor(bugDetails, 
-					p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exDetails = new Extractor(bugDetails, p.getProp(&quot;bugDetailsStart&quot;), p.getProp(&quot;bugDetailsEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			TB.setMission(exDetails.findNext());
-			Extractor exName = new Extractor(bugDetails, 
-					p.getProp(&quot;bugNameStart&quot;), p.getProp(&quot;bugNameEnd&quot;), 0,
-					Extractor.EXCLUDESTARTEND);
+			final Extractor exName = new Extractor(bugDetails, p.getProp(&quot;bugNameStart&quot;), p.getProp(&quot;bugNameEnd&quot;), 0, Extractor.EXCLUDESTARTEND);
 			TB.setName(exName.findNext());
 			return true;
-		} catch (Exception ex) {
+		} catch (final Exception ex) {
 			pref.log(&quot;[getBugMissionAndNameByTrackNr] TB Details, bugNotFound: &quot; + trackNr, ex);
 			return false;
 		}
@@ -3478,11 +3266,9 @@
 			super();
 			try {
 				load(new FileInputStream(FileBase.getProgramDirectory() + &quot;/spider.def&quot;));
-			} catch (Exception ex) {
+			} catch (final Exception ex) {
 				pref.log(&quot;Failed to load spider.def from &quot; + FileBase.getProgramDirectory(), ex);
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), 
-						MyLocale.getMsg(5504, &quot;Could not load 'spider.def'&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5504, &quot;Could not load 'spider.def'&quot;), FormBase.OKB)).execute();
 			}
 		}
 
@@ -3496,11 +3282,9 @@
 		 *             When a key is requested which doesn't exist
 		 */
 		public String getProp(String key) throws Exception {
-			String s = super.getProperty(key);
+			final String s = super.getProperty(key);
 			if (s == null) {
-				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;),
-						MyLocale.getMsg(5497, &quot;Error missing tag in spider.def&quot;)+ &quot;: &quot; + key,
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(5500, &quot;Error&quot;), MyLocale.getMsg(5497, &quot;Error missing tag in spider.def&quot;) + &quot;: &quot; + key, FormBase.OKB)).execute();
 				pref.log(&quot;Missing tag in spider.def: &quot; + key);
 				throw new Exception(&quot;Missing tag in spider.def: &quot; + key);
 			}
@@ -3534,25 +3318,32 @@
 				parse(r);
 				r.close();
 				rFIS.close();
-			} catch (Exception e) {
+			} catch (final Exception e) {
 			}
 			return _routePoints;
 		}
 
 		public void startElement(String name, AttributeList atts) {
-			if (name.equals(&quot;trkpt&quot;)|| name.equals(&quot;rtept&quot;)|| name.equals(&quot;gpxx:rpt&quot;)) {
-				double lat = Common.parseDouble(atts.getValue(&quot;lat&quot;));
-				double lon = Common.parseDouble(atts.getValue(&quot;lon&quot;));
-				TrackPoint tp = new TrackPoint(lat, lon);
+			if (name.equals(&quot;trkpt&quot;) || name.equals(&quot;rtept&quot;) || name.equals(&quot;gpxx:rpt&quot;)) {
+				final double lat = Common.parseDouble(atts.getValue(&quot;lat&quot;));
+				final double lon = Common.parseDouble(atts.getValue(&quot;lon&quot;));
+				final TrackPoint tp = new TrackPoint(lat, lon);
 				if (tp.isValid())
 					_routePoints.add(tp);
 				return;
 			}
+			if (name.equals(&quot;GeoPosition&quot;)) {
+				final double lat = Common.parseDouble(atts.getValue(&quot;Y&quot;));
+				final double lon = Common.parseDouble(atts.getValue(&quot;X&quot;));
+				final TrackPoint tp = new TrackPoint(lat, lon);
+				if (tp.isValid())
+					_routePoints.add(tp);
+				return;
+			}
 		}
 
 		public void endElement(String name) {
 
 		}
-
 	}
 }


Property changes on: branches/r1.2/src/CacheWolf/model
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/model/DefaultListModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/model/DefaultListModel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/model/DefaultListModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,49 @@
+package CacheWolf.model;
+
+import ewe.util.Vector;
+
+public  class DefaultListModel {
+
+	public Vector allItems;
+
+	public Vector shownItems = new Vector ();
+	public int sortCriteria;
+
+	public DefaultListModel() {
+		super();
+		allItems = new Vector ();
+		shownItems = new Vector();
+	}
+
+	/**
+	 * Creates the list of objects to be shown in the List. With this methode You can hide some objects.
+	 * Standardimplementation is to show all objects anytime. 
+	 *  
+	 */
+	public void createShowSet(){
+		shownItems.clear();
+		shownItems.addAll(allItems);
+	}
+	
+	/**
+	 * Adds an Object to this model to last position.
+	 * @param o
+	 */
+	public void add (Object o){
+		allItems.add(o);
+	}
+	
+	/**
+	 * Returns the number of elements in the showset of this model
+	 */
+	public int size(){
+		return shownItems.size();
+	}
+	
+	/**
+	 * Returns the Nth item in the showset of this model
+	 */
+	public Object get(int n){
+		return shownItems.get(n);
+	}
+}
\ No newline at end of file

Added: branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/model/TravelBugJourneyScreenModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,33 @@
+package CacheWolf.model;
+
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugJourneyList;
+import ewe.util.Vector;
+
+public class TravelBugJourneyScreenModel {
+
+	public CacheHolder actualCache;
+	public TravelbugJourneyList allTravelbugJourneys;
+	public Vector shownTravelbugJourneys = new Vector ();
+	public boolean onlyLogged;
+	public int sortCriteria;
+
+	public void toggleOnlyLogged() {
+		onlyLogged = !onlyLogged;
+		createShowSet();
+		Global.getPref().travelbugShowOnlyNonLogged = onlyLogged;
+		Global.getPref().savePreferences();
+	}
+
+	public void createShowSet() {
+		shownTravelbugJourneys.clear();
+		for (int i = 0; i &lt; allTravelbugJourneys.size(); i++) {
+			TravelbugJourney tbJourney = allTravelbugJourneys.getTBJourney(i);
+			if (!onlyLogged || (onlyLogged &amp;&amp; (!tbJourney.getFromLogged() || !tbJourney.getToLogged()))) {
+				shownTravelbugJourneys.add(tbJourney);
+			}
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/model/TravelbugScreenModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,8 @@
+package CacheWolf.model;
+
+public class TravelbugScreenModel extends DefaultListModel {
+
+	public void createShowSet() {
+	}
+
+}

Modified: branches/r1.2/src/CacheWolf/myTableControl.java
===================================================================
--- branches/r1.2/src/CacheWolf/myTableControl.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/myTableControl.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,30 +1,31 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
+import CacheWolf.exp.OCLogExport;
 import CacheWolf.utils.CWWrapper;
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.IconAndText;
@@ -52,15 +53,17 @@
 import ewe.ui.mList;
 
 /**
- *	Implements the user interaction of the list view. Works together with myTableModel and TablePanel
+ * Implements the user interaction of the list view. Works together with myTableModel and TablePanel
  */
-public class myTableControl extends TableControl{
+public class myTableControl extends TableControl {
 
 	public Preferences pref;
 	public Profile profile;
 	public CacheDB cacheDB;
 	public TablePanel tbp;
 
+	public int clickedColumn = 0;
+
 	private MenuItem miOpen, miGoto, miCenter, miUnhideAddis;
 	private MenuItem miOpenOnline, miOpenOffline, miLogOnline, miOpenGmaps;
 	private MenuItem miDelete, miUpdate, miChangeBlack;
@@ -71,47 +74,47 @@
 	private Menu mSmall;
 
 	myTableControl(TablePanel tablePanel) {
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		cacheDB = profile.cacheDB;
 		pref = Global.getPref();
-		tbp =tablePanel;
+		tbp = tablePanel;
 		allowDragSelection = false; // allow only one row to be selected at one time
-	MenuItem[] mnuFull = {
-			miOpen = new MenuItem(MyLocale.getMsg(1021,&quot;Open description&quot;)),
-			miGoto = new MenuItem(MyLocale.getMsg(1010,&quot;Goto&quot;)),
-		  	miCenter = new MenuItem(MyLocale.getMsg(1019,&quot;Center&quot;)),
-		  	miUnhideAddis = new MenuItem(MyLocale.getMsg(1042,&quot;Unhide Addis&quot;)),
-		  	miSeparator = new MenuItem(&quot;-&quot;),
-		  	miOpenOnline = new MenuItem(MyLocale.getMsg(1020,&quot;Open in $browser online&quot;)),
-		  	miOpenOffline = new MenuItem(MyLocale.getMsg(1018,&quot;Open in browser offline&quot;)),
-		  	miLogOnline = new MenuItem(MyLocale.getMsg(1052,&quot;Log online in Browser&quot;)),
-		  	miOpenGmaps = new MenuItem(MyLocale.getMsg(1053,&quot;Open in Google maps online&quot;)),
-		  	miSeparator,
-		  	miDelete = new MenuItem(MyLocale.getMsg(1012,&quot;Delete selected&quot;)),
-		  	miUpdate = new MenuItem(MyLocale.getMsg(1014,&quot;Update&quot;)),
-		  	miChangeBlack = new MenuItem(MyLocale.getMsg(1054, &quot;Change Blacklist&quot;)),
-		  	miSeparator,
-		  	miTickAll = new MenuItem(MyLocale.getMsg(1015,&quot;Select all&quot;)),
-		  	miUntickAll = new MenuItem(MyLocale.getMsg(1016,&quot;De-select all&quot;))
-	};
-  	mFull = new Menu(mnuFull, MyLocale.getMsg(1013,&quot;With selection&quot;));
-  	MenuItem[] mnuSmall = new MenuItem[8];
-  	mnuSmall[0] = miOpen;
-  	mnuSmall[1] = miGoto;
-  	mnuSmall[2] = miCenter;
-  	mnuSmall[3] = miUnhideAddis;
-  	mnuSmall[4] = miSeparator;
-  	mnuSmall[5] = miOpenOnline;
-  	mnuSmall[6] = miOpenOffline;
-  	mnuSmall[7] = miLogOnline;
-  	mSmall = new Menu(mnuSmall, MyLocale.getMsg(1013,&quot;With selection&quot;));
+		MenuItem[] mnuFull = { miOpen = new MenuItem(MyLocale.getMsg(1021, &quot;Open description&quot;)), //
+				miGoto = new MenuItem(MyLocale.getMsg(1010, &quot;Goto&quot;)), //
+				miCenter = new MenuItem(MyLocale.getMsg(1019, &quot;Center&quot;)), //
+				miUnhideAddis = new MenuItem(MyLocale.getMsg(1042, &quot;Unhide Addis&quot;)), //
+				miSeparator = new MenuItem(&quot;-&quot;), //
+				miOpenOnline = new MenuItem(MyLocale.getMsg(1020, &quot;Open in $browser online&quot;)), //
+				miOpenOffline = new MenuItem(MyLocale.getMsg(1018, &quot;Open in browser offline&quot;)), //
+				miLogOnline = new MenuItem(MyLocale.getMsg(1052, &quot;Log online in Browser&quot;)), //
+				miOpenGmaps = new MenuItem(MyLocale.getMsg(1053, &quot;Open in Google maps online&quot;)), //
+				miSeparator, //
+				miDelete = new MenuItem(MyLocale.getMsg(1012, &quot;Delete selected&quot;)), //
+				miUpdate = new MenuItem(MyLocale.getMsg(1014, &quot;Update&quot;)), //
+				miChangeBlack = new MenuItem(MyLocale.getMsg(1054, &quot;Change Blacklist&quot;)), //
+				miSeparator, //
+				miTickAll = new MenuItem(MyLocale.getMsg(1015, &quot;Select all&quot;)), //
+				miUntickAll = new MenuItem(MyLocale.getMsg(1016, &quot;De-select all&quot;)) //
+		};
+		mFull = new Menu(mnuFull, MyLocale.getMsg(1013, &quot;With selection&quot;));
+
+		MenuItem[] mnuSmall = new MenuItem[8];
+		mnuSmall[0] = miOpen;
+		mnuSmall[1] = miGoto;
+		mnuSmall[2] = miCenter;
+		mnuSmall[3] = miUnhideAddis;
+		mnuSmall[4] = miSeparator;
+		mnuSmall[5] = miOpenOnline;
+		mnuSmall[6] = miOpenOffline;
+		mnuSmall[7] = miLogOnline;
+		mSmall = new Menu(mnuSmall, MyLocale.getMsg(1013, &quot;With selection&quot;));
 	}
 
 	/** Full menu when listview includes checkbox */
 	public void setMenuFull() {
 		setMenu(mFull);
-//		if (!Vm.getPlatform().equals(&quot;Win32&quot;) &amp;&amp; !Vm.getPlatform().equals(&quot;Java&quot;))
-//		   ((MenuItem)mFull.items.get(5)).modifiers|=MenuItem.Disabled;
+		// if (!Vm.getPlatform().equals(&quot;Win32&quot;) &amp;&amp; !Vm.getPlatform().equals(&quot;Java&quot;))
+		// ((MenuItem)mFull.items.get(5)).modifiers|=MenuItem.Disabled;
 	}
 
 	public Menu getMenuFull() {
@@ -121,51 +124,60 @@
 	/** Small menu when listview does not include checkbox */
 	public void setMenuSmall() {
 		setMenu(mSmall);
-		//if (!Vm.getPlatform().equals(&quot;Win32&quot;) &amp;&amp; !Vm.getPlatform().equals(&quot;Java&quot;))
-		//	   ((MenuItem)mSmall.items.get(5)).modifiers|=MenuItem.Disabled;
+		// if (!Vm.getPlatform().equals(&quot;Win32&quot;) &amp;&amp; !Vm.getPlatform().equals(&quot;Java&quot;))
+		// ((MenuItem)mSmall.items.get(5)).modifiers|=MenuItem.Disabled;
 	}
 
-	public void penRightReleased(Point p){
-		if (cacheDB.size()&gt;0) { // No context menu when DB is empty
+	public void penRightReleased(Point p) {
+		if (cacheDB.size() &gt; 0) { // No context menu when DB is empty
 			adjustAddiHideUnhideMenu();
-			menuState.doShowMenu(p,true,null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
+			menuState.doShowMenu(p, true, null); // direct call (not through doMenu) is neccesary because it will exclude the whole table
 
 		}
 	}
 
-    public void penHeld(Point p){
-		if (cacheDB.size()&gt;0) // No context menu when DB is empty
+	public void penHeld(Point p) {
+		if (cacheDB.size() &gt; 0) // No context menu when DB is empty
 			adjustAddiHideUnhideMenu();
-			menuState.doShowMenu(p,true,null);
+		menuState.doShowMenu(p, true, null);
 	}
 
 	public void onKeyEvent(KeyEvent ev) {
-		if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this){
-			if ( (ev.modifiers &amp; IKeys.CONTROL) &gt; 0 &amp;&amp; ev.key == 1){ // &lt;ctrl-a&gt; gives 1, &lt;ctrl-b&gt; == 2
+		if (ev.type == KeyEvent.KEY_PRESS &amp;&amp; ev.target == this) {
+			if ((ev.modifiers &amp; IKeys.CONTROL) &gt; 0 &amp;&amp; ev.key == 1) { // &lt;ctrl-a&gt; gives 1, &lt;ctrl-b&gt; == 2
 				// select all on &lt;ctrl-a&gt;
 				setSelectForAll(true);
 				ev.consumed = true;
-			}
-			else  {
+			} else {
 				Global.mainTab.clearDetails();
-				if (ev.key == IKeys.HOME) Global.mainTab.tbP.selectRow(0); //  cursorTo(0,cursor.x+listMode,true);
-				else if (ev.key == IKeys.END) Global.mainTab.tbP.selectRow(model.numRows-1); //cursorTo(model.numRows-1,cursor.x+listMode,true);
-				else if (ev.key == IKeys.PAGE_DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1)); //cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
-				else if (ev.key == IKeys.PAGE_UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
-				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER) Global.mainTab.select(Global.mainTab.descP);
-				else if (ev.key == IKeys.DOWN) Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y+ 1, model.numRows-1));
-				else if (ev.key == IKeys.UP) Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y-1, 0));
-				else if (ev.key == IKeys.LEFT &amp;&amp; Global.mainForm.cacheListVisible &amp;&amp; cursor.y&gt;=0 &amp;&amp; cursor.y&lt;tbp.myMod.numRows) Global.mainForm.cacheList.addCache(cacheDB.get(cursor.y).getWayPoint());
+				if (ev.key == IKeys.HOME)
+					Global.mainTab.tbP.selectRow(0); // cursorTo(0,cursor.x+listMode,true);
+				else if (ev.key == IKeys.END)
+					Global.mainTab.tbP.selectRow(model.numRows - 1); // cursorTo(model.numRows-1,cursor.x+listMode,true);
+				else if (ev.key == IKeys.PAGE_DOWN)
+					Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y + getOnScreen(null).height - 1, model.numRows - 1)); // cursorTo(java.lang.Math.min(cursor.y+ getOnScreen(null).height-1, model.numRows-1),cursor.x+listMode,true); // I don't
+																																	// know why this doesn't work: tbp.doScroll(IScroll.Vertical, IScroll.PageHigher, 1);
+				else if (ev.key == IKeys.PAGE_UP)
+					Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y - getOnScreen(null).height + 1, 0)); // cursorTo(java.lang.Math.max(cursor.y-getOnScreen(null).height+1, 0),cursor.x+listMode,true);
+				else if (ev.key == IKeys.ACTION || ev.key == IKeys.ENTER)
+					Global.mainTab.select(Global.mainTab.descP);
+				else if (ev.key == IKeys.DOWN)
+					Global.mainTab.tbP.selectRow(java.lang.Math.min(cursor.y + 1, model.numRows - 1));
+				else if (ev.key == IKeys.UP)
+					Global.mainTab.tbP.selectRow(java.lang.Math.max(cursor.y - 1, 0));
+				else if (ev.key == IKeys.LEFT &amp;&amp; Global.mainForm.cacheListVisible &amp;&amp; cursor.y &gt;= 0 &amp;&amp; cursor.y &lt; tbp.myMod.numRows)
+					Global.mainForm.cacheList.addCache(cacheDB.get(cursor.y).getWayPoint());
 				else if (ev.key == IKeys.RIGHT) {
 					CacheHolder ch;
 					ch = cacheDB.get(tbp.getSelectedCache());
 					Global.mainTab.gotoP.setDestinationAndSwitch(ch);
-				}
-				else if (ev.key == 6 ) MainMenu.search(); // (char)6 == ctrl + f
-				else super.onKeyEvent(ev);
+				} else if (ev.key == 6)
+					MainMenu.search(); // (char)6 == ctrl + f
+				else
+					super.onKeyEvent(ev);
 			}
-		}
-		else super.onKeyEvent(ev);
+		} else
+			super.onKeyEvent(ev);
 	}
 
 	/** Set all caches either as selected or as deselected, depending on argument */
@@ -174,48 +186,49 @@
 		tbp.refreshTable();
 	}
 
-
 	/** always select a whole row */
-	public boolean isSelected(int pRow,int pCol) {
-		return pRow==selection.y;
+	public boolean isSelected(int pRow, int pCol) {
+		return pRow == selection.y;
 	}
+
 	private void callExternalProgram(String program, String parameter) {
 		// invalid path will be handled by try
 		try {
 			CWWrapper.exec(program, parameter); // maybe this works on some PDAs?
 		} catch (IOException ex) {
-			(new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),
-					MyLocale.getMsg(1034,&quot;Cannot start &quot;+program+&quot;!&quot;) + &quot;\n&quot; + ex.toString() + &quot;\n&quot; +
-					MyLocale.getMsg(1035,&quot;Possible reason:&quot;) + &quot;\n&quot; +
-					MyLocale.getMsg(1036,&quot;A bug in ewe VM, please be&quot;) + &quot;\n&quot; +
-					MyLocale.getMsg(1037,&quot;patient for an update&quot;),FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1034, &quot;Cannot start &quot; + program + &quot;!&quot;) + &quot;\n&quot; + ex.toString() + &quot;\n&quot; + MyLocale.getMsg(1035, &quot;Possible reason:&quot;) + &quot;\n&quot; + MyLocale.getMsg(1036, &quot;A bug in ewe VM, please be&quot;)
+					+ &quot;\n&quot; + MyLocale.getMsg(1037, &quot;patient for an update&quot;), FormBase.OKB)).execute();
 		}
 	}
 
-	public void popupMenuEvent(Object selectedItem){
-		if (selectedItem == null) return;
+	public void popupMenuEvent(Object selectedItem) {
+		String url;
+		CacheHolder mainCache;
+		CacheHolderDetail chD;
+		if (selectedItem == null)
+			return;
 		CacheHolder ch;
-		if (selectedItem == miTickAll){
+		if (selectedItem == miTickAll) {
 			setSelectForAll(true);
 		} else
 
-		if (selectedItem == miUntickAll){
+		if (selectedItem == miUntickAll) {
 			setSelectForAll(false);
 		} else
 
-		if (selectedItem == miDelete){
+		if (selectedItem == miDelete) {
 			Vm.showWait(true);
 			// Count # of caches to delete
-			int allCount=0;
-			int mainNonVisibleCount=0;
-			int addiNonVisibleCount=0;
-			int shouldDeleteCount=0;
-			boolean deleteFiltered=true;  // Bisheriges Verhalten
-			for(int i = cacheDB.size()-1; i &gt;=0; i--){
+			int allCount = 0;
+			int mainNonVisibleCount = 0;
+			int addiNonVisibleCount = 0;
+			int shouldDeleteCount = 0;
+			boolean deleteFiltered = true; // Bisheriges Verhalten
+			for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 				CacheHolder currCache = cacheDB.get(i);
-				if ( currCache.is_Checked) {
+				if (currCache.is_Checked) {
 					allCount++;
-					if (! currCache.isVisible()) {
+					if (!currCache.isVisible()) {
 						if (currCache.isAddiWpt()) {
 							addiNonVisibleCount++;
 						} else {
@@ -226,62 +239,61 @@
 			}
 			// Warn if there are ticked but invisible caches - and ask if they should be deleted too.
 			shouldDeleteCount = allCount;
-			if (addiNonVisibleCount + mainNonVisibleCount &gt; 0){
-				if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),
-						            MyLocale.getMsg(1029, &quot;There are caches that are ticked but invisible.\n(Main caches: &quot;) +
-						            	mainNonVisibleCount + MyLocale.getMsg(1030, &quot;, additional Waypoints: &quot;) +
-						            	addiNonVisibleCount+&quot;)\n&quot; + MyLocale.getMsg(1031, &quot;Delete them, too?&quot;),
-						            	FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+			if (addiNonVisibleCount + mainNonVisibleCount &gt; 0) {
+				if ((new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(1029, &quot;There are caches that are ticked but invisible.\n(Main caches: &quot;) + mainNonVisibleCount + MyLocale.getMsg(1030, &quot;, additional Waypoints: &quot;) + addiNonVisibleCount
+						+ &quot;)\n&quot; + MyLocale.getMsg(1031, &quot;Delete them, too?&quot;), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
 					deleteFiltered = true;
 				} else {
 					deleteFiltered = false;
 					shouldDeleteCount = allCount - mainNonVisibleCount - addiNonVisibleCount;
 				}
 			}
-			if (shouldDeleteCount&gt;0) {
-				if ((new MessageBox(MyLocale.getMsg(144,&quot;Warning&quot;),MyLocale.getMsg(1022, &quot;Delete selected caches (&quot;) + shouldDeleteCount + MyLocale.getMsg(1028, &quot;) ?&quot;), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
-					DataMover dm=new DataMover();
+			if (shouldDeleteCount &gt; 0) {
+				if ((new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(1022, &quot;Delete selected caches (&quot;) + shouldDeleteCount + MyLocale.getMsg(1028, &quot;) ?&quot;), FormBase.YESB | FormBase.NOB)).execute() == FormBase.IDYES) {
+					DataMover dm = new DataMover();
 					myProgressBarForm pbf = new myProgressBarForm();
 					Handle h = new Handle();
-					int nDeleted=0;
-					int size=cacheDB.size();
-					pbf.setTask(h,&quot;Be patient. Reading directory&quot;);
+					int nDeleted = 0;
+					int size = cacheDB.size();
+					pbf.setTask(h, &quot;Be patient. Reading directory&quot;);
 					pbf.exec();
-					h.progress = (float)0.5;
+					h.progress = (float) 0.5;
 					h.changed();
-					String[] CacheFiles = new FileBugfix(profile.dataDir).list(null, FileBase.LIST_FILES_ONLY|FileBase.LIST_DONT_SORT);
-					pbf.setTask(h,MyLocale.getMsg(1012, &quot;Delete selected&quot;));
-					for(int i = size-1; i &gt;=0; i--){// Start Counting down, as the size decreases with each deleted cache
+					String[] CacheFiles = new FileBugfix(profile.dataDir).list(null, FileBase.LIST_FILES_ONLY | FileBase.LIST_DONT_SORT);
+					pbf.setTask(h, MyLocale.getMsg(1012, &quot;Delete selected&quot;));
+					for (int i = size - 1; i &gt;= 0; i--) {// Start Counting down, as the size decreases with each deleted cache
 						ch = cacheDB.get(i);
-						if(ch.is_Checked &amp;&amp; (ch.isVisible() || deleteFiltered)) {
+						if (ch.is_Checked &amp;&amp; (ch.isVisible() || deleteFiltered)) {
 							nDeleted++;
-							h.progress = ((float)nDeleted)/(float)allCount;
+							h.progress = ((float) nDeleted) / (float) allCount;
 							h.changed();
 							cacheDB.removeElementAt(i);
-							dm.deleteCacheFiles(ch.getWayPoint(),profile.dataDir,CacheFiles);
-							ch=null;
-							if (pbf.isClosed) break;
+							dm.deleteCacheFiles(ch.getWayPoint(), profile.dataDir, CacheFiles);
+							ch = null;
+							if (pbf.isClosed)
+								break;
 						}
 					}
 					pbf.exit(0);
-					tbp.myMod.numRows-=nDeleted;
-					profile.saveIndex(pref,true);
+					tbp.myMod.numRows -= nDeleted;
+					profile.saveIndex(pref, true);
 					tbp.refreshTable();
 				}
 			}
 			Vm.showWait(false);
 		} else
 
-		if (selectedItem == miUpdate){
+		if (selectedItem == miUpdate) {
 			MainMenu.updateSelectedCaches(tbp);
+			pref.setOldGCLanguage();
 		} else
-		
-		if (selectedItem == miChangeBlack){
+
+		if (selectedItem == miChangeBlack) {
 			Vm.showWait(true);
 			try {
-				for(int i = cacheDB.size()-1; i &gt;=0; i--){
+				for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 					CacheHolder currCache = cacheDB.get(i);
-					if ( currCache.isVisible() &amp;&amp; currCache.is_Checked) {
+					if (currCache.isVisible() &amp;&amp; currCache.is_Checked) {
 						if (currCache.isAddiWpt()) {
 							// currCache.setBlack(!currCache.is_black());
 						} else {
@@ -295,18 +307,19 @@
 				tbp.refreshTable();
 			} finally {
 				Vm.showWait(false);
-			};
+			}
+			;
 		} else
 
-		if (selectedItem == miCenter){
+		if (selectedItem == miCenter) {
 			if (tbp.getSelectedCache() &lt; 0) {
 				Global.getPref().log(&quot;[myTableControl:popupMenuEvent] getSelectedCache() &lt; 0&quot;);
 				return;
 			}
 			CacheHolder thisCache = cacheDB.get(tbp.getSelectedCache());
-			CWPoint cp=new CWPoint(thisCache.getLatLon());
-			if (!cp.isValid()){
-				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(4111,&quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
+			CWPoint cp = new CWPoint(thisCache.getPos());
+			if (!cp.isValid()) {
+				MessageBox tmpMB = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(4111, &quot;Coordinates must be entered in the format N DD MM.MMM E DDD MM.MMM&quot;), FormBase.OKB);
 				tmpMB.execute();
 			} else {
 				pref.setCurCentrePt(cp);
@@ -317,79 +330,120 @@
 			// This toggles the &quot;showAddis&quot; Flag
 			ch = cacheDB.get(tbp.getSelectedCache());
 			ch.setShowAddis(!ch.showAddis());
-			if (ch.addiWpts.size()&gt;0) {
+			if (ch.addiWpts.size() &gt; 0) {
 				tbp.refreshTable();
 			} else {
 				// This should never occur, as we check prior to activating the menu if the
 				// cache has addis. But just in case...
-				new MessageBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(1043, &quot;This cache has no additional waypoints.&quot;),FormBase.OKB).execute();
+				new MessageBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(1043, &quot;This cache has no additional waypoints.&quot;), FormBase.OKB).execute();
 			}
 		} else
 
-		if (selectedItem == miGoto){
+		if (selectedItem == miGoto) {
 			ch = cacheDB.get(tbp.getSelectedCache());
 			Global.mainTab.gotoP.setDestinationAndSwitch(ch);
 		} else
 
-		if (selectedItem == miOpenOnline){
-				ch = cacheDB.get(tbp.getSelectedCache());
-				CacheHolderDetail chD=ch.getCacheDetails(true);
-				if (chD != null) { callExternalProgram(pref.browser, chD.URL); }
+		if (selectedItem == miOpenOnline) {
+			ch = cacheDB.get(tbp.getSelectedCache());
+			mainCache = ch;
+			if (ch.isAddiWpt() &amp;&amp; (ch.mainCache != null)) {
+				mainCache = ch.mainCache;
+			}
+			chD = mainCache.getCacheDetails(true);
+			url = chD.URL;
+			String wpName = mainCache.getOcCacheID();
+			if (clickedColumn == 14) {
+				if (mainCache.isOC()) {
+					String s = OC.getGCWayPoint(ch.getCacheOwner());
+					if (s.length() &gt; 0)
+						url = &quot;<A HREF="http://www.geocaching.com/seek/cache_details.aspx?wp=">http://www.geocaching.com/seek/cache_details.aspx?wp=</A>&quot; + s;
+				} else {
+					if (wpName.length() &gt; 0) {
+						if (wpName.charAt(0) &lt; 65)
+							wpName = mainCache.getOcCacheID().substring(1);
+						url = &quot;<A HREF="http://">http://</A>&quot; + OC.getOCHostName(wpName) + &quot;/viewcache.php?wp=&quot; + wpName;
+					}
+				}
+			}
+			if (url != null) {
+				callExternalProgram(pref.browser, url);
+			}
 		} else
 
 		if (selectedItem == miOpenGmaps) {
 			ch = cacheDB.get(tbp.getSelectedCache());
-			if (ch.pos.isValid()) {
-				String lat=&quot;&quot;+ch.pos.getLatDeg(CWPoint.DD);
-				String lon=&quot;&quot;+ch.pos.getLonDeg(CWPoint.DD);
-				String nameOfCache=ewe.net.URL.encodeURL(ch.cacheName,false).replace('#','N').replace('@','_');
-				String language=Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
-				if (!pref.language.equalsIgnoreCase(&quot;auto&quot;)) {language=pref.language;}
-				String url=&quot;<A HREF="http://maps.google.">http://maps.google.</A>&quot;+language+&quot;/maps?q=&quot;+nameOfCache+&quot;@&quot;+lat+&quot;,&quot;+lon;
+			if (ch.getPos().isValid()) {
+				String lat = &quot;&quot; + ch.getPos().getLatDeg(CWPoint.DD);
+				String lon = &quot;&quot; + ch.getPos().getLonDeg(CWPoint.DD);
+				String nameOfCache = UrlFetcher.encodeURL(ch.getCacheName(), false).replace('#', 'N').replace('@', '_');
+				String language = Vm.getLocale().getString(Locale.LANGUAGE_SHORT, 0, 0);
+				if (!pref.language.equalsIgnoreCase(&quot;auto&quot;)) {
+					language = pref.language;
+				}
+				url = &quot;<A HREF="http://maps.google.">http://maps.google.</A>&quot; + language + &quot;/maps?q=&quot; + nameOfCache + &quot;@&quot; + lat + &quot;,&quot; + lon;
 				callExternalProgram(pref.browser, url);
-				url=&quot;<A HREF="http://www.geocaching.com/map/default.aspx?lat=">http://www.geocaching.com/map/default.aspx?lat=</A>&quot;+lat+&quot;&amp;lng=&quot;+lon;
+				url = &quot;<A HREF="http://www.geocaching.com/map/default.aspx?lat=">http://www.geocaching.com/map/default.aspx?lat=</A>&quot; + lat + &quot;&amp;lng=&quot; + lon;
 				callExternalProgram(pref.browser, url);
 			}
 		} else
 
 		if (selectedItem == miOpenOffline) {
-			ShowCacheInBrowser sc=new ShowCacheInBrowser();
+			ShowCacheInBrowser sc = new ShowCacheInBrowser();
 			sc.showCache(cacheDB.get(tbp.getSelectedCache()));
 		} else
 
-		if (selectedItem == miLogOnline){
-				ch = cacheDB.get(tbp.getSelectedCache());
-				CacheHolder mainCache = ch;
-				if (ch.isAddiWpt() &amp;&amp; (ch.mainCache != null)) {
-					mainCache = ch.mainCache;
-				}
-				if (mainCache.isCacheWpt()) {
-					CacheHolderDetail chD=mainCache.getCacheDetails(true);
-						if (chD != null) {
-							String URL = &quot;&quot;;
-							if (ch.isOC()) {
-								URL = chD.URL;
-								if (URL.indexOf(&quot;viewcache&quot;) &gt;= 0) {
-									URL = STRreplace.replace(URL, &quot;viewcache&quot;, &quot;log&quot;);
+		if (selectedItem == miLogOnline) {
+			ch = cacheDB.get(tbp.getSelectedCache());
+			mainCache = ch;
+			url = &quot;&quot;;
+			if (ch.isAddiWpt() &amp;&amp; (ch.mainCache != null)) {
+				mainCache = ch.mainCache;
+			}
+			if (mainCache.isCacheWpt()) {
+				chD = mainCache.getCacheDetails(false);
+				if (chD != null) {
+					String notes = chD.getCacheNotes();
+					if (notes.length() &gt; 0) {
+						Vm.setClipboardText(mainCache.getCacheStatus() + '\n' + &quot;&lt;br&gt;&quot; + notes);
+					}
+					if (mainCache.isOC()) {
+						url = chD.URL;
+						if (url.indexOf(&quot;viewcache&quot;) &gt;= 0) {
+							url = STRreplace.replace(url, &quot;viewcache&quot;, &quot;log&quot;);
+						}
+					} else {
+						if (chD.OwnLogId.length() &gt; 0) {
+							String wpName = mainCache.getOcCacheID();
+							if (wpName.length() &gt; 0 &amp;&amp; wpName.charAt(0) &lt; 65) {
+								// OC log (already logged at GC but not at OC)
+								if (clickedColumn == 14) {
+									OCLogExport.doOneLog(mainCache);
+									tbp.refreshTable();
 								} else {
-									URL = &quot;&quot;;
+									// open OC logpage with GC Logtext in Clipboard
+									Vm.setClipboardText(chD.OwnLog.getDate() + '\n' + &quot;&lt;br&gt;&quot; + chD.OwnLog.getMessage());
+									if (wpName.length() &gt; 1) {
+										if (wpName.charAt(0) &lt; 65) {
+											wpName = mainCache.getOcCacheID().substring(1);
+										}
+										url = &quot;<A HREF="http://">http://</A>&quot; + OC.getOCHostName(wpName) + &quot;/log.php?wp=&quot; + wpName;
+									}
 								}
-							} else {
-								URL = &quot;<A HREF="http://www.geocaching.com/seek/log.aspx?ID=">http://www.geocaching.com/seek/log.aspx?ID=</A>&quot; + mainCache.GetCacheID();
 							}
+						} else
+							// GC log
+							url = &quot;<A HREF="http://www.geocaching.com/seek/log.aspx?ID=">http://www.geocaching.com/seek/log.aspx?ID=</A>&quot; + mainCache.GetCacheID();
+					}
 
-							if (URL.length() &gt; 0) {
-								String notes = chD.getCacheNotes();
-								if (notes.length() &gt; 0) {
-									Vm.setClipboardText(notes);
-								}
-								callExternalProgram(pref.browser, URL);
-							}
-						}
+					if (url.length() &gt; 0) {
+						callExternalProgram(pref.browser, url);
+					}
 				}
+			}
 		} else
 
-		if (selectedItem == miOpen){
+		if (selectedItem == miOpen) {
 			penDoubleClicked(null);
 		}
 
@@ -400,18 +454,16 @@
 	}
 
 	public void onEvent(Event ev) {
-		if (ev instanceof PenEvent &amp;&amp; (ev.type == PenEvent.PEN_DOWN) ){
-			Global.mainTab.tbP.myMod.penEventModifiers=((PenEvent)ev).modifiers;
-	    }
+		if (ev instanceof PenEvent &amp;&amp; (ev.type == PenEvent.PEN_DOWN)) {
+			Global.mainTab.tbP.myMod.penEventModifiers = ((PenEvent) ev).modifiers;
+		}
 
 		super.onEvent(ev);
 	}
 
 	/**
-	 * Adjusting the menu item for hiding or unhiding additional waypoints. If the cache has no
-	 * addis, then the menu is deactivated. If it has addis, then the menu text is adapted according
-	 * to the current value of the property &lt;code&gt;showAddis()&lt;/code&gt;.
-	 *
+	 * Adjusting the menu item for hiding or unhiding additional waypoints. If the cache has no addis, then the menu is deactivated. If it has addis, then the menu text is adapted according to the current value of the property &lt;code&gt;showAddis()&lt;/code&gt;.
+	 * 
 	 */
 	public void adjustAddiHideUnhideMenu() {
 		if (tbp.getSelectedCache() &lt; 0) {
@@ -437,97 +489,103 @@
 
 	// /////////////////////////////////////////////////
 	// Allow the caches to be dragged into a cachelist
-    ///////////////////////////////////////////////////
+	// /////////////////////////////////////////////////
 
 	IconAndText imgDrag;
 	String wayPoint;
 	int row;
 
 	public void startDragging(DragContext dc) {
-		 Point p=cellAtPoint(dc.start.x,dc.start.y,null);
-		 if (p==null) {super.startDragging(dc); return;}
-		 wayPoint=null;
-		 if (p.y&gt;=0) {
+		Point p = cellAtPoint(dc.start.x, dc.start.y, null);
+		if (p == null) {
+			super.startDragging(dc);
+			return;
+		}
+		wayPoint = null;
+		if (p.y &gt;= 0) {
 			if (!Global.mainForm.cacheListVisible) {
-				dc.cancelled=true;
+				dc.cancelled = true;
 				return;
 			}
-			 row=p.y;
-			 CacheHolder ch=cacheDB.get(p.y);
-			 wayPoint=ch.getWayPoint();
-			 imgDrag=new IconAndText();
-			 imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
-			 imgDrag.addColumn(ch.getWayPoint());
-			 dc.dragData=dc.startImageDrag(imgDrag,new Point(8,8),this);
-		 } else super.startDragging(dc);
-	 }
+			row = p.y;
+			CacheHolder ch = cacheDB.get(p.y);
+			wayPoint = ch.getWayPoint();
+			imgDrag = new IconAndText();
+			imgDrag.addColumn(CacheType.getTypeImage(ch.getType()));
+			imgDrag.addColumn(ch.getWayPoint());
+			dc.dragData = dc.startImageDrag(imgDrag, new Point(8, 8), this);
+		} else
+			super.startDragging(dc);
+	}
 
-	 public void stopDragging(DragContext dc) {
-		 if (wayPoint!=null &amp;&amp; !dc.cancelled) {
-			 dc.stopImageDrag(true);
-			 Point p = Gui.getPosInParent(this,getWindow());
-			 p.x += dc.curPoint.x;
-			 p.y += dc.curPoint.y;
-			 Control c = getWindow().findChild(p.x,p.y);
-		     if (c instanceof mList &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
-		    	 if (Global.mainForm.cacheList.addCache(wayPoint)) {
-		    		 c.repaintNow();
-		    		 ((mList) c).makeItemVisible(((mList)c).itemsSize()-1);
-		    	 }
-		     }
-		     Global.mainTab.tbP.selectRow(row);
-		 }else super.stopDragging(dc);
-	 }
+	public void stopDragging(DragContext dc) {
+		if (wayPoint != null &amp;&amp; !dc.cancelled) {
+			dc.stopImageDrag(true);
+			Point p = Gui.getPosInParent(this, getWindow());
+			p.x += dc.curPoint.x;
+			p.y += dc.curPoint.y;
+			Control c = getWindow().findChild(p.x, p.y);
+			if (c instanceof mList &amp;&amp; c.text.equals(&quot;CacheList&quot;)) {
+				if (Global.mainForm.cacheList.addCache(wayPoint)) {
+					c.repaintNow();
+					((mList) c).makeItemVisible(((mList) c).itemsSize() - 1);
+				}
+			}
+			Global.mainTab.tbP.selectRow(row);
+		} else
+			super.stopDragging(dc);
+	}
 
-	 public void dragged(DragContext dc) {
-	 	if (wayPoint!=null)
-		   dc.imageDrag();
-	 	else
-	 		super.dragged(dc);
-	 }
+	public void dragged(DragContext dc) {
+		if (wayPoint != null)
+			dc.imageDrag();
+		else
+			super.dragged(dc);
+	}
 
-	 public void cursorTo(int pRow,int pCol,boolean selectNew) {
-		if (pRow != -2 &amp;&amp; pCol != -2 &amp;&amp; !canSelect(pRow,pCol)) return;
-		cursor.set(pCol,pRow);
-		if (selectNew){
+	public void cursorTo(int pRow, int pCol, boolean selectNew) {
+		if (pRow != -2 &amp;&amp; pCol != -2 &amp;&amp; !canSelect(pRow, pCol))
+			return;
+		cursor.set(pCol, pRow);
+		if (selectNew) {
 			clearSelectedCells(oldExtendedSelection);
-			paintCells(null,oldExtendedSelection);
-			if (pRow != -2 &amp;&amp; pCol != -2){
-				if (scrollToVisible(pRow,pCol)) repaintNow();
-				addToSelection(Rect.buff.set(0,pRow,model.numCols,1),true);
-				//fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
+			paintCells(null, oldExtendedSelection);
+			if (pRow != -2 &amp;&amp; pCol != -2) {
+				if (scrollToVisible(pRow, pCol))
+					repaintNow();
+				addToSelection(Rect.buff.set(0, pRow, model.numCols, 1), true);
+				// fireSelectionEvent(TableEvent.FLAG_SELECTED_BY_ARROWKEY);
 				clickedFlags = TableEvent.FLAG_SELECTED_BY_ARROWKEY;
-				if (clickMode) clicked(pRow,pCol);
+				if (clickMode)
+					clicked(pRow, pCol);
 				clickedFlags = 0;
 			}
 		}
-	 }
+	}
 
-	 /**
-	  * this is only necessary to hinder the user to unselect
-	  */
-	 public void penReleased(Point p,boolean isDouble)
-	 {
-		 Point p2 = cellAtPoint(p.x,p.y,null);
-		 super.penReleased(p, isDouble);
-		 Rect sel = getSelection(null);
-		 if ((sel.height == 0 || sel.height == 0) &amp;&amp; p2 != null) cursorTo(p2.y,p2.x, true); // if the selection is gone -&gt; reselect it
+	/**
+	 * this is only necessary to hinder the user to unselect
+	 */
+	public void penReleased(Point p, boolean isDouble) {
+		Point p2 = cellAtPoint(p.x, p.y, null);
+		super.penReleased(p, isDouble);
+		Rect sel = getSelection(null);
+		if ((sel.height == 0 || sel.height == 0) &amp;&amp; p2 != null)
+			cursorTo(p2.y, p2.x, true); // if the selection is gone -&gt; reselect it
 
-	 }
+	}
 
-	 class myProgressBarForm extends ProgressBarForm {
+	class myProgressBarForm extends ProgressBarForm {
 
-		 boolean isClosed=false;
+		boolean isClosed = false;
 
-		 protected boolean canExit(int exitCode) {
-			isClosed=true;
+		protected boolean canExit(int exitCode) {
+			isClosed = true;
 			return true;
-		 }
+		}
 
-	 }
+	}
 
-
-
 	public Menu getMenuSmall() {
 		return mSmall;
 	}

Modified: branches/r1.2/src/CacheWolf/myTableModel.java
===================================================================
--- branches/r1.2/src/CacheWolf/myTableModel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/myTableModel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf;
 
 import ewe.fx.Color;
@@ -31,7 +31,6 @@
 import ewe.fx.Image;
 import ewe.fx.Point;
 import ewe.fx.mImage;
-import ewe.sys.Convert;
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
@@ -41,9 +40,7 @@
 import ewe.util.Vector;
 
 /**
- * Table model used to display the cache list. Used by the table control in the
- * first panel of CacheWolf. 20061212 salzkammergut, patch to speed up
- * scrolling, Used MyLocale
+ * Table model used to display the cache list. Used by the table control in the first panel of CacheWolf. 20061212 salzkammergut, patch to speed up scrolling, Used MyLocale
  */
 public class myTableModel extends TableModel {
 
@@ -66,30 +63,17 @@
 	/** The max number of columns in the list view */
 	public static final int N_COLUMNS = 20;
 	/**
-	 * How the columns are mapped onto the list view. If colMap[i]=j, it means
-	 * that the element j (as per the list below) is visible in column i.
-	 * [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name,
-	 * [6]coordinates, [7]owner, [8]datehidden, [9]status, [10]distance,
-	 * [11]bearing, [12] Size, [13] # of OC recommend. [14] OC index, [15]
-	 * Solver exists, [16] Note exists, [17] # Additionals, [18] # DNF [19] Last
-	 * Sync Date
+	 * How the columns are mapped onto the list view. If colMap[i]=j, it means that the element j (as per the list below) is visible in column i. [0]TickBox, [1]Type, [2]Distance, [3]Terrain, [4]waypoint, [5]name, [6]coordinates, [7]owner, [8]datehidden,
+	 * [9]status, [10]distance, [11]bearing, [12] Size, [13] # of OC recommend. [14] OC index, [15] Solver exists, [16] Note exists, [17] # Additionals, [18] # DNF [19] Last Sync Date
 	 * 
-	 * Attention: When adding columns here, also add a default width in
-	 * Preferences.listColWidth
+	 * Attention: When adding columns here, also add a default width in Preferences.listColWidth
 	 */
 	private int[] colMap;
 	/** The column widths corresponding to the list of columns above */
 	private int[] colWidth;
-	private String[] colName = { &quot; &quot;, &quot;?&quot;, MyLocale.getMsg(1000, &quot;D&quot;),
-			MyLocale.getMsg(1001, &quot;T&quot;), MyLocale.getMsg(1002, &quot;Waypoint&quot;),
-			&quot;Name&quot;, MyLocale.getMsg(1004, &quot;Location&quot;),
-			MyLocale.getMsg(1005, &quot;Owner&quot;), MyLocale.getMsg(1006, &quot;Hidden&quot;),
-			MyLocale.getMsg(1007, &quot;Status&quot;), MyLocale.getMsg(1008, &quot;Dist&quot;),
-			MyLocale.getMsg(1009, &quot;Bear&quot;), MyLocale.getMsg(1017, &quot;S&quot;),
-			MyLocale.getMsg(1026, &quot;#Rec&quot;), MyLocale.getMsg(1027, &quot;OC-IDX&quot;),
-			MyLocale.getMsg(1038, &quot;S&quot;), MyLocale.getMsg(1040, &quot;N&quot;),
-			MyLocale.getMsg(1047, &quot;A&quot;), MyLocale.getMsg(1049, &quot;DNF&quot;),
-			MyLocale.getMsg(1051, &quot;Last synced&quot;) };
+	private String[] colName = { &quot; &quot;, &quot;?&quot;, MyLocale.getMsg(1000, &quot;D&quot;), MyLocale.getMsg(1001, &quot;T&quot;), MyLocale.getMsg(1002, &quot;Waypoint&quot;), &quot;Name&quot;, MyLocale.getMsg(1004, &quot;Location&quot;), MyLocale.getMsg(1005, &quot;Owner&quot;), MyLocale.getMsg(1006, &quot;Hidden&quot;),
+			MyLocale.getMsg(1007, &quot;Status&quot;), MyLocale.getMsg(1008, &quot;Dist&quot;), MyLocale.getMsg(1009, &quot;Bear&quot;), MyLocale.getMsg(1017, &quot;S&quot;), MyLocale.getMsg(1026, &quot;#Rec&quot;), MyLocale.getMsg(1027, &quot;OC-IDX&quot;), MyLocale.getMsg(1038, &quot;S&quot;),
+			MyLocale.getMsg(1040, &quot;N&quot;), MyLocale.getMsg(1047, &quot;A&quot;), MyLocale.getMsg(1049, &quot;DNF&quot;), MyLocale.getMsg(1051, &quot;Last synced&quot;) };
 
 	private static Image noFindLogs[] = new Image[4];
 	public static mImage red, blue, yellow; // skull, green
@@ -106,8 +90,7 @@
 	private mImage picHasSolver, picHasNotes;
 	private mImage[] sizePics = new mImage[CacheSize.CW_TOTAL_SIZE_IMAGES];
 	/**
-	 * This is the modifier (Shift &amp; Control key status) for Pen Events it is
-	 * set in myTableControl.onEvent
+	 * This is the modifier (Shift &amp; Control key status) for Pen Events it is set in myTableControl.onEvent
 	 */
 	public int penEventModifiers;
 	public myTableControl tcControl;
@@ -174,10 +157,8 @@
 	 * 
 	 */
 	public void setColumnNamesAndWidths() {
-		colMap = TableColumnChooser.str2Array(Global.getPref().listColMap, 0,
-				N_COLUMNS - 1, 0, -1);
-		colWidth = TableColumnChooser.str2Array(Global.getPref().listColWidth,
-				10, 1024, 50, colMap.length);
+		colMap = TableColumnChooser.str2Array(Global.getPref().listColMap, 0, N_COLUMNS - 1, 0, -1);
+		colWidth = TableColumnChooser.str2Array(Global.getPref().listColWidth, 10, 1024, 50, colMap.length);
 		numCols = colMap.length;
 		clearCellAdjustments();
 		// If the displayed columns include the checkbox, we use the full menu
@@ -188,8 +169,7 @@
 	}
 
 	/**
-	 * Return the column widths as a comma delimited string for storing in the
-	 * preferences
+	 * Return the column widths as a comma delimited string for storing in the preferences
 	 * 
 	 * @return
 	 */
@@ -261,14 +241,12 @@
 	}
 
 	/**
-	 * Method to set the row color of the table displaying the cache list,
-	 * depending on different flags set to the cache.
+	 * Method to set the row color of the table displaying the cache list, depending on different flags set to the cache.
 	 */
 	/*
 	 * (non-Javadoc)
 	 * 
-	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean,
-	 * ewe.ui.TableCellAttributes)
+	 * @see ewe.ui.TableModel#getCellAttributes(int, int, boolean, ewe.ui.TableCellAttributes)
 	 */
 	public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
 		ta = super.getCellAttributes(row, col, isSelected, ta);
@@ -320,7 +298,7 @@
 					lastColorFG.set(ta.foreground);
 					lastRow = row;
 				} catch (Exception e) {
-					Global.getPref().log(&quot;[myTableModel:getCellAttributes]Ignored row=&quot;+row+&quot; lastRow=&quot;+lastRow,e, true);
+					Global.getPref().log(&quot;[myTableModel:getCellAttributes]Ignored row=&quot; + row + &quot; lastRow=&quot; + lastRow, e, true);
 				}
 				;
 			} else {
@@ -329,8 +307,7 @@
 				ta.fillColor = lastColorBG;
 				ta.foreground = lastColorFG;
 			}
-		} else if (row == -1 &amp;&amp; colMap[col] == 0
-				&amp;&amp; Global.getProfile().showBlacklisted()) {
+		} else if (row == -1 &amp;&amp; colMap[col] == 0 &amp;&amp; Global.getProfile().showBlacklisted()) {
 			ta.fillColor = Color.Black;
 			lastColorBG.set(ta.fillColor);
 		}
@@ -338,22 +315,17 @@
 	}
 
 	/**
-	 * Determines the arithmetic mean value of two colors and stores the result
-	 * in the third color.
+	 * Determines the arithmetic mean value of two colors and stores the result in the third color.
 	 * 
 	 * @param colorMerged
 	 *            Resulting color
 	 * @param colorA
-	 *            First color to merge. May be same object as
-	 *            &lt;code&gt;colorMerged&lt;/code&gt;.
+	 *            First color to merge. May be same object as &lt;code&gt;colorMerged&lt;/code&gt;.
 	 * @param colorB
-	 *            Second color to merge. May be same object as
-	 *            &lt;code&gt;colorMerged&lt;/code&gt;.
+	 *            Second color to merge. May be same object as &lt;code&gt;colorMerged&lt;/code&gt;.
 	 */
 	private void mergeColor(Color colorMerged, Color colorA, Color colorB) {
-		colorMerged.set((colorA.getRed() + colorB.getRed()) / 2, (colorA
-				.getGreen() + colorB.getGreen()) / 2,
-				(colorA.getBlue() + colorB.getBlue()) / 2);
+		colorMerged.set((colorA.getRed() + colorB.getRed()) / 2, (colorA.getGreen() + colorB.getGreen()) / 2, (colorA.getBlue() + colorB.getBlue()) / 2);
 	}
 
 	public int calculateRowHeight(int row) {
@@ -370,9 +342,7 @@
 	}
 
 	/**
-	 * Need to override this method with a null return to avoid getCellData
-	 * being called twice on each access to a cell. For further reference see
-	 * the Ewe source code.
+	 * Need to override this method with a null return to avoid getCellData being called twice on each access to a cell. For further reference see the Ewe source code.
 	 * 
 	 * @author skg
 	 */
@@ -432,8 +402,7 @@
 					return ch.getWayPoint();
 				case 5: // Cachename
 					// Fast return for majority of case
-					if (!showExtraWptInfo
-							|| (ch.has_bugs() == false &amp;&amp; ch.getNoFindLogs() == 0))
+					if (!showExtraWptInfo || (ch.has_bugs() == false &amp;&amp; ch.getNoFindLogs() == 0))
 						return ch.getCacheName();
 					// Now need more checks
 					IconAndText wpVal = new IconAndText();
@@ -448,7 +417,7 @@
 					wpVal.addColumn(ch.getCacheName());
 					return wpVal;
 				case 6: // Location
-					return ch.getLatLon();
+					return ch.getPos().toString();
 				case 7: // Owner
 					return ch.getCacheOwner();
 				case 8: // Date hidden
@@ -465,13 +434,14 @@
 					} else {
 						return sizePics[CacheSize.guiSizeImageId(ch.getCacheSize())];
 					}
-				case 13: // OC number of recommendations
-					 return ch.getRecommended();
-          
-				case 14: // OC rating
-					if (ch.isOC())
-						return Convert.formatInt(ch.recommendationScore);
-					return null;
+				case 13: // OC / gcvote Bewertung
+					return ch.getRecommended();
+				case 14: //
+					if (ch.getWayPoint().startsWith(&quot;GC&quot;))
+						return ch.getOcCacheID();
+					else {
+						return OC.getGCWayPoint(ch.getCacheOwner());
+					}
 				case 15: // Is solver filled?
 					if (ch.hasSolver())
 						return picHasSolver;
@@ -497,10 +467,9 @@
 				case 19: // Last sync date
 					if (!ch.getLastSync().equals(&quot;&quot;)) {
 						try {
-							lastSyncWorker.parse(ch.getLastSync(),
-									&quot;yyyyMMddHHmmss&quot;);
+							lastSyncWorker.parse(ch.getLastSync(), &quot;yyyyMMddHHmmss&quot;);
 						} catch (IllegalArgumentException e) {
-							Global.getPref().log(&quot;Could not parse 'lastSyncDate': &quot;	+ ch.getLastSync() + &quot;. Reset to empty.&quot;, e);
+							Global.getPref().log(&quot;Could not parse 'lastSyncDate': &quot; + ch.getLastSync() + &quot;. Reset to empty.&quot;, e);
 							ch.setLastSync(&quot;&quot;);
 						}
 						return lastSyncWorker.format(&quot;yyyy-MM-dd HH:mm&quot;);
@@ -522,17 +491,18 @@
 			return false;
 		try {
 			// Check whether the click is on the checkbox image
+			tcControl.clickedColumn = colMap[cell.x];
 			if (cell.y &gt;= 0 &amp;&amp; colMap[cell.x] == 0) {
 				Global.getProfile().selectionChanged = true;
 				if ((penEventModifiers &amp; IKeys.SHIFT) &gt; 0) {
-					if (tcControl.cursor.y &gt;= 0) { // Second row being marked
-													// with shift key pressed
+					if (tcControl.cursor.y &gt;= 0) {
+						// Second row being marked with shift key pressed
 						if (tcControl.cursor.y &lt; cell.y)
 							toggleSelect(tcControl.cursor.y + 1, cell.y, cell.x);
 						else
 							toggleSelect(cell.y, tcControl.cursor.y - 1, cell.x);
-					} else { // Remember this row as start of range, but don't
-								// toggle yet
+					} else {
+						// Remember this row as start of range, but don't toggle yet
 					}
 				} else { // Single row marked
 					toggleSelect(cell.y, cell.y, cell.x);
@@ -551,7 +521,7 @@
 				retval = true;
 			}
 		} catch (NullPointerException npex) {
-			Global.getPref().log(&quot;[myTableModel:Penpressed]&quot;,npex,true);
+			Global.getPref().log(&quot;[myTableModel:Penpressed]&quot;, npex, true);
 			Vm.showWait(false);
 		}
 		return retval;
@@ -574,7 +544,7 @@
 			CacheHolder ch = null;
 			if ((a != null) &amp;&amp; (a.y &gt;= 0) &amp;&amp; (a.y &lt; cacheDB.size()))
 				ch = cacheDB.get(a.y);
-			cacheDB.sort(new MyComparer(cacheDB, sortedBy, numRows),!sortAscending);
+			cacheDB.sort(new MyComparer(cacheDB, sortedBy, numRows), !sortAscending);
 			updateRows();
 			// = cacheDB.rebuild(sortedVector of ch,
 			// invisibleVector of ch)
@@ -591,9 +561,7 @@
 	}
 
 	/**
-	 * Toggle the select status for a group of caches If from==to, the addi
-	 * Waypoints are also toggled if the cache is a main waypoint If from!=to,
-	 * each cache is toggled irrespective of its type (main or addi)
+	 * Toggle the select status for a group of caches If from==to, the addi Waypoints are also toggled if the cache is a main waypoint If from!=to, each cache is toggled irrespective of its type (main or addi)
 	 * 
 	 * @param from
 	 *            index of first cache to toggle

Modified: branches/r1.2/src/CacheWolf/navi/Area.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/Area.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/Area.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -31,32 +31,37 @@
 	 public final static int NOT_ON_EDGE = -1;
 	 public final static int AT_TOP_EDGE = 1;
 	 public final static int AT_RIGHT_EDGE = 2;
-	 public final static int AT_BUTTOM_EDGE = 3;
+	 public final static int AT_BOTTOM_EDGE = 3;
 	 public final static int AT_LEFT_EDGE = 4;
 	 public static double edgeTolerance = 3 * 360/40000000; // approx 3m will be seen as the same
 */
 	 public CWPoint topleft;
-	 public CWPoint buttomright;
+	 public CWPoint bottomright;
 	 
 	 public Area() {
 		 topleft = new CWPoint();
-		 buttomright = new CWPoint();
+		 bottomright = new CWPoint();
 	 }
 
 	 public Area(TrackPoint tl, TrackPoint br){
 		 topleft = new CWPoint(tl);
-		 buttomright = new CWPoint(br);
+		 bottomright = new CWPoint(br);
 	 }
+	 
+	 public Area(CWPoint tl, CWPoint br) {
+		 topleft = tl;
+		 bottomright = br;
+	 }
 
 	 public final boolean isInBound(TrackPoint p) {
 		 if (topleft.latDec &gt;= p.latDec &amp;&amp; topleft.lonDec &lt;= p.lonDec 
-				 &amp;&amp; buttomright.latDec &lt;= p.latDec &amp;&amp; buttomright.lonDec &gt;= p.lonDec) return true;
+				 &amp;&amp; bottomright.latDec &lt;= p.latDec &amp;&amp; bottomright.lonDec &gt;= p.lonDec) return true;
 		 else return false;
 	 }
 		
 	 public final boolean isInBound(double lat, double lon) {
 		 if (topleft.latDec &gt;= lat &amp;&amp; topleft.lonDec &lt;= lon
-				 &amp;&amp; buttomright.latDec &lt;= lat &amp;&amp; buttomright.lonDec &gt;= lon) return true;
+				 &amp;&amp; bottomright.latDec &lt;= lat &amp;&amp; bottomright.lonDec &gt;= lon) return true;
 		 else return false;
 	 }
 
@@ -66,24 +71,24 @@
 	 * @return
 	 */
 	 public final boolean isInBound(Area a) {
-		 return (isInBound(a.topleft) &amp;&amp; isInBound(a.buttomright));
+		 return (isInBound(a.topleft) &amp;&amp; isInBound(a.bottomright));
 	 }
 	 
 	 
 	 public final boolean isOverlapping(Area a) {
 		 return ! ( // test if not overlapping and invert the result, see <A HREF="http://www.geoclub.de/viewtopic.php?f=40&amp;t=38364&amp;p=607033#p607033">http://www.geoclub.de/viewtopic.php?f=40&amp;t=38364&amp;p=607033#p607033</A>
-				    this.buttomright.latDec &gt; a.topleft.latDec
-				 || this.topleft.latDec     &lt; a.buttomright.latDec
-				 || this.buttomright.lonDec &lt; a.topleft.lonDec
-				 || this.topleft.lonDec     &gt; a.buttomright.lonDec);
+				    this.bottomright.latDec &gt; a.topleft.latDec
+				 || this.topleft.latDec     &lt; a.bottomright.latDec
+				 || this.bottomright.lonDec &lt; a.topleft.lonDec
+				 || this.topleft.lonDec     &gt; a.bottomright.lonDec);
 	 }
 	 
 	 /* not used at the moment
 	  public boolean equals(Area a) {
 		 if(java.lang.Math.abs(topleft.latDec - a.topleft.latDec) &lt; edgeTolerance 
 				 &amp;&amp; java.lang.Math.abs(topleft.lonDec - a.topleft.lonDec) &lt; edgeTolerance
-				 &amp;&amp; java.lang.Math.abs(buttomright.latDec - a.buttomright.latDec) &lt; edgeTolerance
-				 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - a.buttomright.lonDec) &lt; edgeTolerance )
+				 &amp;&amp; java.lang.Math.abs(bottomright.latDec - a.bottomright.latDec) &lt; edgeTolerance
+				 &amp;&amp; java.lang.Math.abs(bottomright.lonDec - a.bottomright.lonDec) &lt; edgeTolerance )
 			 return true;
 		 else return false;
 	 }
@@ -93,19 +98,19 @@
 	 public int getEdge(CWPoint tl, CWPoint br) {
 		 if (java.lang.Math.abs(topleft.latDec - br.latDec) &lt; edgeTolerance 
 				 &amp;&amp; java.lang.Math.abs(topleft.lonDec - tl.lonDec) &lt; edgeTolerance 
-				 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - br.lonDec) &lt; edgeTolerance)
+				 &amp;&amp; java.lang.Math.abs(bottomright.lonDec - br.lonDec) &lt; edgeTolerance)
 			 return AT_TOP_EDGE;
 			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) &lt; edgeTolerance 
-					 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - tl.lonDec) &lt; edgeTolerance 
-					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - br.latDec) &lt; edgeTolerance)
+					 &amp;&amp; java.lang.Math.abs(bottomright.lonDec - tl.lonDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(bottomright.latDec - br.latDec) &lt; edgeTolerance)
 				 return AT_RIGHT_EDGE;
 			 if (java.lang.Math.abs(topleft.lonDec - tl.lonDec) &lt; edgeTolerance 
-					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - tl.latDec) &lt; edgeTolerance 
-					 &amp;&amp; java.lang.Math.abs(buttomright.lonDec - br.lonDec) &lt; edgeTolerance)
-				 return AT_BUTTOM_EDGE;
+					 &amp;&amp; java.lang.Math.abs(bottomright.latDec - tl.latDec) &lt; edgeTolerance 
+					 &amp;&amp; java.lang.Math.abs(bottomright.lonDec - br.lonDec) &lt; edgeTolerance)
+				 return AT_BOTTOM_EDGE;
 			 if (java.lang.Math.abs(topleft.latDec - tl.latDec) &lt; edgeTolerance 
 					 &amp;&amp; java.lang.Math.abs(topleft.lonDec - br.lonDec) &lt; edgeTolerance 
-					 &amp;&amp; java.lang.Math.abs(buttomright.latDec - br.latDec) &lt; edgeTolerance)
+					 &amp;&amp; java.lang.Math.abs(bottomright.latDec - br.latDec) &lt; edgeTolerance)
 				 return AT_LEFT_EDGE;
 			 return NOT_ON_EDGE;
 	 }
@@ -117,7 +122,7 @@
 	  */
 	 public final String getEasyFindString() {
 		 String ul = getEasyFindString(topleft, 30);
-		 String br = getEasyFindString(buttomright, 30);
+		 String br = getEasyFindString(bottomright, 30);
 		 int i;
 		 for (i=0; i&lt;br.length(); i++ ) {
 			 if (ul.charAt(i) != br.charAt(i)) break;
@@ -153,10 +158,10 @@
 	 }
 	 
 	 public String toString() {
-		 return topleft.toString() + &quot;, &quot; + buttomright.toString();
+		 return topleft.toString() + &quot;, &quot; + bottomright.toString();
 	 }
 	 
 	 public final CWPoint getCenter() {
-		 return new CWPoint((topleft.latDec + buttomright.latDec)/2, (topleft.lonDec + buttomright.lonDec)/2);
+		 return new CWPoint((topleft.latDec + bottomright.latDec)/2, (topleft.lonDec + bottomright.lonDec)/2);
 	 }
 }

Modified: branches/r1.2/src/CacheWolf/navi/AreaList.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/AreaList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/AreaList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -38,28 +38,28 @@
 /*
 	 public AreaList(int s) {super(s);}
 
-	 public void addArea(CWPoint topleft, CWPoint buttomright) {
+	 public void addArea(CWPoint topleft, CWPoint bottomright) {
 		 Area tp = getArea(topleft);
-		 if (tp != null &amp;&amp; tp.isInBound(buttomright)) return; // area already completly in list
-		 int edge = tp.getEdge(topleft, buttomright);
+		 if (tp != null &amp;&amp; tp.isInBound(bottomright)) return; // area already completly in list
+		 int edge = tp.getEdge(topleft, bottomright);
 		 switch (edge) {
 		 case Area.AT_TOP_EDGE: tp.topleft.latDec = topleft.latDec; break;
-		 case Area.AT_RIGHT_EDGE: tp.buttomright.lonDec = buttomright.lonDec; break;
-		 case Area.AT_BUTTOM_EDGE: tp.buttomright.latDec = buttomright.latDec; break;
+		 case Area.AT_RIGHT_EDGE: tp.bottomright.lonDec = bottomright.lonDec; break;
+		 case Area.AT_BOTTOM_EDGE: tp.bottomright.latDec = bottomright.latDec; break;
 		 case Area.AT_LEFT_EDGE: tp.topleft.lonDec = topleft.lonDec; break;
-		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, buttomright));
+		 case Area.NOT_ON_EDGE: addAreaUnconditionally(new Area(topleft, bottomright));
 		 }
 	 }
 
-	 public boolean AreaIsCovered(CWPoint topleft, CWPoint buttomright) {
+	 public boolean AreaIsCovered(CWPoint topleft, CWPoint bottomright) {
 		 Area tp = getArea(topleft);
-		 if (tp != null &amp;&amp; tp.isInBound(buttomright)) return true; // area already completly in list
+		 if (tp != null &amp;&amp; tp.isInBound(bottomright)) return true; // area already completly in list
 		 else return false;
 
 	 }
 
 	 public void addArea(Area a) {
-		 addArea(a.topleft, a.buttomright);
+		 addArea(a.topleft, a.bottomright);
 	 }
 
 	 public static AreaList joinAreas(AreaList al){

Modified: branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/CWGPSPoint.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import org.json.JSONArray;
@@ -40,19 +40,18 @@
 import ewe.sys.TimerProc;
 import ewe.sys.Vm;
 
-
 /**
  * @author Kalle
- * Class for decoding NMEA sentences
+ *         Class for decoding NMEA sentences
  */
 
-public class CWGPSPoint extends CWPoint implements TimerProc{
+public class CWGPSPoint extends CWPoint implements TimerProc {
 	public static final int LOGNMEA = 0x01;
-	public static final int LOGRAW  = 0x02;
-	public static final int LOGALL  = LOGNMEA|LOGRAW;
+	public static final int LOGRAW = 0x02;
+	public static final int LOGALL = LOGNMEA | LOGRAW;
 
 	public double Speed; // Speed: km/h
-	public double Bear;	// Bearing
+	public double Bear; // Bearing
 	public String Time; // Time: HHmmss.SS
 	public String Date; // Date: ddMMyy
 	public int Fix; // Fix (0: none, 1: GPS, 2: differential GPS). See getFix() for more possible values.
@@ -61,7 +60,7 @@
 	public double HDOP; // Horizontal dilution of precision
 	public double Alt; // Altitude in meters
 
-	//Logging
+	// Logging
 	int logTimer = 0;
 	int logFlag = 0;
 	boolean writeLog = false;
@@ -69,15 +68,14 @@
 	FileWriter logFile;
 	String lastStrExamined = &quot;&quot;;
 
-	//Regex numberMatcher = new Regex(&quot;\\-?\\d+&quot;);
+	// Regex numberMatcher = new Regex(&quot;\\-?\\d+&quot;);
 
-	public CWGPSPoint()
-	{
+	public CWGPSPoint() {
 		super();
 		this.Speed = 0;
 		this.Bear = 0;
 		this.Time = &quot;&quot;;
-		this.Date=&quot;&quot;;
+		this.Date = &quot;&quot;;
 		this.Fix = 0;
 		this.numSat = 0;
 		this.numSatsInView = 0;
@@ -85,29 +83,32 @@
 		this.HDOP = 0;
 	}
 
-
-	public double getSpeed(){
+	public double getSpeed() {
 		return this.Speed;
 	}
 
-	public double getBear (){
+	public double getBear() {
 		return this.Bear;
 	}
-	public String getTime(){
+
+	public String getTime() {
 		return this.Time;
 	}
 
 	/**
-	 * @return &gt; 0: fixed &lt;br&gt; 0: not fixed &lt;br&gt; -1: no data from serial port &lt;br&gt; -2 data from serial port could not be interpreted
+	 * @return &gt; 0: fixed &lt;br&gt;
+	 *         0: not fixed &lt;br&gt;
+	 *         -1: no data from serial port &lt;br&gt;
+	 *         -2 data from serial port could not be interpreted
 	 */
-	public int getFix(){
+	public int getFix() {
 		return this.Fix;
 	}
 
 	/**
 	 * this method should be called, if COM-Port is closed
 	 */
-	public void noData(){
+	public void noData() {
 		this.Fix = 0;
 		this.numSat = 0;
 		this.HDOP = 0;
@@ -116,7 +117,7 @@
 	/**
 	 * this method should be called, if not data is coming from COM-Port but is expected to come
 	 */
-	public void noDataError(){
+	public void noDataError() {
 		this.Fix = -1;
 		this.numSat = -1;
 		this.HDOP = -1;
@@ -125,13 +126,13 @@
 	/**
 	 * this method should be called, if examine returns for several calls that it couldn't interprete the data
 	 */
-	public void noInterpretableData(){
+	public void noInterpretableData() {
 		this.Fix = -2;
 		this.numSat = -2;
 		this.HDOP = -2;
 	}
 
-	public void ticked(int timerId, int elapsed){
+	public void ticked(int timerId, int elapsed) {
 		if (timerId == logTimer) {
 			writeLog = true;
 		}
@@ -139,23 +140,26 @@
 	}
 
 	/**
-	 *
-	 * @param logFileDir directory for logfile
-	 * @param seconds	 intervall for writing to logfile
-	 * @param flag		 level of logging
+	 * 
+	 * @param logFileDir
+	 *            directory for logfile
+	 * @param seconds
+	 *            intervall for writing to logfile
+	 * @param flag
+	 *            level of logging
 	 * @return 0 success, -1 failure
 	 */
-	public int startLog(String logFileDir, int seconds, int flag){
+	public int startLog(String logFileDir, int seconds, int flag) {
 
 		Time currTime = new Time();
 		currTime.getTime();
 		currTime.setFormat(&quot;yyyyMMdd'_'HHmm&quot;);
-		String logFileName = new String(logFileDir + currTime.toString()+ &quot;.log&quot;);
+		String logFileName = new String(logFileDir + currTime.toString() + &quot;.log&quot;);
 		// create Logfile
 		try {
 			logFile = new FileWriter(logFileName);
 		} catch (IOException e) {
-			Global.getPref().log(&quot;Error creating LogFile &quot; + logFileName,e,true);
+			Global.getPref().log(&quot;Error creating LogFile &quot; + logFileName, e, true);
 			return -1;
 		}
 		// start timer
@@ -168,10 +172,11 @@
 	public void stopLog() {
 		writeLog = false;
 
-		if (doLogging){
+		if (doLogging) {
 			try {
 				logFile.close();
-			} catch (IOException e) {/*Too lazy to do something */}
+			} catch (IOException e) {/* Too lazy to do something */
+			}
 			if (logTimer &gt; 0) {
 				Vm.cancelTimer(logTimer);
 				logTimer = 0;
@@ -180,82 +185,107 @@
 		doLogging = false;
 	}
 
-
-	public int getSats(){
+	public int getSats() {
 		return this.numSat;
 	}
 
-	public int getSatsInView(){
+	public int getSatsInView() {
 		return this.numSatsInView;
 	}
 
-	public double getAlt(){
+	public double getAlt() {
 		return this.Alt;
 	}
 
-	public double getHDOP(){
+	public double getHDOP() {
 		return this.HDOP;
 	}
 
 	/**
 	 * Sets the attributes from a NMEA String
-	 * @param NMEA	string with data to examine
+	 * 
+	 * @param NMEA
+	 *            string with data to examine
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examine(String NMEA){
+	public boolean examine(String NMEA) {
 		boolean interpreted = false;
 		boolean logWritten = false;
 		try {
 			int i, start, end;
-			String latDeg=&quot;0&quot;, latMin=&quot;0&quot;, latNS=&quot;N&quot;;
-			String lonDeg=&quot;0&quot;, lonMin=&quot;0&quot;, lonEW=&quot;E&quot;;
+			String latDeg = &quot;0&quot;, latMin = &quot;0&quot;, latNS = &quot;N&quot;;
+			String lonDeg = &quot;0&quot;, lonMin = &quot;0&quot;, lonEW = &quot;E&quot;;
 			String currToken;
 			end = 0;
 			lastStrExamined = NMEA;
-			while(true){
+			while (true) {
 				start = NMEA.indexOf(&quot;$GP&quot;, end);
-				if (start == -1) break;
+				if (start == -1)
+					break;
 				end = NMEA.indexOf(&quot;*&quot;, start);
-				if ((end == -1)||(end+3 &gt; NMEA.length())) break;
+				if ((end == -1) || (end + 3 &gt; NMEA.length()))
+					break;
 
-				if ((end - start) &lt; 15 || !checkSumOK(NMEA.substring(start,end+3))){
+				if ((end - start) &lt; 15 || !checkSumOK(NMEA.substring(start, end + 3))) {
 					continue;
 				}
 				// Write log after finding valid NMEA sequence
-				if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0){
+				if (writeLog &amp;&amp; (logFlag &amp; LOGRAW) &gt; 0) {
 					try {
-						logFile.write(NMEA.substring(start,end+3)+&quot;\n&quot;);
+						logFile.write(NMEA.substring(start, end + 3) + &quot;\n&quot;);
 						logWritten = true;
 					} catch (IOException e) {
 						// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 					}
 				}
 
-				Extractor ex = new Extractor (&quot;,&quot; + NMEA.substring(start,end), &quot;,&quot;,&quot;,&quot;,0,true);
+				Extractor ex = new Extractor(&quot;,&quot; + NMEA.substring(start, end), &quot;,&quot;, &quot;,&quot;, 0, true);
 				currToken = ex.findNext();
-				if (currToken.equals(&quot;$GPGGA&quot;)){
+				if (currToken.equals(&quot;$GPGGA&quot;)) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						boolean latlonerror = false; // indicate that some error occured in the data -&gt; in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
+						// indicate that some error occured in the data -&gt; in this case frace fix to non-fixed in order to avoid invalid coordinates when a fix is indicated to the higher level API
+						boolean latlonerror = false;
 						i++;
-						if (currToken.length()==0) {
-							if (i &gt;= 2 &amp;&amp; i &lt;= 5) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
-						}
-						switch (i){
-						case 1: this.Time = currToken; break;
-						case 2: try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 3: latNS = currToken;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							break;
+						case 2:
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 3:
+							latNS = currToken;
+							break;
 
-						case 4: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true; } catch (IndexOutOfBoundsException e) {latlonerror = true;}
-						break;
-						case 5: lonEW = currToken;
-						break;
+						case 4:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							break;
+						case 5:
+							lonEW = currToken;
+							break;
 						case 6:
 							if (!latlonerror) {
 								this.Fix = Convert.toInt(currToken);
@@ -265,142 +295,194 @@
 								this.Fix = 0;
 								break;
 							}
-						case 7: this.numSat = Convert.toInt(currToken); interpreted = true; break;
-						case 8: try {this.HDOP = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						} break;
-						case 9: try {this.Alt = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						} break;
+						case 7:
+							this.numSat = Convert.toInt(currToken);
+							interpreted = true;
+							break;
+						case 8:
+							try {
+								this.HDOP = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							break;
+						case 9:
+							try {
+								this.Alt = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							break;
 						} // switch
 					} // while
-					if (Fix &gt; 0) this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
+					if (Fix &gt; 0)
+						this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
 
 				} // if
 
-				if (currToken.equals(&quot;$GPVTG&quot;)){
+				if (currToken.equals(&quot;$GPVTG&quot;)) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
 						i++;
-						if (currToken.length()==0) continue;
-						switch (i){
-						case 1: try { this.Bear =Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						if (this.Bear &gt; 360) Global.getPref().log(&quot;Error bear VTG&quot;,null);
-						break;
-						case 7: try { this.Speed = Common.parseDouble(currToken); interpreted = true; } catch (NumberFormatException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						break;
+						switch (i) {
+						case 1:
+							try {
+								this.Bear = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							if (this.Bear &gt; 360)
+								Global.getPref().log(&quot;Error bear VTG&quot;, null);
+							break;
+						case 7:
+							try {
+								this.Speed = Common.parseDouble(currToken);
+								interpreted = true;
+							} catch (NumberFormatException e) {
+								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+							}
+							break;
 						} // switch
 					} // while
 				} // if
 
-				if (currToken.equals(&quot;$GPRMC&quot;)){
+				if (currToken.equals(&quot;$GPRMC&quot;)) {
 					i = 0;
 					String status = &quot;V&quot;;
 					boolean latlonerror = false;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
 						i++;
-						if (currToken.length() == 0) {
-							if (i &gt;= 2 &amp;&amp; i &lt;= 6) latlonerror = true; // force non-fix if lat-lon not contained
-							continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
-						}
-						if (currToken.length() == 0) continue;
-						switch (i){
-						case 1: this.Time = currToken; interpreted = true; break;
-						case 2: status = currToken;
-						if (status.equals(&quot;A&quot;)) this.Fix = 1;
-						else this.Fix = 0;
-						interpreted = true;
-						break;
+						switch (i) {
+						case 1:
+							this.Time = currToken;
+							interpreted = true;
+							break;
+						case 2:
+							status = currToken;
+							if (status.equals(&quot;A&quot;))
+								this.Fix = 1;
+							else
+								this.Fix = 0;
+							interpreted = true;
+							break;
 						case 3:
-							try {latDeg = currToken.substring(0,2); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
-							try {latMin = currToken.substring(2,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {latlonerror = true;}
+							try {
+								latDeg = currToken.substring(0, 2);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
+							try {
+								latMin = currToken.substring(2, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
+								latlonerror = true;
+							}
 							break;
-						case 4: latNS = currToken; interpreted = true;
-						break;
-						case 5: try {lonDeg = currToken.substring(0,3); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						try {lonMin = currToken.substring(3,currToken.length()); interpreted = true;} catch (IndexOutOfBoundsException e) {
-							// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-						}
-						break;
-						case 6: lonEW = currToken;
-						interpreted = true;
-						break;
-						case 7: if (status.equals(&quot;A&quot;)){
-							try {this.Speed = Common.parseDouble(currToken)*1.854;
-							interpreted = true; } catch (NumberFormatException e) {
-								//Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
-							}
-						}
-						break;
-						case 8: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
-							try {this.Bear = Common.parseDouble(currToken);
-							interpreted = true; } catch (NumberFormatException e) {
+						case 4:
+							latNS = currToken;
+							interpreted = true;
+							break;
+						case 5:
+							try {
+								lonDeg = currToken.substring(0, 3);
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 							}
-						}
-						break;
-						case 9: if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length()&gt; 0){
-							try {this.Date = currToken;
-							interpreted = true; } catch (NumberFormatException e) {
+							try {
+								lonMin = currToken.substring(3, currToken.length());
+								interpreted = true;
+							} catch (IndexOutOfBoundsException e) {
 								// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 							}
-						}
-						break;
+							break;
+						case 6:
+							lonEW = currToken;
+							interpreted = true;
+							break;
+						case 7:
+							if (status.equals(&quot;A&quot;)) {
+								try {
+									this.Speed = Common.parseDouble(currToken) * 1.854;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+								}
+							}
+							break;
+						case 8:
+							if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length() &gt; 0) {
+								try {
+									this.Bear = Common.parseDouble(currToken);
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+								}
+							}
+							break;
+						case 9:
+							if (status.equals(&quot;A&quot;) &amp;&amp; currToken.length() &gt; 0) {
+								try {
+									this.Date = currToken;
+									interpreted = true;
+								} catch (NumberFormatException e) {
+									// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
+								}
+							}
+							break;
 						} // switch
 					} // while
-					if (latlonerror) this.Fix = 0;
+					if (latlonerror)
+						this.Fix = 0;
 					else {
-						if (status.equals(&quot;A&quot;)){
-							this.set(latNS, latDeg, latMin, &quot;0&quot;,
-									lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
+						if (status.equals(&quot;A&quot;)) {
+							this.set(latNS, latDeg, latMin, &quot;0&quot;, lonEW, lonDeg, lonMin, &quot;0&quot;, TransformCoordinates.DMM);
 						}
 					}
 				} // if
 
-				if (currToken.equals(&quot;$GPGSV&quot;)){
+				if (currToken.equals(&quot;$GPGSV&quot;)) {
 					i = 0;
-					while(ex.endOfSearch() != true){
-						currToken = ex.findNext();
+					while ((currToken = ex.findNext()).length() &gt; 0) {
 						i++;
-						if (currToken.length() == 0) continue; // sometimes there are 2 colons directly one after the other like &quot;,,&quot; (e.g. loox)
-						switch (i){
-						case 3: this.numSatsInView = Convert.toInt(currToken); interpreted = true; break;
+						switch (i) {
+						case 3:
+							this.numSatsInView = Convert.toInt(currToken);
+							interpreted = true;
+							break;
 						} // switch
 					} // while
 				} // if
 
-			} //while
+			} // while
 		} catch (Exception e) {
 			Global.getPref().log(&quot;Exception in examine in CWGPSPoint&quot;, e, true);
 		}
 
-		if	(logWritten)
+		if (logWritten)
 			writeLog = false;
 
 		return interpreted;
 	}
 
-
 	/**
 	 * Sets the attributes from a GPSD &lt;code&gt;POLL&lt;/code&gt; object
-	 *
-	 * @param gps	{@link JSONObject} containing GPS &lt;code&gt;POLL&lt;/code&gt; data.
+	 * 
+	 * @param gps
+	 *            {@link JSONObject} containing GPS &lt;code&gt;POLL&lt;/code&gt; data.
 	 * @return true if some data could be interpreted false otherwise
 	 *         Tblue&gt; For now, this always returns true. Any ideas what
-	 *                should be treated as not interpretable?
-	 * @throws JSONException When trying to access a not existing key (should not happen!).
+	 *         should be treated as not interpretable?
+	 * @throws JSONException
+	 *             When trying to access a not existing key (should not happen!).
 	 */
 	public boolean examineGpsd(JSONObject gps) throws JSONException {
-		JSONArray fixes    = gps.getJSONArray( &quot;fixes&quot; );
-		JSONArray skyviews = gps.getJSONArray( &quot;skyviews&quot; );
+		JSONArray fixes = gps.getJSONArray(&quot;fixes&quot;);
+		JSONArray skyviews = gps.getJSONArray(&quot;skyviews&quot;);
 		JSONArray sats;
 		JSONObject a_fix, a_skyview;
 		int fix_mode, i;
@@ -409,59 +491,55 @@
 
 		lastStrExamined = gps.toString();
 
-		TimeObj.setTime( (long)( gps.getDouble( &quot;timestamp&quot; ) * 1000 ) );
-		this.Time = TimeObj.format( &quot;HHmmss.SS&quot; );
-		this.Date = TimeObj.format( &quot;ddMMyy&quot; );
+		TimeObj.setTime((long) (gps.getDouble(&quot;timestamp&quot;) * 1000));
+		this.Time = TimeObj.format(&quot;HHmmss.SS&quot;);
+		this.Date = TimeObj.format(&quot;ddMMyy&quot;);
 
-		if( fixes.length() &gt; 0 ) {
+		if (fixes.length() &gt; 0) {
 			// We will only use the first fix.
 			// TODO: Randomize?
-			a_fix = fixes.getJSONObject( 0 );
-			
+			a_fix = fixes.getJSONObject(0);
+
 			// 0: no mode seen yet, 1: none, 2: 2D, 3: 3D.
 			// Tblue&gt; Does 3D mean differential here?
-			this.Fix = ( fix_mode = a_fix.getInt( &quot;mode&quot; ) ) &gt; 0 ? fix_mode - 1 : 0;
+			this.Fix = (fix_mode = a_fix.getInt(&quot;mode&quot;)) &gt; 0 ? fix_mode - 1 : 0;
 
 			// Speed is in m/s.
-			if( a_fix.has( &quot;speed&quot; ) ) {
-				this.Speed = ( a_fix.getDouble( &quot;speed&quot; ) / 1000 ) * 60 * 60;
+			if (a_fix.has(&quot;speed&quot;)) {
+				this.Speed = (a_fix.getDouble(&quot;speed&quot;) / 1000) * 60 * 60;
 			}
 
-			if( a_fix.has( &quot;track&quot; ) ) {
-				this.Bear = a_fix.getDouble( &quot;track&quot; );
+			if (a_fix.has(&quot;track&quot;)) {
+				this.Bear = a_fix.getDouble(&quot;track&quot;);
 			}
 
-			if( a_fix.has( &quot;alt&quot; ) ) {
-				this.Alt = a_fix.getDouble( &quot;alt&quot; );
+			if (a_fix.has(&quot;alt&quot;)) {
+				this.Alt = a_fix.getDouble(&quot;alt&quot;);
 			}
 
-			if( a_fix.has( &quot;lat&quot; ) &amp;&amp; a_fix.has( &quot;lon&quot; ) ) {
-				my_lat = a_fix.getDouble( &quot;lat&quot; );
-				my_lon = a_fix.getDouble( &quot;lon&quot; );
+			if (a_fix.has(&quot;lat&quot;) &amp;&amp; a_fix.has(&quot;lon&quot;)) {
+				my_lat = a_fix.getDouble(&quot;lat&quot;);
+				my_lon = a_fix.getDouble(&quot;lon&quot;);
 
-				set( my_lat &gt; 0 ? &quot;N&quot; : &quot;S&quot;, String.valueOf( my_lat ), &quot;0&quot;, &quot;0&quot;,
-					 my_lon &gt; 0 ? &quot;E&quot; : &quot;W&quot;, String.valueOf( my_lon ), &quot;0&quot;, &quot;0&quot;,
-					 TransformCoordinates.DD );
+				set(my_lat &gt; 0 ? &quot;N&quot; : &quot;S&quot;, String.valueOf(my_lat), &quot;0&quot;, &quot;0&quot;, my_lon &gt; 0 ? &quot;E&quot; : &quot;W&quot;, String.valueOf(my_lon), &quot;0&quot;, &quot;0&quot;, TransformCoordinates.DD);
 			}
 		}
 
-		if( skyviews.length() &gt; 0 )
-		{
+		if (skyviews.length() &gt; 0) {
 			// We will only use the first skyview.
 			// TODO: Randomize?
-			a_skyview = skyviews.getJSONObject( 0 );
+			a_skyview = skyviews.getJSONObject(0);
 
-			if( a_skyview.has( &quot;hdop&quot; ) ) {
-				this.HDOP = a_skyview.getDouble( &quot;hdop&quot; );
+			if (a_skyview.has(&quot;hdop&quot;)) {
+				this.HDOP = a_skyview.getDouble(&quot;hdop&quot;);
 			}
 
-			sats = a_skyview.getJSONArray( &quot;satellites&quot; );
+			sats = a_skyview.getJSONArray(&quot;satellites&quot;);
 			this.numSatsInView = sats.length();
 
-			if( this.numSatsInView &gt; 0 )
-			{
-				for( this.numSat = 0, i = 0; i &lt; this.numSatsInView; i++ ) {
-					if( sats.getJSONObject( i ).getBoolean( &quot;used&quot; ) ) {
+			if (this.numSatsInView &gt; 0) {
+				for (this.numSat = 0, i = 0; i &lt; this.numSatsInView; i++) {
+					if (sats.getJSONObject(i).getBoolean(&quot;used&quot;)) {
 						this.numSat++;
 					}
 				}
@@ -471,71 +549,72 @@
 		return true;
 	}
 
-
 	/**
 	 * Sets the attributes from an old-style GPSD string.
-	 * @param gps	GPSD string with data to examine
-	 *              Format: GPSD,key=value,...
+	 * 
+	 * @param gps
+	 *            GPSD string with data to examine
+	 *            Format: GPSD,key=value,...
 	 * @return true if some data could be interpreted false otherwise
 	 */
-	public boolean examineOldGpsd(String gps){
+	public boolean examineOldGpsd(String gps) {
 		boolean valid = false;
-		if(!gps.startsWith(&quot;GPSD,&quot;))
+		if (!gps.startsWith(&quot;GPSD,&quot;))
 			return false;
-		Extractor ex = new Extractor (gps, &quot;,&quot;,&quot;,&quot;,4,true);
-		while(!ex.endOfSearch()){
-			String part = ex.findNext();
-			if(part.startsWith(&quot;A=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+		Extractor ex = new Extractor(gps, &quot;,&quot;, &quot;,&quot;, 4, true);
+		String part;
+		while ((part = ex.findNext()).length() &gt; 0) {
+			if (part.startsWith(&quot;A=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// The current altitude as &quot;A=%f&quot;, meters above mean sea level.
-				this.Alt=Common.parseDouble(part.substring(2));
+				this.Alt = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith(&quot;D=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+			} else if (part.startsWith(&quot;D=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// Returns the UTC time in the ISO 8601 format, &quot;D=yyyy-mm-ddThh:mm:ss.ssZ&quot;
-				//                                               0000000000111111111122
-				//                                               0123456789012345678901
-				String year = part.substring(2,6);
-				String month = part.substring(7,9);
-				String day = part.substring(10,12);
-				String hour = part.substring(13,15);
-				String min = part.substring(16,18);
-				String sec = part.substring(19,21);
-				this.Date=year+month+day;
-				this.Time=hour+min+sec;
+				// 0000000000111111111122
+				// 0123456789012345678901
+				String year = part.substring(2, 6);
+				String month = part.substring(7, 9);
+				String day = part.substring(10, 12);
+				String hour = part.substring(13, 15);
+				String min = part.substring(16, 18);
+				String sec = part.substring(19, 21);
+				this.Date = year + month + day;
+				this.Time = hour + min + sec;
 				valid = true;
-			}else if(part.startsWith(&quot;P=&quot;)){
+			} else if (part.startsWith(&quot;P=&quot;)) {
 				// Returns the current position in the form &quot;P=%f %f&quot;; numbers are in degrees, latitude first.
-				if(part.indexOf('?')&lt;0){
+				if (part.indexOf('?') &lt; 0) {
 					this.Fix = 1;
-					int spacepos=part.indexOf(' ');
-					if(spacepos&gt;=3){
-						String lat=part.substring(2,spacepos);
-						String lon=part.substring(spacepos+1);
-						this.latDec=Common.parseDouble(lat);
-						this.lonDec=Common.parseDouble(lon);
-					}else
+					int spacepos = part.indexOf(' ');
+					if (spacepos &gt;= 3) {
+						String lat = part.substring(2, spacepos);
+						String lon = part.substring(spacepos + 1);
+						this.latDec = Common.parseDouble(lat);
+						this.lonDec = Common.parseDouble(lon);
+					} else
 						this.set(part.substring(2));
-				}else{
+				} else {
 					this.Fix = 0;
 				}
 				valid = true;
-			}else if(part.startsWith(&quot;Q=&quot;)){
+			} else if (part.startsWith(&quot;Q=&quot;)) {
 				// Returns &quot;Q=%d %f %f %f %f %f&quot;: a count of satellites used in the last fix,
 				// and five dimensionless dilution-of-precision (DOP) numbers --
 				// spherical, horizontal, vertical, time, and total geometric.
-				int spacepos=part.indexOf(' ');
-				if(part.indexOf('?')&lt;0 &amp;&amp; spacepos&gt;=3){
+				int spacepos = part.indexOf(' ');
+				if (part.indexOf('?') &lt; 0 &amp;&amp; spacepos &gt;= 3) {
 					this.numSat = Common.parseInt(part.substring(2, spacepos));
 					valid = true;
-				}else{
+				} else {
 					this.numSat = 0;
 				}
-				this.numSatsInView = 0;			// Not supported by GPSD
-				//TODO parse DOP values
-			}else if(part.startsWith(&quot;T=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+				this.numSatsInView = 0; // Not supported by GPSD
+				// TODO parse DOP values
+			} else if (part.startsWith(&quot;T=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// Track made good; course &quot;T=%f&quot; in degrees from true north.
 				this.Bear = Common.parseDouble(part.substring(2));
 				valid = true;
-			}else if(part.startsWith(&quot;V=&quot;) &amp;&amp; part.indexOf('?')&lt;0){
+			} else if (part.startsWith(&quot;V=&quot;) &amp;&amp; part.indexOf('?') &lt; 0) {
 				// The current speed over ground as &quot;V=%f&quot; in knots.
 				this.Speed = Common.parseDouble(part.substring(2));
 				valid = true;
@@ -544,16 +623,16 @@
 		return valid;
 	}
 
-
-	private boolean checkSumOK(String nmea){
+	private boolean checkSumOK(String nmea) {
 		int startPos = 1; // begin after $
 		int endPos = nmea.length() - 3;// without * an two checksum chars
 		byte checkSum = 0;
 
-		for (int i= startPos; i&lt;endPos;i++){
+		for (int i = startPos; i &lt; endPos; i++) {
 			checkSum ^= nmea.charAt(i);
 		}
-		try { return (checkSum == Byte.parseByte(nmea.substring(endPos+1),16));
+		try {
+			return (checkSum == Byte.parseByte(nmea.substring(endPos + 1), 16));
 		} catch (IndexOutOfBoundsException e) {
 			return false;
 		} catch (NumberFormatException e) {
@@ -561,9 +640,7 @@
 		}
 	}
 
-
-
-	public void printAll(){
+	public void printAll() {
 		Global.getPref().log(&quot;Latitude:     &quot; + this.getLatDeg(TransformCoordinates.DD));
 		Global.getPref().log(&quot;Longitude:    &quot; + this.getLonDeg(TransformCoordinates.DD));
 		Global.getPref().log(&quot;Speed:        &quot; + this.Speed);
@@ -577,5 +654,3 @@
 		Global.getPref().log(&quot;----------------&quot;);
 	}
 }
-
-

Modified: branches/r1.2/src/CacheWolf/navi/GotoPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/GotoPanel.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/GotoPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -68,18 +68,17 @@
 import ewe.ui.mLabel;
 
 /**
- *	Class to create the panel which handles the connection to the GPS-device&lt;br&gt;
- *	Displays: current position,speed and bearing; relation to destination waypoint&lt;br&gt;
- *	Class ID: 1500
+ * Class to create the panel which handles the connection to the GPS-device&lt;br&gt;
+ * Displays: current position,speed and bearing; relation to destination waypoint&lt;br&gt;
+ * Class ID: 1500
  */
 
-
 public final class GotoPanel extends CellPanel {
 
-	//public CWGPSPoint gpsPosition = new CWGPSPoint();
-	//public CWPoint toPoint = new CWPoint();
+	// public CWGPSPoint gpsPosition = new CWGPSPoint();
+	// public CWPoint toPoint = new CWPoint();
 	public Navigate myNavigation;
-	mButton btnGPS, btnCenter,btnSave;
+	mButton btnGPS, btnCenter, btnSave;
 	mButton btnGoto, btnMap;
 	int currFormatSel;
 
@@ -101,13 +100,13 @@
 	ImageControl icRose;
 	GotoRose compassRose;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
 
 	Menu mnuContextFormt;
-	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; //miDMM, miDMS, miDD, miUTM, miGK;
+	MenuItem miCooformat[] = new MenuItem[TransformCoordinates.localSystems.length + 3]; // miDMM, miDMS, miDD, miUTM, miGK;
 
 	Menu mnuContextRose;
 	MenuItem miLuminary[] = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
@@ -115,27 +114,32 @@
 
 	/**
 	 * Create GotoPanel
-	 * @param Preferences 	global preferences
-	 * @param MainTab		reference to MainTable
-	 * @param DetailsPanel 	reference to DetailsPanel
-	 * @param Vector		cacheDB
+	 * 
+	 * @param Preferences
+	 *            global preferences
+	 * @param MainTab
+	 *            reference to MainTable
+	 * @param DetailsPanel
+	 *            reference to DetailsPanel
+	 * @param Vector
+	 *            cacheDB
 	 */
 	public GotoPanel(Navigate nav) {
 		myNavigation = nav;
 		pref = Global.getPref();
-		profile=Global.getProfile();
+		profile = Global.getProfile();
 		mainT = Global.mainTab;
 		detP = mainT.detP;
 		cacheDB = profile.cacheDB;
 
 		// Button
-		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504,&quot;Start&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309,&quot;Centre&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311,&quot;Create Waypoint&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		ButtonP.addNext(btnGPS = new mButton(MyLocale.getMsg(1504, &quot;Start&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addNext(btnCenter = new mButton(MyLocale.getMsg(309, &quot;Centre&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		ButtonP.addLast(btnSave = new mButton(MyLocale.getMsg(311, &quot;Create Waypoint&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		// ButtonP.addLast(btnMap = new mButton(MyLocale.getMsg(1506,&quot;Map&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
 
-		//Format selection for coords
-		//context menu
+		// Format selection for coords
+		// context menu
 		mnuContextFormt = new Menu();
 		currFormatSel = 1; // default to d&#176; m.m
 		mnuContextFormt.addItem(miCooformat[0] = new MenuItem(&quot;d.d&#176;&quot;));
@@ -148,14 +152,16 @@
 
 		// Create context menu for compass rose: select luminary for orientation
 		mnuContextRose = new Menu();
-		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i &lt; SkyOrientation.LUMINARY_NAMES.length; i++) {
 			mnuContextRose.addItem(miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i)));
-			if (i == myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-			else miLuminary[i].modifiers &amp;= MenuItem.Checked;
+			if (i == myNavigation.luminary)
+				miLuminary[i].modifiers |= MenuItem.Checked;
+			else
+				miLuminary[i].modifiers &amp;= MenuItem.Checked;
 		}
 
-		//Coords
-		CoordsP.addNext(lblGPS = new mLabel(&quot;GPS: &quot;),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		// Coords
+		CoordsP.addNext(lblGPS = new mLabel(&quot;GPS: &quot;), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		lblGPS.backGround = RED;
 		lblGPS.setMenu(mnuContextFormt);
 		lblGPS.modifyAll(ControlConstants.WantHoldDown, 0);
@@ -164,45 +170,47 @@
 		lblPosition.anchor = CellConstants.CENTER;
 		lblPosition.setMenu(mnuContextFormt);
 		lblPosition.modifyAll(ControlConstants.WantHoldDown, 0);
-		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(lblPosition, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500,&quot;DST:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		lblDST.backGround = new Color(0,0,255);
+		CoordsP.addNext(lblDST = new mLabel(MyLocale.getMsg(1500, &quot;DST:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		lblDST.backGround = new Color(0, 0, 255);
 		lblDST.setMenu(mnuContextFormt);
 		lblDST.modifyAll(ControlConstants.WantHoldDown, 0);
 
-		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()),CellConstants.HSTRETCH, (CellConstants.HFILL|CellConstants.WEST));
+		CoordsP.addLast(btnGoto = new mButton(getGotoBtnText()), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
 
-		//Rose for bearing
-		//		compassRose = new GotoRose(&quot;rose.png&quot;);
+		// Rose for bearing
+		// compassRose = new GotoRose(&quot;rose.png&quot;);
 		compassRose = new GotoRose();
 		icRose = new ImageControl(compassRose);
 		icRose.setMenu(mnuContextRose);
 		icRose.modifyAll(ControlConstants.WantHoldDown, 0); // this is necessary in order to make PenHold on a PDA work as right click
-		roseP.addLast(icRose,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.NORTH));
+		roseP.addLast(icRose, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.NORTH));
 
 		mnuContextRose.addItem(new MenuItem(&quot;&quot;, MenuItem.Separator, null));
-		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503,&quot;North Centered&quot;)));
-		if (compassRose.isNorthCentered()) miNorthCentered.modifiers |= MenuItem.Checked;
-		else miNorthCentered.modifiers &amp;= MenuItem.Checked;
+		mnuContextRose.addItem(miNorthCentered = new MenuItem(MyLocale.getMsg(1503, &quot;North Centered&quot;)));
+		if (compassRose.isNorthCentered())
+			miNorthCentered.modifiers |= MenuItem.Checked;
+		else
+			miNorthCentered.modifiers &amp;= MenuItem.Checked;
 
-		//add Panels
-		HeadP.addLast(ButtonP,CellConstants.HSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		HeadP.addLast(CoordsP,CellConstants.HSTRETCH, CellConstants.HFILL|CellConstants.NORTH).setTag(SPAN,new Dimension(2,1));	
-		this.addNext(HeadP,CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN,new Dimension(2,1));		
-		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506,&quot;Map&quot;)+&quot; &quot;),CellConstants.HSTRETCH, CellConstants.VFILL|CellConstants.RIGHT).setTag(SPAN,new Dimension(2,1));
-		this.addLast(roseP,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST).setTag(SPAN,new Dimension(2,1));
-		btnMap.backGround=GREEN;
+		// add Panels
+		HeadP.addLast(ButtonP, CellConstants.HSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		HeadP.addLast(CoordsP, CellConstants.HSTRETCH, CellConstants.HFILL | CellConstants.NORTH).setTag(SPAN, new Dimension(2, 1));
+		this.addNext(HeadP, CellConstants.HSTRETCH, CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(btnMap = new mButton(MyLocale.getMsg(1506, &quot;Map&quot;) + &quot; &quot;), CellConstants.HSTRETCH, CellConstants.VFILL | CellConstants.RIGHT).setTag(SPAN, new Dimension(2, 1));
+		this.addLast(roseP, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST).setTag(SPAN, new Dimension(2, 1));
+		btnMap.backGround = GREEN;
 	}
 
-	public void resizeTo(int pWidth, int pHeight){
+	public void resizeTo(int pWidth, int pHeight) {
 		super.resizeTo(pWidth, pHeight);
 		Rect coordsRect = CoordsP.getRect();
 		int roseHeight = pHeight - coordsRect.y - coordsRect.height;
 		if (Gui.screenIs(Gui.PDA_SCREEN) &amp;&amp; Vm.isMobile()) {
-			//some space for the SIP button
-			if ( (Vm.getParameter(VmConstants.VM_FLAGS) &amp; (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN) ){
-				Rect screen = (Rect)Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT,null,new Rect(),0);
+			// some space for the SIP button
+			if ((Vm.getParameter(VmConstants.VM_FLAGS) &amp; (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) == (VmConstants.VM_FLAG_SIP_BUTTON_ON_SCREEN)) {
+				Rect screen = (Rect) Window.getGuiInfo(WindowConstants.INFO_SCREEN_RECT, null, new Rect(), 0);
 				roseHeight -= screen.height / 14;
 			}
 		}
@@ -211,14 +219,17 @@
 		compassRose.resize(pWidth, roseHeight);
 	}
 
-
 	/**
 	 * set the coords of the destination
-	 * @param dest destination
+	 * 
+	 * @param dest
+	 *            destination
 	 */
-	public void setDestination(CWPoint dest){
+	public void setDestination(CWPoint dest) {
 		myNavigation.setDestination(dest);
-		if (!myNavigation.destination.isValid()) (new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;), MyLocale.getMsg(1507,&quot;Coordinates are out of range:&quot;) +&quot;\n&quot;+MyLocale.getMsg(1508,&quot;latitude&quot;)+&quot;: &quot;+myNavigation.destination.latDec+&quot;\n &quot;+MyLocale.getMsg(1509,&quot;longditue&quot;)+&quot;: &quot;+myNavigation.destination.lonDec, FormBase.OKB)).execute();
+		if (!myNavigation.destination.isValid())
+			(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1507, &quot;Coordinates are out of range:&quot;) + &quot;\n&quot; + MyLocale.getMsg(1508, &quot;latitude&quot;) + &quot;: &quot; + myNavigation.destination.latDec + &quot;\n &quot; + MyLocale.getMsg(1509, &quot;longditue&quot;) + &quot;: &quot;
+					+ myNavigation.destination.lonDec, FormBase.OKB)).execute();
 
 	}
 
@@ -227,15 +238,17 @@
 		updateDistance();
 	}
 
-
 	/**
 	 * set the coords of the destination and switch to gotoPanel
-	 * @param LatLon destination
+	 * 
+	 * @param LatLon
+	 *            destination
 	 */
 	public void setDestinationAndSwitch(CWPoint where) {
 		myNavigation.setDestination(where);
 		mainT.select(this);
 	}
+
 	public void setDestinationAndSwitch(CacheHolder ch) {
 		myNavigation.setDestination(ch);
 		mainT.select(this);
@@ -243,16 +256,16 @@
 
 	/**
 	 * updates distance and bearing
-	 *
+	 * 
 	 */
 
 	public void updateDistance() {
-		//update distance
+		// update distance
 		float distance = -1.0f;
-		if (myNavigation.gpsPos.isValid() &amp;&amp; myNavigation.destination.isValid() ) {
-			distance = (float)myNavigation.gpsPos.getDistance(myNavigation.destination);
+		if (myNavigation.gpsPos.isValid() &amp;&amp; myNavigation.destination.isValid()) {
+			distance = (float) myNavigation.gpsPos.getDistance(myNavigation.destination);
 		}
-		compassRose.setWaypointDirectionDist((float)myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
+		compassRose.setWaypointDirectionDist((float) myNavigation.gpsPos.getBearing(myNavigation.destination), distance);
 	}
 
 	/**
@@ -263,37 +276,41 @@
 		Double speed = new Double();
 		Double sunAzimut = new Double();
 		compassRose.setGpsStatus(fix, myNavigation.gpsPos.getSats(), myNavigation.gpsPos.getSatsInView(), myNavigation.gpsPos.getHDOP());
-		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) {
 			// display values only, if signal good
 			lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 			speed.set(myNavigation.gpsPos.getSpeed());
 			sunAzimut.set(myNavigation.skyOrientationDir.lonDec);
 			bearMov.set(myNavigation.gpsPos.getBear());
 			updateDistance();
-			compassRose.setSunMoveDirections((float)sunAzimut.value, (float)bearMov.value, (float)speed.value);
+			compassRose.setSunMoveDirections((float) sunAzimut.value, (float) bearMov.value, (float) speed.value);
 			// Set background to signal quality
 		}
 
 		// receiving data, but signal ist not good
-		if ((fix == 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) {
+		if ((fix == 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) {
 			gpsStatus = YELLOW;
 		}
 		// receiving no data
 		if (fix == -1) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1510, &quot;No data from GPS.\nConnection to serial port/gpsd closed.&quot;),FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1510, &quot;No data from GPS.\nConnection to serial port/gpsd closed.&quot;), FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps();
 		}
 		// cannot interpret data
 		if (fix == -2) {
-			if (gpsStatus != RED) (new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1511, &quot;Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n&quot;)+myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
+			if (gpsStatus != RED)
+				(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1511,
+						&quot;Cannot interpret data from GPS/gpsd!\nPossible reasons:\nWrong port,\nwrong baud rate,\ninvalid protocol (need NMEA/gpsd).\nConnection to serial port closed.\nLast String tried to interpret:\n&quot;)
+						+ myNavigation.gpsPos.lastStrExamined, FormBase.OKB)).exec();
 			gpsStatus = RED;
 			myNavigation.stopGps(); // TODO automatic in myNavigate?
 		}
 	}
 
 	public void gpsStarted() {
-		btnGPS.setText(MyLocale.getMsg(1505,&quot;Stop&quot;));
+		btnGPS.setText(MyLocale.getMsg(1505, &quot;Stop&quot;));
 	}
 
 	public void startGps() {
@@ -301,28 +318,33 @@
 	}
 
 	public void gpsStoped() {
-		btnGPS.setText(MyLocale.getMsg(1504,&quot;Start&quot;));
+		btnGPS.setText(MyLocale.getMsg(1504, &quot;Start&quot;));
 		gpsStatus = this.backGround;
 		this.repaintNow(); // without this the change in the background color will not be displayed
 	}
 
-
 	private String getGotoBtnText() {
-		if (myNavigation.destination == null) return MyLocale.getMsg(999,&quot;Not set&quot;);
-		else return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
+		if (myNavigation.destination == null)
+			return MyLocale.getMsg(999, &quot;Not set&quot;);
+		else
+			return myNavigation.destination.toString(CoordsScreen.getLocalSystem(currFormatSel));
 	}
 
 	public void switchToMovingMap() {
 		CWPoint centerTo = null;
-		if (myNavigation.isGpsPosValid()) centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
+		if (myNavigation.isGpsPosValid())
+			centerTo = new CWPoint(myNavigation.gpsPos); // set gps-pos if gps is on
 		else {
 			// setze Zielpunkt als Ausgangspunkt, wenn GPS aus ist und lade entsprechende Karte
-			//centerTo = new CWPoint(myNavigation.destination);
-			if (myNavigation.destination.isValid())	centerTo = new CWPoint(myNavigation.destination);
+			// centerTo = new CWPoint(myNavigation.destination);
+			if (myNavigation.destination.isValid())
+				centerTo = new CWPoint(myNavigation.destination);
 			else {
-				if (mainT.ch != null &amp;&amp; mainT.ch.pos.isValid()) centerTo = new CWPoint(mainT.ch.pos);
+				if (mainT.ch != null &amp;&amp; mainT.ch.getPos().isValid())
+					centerTo = new CWPoint(mainT.ch.getPos());
 				else {
-					if (pref.getCurCentrePt().isValid()) centerTo = new CWPoint(pref.getCurCentrePt());
+					if (pref.getCurCentrePt().isValid())
+						centerTo = new CWPoint(pref.getCurCentrePt());
 				}
 			}
 		}
@@ -335,10 +357,10 @@
 	/**
 	 * Eventhandler
 	 */
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		if (ev instanceof MenuEvent) {
 			if (ev.type == MenuEvent.SELECTED) {
-				if (((MenuEvent)ev).menu == mnuContextFormt) {
+				if (((MenuEvent) ev).menu == mnuContextFormt) {
 					mnuContextFormt.close();
 					mnuContextFormt.getItemAt(currFormatSel).modifiers &amp;= ~MenuItem.Checked;
 					currFormatSel = mnuContextFormt.getInt();
@@ -346,23 +368,22 @@
 					lblPosition.setText(myNavigation.gpsPos.toString(CoordsScreen.getLocalSystem(currFormatSel)));
 					btnGoto.setText(getGotoBtnText());
 				} // end lat-lon-format context menu
-				if (((MenuEvent)ev).menu == mnuContextRose) {
+				if (((MenuEvent) ev).menu == mnuContextRose) {
 					MenuItem action = (MenuItem) mnuContextRose.getSelectedItem();
 					if (action != null) {
-						for (int i=0; i&lt;miLuminary.length; i++) {
+						for (int i = 0; i &lt; miLuminary.length; i++) {
 							if (action == miLuminary[i]) {
 								myNavigation.setLuminary(i);
 								miLuminary[i].modifiers |= MenuItem.Checked;
 								compassRose.setLuminaryName(SkyOrientation.getLuminaryName(myNavigation.luminary));
-							} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
+							} else
+								miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
 						}
 						if (action == miNorthCentered) {
 							if (compassRose.isNorthCentered()) {
 								compassRose.setNorthCentered(false);
 								miNorthCentered.modifiers &amp;= ~MenuItem.Checked;
-							}
-							else
-							{
+							} else {
 								compassRose.setNorthCentered(true);
 								miNorthCentered.modifiers |= MenuItem.Checked;
 							}
@@ -372,44 +393,49 @@
 			}
 		}
 
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
 			// start/stop GPS connection
-			if (ev.target == btnGPS){
-				if (btnGPS.getText().equals(MyLocale.getMsg(1504, &quot;Start&quot;))) startGps();
-				else myNavigation.stopGps();
+			if (ev.target == btnGPS) {
+				if (btnGPS.getText().equals(MyLocale.getMsg(1504, &quot;Start&quot;)))
+					startGps();
+				else
+					myNavigation.stopGps();
 			}
 
 			// set current position as centre and recalculate distance of caches in MainTab
-			if (ev.target == btnCenter){
+			if (ev.target == btnCenter) {
 				if (myNavigation.gpsPos.isValid()) {
 					pref.setCurCentrePt(myNavigation.gpsPos);
-				} else (new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(1514, &quot;Cannot recalculate distances, because the GPS position is not set&quot;), FormBase.OKB)).execute();
+				} else
+					(new MessageBox(MyLocale.getMsg(312, &quot;Error&quot;), MyLocale.getMsg(1514, &quot;Cannot recalculate distances, because the GPS position is not set&quot;), FormBase.OKB)).execute();
 			}
-			//Start moving map
-			if (ev.target == btnMap){
+			// Start moving map
+			if (ev.target == btnMap) {
 				switchToMovingMap();
 			}
 			// create new waypoint with current GPS-position
-			if (ev.target == btnSave){
+			if (ev.target == btnSave) {
 				CacheHolder ch = new CacheHolder();
-				ch.setLatLon(myNavigation.gpsPos.toString());
-				ch.pos = new CWPoint(myNavigation.gpsPos);
+				ch.setPos(myNavigation.gpsPos);
 				ch.setType(CacheType.CW_TYPE_STAGE); // see CacheType.GC_AW_STAGE_OF_MULTI // TODO unfertig
 				mainT.newWaypoint(ch);
 			}
 			// change destination waypoint
-			if (ev.target == btnGoto){
-				if(Vm.isMobile()){
+			if (ev.target == btnGoto) {
+				if (Vm.isMobile()) {
 					InputScreen InScr = new InputScreen(CoordsScreen.getLocalSystem(currFormatSel));
-					if (myNavigation.destination.isValid())	InScr.setCoords(myNavigation.destination);
-					else InScr.setCoords(new CWPoint(0,0));
+					if (myNavigation.destination.isValid())
+						InScr.setCoords(myNavigation.destination);
+					else
+						InScr.setCoords(new CWPoint(0, 0));
 					if (InScr.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(InScr.getCoords());
-				}else
-				{
+				} else {
 					CoordsScreen cs = new CoordsScreen();
-					if (myNavigation.destination.isValid())	cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
-					else cs.setFields(new CWPoint(0,0), CoordsScreen.getLocalSystem(currFormatSel));
+					if (myNavigation.destination.isValid())
+						cs.setFields(myNavigation.destination, CoordsScreen.getLocalSystem(currFormatSel));
+					else
+						cs.setFields(new CWPoint(0, 0), CoordsScreen.getLocalSystem(currFormatSel));
 					if (cs.execute(null, CellConstants.TOP) == FormBase.IDOK)
 						setDestination(cs.getCoords());
 				}
@@ -420,7 +446,8 @@
 	}
 }
 
-/** class for displaying the compass rose
+/**
+ * class for displaying the compass rose
  * including goto, sun and moving direction
  */
 class GotoRose extends AniImage {
@@ -445,25 +472,28 @@
 
 	boolean northCentered = Global.getPref().northCenteredGoto;
 
-	final static Color RED = new Color(255,0,0);
-	final static Color YELLOW = new Color(255,255,0);
-	final static Color GREEN = new Color(0,255,0);
-	final static Color BLUE = new Color(0,0,255);
-	final static Color ORANGE = new Color(255,128,0);
-	final static Color DARKGREEN = new Color(0,192,0);
-	final static Color CYAN = new Color(0,255,255);
-	final static Color MAGENTA = new Color(255,0,255);
+	final static Color RED = new Color(255, 0, 0);
+	final static Color YELLOW = new Color(255, 255, 0);
+	final static Color GREEN = new Color(0, 255, 0);
+	final static Color BLUE = new Color(0, 0, 255);
+	final static Color ORANGE = new Color(255, 128, 0);
+	final static Color DARKGREEN = new Color(0, 192, 0);
+	final static Color CYAN = new Color(0, 255, 255);
+	final static Color MAGENTA = new Color(255, 0, 255);
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public GotoRose(String fn){
+	public GotoRose(String fn) {
 		super(fn);
 	}
 
-	public GotoRose(){
+	public GotoRose() {
 		super();
 	}
 
@@ -472,7 +502,7 @@
 		distance = dist;
 	}
 
-	public void setSunMoveDirections(float sd, float md, float speed ) {
+	public void setSunMoveDirections(float sd, float md, float speed) {
 		sunDir = sd;
 		moveDir = md;
 		m_speed = speed;
@@ -492,15 +522,18 @@
 		refresh();
 	}
 
-
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
+	public void doDraw(Graphics g, int options) {
 		g.setColor(Color.White);
 		g.fillRect(0, 0, location.width, location.height);
 
@@ -512,15 +545,14 @@
 		roseRadius = java.lang.Math.min((location.width * 3) / 4, location.height) / 2;
 
 		if (northCentered) {
-			//scale(location.width, location.height, null, 0);
-			//super.doDraw(g, options);
-			drawFullRose(g, 0, new Color(255,255,255), new Color(200,200,200), new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(75,75,75), 1.0f, true, true);
-		}
-		else {
-			int radius = (int)(roseRadius * 0.75f);
+			// scale(location.width, location.height, null, 0);
+			// super.doDraw(g, options);
+			drawFullRose(g, 0, new Color(255, 255, 255), new Color(200, 200, 200), new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(75, 75, 75), 1.0f, true, true);
+		} else {
+			int radius = (int) (roseRadius * 0.75f);
 
-			g.setPen(new Pen(new Color(150,150,150),Pen.SOLID,3));
-			g.drawEllipse(location.width/2 - radius, location.height/2 - radius, 2 * radius, 2 * radius );
+			g.setPen(new Pen(new Color(150, 150, 150), Pen.SOLID, 3));
+			g.drawEllipse(location.width / 2 - radius, location.height / 2 - radius, 2 * radius, 2 * radius);
 		}
 
 		drawArrows(g);
@@ -530,7 +562,7 @@
 		drawGpsStatus(g);
 	}
 
-	private void drawWayPointData(Graphics g){
+	private void drawWayPointData(Graphics g) {
 		String strTemp = MyLocale.getMsg(1512, &quot;Waypoint&quot;);
 		g.setColor(Color.DarkBlue);
 		g.fillRect(0, 0, fm.getTextWidth(strTemp) + 4, lineHeight);
@@ -559,29 +591,30 @@
 			threshold = 1.0;
 			newDistance = distance;
 		}
-		if ( newDistance &gt;= 0.0f ) {
+		if (newDistance &gt;= 0.0f) {
 			tmp.set(newDistance);
-			if (tmp.value &gt;= threshold){
-				strTemp = MyLocale.formatDouble(tmp,&quot;0.000&quot;)+ &quot; &quot; + Metrics.getUnit(bigUnit);
+			if (tmp.value &gt;= threshold) {
+				strTemp = MyLocale.formatDouble(tmp, &quot;0.000&quot;) + &quot; &quot; + Metrics.getUnit(bigUnit);
 			} else {
 				tmp.set(Metrics.convertUnit(tmp.value, bigUnit, smallUnit));
-				strTemp = tmp.toString(3,0,0) + &quot; &quot; + Metrics.getUnit(smallUnit);
+				strTemp = tmp.toString(3, 0, 0) + &quot; &quot; + Metrics.getUnit(smallUnit);
 			}
-		}
-		else strTemp = &quot;--- &quot;+Metrics.getUnit(bigUnit);
+		} else
+			strTemp = &quot;--- &quot; + Metrics.getUnit(bigUnit);
 		g.drawText(strTemp, 2, lineHeight);
 
 		tmp.set(gotoDir);
 		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
-			strTemp = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
-		else strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
-		g.drawText(strTemp, 2, 2*lineHeight);
+			strTemp = tmp.toString(0, 0, 0) + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
+		else
+			strTemp = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
+		g.drawText(strTemp, 2, 2 * lineHeight);
 	}
 
-	private void drawGpsData(Graphics g){
+	private void drawGpsData(Graphics g) {
 		g.setColor(RED);
 
-		String strHeadline = MyLocale.getMsg(1501,&quot;Current&quot;);
+		String strHeadline = MyLocale.getMsg(1501, &quot;Current&quot;);
 
 		Double tmp = new Double();
 
@@ -600,17 +633,16 @@
 		}
 		if (tmp.value &gt;= 0) {
 			if (tmp.value &gt;= 100) {
-				strSpeed = MyLocale.formatDouble(tmp,&quot;0&quot;) + unit;
+				strSpeed = MyLocale.formatDouble(tmp, &quot;0&quot;) + unit;
+			} else {
+				strSpeed = MyLocale.formatDouble(tmp, &quot;0.0&quot;) + unit;
 			}
-			else {
-				strSpeed = MyLocale.formatDouble(tmp,&quot;0.0&quot;) + unit;
-			}
 		}
 
 		tmp.set(moveDir);
-		String strMoveDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		String strMoveDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 		if ((tmp.value &lt;= 360) &amp;&amp; (tmp.value &gt;= -360))
-			strMoveDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+			strMoveDir = tmp.toString(0, 0, 0) + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSpeed), fm.getTextWidth(strMoveDir));
 		textWidth = java.lang.Math.max(textWidth, fm.getTextWidth(strHeadline));
@@ -621,21 +653,21 @@
 		g.setColor(Color.Black);
 		g.drawText(strHeadline, startX + 2, 0);
 		g.drawText(strSpeed, startX + 2, lineHeight);
-		g.drawText(strMoveDir, startX + 2, 2*lineHeight);
+		g.drawText(strMoveDir, startX + 2, 2 * lineHeight);
 	}
 
-	private void drawLuminaryData(Graphics g){
+	private void drawLuminaryData(Graphics g) {
 		g.setColor(YELLOW);
 
-		String strSunDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+		String strSunDir = &quot;---&quot; + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 		if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) {
 			Double tmp = new Double();
 			tmp.set(sunDir);
-			strSunDir = tmp.toString(0,0,0) + &quot; &quot; + MyLocale.getMsg(1502,&quot;deg&quot;);
+			strSunDir = tmp.toString(0, 0, 0) + &quot; &quot; + MyLocale.getMsg(1502, &quot;deg&quot;);
 		}
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(m_Luminary), fm.getTextWidth(strSunDir));
-		int startY = location.height - 2*lineHeight;
+		int startY = location.height - 2 * lineHeight;
 		g.fillRect(0, startY, textWidth + 4, location.height - startY);
 
 		g.setColor(Color.Black);
@@ -643,104 +675,96 @@
 		g.drawText(strSunDir, 2, startY + lineHeight);
 	}
 
-	private void drawGpsStatus(Graphics g){
+	private void drawGpsStatus(Graphics g) {
 		if ((m_fix &gt; 0) &amp;&amp; (m_sats &gt;= 0)) {
 			// Set background to signal quality
 			g.setColor(GREEN);
+		} else
+		// receiving data, but signal ist not good
+		if ((m_fix == 0) &amp;&amp; (m_sats &gt;= 0)) {
+			g.setColor(YELLOW);
+		} else {
+			g.setColor(RED);
 		}
-		else
-			// receiving data, but signal ist not good
-			if ((m_fix == 0) &amp;&amp; (m_sats &gt;= 0)) {
-				g.setColor(YELLOW);
-			}
-			else {
-				g.setColor(RED);
-			}
 
 		String strSats = &quot;Sats: -&quot;;
 		if (m_sats &gt;= 0) {
 			strSats = &quot;Sats: &quot; + Convert.toString(m_sats) + &quot;/&quot; + Convert.toString(m_satsInView);
 		}
 		String strHdop = &quot;HDOP: -&quot;;
-		if (m_hdop &gt;= 0) strHdop = &quot;HDOP: &quot; + Convert.toString(m_hdop);
+		if (m_hdop &gt;= 0)
+			strHdop = &quot;HDOP: &quot; + Convert.toString(m_hdop);
 
 		int textWidth = java.lang.Math.max(fm.getTextWidth(strSats), fm.getTextWidth(strHdop));
 		int startX = location.width - (textWidth + 4);
-		int startY = location.height - 2*lineHeight;
-		g.fillRect(startX, startY, location.width - startX ,location.height - startY);
+		int startY = location.height - 2 * lineHeight;
+		g.fillRect(startX, startY, location.width - startX, location.height - startY);
 
 		g.setColor(Color.Black);
 		g.drawText(strSats, startX + 2, startY);
 		g.drawText(strHdop, startX + 2, startY + lineHeight);
 	}
 
-	private void drawArrows(Graphics g){
-		if (g != null)
-		{
+	private void drawArrows(Graphics g) {
+		if (g != null) {
 			// select moveDirColor according to difference to gotoDir
 			Color moveDirColor = RED;
 
-			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360 &amp;&amp; moveDir &lt; 360 &amp;&amp; moveDir &gt; -360)
-			{
+			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360 &amp;&amp; moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
 				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff &gt; 360)
-				{
+				while (diff &gt; 360) {
 					diff -= 360.0f;
 				}
-				if (diff &gt; 180.0f)
-				{
+				if (diff &gt; 180.0f) {
 					diff = 360.0f - diff;
 				}
 
-				if (diff &lt;= 12.25f)
-				{
+				if (diff &lt;= 12.25f) {
 					moveDirColor = GREEN;
-				}
-				else if (diff &lt;= 22.5f)
-				{
+				} else if (diff &lt;= 22.5f) {
 					moveDirColor = CYAN;
-				}
-				else if (diff &lt;= 45.0f)
-				{
+				} else if (diff &lt;= 45.0f) {
 					moveDirColor = ORANGE;
-				}
-				else if (diff &lt;= 90.0f)
-				{
+				} else if (diff &lt;= 90.0f) {
 					moveDirColor = MAGENTA;
 				}
 			}
 
 			// draw only valid arrows
 			if (northCentered) {
-				if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
-				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
-				if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir, YELLOW, 0.75f);
-			}
-			else {
-				//moveDir centered
+				if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360)
+					drawThickArrow(g, gotoDir, Color.DarkBlue, 1.0f);
+				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360)
+					drawThinArrow(g, moveDir, RED, moveDirColor, 1.0f);
+				if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360)
+					drawSunArrow(g, sunDir, YELLOW, 0.75f);
+			} else {
+				// moveDir centered
 				if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
-					//drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
-					//drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
-					drawFullRose(g, 360 - moveDir, new Color(255,255,255), new Color(200,200,200), new Color(150,150,150), new Color(200,200,200), new Color(200,200,200), new Color(75,75,75), 1.0f, false, false);
+					// drawDoubleArrow(g, 360 - moveDir, BLUE, new Color(175,0,0), 1.0f);
+					// drawRose(g, 360 - moveDir, new Color(100,100,100), new Color(200,200,200), 1.0f);
+					drawFullRose(g, 360 - moveDir, new Color(255, 255, 255), new Color(200, 200, 200), new Color(150, 150, 150), new Color(200, 200, 200), new Color(200, 200, 200), new Color(75, 75, 75), 1.0f, false, false);
 
-					int radius = (int)(roseRadius * 0.75f);
-					g.setPen(new Pen(RED,Pen.SOLID,3));
-					g.drawLine(location.width/2, location.height/2 - radius, location.width/2, location.height/2 + radius);
+					int radius = (int) (roseRadius * 0.75f);
+					g.setPen(new Pen(RED, Pen.SOLID, 3));
+					g.drawLine(location.width / 2, location.height / 2 - radius, location.width / 2, location.height / 2 + radius);
 
-					if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
-					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
+					if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360)
+						drawThinArrow(g, gotoDir - moveDir, Color.DarkBlue, moveDirColor, 1.0f);
+					if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360)
+						drawSunArrow(g, sunDir - moveDir, YELLOW, 0.75f);
 				}
 			}
 		}
 	}
 
 	private void drawSunArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.08f;
 		float circlePos = arrowLength * 0.7f;
-		int circleRadius = (int)(arrowLength * 0.1f);
+		int circleRadius = (int) (arrowLength * 0.1f);
 
 		int circleX = centerX + new Float(circlePos * java.lang.Math.sin(angleRad)).intValue();
 		int circleY = centerY - new Float(circlePos * java.lang.Math.cos(angleRad)).intValue();
@@ -757,20 +781,20 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		//		g.setPen(new Pen(col,Pen.SOLID,3));
-		//		g.drawLine(centerX,centerY,pointX,pointY);
+		// g.setPen(new Pen(col,Pen.SOLID,3));
+		// g.drawLine(centerX,centerY,pointX,pointY);
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		g.fillEllipse(circleX - circleRadius, circleY - circleRadius, 2 * circleRadius, 2 * circleRadius);
 	}
 
 	private void drawThinArrow(Graphics g, float angle, Color col, Color colPoint, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
-		float halfOpeningAngle = (float)(java.lang.Math.PI * 0.03);
+		float halfOpeningAngle = (float) (java.lang.Math.PI * 0.03);
 		float sideLineLength = arrowLength * 0.75f;
 
 		int[] pointsX = new int[4];
@@ -785,7 +809,7 @@
 		pointsX[3] = centerX;
 		pointsY[3] = centerY;
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 		if (colPoint != null) {
@@ -794,29 +818,28 @@
 		}
 	}
 
-	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight,
-			Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
+	private void drawFullRose(Graphics g, float angle, Color colLeft, Color colRight, Color colNorthLeft, Color colNorthRight, Color colBorder, Color colText, float scale, boolean bDrawText, boolean bDrawEightArrows) {
 		float subScale1 = 1.0f;
 		float subScale2 = 0.9f;
 		float innerScale = 0.15f;
-		if(bDrawEightArrows){
+		if (bDrawEightArrows) {
 			innerScale = 0.12f;
-			drawRosePart(g,  45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NE&quot;, bDrawText);
+			drawRosePart(g, 45 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NE&quot;, bDrawText);
 			drawRosePart(g, 135 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SE&quot;, bDrawText);
 			drawRosePart(g, 225 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;SW&quot;, bDrawText);
 			drawRosePart(g, 315 + angle, colLeft, colRight, colBorder, colText, scale * subScale2, innerScale, &quot;NW&quot;, bDrawText);
 		}
 
-		drawRosePart(g,   0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, &quot;N&quot;, bDrawText);
-		drawRosePart(g,  90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;E&quot;, bDrawText);
+		drawRosePart(g, 0 + angle, colNorthLeft, colNorthRight, colBorder, colText, scale * subScale1, innerScale, &quot;N&quot;, bDrawText);
+		drawRosePart(g, 90 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;E&quot;, bDrawText);
 		drawRosePart(g, 180 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;S&quot;, bDrawText);
 		drawRosePart(g, 270 + angle, colLeft, colRight, colBorder, colText, scale * subScale1, innerScale, &quot;W&quot;, bDrawText);
 	}
 
 	private void drawRosePart(Graphics g, float angle, Color colLeft, Color colRight, Color colBorder, Color colText, float scale, float innerScale, String strDir, boolean bDrawText) {
-		float angleRad = angle * (float)java.lang.Math.PI / 180;
-		float angleRadText = (angle + 7.5f) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = angle * (float) java.lang.Math.PI / 180;
+		float angleRadText = (angle + 7.5f) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * innerScale;
@@ -831,7 +854,7 @@
 		pointsX[2] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 4.0)).intValue();
 		pointsY[2] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 4.0)).intValue();
 
-		g.setPen(new Pen(colBorder,Pen.SOLID,1));
+		g.setPen(new Pen(colBorder, Pen.SOLID, 1));
 		g.setBrush(new Brush(colLeft, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
@@ -841,27 +864,26 @@
 		g.setBrush(new Brush(colRight, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 3);
 
-		if (bDrawText){
+		if (bDrawText) {
 			int tempFontSize = new Float(scale * mainFont.getSize()).intValue();
 			Font tempFont = new Font(mainFont.getName(), Font.BOLD, tempFontSize);
 			g.setFont(tempFont);
 			FontMetrics tempFm = g.getFontMetrics(tempFont);
 			float stringHeight = tempFm.getHeight();
-			float stringWidth = tempFm.getTextWidth( strDir );
-			float stringGap = (float)java.lang.Math.sqrt(stringHeight*stringHeight + stringWidth*stringWidth);
+			float stringWidth = tempFm.getTextWidth(strDir);
+			float stringGap = (float) java.lang.Math.sqrt(stringHeight * stringHeight + stringWidth * stringWidth);
 
 			float stringPosition = arrowLength - stringGap / 2.0f;
 			g.setColor(colText);
-			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(),
-					centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
+			g.drawText(strDir, centerX + new Float(stringPosition * java.lang.Math.sin(angleRadText) - stringWidth / 2.0f).intValue(), centerY - new Float(stringPosition * java.lang.Math.cos(angleRadText) + stringHeight / 2.0f).intValue());
 
 			g.setFont(mainFont);
 		}
 	}
 
 	private void drawThickArrow(Graphics g, float angle, Color col, float scale) {
-		float angleRad = (angle) * (float)java.lang.Math.PI / 180;
-		int centerX = location.width/2, centerY = location.height/2;
+		float angleRad = (angle) * (float) java.lang.Math.PI / 180;
+		int centerX = location.width / 2, centerY = location.height / 2;
 		float arrowLength = roseRadius * scale;
 		float halfArrowWidth = arrowLength * 0.1f;
 
@@ -877,7 +899,7 @@
 		pointsX[3] = centerX + new Float(halfArrowWidth * java.lang.Math.sin(angleRad - java.lang.Math.PI / 2.0)).intValue();
 		pointsY[3] = centerY - new Float(halfArrowWidth * java.lang.Math.cos(angleRad - java.lang.Math.PI / 2.0)).intValue();
 
-		g.setPen(new Pen(Color.Black,Pen.SOLID,1));
+		g.setPen(new Pen(Color.Black, Pen.SOLID, 1));
 		g.setBrush(new Brush(col, Brush.SOLID));
 		g.fillPolygon(pointsX, pointsY, 4);
 	}
@@ -900,15 +922,14 @@
 		FontMetrics metrics = g.getFontMetrics(newFont);
 		int fontHeight = metrics.getHeight();
 
-		float ratio = (float)fontHeight / (float)size;
-		if(ratio &lt; 0.9 || ratio &gt; 1.1){
+		float ratio = (float) fontHeight / (float) size;
+		if (ratio &lt; 0.9 || ratio &gt; 1.1) {
 			size = (int) (size / ratio + 0.5);
-			if(size&lt;5)
-				size=5;
+			if (size &lt; 5)
+				size = 5;
 			newFont = new Font(name, style, size);
 		}
 
 		return newFont;
 	}
 }
-

Modified: branches/r1.2/src/CacheWolf/navi/MapImage.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapImage.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapImage.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,29 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
+
 import ewe.fx.Color;
 import ewe.fx.Dimension;
 import ewe.fx.Image;
@@ -35,45 +36,52 @@
 import ewe.graphics.AniImage;
 import ewe.io.FileInputStream;
 import ewe.io.IOException;
-/** 
+
+/**
  * class that can be used with any x and any y
- * it will save taht location and make itself automatically
- * invisible if it is not on the screen. Call setscreensize to
- * set the screensize
+ * it will save that location and
+ * make itself automatically invisible if it is not on the screen.
+ * Call setscreensize to set the screensize
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapImage extends AniImage {
 	public Point locAlways = new Point(); // contains the theoretical location even if it the location is out of the screen. If the image is on the screen, it contains the same as location
 	public static Dimension screenDim;
 	boolean hidden = false;
+
 	public MapImage() {
 		super();
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	public MapImage(String f) throws ImageDecodingException, UnsupportedImageFormatException, ImageNotFoundException, ewe.sys.SystemResourceException {
-		if (screenDim == null) screenDim = new Dimension(0,0);
-		//super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
+		// super(f); the following code is only necessary because of an Bug in ewe 1.49, which doesn't read from a fakefilesystem. If there were no bug, calling super(f) would be sufficient
 		ewe.io.File file = ewe.sys.Vm.newFileObject();
 		file.set(null, f);
 		try {
-		//ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
-		setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super() 
-		freeSource(); // copied from super()
-		} catch (IOException e) { 
-			throw new ImageNotFoundException(f); // in order to behave the same way as super would have 
+			// ByteArray imbytes = ewe.io.IO.readAllBytes(input, knownSize, stopAfterKnownSize);(file, null, true); // this would be possible if ewe 1.49 wouldn't have another bug: fakefilesystem doesn't implement (oderride) length(), it only overrides
+			// getLenght(), that's why readallBytes will call the original File implementation and cause and NullpointerException
+			setImage(new Image(new FileInputStream(f).toReadableStream(), 0), 0); // copied from super()
+			freeSource(); // copied from super()
+		} catch (IOException e) {
+			throw new ImageNotFoundException(f); // in order to behave the same way as super would have
 		}
 	}
 
 	public MapImage(mImage im) {
 		super(im);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
 	/**
 	 * Best you call this routine before you make any instance of MapImage
-	 * If the windows size changes after instantiation call  screenDimChanged()
+	 * If the windows size changes after instantiation call screenDimChanged()
 	 * for every symbol.
 	 * 
 	 */
@@ -83,13 +91,14 @@
 
 	public void setImage(Image im, Color c) {
 		super.setImage(im, c);
-		if (screenDim == null) screenDim = new Dimension(0,0);
+		if (screenDim == null)
+			screenDim = new Dimension(0, 0);
 	}
 
-	public void setLocation (int x, int y) {
+	public void setLocation(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden &amp;&amp; isOnScreen()) { 
+		if (!hidden &amp;&amp; isOnScreen()) {
 			super.setLocation(x, y);
 			properties &amp;= ~mImage.IsInvisible;
 		} else {
@@ -98,10 +107,10 @@
 		}
 	}
 
-	public void move (int x, int y) {
+	public void move(int x, int y) {
 		locAlways.x = x;
 		locAlways.y = y;
-		if (!hidden &amp;&amp; isOnScreen()) { 
+		if (!hidden &amp;&amp; isOnScreen()) {
 			super.move(x, y);
 			properties &amp;= ~mImage.IsInvisible;
 		} else {
@@ -110,23 +119,24 @@
 		}
 	}
 
-	public boolean isOnScreen() { 
-		if ( (locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp; 
-				(locAlways.y + location.height &gt; 0 &amp;&amp; locAlways.y &lt; screenDim.height) ) return true;
-		else return false;
+	public boolean isOnScreen() {
+		if ((locAlways.x + location.width &gt; 0 &amp;&amp; locAlways.x &lt; screenDim.width) &amp;&amp; (locAlways.y + location.height &gt; 0 &amp;&amp; locAlways.y &lt; screenDim.height))
+			return true;
+		else
+			return false;
 	}
 
 	public void screenDimChanged() {
 		move(locAlways.x, locAlways.y);
-		//if (!hidden &amp;&amp; isOnScreen()) properties &amp;= ~AniImage.IsInvisible;
-		//else properties |= AniImage.IsInvisible;
+		// if (!hidden &amp;&amp; isOnScreen()) properties &amp;= ~AniImage.IsInvisible;
+		// else properties |= AniImage.IsInvisible;
 	}
 
-
 	public void hide() {
 		hidden = true;
 		properties |= mImage.IsInvisible;
 	}
+
 	public void unhide() {
 		hidden = false;
 		move(locAlways.x, locAlways.y);

Modified: branches/r1.2/src/CacheWolf/navi/MapInfoObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapInfoObject.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapInfoObject.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -40,16 +40,14 @@
 import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 
-
 /**
- * class to read, save and do the calculations for calibrated and 
- * calibrating maps
- * start offset for language file: 4300
+ * class to read, save and do the calculations for calibrated and calibrating maps start offset for language file: 4300
+ * 
  * @author pfeffer
- *
+ * 
  */
 public class MapInfoObject extends Area {
-	//World file:
+	// World file:
 	// x scale
 	// y scale
 	// x rotation
@@ -59,89 +57,95 @@
 	// lon of lower right corner of image
 	// lat of lower right corner of image
 
-	private double[] affine = {0,0,0,0};
+	private final double[] affine = { 0, 0, 0, 0 };
 	private CWPoint affineTopleft = new CWPoint();;
-	private double transLatX, transLatY, transLonX, transLonY; // this are needed for the inervers calculation from lat/lon to x/y
+	// this are needed for the inervers calculation from lat/lon to x/y
+	private double transLatX, transLatY, transLonX, transLonY;
 	public CWPoint center = new CWPoint();
 	public float sizeKm = 0; // diagonale
-	public float scale; // in meters per pixel, note: it is assumed that this scale identifying the scale of the map, automatically adjusted when zooming
-	public float zoomFactor = 1; // if the image is zoomed, direct after laoding always 1
-	public Point shift = new Point (0,0);
-	public CWPoint origAffineUpperLeft; // this is only valid after zooming 
+	// in meters per pixel, note: it is assumed that this scale identifying the scale of the map,
+	// automatically adjusted when zooming
+	public float scale;
+	// if the image is zoomed, direct after laoding always 1
+	public float zoomFactor = 1;
+	public Point shift = new Point(0, 0);
+	public CWPoint origAffineUpperLeft; // this is only valid after zooming
 	public float rotationRad; // contains the rotation of the map == north direction in rad
-	/** full path to the respective worldfile, including &quot;.wfl&quot;*/
+	/** full path to the respective worldfile, including &quot;.wfl&quot; */
 	public String fileNameWFL = &quot;&quot;;
 	/** filename wihout directory */
-//	public String fileName = new String();
-	/** name of the map, introduced to allow 'maps' without an image (empty maps) */ 
+	// public String fileName = new String();
+	/**
+	 * name of the map, introduced to allow 'maps' without an image (empty maps)
+	 */
 	public String mapName = &quot;&quot;;
-	//private Character digSep = new Character(' ');
+	// private Character digSep = new Character(' ');
 	static private String digSep = MyLocale.getDigSeparator();
-	private int coordTrans = 0; 
+	private int coordTrans = 0;
 
 	public MapInfoObject() { // Public constructor
 	}
 
 	public MapInfoObject(MapInfoObject map) {
-		super (map.topleft, map.buttomright);
+		super(map.topleft, map.bottomright);
 		mapName = map.mapName;
 		affine[0] = map.affine[0];
 		affine[1] = map.affine[1];
 		affine[2] = map.affine[2];
 		affine[3] = map.affine[3];
-		origAffineUpperLeft = new CWPoint (map.origAffineUpperLeft);
+		origAffineUpperLeft = new CWPoint(map.origAffineUpperLeft);
 		affineTopleft = new CWPoint(map.affineTopleft);
 		zoomFactor = map.zoomFactor;
 		shift.set(map.shift);
 		coordTrans = map.coordTrans;
-		//	fileName = new String(map.fileName);
+		// fileName = new String(map.fileName);
 		fileNameWFL = new String(map.fileNameWFL);
 		mapName = new String(mapName);
 		doCalculations();
 	}
 
 	/**
-	 * constructes an MapInfoObject without an associated map
-	 * but with 1 Pixel = scale meters
+	 * constructes an MapInfoObject without an associated map but with 1 Pixel = scale meters
 	 */
 	public MapInfoObject(double scalei, double lat) {
-		super(new CWPoint(1,0), new CWPoint(0,1));
-		mapName=MyLocale.getMsg(4300, &quot;empty 1 Pixel = &quot;) + scalei + MyLocale.getMsg(4301,&quot;meters&quot;);
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deg / java.lang.Math.cos(lat*java.lang.Math.PI / 180); //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=1; //top
-		topleft.lonDec=0; //left
-		buttomright.latDec = 0; //buttom
-		buttomright.lonDec = 1; //right
+		super(new CWPoint(1, 0), new CWPoint(0, 1));
+		mapName = MyLocale.getMsg(4300, &quot;empty 1 Pixel = &quot;) + scalei + MyLocale.getMsg(4301, &quot;meters&quot;);
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deg / java.lang.Math.cos(lat * java.lang.Math.PI / 180); // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = 1; // top
+		topleft.lonDec = 0; // left
+		bottomright.latDec = 0; // bottom
+		bottomright.lonDec = 1; // right
 		affineTopleft.set(topleft);
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 	}
 
 	/**
-	 * constructs an MapInfoObject with an associated map
-	 * with 1 Pixel = scale meters, centre and width, hight in pixels
-	 * @param name path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
+	 * constructs an MapInfoObject with an associated map with 1 Pixel = scale meters, centre and width, hight in pixels
+	 * 
+	 * @param name
+	 *            path and filename of .wfl file without the extension (it is needed because the image will be searched in the same directory)
 	 */
 	public MapInfoObject(double scalei, CWPoint center, int width, int hight, String name) {
 		super();
-		mapName = name+&quot;.wfl&quot;;
-		double meters2deg = 1/(1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double pixel2deg = meters2deg * scalei;
-		double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec*java.lang.Math.PI / 180); 
-		affine[0]=0; //x2lat
-		affine[1]=pixel2deghorizontal; //x2lon
-		affine[2]=-pixel2deg; //y2lat
-		affine[3]=0; //y2lon
-		topleft.latDec=center.latDec + hight / 2 *pixel2deg; //top
-		topleft.lonDec=center.lonDec - width / 2 *pixel2deghorizontal; //left
+		mapName = name + &quot;.wfl&quot;;
+		final double meters2deg = 1 / (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		final double pixel2deg = meters2deg * scalei;
+		final double pixel2deghorizontal = pixel2deg / java.lang.Math.cos(center.latDec * java.lang.Math.PI / 180);
+		affine[0] = 0; // x2lat
+		affine[1] = pixel2deghorizontal; // x2lon
+		affine[2] = -pixel2deg; // y2lat
+		affine[3] = 0; // y2lon
+		topleft.latDec = center.latDec + hight / 2 * pixel2deg; // top
+		topleft.lonDec = center.lonDec - width / 2 * pixel2deghorizontal; // left
 		affineTopleft.set(topleft);
-		buttomright.latDec = center.latDec - hight / 2 *pixel2deg; //buttom
-		buttomright.lonDec = center.lonDec + width / 2 *pixel2deghorizontal; //right
+		bottomright.latDec = center.latDec - hight / 2 * pixel2deg; // bottom
+		bottomright.lonDec = center.lonDec + width / 2 * pixel2deghorizontal; // right
 		fileNameWFL = name;
 		origAffineUpperLeft = new CWPoint(affineTopleft);
 		doCalculations();
@@ -154,42 +158,51 @@
 
 	/**
 	 * 
-	 * @param path including trailing &quot;/&quot;
-	 * @param n without &quot;.wfl&quot;
+	 * @param path
+	 *            including trailing &quot;/&quot;
+	 * @param n
+	 *            without &quot;.wfl&quot;
 	 * @return name of the map including fast-find-prefix
 	 */
 	public String setName(String path, String n) {
-		String pref = getFfPrefix();
+		final String pref = getFfPrefix();
 		mapName = pref + n;
 		fileNameWFL = path + pref + mapName + &quot;.wfl&quot;;
 		return mapName;
 	}
 
-	/** 
+	/**
 	 * @return the filename of the associated map image, &quot;&quot; if no file is associated, null if associated file could not be found
 	 */
 	public String getImageFilename() {
-		// if (fileName == null || fileName.length() &gt; 0) return fileName; 
-		if (fileNameWFL.length() == 0) return &quot;&quot;; // no image associated (empty map)
-		String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
+		// if (fileName == null || fileName.length() &gt; 0) return fileName;
+		if (fileNameWFL.length() == 0)
+			return &quot;&quot;; // no image associated (empty map)
+		final String n = fileNameWFL.substring(0, fileNameWFL.lastIndexOf('.'));
 		return Common.getImageName(CacheWolf.STRreplace.replace(n, &quot;//&quot;, &quot;/&quot;));
 	}
 
 	/**
 	 * Method to load a .wfl-file
-	 * @param mapsPath path to the map inclunding / at the end
-	 * @param thisMap name of the map without extension
-	 * @throws IOException when there was a problem reading .wfl-file
-	 * @throws IOException when lat/lon were out of range
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @param mapsPath
+	 *            path to the map inclunding / at the end
+	 * @param thisMap
+	 *            name of the map without extension
+	 * @throws IOException
+	 *             when there was a problem reading .wfl-file
+	 * @throws IOException
+	 *             when lat/lon were out of range
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 	public void loadwfl(String mapsPath, String thisMap) throws IOException, ArithmeticException {
-		FileInputStream instream = new FileInputStream (CacheWolf.STRreplace.replace(mapsPath + thisMap + &quot;.wfl&quot;, &quot;//&quot;, &quot;/&quot;));
-		InputStreamReader in = new InputStreamReader(instream);
-		
+		final FileInputStream instream = new FileInputStream(CacheWolf.STRreplace.replace(mapsPath + thisMap + &quot;.wfl&quot;, &quot;//&quot;, &quot;/&quot;));
+		final InputStreamReader in = new InputStreamReader(instream);
+
 		String line = &quot;&quot;;
 		try {
-			for(int i = 0; i&lt;4;i++){
+			for (int i = 0; i &lt; 4; i++) {
 				line = in.readLine();
 				affine[i] = Common.parseDoubleException(line);
 			}
@@ -198,23 +211,31 @@
 			line = in.readLine();
 			affineTopleft.lonDec = Common.parseDoubleException(line);
 			line = in.readLine();
-			buttomright.latDec = Common.parseDoubleException(line);
+			bottomright.latDec = Common.parseDoubleException(line);
 			line = in.readLine();
-			buttomright.lonDec = Common.parseDoubleException(line);
-			line = in.readLine(); // readLine returns null, if End of File reached
-			if (line != null) coordTrans = Common.parseInt(line);
-			else coordTrans = 0;
+			bottomright.lonDec = Common.parseDoubleException(line);
+			line = in.readLine(); // readLine returns null, if End of File
+									// reached
+			if (line != null)
+				coordTrans = Common.parseInt(line);
+			else
+				coordTrans = 0;
 			fileNameWFL = mapsPath + thisMap + &quot;.wfl&quot;;
-//			fileName = &quot;&quot;; //mapsPath + thisMap + &quot;.png&quot;;
+			// fileName = &quot;&quot;; //mapsPath + thisMap + &quot;.png&quot;;
 			mapName = thisMap;
 			in.close();
-			if( !buttomright.isValid() ) {
-				affine[0] = 0; affine[1] = 0; affine[2] = 0; affine[3] = 0; 
+			if (!bottomright.isValid()) {
+				affine[0] = 0;
+				affine[1] = 0;
+				affine[2] = 0;
+				affine[3] = 0;
 				topleft.makeInvalid();
-				throw (new IOException(MyLocale.getMsg(4301, &quot;Lat/Lon out of range while reading &quot;)+mapsPath + thisMap + &quot;.wfl&quot;));
+				throw (new IOException(MyLocale.getMsg(4301, &quot;Lat/Lon out of range while reading &quot;) + mapsPath + thisMap + &quot;.wfl&quot;));
 			}
-		} catch (NullPointerException e) { // in.readline liefert null zur&#252;ck, wenn keine Daten mehr vorhanden sind
-			throw (new IOException(MyLocale.getMsg(4303, &quot;not enough lines in file &quot;)+mapsPath + thisMap + &quot;.wfl&quot;));
+		} catch (final NullPointerException e) { // in.readline liefert null
+													// zur&#252;ck, wenn keine Daten
+													// mehr vorhanden sind
+			throw (new IOException(MyLocale.getMsg(4303, &quot;not enough lines in file &quot;) + mapsPath + thisMap + &quot;.wfl&quot;));
 		}
 		doCalculations();
 		origAffineUpperLeft = new CWPoint(affineTopleft);
@@ -223,24 +244,30 @@
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight) throws IllegalArgumentException {
 		evalGCP(GCPs, imageWidth, imageHeight, 0);
 	}
-		/**
-	 *	Method to evaluate ground control points (georeferenced points) and identify the parameters
-	 *	for the affine transformation
-	 *  @throws IllegalArgumentException when less than 3 georeferenced points were given in GCPs
+
+	/**
+	 * Method to evaluate ground control points (georeferenced points) and identify the parameters for the affine transformation
+	 * 
+	 * @throws IllegalArgumentException
+	 *             when less than 3 georeferenced points were given in GCPs
 	 */
 
 	public void evalGCP(ewe.util.Vector GCPs, int imageWidth, int imageHeight, int epsg_code) throws IllegalArgumentException {
-		//N 48 16.000 E 11 32.000
-		//N 48 16.000 E 11 50.000
-		//N 48 9.000 E 11 32.000
-		if (GCPs.size() &lt; 3 ) throw new IllegalArgumentException(MyLocale.getMsg(4304, &quot;not enough points to calibrate the map&quot;));
+		// N 48 16.000 E 11 32.000
+		// N 48 16.000 E 11 50.000
+		// N 48 9.000 E 11 32.000
+		if (GCPs.size() &lt; 3)
+			throw new IllegalArgumentException(MyLocale.getMsg(4304, &quot;not enough points to calibrate the map&quot;));
 		GCPoint gcp = new GCPoint();
-		//Calculate parameters for latitutde affine transformation (affine 0,2,4)
-		Matrix X = new Matrix(GCPs.size(),3);
-		Matrix trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i &lt; GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
-			X.matrix[i][0] = 1; X.matrix[i][1] = gcp.bitMapX; X.matrix[i][2] = gcp.bitMapY;
+		// Calculate parameters for latitutde affine transformation (affine
+		// 0,2,4)
+		Matrix X = new Matrix(GCPs.size(), 3);
+		Matrix trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i &lt; GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
+			X.matrix[i][0] = 1;
+			X.matrix[i][1] = gcp.bitMapX;
+			X.matrix[i][2] = gcp.bitMapY;
 			trg.matrix[i][0] = gcp.latDec;
 		}
 		Matrix Xtran = new Matrix(X);
@@ -256,11 +283,12 @@
 		affine[2] = beta.matrix[2][0];
 		affineTopleft.latDec = beta.matrix[0][0];
 
-		//Calculate parameters for longitude affine transformation (affine 1,3,5)
-		X = new Matrix(GCPs.size(),3);
-		trg = new Matrix(GCPs.size(),1);
-		for(int i = 0; i &lt; GCPs.size();i++){
-			gcp = (GCPoint)GCPs.get(i);
+		// Calculate parameters for longitude affine transformation (affine
+		// 1,3,5)
+		X = new Matrix(GCPs.size(), 3);
+		trg = new Matrix(GCPs.size(), 1);
+		for (int i = 0; i &lt; GCPs.size(); i++) {
+			gcp = (GCPoint) GCPs.get(i);
 			X.matrix[i][0] = 1;
 			X.matrix[i][1] = gcp.bitMapX;
 			X.matrix[i][2] = gcp.bitMapY;
@@ -279,130 +307,156 @@
 		affine[3] = beta.matrix[2][0];
 		affineTopleft.lonDec = beta.matrix[0][0];
 		coordTrans = epsg_code;
-		buttomright = calcLatLon(imageWidth, imageHeight);
+		bottomright = calcLatLon(imageWidth, imageHeight);
 		doCalculations();
 	}
 
 	/**
 	 * calculates centre, diagonal size of the map and inverse to affine transformation
-	 * @throws ArithmeticException when affine data is not correct, e.g. it is not possible to inverse affine-transformation
+	 * 
+	 * @throws ArithmeticException
+	 *             when affine data is not correct, e.g. it is not possible to inverse affine-transformation
 	 */
 
 	private void doCalculations() throws ArithmeticException {
 		try {
 			topleft.set(calcLatLon(0, 0));
-			center.set((buttomright.latDec + topleft.latDec)/2,(buttomright.lonDec + topleft.lonDec)/2);
-			sizeKm = java.lang.Math.abs((float)center.getDistance(buttomright)) *2;
+			center.set((bottomright.latDec + topleft.latDec) / 2, (bottomright.lonDec + topleft.lonDec) / 2);
+			sizeKm = java.lang.Math.abs((float) center.getDistance(bottomright)) * 2;
 
-			//calculate reverse affine
-			double nenner=(-affine[1]*affine[2]+affine[0]*affine[3]);
-			transLatX = affine[3]/nenner; // nenner == 0 cannot happen as long als affine is correct
-			transLonX = -affine[2]/nenner;
-			transLatY = -affine[1]/nenner;
-			transLonY = affine[0]/nenner;
+			// calculate reverse affine
+			final double nenner = (-affine[1] * affine[2] + affine[0] * affine[3]);
+			transLatX = affine[3] / nenner; // nenner == 0 cannot happen as long
+											// als affine is correct
+			transLonX = -affine[2] / nenner;
+			transLatY = -affine[1] / nenner;
+			transLonY = affine[0] / nenner;
 
 			// calculate north direction
-			Point c = calcMapXY(center);
-			int heightpixel = c.y * 2;
+			final Point c = calcMapXY(center);
+			final int heightpixel = c.y * 2;
 			c.y -= 1000;
-			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);  // note: the direction of nord can vary across the image. In Gau&#223;-Kr&#252;ger Projection it does change about 1 degree per 10km! //(float)java.lang.Math.atan(rotationX2y);
-			if (rotationRad &gt; Math.PI) rotationRad -= 2* Math.PI;
+			rotationRad = (float) (center.getBearing(calcLatLon(c)) / 180 * Math.PI);
+			// note: the direction of nord can vary across the image.
+			// In Gau&#223;-Kr&#252;ger Projection it does change about 1 degree per 10km!
+			// (float)java.lang.Math.atan(rotationX2y);
+			if (rotationRad &gt; Math.PI)
+				rotationRad -= 2 * Math.PI;
 
 			// calculate scale in meters per pixel
-			double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
+			final double heightkm = calcLatLon(0, heightpixel).getDistance(topleft);
 			scale = (float) (heightkm * 1000 / heightpixel);
-		} catch (ArithmeticException ex) { throw new ArithmeticException(MyLocale.getMsg(4305, &quot;Not allowed values in affine\n (matrix cannot be inverted)\n in file \n&quot;) + fileNameWFL); }
+		} catch (final ArithmeticException ex) {
+			throw new ArithmeticException(MyLocale.getMsg(4305, &quot;Not allowed values in affine\n (matrix cannot be inverted)\n in file \n&quot;) + fileNameWFL);
+		}
 	}
 
 	public void saveWFL() throws IOException, IllegalArgumentException {
-		File dateiF = new FileBugfix(fileNameWFL);
-		String tmp = dateiF.getDrivePath(); // contains the name and the extension
+		final File dateiF = new FileBugfix(fileNameWFL);
+		final String tmp = dateiF.getDrivePath(); // contains the name and the
+													// extension
 		saveWFL(tmp, mapName);
 	}
 
 	/**
-	 *	Method to save a world file (.wfl)
-	 * @param mapsPath without &quot;/&quot; at the end
-	 * @param mapFileName without file extension
-	 * @throws IOException when there was a problem writing .wfl-file
-	 * @throws IllegalArgumentException when affine[x] for all x == 0 (&quot;map not calibrated&quot;).
+	 * Method to save a world file (.wfl)
+	 * 
+	 * @param mapsPath
+	 *            without &quot;/&quot; at the end
+	 * @param mapFileName
+	 *            without file extension
+	 * @throws IOException
+	 *             when there was a problem writing .wfl-file
+	 * @throws IllegalArgumentException
+	 *             when affine[x] for all x == 0 (&quot;map not calibrated&quot;).
 	 */
 	public void saveWFL(String mapsPath, String mapFileName) throws IOException, IllegalArgumentException {
-		if (affine[0]==0 &amp;&amp; affine[1]==0 &amp;&amp; affine[2]==0 &amp;&amp; affine[3]==0 &amp;&amp; 
-				!topleft.isValid()) throw (new IllegalArgumentException(MyLocale.getMsg(4306, &quot;map not calibrated&quot;)));
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;)));
-		StringBuffer towriteB=new StringBuffer(400);
+		if (mapsPath.endsWith(&quot;/&quot;)) {
+			mapsPath = mapsPath.substring(0, mapsPath.length() - 1);
+		}
+		if (affine[0] == 0 &amp;&amp; affine[1] == 0 &amp;&amp; affine[2] == 0 &amp;&amp; affine[3] == 0 &amp;&amp; !topleft.isValid())
+			throw (new IllegalArgumentException(MyLocale.getMsg(4306, &quot;map not calibrated&quot;)));
+		final PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;)));
+		final StringBuffer towriteB = new StringBuffer(400);
 		towriteB.append(Convert.toString(affine[0])).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(affine[1])).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(affine[2])).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(affine[3])).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(affineTopleft.latDec)).append(&quot;\n&quot;);
 		towriteB.append(Convert.toString(affineTopleft.lonDec)).append(&quot;\n&quot;);
-		towriteB.append(Convert.toString(buttomright.latDec)).append(&quot;\n&quot;);
-		towriteB.append(Convert.toString(buttomright.lonDec)).append(&quot;\n&quot;);
-		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? &quot;&quot; : Convert.toString(coordTrans)+&quot;\n&quot;));
+		towriteB.append(Convert.toString(bottomright.latDec)).append(&quot;\n&quot;);
+		towriteB.append(Convert.toString(bottomright.lonDec)).append(&quot;\n&quot;);
+		towriteB.append(((coordTrans == 0 || coordTrans == TransformCoordinates.EPSG_WGS84) ? &quot;&quot; : Convert.toString(coordTrans) + &quot;\n&quot;));
 		String towrite = towriteB.toString();
-		if (digSep.equals(&quot;,&quot;)) towrite=towrite.replace(',', '.');
+		if (digSep.equals(&quot;,&quot;))
+			towrite = towrite.replace(',', '.');
 		outp.print(towrite);
 		outp.close();
-//		this.fileName = &quot;&quot;; // this will be set in getImageFilenam //mapsPath + &quot;/&quot; + mapFileName + &quot;.png&quot;;
+		// this.fileName = &quot;&quot;; // this will be set in getImageFilenam //mapsPath
+		// + &quot;/&quot; + mapFileName + &quot;.png&quot;;
 		this.fileNameWFL = mapsPath + &quot;/&quot; + mapFileName + &quot;.wfl&quot;;
 		this.mapName = mapFileName;
 	}
 
-
 	/**
 	 * zoom in / out
-	 * @param zf zf &gt; 1 == zoom in, zoom is relative to original unscaled image
-	 * @param diffX shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
+	 * 
+	 * @param zf
+	 *            zf &gt; 1 == zoom in, zoom is relative to original unscaled image
+	 * @param diffX
+	 *            shift of map in pixels (if the map was cropped while zooming) in the not zoomed image
 	 * @param diffY
 	 */
 	public void zoom(float zf, int diffX, int diffY) {
 		// restore original values to calculate corret shift (upperleft)
 		affineTopleft.latDec = origAffineUpperLeft.latDec;
 		affineTopleft.lonDec = origAffineUpperLeft.lonDec;
-		affine[0] = affine[0] * zoomFactor; 
-		affine[1] = affine[1] * zoomFactor; 
+		affine[0] = affine[0] * zoomFactor;
+		affine[1] = affine[1] * zoomFactor;
 		affine[2] = affine[2] * zoomFactor;
 		affine[3] = affine[3] * zoomFactor;
 		TrackPoint upperleft = calcLatLon(diffX, diffY);
-		if (coordTrans != 0) upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
-		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken affineTopleft
+		if (coordTrans != 0)
+			upperleft = TransformCoordinatesProperties.fromWgs84(upperleft, coordTrans);
+		affineTopleft.latDec = upperleft.latDec; // TODO nachdenken
+													// affineTopleft
 		affineTopleft.lonDec = upperleft.lonDec;
-		affine[0] = affine[0] / zf ; 
-		affine[1] = affine[1] / zf ; 
-		affine[2] = affine[2] / zf ; 
-		affine[3] = affine[3] / zf ; 
-		zoomFactor = zf ;
+		affine[0] = affine[0] / zf;
+		affine[1] = affine[1] / zf;
+		affine[2] = affine[2] / zf;
+		affine[3] = affine[3] / zf;
+		zoomFactor = zf;
 		shift.x = diffX;
 		shift.y = diffY;
 		doCalculations(); // TODO lowlat neu berechnen?
 	}
 
 	/**
-	 * Method to calculate bitmap x,y of the current map using
-	 * lat and lon target coordinates. There ist no garanty that
-	 * the returned coordinates are inside of the map. They can be negative.
+	 * Method to calculate bitmap x,y of the current map using lat and lon target coordinates. There ist no garanty that the returned coordinates are inside of the map. They can be negative.
+	 * 
 	 * @param lat
 	 * @param lon
 	 */
-	public Point calcMapXY(TrackPoint ll){
+	public Point calcMapXY(TrackPoint ll) {
 		TrackPoint t;
-		if (coordTrans != 0) t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
-		else t = ll;
-		Point coords = new Point();
+		if (coordTrans != 0)
+			t = TransformCoordinatesProperties.fromWgs84(ll, coordTrans);
+		else
+			t = ll;
+		final Point coords = new Point();
 		double b0, b1;
 		b0 = t.latDec - affineTopleft.latDec;
 		b1 = t.lonDec - affineTopleft.lonDec;
-		double mapx = transLatX * b0 + transLonX * b1;
-		double mapy = transLatY * b0 + transLonY * b1;
-		coords.x = (int)Math.round(mapx);
-		coords.y = (int)Math.round(mapy);
+		final double mapx = transLatX * b0 + transLonX * b1;
+		final double mapy = transLatY * b0 + transLonY * b1;
+		coords.x = (int) Math.round(mapx);
+		coords.y = (int) Math.round(mapy);
 		return coords;
 	}
 
 	/**
 	 * gives back lat/lon from x, y in map
+	 * 
 	 * @param x
 	 * @param y
 	 * @return
@@ -415,51 +469,49 @@
 			ll = TransformCoordinatesProperties.toWgs84(ll, coordTrans);
 		return ll;
 	}
-	
+
 	public CWPoint calcLatLon(Point p) {
 		return calcLatLon(p.x, p.y);
 	}
 
 	/**
-	 * Get the prefix used for easy and fast finding of the best map
-	 * The filname of the .wfl and respective image should start with this
-	 * prefix in order to make finding the best map much faster 
+	 * Get the prefix used for easy and fast finding of the best map The filname of the .wfl and respective image should start with this prefix in order to make finding the best map much faster
+	 * 
 	 * @return
 	 */
 	public String getFfPrefix() {
-		return &quot;FF1&quot;+getEasyFindString()+&quot;E-&quot;;
+		return &quot;FF1&quot; + getEasyFindString() + &quot;E-&quot;;
 	}
 }
 
-	/**
-	 *	Class based on CWPoint but intended to handle bitmap x and y
-	 *	Used for georeferencing bitmaps.
-	 */
-	class GCPoint extends CWPoint{
-		public int bitMapX = 0;
-		public int bitMapY = 0;
+/**
+ * Class based on CWPoint but intended to handle bitmap x and y Used for georeferencing bitmaps.
+ */
+class GCPoint extends CWPoint {
+	public int bitMapX = 0;
+	public int bitMapY = 0;
 
-		public GCPoint(){ // Public constructor
-		}
+	public GCPoint() { // Public constructor
+	}
 
-		public GCPoint(CWPoint p) {
-			super(p);
-		}
+	public GCPoint(CWPoint p) {
+		super(p);
+	}
 
-		/**
-		 * If you are using Gau&#223;-Kr&#252;ger, put lat = northing, lon = easting 
-		 * @param lat
-		 * @param lon
-		 */
-		public GCPoint(double lat, double lon){
-			this.latDec = lat;
-			this.lonDec = lon;
-		}
-		
-		public GCPoint(CWPoint ll, Point px) {
-			super(ll);
-			bitMapX = px.x;
-			bitMapY = px.y;
-		}
+	/**
+	 * If you are using Gau&#223;-Kr&#252;ger, put lat = northing, lon = easting
+	 * 
+	 * @param lat
+	 * @param lon
+	 */
+	public GCPoint(double lat, double lon) {
+		this.latDec = lat;
+		this.lonDec = lon;
 	}
-	
\ No newline at end of file
+
+	public GCPoint(CWPoint ll, Point px) {
+		super(ll);
+		bitMapX = px.x;
+		bitMapY = px.y;
+	}
+}

Modified: branches/r1.2/src/CacheWolf/navi/MapLoader.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapLoader.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapLoader.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,70 +1,71 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import CacheWolf.HttpConnection;
 import CacheWolf.InfoBox;
 import CacheWolf.MyLocale;
 import CacheWolf.STRreplace;
+import CacheWolf.UrlFetcher;
 import CacheWolf.utils.FileBugfix;
 import ewe.fx.Point;
+import ewe.io.BufferedWriter;
 import ewe.io.File;
 import ewe.io.FileBase;
 import ewe.io.FileInputStream;
-import ewe.io.FileOutputStream;
+import ewe.io.FileReader;
+import ewe.io.FileWriter;
 import ewe.io.IOException;
-import ewe.net.Socket;
+import ewe.io.PrintWriter;
 import ewe.sys.Convert;
 import ewe.sys.Double;
 import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.FormBase;
 import ewe.ui.MessageBox;
-import ewe.util.ByteArray;
 import ewe.util.Properties;
 import ewe.util.StandardComparer;
 import ewe.util.Utils;
 import ewe.util.Vector;
 import ewe.util.mString;
 
-
 /**
- *
+ * 
  * start offset for language file: 4800
  */
 
-//Um Karten zu holen!
-//<A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|</A>
-//oder
-//<A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||</A>
+// Um Karten zu holen!
+// <A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.09901667,11.35688333&amp;Lang=EUR0407&amp;Alti=1&amp;Size=600,600&amp;Offs=0.000000,0.000000&amp;Pins=|5748|</A>
+// oder
+// <A HREF="http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||">http://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.&amp;CenP=48.15,11.5833&amp;Alti=2&amp;Lang=EUR0407&amp;Size=900,900&amp;Offs=0,0&amp;MapS=0&amp;Pins=|48.15,11.5833|4|48.15,11.5833&amp;Pins=|48.15,11.5833|1|48.15,%2011.5833||</A>
 
-
 public class MapLoader {
 	InfoBox progressInfobox;
 
@@ -75,17 +76,19 @@
 	double latinc;
 	double loninc;
 	CWPoint topleft;
-	CWPoint buttomright;
+	CWPoint bottomright;
 	Point tilesSize;
 	float tileScale;
+	boolean fetchOnlyMapWithCache = false;
 
 	/**
-	 *
+	 * 
 	 * @param prxy
 	 * @param prt
-	 * @param wmspath without trailing &quot;/&quot;
+	 * @param wmspath
+	 *            without trailing &quot;/&quot;
 	 */
-	public MapLoader(String wmspath){
+	public MapLoader(String wmspath) {
 		long start = new Time().getTime();
 		InfoBox progressBox = null;
 		boolean showprogress = false;
@@ -96,11 +99,11 @@
 		String FileName;
 		OnlineMapService tempOMS;
 		MessageBox f = null;
-		dateien = files.list(&quot;*.wms&quot;, FileBase.LIST_FILES_ONLY); //&quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
-		for(int i = 0; i &lt; dateien.length;i++){
+		dateien = files.list(&quot;*.wms&quot;, FileBase.LIST_FILES_ONLY); // &quot;*.xyz&quot; doesn't work on some systems -&gt; use FileBugFix
+		for (int i = 0; i &lt; dateien.length; i++) {
 			FileName = dateien[i];
 			try {
-				if (!showprogress &amp;&amp; ((i &amp; 0) == 0) &amp;&amp; (new Time().getTime()-start  &gt; 100) ) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
+				if (!showprogress &amp;&amp; ((i &amp; 0) == 0) &amp;&amp; (new Time().getTime() - start &gt; 100)) { // reason for (i &amp; 7 == 0): test time only after i is incremented 15 times
 					showprogress = true;
 					progressBox = new InfoBox(MyLocale.getMsg(327, &quot;Info&quot;), MyLocale.getMsg(4800, &quot;Loading online map services&quot;));
 					progressBox.exec();
@@ -109,8 +112,9 @@
 				}
 				tempOMS = new WebMapService(STRreplace.replace(wmspath + &quot;/&quot; + FileName, &quot;//&quot;, &quot;/&quot;));
 				onlineMapServices.add(tempOMS);
-			}catch(Exception ex){
-				if (f == null) (f=new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4801, &quot;Ignoring error while \n reading web map service definition file \n&quot;)+ex.toString(), FormBase.OKB)).exec();
+			} catch (Exception ex) {
+				if (f == null)
+					(f = new MessageBox(MyLocale.getMsg(144, &quot;Warning&quot;), MyLocale.getMsg(4801, &quot;Ignoring error while \n reading web map service definition file \n&quot;) + ex.toString(), FormBase.OKB)).exec();
 			}
 		}
 		tempOMS = new ExpediaMapService();
@@ -121,26 +125,33 @@
 		}
 	}
 
-	public String[] getAvailableOnlineMapServices(){
+	public void setFetchOnlyMapWithCache(boolean value) {
+		fetchOnlyMapWithCache = value;
+	}
+
+	public String[] getAvailableOnlineMapServices() {
 		int s = onlineMapServices.size();
 		String[] services = new String[s];
-		for (int i=0; i &lt; s; i++) {
-			services[i]=onlineMapServices.get(i).toString();
+		for (int i = 0; i &lt; s; i++) {
+			services[i] = onlineMapServices.get(i).toString();
 		}
 		return services;
 	}
 
 	public void setCurrentMapService(int index) {
-		if (index==-1) index=0; // if no center set
+		if (index == -1)
+			index = 0; // if no center set
 		currentOnlineMapService = (OnlineMapService) onlineMapServices.get(index);
 	}
 
 	/**
 	 * calculates the Expedia Alti = scale which fits in distance to its edges
+	 * 
 	 * @param center
-	 * @param distance in meters
+	 * @param distance
+	 *            in meters
 	 * @return meters per pixel calculatet in a way that the circle around center
-	 * is completly within the map
+	 *         is completly within the map
 	 */
 
 	public static float getScale(CWPoint center, float distance, Point size) {
@@ -153,59 +164,66 @@
 	/**
 	 * download maps from expedia at zoomlevel alti and save the maps and the .wfl
 	 * in path
-	 * @param center centre of all tiles
-	 * @param radius in meters
-	 * @param scale in &quot;alti&quot; value 1 alti =  3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
-	 * @param size in pixels
-	 * @param overlapping in pixels
-	 * @param path without &quot;/&quot; at the end
-	 *
+	 * 
+	 * @param center
+	 *            centre of all tiles
+	 * @param radius
+	 *            in meters
+	 * @param scale
+	 *            in &quot;alti&quot; value 1 alti = 3950 /2817.947378 = 1,046861280317350198581316446428 meters per pixel
+	 * @param size
+	 *            in pixels
+	 * @param overlapping
+	 *            in pixels
+	 * @param path
+	 *            without &quot;/&quot; at the end
+	 * 
 	 */
-	public void setTiles (CWPoint center, float radius, float scale, Point size, int overlapping) {
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec/180*java.lang.Math.PI);
+	public void setTiles(CWPoint center, float radius, float scale, Point size, int overlapping) {
+		double metersPerLat = (1000 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos(center.latDec / 180 * java.lang.Math.PI);
 		topleft = new CWPoint(center.latDec + (radius / metersPerLat), center.lonDec - (radius / metersPerLon));
-		buttomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
+		bottomright = new CWPoint(center.latDec - (radius / metersPerLat), center.lonDec + (radius / metersPerLon));
 
-		this.setTiles(topleft, buttomright, scale, size, overlapping);
+		this.setTiles(topleft, bottomright, scale, size, overlapping);
 	}
 
-	public void setTiles(CWPoint toplefti, CWPoint buttomrighti, float scale, Point size, int overlapping) {
-		//if (toplefti.latDec &lt;= buttomrighti.latDec || toplefti.lonDec &gt;= toplefti.lonDec) throw new IllegalArgumentException(&quot;topleft must be left and above buttom right&quot;);
+	public void setTiles(CWPoint toplefti, CWPoint bottomrighti, float scale, Point size, int overlapping) {
+		// if (toplefti.latDec &lt;= bottomrighti.latDec || toplefti.lonDec &gt;= toplefti.lonDec) throw new IllegalArgumentException(&quot;topleft must be left and above bottom right&quot;);
 		topleft = new CWPoint(toplefti);
-		buttomright = new CWPoint(buttomrighti);
-		double metersPerLat = (1000*(new CWPoint(0,0)).getDistance(new CWPoint(1,0)));
-		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + buttomright.latDec)/2/180*java.lang.Math.PI);
+		bottomright = new CWPoint(bottomrighti);
+		double metersPerLat = (1000.0 * (new CWPoint(0, 0)).getDistance(new CWPoint(1, 0)));
+		double metersPerLon = metersPerLat * java.lang.Math.cos((toplefti.latDec + bottomright.latDec) / 2 / 180 * java.lang.Math.PI);
 		double metersperpixel = currentOnlineMapService.getMetersPerPixel(scale);
 		double pixelsPerLat = metersPerLat / metersperpixel;
 		double pixelsPerLon = metersPerLon / metersperpixel;
 
-		//over all pixelsize without borders
-		double pixelsY = (topleft.latDec - buttomright.latDec) * pixelsPerLat;
-		double pixelsX = -(topleft.lonDec - buttomright.lonDec) * pixelsPerLon ;
+		// over all pixelsize without borders
+		double pixelsY = (topleft.latDec - bottomright.latDec) * pixelsPerLat;
+		double pixelsX = -(topleft.lonDec - bottomright.lonDec) * pixelsPerLon;
 
-		//border sizes around given area and overlapping between tiles
-		//int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
-		//int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
+		// border sizes around given area and overlapping between tiles
+		// int borderX = (int) java.lang.Math.round((float)size.x * (overlapping - 1.0));
+		// int borderY = (int) java.lang.Math.round((float)size.y * (overlapping - 1.0));
 		int borderX = overlapping;
 		int borderY = overlapping;
 
-		numMapsY = (int) java.lang.Math.ceil( (pixelsY + borderY) / (size.y - borderY) );
-		numMapsX = (int) java.lang.Math.ceil( (pixelsX + borderX) / (size.x - borderX) );
+		numMapsY = (int) java.lang.Math.ceil((pixelsY + borderY) / (size.y - borderY));
+		numMapsX = (int) java.lang.Math.ceil((pixelsX + borderX) / (size.x - borderX));
 
-		//increments calulated from pixel offset of tiles
+		// increments calulated from pixel offset of tiles
 		latinc = -(size.y - borderY) / pixelsPerLat;
 		loninc = (size.x - borderX) / pixelsPerLon;
 
-		//calculation of centre of first tile
+		// calculation of centre of first tile
 
-		//additional size for borders and rounding
+		// additional size for borders and rounding
 		double oversizeX = (numMapsX * (size.x - borderX) + borderX) - pixelsX;
 		double oversizeY = (numMapsY * (size.y - borderY) + borderY) - pixelsY;
 
-		//offset for upper left corner
-		double offsetLat = -( (size.y - oversizeY) / 2.0 ) / pixelsPerLat;
-		double offsetLon = ( (size.x - oversizeX) / 2.0 ) / pixelsPerLon;
+		// offset for upper left corner
+		double offsetLat = -((size.y - oversizeY) / 2.0) / pixelsPerLat;
+		double offsetLon = ((size.x - oversizeX) / 2.0) / pixelsPerLon;
 
 		topleft.latDec += offsetLat;
 		topleft.lonDec += offsetLon;
@@ -222,82 +240,285 @@
 		for (int row = 1; row &lt;= numMapsY; row++) {
 			lon = topleft.lonDec;
 			for (int col = 1; col &lt;= numMapsX; col++) {
-				if (progressInfobox != null)
-					progressInfobox.setInfo(MyLocale.getMsg(4802, &quot;Downloading calibrated (georeferenced) \n map image \n '&quot;) + currentOnlineMapService.getName()+MyLocale.getMsg(4803, &quot;' \n Downloading tile \n row&quot;)+&quot; &quot;+row+&quot; / &quot;+numMapsY+MyLocale.getMsg(4804, &quot; column&quot;)+&quot; &quot;+ col + &quot; / &quot;+numMapsX);
 				center.set(lat, lon);
-				try {
-					downloadMap(center, tileScale, tilesSize, tilesPath);
-				} catch (Exception e) {
-					this.progressInfobox.addWarning(MyLocale.getMsg(4805, &quot;Tile&quot;)+&quot; &quot; + row + &quot;/&quot; + col + MyLocale.getMsg(4806, &quot;: Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+				if (!fetchOnlyMapWithCache || hasCache(center, latinc, loninc)) {
+					if (progressInfobox != null)
+						progressInfobox.setInfo(MyLocale.getMsg(4802, &quot;Downloading calibrated (georeferenced) \n map image \n '&quot;) + currentOnlineMapService.getName() + MyLocale.getMsg(4803, &quot;' \n Downloading tile \n row&quot;) + &quot; &quot; + row + &quot; / &quot; + numMapsY
+								+ MyLocale.getMsg(4804, &quot; column&quot;) + &quot; &quot; + col + &quot; / &quot; + numMapsX);
+					try {
+						downloadMap(center, tileScale, tilesSize, tilesPath);
+					} catch (Exception e) {
+						this.progressInfobox.addWarning(MyLocale.getMsg(4805, &quot;Tile&quot;) + &quot; &quot; + row + &quot;/&quot; + col + MyLocale.getMsg(4806, &quot;: Ignoring error:&quot;) + &quot; &quot; + e.getMessage() + &quot;\n&quot;);
+					}
+					if (progressInfobox.isClosed)
+						return;
 				}
-				if (progressInfobox.isClosed) return;
 				lon += loninc;
 			}
 			lat += latinc;
 		}
 	}
 
-	public void setProgressInfoBox (InfoBox progrssInfoboxi) {
+	private boolean hasCache(CWPoint center, double latinc, double loninc) {
+		double lat = center.latDec - (latinc / 2.0);
+		double lon = center.lonDec - (loninc / 2.0);
+		CWPoint tl = new CWPoint(lat, lon);
+		lat = center.latDec + (latinc / 2.0);
+		lon = center.lonDec + (loninc / 2.0);
+		CWPoint br = new CWPoint(lat, lon);
+		Area maparea = new Area(tl, br);
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		for (int i = 0; i &lt; cacheDB.size(); i++) {
+			CacheHolder ch = cacheDB.get(i);
+			if (maparea.isInBound(ch.getPos())) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public void setProgressInfoBox(InfoBox progrssInfoboxi) {
 		progressInfobox = progrssInfoboxi;
 	}
+
 	/**
-	 *
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
-	 * @param path must include trailing &quot;/&quot;
+	 * @param path
+	 *            must include trailing &quot;/&quot;
 	 * @throws Exception
 	 */
 	public void downloadMap(CWPoint center, float scale, Point pixelsize, String path) throws Exception {
 		MapInfoObject mio = currentOnlineMapService.getMapInfoObject(center, scale, pixelsize);
 		String filename = createFilename(mio.getCenter(), mio.scale);
-		String imagename = mio.setName(path, filename) + currentOnlineMapService.getImageFileExt();
+		String imagename = mio.setName(path, filename);
+		String imagetype = currentOnlineMapService.getImageFileExt();
 		String url = currentOnlineMapService.getUrlForCenterScale(center, scale, pixelsize);
-		if (currentOnlineMapService instanceof ExpediaMapService) {
-			downloadImage(url, path+imagename);
-			mio.saveWFL();
-		}
-		else {
-			WebMapService wms = (WebMapService) currentOnlineMapService;
-			if (wms.requestUrlPart.equalsIgnoreCase(&quot;Kosmos&quot;)) {
-				url=&quot;bitmapgen&quot;+
-					&quot; \&quot;&quot;+FileBase.getProgramDirectory().replace('/',File.separatorChar)+&quot;\\&quot;+wms.serviceTypeUrlPart+&quot;\&quot;&quot;+
-					&quot; \&quot;&quot;+path.replace('/', File.separatorChar)+imagename+&quot;\&quot;&quot;+
-					&quot; -mb &quot;+url; // + minx miny maxx maxy + pixelsize.x
-				File f=new FileBugfix(wms.MainUrl);
-				if (!f.exists() || !f.canRead()) {
-					MessageBox mb=new MessageBox(MyLocale.getMsg(321,&quot;Error&quot;),MyLocale.getMsg(1834,&quot;Please enter the correct path to Kosmos.Console.exe into the wms-file.&quot;),ewe.ui.MessageBox.OKB);
-					mb.execute();
+		String fName = path + imagename + imagetype;
+		FileBugfix fn = new FileBugfix(path + imagename + &quot;.wfl&quot;);
+		FileBugfix fn1 = new FileBugfix(fName);
+		if (!fn.exists() || fn.length() == 0 || !fn1.exists() || fn1.length() == 0) {
+			if (currentOnlineMapService instanceof ExpediaMapService) {
+				downloadImage(url, path + imagename + imagetype);
+			} else {
+				WebMapService wms = (WebMapService) currentOnlineMapService;
+				if (wms.requestUrlPart.startsWith(&quot;REQUEST&quot;)) {
+					downloadImage(url, path + imagename + imagetype);
 				} else {
-					Vm.exec(wms.MainUrl.replace('/', File.separatorChar), url, 0, true);
-					mio.saveWFL();
+					Area maparea = wms.CenterScaleToArea(center, scale, pixelsize);
+					CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+					CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+
+					String mapProgramPath = wms.versionUrlPart + &quot;/&quot;;
+					mapProgramPath = mapProgramPath.replace('/', FileBase.separatorChar);
+					String mapProgram = mapProgramPath + wms.MainUrl;
+					File f = new FileBugfix(mapProgram);
+					if (!f.exists() || !f.canRead()) {
+						MessageBox mb = new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1834, &quot;Please enter the correct path to Kosmos.Console.exe into the wms-file.&quot;), ewe.ui.MessageBox.OKB);
+						mb.execute();
+						return;
+					}
+
+					String mapProgramParams = &quot;&quot;;
+
+					if (wms.requestUrlPart.equalsIgnoreCase(&quot;Kosmos&quot;)) {
+						// minx miny maxx maxy + pixelsize.x
+						mapProgramParams = &quot;bitmapgen&quot; + &quot; \&quot;&quot; + FileBase.getProgramDirectory().replace('/', File.separatorChar) + &quot;\\&quot; + wms.serviceTypeUrlPart + &quot;\&quot;&quot; + &quot; \&quot;&quot; + path.replace('/', File.separatorChar) + imagename + imagetype + &quot;\&quot;&quot;
+								+ &quot; -mb &quot; + bottomleft.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + &quot; &quot; + topright.toString(TransformCoordinates.LAT_LON).replace(',', ' ') + &quot; -w &quot; + pixelsize.x;
+						Vm.exec(mapProgram, mapProgramParams, 0, true);
+					} else {
+						if (wms.requestUrlPart.equalsIgnoreCase(&quot;Maperitive&quot;)) {
+							// Maperitive runs on Windows and Linux
+							// generating scriptfile for Maperitive from wmsfile
+							String cwPath = FileBase.getProgramDirectory().replace('/', FileBase.separatorChar) + FileBase.separatorChar;
+							String scriptFileName = cwPath + &quot;maperitive.script&quot;;
+
+							PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(scriptFileName)));
+							outp.println(&quot;use-ruleset alias=default&quot;);
+							outp.println(&quot;clear-map&quot;);
+
+							if (wms.serviceTypeUrlPart.equals(&quot;&quot;)) {
+								outp.println(&quot;add-web-map&quot;);
+							} else {
+								outp.println(&quot;add-web-map provider=&quot; + wms.serviceTypeUrlPart);
+							}
+
+							if (!wms.stylesUrlPart.equals(&quot;&quot;)) {
+								String myrules = mapProgramPath + wms.stylesUrlPart.replace('/', FileBase.separatorChar);
+								outp.println(&quot;use-ruleset location=&quot; + myrules);
+								// outp.println(&quot;apply-ruleset&quot;);
+							}
+							if (!wms.layersUrlPart.equals(&quot;&quot;)) {
+								outp.println(&quot;clear-map&quot;);
+								outp.println(&quot;load-source &quot; + mapProgramPath + wms.layersUrlPart.replace('/', FileBase.separatorChar));
+								// implicit does apply-ruleset
+							}
+
+							String koords = bottomleft.toString(TransformCoordinates.LON_LAT) + &quot;,&quot; + topright.toString(TransformCoordinates.LON_LAT);
+							outp.println(&quot;bounds-set &quot; + koords);
+							outp.println(&quot;zoom-bounds&quot;);
+							if (path.indexOf(':') == 1) {
+								outp.print(&quot;export-bitmap file=&quot; + &quot;\&quot;&quot; + fName + &quot;\&quot;&quot;);
+							} else {
+								outp.print(&quot;export-bitmap file=&quot; + fName);
+							}
+							outp.print(&quot; bounds=&quot; + koords);
+							String pxSize = &quot; width=&quot; + pixelsize.x + &quot; height=&quot; + pixelsize.y;
+							outp.print(pxSize);
+							outp.println(&quot; kml=false&quot;);
+							outp.close();
+							// executing the generated script
+							if (mapProgram.indexOf(':') == 1) {
+								mapProgramParams = &quot;-exitafter &quot; + &quot;\&quot;&quot; + scriptFileName + &quot;\&quot;&quot;;
+							} else {
+								mapProgramParams = &quot;-exitafter &quot; + scriptFileName;
+							}
+							Vm.exec(mapProgram, mapProgramParams, 0, true);
+							// preparation for generating wfl from the ozi map-file
+							Vector GCPs = map2wfl(path + imagename);
+							mio.evalGCP(GCPs, pixelsize.x, pixelsize.y);
+							// can not supress genaration of pgw,jgw-file
+							FileBugfix pgwFile = new FileBugfix(path + imagename + &quot;.pgw&quot;); // seems to bee for png
+							pgwFile.delete();
+							FileBugfix jgwFile = new FileBugfix(path + imagename + &quot;.jgw&quot;); // seems to bee for jpg
+							jgwFile.delete();
+						}
+					}
 				}
 			}
-			else {
-				downloadImage(url, path+imagename);
-				mio.saveWFL();
+			mio.saveWFL();
+		}
+	}
+
+	private Vector map2wfl(String pathAndImageName) {
+		Vector GCPs = new Vector();
+		File mapFile = new File(pathAndImageName + &quot;.map&quot;);
+		if (mapFile.exists()) {
+			GCPoint gcp1 = new GCPoint();
+			GCPoint gcp2 = new GCPoint();
+			GCPoint gcp3 = new GCPoint();
+			GCPoint gcp4 = new GCPoint();
+			GCPoint gcpG = new GCPoint();
+			String line = &quot;&quot;;
+			String[] parts;
+			try {
+				FileReader inMap = new FileReader(pathAndImageName + &quot;.map&quot;);
+				while ((line = inMap.readLine()) != null) {
+					if (line.equals(&quot;MMPNUM,4&quot;)) {
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp1.bitMapX = Convert.toInt(parts[2]);
+						gcp1.bitMapY = Convert.toInt(parts[3]);
+						if (gcp1.bitMapX == 0)
+							gcp1.bitMapX = 1;
+						if (gcp1.bitMapY == 0)
+							gcp1.bitMapY = 1;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp2.bitMapX = Convert.toInt(parts[2]);
+						gcp2.bitMapY = Convert.toInt(parts[3]);
+						if (gcp2.bitMapX == 0)
+							gcp2.bitMapX = 1;
+						if (gcp2.bitMapY == 0)
+							gcp2.bitMapY = 1;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp3.bitMapX = Convert.toInt(parts[2]);
+						gcp3.bitMapY = Convert.toInt(parts[3]);
+						if (gcp3.bitMapX == 0)
+							gcp3.bitMapX = 1;
+						if (gcp3.bitMapY == 0)
+							gcp3.bitMapY = 1;
+						// imageWidth = gcp3.bitMapX;
+						// imageHeight = gcp3.bitMapY;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						gcp4.bitMapX = Convert.toInt(parts[2]);
+						gcp4.bitMapY = Convert.toInt(parts[3]);
+						if (gcp4.bitMapX == 0)
+							gcp4.bitMapX = 1;
+						if (gcp4.bitMapY == 0)
+							gcp4.bitMapY = 1;
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp1.bitMapX;
+						gcpG.bitMapY = gcp1.bitMapY;
+						GCPs.add(gcpG);
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp2.bitMapX;
+						gcpG.bitMapY = gcp2.bitMapY;
+						GCPs.add(gcpG);
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp3.bitMapX;
+						gcpG.bitMapY = gcp3.bitMapY;
+						GCPs.add(gcpG);
+
+						line = inMap.readLine();
+						parts = mString.split(line, ',');
+						if (MyLocale.getDigSeparator().equals(&quot;,&quot;)) {
+							parts[3] = parts[3].replace('.', ',');
+							parts[2] = parts[2].replace('.', ',');
+						}
+						gcpG = new GCPoint(Convert.toDouble(parts[3]), Convert.toDouble(parts[2]));
+						gcpG.bitMapX = gcp4.bitMapX;
+						gcpG.bitMapY = gcp4.bitMapY;
+						GCPs.add(gcpG);
+					} // if
+				} // while
+				inMap.close();
+			} catch (IllegalArgumentException ex) { // is thrown from Convert.toDouble and saveWFL if affine[0-5]==0 NumberFormatException is a subclass of IllegalArgumentExepction
+				Global.getPref().log(MyLocale.getMsg(4117, &quot;Error while importing .map-file: &quot;), ex);
+			} catch (IOException ex) {
+				Global.getPref().log(MyLocale.getMsg(4118, &quot;IO-Error while reading or writing calibration file&quot;), ex);
 			}
+			mapFile.delete();
+		} else { // if map file.exists
+			Global.getPref().log(MyLocale.getMsg(4119, &quot;No calibration file found for: &quot;), null);
 		}
+		return GCPs;
 	}
 
 	public String createFilename(CWPoint center, float scale) {
-		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem()+&quot;_s&quot;+Common.DoubleToString(scale,0,1)
-				+ &quot;_c&quot; + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
+		String filename = Common.ClearForFileName(currentOnlineMapService.getNameForFileSystem() + &quot;_s&quot; + Common.DoubleToString(scale, 0, 1) + &quot;_c&quot; + center.toString(TransformCoordinates.LAT_LON).replace(',', '-'));
 		return filename;
 	}
 
 	/**
-	 * @param url usual URL. If a redirect is requiered (as in the case of
-	 * Expedia, add an &quot;R&quot; before &quot;<A HREF="http://">http://</A>&quot; --&gt; Don't download the url, retry until getting a http-redirect
-	 * this is necessary for expedia as it delivers the image only after a http-redirect
-	 * and sometimes doesn't send a redirect on the first try
-	 * @param datei path and name of file to save to
+	 * @param url
+	 *            usual URL. If a redirect is requiered (as in the case of
+	 *            Expedia, add an &quot;R&quot; before &quot;<A HREF="http://">http://</A>&quot; --&gt; Don't download the url, retry until getting a http-redirect
+	 *            this is necessary for expedia as it delivers the image only after a http-redirect
+	 *            and sometimes doesn't send a redirect on the first try
+	 * @param datei
+	 *            path and name of file to save to
 	 */
 	public void downloadImage(String url, String datei) throws IOException {
-		HttpConnection connImg; // TODO implement this in UrlFetcher class
-		Socket sockImg;
-		FileOutputStream fos;
-		ByteArray daten;
 		String realurl;
 		boolean forceredirect;
 		if (url.startsWith(&quot;R&quot;)) {
@@ -307,44 +528,22 @@
 			forceredirect = false;
 			realurl = url;
 		}
-		connImg = new HttpConnection(realurl);
-		connImg.setRequestorProperty(&quot;USER_AGENT&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.5) Gecko/20041107 Firefox/1.0&quot;);
-		connImg.setRequestorProperty(&quot;Connection&quot;, &quot;close&quot;);
-	//	this prevents gdz1.leipzig.ifag.de (dtk100) from answering and ist not necessary for expedia connImg.setRequestorProperty(&quot;Cookie&quot;, &quot;jscript=1; path=/;&quot;);
-		connImg.documentIsEncoded = true;
-		try{
-			File dateiF = new FileBugfix(datei);
-			if(!dateiF.exists()){
-				int i=0;
-				sockImg = connImg.connect();
-				String quelle = connImg.getRedirectTo();
-				boolean redirrected = false;
-				while (i &lt; 5 &amp;&amp; (quelle != null || (forceredirect &amp;&amp; !redirrected))) { // this is necessary because expedia sometimes doesn't directly anser with the redirect to the map-image, but give a page in between. Solved the problem by retrying see also: <A HREF="http://www.geoclub.de/viewtopic.php?p=305071#305071">http://www.geoclub.de/viewtopic.php?p=305071#305071</A>
-					if (quelle != null) {
-						redirrected = true;
-						sockImg.close();
-						connImg = connImg.getRedirectedConnection(quelle);
-						sockImg = connImg.connect();
-						quelle = connImg.getRedirectTo();
-					}
-					i++;
-				}
-				if (i &gt; 4) throw new IOException(MyLocale.getMsg(4807, &quot;loadTo: failed to download map: didn't get http-redirect&quot;));
-				String ct = (String)connImg.documentProperties.getValue(&quot;content-type&quot;, &quot;&quot;);
-				if (!ct.substring(0, 5).equalsIgnoreCase(&quot;image&quot;) )  {
-					String tmp = connImg.readText(sockImg, null).toString(); // TODO if the content is binary will will get an Exception in InfoBox, trying to display the content
-					tmp = tmp.substring(0, (tmp.length() &lt; 1000 ? tmp.length() : 1000));
-					sockImg.close();
-					throw new IOException(MyLocale.getMsg(4808, &quot;downloadImage: content-type:&quot;)+&quot; &quot; + ct + MyLocale.getMsg(4809, &quot; is not an image, begin of content:&quot;)+&quot; &quot; + tmp);
-				}
-				daten = connImg.readData(sockImg);
-				fos = new FileOutputStream(datei); // note: using the constructor (File) instead of (String) will cause not to use the fake file system
-				fos.write(daten.toBytes());
-				fos.close();
-				sockImg.close();
+		File dateiF = new FileBugfix(datei);
+		if (!dateiF.exists()) {
+			if (forceredirect)
+				UrlFetcher.setForceRedirect();
+			UrlFetcher.fetchDataFile(realurl, datei);
+			String ct = null;
+			try {
+				ct = (String) UrlFetcher.getDocumentProperties().getValue(&quot;content-type&quot;, &quot;no-content-type provided&quot;);
+			} catch (Exception e) {
+				ct = &quot;document property content-type does not exist!&quot;;
 			}
-		}catch(IOException e){
-			throw new IOException(MyLocale.getMsg(4810, &quot;Error while downloading or saving map:\n&quot;) + e.getMessage());
+			if (!ct.substring(0, 5).equalsIgnoreCase(&quot;image&quot;)) {
+				dateiF = new FileBugfix(datei);
+				dateiF.delete();
+				throw new IOException(MyLocale.getMsg(4808, &quot;downloadImage: content-type:&quot;) + &quot; &quot; + ct + MyLocale.getMsg(4809, &quot; is not an image, begin of content:&quot;) + &quot; (deleted)&quot;);
+			}
 		}
 	}
 }
@@ -356,7 +555,7 @@
 	String mapType;
 	/** Esentially the same as name, but used for the file system. It will be part of the names of the downloaded images */
 	String filename;
-	String MainUrl; //<A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS</A>
+	String MainUrl; // <A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS</A>
 	/** including &quot;.&quot; */
 	String imageFileExt; // &quot;.gif&quot;, &quot;.jpg&quot;...
 	double recommendedScales[];
@@ -369,7 +568,7 @@
 	 * This method is used in case the online map service provides only certain steps of
 	 * zoomlevels. In this case the scale in meters per pixel must be returned, which
 	 * will be used instead of the wished scale.
-	 *
+	 * 
 	 * @param scale
 	 * @return
 	 */
@@ -383,6 +582,7 @@
 
 	/**
 	 * Overlaod this to integrate name of layers
+	 * 
 	 * @return friendly service name
 	 */
 	public String getName() {
@@ -393,6 +593,7 @@
 	 * This method is called to get a name of the
 	 * online map service which will be part of the filename
 	 * used for the downloaded image
+	 * 
 	 * @return friendly service name
 	 */
 	public String getNameForFileSystem() {
@@ -402,10 +603,12 @@
 	public String getMapType() {
 		return mapType;
 	}
+
 	/**
 	 * Overload this and return the URL to the map image, don't call super
 	 * Alternatively overload getUrlForBoundingBoxInternal
 	 * You must overload either this method or getUrlForBoundingBox
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -421,6 +624,7 @@
 	 * This is made protected and named &quot;...Internal&quot; because a lot of services
 	 * don't work correctly when a map is requested, that is not exactly quadratic
 	 * --&gt; alway use getUrlForCenter...
+	 * 
 	 * @param surArea
 	 * @param pixelsize
 	 * @return
@@ -432,6 +636,7 @@
 	/**
 	 * overload this if your map service uses a special projection
 	 * an return an Area that is quadratic in that projection
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -439,19 +644,19 @@
 	 */
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
-		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y)/2 * scale / 1000;
+		double halfdiagonal = Math.sqrt(pixelsize.x * pixelsize.x + pixelsize.y * pixelsize.y) / 2 * scale / 1000;
 		bbox.topleft = center.project(-45, halfdiagonal);
-		bbox.buttomright = center.project(135, halfdiagonal);
+		bbox.bottomright = center.project(135, halfdiagonal);
 		return bbox;
 	}
 
-
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
 		throw new IllegalArgumentException(MyLocale.getMsg(4811, &quot;OnlineMapService: getMapInfoObjectInternal(Area maparea, Point pixelsize):\n This method must be overloaded in order to be able to use it&quot;));
 	}
 
 	/**
 	 * Overload this (don't call super()) or alternatively overload getMapInfoObjectInternal
+	 * 
 	 * @param center
 	 * @param scale
 	 * @param pixelsize
@@ -469,9 +674,9 @@
 class WebMapService extends OnlineMapService {
 	String layersUrlPart; //
 	String versionUrlPart; // VERSION=1.1.0
-	String serviceTypeUrlPart; //&quot;SERVICE=WMS&quot;
+	String serviceTypeUrlPart; // &quot;SERVICE=WMS&quot;
 	int coordinateReferenceSystem[]; // WGS84: 4326, German GK: 31466 /
-	String coordinateReferenceSystemUrlPart[]; //&amp;SRS=EPSG:31466
+	String coordinateReferenceSystemUrlPart[]; // &amp;SRS=EPSG:31466
 	public String requestUrlPart;
 	String imageFormatUrlPart; // FORMAT=image/png
 	String stylesUrlPart; // STYLES=
@@ -479,12 +684,13 @@
 	double maxscaleWMS;
 
 	/**
-	 *
-	 * @param filename without file extension
+	 * 
+	 * @param filename
+	 *            without file extension
 	 * @throws IOException
 	 * @throws IllegalArgumentException
 	 */
-	public WebMapService (String filename_) throws IOException, IllegalArgumentException{
+	public WebMapService(String filename_) throws IOException, IllegalArgumentException {
 		FileInputStream in = new FileInputStream(filename_);
 		Properties wms = new Properties();
 		wms.load(in);
@@ -492,104 +698,128 @@
 		String tmp = FileBase.getFileExt(filename_);
 		this.filename = tmp.substring(0, tmp.lastIndexOf('.'));
 		name = wms.getProperty(&quot;Name&quot;, &quot;&quot;).trim();
-		if (name == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4812, &quot;WebMapService: property &gt;Name:&lt; missing in file:\n&quot;) + filename);
-		MainUrl = wms.getProperty(&quot;MainUrl&quot;, &quot;&quot;).trim();;
-		if (MainUrl == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4813, &quot;WebMapService: property &gt;MainUrl:&lt; missing in file:\n&quot;) + filename);
+		if (name == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4812, &quot;WebMapService: property &gt;Name:&lt; missing in file:\n&quot;) + filename);
+		MainUrl = wms.getProperty(&quot;MainUrl&quot;, &quot;&quot;).trim();
+		;
+		if (MainUrl == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4813, &quot;WebMapService: property &gt;MainUrl:&lt; missing in file:\n&quot;) + filename);
 		mapType = wms.getProperty(&quot;MapType&quot;, &quot;maptype_unknown&quot;).trim();
 		serviceTypeUrlPart = wms.getProperty(&quot;ServiceTypeUrlPart&quot;, &quot;SERVICE=WMS&quot;).trim();
-		layersUrlPart = wms.getProperty(&quot;LayersUrlPart&quot;, &quot;&quot;).trim();;
-		versionUrlPart = wms.getProperty(&quot;VersionUrlPart&quot;, &quot;&quot;).trim();;
+		layersUrlPart = wms.getProperty(&quot;LayersUrlPart&quot;, &quot;&quot;).trim();
+		;
+		versionUrlPart = wms.getProperty(&quot;VersionUrlPart&quot;, &quot;&quot;).trim();
+		;
 		tmp = wms.getProperty(&quot;CoordinateReferenceSystemCacheWolf&quot;, &quot;&quot;).trim();
-		if (tmp.equals(&quot;&quot;)) throw new IllegalArgumentException(MyLocale.getMsg(4814, &quot;WebMapService: no CoordinateReferenceSystemCacheWolf given&quot;));
+		if (tmp.equals(&quot;&quot;))
+			throw new IllegalArgumentException(MyLocale.getMsg(4814, &quot;WebMapService: no CoordinateReferenceSystemCacheWolf given&quot;));
 		String[] tmp2 = mString.split(tmp, ' ');
 		coordinateReferenceSystem = new int[tmp2.length];
 		for (int i = 0; i &lt; tmp2.length; i++) {
 			coordinateReferenceSystem[i] = Common.parseInt(tmp2[i].trim());
-			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i])) throw new IllegalArgumentException(MyLocale.getMsg(4815, &quot;Coordinate reference system not supported by CacheWolf:\n&quot;) + coordinateReferenceSystem[i]);
+			if (!TransformCoordinates.isSupported(coordinateReferenceSystem[i]))
+				throw new IllegalArgumentException(MyLocale.getMsg(4815, &quot;Coordinate reference system not supported by CacheWolf:\n&quot;) + coordinateReferenceSystem[i]);
 		}
 		tmp = wms.getProperty(&quot;CoordinateReferenceSystemUrlPart&quot;, &quot;&quot;).trim();
-		if (tmp == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4816, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; missing in file:\n&quot;) + filename);
+		if (tmp == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4816, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; missing in file:\n&quot;) + filename);
 		tmp2 = mString.split(tmp, ' ');
-		if (tmp2.length != coordinateReferenceSystem.length) throw new IllegalArgumentException(MyLocale.getMsg(4817, &quot;number of strings in CoordinateReferenceSystemUrlPart (&quot;)+tmp2.length+MyLocale.getMsg(4818, &quot;) must match the number of codes in CoordinateReferenceSystemCacheWolf (&quot;)+coordinateReferenceSystem.length+MyLocale.getMsg(4819, &quot;) use normal space as separator&quot;));
+		if (tmp2.length != coordinateReferenceSystem.length)
+			throw new IllegalArgumentException(MyLocale.getMsg(4817, &quot;number of strings in CoordinateReferenceSystemUrlPart (&quot;) + tmp2.length + MyLocale.getMsg(4818, &quot;) must match the number of codes in CoordinateReferenceSystemCacheWolf (&quot;)
+					+ coordinateReferenceSystem.length + MyLocale.getMsg(4819, &quot;) use normal space as separator&quot;));
 		coordinateReferenceSystemUrlPart = new String[tmp2.length];
 		for (int i = 0; i &lt; tmp2.length; i++) {
 			coordinateReferenceSystemUrlPart[i] = tmp2[i].trim();
-			if (coordinateReferenceSystemUrlPart[i] == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4820, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; incorrect in file:\n&quot;) + filename);
+			if (coordinateReferenceSystemUrlPart[i] == &quot;&quot;)
+				throw new IllegalArgumentException(MyLocale.getMsg(4820, &quot;WebMapService: property &gt;CoordinateReferenceSystemUrlPart:&lt; incorrect in file:\n&quot;) + filename);
 		}
 		requestUrlPart = wms.getProperty(&quot;RequestUrlPart&quot;, &quot;REQUEST=GetMap&quot;).trim();
 		imageFormatUrlPart = wms.getProperty(&quot;ImageFormatUrlPart&quot;, &quot;&quot;).trim();
 		stylesUrlPart = wms.getProperty(&quot;StylesUrlPart&quot;, &quot;&quot;).trim();
 		String topleftS = wms.getProperty(&quot;BoundingBoxTopLeftWGS84&quot;, &quot;&quot;).trim();
-		String buttomrightS = wms.getProperty(&quot;BoundingBoxButtomRightWGS84&quot;, &quot;&quot;).trim();
+		String bottomrightS = wms.getProperty(&quot;BoundingBoxBottomRightWGS84&quot;);
+		// To be backward-compatible with mispelled property-name: Don't remove these lines until all wms-Files has been changed
+		if (bottomrightS == null) {
+			bottomrightS = wms.getProperty(&quot;BoundingBoxButtomRightWGS84&quot;, &quot;&quot;);
+		}
+		bottomrightS.trim();
 		CWPoint topleft = new CWPoint(topleftS);
-		CWPoint buttomright = new CWPoint(buttomrightS);
-		if (!topleft.isValid()) topleft.set(90, -180);
-		if (!buttomright.isValid()) buttomright.set(-90, 180);
-		boundingBox = new Area (topleft, buttomright);
+		CWPoint bottomright = new CWPoint(bottomrightS);
+		if (!topleft.isValid())
+			topleft.set(90, -180);
+		if (!bottomright.isValid())
+			bottomright.set(-90, 180);
+		boundingBox = new Area(topleft, bottomright);
 		minscaleWMS = Common.parseDouble(wms.getProperty(&quot;MinScale&quot;, &quot;0&quot;).trim());
 		maxscaleWMS = Common.parseDouble(wms.getProperty(&quot;MaxScale&quot;, Convert.toString(java.lang.Double.MAX_VALUE)).trim());
 		minscale = minscaleWMS / Math.sqrt(2); // in WMS scale is measured diagonal while in CacheWolf it is measured vertical
 		maxscale = maxscaleWMS / Math.sqrt(2);
 		imageFileExt = wms.getProperty(&quot;ImageFileExtension&quot;, &quot;&quot;).trim();
-		if (imageFileExt == &quot;&quot;) throw new IllegalArgumentException(MyLocale.getMsg(4821, &quot;WebMapService: property &gt;ImageFileExtension:&lt; missing in file:\n&quot;) + filename);
-		String [] recommendedScalesStr = mString.split(wms.getProperty(&quot;RecommendedScale&quot;, &quot;5&quot;).trim(), ' ');
+		if (imageFileExt == &quot;&quot;)
+			throw new IllegalArgumentException(MyLocale.getMsg(4821, &quot;WebMapService: property &gt;ImageFileExtension:&lt; missing in file:\n&quot;) + filename);
+		String[] recommendedScalesStr = mString.split(wms.getProperty(&quot;RecommendedScale&quot;, &quot;5&quot;).trim(), ' ');
 		// convert recommended scales to doube[], sort them and set preselected recommended scale
 		if (recommendedScalesStr.length &gt; 0) {
 			double preselected = Common.parseDouble(recommendedScalesStr[0]);
 			Double[] recommendedScalesObj = new Double[recommendedScalesStr.length];
-			for (int i=0; i &lt; recommendedScalesObj.length; i++) {
+			for (int i = 0; i &lt; recommendedScalesObj.length; i++) {
 				recommendedScalesObj[i] = new Double();
 				recommendedScalesObj[i].set(Common.parseDouble(recommendedScalesStr[i].replace(',', '.')));
 			}
 			Utils.sort(recommendedScalesObj, new StandardComparer(), false);
 			recommendedScales = new double[recommendedScalesStr.length];
-			for (int i=0; i &lt; recommendedScales.length; i++) {
+			for (int i = 0; i &lt; recommendedScales.length; i++) {
 				recommendedScales[i] = recommendedScalesObj[i].value;
-				if (recommendedScales[i] == preselected) preselectedRecScaleIndex = i;
+				if (recommendedScales[i] == preselected)
+					preselectedRecScaleIndex = i;
 			}
 		}
 	}
 
 	private static final int TOPLEFT_INDEX = 0;
-	private static final int BUTTOMRIGHT_INDEX = 1;
+	private static final int BOTTOMRIGHT_INDEX = 1;
 	private static final int TOPRIGHT_INDEX = 2;
-	private static final int BUTTOMLEFT_INDEX = 3;
+	private static final int BOTTOMLEFT_INDEX = 3;
+
 	/**
-	 *
+	 * 
 	 * @param maparea
-	 * @return [0] = topleft, [1] = buttomright, [2] = topright, [3] = buttomleft
+	 * @return [0] = topleft, [1] = bottomright, [2] = topright, [3] = bottomleft
 	 */
 	private ProjectedPoint[] getGkArea(Area maparea) {
 		ProjectedPoint[] ret = new ProjectedPoint[4];
-	//	CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.buttomright.lonDec);
-	//	CWPoint buttomleft = new CWPoint(maparea.buttomright.latDec, maparea.topleft.lonDec);
+		// CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+		// CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
 		int crs = getCrs(maparea.getCenter());
 		// FIXME region is never read. Needed?
 		// int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[crs]);
 		ret[TOPLEFT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.topleft, coordinateReferenceSystem[crs]);
-		ret[BUTTOMRIGHT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.buttomright, coordinateReferenceSystem[crs]);
-		ret[TOPRIGHT_INDEX] =  ret[BUTTOMRIGHT_INDEX].cloneIt();
-		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BUTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
-		ret[BUTTOMLEFT_INDEX] = ret[BUTTOMRIGHT_INDEX].cloneIt();
-		ret[BUTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BUTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth, ret[TOPLEFT_INDEX].lengthOfStripe0);
-		//ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
-		//ret[3] = TransformCoordinates.wgs84ToGermanGk(buttomleft, coordinateReferenceSystem[crs]);
+		ret[BOTTOMRIGHT_INDEX] = TransformCoordinates.wgs84ToEpsg(maparea.bottomright, coordinateReferenceSystem[crs]);
+		ret[TOPRIGHT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
+		ret[TOPRIGHT_INDEX].shift(ret[TOPLEFT_INDEX].getNorthing() - ret[BOTTOMRIGHT_INDEX].getNorthing(), 0); // was: new GkPoint(ret[BUTTOMRIGHT_INDEX].getEasting(region), ret[TOPLEFT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
+		ret[BOTTOMLEFT_INDEX] = ret[BOTTOMRIGHT_INDEX].cloneIt();
+		ret[BOTTOMLEFT_INDEX].shift(ret[TOPLEFT_INDEX].getEasting() - ret[BOTTOMRIGHT_INDEX].getEasting(), 1); // was: new GkPoint(ret[TOPLEFT_INDEX].getEasting(region), ret[BUTTOMRIGHT_INDEX].northing, ret[TOPLEFT_INDEX].stripewidth,
+																												// ret[TOPLEFT_INDEX].lengthOfStripe0);
+		// ret[2] = TransformCoordinates.wgs84ToGermanGk(topright, coordinateReferenceSystem[crs]);
+		// ret[3] = TransformCoordinates.wgs84ToGermanGk(bottomleft, coordinateReferenceSystem[crs]);
 		return ret;
 	}
+
 	public Area CenterScaleToArea(CWPoint center, float scale, Point pixelsize) {
 		Area bbox = new Area();
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if (region &gt; 0 ) {
+		if (region &gt; 0) {
 			int epsg = coordinateReferenceSystem[getCrs(center)];
 			ProjectedPoint cgk = TransformCoordinates.wgs84ToEpsg(center, epsg);
 			ProjectedPoint tlgk = cgk.cloneIt();
-			tlgk.shift(- pixelsize.x * scale / 2, 1);
+			tlgk.shift(-pixelsize.x * scale / 2, 1);
 			tlgk.shift(pixelsize.y * scale / 2, 0);
 			ProjectedPoint brgk = cgk.cloneIt();
 			brgk.shift(pixelsize.x * scale / 2, 1);
 			brgk.shift(-pixelsize.y * scale / 2, 0);
 			bbox.topleft = TransformCoordinates.ProjectedEpsgToWgs84(tlgk, epsg); // old: (tlgk, region);
-			bbox.buttomright = TransformCoordinates.ProjectedEpsgToWgs84(brgk, epsg); // TransformCoordinates.GkToWgs84(brgk, region);
+			bbox.bottomright = TransformCoordinates.ProjectedEpsgToWgs84(brgk, epsg); // TransformCoordinates.GkToWgs84(brgk, region);
 		} else {
 			switch (coordinateReferenceSystem[0]) {
 			case TransformCoordinates.EPSG_ETRS89:
@@ -597,49 +827,46 @@
 				bbox.topleft.set(center);
 				bbox.topleft.shift(-pixelsize.x * scale / 2, 1);
 				bbox.topleft.shift(pixelsize.y * scale / 2, 0);
-				bbox.buttomright.set(center);
-				bbox.buttomright.shift(pixelsize.x * scale / 2, 1);
-				bbox.buttomright.shift(-pixelsize.y * scale / 2, 0);
+				bbox.bottomright.set(center);
+				bbox.bottomright.shift(pixelsize.x * scale / 2, 1);
+				bbox.bottomright.shift(-pixelsize.y * scale / 2, 0);
 				break;
-			default: throw new IllegalArgumentException(&quot;CenterScaleToArea: epsg: &quot; + coordinateReferenceSystem[0] + &quot; not supported&quot;);
+			default:
+				throw new IllegalArgumentException(&quot;CenterScaleToArea: epsg: &quot; + coordinateReferenceSystem[0] + &quot; not supported&quot;);
 			}
 		}
 		return bbox;
 	}
 
 	protected String getUrlForBoundingBoxInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;)+&quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;)+&quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;)+&quot; &quot; + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;) + &quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;) + &quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;) + &quot; &quot; + boundingBox.toString());
 		// <A HREF="http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png">http://www.geoserver.nrw.de/GeoOgcWms1.3/servlet/TK25?SERVICE=WMS&amp;VERSION=1.1.0&amp;REQUEST=GetMap&amp;SRS=EPSG:31466&amp;BBOX=2577567.0149,5607721.7566,2578567.0077,5608721.7602&amp;WIDTH=500&amp;HEIGHT=500&amp;LAYERS=Raster:TK25_KMF:Farbkombination&amp;STYLES=&amp;FORMAT=image/png</A>
-		CWPoint buttomleft = new CWPoint (maparea.buttomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
-		double scaleh = maparea.buttomright.getDistance(buttomleft) * 1000 / pixelsize.x;
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
+		double scaleh = maparea.bottomright.getDistance(bottomleft) * 1000 / pixelsize.x;
 		double scalev = maparea.topleft.getDistance(topright) * 1000 / pixelsize.y;
 		double scale = Math.sqrt(scaleh * scaleh + scalev * scalev); // meters per pixel measured diagonal
-		if ( scale &lt; minscaleWMS || scale &gt; maxscaleWMS ) throw new IllegalArgumentException(MyLocale.getMsg(4825, &quot;scale&quot;)+&quot; &quot; + scale / Math.sqrt(2)+ MyLocale.getMsg(4826, &quot; not supported by online map service, supported scale range:&quot;)+&quot; &quot; + minscale + &quot; - &quot; + maxscale + MyLocale.getMsg(4827, &quot; (measured in meters per pixel vertically)&quot;));
+		if (scale &lt; minscaleWMS || scale &gt; maxscaleWMS)
+			throw new IllegalArgumentException(MyLocale.getMsg(4825, &quot;scale&quot;) + &quot; &quot; + scale / Math.sqrt(2) + MyLocale.getMsg(4826, &quot; not supported by online map service, supported scale range:&quot;) + &quot; &quot; + minscale + &quot; - &quot; + maxscale
+					+ MyLocale.getMsg(4827, &quot; (measured in meters per pixel vertically)&quot;));
 		int crs = 0;
 		String bbox = &quot;BBOX=&quot;;
 		int localsystem = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
 		if (localsystem &gt; 0) {
 			crs = getCrs(maparea.getCenter());
 			ProjectedPoint[] gk = getGkArea(maparea);
-			buttomleft = TransformCoordinates.ProjectedEpsgToWgs84(gk[BUTTOMLEFT_INDEX], coordinateReferenceSystem[crs]);
+			bottomleft = TransformCoordinates.ProjectedEpsgToWgs84(gk[BOTTOMLEFT_INDEX], coordinateReferenceSystem[crs]);
 			topright = TransformCoordinates.ProjectedEpsgToWgs84(gk[TOPRIGHT_INDEX], coordinateReferenceSystem[crs]);
-			bbox += TransformCoordinates.wgs84ToEpsg(buttomleft, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;);
+			bbox += TransformCoordinates.wgs84ToEpsg(bottomleft, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;);
 			bbox += &quot;,&quot; + TransformCoordinates.wgs84ToEpsg(topright, coordinateReferenceSystem[crs]).toString(2, &quot;&quot;, &quot;,&quot;);
 		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84)
-			bbox += buttomleft.toString(TransformCoordinates.LON_LAT)  + &quot;,&quot; + topright.toString(TransformCoordinates.LON_LAT);
-		else throw new IllegalArgumentException(MyLocale.getMsg(4828, &quot;Coordinate system not supported by cachewolf:&quot;)+&quot; &quot; + coordinateReferenceSystem.toString());
-		String ret = MainUrl + &quot;SERVICE=WMS&quot; + &quot;&amp;&quot;+ versionUrlPart + &quot;&amp;&quot; + requestUrlPart + &quot;&amp;&quot; +
-		coordinateReferenceSystemUrlPart[crs] + &quot;&amp;&quot; + bbox +
-		&quot;&amp;WIDTH=&quot; + pixelsize.x + &quot;&amp;HEIGHT=&quot; + pixelsize.y + &quot;&amp;&quot; +
-		layersUrlPart + &quot;&amp;&quot; + stylesUrlPart + &quot;&amp;&quot; + imageFormatUrlPart;
-		if (requestUrlPart.equalsIgnoreCase(&quot;Kosmos&quot;)) {
-			// minlat minlng maxlat maxlng
-			ret=buttomleft.toString(TransformCoordinates.LAT_LON).replace(',',' ')+&quot; &quot;+
-				topright.toString(TransformCoordinates.LAT_LON).replace(',',' ')+
-				&quot; -w &quot;+pixelsize.x;
-		}
-		Global.getPref().log(ret + &quot; WGS84: Buttom left: &quot; + buttomleft.toString(TransformCoordinates.DD) + &quot;top right: &quot; + topright.toString(TransformCoordinates.DD));
+			bbox += bottomleft.toString(TransformCoordinates.LON_LAT) + &quot;,&quot; + topright.toString(TransformCoordinates.LON_LAT);
+		else
+			throw new IllegalArgumentException(MyLocale.getMsg(4828, &quot;Coordinate system not supported by cachewolf:&quot;) + &quot; &quot; + coordinateReferenceSystem.toString());
+		String ret = MainUrl + serviceTypeUrlPart + &quot;&amp;&quot; + versionUrlPart + &quot;&amp;&quot; + requestUrlPart + &quot;&amp;&quot; + coordinateReferenceSystemUrlPart[crs] + &quot;&amp;&quot; + bbox + &quot;&amp;WIDTH=&quot; + pixelsize.x + &quot;&amp;HEIGHT=&quot; + pixelsize.y + &quot;&amp;&quot; + layersUrlPart + &quot;&amp;&quot; + stylesUrlPart
+				+ &quot;&amp;&quot; + imageFormatUrlPart;
+		Global.getPref().log(ret + &quot; WGS84: Bottom left: &quot; + bottomleft.toString(TransformCoordinates.DD) + &quot;top right: &quot; + topright.toString(TransformCoordinates.DD));
 		return ret;
 	}
 
@@ -648,71 +875,79 @@
 	 * a) if only one is in the array 0 is returned
 	 * b) if there are more, find out which one matches the correct zone (e.g. Gau&#223;-K&#252;ger stripe)
 	 * Call this routine with center of the area (use Area.getcenter())
-	 * @param p Point for which the epsg code is searched for
+	 * 
+	 * @param p
+	 *            Point for which the epsg code is searched for
 	 * @return
 	 */
 	private int getCrs(TrackPoint p) {
 		int crsindex = 0;
 		if (coordinateReferenceSystem.length &gt; 1) {
 			int ls = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if buttom left and top right are not in the same Gau&#223;-Kr&#252;ger stripe?
+			ProjectedPoint gkbl = TransformCoordinates.wgs84ToLocalsystem(p, ls); // TODO: think / read about what to do if bottom left and top right are not in the same Gau&#223;-Kr&#252;ger stripe?
 			int wantepsg = gkbl.getEpsgCode();
 			for (crsindex = 0; crsindex &lt; coordinateReferenceSystem.length; crsindex++) {
-				if (coordinateReferenceSystem[crsindex] == wantepsg) break;
+				if (coordinateReferenceSystem[crsindex] == wantepsg)
+					break;
 			}
 			if (crsindex &gt;= coordinateReferenceSystem.length) { // not match
 				for (crsindex = 0; crsindex &lt; coordinateReferenceSystem.length; crsindex++) {
-					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1) break; // accept 1 zone deviation
+					if (Math.abs(coordinateReferenceSystem[crsindex] - wantepsg) == 1)
+						break; // accept 1 zone deviation
 				}
-				if (crsindex &gt;= coordinateReferenceSystem.length) crsindex = -1;
+				if (crsindex &gt;= coordinateReferenceSystem.length)
+					crsindex = -1;
 
 			}
-			if (crsindex &lt; 0) throw new IllegalArgumentException(MyLocale.getMsg(4829, &quot;getUrlForBoundingBox: Point:&quot;)+&quot; &quot; + gkbl.toString() + MyLocale.getMsg(4830, &quot;no matching Gau&#223;-Kr&#252;ger-Stripe in the EPSG-code list in the .wms&quot;));
+			if (crsindex &lt; 0)
+				throw new IllegalArgumentException(MyLocale.getMsg(4829, &quot;getUrlForBoundingBox: Point:&quot;) + &quot; &quot; + gkbl.toString() + MyLocale.getMsg(4830, &quot;no matching Gau&#223;-Kr&#252;ger-Stripe in the EPSG-code list in the .wms&quot;));
 		}
 		return crsindex;
 	}
 
 	protected MapInfoObject getMapInfoObjectInternal(Area maparea, Point pixelsize) {
-		if (!boundingBox.isOverlapping(maparea)) throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;)+&quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;)+&quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;)+&quot; &quot; + boundingBox.toString());
+		if (!boundingBox.isOverlapping(maparea))
+			throw new IllegalArgumentException(MyLocale.getMsg(4822, &quot;area:&quot;) + &quot; &quot; + maparea.toString() + MyLocale.getMsg(4823, &quot; not covered by service:&quot;) + &quot; &quot; + name + MyLocale.getMsg(4824, &quot;, service area:&quot;) + &quot; &quot; + boundingBox.toString());
 		Vector georef = new Vector(4);
 
 		// calculate a rectangle in the according coordinate reference system
-		CWPoint buttomleft = new CWPoint (maparea.buttomright.latDec, maparea.topleft.lonDec);
-		CWPoint topright = new CWPoint (maparea.topleft.latDec, maparea.buttomright.lonDec);
+		CWPoint bottomleft = new CWPoint(maparea.bottomright.latDec, maparea.topleft.lonDec);
+		CWPoint topright = new CWPoint(maparea.topleft.latDec, maparea.bottomright.lonDec);
 		CWPoint topleft = new CWPoint(maparea.topleft);
-		CWPoint buttomright = new CWPoint(maparea.buttomright);
-		double metersperpixalhorizontal = ( buttomright.getDistance(buttomleft) + topleft.getDistance(topright))/2 * 1000 / pixelsize.x;
-		double metersperpixalvertical = ( buttomright.getDistance(topright) + topleft.getDistance(buttomleft))/2 * 1000 / pixelsize.y;
+		CWPoint bottomright = new CWPoint(maparea.bottomright);
+		double metersperpixalhorizontal = (bottomright.getDistance(bottomleft) + topleft.getDistance(topright)) / 2 * 1000 / pixelsize.x;
+		double metersperpixalvertical = (bottomright.getDistance(topright) + topleft.getDistance(bottomleft)) / 2 * 1000 / pixelsize.y;
 		int region = TransformCoordinates.getLocalProjectionSystem(coordinateReferenceSystem[0]);
-		if ( region &gt; 0) {
+		if (region &gt; 0) {
 			ProjectedPoint[] gk = getGkArea(maparea);
 			// bounding box in WMS is defined around the pixels, not exactly on the pixels --&gt; the bounding box must be reduced on all edges by half a pixel
 			gk[TOPLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
 			gk[TOPLEFT_INDEX].shift(-metersperpixalvertical / 2, 0);
-			gk[BUTTOMRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
-			gk[BUTTOMRIGHT_INDEX].shift(metersperpixalvertical / 2, 0);
+			gk[BOTTOMRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
+			gk[BOTTOMRIGHT_INDEX].shift(metersperpixalvertical / 2, 0);
 			gk[TOPRIGHT_INDEX].shift(-metersperpixalhorizontal / 2, 1);
 			gk[TOPRIGHT_INDEX].shift(-metersperpixalvertical / 2, 0);
-			gk[BUTTOMLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
-			gk[BUTTOMLEFT_INDEX].shift(metersperpixalvertical / 2, 0);
+			gk[BOTTOMLEFT_INDEX].shift(metersperpixalhorizontal / 2, 1);
+			gk[BOTTOMLEFT_INDEX].shift(metersperpixalvertical / 2, 0);
 
 			topleft.set(gk[TOPLEFT_INDEX].getNorthing(), gk[TOPLEFT_INDEX].getEasting());
-			buttomright.set(gk[BUTTOMRIGHT_INDEX].getNorthing(), gk[BUTTOMRIGHT_INDEX].getEasting());
+			bottomright.set(gk[BOTTOMRIGHT_INDEX].getNorthing(), gk[BOTTOMRIGHT_INDEX].getEasting());
 			topright.set(gk[TOPRIGHT_INDEX].getNorthing(), gk[TOPRIGHT_INDEX].getEasting());
-			buttomleft.set(gk[BUTTOMLEFT_INDEX].getNorthing(), gk[BUTTOMLEFT_INDEX].getEasting());
+			bottomleft.set(gk[BOTTOMLEFT_INDEX].getNorthing(), gk[BOTTOMLEFT_INDEX].getEasting());
 		} else if (coordinateReferenceSystem[0] == TransformCoordinates.EPSG_WGS84) {
 			// bounding box in WMS is defined around the pixels, not exactly on the pixels --&gt; the bounding box must be reduced on all edges by half a pixel
 			topleft.shift(metersperpixalhorizontal / 2, 1);
 			topleft.shift(-metersperpixalvertical / 2, 0);
-			buttomright.shift(-metersperpixalhorizontal, 1);
-			buttomright.shift(metersperpixalhorizontal, 0);
-			topright = new CWPoint (topleft.latDec, buttomright.lonDec);
-			buttomleft = new CWPoint (buttomright.latDec, topleft.lonDec);
-		} else throw new IllegalArgumentException(MyLocale.getMsg(4831, &quot;getMapInfoObject: Coordinate system not supported by cachewolf:&quot;)+&quot; &quot; + coordinateReferenceSystem);
+			bottomright.shift(-metersperpixalhorizontal, 1);
+			bottomright.shift(metersperpixalhorizontal, 0);
+			topright = new CWPoint(topleft.latDec, bottomright.lonDec);
+			bottomleft = new CWPoint(bottomright.latDec, topleft.lonDec);
+		} else
+			throw new IllegalArgumentException(MyLocale.getMsg(4831, &quot;getMapInfoObject: Coordinate system not supported by cachewolf:&quot;) + &quot; &quot; + coordinateReferenceSystem);
 		georef.add(new GCPoint(topleft, new Point(0, 0)));
-		georef.add(new GCPoint(buttomright, new Point(pixelsize.x, pixelsize.y)));
+		georef.add(new GCPoint(bottomright, new Point(pixelsize.x, pixelsize.y)));
 		georef.add(new GCPoint(topright, new Point(pixelsize.x, 0)));
-		georef.add(new GCPoint(buttomleft, new Point(0, pixelsize.y)));
+		georef.add(new GCPoint(bottomleft, new Point(0, pixelsize.y)));
 
 		MapInfoObject ret = new MapInfoObject();
 		ret.evalGCP(georef, pixelsize.x, pixelsize.y, coordinateReferenceSystem[getCrs(maparea.getCenter())]);
@@ -722,25 +957,26 @@
 
 class ExpediaMapService extends OnlineMapService {
 	/*
-	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
+	 * information from: DownloadMouseMode.properties in project GPSylon ( in directory gpsylon_src-0.5.2\plugins\downloadmousemode\auxiliary\org\dinopolis\gpstool\plugin\downloadmousemode and DownloadMapCalculator.java in Dir
+	 * gpsylon_src-0.5.2\plugins\downloadmousemode\src\org\dinopolis\gpstool\plugin\downloadmousemode
 	 * download.map.url.expedia_east=http\://www.expedia.com/pub/agent.dll?qscr=mrdt&amp;ID=3XNsF.&amp;CenP={0,number,#.########},{1,number,#.########}&amp;Lang=EUR0809&amp;Alti={2,number,#}&amp;Size={3,number,#},{4,number,#}&amp;Offs=0.000000,0.000000\&amp;BCheck=1
 	 * download.map.url.expedia_east.title=Url of Expedia Europe
 	 * download.map.scale_factor.expedia_east=3950
 	 */
 	final static float downloadMapScaleFactorExpedia_east = 3950;
-	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f/2817.947378f;
+	final static float MAPBLAST_METERS_PER_PIXEL = 1.0f / 2817.947378f;
 	final static float EXPEDIA_METERS_PER_PIXEL = downloadMapScaleFactorExpedia_east * MAPBLAST_METERS_PER_PIXEL;
 
 	public ExpediaMapService() {
 		name = &quot;Expedia&quot;;
 		filename = &quot;expedia&quot;;
-		MainUrl = &quot;<A HREF="Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.">Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.</A>&quot;; //&quot;<A HREF="Rhttp://">Rhttp://</A>&quot; forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
+		MainUrl = &quot;<A HREF="Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.">Rhttp://www.expedia.de/pub/agent.dll?qscr=mrdt&amp;ID=3kQaz.</A>&quot;; // &quot;<A HREF="Rhttp://">Rhttp://</A>&quot; forces doenloadUrl to retry the URL until it gets an http-redirect and then downloads from there
 		imageFileExt = &quot;.gif&quot;;
 		mapType = &quot;expedia&quot;;
-		recommendedScales = new double[]{5};
+		recommendedScales = new double[] { 5 };
 		minscale = getMetersPerPixel(0.00000000000000000000001f);
-		maxscale = getMetersPerPixel((float)new CWPoint(0,0).getDistance(new CWPoint(0,180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -&gt; m. /1000 because we have 1000x1000 Pixel usually
-		boundingBox = new Area(new CWPoint(90,-180), new CWPoint(-90,180));
+		maxscale = getMetersPerPixel((float) new CWPoint(0, 0).getDistance(new CWPoint(0, 180)) * 2 * 1000 / 1000); // whole world * 1000 because of km -&gt; m. /1000 because we have 1000x1000 Pixel usually
+		boundingBox = new Area(new CWPoint(90, -180), new CWPoint(-90, 180));
 	}
 
 	public float getMetersPerPixel(float scale) {
@@ -748,24 +984,25 @@
 	}
 
 	private int getZoomlevel(float scale) {
-		return (int)(Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
+		return (int) (Math.ceil(scale / EXPEDIA_METERS_PER_PIXEL));
 	}
 
 	public String getUrlForCenterScale(CWPoint center, float scale, Point pixelsize) {
 		int zoomlevel = getZoomlevel(scale);
 		String zone;
-		if (     (center.lonDec &lt;= -30   &amp;&amp; center.lonDec &gt;= -170) ||
-				( center.lonDec &gt; 360-30 &amp;&amp; center.lonDec &lt;= 360-170) ) zone = &quot;USA0409&quot;; // TODO test which zone-code ist best for asia
-		else zone = &quot;EUR0809&quot;;
+		if ((center.lonDec &lt;= -30 &amp;&amp; center.lonDec &gt;= -170) || (center.lonDec &gt; 360 - 30 &amp;&amp; center.lonDec &lt;= 360 - 170))
+			zone = &quot;USA0409&quot;; // TODO test which zone-code ist best for asia
+		else
+			zone = &quot;EUR0809&quot;;
 		String quelle = MainUrl + &quot;&amp;CenP=&quot; + center.toString(TransformCoordinates.LAT_LON);
-		quelle = quelle + &quot;&amp;Alti=&quot;+Convert.toString(zoomlevel)+&quot;&amp;Lang=&quot;+zone+&quot;&amp;Size=&quot;+Convert.toString(pixelsize.x)+&quot;,&quot;+Convert.toString(pixelsize.y)+&quot;&amp;Offs=0,0&amp;MapS=0&quot;; //&amp;Pins=|&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.') + &quot;|5|&quot;;
+		quelle = quelle + &quot;&amp;Alti=&quot; + Convert.toString(zoomlevel) + &quot;&amp;Lang=&quot; + zone + &quot;&amp;Size=&quot; + Convert.toString(pixelsize.x) + &quot;,&quot; + Convert.toString(pixelsize.y) + &quot;&amp;Offs=0,0&amp;MapS=0&quot;; // &amp;Pins=|&quot; + latD.toString().replace(',', '.') + &quot;,&quot; + lonD.toString().replace(',', '.') + &quot;|5|&quot;;
 		return quelle;
 	}
 
 	public MapInfoObject getMapInfoObject(CWPoint center, float scale, Point pixelsize) {
 		float metersPerPixel2 = getMetersPerPixel(scale);
 		float metersPerPixel = metersPerPixel2;
-		MapInfoObject cal = new MapInfoObject(metersPerPixel, center,  pixelsize.x, pixelsize.y, name);
+		MapInfoObject cal = new MapInfoObject(metersPerPixel, center, pixelsize.x, pixelsize.y, name);
 		return cal;
 	}
 

Modified: branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapLoaderGui.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -60,47 +60,47 @@
 
 /**
  * @author pfeffer
- * This Class is the Dialog for Download calibrated from expedia.com
- * is called from
- *  * start offset for language file: 1800
+ *         This Class is the Dialog for Download calibrated from expedia.com
+ *         is called from
+ *         * start offset for language file: 1800
  */
 
 public class MapLoaderGui extends Form {
 	mButton cancelB, okBtiles, okBPerCache, cancelBPerCache;
-    Preferences pref = Global.getPref ();
+	Preferences pref = Global.getPref();
 	mTabbedPanel mTab = new mTabbedPanel();
 	CellPanel pnlTiles = new CellPanel();
 	CellPanel pnlPerCache = new CellPanel();
 
-	final String descString = MyLocale.getMsg(1802,&quot;Download georeferenced maps\n Select online service:&quot;);
+	final String descString = MyLocale.getMsg(1802, &quot;Download georeferenced maps\n Select online service:&quot;);
 	mChoice mapServiceChoice;
-	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803,&quot;for&quot;));
-	mChoice forSelectedChkBox = new mChoice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 0);
-	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] {MyLocale.getMsg(1804,&quot;all&quot;), MyLocale.getMsg(1805,&quot;selected&quot;)}, 1);
-	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806,&quot;caches&quot;));
+	mCheckBox forCachesChkBox = new mCheckBox(MyLocale.getMsg(1803, &quot;for&quot;));
+	mChoice forSelectedChkBox = new mChoice(new String[] { MyLocale.getMsg(1804, &quot;all&quot;), MyLocale.getMsg(1805, &quot;selected&quot;) }, 0);
+	mChoice forSelectedChkBoxPerCache = new mChoice(new String[] { MyLocale.getMsg(1804, &quot;all&quot;), MyLocale.getMsg(1805, &quot;selected&quot;) }, 1);
+	mLabel cachesLbl = new mLabel(MyLocale.getMsg(1806, &quot;caches&quot;));
 	mInput distanceInput;
 	mLabel distLbl;
 	mLabel km = new mLabel(&quot;km&quot;);
 	mLabel coosLbl;
 	mButton coosBtn;
-	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807,&quot;Approx. m per pixel:&quot;));
+	mLabel scaleLbl = new mLabel(MyLocale.getMsg(1807, &quot;Approx. m per pixel:&quot;));
 	mComboBox scaleInput = new mComboBox();
 	mComboBox scaleInputPerCache = new mComboBox();
-	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808,&quot;overlapping in pixel:&quot;));
-    mInput overlappingInput = new mInput(&quot;&quot;+pref.mapOverlapping);
-	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
-	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809,&quot;download an overview map&quot;));
+	mLabel overlappingLbl = new mLabel(MyLocale.getMsg(1808, &quot;overlapping in pixel:&quot;));
+	mInput overlappingInput = new mInput(&quot;&quot; + pref.mapOverlapping);
+	mCheckBox overviewChkBox = new mCheckBox(MyLocale.getMsg(1809, &quot;download an overview map&quot;));
+	mCheckBox fetchOnlyMapWithCacheChkBox = new mCheckBox(MyLocale.getMsg(165, &quot;only for caches&quot;));
+	mCheckBox overviewChkBoxPerCache = new mCheckBox(MyLocale.getMsg(1809, &quot;download an overview map&quot;));
+	mCheckBox smallTiles = new mCheckBox(MyLocale.getMsg(4280, &quot;Small Tiles&quot;));
+	mCheckBox bigTiles = new mCheckBox(MyLocale.getMsg(4282, &quot;BigTiles&quot;));
+	CheckBoxGroup tileSize = new CheckBoxGroup();
 
-    mCheckBox smallTiles = new mCheckBox (MyLocale.getMsg (4280, &quot;Small Tiles&quot;));
-    mCheckBox bigTiles = new mCheckBox (MyLocale.getMsg (4282, &quot;BigTiles&quot;));
-    CheckBoxGroup tileSize = new CheckBoxGroup ();
-
-    /**
-     * Inputfields for width an height of tile size
-     */
-    private mInput tileWidthInput = new mInput ();
-    private mInput tileHeightInput = new mInput();
-    MapLoader mapLoader;
+	/**
+	 * Inputfields for width an height of tile size
+	 */
+	private mInput tileWidthInput = new mInput();
+	private mInput tileHeightInput = new mInput();
+	MapLoader mapLoader;
 	String[] unsortedMapServices;
 	String[] sortedmapServices;
 	int[] sortingMapServices;
@@ -124,19 +124,19 @@
 		this.title = MyLocale.getMsg(1800, &quot;Download georeferenced maps&quot;);
 		center = new CWPoint(pref.getCurCentrePt());
 		tileWidth = pref.tilewidth;
-		tileHeight=pref.tileheight;
+		tileHeight = pref.tileheight;
 		if (tileWidth == 0 || tileHeight == 0) {
-			tileWidth = pref.myAppWidth &gt; 200?pref.myAppWidth:200;
-			tileHeight = pref.myAppHeight &gt; 175?pref.myAppHeight:175;
+			tileWidth = pref.myAppWidth &gt; 200 ? pref.myAppWidth : 200;
+			tileHeight = pref.myAppHeight &gt; 175 ? pref.myAppHeight : 175;
 		}
-		pref.tilewidth=tileWidth;
-		pref.tileheight=tileHeight;
+		pref.tilewidth = tileWidth;
+		pref.tileheight = tileHeight;
 		// ist das wirklich so gewollt?
-		pref.tilewidth=1000;
-		pref.tileheight=1000;
+		pref.tilewidth = 1000;
+		pref.tileheight = 1000;
 		initTileInputfields();
 		cacheDB = cacheDBi;
-		mapLoader = new MapLoader(FileBase.getProgramDirectory()+&quot;/&quot;+&quot;webmapservices&quot;);
+		mapLoader = new MapLoader(FileBase.getProgramDirectory() + &quot;/&quot; + &quot;webmapservices&quot;);
 
 		// sort the items in the list of services in a way that services which cover the current center point.
 		unsortedMapServices = mapLoader.getAvailableOnlineMapServices();
@@ -151,36 +151,38 @@
 		pnlTiles.addNext(forCachesChkBox);
 		pnlTiles.addNext(forSelectedChkBox);
 		pnlTiles.addLast(cachesLbl);
-		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810,&quot;Within a rectangle of:&quot;)),CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distLbl = new mLabel(MyLocale.getMsg(1810, &quot;Within a rectangle of:&quot;)), CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		distanceInput = new mInput();
 		int tmp = Convert.toInt((Global.getProfile().getDistOC()));
 		tmp = java.lang.Math.max(tmp, Convert.toInt((Global.getProfile().getDistGC())));
 		distanceInput.setText(Convert.toString((tmp &gt; 0 ? tmp : 15)));
-		pnlTiles.addNext(distanceInput,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addNext(distanceInput, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		pnlTiles.addLast(km);
-		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, &quot;around the centre:&quot;)+&quot; &quot;));
+		pnlTiles.addNext(coosLbl = new mLabel(MyLocale.getMsg(1811, &quot;around the centre:&quot;) + &quot; &quot;));
 		pnlTiles.addLast(coosBtn = new mButton(center.toString()));
 		pnlTiles.addNext(scaleLbl);
 		mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 		this.focusFirst();
 		pnlTiles.addLast(scaleInput);
-		//	pnlTiles.addLast(resolutionLbl);
+		// pnlTiles.addLast(resolutionLbl);
 		pnlTiles.addNext(overlappingLbl);
 		pnlTiles.addLast(overlappingInput);
 		overviewChkBox.setState(false);
-		pnlTiles.addLast(overviewChkBox);
+		pnlTiles.addNext(overviewChkBox);
+		fetchOnlyMapWithCacheChkBox.setState(false);
+		pnlTiles.addLast(fetchOnlyMapWithCacheChkBox);
 		pnlTiles.addNext(smallTiles);
 		pnlTiles.addLast(bigTiles);
 		smallTiles.setGroup(tileSize);
-                bigTiles.setGroup(tileSize);
+		bigTiles.setGroup(tileSize);
 		tileSize.selectIndex(pref.mapTileSize);
-		cancelB = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		cancelB = new mButton(MyLocale.getMsg(1604, &quot;Cancel&quot;));
 		cancelB.setHotKey(0, IKeys.ESCAPE);
-		pnlTiles.addNext(cancelB,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
-		okBtiles = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		pnlTiles.addNext(cancelB, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
+		okBtiles = new mButton(MyLocale.getMsg(1605, &quot;OK&quot;));
 		okBtiles.setHotKey(0, IKeys.ACTION);
 		okBtiles.setHotKey(0, IKeys.ENTER);
-		pnlTiles.addLast(okBtiles,CellConstants.DONTSTRETCH, (CellConstants.DONTFILL|CellConstants.WEST));
+		pnlTiles.addLast(okBtiles, CellConstants.DONTSTRETCH, (CellConstants.DONTFILL | CellConstants.WEST));
 		updateForCachesState();
 		mTab.addCard(pnlTiles, MyLocale.getMsg(1812, &quot;Tiles&quot;), MyLocale.getMsg(1812, &quot;Tiles&quot;));
 
@@ -189,20 +191,20 @@
 		pnlPerCache.addNext(forSelectedChkBoxPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addLast(new mLabel(MyLocale.getMsg(1806, &quot;caches&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
 		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1807, &quot;Approx. m per pixel&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-		pnlPerCache.addNext (new mLabel(MyLocale.getMsg(1835, &quot;Tilesize&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		CellPanel pnl = new CellPanel();		
+		pnlPerCache.addLast(scaleInputPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		pnlPerCache.addNext(new mLabel(MyLocale.getMsg(1835, &quot;Tilesize&quot;)), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		CellPanel pnl = new CellPanel();
 		tileHeightInput.columns = tileWidthInput.columns = 5;
-		pnl.addNext (tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addNext (new mLabel(&quot;x&quot;), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		pnl.addLast (tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-        pnlPerCache.addLast(pnl,CellConstants.DONTSTRETCH, CellConstants.DONTFILL|CellConstants.WEST);
-		
-        cancelBPerCache = new mButton(MyLocale.getMsg(1604,&quot;Cancel&quot;));
+		pnl.addNext(tileWidthInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addNext(new mLabel(&quot;x&quot;), CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnl.addLast(tileHeightInput, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
+		pnlPerCache.addLast(pnl, CellConstants.DONTSTRETCH, CellConstants.DONTFILL | CellConstants.WEST);
+
+		cancelBPerCache = new mButton(MyLocale.getMsg(1604, &quot;Cancel&quot;));
 		cancelBPerCache.setHotKey(0, IKeys.ESCAPE);
 		pnlPerCache.addNext(cancelBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
-		okBPerCache = new mButton(MyLocale.getMsg(1605,&quot;OK&quot;));
+		okBPerCache = new mButton(MyLocale.getMsg(1605, &quot;OK&quot;));
 		okBPerCache.setHotKey(0, IKeys.ACTION);
 		okBPerCache.setHotKey(0, IKeys.ENTER);
 		pnlPerCache.addLast(okBPerCache, CellConstants.DONTSTRETCH, CellConstants.DONTFILL);
@@ -217,9 +219,9 @@
 		tileHeightInput.setText(Integer.toString(pref.tileheight));
 	}
 
-	private void setRecommScaleInput(){
+	private void setRecommScaleInput() {
 		String[] recScales = new String[mapLoader.currentOnlineMapService.recommendedScales.length];
-		for (int i=0; i&lt;recScales.length; i++) {
+		for (int i = 0; i &lt; recScales.length; i++) {
 			recScales[i] = Convert.toString(mapLoader.currentOnlineMapService.recommendedScales[i]);
 		}
 		scaleInput.choice.set(recScales, mapLoader.currentOnlineMapService.preselectedRecScaleIndex);
@@ -232,70 +234,72 @@
 	 * sort the map services in order to have the services, which cover
 	 * the current center first in the list
 	 * this sets inbound[], sortedMapServices[] and sortingmapServices[]
-	 *
+	 * 
 	 */
 	private void sortMapServices() {
-		sortingMapServices = new int[unsortedMapServices.length+1];
+		sortingMapServices = new int[unsortedMapServices.length + 1];
 		inbound = new boolean[unsortedMapServices.length];
-		int j=0;
-		for (int i=0; i &lt; sortingMapServices.length-1; i++) {
-			if( ((OnlineMapService)mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
+		int j = 0;
+		for (int i = 0; i &lt; sortingMapServices.length - 1; i++) {
+			if (((OnlineMapService) mapLoader.onlineMapServices.get(i)).boundingBox.isInBound(center)) {
 				sortingMapServices[j] = i;
 				j++;
 				inbound[i] = true;
-			} else inbound[i] = false;
+			} else
+				inbound[i] = false;
 		}
-		int k=j;
-		sortedmapServices = new String[unsortedMapServices.length+1];
-		for (int i=0; i &lt; sortedmapServices.length-1; i++) {
+		int k = j;
+		sortedmapServices = new String[unsortedMapServices.length + 1];
+		for (int i = 0; i &lt; sortedmapServices.length - 1; i++) {
 			if (!inbound[i]) {
 				sortingMapServices[j] = i;
 				j++;
 			}
-			sortedmapServices[i] = ((OnlineMapService)mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
+			sortedmapServices[i] = ((OnlineMapService) mapLoader.onlineMapServices.get(sortingMapServices[i])).getName();
 		}
-		sortedmapServices[j]=sortedmapServices[k];
-		sortedmapServices[k]=&quot;===== ===== ===== ===== ===== ===== =====&quot;;
-		sortingMapServices[j]=sortingMapServices[k];
-		sortingMapServices[k]=-1;
+		sortedmapServices[j] = sortedmapServices[k];
+		sortedmapServices[k] = &quot;===== ===== ===== ===== ===== ===== =====&quot;;
+		sortingMapServices[j] = sortingMapServices[k];
+		sortingMapServices[k] = -1;
 	}
 
 	private int getSortedMapServiceIndex(int originalindex) {
 		for (int i = 0; i &lt; sortingMapServices.length; i++) {
-			if (sortingMapServices[i] == originalindex) return i;
+			if (sortingMapServices[i] == originalindex)
+				return i;
 		}
-		throw new IllegalStateException(MyLocale.getMsg(1818, &quot;getSortedMapServiceIndex: index&quot;)+&quot; &quot; + originalindex + MyLocale.getMsg(1819, &quot;not found&quot;));
+		throw new IllegalStateException(MyLocale.getMsg(1818, &quot;getSortedMapServiceIndex: index&quot;) + &quot; &quot; + originalindex + MyLocale.getMsg(1819, &quot;not found&quot;));
 	}
 
 	public String getMapsDir() {
 		String ret = Global.getPref().getMapDownloadSavePath(mapLoader.currentOnlineMapService.getMapType());
-		Global.getPref().saveCustomMapsPath(getLeadingPath(ret,Global.getPref().getMapLoadPath()));
+		Global.getPref().saveCustomMapsPath(getLeadingPath(ret, Global.getPref().getMapLoadPath()));
 		// Global.getPref().saveCustomMapsPath(ret);
 		// eigentlich d&#252;rft das erst gespeichert werden, wenn erfolgreich heruntergeladen wurde
 		return ret;
 	}
 
-	private String getLeadingPath(String newPath , String oldPath) {
-		String LeadingPath=&quot;&quot;;
-		int StartPos=0;
+	private String getLeadingPath(String newPath, String oldPath) {
+		String LeadingPath = &quot;&quot;;
+		int StartPos = 0;
 		int EndPos;
-		int LastPos = java.lang.Math.min(newPath.length(),oldPath.length());
+		int LastPos = java.lang.Math.min(newPath.length(), oldPath.length());
 		do {
-			EndPos=java.lang.Math.min(newPath.indexOf(&quot;/&quot;, StartPos),LastPos);
-			if (newPath.substring(StartPos,EndPos).equals(oldPath.substring(StartPos, EndPos))) {
-				LeadingPath=LeadingPath.concat(newPath.substring(StartPos,EndPos+1));
-				StartPos=EndPos+1;
-			}
-			else {
+			EndPos = java.lang.Math.min(newPath.indexOf(&quot;/&quot;, StartPos), LastPos);
+			if (newPath.substring(StartPos, EndPos).equals(oldPath.substring(StartPos, EndPos))) {
+				LeadingPath = LeadingPath.concat(newPath.substring(StartPos, EndPos + 1));
+				StartPos = EndPos + 1;
+			} else {
 				break;
 			}
-		} while (StartPos&lt;LastPos);
+		} while (StartPos &lt; LastPos);
 		return LeadingPath;
 	}
 
 	public void downloadTiles() {
 		String mapsDir = getMapsDir();
-		if (mapsDir == null) return;
+		if (mapsDir == null)
+			return;
 		InfoBox progressBox = new InfoBox(MyLocale.getMsg(1815, &quot;Downloading georeferenced maps&quot;), MyLocale.getMsg(1816, &quot;Downloading georeferenced maps\n \n \n \n \n&quot;), InfoBox.PROGRESS_WITH_WARNINGS);
 		progressBox.setPreferredSize(220, 300);
 		progressBox.setInfoHeight(160);
@@ -304,16 +308,16 @@
 		mapLoader.setProgressInfoBox(progressBox);
 		Vm.showWait(true);
 		int length;
-        	switch (tileSize.getSelectedIndex()){
-		    //Perhaps introduce a medium size??
+		switch (tileSize.getSelectedIndex()) {
+		// Perhaps introduce a medium size??
 		case 0:
-		    length=500;
-		    break;
+			length = 500;
+			break;
 		default:
-		    length=1000;
+			length = 1000;
 		}
-		//Override size if one tile for each cache is wanted
-			Point size = new Point(length, length);
+		// Override size if one tile for each cache is wanted
+		Point size = new Point(length, length);
 		if (perCache) {
 			length = 1000;
 			size = new Point(tileWidth, tileHeight);
@@ -326,9 +330,8 @@
 				progressBox.close(0);
 				return;
 			}
-			mapLoader.setTiles(surArea.topleft, surArea.buttomright, scale, size, overlapping );
-		} else
-		{ // calculate from centre point an radius
+			mapLoader.setTiles(surArea.topleft, surArea.bottomright, scale, size, overlapping);
+		} else { // calculate from centre point an radius
 			mapLoader.setTiles(center, radius * 1000, scale, size, overlapping);
 		}
 		if (overviewmap) {
@@ -337,32 +340,28 @@
 			try {
 				mapLoader.downloadMap(center, overviewScale, size, mapsDir);
 			} catch (Exception e) {
-				progressBox.addWarning(MyLocale.getMsg(1825, &quot;Overview map: Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+				progressBox.addWarning(MyLocale.getMsg(1825, &quot;Overview map: Ignoring error:&quot;) + &quot; &quot; + e.getMessage() + &quot;\n&quot;);
 			}
 		}
-		if (!perCache){  // download tiles
+		if (!perCache) { // download tiles
 			mapLoader.setProgressInfoBox(progressBox);
+			mapLoader.setFetchOnlyMapWithCache(fetchOnlyMapWithCacheChkBox.getState());
 			mapLoader.downlaodTiles(mapsDir);
 		} else { // per cache
 			CacheHolder ch;
-			CWPoint tmpca = new CWPoint();
 			int numdownloaded = 0;
 			Global.getProfile().getSourroundingArea(onlySelected); // calculate numCachesInArea
 			int numCaches = Global.getProfile().numCachesInArea;
-			for (int i=cacheDB.size()-1; i &gt;= 0; i--) {
+			for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 				ch = cacheDB.get(i);
 				if (!this.onlySelected || ch.is_Checked) {
-					if (ch.pos == null) { // this can not happen
-						tmpca.set(ch.getLatLon());
-						ch.pos = new CWPoint(tmpca);
-					}
-					if (ch.pos.isValid() &amp;&amp; ch.pos.latDec != 0 &amp;&amp; ch.pos.lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos &#252;berall korrekt ist
+					if (ch.getPos().isValid() &amp;&amp; ch.getPos().latDec != 0 &amp;&amp; ch.getPos().lonDec != 0) { // TODO != 0 sollte verschwinden, sobald das handling von nicht gesetzten Koos &#252;berall korrekt ist
 						numdownloaded++;
-						progressBox.setInfo(MyLocale.getMsg(1820, &quot;Downloading map '&quot;)+mapLoader.currentOnlineMapService.getName()+&quot;'\n&quot;+numdownloaded+&quot; / &quot;+numCaches+MyLocale.getMsg(1821, &quot;\n for cache:\n&quot;)+ch.getCacheName());
+						progressBox.setInfo(MyLocale.getMsg(1820, &quot;Downloading map '&quot;) + mapLoader.currentOnlineMapService.getName() + &quot;'\n&quot; + numdownloaded + &quot; / &quot; + numCaches + MyLocale.getMsg(1821, &quot;\n for cache:\n&quot;) + ch.getCacheName());
 						try {
-							mapLoader.downloadMap(ch.pos, scale, size, mapsDir);
+							mapLoader.downloadMap(ch.getPos(), scale, size, mapsDir);
 						} catch (Exception e) {
-							progressBox.addWarning(MyLocale.getMsg(1822, &quot;Cache:&quot;)+&quot; &quot; + ch.getCacheName() + &quot;(&quot; + ch.getWayPoint() + &quot;) &quot;+MyLocale.getMsg(1823, &quot;Ignoring error:&quot;)+&quot; &quot; + e.getMessage()+&quot;\n&quot;);
+							progressBox.addWarning(MyLocale.getMsg(1822, &quot;Cache:&quot;) + &quot; &quot; + ch.getCacheName() + &quot;(&quot; + ch.getWayPoint() + &quot;) &quot; + MyLocale.getMsg(1823, &quot;Ignoring error:&quot;) + &quot; &quot; + e.getMessage() + &quot;\n&quot;);
 						}
 					}
 				}
@@ -373,20 +372,19 @@
 		progressBox.addOkButton();
 		progressBox.waitUntilClosed();
 		mapLoader.setProgressInfoBox(null);
-		//progressBox.close(0);
-		if(Global.mainTab.mm != null) Global.mainTab.mm.mapsloaded = false;
-		//	(new MessageBox(&quot;Download maps&quot;, &quot;Downloaded and calibrated the maps successfully&quot;, MessageBox.OKB)).execute();
+		// progressBox.close(0);
+		if (Global.mainTab.mm != null)
+			Global.mainTab.mm.mapsloaded = false;
+		// (new MessageBox(&quot;Download maps&quot;, &quot;Downloaded and calibrated the maps successfully&quot;, MessageBox.OKB)).execute();
 	}
 
-
 	private void updateForCachesState() {
 		int a, b;
 		if (forCachesChkBox.getState()) {
 			// create map rectangle from caches
 			a = 0;
 			b = ControlConstants.Disabled;
-		}
-		else { // use centre and distance input
+		} else { // use centre and distance input
 			a = ControlConstants.Disabled;
 			b = 0;
 		}
@@ -396,28 +394,29 @@
 		distLbl.modify(b, a);
 		coosBtn.modify(b, a);
 		coosLbl.modify(b, a);
-		km.modify(b,a);
+		km.modify(b, a);
 		repaintNow();
 
 	}
 
-	public void onEvent(Event ev){
-		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelB || ev.target == cancelBPerCache){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelB || ev.target == cancelBPerCache) {
 				this.close(FormBase.IDCANCEL);
-			}
-			else if (ev.target == okBtiles || ev.target == okBPerCache){
+			} else if (ev.target == okBtiles || ev.target == okBPerCache) {
 				if (sortingMapServices[mapServiceChoice.selectedIndex] == -1) {
 					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1833, &quot;Please don't select the separator line in the wms service option&quot;), FormBase.OKB)).execute();
 				}
 				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
 				if (ev.target == okBtiles) { // get tiles
 					perCache = false;
-					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBox.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;)))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBox.getState();
-					radius = (float)CacheWolf.Common.parseDouble(distanceInput.getText());
-					scale = (float)CacheWolf.Common.parseDouble(scaleInput.getText());
+					radius = (float) CacheWolf.Common.parseDouble(distanceInput.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInput.getText());
 					overlapping = Convert.toInt(overlappingInput.getText());
 					if (!forCachesChkBox.getState()) {
 						if (radius &lt;= 0) {
@@ -435,41 +434,43 @@
 					}
 				} else { // per cache
 					perCache = true;
-					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;))) onlySelected = false;
-					else onlySelected = true;
+					if (forSelectedChkBoxPerCache.getSelectedItem().toString().equalsIgnoreCase(MyLocale.getMsg(1804, &quot;all&quot;)))
+						onlySelected = false;
+					else
+						onlySelected = true;
 					overviewmap = overviewChkBoxPerCache.getState();
-					scale = (float)CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
+					scale = (float) CacheWolf.Common.parseDouble(scaleInputPerCache.getText());
 					tileWidth = CacheWolf.Common.parseInt(tileWidthInput.getText());
 					tileHeight = CacheWolf.Common.parseInt(tileHeightInput.getText());
 					if (tileWidth &lt;= 0) {
 						new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1836, &quot;Width of tiles must be greater 0.&quot;), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					if (tileHeight &lt;= 0) {
 						new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), MyLocale.getMsg(1837, &quot;Height of tiles must be greater 0.&quot;), FormBase.OKB).execute();
-						initTileInputfields ();
+						initTileInputfields();
 						return;
 					}
 					// If width and height has been valid, set them in preferences also:
-					pref.tileheight=tileHeight;
-					pref.tilewidth=tileWidth;
+					pref.tileheight = tileHeight;
+					pref.tilewidth = tileWidth;
 				}
 				if (scale &lt; mapLoader.currentOnlineMapService.minscale || scale &gt; mapLoader.currentOnlineMapService.maxscale) {
 					if (scale &lt; mapLoader.currentOnlineMapService.minscale) {
 						scaleInput.setText(Convert.toString(mapLoader.currentOnlineMapService.minscale));
-						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale*100)/100));
+						scaleInputPerCache.setText(Convert.toString(java.lang.Math.ceil(mapLoader.currentOnlineMapService.minscale * 100) / 100));
 					} else {
-						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale*100)/100));
+						scaleInput.setText(Convert.toString(java.lang.Math.floor(mapLoader.currentOnlineMapService.maxscale * 100) / 100));
 						scaleInputPerCache.setText(Convert.toString(mapLoader.currentOnlineMapService.maxscale));
 					}
-					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), &quot;! &quot; + scale + &quot;\n&quot; + MyLocale.getMsg(1830, &quot;The selected online map service provides map in the scale from&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.minscale + MyLocale.getMsg(1831, &quot; to&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, &quot;\n please adjust 'Approx. meter pro pixel' accordingly&quot;), FormBase.OKB)).execute();
+					(new MessageBox(MyLocale.getMsg(321, &quot;Error&quot;), &quot;! &quot; + scale + &quot;\n&quot; + MyLocale.getMsg(1830, &quot;The selected online map service provides map in the scale from&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.minscale
+							+ MyLocale.getMsg(1831, &quot; to&quot;) + &quot; &quot; + mapLoader.currentOnlineMapService.maxscale + MyLocale.getMsg(1832, &quot;\n please adjust 'Approx. meter pro pixel' accordingly&quot;), FormBase.OKB)).execute();
 					return;
 				}
 				this.close(FormBase.IDOK);
 				this.downloadTiles();
-			}
-			else if (ev.target == coosBtn) {
+			} else if (ev.target == coosBtn) {
 				CoordsScreen cs = new CoordsScreen();
 				cs.setFields(center, TransformCoordinates.CW);
 				if (cs.execute() != FormBase.IDCANCEL) {
@@ -479,32 +480,29 @@
 					sortMapServices();
 					mapServiceChoice.set(sortedmapServices, (!inbound[tmp] ? 0 : getSortedMapServiceIndex((tmp))));
 				}
-			}
-			else if (ev.target == forCachesChkBox) {
+			} else if (ev.target == forCachesChkBox) {
 				updateForCachesState();
+			} else if (ev.target == tileSize) {
+				switch (tileSize.getSelectedIndex()) {
+				case 0:
+					overlappingInput.setText(&quot;10&quot;);
+					pref.mapTileSize = 0;
+					pref.mapOverlapping = 10;
+					break;
+				default:
+					overlappingInput.setText(&quot;100&quot;);
+					pref.mapTileSize = 1;
+					pref.mapOverlapping = 100;
+				}
 			}
-			else if (ev.target == tileSize){
-			    switch (tileSize.getSelectedIndex()){
-			    case 0:
-			    overlappingInput.setText (&quot;10&quot;);
-			    pref.mapTileSize=0;
-			    pref.mapOverlapping=10;
-			    break;
-			    default:
-			    overlappingInput.setText (&quot;100&quot;);
-			    pref.mapTileSize=1;
-			    pref.mapOverlapping=100;
-			    }
-			}
 		} // end of &quot;if controllEvent...&quot;
-		if (ev instanceof DataChangeEvent){
-		    if (ev.target == mapServiceChoice) {
-			mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
-			setRecommScaleInput();
-		    }
-		    else if (ev.target == overlappingInput){
-			pref.mapOverlapping = Convert.toInt(overlappingInput.getText ());
-		    }
+		if (ev instanceof DataChangeEvent) {
+			if (ev.target == mapServiceChoice) {
+				mapLoader.setCurrentMapService(sortingMapServices[mapServiceChoice.selectedIndex]);
+				setRecommScaleInput();
+			} else if (ev.target == overlappingInput) {
+				pref.mapOverlapping = Convert.toInt(overlappingInput.getText());
+			}
 		}
 		super.onEvent(ev);
 	}

Modified: branches/r1.2/src/CacheWolf/navi/MapSymbol.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapSymbol.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapSymbol.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,26 +33,30 @@
 	String name;
 	String filename;
 	CWPoint where;
-	
+
 	public MapSymbol(String namei, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, String filenamei, CWPoint where_) {
 		name = namei;
 		filename = filenamei;
 		where = where_;
 		mapObject = mapObjecti;
 	}
+
 	public MapSymbol(String namei, Object mapObjecti, Image fromIm, CWPoint where_) {
 		name = namei;
 		where = where_;
 		mapObject = mapObjecti;
 		setImage(fromIm);
 	}
-	public void loadImage(){
-		setImage(new Image(filename),0); freeSource();;
-		//properties = AniImage.AlwaysOnTop;
+
+	public void loadImage() {
+		setImage(new Image(filename), 0);
+		freeSource();
+		// properties = AniImage.AlwaysOnTop;
 	}
 }

Modified: branches/r1.2/src/CacheWolf/navi/MapsList.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MapsList.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MapsList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -300,8 +300,8 @@
 	 * if no map includes both it returns null
 	 * @param if more than one map includes topleft and bottomright than the one will
 	 * be returned which has its center nearest to topleft. If you have gps-pos and goto-pos
-	 * as topleft and buttomright use gps as topleft.
-	 * if topleft is really topleft or if it is buttomright is not relevant.
+	 * as topleft and bottomright use gps as topleft.
+	 * if topleft is really topleft or if it is bottomright is not relevant.
 	 */
 
 	public final MapInfoObject getMapForArea(CWPoint topleft, CWPoint bottomright){
@@ -527,9 +527,9 @@
 	}
 */
 	/** for determining if a new map should be downloaded
-	public boolean isInAmap(CWPoint topleft, CWPoint buttomright) {
-		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(buttomright.latDec)) ||
-			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(buttomright.lonDec)
+	public boolean isInAmap(CWPoint topleft, CWPoint bottomright) {
+		if (!latRangeList.isInRange(topleft.latDec) || !latRangeList.isInRange(bottomright.latDec)) ||
+			!lonRangeList.inInRange(topleft.lonDec) || !lonRangeList.isInRange(boxsttomright.lonDec)
 			return false;
 	}
 	 */

Modified: branches/r1.2/src/CacheWolf/navi/MovingMap.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/MovingMap.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/MovingMap.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
 
 import CacheWolf.CWPoint;
@@ -33,7 +33,6 @@
 import CacheWolf.CacheType;
 import CacheWolf.Common;
 import CacheWolf.Global;
-import CacheWolf.GuiImageBroker;
 import CacheWolf.InfoBox;
 import CacheWolf.MainTab;
 import CacheWolf.MyLocale;
@@ -61,6 +60,7 @@
 import ewe.sys.Convert;
 import ewe.sys.Double;
 import ewe.sys.SystemResourceException;
+import ewe.sys.Time;
 import ewe.sys.Vm;
 import ewe.ui.CellConstants;
 import ewe.ui.ControlConstants;
@@ -86,17 +86,21 @@
 import ewe.util.Vector;
 
 /**
- *	Class to handle a moving map.
+ * Class to handle a moving map.
  */
 public final class MovingMap extends Form implements ICommandListener {
-	public final static int gotFix = 4; //green
-	public final static int lostFix = 3; //yellow
+	public final static int gotFix = 4; // green
+	public final static int lostFix = 3; // yellow
 	public final static int noGPSData = 2; // red
-	public final static int noGPS = 1; // no GPS-Position marker, manually disconnected
-	public final static int ignoreGPS = -1; // ignore even changes in GPS-signal (eg. from lost fix to gotFix) this is wanted when the map is moved manually
+	public final static int noGPS = 1; // no GPS-Position marker, manually
+										// disconnected
+	public final static int ignoreGPS = -1; // ignore even changes in
+											// GPS-signal (eg. from lost fix
+											// to gotFix) this is wanted
+											// when the map is moved
+											// manually
 
 	public MapSymbol gotoPos = null;
-	CacheHolder markedCache = null;
 	public int GpsStatus;
 	Preferences pref;
 	MovingMapPanel mmp;
@@ -107,7 +111,7 @@
 	CWPoint TrackOverlaySetCenterTopLeft;
 	Vector tracks;
 	MapInfoObject currentMap = null;
-	//String mapPath;
+	// String mapPath;
 	Navigate myNavigation;
 	boolean running = false;
 
@@ -117,33 +121,39 @@
 	AniImage statusImageNoSignal;
 	AniImage statusImageNoGps;
 	MapSymbol posCircle;
-	String MARK_CACHE_IMAGE;
+	final static Image imgSelectedCache = new Image(&quot;mark_cache.png&quot;);
+	final static Image imgGoto = new Image(&quot;goto_map.png&quot;);
 	int posCircleX = 0, posCircleY = 0, lastCompareX = Integer.MAX_VALUE, lastCompareY = Integer.MAX_VALUE;
-	//double posCircleLat, posCircleLon;
+	// double posCircleLat, posCircleLon;
 	FontMetrics fm;
 
-	boolean dontUpdatePos = false; // this is only internaly used to avoid multi-threading problems
+	boolean dontUpdatePos = false; // this is only internaly used to avoid
+									// multi-threading problems
 	boolean ignoreGps = false; // ignores updateGps-calls if true
 	boolean autoSelectMap = true;
-	boolean forceMapLoad = true; // only needed to force updateposition to try to load the best map again after OutOfMemoryError after an repeated click on snap-to-gps
+	boolean forceMapLoad = true; // only needed to force updateposition
+									// to try to load the best map again
+									// after OutOfMemoryError after an
+									// repeated click on snap-to-gps
 	public boolean mapHidden = false;
 	boolean noMapsAvailable;
 	boolean zoomingMode = false;
 	public boolean mapsloaded = false;
-	boolean additionalOverlaysDeleted=true;
-	protected boolean paintPosDestLine=true;
+	boolean additionalOverlaysDeleted = true;
+	protected boolean paintPosDestLine = true;
 	Point lastRepaintMapPos = null;
 	double lastDistance = -1;
 
 	// the layer for the buttons
-	private MovingMapControls controlsLayer;
-	
+	private final MovingMapControls controlsLayer;
+
 	float lastHighestResolutionGPSDestScale = -1;
 
 	public static final int tileWidth = 100;
 	public static final int tileHeight = 100;
 
-	//Needed by updatePosition to decide if a recalculation of map-tiles is needed:
+	// Needed by updatePosition to decide if a recalculation of map-tiles is
+	// needed:
 	private int lastXPos;
 	private int lastYPos;
 	private int lastWidth;
@@ -157,76 +167,83 @@
 	public void setFillWhiteArea(boolean fillWhiteArea) {
 		pref.fillWhiteArea = fillWhiteArea;
 		if (!fillWhiteArea) { // remove tiles from panel
-			for (int i = mmp.images.size() -1; i &gt;= 0; i--) {
-				AniImage im = (AniImage) mmp.images.get(i);
-				if ((im instanceof MapImage)
-						&amp;&amp; (!((im instanceof MapSymbol)
-								|| (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+			for (int i = mmp.images.size() - 1; i &gt;= 0; i--) {
+				final AniImage im = (AniImage) mmp.images.get(i);
+				if ((im instanceof MapImage) &amp;&amp; (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
 					mmp.images.remove(im);
 				}
 			}
 		}
 	}
 
-	public boolean getShowCachesOnMap() {return pref.showCachesOnMap; }
 	public void setShowCachesOnMap(boolean value) {
 		if (value != pref.showCachesOnMap) {
-			pref.showCachesOnMap=value;
+			pref.showCachesOnMap = value;
 		}
 		if (!value) {
 			removeAllMapSymbols();
 		}
 
 	}
-	
-	
+
 	public boolean isMobileVga() {
 		return mobileVGA;
 	}
-	
+
 	public InteractivePanel getMmp() {
 		return mmp;
 	}
-	
+
 	public MovingMapControls getControlsLayer() {
 		return controlsLayer;
 	}
 
-	public MovingMap(Navigate nav, CacheDB cacheDB){
+	public MovingMap(Navigate nav, CacheDB cacheDB) {
 		this.cacheDB = cacheDB;
 		this.myNavigation = nav;
 		this.pref = Global.getPref();
-		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)	this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
-//      The following line is commented out, because this caused trouble under ewe-vm v1.49 on win-xp
-//      when MovingMap was started with maximized CacheWolf-Window
-//		this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE | UIConstants.BDR_NOBORDER;
+		if (pref.myAppHeight &lt;= 640 &amp;&amp; pref.myAppWidth &lt;= 640)
+			this.windowFlagsToSet = WindowConstants.FLAG_FULL_SCREEN;
+		// The following line is commented out, because this caused trouble
+		// under ewe-vm v1.49 on win-xp
+		// when MovingMap was started with maximized CacheWolf-Window
+		// this.windowFlagsToClear = WindowConstants.FLAG_HAS_TITLE |
+		// UIConstants.BDR_NOBORDER;
 		this.hasTopBar = false;
 		this.noBorder = true;
 		this.setPreferredSize(pref.myAppWidth, pref.myAppHeight);
-//		this.setPreferredSize(240,320);
+		// this.setPreferredSize(240,320);
 		this.title = &quot;Moving Map&quot;;
-		this.backGround = new Color(254,254,254); // background must not be black because black is interpreted as transparent and transparent images above (eg trackoverlay) want be drawn in windows-VM, so be care, don|t use white either
+		this.backGround = new Color(254, 254, 254); // background must not
+													// be black because
+													// black is interpreted
+													// as transparent and
+													// transparent images
+													// above (eg
+													// trackoverlay) want be
+													// drawn in windows-VM,
+													// so be care, don|t use
+													// white either
 
 		mmp = new MovingMapPanel(this);
 		this.addLast(mmp);
 
-		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400) 
+		if (Vm.isMobile() &amp;&amp; MyLocale.getScreenWidth() &gt;= 400)
 			mobileVGA = true;
-		String imagesize=&quot;&quot;;
-		if(mobileVGA) imagesize=&quot;_vga&quot;;
+		String imagesize = &quot;&quot;;
+		if (mobileVGA)
+			imagesize = &quot;_vga&quot;;
 
-		
-		statusImageHaveSignal = new AniImage(&quot;position_green&quot;+imagesize+&quot;.png&quot;);
-		statusImageNoSignal = new AniImage(&quot;position_yellow&quot;+imagesize+&quot;.png&quot;);
-		statusImageNoGps = new AniImage(&quot;position_red&quot;+imagesize+&quot;.png&quot;);
-		posCircle = new MapSymbol(&quot;position_green&quot;+imagesize+&quot;.png&quot;, &quot;gps-position&quot;, new CWPoint());
-		MARK_CACHE_IMAGE = &quot;mark_cache.png&quot;;
-		//directionArrows
+		statusImageHaveSignal = new AniImage(&quot;position_green&quot; + imagesize + &quot;.png&quot;);
+		statusImageNoSignal = new AniImage(&quot;position_yellow&quot; + imagesize + &quot;.png&quot;);
+		statusImageNoGps = new AniImage(&quot;position_red&quot; + imagesize + &quot;.png&quot;);
+		posCircle = new MapSymbol(&quot;position_green&quot; + imagesize + &quot;.png&quot;, &quot;gps-position&quot;, new CWPoint());
+		// directionArrows
 		directionArrows.properties = mImage.AlwaysOnTop;
 		mmp.addImage(directionArrows);
-		//target distance
-		int fontSize = ( 3 * pref.fontSize ) / 2;
-		Font imageFont = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize );
+		// target distance
+		final int fontSize = (3 * pref.fontSize) / 2;
+		final Font imageFont = new Font(&quot;Helvetica&quot;, Font.PLAIN, fontSize);
 		fm = getFontMetrics(imageFont);
 		setGpsStatus(noGPS);
 		posCircle.properties = mImage.AlwaysOnTop;
@@ -238,56 +255,70 @@
 		mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 		lastHighestResolutionGPSDestScale = -1;
 
-		lastRepaintMapPos = new Point(pref.myAppWidth +1, pref.myAppHeight +1);
-		
+		lastRepaintMapPos = new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
+
 		controlsLayer = new MovingMapControls(this);
-		
-		
+
 	}
 
-	public void resizeTo(int w,int h) {
+	public void resizeTo(int w, int h) {
 		super.resizeTo(w, h);
 		updateFormSize(w, h);
 	}
 
 	public void updateFormSize(int w, int h) {
 		MapImage.setScreenSize(w, h);
-		directionArrows.setLocation(w/2-directionArrows.getWidth()/2, 10);
-		if (mmp.mapImage != null) mmp.mapImage.screenDimChanged();
-		if (posCircle != null) posCircle.screenDimChanged();
-		if (tracks != null) rebuildOverlaySet();
-		if (symbols != null) { // TODO: see if the rest of the code works with symbols = null
-			for (int i = symbols.size() -1; i &gt;= 0; i-- ) {
-				((MapSymbol)symbols.get(i)).screenDimChanged();
+		directionArrows.setLocation(w / 2 - directionArrows.getWidth() / 2, 10);
+		if (mmp.mapImage != null)
+			mmp.mapImage.screenDimChanged();
+		if (posCircle != null)
+			posCircle.screenDimChanged();
+		if (tracks != null)
+			rebuildOverlaySet();
+		if (symbols != null) { // TODO: see if the rest of the code works
+								// with symbols = null
+			for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+				((MapSymbol) symbols.get(i)).screenDimChanged();
 			}
 		}
-		if (controlsLayer!=null) {
+		if (controlsLayer != null) {
 			controlsLayer.updateFormSize(w, h);
 		}
 	}
 
 	boolean loadingMapList = false;
+
 	/**
 	 * loads the list of maps
-	 * @param mapsPath must not have a trailing end &quot;/&quot;
-	 * @param lat used to create empty maps with correct conversion from lon to meters the latitude must be known
+	 * 
+	 * @param mapsPath
+	 *            must not have a trailing end &quot;/&quot;
+	 * @param lat
+	 *            used to create empty maps with correct conversion from lon
+	 *            to meters the latitude must be known
 	 */
-	public void loadMaps(String mapsPath, double lat){
-		if (loadingMapList) return;
+	public void loadMaps(String mapsPath, double lat) {
+		if (loadingMapList)
+			return;
 		loadingMapList = true;
-		InfoBox inf = new InfoBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(4203, &quot;Loading list of maps...&quot;));
+		final InfoBox inf = new InfoBox(MyLocale.getMsg(4201, &quot;Info&quot;), MyLocale.getMsg(4203, &quot;Loading list of maps...&quot;));
 		Vm.showWait(this, true);
 		inf.exec();
 		inf.waitUntilPainted(100);
 		resetCenterOfMap();
-		boolean saveGpsIgnoreStatus = dontUpdatePos;
+		final boolean saveGpsIgnoreStatus = dontUpdatePos;
 		dontUpdatePos = true;
 		maps = new MapsList(mapsPath); // this actually loads the maps
 		if (maps.isEmpty()) {
-			(new MessageBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4204, &quot;No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated&quot;), FormBase.OKB)).execute();
+			(new MessageBox(MyLocale.getMsg(4201, &quot;Information&quot;), MyLocale.getMsg(4204, &quot;No georeferenced map available \n Please choose a scale \n to show the track and the caches. \n You can get one by the menu: Application/Maps/download calibrated&quot;),
+					FormBase.OKB)).execute();
 			noMapsAvailable = true;
-		} else noMapsAvailable = false;
-		maps.addEmptyMaps(lat); // the empty maps must be added last, otherwise in method setBestMap, when no map is available, a malfunction will happen, see there
+		} else
+			noMapsAvailable = false;
+		maps.addEmptyMaps(lat); // the empty maps must be added last,
+								// otherwise in method setBestMap, when no
+								// map is available, a malfunction will
+								// happen, see there
 		maps.onCompletedRead();
 		dontUpdatePos = saveGpsIgnoreStatus;
 		inf.close(0);
@@ -298,11 +329,10 @@
 
 	public void updateScale() {
 
-		if (currentMap != null)
-		{
+		if (currentMap != null) {
 			double lineLengthMeters = 40 * currentMap.scale;
 
-			int metricSystem = pref.metricSystem;
+			final int metricSystem = pref.metricSystem;
 			double localizedLineLength = 0;
 			int bigUnit = -1;
 			int smallUnit = -1;
@@ -313,7 +343,7 @@
 				smallUnit = Metrics.FEET;
 				threshold = 501;
 
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, smallUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, smallUnit);
 			} else {
 				bigUnit = Metrics.KILOMETER;
 				smallUnit = Metrics.METER;
@@ -324,53 +354,50 @@
 
 			int currentUnit = smallUnit;
 
-			float digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-			localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+			float digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+			localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 
-			if (localizedLineLength &gt;= threshold)
-			{
+			if (localizedLineLength &gt;= threshold) {
 				currentUnit = bigUnit;
-				localizedLineLength = Metrics.convertUnit( lineLengthMeters, Metrics.METER, currentUnit);
+				localizedLineLength = Metrics.convertUnit(lineLengthMeters, Metrics.METER, currentUnit);
 
-				digits = (float)java.lang.Math.floor( java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0) );
-				localizedLineLength = (float)java.lang.Math.ceil( localizedLineLength / (float)java.lang.Math.pow(10, digits) ) * (float)java.lang.Math.pow(10, digits);
+				digits = (float) java.lang.Math.floor(java.lang.Math.log(localizedLineLength) / java.lang.Math.log(10.0));
+				localizedLineLength = (float) java.lang.Math.ceil(localizedLineLength / (float) java.lang.Math.pow(10, digits)) * (float) java.lang.Math.pow(10, digits);
 			}
 
 			String lineLengthString = Convert.toString((int) localizedLineLength) + Metrics.getUnit(currentUnit);
 
-			if	(digits &lt; 0){
-				Double tmp = new Double();
+			if (digits &lt; 0) {
+				final Double tmp = new Double();
 				tmp.set(localizedLineLength);
 
-				int decimals = (int)(-1 * digits);
+				final int decimals = (int) (-1 * digits);
 
-				lineLengthString = tmp.toString(decimals+2,decimals,0) + Metrics.getUnit(currentUnit);
-//				lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) + Metrics.getUnit(currentUnit);
+				lineLengthString = tmp.toString(decimals + 2, decimals, 0) + Metrics.getUnit(currentUnit);
+				// lineLengthString = MyLocale.formatDouble(tmp,&quot;0.000&quot;) +
+				// Metrics.getUnit(currentUnit);
 			}
 
-			lineLengthMeters = Metrics.convertUnit( localizedLineLength, currentUnit, Metrics.METER);
+			lineLengthMeters = Metrics.convertUnit(localizedLineLength, currentUnit, Metrics.METER);
 
-			int lineLengthPixels = (int)java.lang.Math.round( lineLengthMeters / currentMap.scale );
+			final int lineLengthPixels = (int) java.lang.Math.round(lineLengthMeters / currentMap.scale);
 
 			controlsLayer.updateContent(&quot;scale&quot;, lineLengthString, lineLengthPixels);
-		}
-		else{
+		} else {
 
-		controlsLayer.updateContent(&quot;scale&quot;, &quot;no map&quot;, 20);
+			controlsLayer.updateContent(&quot;scale&quot;, &quot;no map&quot;, 20);
 		}
 	}
 
 	public void updateDistance(boolean repaint) {
-		if (gotoPos != null &amp;&amp; posCircle.where.isValid())
-		{
-			double currentDistance = gotoPos.where.getDistance(posCircle.where);
-			if (currentDistance != lastDistance)
-			{
+		if (gotoPos != null &amp;&amp; posCircle.where.isValid()) {
+			final double currentDistance = gotoPos.where.getDistance(posCircle.where);
+			if (currentDistance != lastDistance) {
 				lastDistance = currentDistance;
-				ewe.sys.Double dd = new ewe.sys.Double();
+				final ewe.sys.Double dd = new ewe.sys.Double();
 				String d;
 
-				int metricSystem = pref.metricSystem;
+				final int metricSystem = pref.metricSystem;
 				double localizedDistance = 0;
 				int bigUnit = -1;
 				int smallUnit = -1;
@@ -389,42 +416,45 @@
 					localizedDistance = currentDistance;
 				}
 				dd.set(localizedDistance);
-				if (dd.value &gt;= threshold){
-					d = MyLocale.formatDouble(dd,&quot;0.000&quot;) + Metrics.getUnit(bigUnit);
+				if (dd.value &gt;= threshold) {
+					d = MyLocale.formatDouble(dd, &quot;0.000&quot;) + Metrics.getUnit(bigUnit);
 				} else {
 					dd.set(Metrics.convertUnit(dd.value, bigUnit, smallUnit));
-					d = dd.toString(3,0,0) + Metrics.getUnit(smallUnit);
+					d = dd.toString(3, 0, 0) + Metrics.getUnit(smallUnit);
 				}
 
 				controlsLayer.updateContent(&quot;distance&quot;, d);
 
 			}
-		}
-		else
-		{
+		} else {
 			controlsLayer.updateContent(&quot;distance&quot;, &quot;&quot;);
 		}
 	}
 
 	public void forceMapLoad() {
 		forceMapLoad = true;
-		updatePosition(posCircle.where); // this sets forceMapLoad to false after loading a map
+		updatePosition(posCircle.where); // this sets forceMapLoad to
+											// false after loading a map
 	}
 
 	public final FormFrame myExec(CWPoint centerTo, boolean forceCenter) {
-		FormFrame ret = exec();
+		final FormFrame ret = exec();
 		running = true;
-		// disconnect movingMap from GPS TODO only if GPS-pos is not on the screen
-		if (forceCenter) setGpsStatus(noGPS);
-		// to load maplist + place a map on screen otherwise no symbol can be placed
-		ignoreGps=true; // else overlay symbols are removed on started gps
-		
+		// disconnect movingMap from GPS TODO only if GPS-pos is not on the
+		// screen
+		if (forceCenter)
+			setGpsStatus(noGPS);
+		// to load maplist + place a map on screen otherwise no symbol can
+		// be placed
+		ignoreGps = true; // else overlay symbols are removed on started
+							// gps
+
 		rebuildOverlaySet(); // show tracks , even if reentering map
-		
+
 		updatePosition(centerTo);
 		setCenterOfScreen(centerTo, false);
-		
-		if (getControlsLayer()!=null) {
+
+		if (getControlsLayer() != null) {
 			getControlsLayer().changeRoleState(MovingMapControls.ROLE_MENU, false);
 		}
 
@@ -432,50 +462,39 @@
 		if (Global.getProfile().selectionChanged) {
 			// this means marking has changed
 			Global.getProfile().selectionChanged = false;
-			if (getShowCachesOnMap()) removeAllMapSymbols(); // not really needed: hopefully removed by showCachesOnMap
+			if (pref.showCachesOnMap)
+				removeAllMapSymbols(); // not really needed: hopefully
+										// removed by showCachesOnMap
 		}
-		setMarkedCache(Global.mainTab.ch); // this is the selected one (not necessary marked)
 		showCachesOnMap();
-		
+
 		if (myNavigation.destinationIsCache) {
 			destChanged(myNavigation.destinationCache);
-		}
-		else {
+		} else {
 			destChanged(myNavigation.destination);
 		}
 
 		repaint();
-		ignoreGps=false;
-		
+		ignoreGps = false;
+
 		return ret;
 	}
 
-	public void setMarkedCache(CacheHolder ch) {
-		if (ch == markedCache) return;
-		if (markedCache != null) {
-			removeMapSymbol(&quot;selectedCache&quot;);
-			if (!markedCache.is_Checked) removeMapSymbol(markedCache);
-		}
-		if (ch != null) {
-			if ( ch.pos.isValid()) {
-				addSymbol(&quot;selectedCache&quot;, MARK_CACHE_IMAGE, ch.pos);
-				addSymbolIfNecessary(ch.getCacheName(), ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
-				markedCache = ch;
-			}
-		}
-	}
-
 	public void addTrack(Track tr) {
-		if (tr == null) return;
-		if (tracks == null) tracks = new Vector();
-		if (tracks.find(tr) &gt;= 0 ) return; // track already in list
+		if (tr == null)
+			return;
+		if (tracks == null)
+			tracks = new Vector();
+		if (tracks.find(tr) &gt;= 0)
+			return; // track already in list
 		tracks.add(tr);
 		rebuildOverlaySet();
 	}
 
 	public void addTracks(Track[] trs) {
-		if (trs==null || trs.length == 0) return;
-		for (int i=0; i&lt;trs.length; i++) {
+		if (trs == null || trs.length == 0)
+			return;
+		for (int i = 0; i &lt; trs.length; i++) {
 			addTrack(trs[i]);
 		}
 		rebuildOverlaySet();
@@ -483,26 +502,30 @@
 
 	/**
 	 * adds an 3x3 set of overlays to the map-window which contain the track
-	 *
+	 * 
 	 * add tracks with addtrack(track) before
 	 */
 
 	public void addOverlaySet() {
-		if (tracks == null) return; // no tracks
+		if (tracks == null)
+			return; // no tracks
 		try {
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 			addMissingOverlays();
-		} catch (NullPointerException e) {
+		} catch (final NullPointerException e) {
 			// hapens if currentmap == null or PosCircle not valid
+		} catch (final IllegalArgumentException e) {
+			// happens if screensize is still not known ---&gt; in both cases
+			// creation of Overlayset will be done in updateOverlayPos if
+			// tracks != null
 		}
-		catch (IllegalArgumentException e) {
-			// happens if screensize is still not known    ---&gt; in both cases creation of Overlayset will be done in updateOverlayPos if tracks != null
-		}
 	}
 
 	public void destroyOverlaySet() {
 		if (TrackOverlays != null) {
-			for (int i=0; i&lt; TrackOverlays.length; i++) {	destroyOverlay(i);	}
+			for (int i = 0; i &lt; TrackOverlays.length; i++) {
+				destroyOverlay(i);
+			}
 		}
 		Vm.getUsedMemory(true); // call garbage collection
 		Vm.gc();
@@ -514,24 +537,49 @@
 	}
 
 	public void addMissingOverlays() {
-		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0) return; // height == 0 happens if this is called before the form ist displayed on the screen
+		if (currentMap == null || (!posCircle.where.isValid()) || width == 0 || height == 0)
+			return; // height == 0 happens if this is called before the form
+					// ist displayed on the screen
 		if (TrackOverlays == null) {
 			TrackOverlays = new TrackOverlay[9];
 			TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
 		}
-		boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid multi-threading problems
+		final boolean saveGPSIgnoreStatus = dontUpdatePos; // avoid
+															// multi-threading
+															// problems
 		dontUpdatePos = true;
-		Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4] == center of Trackoverlays
-		//upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 * width;
-		//upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1 * height;
+		final Point upperleftOf4 = getXYonScreen(TrackOverlaySetCenterTopLeft); // TrackOverlay[4]
+																				// ==
+																				// center
+																				// of
+																				// Trackoverlays
+		// upperleftOf4.x = (upperleftOf4.x + 1* width) % (width * 2) - 1 *
+		// width;
+		// upperleftOf4.y = (upperleftOf4.y + 1* height) % (height * 2) - 1
+		// * height;
 		int i;
-		for (int yi=0; yi&lt;3; yi++) {
-			for (int xi=0; xi&lt;3; xi++) {
-				i = yi*3+xi;
-				if (TrackOverlays[i]==null) {
+		for (int yi = 0; yi &lt; 3; yi++) {
+			for (int xi = 0; xi &lt; 3; xi++) {
+				i = yi * 3 + xi;
+				if (TrackOverlays[i] == null) {
 					pref.log(&quot;addMissingOverlays: widht: &quot; + width + &quot;, height: &quot; + height);
-					TrackOverlays[i]= new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x+(xi-1)*width, upperleftOf4.y+(yi-1)*height), width, height, currentMap);
-					TrackOverlays[i].setLocation(width+1, height+1); // outside of the screen will hide it automatically it will get the correct position in upadteOverlayposition
+					TrackOverlays[i] = new TrackOverlay(ScreenXY2LatLon(upperleftOf4.x + (xi - 1) * width, upperleftOf4.y + (yi - 1) * height), width, height, currentMap);
+					TrackOverlays[i].setLocation(width + 1, height + 1); // outside
+																			// of
+																			// the
+																			// screen
+																			// will
+																			// hide
+																			// it
+																			// automatically
+																			// it
+																			// will
+																			// get
+																			// the
+																			// correct
+																			// position
+																			// in
+																			// upadteOverlayposition
 					TrackOverlays[i].tracks = this.tracks;
 					TrackOverlays[i].paintTracks();
 					mmp.addImage(TrackOverlays[i]);
@@ -539,29 +587,32 @@
 			}
 		}
 		updateOverlayOnlyPos();
-		if (mmp.mapImage != null) mmp.images.moveToBack(mmp.mapImage);
+		if (mmp.mapImage != null)
+			mmp.images.moveToBack(mmp.mapImage);
 		dontUpdatePos = saveGPSIgnoreStatus;
 	}
 
 	private void destroyOverlay(int ov) {
-		if (TrackOverlays[ov] == null) return;
+		if (TrackOverlays[ov] == null)
+			return;
 		mmp.removeImage(TrackOverlays[ov]);
 		TrackOverlays[ov].free();
-		TrackOverlays[ov]=null;
+		TrackOverlays[ov] = null;
 	}
+
 	public void rearangeOverlays() {
-		Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
+		final Point oldp = getXYonScreen(TrackOverlaySetCenterTopLeft);
 		if (TrackOverlays[1].isOnScreen()) { // oben raus
-			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2* height));
+			TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y - 2 * height));
 			destroyOverlay(6);
 			destroyOverlay(7);
 			destroyOverlay(8);
 			mmp.removeImage(TrackOverlays[0]);
 			mmp.removeImage(TrackOverlays[1]);
 			mmp.removeImage(TrackOverlays[2]);
-			TrackOverlays[6]=TrackOverlays[0];
-			TrackOverlays[7]=TrackOverlays[1];
-			TrackOverlays[8]=TrackOverlays[2];
+			TrackOverlays[6] = TrackOverlays[0];
+			TrackOverlays[7] = TrackOverlays[1];
+			TrackOverlays[8] = TrackOverlays[2];
 			mmp.addImage(TrackOverlays[6]);
 			mmp.addImage(TrackOverlays[7]);
 			mmp.addImage(TrackOverlays[8]);
@@ -573,16 +624,16 @@
 			destroyOverlay(5);
 		} else {
 			if (TrackOverlays[3].isOnScreen()) { // links raus
-				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y ));
+				TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y));
 				destroyOverlay(2);
 				destroyOverlay(5);
 				destroyOverlay(8);
 				mmp.removeImage(TrackOverlays[0]);
 				mmp.removeImage(TrackOverlays[3]);
 				mmp.removeImage(TrackOverlays[6]);
-				TrackOverlays[2]=TrackOverlays[0];
-				TrackOverlays[5]=TrackOverlays[3];
-				TrackOverlays[8]=TrackOverlays[6];
+				TrackOverlays[2] = TrackOverlays[0];
+				TrackOverlays[5] = TrackOverlays[3];
+				TrackOverlays[8] = TrackOverlays[6];
 				mmp.addImage(TrackOverlays[2]);
 				mmp.addImage(TrackOverlays[5]);
 				mmp.addImage(TrackOverlays[8]);
@@ -594,16 +645,16 @@
 				destroyOverlay(7);
 			} else {
 				if (TrackOverlays[5].isOnScreen()) { // rechts raus
-					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y ));
+					TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y));
 					destroyOverlay(0);
 					destroyOverlay(3);
 					destroyOverlay(6);
 					mmp.removeImage(TrackOverlays[2]);
 					mmp.removeImage(TrackOverlays[5]);
 					mmp.removeImage(TrackOverlays[8]);
-					TrackOverlays[0]=TrackOverlays[2];
-					TrackOverlays[3]=TrackOverlays[5];
-					TrackOverlays[6]=TrackOverlays[8];
+					TrackOverlays[0] = TrackOverlays[2];
+					TrackOverlays[3] = TrackOverlays[5];
+					TrackOverlays[6] = TrackOverlays[8];
 					mmp.addImage(TrackOverlays[0]);
 					mmp.addImage(TrackOverlays[3]);
 					mmp.addImage(TrackOverlays[6]);
@@ -615,16 +666,16 @@
 					destroyOverlay(7);
 				} else {
 					if (TrackOverlays[7].isOnScreen()) { // unten raus
-						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2* height));
+						TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x, oldp.y + 2 * height));
 						destroyOverlay(0);
 						destroyOverlay(1);
 						destroyOverlay(2);
 						mmp.removeImage(TrackOverlays[6]);
 						mmp.removeImage(TrackOverlays[7]);
 						mmp.removeImage(TrackOverlays[8]);
-						TrackOverlays[0]=TrackOverlays[6];
-						TrackOverlays[1]=TrackOverlays[7];
-						TrackOverlays[2]=TrackOverlays[8];
+						TrackOverlays[0] = TrackOverlays[6];
+						TrackOverlays[1] = TrackOverlays[7];
+						TrackOverlays[2] = TrackOverlays[8];
 						mmp.addImage(TrackOverlays[0]);
 						mmp.addImage(TrackOverlays[1]);
 						mmp.addImage(TrackOverlays[2]);
@@ -634,12 +685,14 @@
 						destroyOverlay(3);
 						destroyOverlay(4);
 						destroyOverlay(5);
-					} else { // it is important to test for diagonal only if the other didn't match
-						if (TrackOverlays[0].isOnScreen()) {  // links oben raus
-							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y - 2* height));
+					} else { // it is important to test for diagonal only
+								// if the other didn't match
+						if (TrackOverlays[0].isOnScreen()) { // links
+																// oben raus
+							TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y - 2 * height));
 							destroyOverlay(8);
 							mmp.removeImage(TrackOverlays[0]);
-							TrackOverlays[8]=TrackOverlays[0];
+							TrackOverlays[8] = TrackOverlays[0];
 							mmp.addImage(TrackOverlays[8]);
 							TrackOverlays[0] = null;
 							destroyOverlay(1);
@@ -650,11 +703,13 @@
 							destroyOverlay(6);
 							destroyOverlay(7);
 						} else {
-							if (TrackOverlays[2].isOnScreen()) { // rechts oben raus
-								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y - 2* height));
+							if (TrackOverlays[2].isOnScreen()) { // rechts
+																	// oben
+																	// raus
+								TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y - 2 * height));
 								destroyOverlay(6);
 								mmp.removeImage(TrackOverlays[2]);
-								TrackOverlays[6]=TrackOverlays[2];
+								TrackOverlays[6] = TrackOverlays[2];
 								mmp.addImage(TrackOverlays[6]);
 								TrackOverlays[2] = null;
 								destroyOverlay(0);
@@ -665,11 +720,13 @@
 								destroyOverlay(7);
 								destroyOverlay(8);
 							} else {
-								if (TrackOverlays[6].isOnScreen()) { // links unten raus
-									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2* width, oldp.y + 2* height));
+								if (TrackOverlays[6].isOnScreen()) { // links
+																		// unten
+																		// raus
+									TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x - 2 * width, oldp.y + 2 * height));
 									destroyOverlay(2);
 									mmp.removeImage(TrackOverlays[6]);
-									TrackOverlays[2]=TrackOverlays[6];
+									TrackOverlays[2] = TrackOverlays[6];
 									mmp.addImage(TrackOverlays[2]);
 									TrackOverlays[6] = null;
 									destroyOverlay(0);
@@ -680,11 +737,13 @@
 									destroyOverlay(7);
 									destroyOverlay(8);
 								} else {
-									if (TrackOverlays[8].isOnScreen()) { // rechts unten raus
-										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2* width, oldp.y + 2* height));
+									if (TrackOverlays[8].isOnScreen()) { // rechts
+																			// unten
+																			// raus
+										TrackOverlaySetCenterTopLeft.set(ScreenXY2LatLon(oldp.x + 2 * width, oldp.y + 2 * height));
 										destroyOverlay(0);
 										mmp.removeImage(TrackOverlays[8]);
-										TrackOverlays[0]=TrackOverlays[8];
+										TrackOverlays[0] = TrackOverlays[8];
 										mmp.addImage(TrackOverlays[0]);
 										TrackOverlays[8] = null;
 										destroyOverlay(1);
@@ -694,49 +753,60 @@
 										destroyOverlay(5);
 										destroyOverlay(6);
 										destroyOverlay(7);
-									}else
-										for (int i=0; i&lt;TrackOverlays.length; i++) {
+									} else
+										for (int i = 0; i &lt; TrackOverlays.length; i++) {
 											destroyOverlay(i);
 											TrackOverlaySetCenterTopLeft = ScreenXY2LatLon(100, 100);
-										} // this happens if a position jump occured
-								}}}}}}} // close all IFs
+										} // this happens if a position
+											// jump occured
+								}
+							}
+						}
+					}
+				}
+			}
+		} // close all IFs
 		Vm.gc(); // call garbage collection
 	}
 
 	public void ShowLastAddedPoint(Track tr) {
-		if (TrackOverlays == null || tr == null) return;
-		for (int i=0; i&lt;TrackOverlays.length; i++){
+		if (TrackOverlays == null || tr == null)
+			return;
+		for (int i = 0; i &lt; TrackOverlays.length; i++) {
 			TrackOverlays[i].paintLastAddedPoint(tr);
 		}
 	}
 
 	public void updateOverlayOnlyPos() {
-		if (TrackOverlays == null || TrackOverlays[4] == null) return;
-		//	Point upperleft = getMapXYPosition();
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			return;
+		// Point upperleft = getMapXYPosition();
 		Point posOnScreen;
 		posOnScreen = getXYonScreen(TrackOverlays[4].topLeft);
-		Dimension ws = mmp.getSize(null);
-		int ww = ws.width;
-		int wh = ws.height;
-		//Vm.sleep(100); // this is necessary because the ewe vm ist not multi-threaded and the serial thread also needs time
+		final Dimension ws = mmp.getSize(null);
+		final int ww = ws.width;
+		final int wh = ws.height;
+		// Vm.sleep(100); // this is necessary because the ewe vm ist not
+		// multi-threaded and the serial thread also needs time
 		int num, pX, pY;
-		for (int yi=0; yi&lt;3; yi++) {
-			for (int xi=0; xi&lt;3; xi++) {
-				num = yi*3+xi;
-				pX = posOnScreen.x+(xi-1)*ww;
-				pY = posOnScreen.y+(yi-1)*wh;
+		for (int yi = 0; yi &lt; 3; yi++) {
+			for (int xi = 0; xi &lt; 3; xi++) {
+				num = yi * 3 + xi;
+				pX = posOnScreen.x + (xi - 1) * ww;
+				pY = posOnScreen.y + (yi - 1) * wh;
 				TrackOverlays[num].setLocation(pX, pY);
 			}
 		}
 	}
 
 	public void updateOverlayPos() {
-		if (tracks == null || tracks.size() == 0) return;
-		if (TrackOverlays == null || TrackOverlays[4] == null) addMissingOverlays();
+		if (tracks == null || tracks.size() == 0)
+			return;
+		if (TrackOverlays == null || TrackOverlays[4] == null)
+			addMissingOverlays();
 		else {
 			updateOverlayOnlyPos();
-			if (TrackOverlays[0].locAlways.x &gt; 0 || TrackOverlays[2].locAlways.x &lt; 0
-					|| TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
+			if (TrackOverlays[0].locAlways.x &gt; 0 || TrackOverlays[2].locAlways.x &lt; 0 || TrackOverlays[0].locAlways.y &gt; 0 || TrackOverlays[8].locAlways.y &lt; 0) { // testForNeedToRearange
 				rearangeOverlays();
 				addMissingOverlays();
 				// updateOverlayOnlyPos(); is called from addMissingOverlays
@@ -746,249 +816,289 @@
 
 	/**
 	 * move posCircle to the Centre of the Screen
-	 *
+	 * 
 	 */
 	public void resetCenterOfMap() {
 		if (width != 0) {
-			posCircleX = width /2;
-			posCircleY = height /2;
+			posCircleX = width / 2;
+			posCircleY = height / 2;
 		} else {
-			posCircleX = pref.myAppWidth/2; // maybe this could /should be repleced to windows size
-			posCircleY = pref.myAppHeight/2;
+			// maybe this could / should be replaced to windows size
+			posCircleX = pref.myAppWidth / 2;
+			posCircleY = pref.myAppHeight / 2;
 		}
 		posCircle.hidden = false;
-		posCircle.move(posCircleX-posCircle.getWidth()/2, posCircleY-posCircle.getHeight()/2); // posCircle.setLocation caused a problem -&gt; hiding the posCircle in some situation
+		posCircle.move(posCircleX - posCircle.getWidth() / 2, posCircleY - posCircle.getHeight() / 2);
+		// posCircle.setLocation a problem -&gt; hiding the posCircle in some situation
 	}
 
 	public void movePosCircleToLatLon(CWPoint p, boolean repaint) {
 		moveScreenXYtoLatLon(new Point(posCircleX, posCircleY), p, repaint);
 	}
 
-	public void setCenterOfScreen (CWPoint c, boolean repaint) {
-		moveScreenXYtoLatLon(new Point (this.width/2, this.height/2), c, repaint);
+	public void setCenterOfScreen(CWPoint c, boolean repaint) {
+		moveScreenXYtoLatLon(new Point(this.width / 2, this.height / 2), c, repaint);
 	}
 
 	public void moveScreenXYtoLatLon(Point s, CWPoint c, boolean repaint) {
-		Point mappos = getMapPositionOnScreen();
-		Point onscreenpos = getXYonScreen(c);
-		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
+		final Point mappos = getMapPositionOnScreen();
+		final Point onscreenpos = getXYonScreen(c);
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.move(mappos.x - onscreenpos.x + s.x, mappos.y - onscreenpos.y + s.y);
 		mapMoved(s.x - onscreenpos.x, s.y - onscreenpos.y);
-		if (repaint) mmp.repaintNow();
+		if (repaint)
+			mmp.repaintNow();
 	}
 
-	/** call this if the map moved on the screen (by dragging)
-	 * this routine will adjust (move accordingly) all other symbols on the screen
+	/**
+	 * call this if the map moved on the screen (by dragging) this routine
+	 * will adjust (move accordingly) all other symbols on the screen
+	 * 
 	 * @param diffX
 	 * @param diffY
 	 */
 	public void mapMoved(int diffX, int diffY) {
-		int w = posCircle.getWidth();
-		int h = posCircle.getHeight();
-		int npx = posCircleX-w/2+diffX;
-		int npy = posCircleY-h/2+diffY;
+		final int w = posCircle.getWidth();
+		final int h = posCircle.getHeight();
+		final int npx = posCircleX - w / 2 + diffX;
+		final int npy = posCircleY - h / 2 + diffY;
 		posCircle.move(npx, npy);
-		posCircleX = posCircleX+diffX;
-		posCircleY = posCircleY+diffY;
-		if (posCircle.where.isValid()){
+		posCircleX = posCircleX + diffX;
+		posCircleY = posCircleY + diffY;
+		if (posCircle.where.isValid()) {
 			dontUpdatePos = false;
 			updatePosition(posCircle.where);
-		}
-		else updateSymbolPositions(); // will also be done in updatePosition
+		} else
+			// will also be done in updatePosition
+			updateSymbolPositions();
 		updateOverlayPos();
 	}
 
 	/**
-	 * get upper left corner of map on window
-	 * this is called when the map needs to be moved / the position of the map is wanted
-	 * the map-position is calculated relativ to posCircle (x,y and lat/lon)
-	 * returns the same as mmp.mapImage.getLocation(mapPos);
-	 * but also works if mmp == null and is used to move the map to the correct point
+	 * get upper left corner of map on window this is called when the map
+	 * needs to be moved / the position of the map is wanted the
+	 * map-position is calculated relativ to posCircle (x,y and lat/lon)
+	 * returns the same as mmp.mapImage.getLocation(mapPos); but also works
+	 * if mmp == null and is used to move the map to the correct point
+	 * 
 	 * @return
 	 */
 	public Point getMapPositionOnScreen() {
 		if (currentMap == null || !posCircle.where.isValid())
-			return new Point(pref.myAppWidth +1, pref.myAppHeight +1);
-		// in case no calculation is possible return somthing outside of the screen
-		Point mapPos = new Point();
-		//if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
-		//else {
-		Point mapposint = currentMap.calcMapXY(posCircle.where);
+			return new Point(pref.myAppWidth + 1, pref.myAppHeight + 1);
+		// in case no calculation is possible return somthing outside of the
+		// screen
+		final Point mapPos = new Point();
+		// if (mmp.mapImage != null) mmp.mapImage.getLocation(mapPos);
+		// else {
+		final Point mapposint = currentMap.calcMapXY(posCircle.where);
 		mapPos.x = posCircleX - mapposint.x;
 		mapPos.y = posCircleY - mapposint.y;
-		//}
+		// }
 		return mapPos;
 	}
 
 	/**
-	 *
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
 	 */
-	public Point getXYonScreen(TrackPoint ll){
-		if (currentMap == null) return null;
-		Point coords = currentMap.calcMapXY(ll);
-		Point mapPos = getMapPositionOnScreen();
+	public Point getXYonScreen(TrackPoint ll) {
+		if (currentMap == null)
+			return null;
+		final Point coords = currentMap.calcMapXY(ll);
+		final Point mapPos = getMapPositionOnScreen();
 		return new Point(coords.x + mapPos.x, coords.y + mapPos.y);
 	}
 
-	public CWPoint ScreenXY2LatLon (int px, int py){
-		Point mapPos = getMapPositionOnScreen();
+	public CWPoint ScreenXY2LatLon(int px, int py) {
+		final Point mapPos = getMapPositionOnScreen();
 		return currentMap.calcLatLon(px - mapPos.x, py - mapPos.y);
 	}
 
-
 	public void updateSymbolPositions() {
-		if (symbols == null) return;
+		if (symbols == null)
+			return;
 		Point pOnScreen;
 		MapSymbol symb;
 		int w, h;
 		showCachesOnMap();
-		for (int i=symbols.size()-1; i&gt;=0; i--) {
-			symb = (MapSymbol)symbols.get(i);
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			symb = (MapSymbol) symbols.get(i);
 			pOnScreen = getXYonScreen(symb.where);
-			w=symb.getWidth();
-			h=symb.getHeight();
-			symb.move(pOnScreen.x-w/2, pOnScreen.y-h/2);
+			w = symb.getWidth();
+			h = symb.getHeight();
+			symb.move(pOnScreen.x - w / 2, pOnScreen.y - h / 2);
 		}
 	}
 
 	public MapSymbol addSymbol(String pName, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, filename, where);
+		if (symbols == null)
+			symbols = new Vector();
+		final MapSymbol ms = new MapSymbol(pName, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		final Point pOnScreen = getXYonScreen(where);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
 	public MapSymbol addSymbol(String pName, Object mapObject, String filename, CWPoint where) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
+		if (symbols == null)
+			symbols = new Vector();
+		final MapSymbol ms = new MapSymbol(pName, mapObject, filename, where);
 		ms.loadImage();
 		ms.properties |= mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(where);
-		ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		final Point pOnScreen = getXYonScreen(where);
+		ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 		return ms;
 	}
 
-	public void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
-		if (findMapSymbol(pName) &gt;= 0) return;
-		else addSymbol(pName, mapObject, imSymb, where);
+	private boolean addSymbolIsNecessary(String pName) {
+		if (findMapSymbol(pName) &gt;= 0)
+			return false;
+		else
+			return true;
 	}
 
+	private void addSymbolIfNecessary(String pName, Object mapObject, Image imSymb, CWPoint where) {
+		if (findMapSymbol(pName) &gt;= 0)
+			return;
+		else
+			addSymbol(pName, mapObject, imSymb, where);
+	}
+
 	public void addSymbolOnTop(String pName, Object mapObject, String filename, CWPoint where) {
-		removeMapSymbol(pName); // Object possibly removes another picture from screen
-		addSymbol(pName,mapObject,filename, where);
+		removeMapSymbol(mapObject);
+		addSymbol(pName, mapObject, filename, where);
 	}
 
 	public void addSymbol(String pName, Object mapObject, Image imSymb, CWPoint ll) {
-		if (symbols==null) symbols=new Vector();
-		MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
+		if (symbols == null)
+			symbols = new Vector();
+		final MapSymbol ms = new MapSymbol(pName, mapObject, imSymb, ll);
 		ms.properties = mImage.AlwaysOnTop;
-		Point pOnScreen = getXYonScreen(ll);
-		if (pOnScreen != null) ms.setLocation(pOnScreen.x-ms.getWidth()/2, pOnScreen.y-ms.getHeight()/2);
+		final Point pOnScreen = getXYonScreen(ll);
+		if (pOnScreen != null)
+			ms.setLocation(pOnScreen.x - ms.getWidth() / 2, pOnScreen.y - ms.getHeight() / 2);
 		symbols.add(ms);
 		mmp.addImage(ms);
 	}
 
 	public void destChanged(CWPoint d) {
-		if(!running || (d == null &amp;&amp; gotoPos == null) ||
-				(d != null &amp;&amp; gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
+		if (!running || (d == null &amp;&amp; gotoPos == null) || (d != null &amp;&amp; gotoPos != null &amp;&amp; gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol(&quot;goto&quot;);
-		if (d == null || !d.isValid() ) return;
+		if (d == null || !d.isValid())
+			return;
 		gotoPos = addSymbol(&quot;goto&quot;, &quot;goto_map.png&quot;, d);
-		//updateDistance(); - this is called from updatePosition
 		forceMapLoad = true;
-		if (this.width != 0) updatePosition(posCircle.where); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+		// dirty hack: if this.width == 0, then the symbols are not on the
+		// screen
+		// and get hidden by updateSymbolPositions
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
 	public void destChanged(CacheHolder ch) {
-		CWPoint d = new CWPoint (ch.pos);
-		if(!running || (gotoPos != null &amp;&amp; gotoPos.where.equals(d))) return;
+		final CWPoint d = new CWPoint(ch.getPos());
+		if (!running || (gotoPos != null &amp;&amp; gotoPos.where.equals(d)))
+			return;
 		removeMapSymbol(&quot;goto&quot;);
-		if (!d.isValid() ) return;
+		if (!d.isValid())
+			return;
 		gotoPos = addSymbol(&quot;goto&quot;, ch, &quot;goto_map.png&quot;, d);
-		//updateDistance(); - this is called from updatePosition
 		forceMapLoad = true;
-		if (this.width != 0) updatePosition(posCircle.where); // dirty hack: if this.width == 0, then the symbols are not on the screen and get hidden by updateSymbolPositions
+		// dirty hack: if this.width == 0, then the symbols are not on the
+		// screen
+		// and get hidden by updateSymbolPositions
+		if (this.width != 0)
+			updatePosition(posCircle.where);
 	}
 
-	public CWPoint getGotoPos(){
-		if (gotoPos == null) return null;
+	public CWPoint getGotoPos() {
+		if (gotoPos == null)
+			return null;
 		return new CWPoint(gotoPos.where);
 	}
 
-	public void removeAllMapSymbols(){
-		if (symbols == null) return;
-		for (int i = symbols.size()-1; i &gt;= 0; i--) {
-			mmp.removeImage((MapSymbol)symbols.get(i));
+	public void removeAllMapSymbols() {
+		if (symbols == null)
+			return;
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			mmp.removeImage((MapSymbol) symbols.get(i));
 		}
 		symbols.removeAllElements();
 	}
 
 	public void removeMapSymbol(String pName) {
-		int symbNr = findMapSymbol(pName);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		final int symbNr = findMapSymbol(pName);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(Object obj) {
-		int symbNr = findMapSymbol(obj);
-		if (symbNr != -1) removeMapSymbol(symbNr);
+		final int symbNr = findMapSymbol(obj);
+		if (symbNr != -1)
+			removeMapSymbol(symbNr);
 	}
 
 	public void removeMapSymbol(int SymNr) {
-		mmp.removeImage(((MapSymbol)symbols.get(SymNr)));
+		mmp.removeImage(((MapSymbol) symbols.get(SymNr)));
 		symbols.removeElementAt(SymNr);
 	}
 
 	public int findMapSymbol(String pName) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.name == pName) return i;
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.name == pName)
+				return i;
 		}
 		return -1;
 	}
 
 	public int findMapSymbol(Object obj) {
-		if (symbols == null) return -1;
+		if (symbols == null)
+			return -1;
 		MapSymbol ms;
-		for (int i = symbols.size() -1; i &gt;= 0 ; i--) {
-			ms= (MapSymbol)symbols.get(i);
-			if (ms.mapObject == obj) return i;
+		for (int i = symbols.size() - 1; i &gt;= 0; i--) {
+			ms = (MapSymbol) symbols.get(i);
+			if (ms.mapObject == obj)
+				return i;
 		}
 		return -1;
 	}
 
 	/**
 	 * Move the map so that the posCircle is at lat/lon
-	 *
+	 * 
 	 * @param
 	 */
-	public void updateOnlyPosition(CWPoint where, boolean updateOverlay){
+	public void updateOnlyPosition(CWPoint where, boolean updateOverlay) {
 		posCircle.where.set(where);
-		Point mapPos = getMapPositionOnScreen();
-		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1))
-		{
+		final Point mapPos = getMapPositionOnScreen();
+		if (forceMapLoad || (java.lang.Math.abs(lastRepaintMapPos.x - mapPos.x) &gt; 1 || java.lang.Math.abs(lastRepaintMapPos.y - mapPos.y) &gt; 1)) {
 			lastRepaintMapPos = mapPos;
-			if (mmp.mapImage != null) 	mmp.mapImage.move(mapPos.x, mapPos.y);
+			if (mmp.mapImage != null)
+				mmp.mapImage.move(mapPos.x, mapPos.y);
 			updateSymbolPositions();
 			updateDistance(false);
-			if (updateOverlay ) updateOverlayPos(); // &amp;&amp; TrackOverlays != null
+			if (updateOverlay)
+				updateOverlayPos(); // &amp;&amp; TrackOverlays != null
 			repaint(); // don't wait
-		}
-		else
-		{
+		} else {
 			updateDistance(true);
 		}
 	}
+
 	private void loadBestMap(CWPoint where) {
 		if (!mapsloaded || !this.maps.getMapsPath().equals(pref.getCustomMapsPath())) {
 			loadMaps(pref.getCustomMapsPath(), where.latDec);
@@ -999,46 +1109,47 @@
 			forceMapLoad = false;
 		}
 	}
+
 	/**
-	 * Method to laod the best map for lat/lon and move the map so that the posCircle is at lat/lon
+	 * Method to laod the best map for lat/lon and move the map so that the
+	 * posCircle is at lat/lon
 	 */
-	public void updatePosition(CWPoint where){
-		if (dontUpdatePos || loadingMapList) return; // avoid multi-threading problems
+	public void updatePosition(CWPoint where) {
+		if (dontUpdatePos || loadingMapList || (where.latDec == 0 &amp;&amp; where.lonDec == 0))
+			return; // avoid multi-threading problems
 		loadBestMap(where);
-		if (width==0 || height==0) { pref.log(&quot;[MovingMap:updatePosition]no window shown&quot;); return; } // why is this called with these values
+		if (width == 0 || height == 0) {
+			pref.log(&quot;[MovingMap:updatePosition]no window shown&quot;);
+			return;
+		} // why is this called with these values
 		updateOnlyPosition(where, true);
-		Point mapPos = getMapPositionOnScreen();
-		boolean screenNotCompletlyCovered = (mmp.mapImage == null)
-				|| (mmp.mapImage != null &amp;&amp; (
-				   mapPos.y &gt; 0                                      || mapPos.x                           &gt; 0
-				|| mapPos.y + mmp.mapImage.getHeight() &lt; this.height || mapPos.x + mmp.mapImage.getWidth() &lt; this.width));
-		//if screendimensions changed also force reload of map
+		final Point mapPos = getMapPositionOnScreen();
+		final boolean screenNotCompletlyCovered = (mmp.mapImage == null) || (mmp.mapImage != null &amp;&amp; (mapPos.y &gt; 0 || mapPos.x &gt; 0 || mapPos.y + mmp.mapImage.getHeight() &lt; this.height || mapPos.x + mmp.mapImage.getWidth() &lt; this.width));
+		// if screendimensions changed also force reload of map
 		forceMapLoad |= lastWidth != width || lastHeight != height;
-		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) { // if force || want || map doesn't cover the screen completly
-			if (forceMapLoad ||
-				(java.lang.Math.abs(lastCompareX - mapPos.x) &gt; this.width / 10 ||
-				 java.lang.Math.abs(lastCompareY - mapPos.y) &gt; this.height / 10)) {
-				// more then 1/10 of screen moved since last time we tried to find a better map
+		if (forceMapLoad || wantMapTest || screenNotCompletlyCovered) {
+			if (forceMapLoad || (java.lang.Math.abs(lastCompareX - mapPos.x) &gt; this.width / 10 || java.lang.Math.abs(lastCompareY - mapPos.y) &gt; this.height / 10)) {
+				// more then 1/10 of screen moved since last time we tried
+				// to find a better map
 				if (autoSelectMap) {
 					setBestMap(where, screenNotCompletlyCovered);
 					forceMapLoad = false;
 				}
-				if (isFillWhiteArea()) { fillWhiteArea(screenNotCompletlyCovered); }
+				if (isFillWhiteArea()) {
+					fillWhiteArea(screenNotCompletlyCovered);
+				}
 				lastCompareX = mapPos.x;
 				lastCompareY = mapPos.y;
-			}
-			else{
-				int deltaX = mapPos.x - lastXPos;
-				int deltaY = mapPos.y - lastYPos;
-				for(int i = mmp.images.size() -1; i &gt;= 0; i--){
-					AniImage im = (AniImage) mmp.images.get(i);
-					if ((im instanceof MapImage)
-						&amp;&amp; (!((im instanceof MapSymbol)
-							|| (im instanceof TrackOverlay)
-							|| mmp.mapImage == im))) {
-						//locAlways contains the real coordinates while
-						//location is only correct if the image is on the screen.
-						Point p = ((MapImage)im).locAlways;
+			} else {
+				final int deltaX = mapPos.x - lastXPos;
+				final int deltaY = mapPos.y - lastYPos;
+				for (int i = mmp.images.size() - 1; i &gt;= 0; i--) {
+					final AniImage im = (AniImage) mmp.images.get(i);
+					if ((im instanceof MapImage) &amp;&amp; (!((im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im))) {
+						// locAlways contains the real coordinates while
+						// location is only correct if the image is on the
+						// screen.
+						final Point p = ((MapImage) im).locAlways;
 						p.x += deltaX;
 						p.y += deltaY;
 						im.setLocation(p.x, p.y);
@@ -1056,223 +1167,250 @@
 	private void showCachesOnMap() {
 		// if (width == 0 || height == 0) return;
 		CacheHolder ch;
-		Area screenArea = new Area(ScreenXY2LatLon(0,0), ScreenXY2LatLon(width,height));
+		final Area screenArea = new Area(ScreenXY2LatLon(0, 0), ScreenXY2LatLon(width, height));
 		for (int i = cacheDB.size() - 1; i &gt;= 0; i--) {
 			ch = cacheDB.get(i);
-			if (screenArea.isInBound(ch.pos)) {
-				// because visible and valid don't change while showing map --&gt;need no remove
-				if (ch.isVisible() &amp;&amp; ch.pos.isValid()) {
-					if (getShowCachesOnMap()) {
-						addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
-					}
-					else {
-						if (ch.is_Checked) {
-							addSymbolIfNecessary(ch.cacheName, ch, GuiImageBroker.getTypeImage(ch.getType(),true), ch.pos);
+			if (screenArea.isInBound(ch.getPos())) {
+				// because visible and valid don't change while showing map
+				// --&gt;need no remove
+				if (ch.isVisible() &amp;&amp; ch.getPos().isValid()) {
+					if (pref.showCachesOnMap) {
+						if (addSymbolIsNecessary(ch.getWayPoint())) {
+							addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
 						}
-						else {
+					} else {
+						if (ch.is_Checked || ch == cacheDB.get(Global.mainTab.tbP.getSelectedCache())) {
+							if (addSymbolIsNecessary(ch.getWayPoint())) {
+								addSymbol(ch.getWayPoint(), ch, CacheType.getMapImage(ch), ch.getPos());
+							}
+						} else {
 							removeMapSymbol(ch);
 						}
 					}
 				}
-			}else{
-				if (ch.cacheName.equals(&quot;&quot;)) {
-					removeMapSymbol(ch);
-				}
-				else {
-					// remove the right one , as
-					// possibly more than one picture associated with ch (target,selected ..)
-					removeMapSymbol(ch.cacheName);
-				}
+			} else {
+				removeMapSymbol(ch);
 			}
 		}
 		// adding target and selected
 		// show target
 		if (gotoPos != null) {
-			// the CacheHolder Symbol must be inserted too, even if not marked (if it is Cache)
+			// the CacheHolder Symbol must be inserted too, even if not
+			// marked (if it is Cache)
 			// anywhere there if all Caches shown on map
 			CacheHolder gotoPosCH = null;
 			if (gotoPos.mapObject instanceof CacheHolder) {
 				gotoPosCH = (CacheHolder) gotoPos.mapObject;
 			}
 			if (gotoPosCH != null) {
-				if (screenArea.isInBound(gotoPosCH.pos)) {
-					if (!getShowCachesOnMap()) {
-						addSymbolIfNecessary(gotoPosCH.cacheName, gotoPosCH, GuiImageBroker.getTypeImage(gotoPosCH.getType(),true), gotoPosCH.pos);
+				if (screenArea.isInBound(gotoPosCH.getPos())) {
+					if (!pref.showCachesOnMap) {
+						addSymbolIfNecessary(gotoPosCH.getWayPoint(), gotoPosCH, CacheType.getMapImage(gotoPosCH), gotoPosCH.getPos());
 					}
-					addSymbolOnTop(&quot;goto&quot;, gotoPosCH, &quot;goto_map.png&quot;, gotoPos.where);
+					addSymbolIfNecessary(&quot;goto&quot;, gotoPosCH, imgGoto, gotoPos.where);
 				}
 			}
 		}
-		// show Selected
-		if (markedCache != null) {
-			if (screenArea.isInBound(markedCache.pos)) {
-				addSymbolIfNecessary(markedCache.cacheName, markedCache, GuiImageBroker.getTypeImage(markedCache.getType(),true), markedCache.pos);
-				addSymbolOnTop(&quot;selectedCache&quot;, markedCache, MARK_CACHE_IMAGE, markedCache.pos);
+		// mark Selected
+		removeMapSymbol(&quot;selectedCache&quot;);
+		ch = cacheDB.get(Global.mainTab.tbP.getSelectedCache());
+		if (ch != null) {
+			if (screenArea.isInBound(ch.getPos())) {
+				addSymbolIfNecessary(&quot;selectedCache&quot;, ch, imgSelectedCache, ch.getPos());
 			}
 		}
 	}
-	boolean reflectResourceException=true;
+
+	boolean reflectResourceException = true;
+
 	private void fillWhiteArea(boolean screenNotCompletlyCovered) {
-		if (mmp.mapImage == null) return; // if error at map load
+		if (mmp.mapImage == null)
+			return; // if error at map load
 		// Clean up any additional images, tiles will removed and any
 		// other item be added again later
-		Vector icons = new Vector(mmp.images.size());
-		try {			
-		Vm.showWait(true);
-		dontUpdatePos=true; // no new Position while filling
-		
-		int s = mmp.images.size(); // avoid calling size() in each iteration
-		for (int i = 0; i &lt; s ;  i++) {
-			AniImage im = (AniImage) mmp.images.get(i);
-			if (!(im instanceof MapImage) ||
-				(im instanceof MapSymbol) ||
-				(im instanceof TrackOverlay) ||
-				mmp.mapImage == im) {
-				icons.add(im);
+		final Vector icons = new Vector(mmp.images.size());
+		try {
+			Vm.showWait(true);
+			dontUpdatePos = true; // no new Position while filling
+
+			final int s = mmp.images.size(); // avoid calling size() in
+												// each iteration
+			for (int i = 0; i &lt; s; i++) {
+				final AniImage im = (AniImage) mmp.images.get(i);
+				if (!(im instanceof MapImage) || (im instanceof MapSymbol) || (im instanceof TrackOverlay) || mmp.mapImage == im) {
+					icons.add(im);
+				}
 			}
-		}
-		mmp.images.clear();
-		// Mark all tiles as dirty
-		MovingMapCache.getCache().clearUsedFlags();
+			mmp.images.clear();
+			// Mark all tiles as dirty
+			MovingMapCache.getCache().clearUsedFlags();
 
-		// Holds areas not filled by currentmap and/or used tiles
-		Vector rectangles = new Vector();
-		// calculate areas which will not drawn
-		Point mapPosx = getMapPositionOnScreen();
-		if ( screenNotCompletlyCovered &amp;&amp; ( // screen not completely covered is only used, because it is already calculated
-				mapPosx.x &gt; this.width || mapPosx.y &gt; this.height // map doesn't overlap with the screen
-				|| mapPosx.x + mmp.mapImage.getWidth() &lt; 0 || mapPosx.y + mmp.mapImage.getHeight() &lt; 0) ) {
-			rectangles.add(new Rect(0,0, this.width, this.height)); // if the map is completely outside the screen, just fill the screen, nit all the space beteween the map and the screen
-		} else {
-			Rect whiteArea = new Rect((int)(-width/10), (int)(-height/10), (int)(width*1.1), (int)(height*1.1));
-			Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
-			calculateRectangles(blackArea, whiteArea, rectangles);
-		}
-		// I've sometimes experienced an endless loop which might be
-		// caused by a bug in getBestMap. Therefore i will stop the loop
-		// after 30 runs
-		int count = 0;
-		while (isFillWhiteArea() &amp;&amp; currentMap.zoomFactor == 1.0
-				&amp;&amp; !mapHidden &amp;&amp; !rectangles.isEmpty() &amp;&amp; count &lt; 30) {
-			count++;
-			try {
-				updateTileForWhiteArea(rectangles);
+			// Holds areas not filled by currentmap and/or used tiles
+			final Vector rectangles = new Vector();
+			// calculate areas which will not drawn
+			final Point mapPosx = getMapPositionOnScreen();
+			if (screenNotCompletlyCovered &amp;&amp; ( // screen not completely
+												// covered is only used,
+												// because it is already
+												// calculated
+					mapPosx.x &gt; this.width || mapPosx.y &gt; this.height // map
+																		// doesn't
+																		// overlap
+																		// with
+																		// the
+																		// screen
+							|| mapPosx.x + mmp.mapImage.getWidth() &lt; 0 || mapPosx.y + mmp.mapImage.getHeight() &lt; 0)) {
+				rectangles.add(new Rect(0, 0, this.width, this.height)); // if
+																			// the
+																			// map
+																			// is
+																			// completely
+																			// outside
+																			// the
+																			// screen,
+																			// just
+																			// fill
+																			// the
+																			// screen,
+																			// nit
+																			// all
+																			// the
+																			// space
+																			// beteween
+																			// the
+																			// map
+																			// and
+																			// the
+																			// screen
+			} else {
+				final Rect whiteArea = new Rect((-width / 10), (-height / 10), (int) (width * 1.1), (int) (height * 1.1));
+				final Rect blackArea = new Rect(mapPosx.x, mapPosx.y, mmp.mapImage.getWidth(), mmp.mapImage.getHeight());
+				calculateRectangles(blackArea, whiteArea, rectangles);
 			}
-			catch (ewe.sys.SystemResourceException sre) {
-				// next time there may be no problem, and ask only once
-				if (reflectResourceException) {
-					if (new MessageBox(
-							&quot;Error&quot;,
-							&quot;Not enough ressources to fill white ares, disabling this&quot;,
-							MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
-						setFillWhiteArea(false);
-						reflectResourceException=true;
+			// I've sometimes experienced an endless loop which might be
+			// caused by a bug in getBestMap. Therefore i will stop the loop
+			// after 30 runs
+			int count = 0;
+			while (isFillWhiteArea() &amp;&amp; currentMap.zoomFactor == 1.0 &amp;&amp; !mapHidden &amp;&amp; !rectangles.isEmpty() &amp;&amp; count &lt; 30) {
+				count++;
+				try {
+					updateTileForWhiteArea(rectangles);
+				} catch (final ewe.sys.SystemResourceException sre) {
+					// next time there may be no problem, and ask only once
+					if (reflectResourceException) {
+						if (new MessageBox(&quot;Error&quot;, &quot;Not enough ressources to fill white ares, disabling this&quot;, MessageBox.YESB | MessageBox.NOB).execute() == MessageBox.IDYES) {
+							setFillWhiteArea(false);
+							reflectResourceException = true;
+						} else {
+							reflectResourceException = false;
+						}
 					}
-					else {
-						reflectResourceException=false;						
-					}
 				}
 			}
-		}
-		} 
-		finally {
+		} finally {
 			// Remove all tiles not needed from the cache to reduce memory
 			MovingMapCache.getCache().cleanCache();
 			// At Last redraw all icons on the map
 			mmp.images.addAll(icons);
-			Vm.showWait(false);		
-			dontUpdatePos=false; // do next Position 
+			Vm.showWait(false);
+			dontUpdatePos = false; // do next Position
 			repaint();
-		} 
+		}
 	}
+
 	private void updateTileForWhiteArea(Vector rectangles) {
 		Rect blackArea;
-		Rect r = (Rect) rectangles.get(0);
+		final Rect r = (Rect) rectangles.get(0);
 		rectangles.removeElementAt(0);
-		//calculate the center of the rectangle and try to get an map for it
-		int middlewidth = r.x + (r.width)/2;
-		int middleheight = r.y + (r.height)/2;
-		CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
-		Rect screen = new Rect ();
-		screen.height = r.height ;//- r.y;
-		screen.width = r.width ;//- r.x;
-		MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true,false);
-		if (bestMap == null){
-			//No map found, area must be left white
+		// calculate the center of the rectangle and try to get an map for
+		// it
+		final int middlewidth = r.x + (r.width) / 2;
+		final int middleheight = r.y + (r.height) / 2;
+		final CWPoint centerPoint = ScreenXY2LatLon(middlewidth, middleheight);
+		final Rect screen = new Rect();
+		screen.height = r.height;// - r.y;
+		screen.width = r.width;// - r.x;
+		final MapInfoObject bestMap = maps.getBestMap(centerPoint, screen, currentMap.scale, true, false);
+		if (bestMap == null) {
+			// No map found, area must be left white
 			return;
 		}
-		//A map was found, but it does not contain the previously calculated center
-		if (!(bestMap.buttomright.latDec &lt;= centerPoint.latDec &amp;&amp; centerPoint.latDec &lt;= bestMap.topleft.latDec)){
+		// A map was found, but it does not contain the previously
+		// calculated center
+		if (!(bestMap.bottomright.latDec &lt;= centerPoint.latDec &amp;&amp; centerPoint.latDec &lt;= bestMap.topleft.latDec)) {
 			return;
 		}
-		if (!(bestMap.topleft.lonDec &lt;= centerPoint.lonDec &amp;&amp; centerPoint.lonDec &lt;= bestMap.buttomright.lonDec)){
+		if (!(bestMap.topleft.lonDec &lt;= centerPoint.lonDec &amp;&amp; centerPoint.lonDec &lt;= bestMap.bottomright.lonDec)) {
 			return;
 		}
-		//Pfeffer got an NPE in the following if-statement. I think the image-filename has got not the correct extension.
-		//For me, showing a message seems better than throwing the NPE
-		String imagefilename = bestMap.getImageFilename();
-		if (imagefilename == null){
-			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, FormBase.OKB)).execute();
+		// Pfeffer got an NPE in the following if-statement. I think the
+		// image-filename has got not the correct extension.
+		// For me, showing a message seems better than throwing the NPE
+		final String imagefilename = bestMap.getImageFilename();
+		if (imagefilename == null) {
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;) + currentMap.fileNameWFL, FormBase.OKB)).execute();
 			return;
 		}
 
 		if (!imagefilename.equals(currentMap.getImageFilename())) {
-			String filename = bestMap.getImageFilename();
+			final String filename = bestMap.getImageFilename();
 			if (filename.length() &gt; 0) {
-				//calculate position of the new map on the screen
-				Point mapPos = new Point();
-				Point mapposint = bestMap.calcMapXY(posCircle.where);
+				// calculate position of the new map on the screen
+				final Point mapPos = new Point();
+				final Point mapposint = bestMap.calcMapXY(posCircle.where);
 				mapPos.x = posCircleX - mapposint.x;
 				mapPos.y = posCircleY - mapposint.y;
-				Point mapDimension = bestMap.calcMapXY(bestMap.buttomright);
-				blackArea = new Rect (mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
-				//Are there any white areas left?
+				final Point mapDimension = bestMap.calcMapXY(bestMap.bottomright);
+				blackArea = new Rect(mapPos.x, mapPos.y, mapDimension.x, mapDimension.y);
+				// Are there any white areas left?
 				calculateRectangles(blackArea, r, rectangles);
-				//Not all maps have the dimension 1000x1000 Pixels, we cache this information:
-				Dimension rect2 = MovingMapCache.getCache().getDimension (filename);
+				// Not all maps have the dimension 1000x1000 Pixels, we
+				// cache this information:
+				Dimension rect2 = MovingMapCache.getCache().getDimension(filename);
 				MapImage fullImage = null;
-				if (rect2 == null){
+				if (rect2 == null) {
 					fullImage = new MapImage(filename);
-					rect2 = new Dimension (fullImage.getHeight(), fullImage.getWidth());
-					MovingMapCache.getCache ().putDimension (filename, rect2);
+					rect2 = new Dimension(fullImage.getHeight(), fullImage.getWidth());
+					MovingMapCache.getCache().putDimension(filename, rect2);
 				}
 				generateTiles(blackArea, filename, mapPos, rect2, fullImage);
 			}
 		}
 	}
 
-	private void generateTiles(Rect blackArea, String filename, Point mapPos,
-			Dimension rect2, MapImage fullImage) {
-		//Generate tiles from the map
-		int numRows = ((rect2.height-1)/tileHeight)+1;
-		int numCols = ((rect2.width-1)/tileWidth)+1;
+	private void generateTiles(Rect blackArea, String filename, Point mapPos, Dimension rect2, MapImage fullImage) {
+		// Generate tiles from the map
+		final int numRows = ((rect2.height - 1) / tileHeight) + 1;
+		final int numCols = ((rect2.width - 1) / tileWidth) + 1;
 		for (int row = 0; row &lt; numRows; row++) {
 			for (int column = 0; column &lt; numCols; column++) {
-				//Tile is not needed, don't process
+				// Tile is not needed, don't process
 				if (!isCoveredByBlackArea(mapPos, row, column, blackArea, rect2)) {
 					continue;
 				}
-				//Get tile from cache or if not found, put all tiles for this image into the cache.
+				// Get tile from cache or if not found, put all tiles for
+				// this image into the cache.
 				MapImage im = MovingMapCache.getCache().get(filename, row, column);
 				if (im == null) {
-					if (fullImage == null){
+					if (fullImage == null) {
 						fullImage = new MapImage(filename);
 					}
 					putImageIntoCache(filename, fullImage, mapPos, blackArea);
 					im = MovingMapCache.getCache().get(filename, row, column);
 				}
-				//If a tile has been found, draw it on the screen
+				// If a tile has been found, draw it on the screen
 				if (im != null) {
-					//Check if not already added. this might happen if the map for horizontal and vertical stripe is the same
-					boolean added=false;
-					for(int i=mmp.images.size()-1; i &gt;= 0; i--) {
-						MapImage m=(MapImage) mmp.images.get(i);
-						if (m == im){
-							added=true;
+					// Check if not already added. this might happen if the
+					// map for horizontal and vertical stripe is the same
+					boolean added = false;
+					for (int i = mmp.images.size() - 1; i &gt;= 0; i--) {
+						final MapImage m = (MapImage) mmp.images.get(i);
+						if (m == im) {
+							added = true;
 							break;
 						}
 					}
-					if(!added){
+					if (!added) {
 						im.setLocation(mapPos.x + (column * tileWidth), mapPos.y + (row * tileHeight));
 						mmp.addImage(im);
 					}
@@ -1283,17 +1421,17 @@
 
 	private void putImageIntoCache(String filename, MapImage fullImage, Point mapPos, Rect blackArea) {
 		MapImage im;
-		int numRows = (fullImage.getHeight()-1)/tileHeight + 1;
-		int numCols = (fullImage.getWidth()-1)/tileWidth + 1;
+		final int numRows = (fullImage.getHeight() - 1) / tileHeight + 1;
+		final int numCols = (fullImage.getWidth() - 1) / tileWidth + 1;
 		for (int row2 = 0; row2 &lt; numRows; row2++) {
 			for (int column2 = 0; column2 &lt; numCols; column2++) {
-				int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth*column2));
-				int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight*row2));
-				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))){
+				final int realWidth = java.lang.Math.min(tileWidth, (fullImage.getWidth() - tileWidth * column2));
+				final int realHeight = java.lang.Math.min(tileHeight, (fullImage.getHeight() - tileHeight * row2));
+				if (!isCoveredByBlackArea(mapPos, row2, column2, blackArea, new Dimension(fullImage.getWidth(), fullImage.getHeight()))) {
 					continue;
 				}
-				Image image2 = new Image(realWidth, realHeight);
-				int[] pixels = new int[realWidth * realHeight];
+				final Image image2 = new Image(realWidth, realHeight);
+				final int[] pixels = new int[realWidth * realHeight];
 				fullImage.getPixels(pixels, 0, tileWidth * column2, tileHeight * row2, realWidth, realHeight, 0);
 				image2.setPixels(pixels, 0, 0, 0, realWidth, realHeight, 0);
 				im = new MapImage();
@@ -1304,54 +1442,55 @@
 		}
 	}
 
-	private boolean isCoveredByBlackArea (Point mapPos, int row,int column,Rect blackArea, Dimension mapDimension){
-		int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth*column));
-		int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight*row));
-		int left = mapPos.x + column * tileWidth;
-		int right = left + realWidth;
-		int top = mapPos.y + row * tileHeight;
-		int bottom = top +realHeight;
-		if (right &lt; blackArea.x || bottom &lt; blackArea.y){
+	private boolean isCoveredByBlackArea(Point mapPos, int row, int column, Rect blackArea, Dimension mapDimension) {
+		final int realWidth = java.lang.Math.min(tileWidth, (mapDimension.width - tileWidth * column));
+		final int realHeight = java.lang.Math.min(tileHeight, (mapDimension.height - tileHeight * row));
+		final int left = mapPos.x + column * tileWidth;
+		final int right = left + realWidth;
+		final int top = mapPos.y + row * tileHeight;
+		final int bottom = top + realHeight;
+		if (right &lt; blackArea.x || bottom &lt; blackArea.y) {
 			return false;
 		}
-		if (left &gt; blackArea.x + blackArea.width || top &gt; blackArea.y + blackArea.height){
+		if (left &gt; blackArea.x + blackArea.width || top &gt; blackArea.y + blackArea.height) {
 			return false;
 		}
 		return true;
 	}
+
 	/*
-	private String SRect(Rect r){
-		String OL, UR ;
-		OL= &quot; (&quot;+String.valueOf(r.x)+&quot;,&quot;+String.valueOf(r.y)+&quot;)&quot;;
-		UR= &quot; (&quot;+String.valueOf(r.x+r.width)+&quot;,&quot;+String.valueOf(r.y+r.height)+&quot;) &quot;;
-		return OL+&quot; :&quot;+UR;
-	}
-	*/
+	 * private String SRect(Rect r){ String OL, UR ; OL= &quot;
+	 * (&quot;+String.valueOf(r.x)+&quot;,&quot;+String.valueOf(r.y)+&quot;)&quot;; UR= &quot;
+	 * (&quot;+String.valueOf(r.x+r.width)+&quot;,&quot;+String.valueOf(r.y+r.height)+&quot;) &quot;;
+	 * return OL+&quot; :&quot;+UR; }
+	 */
 	private void calculateRectangles(Rect blackArea, Rect whiteArea, Vector rectangles) {
-		if (width == 0 || height == 0) return;
-		int offsetX = width/10;
-		int offsetY = height/10;
-		int width=this.width+offsetX;
-		int height=this.height+offsetY;
-		if (whiteArea.x &gt;= width || whiteArea.y &gt;= height) return;
+		if (width == 0 || height == 0)
+			return;
+		final int offsetX = width / 10;
+		final int offsetY = height / 10;
+		final int width = this.width + offsetX;
+		final int height = this.height + offsetY;
+		if (whiteArea.x &gt;= width || whiteArea.y &gt;= height)
+			return;
 
-		if (blackArea.x &lt; -offsetX){
+		if (blackArea.x &lt; -offsetX) {
 			blackArea.width += blackArea.x + offsetX;
 			blackArea.x = -offsetX;
 		}
-		if (blackArea.y &lt; -offsetY){
+		if (blackArea.y &lt; -offsetY) {
 			blackArea.height += blackArea.y + offsetY;
 			blackArea.y = -offsetY;
 		}
-		if (blackArea.x + blackArea.width &gt; width){
+		if (blackArea.x + blackArea.width &gt; width) {
 			blackArea.width = width - blackArea.x;
 		}
-		if (blackArea.y + blackArea.height &gt; height){
+		if (blackArea.y + blackArea.height &gt; height) {
 			blackArea.height = height - blackArea.y;
 		}
 
 		if (blackArea.x &gt; whiteArea.x) {
-			Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = -offsetX;
 			r.y = whiteArea.y;
 			r.width = blackArea.x + offsetX;
@@ -1359,23 +1498,23 @@
 			rectangles.add(r);
 		}
 		if (blackArea.y &gt; whiteArea.y) {
-			Rect r= new Rect ();
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = -offsetY;
 			r.width = whiteArea.width;
 			r.height = blackArea.y + offsetY;
 			rectangles.add(r);
 		}
-		if ((blackArea.y + blackArea.height) &lt;  whiteArea.y + whiteArea.height) {
-			Rect r= new Rect ();
+		if ((blackArea.y + blackArea.height) &lt; whiteArea.y + whiteArea.height) {
+			final Rect r = new Rect();
 			r.x = whiteArea.x;
 			r.y = blackArea.y + blackArea.height;
 			r.width = whiteArea.width;
 			r.height = (whiteArea.y + whiteArea.height) - r.y;
 			rectangles.add(r);
 		}
-		if ((blackArea.x + blackArea.width)&lt;  whiteArea.x + whiteArea.width) {
-			Rect r= new Rect ();
+		if ((blackArea.x + blackArea.width) &lt; whiteArea.x + whiteArea.width) {
+			final Rect r = new Rect();
 			r.x = blackArea.x + blackArea.width;
 			r.y = whiteArea.y;
 			r.width = (whiteArea.x + whiteArea.width) - r.x;
@@ -1385,18 +1524,24 @@
 	}
 
 	public void updateGps(int fix) {
-		if (!running || ignoreGps) return;
-		// runMovingMap neccessary in case of multi-threaded Java-VM: 
+		if (!running || ignoreGps)
+			return;
+		// runMovingMap neccessary in case of multi-threaded Java-VM:
 		// ticked could be called during load of mmp
-		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats()&gt;= 0)) { // TODO is getSats really necessary?
-			directionArrows.setDirections((float)myNavigation.gpsPos.getBearing(myNavigation.destination),
-					(float)myNavigation.skyOrientationDir.lonDec, (float)myNavigation.gpsPos.getBear());
+		if ((fix &gt; 0) &amp;&amp; (myNavigation.gpsPos.getSats() &gt;= 0)) { // TODO
+																	// is
+																	// getSats
+																	// really
+																	// necessary?
+			directionArrows.setDirections((float) myNavigation.gpsPos.getBearing(myNavigation.destination), (float) myNavigation.skyOrientationDir.lonDec, (float) myNavigation.gpsPos.getBear());
 			setGpsStatus(MovingMap.gotFix);
 			updatePosition(myNavigation.gpsPos);
 			ShowLastAddedPoint(myNavigation.curTrack);
 		}
-		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats()== 0) 	setGpsStatus(MovingMap.lostFix);
-		if (fix &lt; 0 )	setGpsStatus(MovingMap.noGPSData);
+		if (fix == 0 &amp;&amp; myNavigation.gpsPos.getSats() == 0)
+			setGpsStatus(MovingMap.lostFix);
+		if (fix &lt; 0)
+			setGpsStatus(MovingMap.noGPSData);
 		controlsLayer.updateContent(&quot;hdop&quot;, Convert.toString(myNavigation.gpsPos.getHDOP()));
 		controlsLayer.updateContent(&quot;sats&quot;, Convert.toString(myNavigation.gpsPos.getSats()) + &quot;/&quot; + Convert.toString(myNavigation.gpsPos.getSatsInView()));
 	}
@@ -1405,81 +1550,132 @@
 		addTrack(myNavigation.curTrack);
 		ignoreGps = false;
 	}
+
 	public void gpsStoped() {
 		setGpsStatus(MovingMap.noGPS);
 	}
 
 	int mapChangeModus = HIGHEST_RESOLUTION_GPS_DEST;
 	float scaleWanted;
-	boolean wantMapTest = true; // if true updateposition calls setBestMap regulary even if the currentmap covers the whole screen
-	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen resolution as long as a map is available that overlaps with the screen and with the PosCircle - it changes the resolution if no such map is available. It wil cahnge back to the wanted scale as soon as a map becomes available (through movement of the GPS-receiver)
+	boolean wantMapTest = true; // if true updateposition calls setBestMap
+								// regulary even if the currentmap covers
+								// the whole screen
+	public final static int NORMAL_KEEP_RESOLUTION = 1; // keeps the choosen
+														// resolution as
+														// long as a map is
+														// available that
+														// overlaps with the
+														// screen and with
+														// the PosCircle -
+														// it changes the
+														// resolution if no
+														// such map is
+														// available. It wil
+														// cahnge back to
+														// the
+	// wanted scale as soon as a map becomes available (through movement of
+	// the GPS-receiver)
 	public final static int HIGHEST_RESOLUTION = 2;
 	public final static int HIGHEST_RESOLUTION_GPS_DEST = 3;
 	boolean inBestMap = false; // to avoid multi-threading problems
 
 	/**
-	 * loads the best map for lat/lon according to mapChangeModus
-	 * lat/lon will be at the screen-pos of posCircle
-	 * when posCircle is not on the screen (shifted outside my the user)
-	 * then this routine uses the centre of the screen to find the best map
-	 * but anyway the map will be adjusted (moved) relativ to posCircle
-	 * when a better map was found the called method updateposition will set
-	 * posCirleLat/-Lon to lat/lon.
-	 *
+	 * loads the best map for lat/lon according to mapChangeModus lat/lon
+	 * will be at the screen-pos of posCircle when posCircle is not on the
+	 * screen (shifted outside my the user) then this routine uses the
+	 * centre of the screen to find the best map but anyway the map will be
+	 * adjusted (moved) relativ to posCircle when a better map was found the
+	 * called method updateposition will set posCirleLat/-Lon to lat/lon.
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @param loadIfSameScale
-	 * 			false: will not change the map if the better map has the same scale as the current
-	 * 			  - this is used not to change the map if it covers already the screen completely
-	 * 			true: willchange the map, regardless of change in scale
+	 *            false: will not change the map if the better map has the
+	 *            same scale as the current - this is used not to change the
+	 *            map if it covers already the screen completely true:
+	 *            willchange the map, regardless of change in scale
 	 */
 	public void setBestMap(CWPoint where, boolean loadIfSameScale) {
-		if (inBestMap) return;
+		if (inBestMap)
+			return;
 		inBestMap = true;
-		Object [] s = getRectForMapChange(where);
-		CWPoint cll = (CWPoint) s[0];
-		Rect screen = (Rect) s[1];
-		boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
+		final Object[] s = getRectForMapChange(where);
+		final CWPoint cll = (CWPoint) s[0];
+		final Rect screen = (Rect) s[1];
+		final boolean posCircleOnScreen = ((Boolean) s[2]).booleanValue();
 		MapInfoObject newmap = null;
 		wantMapTest = true;
 		switch (mapChangeModus) {
 		case NORMAL_KEEP_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, scaleWanted, false,true);
-			if (newmap == null) newmap = currentMap;
-			if (MapsList.scaleEquals(scaleWanted, newmap)) wantMapTest = false;
+			newmap = maps.getBestMap(cll, screen, scaleWanted, false, true);
+			if (newmap == null)
+				newmap = currentMap;
+			if (MapsList.scaleEquals(scaleWanted, newmap))
+				wantMapTest = false;
 			break;
 		case HIGHEST_RESOLUTION:
 			lastHighestResolutionGPSDestScale = -1;
-			newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+			newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			break;
 		case HIGHEST_RESOLUTION_GPS_DEST:
-			if (gotoPos!= null &amp;&amp; GpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
-				if ( ( !posCircleOnScreen ) &amp;&amp; ( lastHighestResolutionGPSDestScale &gt; 0 ) ) {
-					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+			if (gotoPos != null &amp;&amp; GpsStatus != noGPS &amp;&amp; posCircle.where.isValid()) {
+				if ((!posCircleOnScreen) &amp;&amp; (lastHighestResolutionGPSDestScale &gt; 0)) {
+					newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 				} else {
-					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO use home-coos if no gps? - consider start from details panel and from gotopanel
-					if (newmap == null)	newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false,true); // use map with most available overview if no map containing PosCircle and GotoPos is available
+					newmap = maps.getMapForArea(posCircle.where, gotoPos.where); // TODO
+																					// use
+																					// home-coos
+																					// if
+																					// no
+																					// gps?
+																					// -
+																					// consider
+																					// start
+																					// from
+																					// details
+																					// panel
+																					// and
+																					// from
+																					// gotopanel
+					if (newmap == null)
+						newmap = maps.getBestMap(cll, screen, 10000000000000000000000000000000000f, false, true); // use
+																													// map
+																													// with
+																													// most
+																													// available
+																													// overview
+																													// if
+																													// no
+																													// map
+																													// containing
+																													// PosCircle
+																													// and
+																													// GotoPos
+																													// is
+																													// available
 
 					if (newmap != null) {
 						lastHighestResolutionGPSDestScale = newmap.scale;
 
 						if (!posCircleOnScreen) {
-							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale , false,true);
+							newmap = maps.getBestMap(cll, screen, lastHighestResolutionGPSDestScale, false, true);
 						}
 					}
 				}
 			}
-			//	either Goto-Pos or GPS-Pos not set
+			// either Goto-Pos or GPS-Pos not set
 			else {
 				lastHighestResolutionGPSDestScale = -1;
-				newmap = maps.getBestMap(cll, screen, 0.000001f, false,true);
+				newmap = maps.getBestMap(cll, screen, 0.000001f, false, true);
 			}
 			break;
-		default: (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, FormBase.OKB)).execute(); break;
+		default:
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4208, &quot;Bug: \nillegal mapChangeModus: &quot;) + mapChangeModus, FormBase.OKB)).execute();
+			break;
 		}
-		if ( newmap != null &amp;&amp; (currentMap == null || !currentMap.mapName.equals(newmap.mapName)) ) {
-			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap) ) {
+		if (newmap != null &amp;&amp; (currentMap == null || !currentMap.mapName.equals(newmap.mapName))) {
+			if (loadIfSameScale || !MapsList.scaleEquals(currentMap.scale / currentMap.zoomFactor, newmap)) {
 				// better map found
 				setMap(newmap, where);
 				moveScreenXYtoLatLon(new Point(screen.x, screen.y), cll, true);
@@ -1489,54 +1685,94 @@
 		}
 		if (currentMap == null &amp;&amp; newmap == null) {
 			// F?r die aktuelle Position steht keine Karte zur Verf?ng
-			posCircle.where.set(cll); // choosemap calls setmap with posCircle-coos
+			posCircle.where.set(cll); // choosemap calls setmap with
+										// posCircle-coos
 			try {
-				setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
-			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec(); }
-			while (currentMap == null) { // this actually cannot happen, but maybe in case of an inconstistent code change (esp. regarding empty maps)
+				setMap(((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(), where); // beware:
+																								// &quot;-4&quot;
+																								// only
+																								// works
+																								// if
+																								// the
+																								// empty
+																								// maps
+																								// were
+																								// added
+																								// last
+																								// see
+																								// MapsList.addEmptyMaps
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4209, &quot;setBestMap: problem in: setMap( ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(), lat, lon) lat/lon:&quot;) + where.toString(), FormBase.OKB)).exec();
+			}
+			while (currentMap == null) { // this actually cannot happen,
+											// but maybe in case of an
+											// inconstistent code change
+											// (esp. regarding empty maps)
 				mmp.chooseMap(); // force the user to select a scale
-				 if (currentMap == null) (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
+				if (currentMap == null)
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4210, &quot;Moving map cannot run without a map - please select one. \n You can select an empty map&quot;), FormBase.OKB)).execute();
 			}
 		}
 		inBestMap = false;
 	}
 
-	public void setResModus (int modus) {
+	public void setResModus(int modus) {
 		scaleWanted = currentMap.scale;
-		if (mapChangeModus == modus) return;
+		if (mapChangeModus == modus)
+			return;
 		mapChangeModus = modus;
 		lastHighestResolutionGPSDestScale = -1;
 		if (modus != NORMAL_KEEP_RESOLUTION) {
 			setBestMap(posCircle.where, true);
 		}
 	}
+
 	/**
 	 * method to get a point on the screen which must be included in the map
-	 * the map methods are looking for. If the poscircle is on the screen this will be
-	 * that point. If it is outside then the centre of the screen will be used.
-	 *
-	 * returns [0] = CWPoint of that point, [1] Rect describing the screen around it
+	 * the map methods are looking for. If the poscircle is on the screen
+	 * this will be that point. If it is outside then the centre of the
+	 * screen will be used.
+	 * 
+	 * returns [0] = CWPoint of that point, [1] Rect describing the screen
+	 * around it
+	 * 
 	 * @param lat
 	 * @param lon
 	 * @return
 	 */
 	public Object[] getRectForMapChange(CWPoint ll) {
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
 		int pX, pY;
 		CWPoint cll;
 		Boolean posCircleOnScreen = java.lang.Boolean.FALSE;
 		if (posCircleX &gt;= 0 &amp;&amp; posCircleX &lt;= w &amp;&amp; posCircleY &gt;= 0 &amp;&amp; posCircleY &lt;= h &amp;&amp; ll.isValid()) {
 			posCircleOnScreen = java.lang.Boolean.TRUE;
 			pX = posCircleX; // posCircle is inside the screen
-			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem evtl. Kartenwechsel PosCircle on Screen ist. So wie es jetzt ist, kann 2mal der gleiche Aufruf zum laden unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn vorher PosCircle nicht auf dem SChirm war, nach dem ersten Laden aber schon.
+			pY = posCircleY; // TODO eigentlich interessiert, ob nach dem
+								// evtl. Kartenwechsel PosCircle on Screen
+								// ist. So wie es jetzt ist, kann 2mal der
+								// gleiche Aufruf zum laden
+								// unterschiedlicher Karten f&#239;&#191;&#189;hren, wenn
+								// vorher PosCircle nicht auf dem
+			// SChirm war, nach dem ersten Laden aber schon.
 			cll = new CWPoint(ll);
-		} else { // when posCircle out of screen - use centre of screen as point which as to be included in the map
-			cll = ScreenXY2LatLon(w/2, h/2);
-			pX = w/2;
-			pY = h/2;
+		} else { // when posCircle out of screen - use centre of screen
+					// as point which as to be included in the map
+			cll = ScreenXY2LatLon(w / 2, h / 2);
+			pX = w / 2;
+			pY = h / 2;
 		}
-		Object[] ret = new Object[3];
+		final Object[] ret = new Object[3];
 		ret[0] = cll;
 		ret[1] = new Rect(pX, pY, w, h);
 		ret[2] = posCircleOnScreen;
@@ -1544,25 +1780,35 @@
 	}
 
 	/**
-	 *
-	 * @param betterOverview true: getmap with better overview
+	 * 
+	 * @param betterOverview
+	 *            true: getmap with better overview
 	 * @return
 	 */
-	public void loadMoreDetailedMap(boolean betterOverview){
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
-		Rect screen = new Rect(w/2, h/2, w, h);
+	public void loadMoreDetailedMap(boolean betterOverview) {
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
+		final Rect screen = new Rect(w / 2, h / 2, w, h);
 
 		CWPoint cll;
 		if (currentMap != null) {
-			cll = ScreenXY2LatLon(w/2, h/2);
+			cll = ScreenXY2LatLon(w / 2, h / 2);
 		} else {
 			cll = new CWPoint(posCircle.where);
 		}
 
-		MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale * currentMap.zoomFactor, !betterOverview);
+		final MapInfoObject m = maps.getMapChangeResolution(cll, screen, currentMap.scale * currentMap.zoomFactor, !betterOverview);
 		if (m != null) {
-			boolean saveGpsIgnStatus = dontUpdatePos;
+			final boolean saveGpsIgnStatus = dontUpdatePos;
 			dontUpdatePos = true;
 			setMap(m, cll);
 			setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
@@ -1570,57 +1816,103 @@
 				fillWhiteArea(true);
 			}
 			dontUpdatePos = saveGpsIgnStatus;
-		}
-		else (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) +
-				(betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;) ) +
-				MyLocale.getMsg(4214, &quot; detailed map available&quot;),
-				FormBase.OKB)).execute();
+		} else
+			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4211, &quot;No &quot;) + (betterOverview ? MyLocale.getMsg(4212, &quot;less&quot;) : MyLocale.getMsg(4213, &quot;more&quot;)) + MyLocale.getMsg(4214, &quot; detailed map available&quot;), FormBase.OKB)).execute();
 	}
 
-	public void loadMapForAllCaches(){
-		Area sur = Global.getProfile().getSourroundingArea(true);
+	public void loadMapForAllCaches() {
+		final Area sur = Global.getProfile().getSourroundingArea(true);
 		if (sur == null) {
 			(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4215, &quot;Keine  Caches mit H&#239;&#191;&#189;ckchen ausgew&#239;&#191;&#189;hlt&quot;), FormBase.OKB)).execute();
 			return;
 		}
-		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.buttomright);
-		if (newmap == null ) { // no map that includs all caches is available -&gt; load map with lowest resolution
-			Object [] s = getRectForMapChange(posCircle.where);
-			CWPoint cll = (CWPoint) s[0];
-			Rect screen = (Rect) s[1];
-			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE -1, false,true);
+		MapInfoObject newmap = maps.getMapForArea(sur.topleft, sur.bottomright);
+		if (newmap == null) { // no map that includs all caches is
+								// available -&gt; load map with lowest
+								// resolution
+			final Object[] s = getRectForMapChange(posCircle.where);
+			final CWPoint cll = (CWPoint) s[0];
+			final Rect screen = (Rect) s[1];
+			newmap = maps.getBestMap(cll, screen, Float.MAX_VALUE - 1, false, true);
 		}
-		if (newmap == null) { // no map is covering any area of the caches -&gt; zoom an empty map to cover all caches on screen
+		if (newmap == null) { // no map is covering any area of the caches
+								// -&gt; zoom an empty map to cover all caches
+								// on screen
 			try {
-				Object [] s = getRectForMapChange(posCircle.where);
-			//	CWPoint cll = (CWPoint) s[0];
-				Rect screen = (Rect) s[1];
-				float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.buttomright.lonDec) * 1000 / (screen.width-15)); // 15 for the size of the cache image
-				float neededscaley = (float) (sur.topleft.getDistance(sur.buttomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height-15)); // 15 for the size of the cache image
-				newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap(); // beware: &quot;-4&quot; only works if the empty maps were added last see MapsList.addEmptyMaps
+				final Object[] s = getRectForMapChange(posCircle.where);
+				// CWPoint cll = (CWPoint) s[0];
+				final Rect screen = (Rect) s[1];
+				final float neededscalex = (float) (sur.topleft.getDistance(sur.topleft.latDec, sur.bottomright.lonDec) * 1000 / (screen.width - 15)); // 15
+																																						// for
+																																						// the
+																																						// size
+																																						// of
+																																						// the
+																																						// cache
+																																						// image
+				final float neededscaley = (float) (sur.topleft.getDistance(sur.bottomright.latDec, sur.topleft.lonDec) * 1000 / (screen.height - 15)); // 15
+																																						// for
+																																						// the
+																																						// size
+																																						// of
+																																						// the
+																																						// cache
+																																						// image
+				newmap = ((MapListEntry) maps.elementAt(maps.getCount() - 4)).getMap(); // beware:
+																						// &quot;-4&quot;
+																						// only
+																						// works
+																						// if
+																						// the
+																						// empty
+																						// maps
+																						// were
+																						// added
+																						// last
+																						// see
+																						// MapsList.addEmptyMaps
 				newmap.zoom(newmap.scale * newmap.zoomFactor / (neededscalex &gt; neededscaley ? neededscalex : neededscaley), 0, 0);
 				forceMapLoad = true;
-			} catch (IOException e) { (new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec(); }
+			} catch (final IOException e) {
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4279, &quot;loadMapForAllCaches: IO-Exception in: newmap = ((MapListEntry)maps.elementAt(maps.getCount() - 4)).getMap();&quot;), FormBase.OKB)).exec();
+			}
 		}
-		boolean saveGpsIgnStatus = dontUpdatePos;
+		final boolean saveGpsIgnStatus = dontUpdatePos;
 		dontUpdatePos = true;
 		setMap(newmap, posCircle.where);
 		setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 		dontUpdatePos = saveGpsIgnStatus;
 	}
 
-	public void setGpsStatus (int status) {
-		if (status == GpsStatus) return; // if ignoreGpsStatutsChanges == true than the Map is in manual-mode
+	public void setGpsStatus(int status) {
+		if (status == GpsStatus)
+			return; // if ignoreGpsStatutsChanges == true than the Map is in
+					// manual-mode
 		GpsStatus = status;
 		dontUpdatePos = false;
 		ignoreGps = false;
 		switch (status) {
-		case noGPS: 	{ posCircle.change(null); ignoreGps = true; break; }
-		case gotFix:    { posCircle.change(statusImageHaveSignal); break; }
-		case lostFix:   { posCircle.change(statusImageNoSignal); break; }
-		case noGPSData: { posCircle.change(statusImageNoGps); break; }
+		case noGPS: {
+			posCircle.change(null);
+			ignoreGps = true;
+			break;
 		}
-		mapMoved(0, 0); // positions the posCircle correctly accourding to its size (which can change when the image changes, e.g. from null to something else
+		case gotFix: {
+			posCircle.change(statusImageHaveSignal);
+			break;
+		}
+		case lostFix: {
+			posCircle.change(statusImageNoSignal);
+			break;
+		}
+		case noGPSData: {
+			posCircle.change(statusImageNoGps);
+			break;
+		}
+		}
+		mapMoved(0, 0); // positions the posCircle correctly accourding to
+						// its size (which can change when the image
+						// changes, e.g. from null to something else
 		posCircle.refreshNow();
 	}
 
@@ -1628,122 +1920,147 @@
 		resetCenterOfMap();
 		dontUpdatePos = false;
 		ignoreGps = false;
-		lastCompareX = Integer.MAX_VALUE; // neccessary to make updateposition to test if the current map is the best one for the GPS-Position
+		lastCompareX = Integer.MAX_VALUE; // neccessary to make
+											// updateposition to test if the
+											// current map is the best one
+											// for the GPS-Position
 		lastCompareY = Integer.MAX_VALUE;
 		autoSelectMap = true;
 		forceMapLoad = true;
 		// showMap(); why this?
-		if (myNavigation.gpsPos.Fix &lt;=0) updatePosition(posCircle.where);
-		else updateGps(myNavigation.gpsPos.getFix());
+		if (myNavigation.gpsPos.Fix &lt;= 0)
+			updatePosition(posCircle.where);
+		else
+			updateGps(myNavigation.gpsPos.getFix());
 	}
 
-	/** sets and displays the map
-	 *
+	/**
+	 * sets and displays the map
+	 * 
 	 * @param newmap
-	 * @param lat move map so that lat/lon is in the centre / -361: don't adust to lat/lon
-	 * @param lon -361: don't adust to lat/lon
+	 * @param lat
+	 *            move map so that lat/lon is in the centre / -361: don't
+	 *            adust to lat/lon
+	 * @param lon
+	 *            -361: don't adust to lat/lon
 	 */
 	public void setMap(MapInfoObject newmap, CWPoint where) {
 		if (currentMap != null &amp;&amp; newmap.mapName.equals(currentMap.mapName) &amp;&amp; !forceMapLoad) {
 			updateOnlyPosition(where, true);
 			return;
 		}
-		try {			
+		try {
 			Vm.showWait(true);
 			boolean saveIgnoreStatus;
 			saveIgnoreStatus = dontUpdatePos;
-			dontUpdatePos = true;  // make updatePosition ignore calls during loading new map
-			pref.log(MyLocale.getMsg(4216, &quot;Loading map...&quot;)+newmap.mapName);
+			dontUpdatePos = true; // make updatePosition ignore calls
+									// during loading new map
+			pref.log(MyLocale.getMsg(4216, &quot;Loading map...&quot;) + newmap.mapName);
 			try {
 				this.currentMap = newmap;
 				this.title = currentMap.mapName;
-				// neccessary to make updateposition to test if the current map is the best one for the GPS-Position
-				lastCompareX = Integer.MAX_VALUE; 
+				// neccessary to make updateposition to test if the current
+				// map is the best one for the GPS-Position
+				lastCompareX = Integer.MAX_VALUE;
 				lastCompareY = Integer.MAX_VALUE;
-				if (mmp.mapImage != null ) {
-					mmp.removeImage(mmp.mapImage); 
-					mmp.mapImage.free(); 
-					mmp.mapImage = null; 
+				if (mmp.mapImage != null) {
+					mmp.removeImage(mmp.mapImage);
+					mmp.mapImage.free();
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 					// calls the garbage collection
-					Vm.getUsedMemory(true); 
-				} 
-				// give memory free before loading the new map to avoid out of memory error
-				String ImageFilename = currentMap.getImageFilename();
-				if (ImageFilename == null ) {
+					Vm.getUsedMemory(true);
+				}
+				// give memory free before loading the new map to avoid out
+				// of memory error
+				final String ImageFilename = currentMap.getImageFilename();
+				if (ImageFilename == null) {
 					mmp.mapImage = new MapImage();
 					maps.remove(currentMap);
-					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;)+currentMap.fileNameWFL, FormBase.OKB)).execute();
-				}
-				else {
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4217, &quot;Could not find image associated with: \n&quot;) + currentMap.fileNameWFL, FormBase.OKB)).execute();
+				} else {
 					if (ImageFilename.length() &gt; 0) {
 						// attention: when running in native java-vm,
-						// no exception will be thrown, not even OutOfMemeoryError
-						mmp.mapImage = new MapImage(ImageFilename); 
-					}
-					else mmp.mapImage = new MapImage(); // no image associated with the calibration info (&quot;empty map&quot;)
+						// no exception will be thrown, not even
+						// OutOfMemeoryError
+						mmp.mapImage = new MapImage(ImageFilename);
+					} else
+						mmp.mapImage = new MapImage(); // no image
+														// associated with
+														// the calibration
+														// info (&quot;empty
+														// map&quot;)
 				}
 				mapImage1to1 = mmp.mapImage;
 				mmp.mapImage.properties = mmp.mapImage.properties | mImage.IsMoveable;
-				if (mapHidden) mmp.mapImage.hide();
-				mmp.mapImage.move(0,0);
+				if (mapHidden)
+					mmp.mapImage.hide();
+				mmp.mapImage.move(0, 0);
 				mmp.addImage(mmp.mapImage);
 				mmp.images.moveToBack(mmp.mapImage);
 				rebuildOverlaySet();
-				forceMapLoad = true; // forces updateOnlyPosition to redraw
+				forceMapLoad = true; // forces updateOnlyPosition to
+										// redraw
 				updateAfterMapChange(where);
 				forceMapLoad = false;
 				directionArrows.setMap(currentMap);
 				updateScale();
-				// this doesn't work in a ticked-thread in the ewe-vm. 
+				// this doesn't work in a ticked-thread in the ewe-vm.
 				// That's why i made a new mThread in gotoPanel for ticked
 				dontUpdatePos = saveIgnoreStatus;
-			} catch (IllegalArgumentException e) { 
+			} catch (final IllegalArgumentException e) {
 				// thrown by new AniImage() in ewe-vm if file not found;
-				pref.log(&quot;[MovingMap:setMap]IllegalArgumentException&quot;,e,true);
+				pref.log(&quot;[MovingMap:setMap]IllegalArgumentException&quot;, e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;)+ newmap.getImageFilename(), FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4218, &quot;Could not load map: \n&quot;) + newmap.getImageFilename(), FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
-			} catch (OutOfMemoryError e) {
-				pref.log(&quot;[MovingMap:setMap]OutOfMemoryError&quot;,e,true);
+			} catch (final OutOfMemoryError e) {
+				pref.log(&quot;[MovingMap:setMap]OutOfMemoryError&quot;, e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
 				updateOnlyPosition(where, false);
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;)
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
-						FormBase.OKB)).execute();
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4219, &quot;Not enough memory to load map: \n&quot;) + newmap.getImageFilename() + MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;), FormBase.OKB))
+						.execute();
 				dontUpdatePos = saveIgnoreStatus;
-			}catch (SystemResourceException e) {
-				pref.log(&quot;[MovingMap:setMap]SystemResourceException&quot;,e,true);
+			} catch (final SystemResourceException e) {
+				pref.log(&quot;[MovingMap:setMap]SystemResourceException&quot;, e, true);
 				if (mmp.mapImage != null) {
 					mmp.removeImage(mmp.mapImage);
 					mmp.mapImage.free();
-					mmp.mapImage = null; 
+					mmp.mapImage = null;
 					mapImage1to1 = mmp.mapImage;
 				}
 				rebuildOverlaySet();
-				updateOnlyPosition(where, false); // TODO this doesn't work correctly if the resolution changed, I guess because the pixels of PosCircle will be interpreted from the new resolution, but should be interpreted using the old resolution to test: select a map with a much greater value of m per pixel manually
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;)
-						+ newmap.getImageFilename()
-						+ MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
+				updateOnlyPosition(where, false); // TODO this doesn't
+													// work correctly if the
+													// resolution changed, I
+													// guess because the
+													// pixels of PosCircle
+													// will be interpreted
+													// from the new
+													// resolution, but
+													// should be interpreted
+													// using the old
+													// resolution to
+				// test: select a map with a much greater value of m per
+				// pixel manually
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4221, &quot;Not enough ressources to load map: &quot;) + newmap.getImageFilename() + MyLocale.getMsg(4220, &quot;\nYou can try to close\n all prgrams and \nrestart CacheWolf&quot;),
 						FormBase.OKB)).execute();
 				dontUpdatePos = saveIgnoreStatus;
 			}
-		}
-		finally{
+		} finally {
 			Vm.showWait(false);
 		}
 	}
@@ -1752,21 +2069,31 @@
 		if (!posCircle.where.isValid()) {
 			posCircle.where.set(newCenter);
 		}
-		Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
-		Point centerOnMap = currentMap.calcMapXY(newCenter);
-		int w = (width != 0 ? width : pref.myAppWidth); // width == 0 happens if this routine is run before the windows is on the screen
-		int h = (height != 0 ? height : pref.myAppHeight);
-		int mapPosX = w/2 - centerOnMap.x;
-		int mapPosY = h/2 - centerOnMap.y;
-		int newPosCircleX = mapPosX + circlePosOnMap.x;
-		int newPosCircleY = mapPosY + circlePosOnMap.y;
+		final Point circlePosOnMap = currentMap.calcMapXY(posCircle.where);
+		final Point centerOnMap = currentMap.calcMapXY(newCenter);
+		final int w = (width != 0 ? width : pref.myAppWidth); // width ==
+																// 0 happens
+																// if this
+																// routine
+																// is run
+																// before
+																// the
+																// windows
+																// is on the
+																// screen
+		final int h = (height != 0 ? height : pref.myAppHeight);
+		final int mapPosX = w / 2 - centerOnMap.x;
+		final int mapPosY = h / 2 - centerOnMap.y;
+		final int newPosCircleX = mapPosX + circlePosOnMap.x;
+		final int newPosCircleY = mapPosY + circlePosOnMap.y;
 
-		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.move(mapPosX, mapPosY);
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.move(mapPosX, mapPosY);
 
-		int wCircle = posCircle.getWidth();
-		int hCircle = posCircle.getHeight();
-		int npx = newPosCircleX-wCircle/2;
-		int npy = newPosCircleY-hCircle/2;
+		final int wCircle = posCircle.getWidth();
+		final int hCircle = posCircle.getHeight();
+		final int npx = newPosCircleX - wCircle / 2;
+		final int npy = newPosCircleY - hCircle / 2;
 		posCircle.move(npx, npy);
 		posCircleX = newPosCircleX;
 		posCircleY = newPosCircleY;
@@ -1777,9 +2104,9 @@
 	public void hideMap() {
 		if (mmp != null &amp;&amp; mmp.mapImage != null)
 			mmp.mapImage.hide();
-		for(Iterator i=mmp.images.iterator(); i.hasNext ();){
-			AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
+			final AniImage image = (AniImage) i.next();
+			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)) {
 				((MapImage) image).hide();
 			}
 		}
@@ -1788,63 +2115,86 @@
 	}
 
 	public void showMap() {
-		if (mmp != null &amp;&amp; mmp.mapImage != null) mmp.mapImage.unhide();
+		if (mmp != null &amp;&amp; mmp.mapImage != null)
+			mmp.mapImage.unhide();
 		mapHidden = false;
-		for(Iterator i=mmp.images.iterator(); i.hasNext ();){
-			AniImage image = (AniImage) i.next();
-			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)){
+		for (final Iterator i = mmp.images.iterator(); i.hasNext();) {
+			final AniImage image = (AniImage) i.next();
+			if (image instanceof MapImage &amp;&amp; !(image instanceof MapSymbol) &amp;&amp; !(image instanceof TrackOverlay)) {
 				((MapImage) image).unhide();
 			}
 		}
 		repaintNow();
 	}
-/*
-	public void setZoomingMode() {
-		repaintNow();
-		zoomingMode = true;
-	}
-*/
+
+	/*
+	 * public void setZoomingMode() { repaintNow(); zoomingMode = true; }
+	 */
 	/**
 	 * zommes in if w&gt;0 and out if w&lt;0
+	 * 
 	 * @param firstclickpoint
 	 * @param w
 	 * @param h
 	 */
 	public void zoomScreenRect(Point firstclickpoint, int w, int h) {
-		int newImageWidth = (int) (this.width *  (this.width  &lt; 481 ? 2 : 1.6)); // (maximal) size of the zoomed image
-		int newImageHeight= (int) (this.height * (this.width &lt; 481 ?  2 : 1.6)); // dont make this to big, otherwise it causes out of memory errors
-		CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w/2, firstclickpoint.y + h/2);
+		int newImageWidth = (int) (this.width * (this.width &lt; 481 ? 2 : 1.6)); // (maximal)
+																				// size
+																				// of
+																				// the
+																				// zoomed
+																				// image
+		int newImageHeight = (int) (this.height * (this.width &lt; 481 ? 2 : 1.6)); // dont
+																					// make
+																					// this
+																					// to
+																					// big,
+																					// otherwise
+																					// it
+																					// causes
+																					// out
+																					// of
+																					// memory
+																					// errors
+		final CWPoint center = ScreenXY2LatLon(firstclickpoint.x + w / 2, firstclickpoint.y + h / 2);
 		float zoomFactor;
 		if (h &lt; 0) {
 			h = java.lang.Math.abs(h);
 			firstclickpoint.y = firstclickpoint.y - h;
 		}
 		if (w &gt; 0) { // zoom in
-			zoomFactor = java.lang.Math.min((float)this.width / (float)w, (float)this.height / (float)h);
-		}
-		else { // zoom out
+			zoomFactor = java.lang.Math.min((float) this.width / (float) w, (float) this.height / (float) h);
+		} else { // zoom out
 			w = java.lang.Math.abs(w);
-			firstclickpoint.x = firstclickpoint.x - w; // make firstclickedpoint the upper left corner
-			zoomFactor = java.lang.Math.max((float)w / (float)this.width, (float)h / (float)this.height);
+			firstclickpoint.x = firstclickpoint.x - w; // make
+														// firstclickedpoint
+														// the upper left
+														// corner
+			zoomFactor = java.lang.Math.max((float) w / (float) this.width, (float) h / (float) this.height);
 		}
-		// calculate rect in unzoomed image in a way that the centre of the new image is the centre of selected area but give priority to the prefered image size of the scaled image
+		// calculate rect in unzoomed image in a way that the centre of the
+		// new image is the centre of selected area but give priority to the
+		// prefered image size of the scaled image
 		newImageHeight = (int) (newImageHeight / zoomFactor / currentMap.zoomFactor);
 		newImageWidth = (int) (newImageWidth / zoomFactor / currentMap.zoomFactor);
-		Point mappos = getMapPositionOnScreen();
-		int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w/2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth /2);
-		int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h/2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight /2);
-		Rect newImageRect = new Rect(xinunscaledimage , yinunscaledimage, newImageWidth, newImageHeight);
-		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
-		{
+		final Point mappos = getMapPositionOnScreen();
+		final int xinunscaledimage = (int) ((firstclickpoint.x - mappos.x + w / 2) / currentMap.zoomFactor + currentMap.shift.x - newImageWidth / 2);
+		final int yinunscaledimage = (int) ((firstclickpoint.y - mappos.y + h / 2) / currentMap.zoomFactor + currentMap.shift.y - newImageHeight / 2);
+		final Rect newImageRect = new Rect(xinunscaledimage, yinunscaledimage, newImageWidth, newImageHeight);
+		if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null) {
 			// try to avoid overlapping by shifting
 			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0; // align left if left overlapping
 			if (newImageRect.y &lt; 0)
 				newImageRect.y = 0;
 			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
-				newImageRect.x = mapImage1to1.getWidth()- newImageWidth; // align right if right overlaping
+				newImageRect.x = mapImage1to1.getWidth() - newImageWidth; // align
+																			// right
+																			// if
+																			// right
+																			// overlaping
 			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
-				newImageRect.y = mapImage1to1.getHeight()- newImageHeight;
+				newImageRect.y = mapImage1to1.getHeight() - newImageHeight;
 			// crop if after shifting still overlapping
 			if (newImageRect.x &lt; 0)
 				newImageRect.x = 0;
@@ -1853,25 +2203,23 @@
 			if (newImageRect.x + newImageRect.width &gt;= mapImage1to1.getWidth())
 				newImageRect.width = mapImage1to1.getWidth() - newImageRect.x;
 			if (newImageRect.y + newImageRect.height &gt;= mapImage1to1.getHeight())
-				newImageRect.height= mapImage1to1.getHeight()- newImageRect.y;
+				newImageRect.height = mapImage1to1.getHeight() - newImageRect.y;
 		}
 		zoomFromUnscaled(zoomFactor * currentMap.zoomFactor, newImageRect, center);
 	}
 
 	public void zoomin() {
-		zoomScreenRect(new Point(this.width / 4, this.height / 4),
-				this.width / 2, this.height / 2);
+		zoomScreenRect(new Point(this.width / 4, this.height / 4), this.width / 2, this.height / 2);
 	}
 
 	public void zoomout() {
-		CWPoint center = currentMap.center;
+		final CWPoint center = currentMap.center;
 		float zoomfactor = currentMap.zoomFactor / 2;
 		if (zoomfactor &lt; 1) {
 			zoomfactor = 1;
 		}
 		if (mapImage1to1 != null)
-			zoomFromUnscaled(zoomfactor, new Rect(0, 0,
-					mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+			zoomFromUnscaled(zoomfactor, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
 		else
 			zoomFromUnscaled(zoomfactor, new Rect(0, 0, 1, 1), center);
 	}
@@ -1881,20 +2229,26 @@
 	}
 
 	public void zoom1to1() {
-		CWPoint center = ScreenXY2LatLon(this.width /2 , this.height/2);
-		if (mapImage1to1 != null) zoomFromUnscaled(1, new Rect(0,0,mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
-		else zoomFromUnscaled(1, new Rect(0,0, 1,1), center);
+		final CWPoint center = ScreenXY2LatLon(this.width / 2, this.height / 2);
+		if (mapImage1to1 != null)
+			zoomFromUnscaled(1, new Rect(0, 0, mapImage1to1.getWidth(), mapImage1to1.getHeight()), center);
+		else
+			zoomFromUnscaled(1, new Rect(0, 0, 1, 1), center);
 	}
 
 	/**
 	 * do the actual scaling
-	 * @param zoomFactor relative to original image
-	 * @param newImageRect Rect in the 1:1 image that contains the area to be zoomed into
+	 * 
+	 * @param zoomFactor
+	 *            relative to original image
+	 * @param newImageRect
+	 *            Rect in the 1:1 image that contains the area to be zoomed
+	 *            into
 	 * @param center
 	 */
-	public void zoomFromUnscaled (float zoomFactor, Rect newImageRect, CWPoint center) {
+	public void zoomFromUnscaled(float zoomFactor, Rect newImageRect, CWPoint center) {
 		Vm.showWait(this, true);
-		boolean savegpsstatus = dontUpdatePos;
+		final boolean savegpsstatus = dontUpdatePos;
 		if (mapImage1to1 != null) {
 			dontUpdatePos = true; // avoid multi-thread problems
 			int saveprop = mImage.IsMoveable;
@@ -1906,32 +2260,38 @@
 				if (mmp.mapImage != mapImage1to1) {
 					mmp.mapImage.free();
 					mmp.mapImage = null;
-				} else tmp = mapImage1to1;
+				} else
+					tmp = mapImage1to1;
 			}
 			Vm.getUsedMemory(true);
 			try {
-				if (zoomFactor == 1) tmp = mapImage1to1;
-				else tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width*zoomFactor), (int)(newImageRect.height*zoomFactor), newImageRect, 0));
+				if (zoomFactor == 1)
+					tmp = mapImage1to1;
+				else
+					tmp = new MapImage(mapImage1to1.scale((int) (newImageRect.width * zoomFactor), (int) (newImageRect.height * zoomFactor), newImageRect, 0));
 				currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
-			} catch (OutOfMemoryError e) {
-				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;),
-						MyLocale.getMsg(4222, &quot;Out of memory error&quot;), FormBase.OKB)).execute();
-				//tmp = mapImage1to1;
-			} //if (tmp != null) currentMap.zoom();}
+			} catch (final OutOfMemoryError e) {
+				(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4222, &quot;Out of memory error&quot;), FormBase.OKB)).execute();
+				// tmp = mapImage1to1;
+			} // if (tmp != null) currentMap.zoom();}
 			Vm.getUsedMemory(true);
-			mmp.mapImage = tmp; // use unscaled or no image in case of OutOfMemoryError
+			mmp.mapImage = tmp; // use unscaled or no image in case of
+								// OutOfMemoryError
 			mmp.mapImage.properties = saveprop;
-			if (mapHidden) mmp.mapImage.hide();
+			if (mapHidden)
+				mmp.mapImage.hide();
 			mmp.addImage(mmp.mapImage);
 			mmp.images.moveToBack(mmp.mapImage);
-			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null)
-			{
-				Point mappos = getMapPositionOnScreen();
-				mmp.mapImage.move(mappos.x,mappos.y);
+			if (mapImage1to1 != null &amp;&amp; mmp.mapImage != null &amp;&amp; mapImage1to1.image != null) {
+				final Point mappos = getMapPositionOnScreen();
+				mmp.mapImage.move(mappos.x, mappos.y);
 			}
 		} else // no map image loaded
-		{ currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y); }
-		// scaleWanted = currentMap.scale; use this if you want to change automatically to a map scale that best fits the zooming
+		{
+			currentMap.zoom(zoomFactor, newImageRect.x, newImageRect.y);
+		}
+		// scaleWanted = currentMap.scale; use this if you want to change
+		// automatically to a map scale that best fits the zooming
 		destroyOverlaySet();
 		Vm.getUsedMemory(true); // call garbage collection
 		setCenterOfScreen(center, false);
@@ -1942,15 +2302,14 @@
 		dontUpdatePos = savegpsstatus;
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED )){
+	public void onEvent(Event ev) {
+		if (ev instanceof FormEvent &amp;&amp; (ev.type == FormEvent.CLOSED)) {
 			running = false;
 		}
-		if( ev instanceof KeyEvent &amp;&amp;
-			ev.target == this &amp;&amp;
-			( (((KeyEvent)ev).key == IKeys.ESCAPE) ||
-			  (((KeyEvent)ev).key == IKeys.ENTER) ||
-			  (((KeyEvent)ev).key == IKeys.ACTION) ) ) {
+		if (ev instanceof KeyEvent &amp;&amp; ev.target == this &amp;&amp; //
+				((((KeyEvent) ev).key == IKeys.ESCAPE) || //
+						(((KeyEvent) ev).key == IKeys.ENTER) || //
+				(((KeyEvent) ev).key == IKeys.ACTION))) {
 			this.close(0);
 			ev.consumed = true;
 		}
@@ -1958,21 +2317,21 @@
 	}
 
 	public boolean handleCommand(int actionCommand) {
-		if (CLOSE == actionCommand) {			
-			WindowEvent tmp = new WindowEvent();
+		if (CLOSE == actionCommand) {
+			final WindowEvent tmp = new WindowEvent();
 			tmp.type = WindowEvent.CLOSE;
 			postEvent(tmp);
 			return true;
-		} 
+		}
 		if (SELECT_MAP == actionCommand) {
 			mmp.chooseMap();
 			return true;
 		}
 		if (CHANGE_MAP_DIR == actionCommand) {
-			FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
+			final FileChooser fc = new FileChooser(FileChooserBase.DIRECTORY_SELECT, Global.getPref().getCustomMapsPath());
 			fc.addMask(&quot;*.wfl&quot;);
-			fc.setTitle(MyLocale.getMsg(4200,&quot;Select map directory:&quot;));
-			if(fc.execute() != FormBase.IDCANCEL){
+			fc.setTitle(MyLocale.getMsg(4200, &quot;Select map directory:&quot;));
+			if (fc.execute() != FormBase.IDCANCEL) {
 				Global.getPref().saveCustomMapsPath(fc.getChosen().toString());
 				loadMaps(Global.getPref().getCustomMapsPath(), posCircle.where.latDec);
 				forceMapLoad();
@@ -1981,27 +2340,27 @@
 		}
 		if (FILL_MAP == actionCommand) {
 			setFillWhiteArea(true);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (NO_FILL_MAP == actionCommand) {
 			setFillWhiteArea(false);
-			updatePosition (posCircle.where);
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (SHOW_CACHES == actionCommand) {
 			setShowCachesOnMap(true);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
 		if (HIDE_CACHES == actionCommand) {
 			setShowCachesOnMap(false);
-			forceMapLoad=true;
-			updatePosition (posCircle.where);
+			forceMapLoad = true;
+			updatePosition(posCircle.where);
 			mmp.repaint();
 			return true;
 		}
@@ -2042,7 +2401,7 @@
 			return true;
 		}
 		if (MOVE_TO_DEST == actionCommand) {
-			if (gotoPos!=null) {
+			if (gotoPos != null) {
 				setCenterOfScreen(gotoPos.where, true);
 			}
 			return true;
@@ -2075,22 +2434,20 @@
 		return mapHidden;
 	}
 
-	
 	public void setPaintPosDestLine(boolean paintPosDestLine) {
 		this.paintPosDestLine = paintPosDestLine;
 	}
-	
-	
+
 }
 
 /**
- *	Class to display the map bitmap and to select another bitmap to display.
+ * Class to display the map bitmap and to select another bitmap to display.
  */
 class MovingMapPanel extends InteractivePanel implements EventListener {
 	Menu kontextMenu;
 	MenuItem gotoMenuItem = new MenuItem(MyLocale.getMsg(4230, &quot;Goto here$g&quot;), 0, null);
 	MenuItem newWayPointMenuItem = new MenuItem(MyLocale.getMsg(4232, &quot;Create new Waypoint here$n&quot;), 0, null);;
-	MenuItem openCacheDescMenuItem,openCacheDetailMenuItem,addCachetoListMenuItem,gotoCacheMenuItem,hintMenuItem,missionMenuItem;
+	MenuItem openCacheDescMenuItem, openCacheDetailMenuItem, addCachetoListMenuItem, gotoCacheMenuItem, markFoundMenuItem, hintMenuItem, missionMenuItem;
 
 	MenuItem miLuminary[];
 
@@ -2100,47 +2457,53 @@
 	Point saveMapLoc = null;
 	boolean saveGpsIgnoreStatus;
 	boolean paintingZoomArea;
-	
+
 	ImageList saveImageList = null;
-	int lastZoomWidth , lastZoomHeight;
-	
-	boolean ignoreNextDrag=false;
-	boolean onlyIfCache=false;
-	
-	public MovingMapPanel(MovingMap f){
+	int lastZoomWidth, lastZoomHeight;
+
+	boolean ignoreNextDrag = false;
+	boolean onlyIfCache = false;
+
+	public MovingMapPanel(MovingMap f) {
 		this.mm = f;
 		miLuminary = new MenuItem[SkyOrientation.LUMINARY_NAMES.length];
-		for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+		for (int i = 0; i &lt; SkyOrientation.LUMINARY_NAMES.length; i++) {
 			miLuminary[i] = new MenuItem(SkyOrientation.getLuminaryName(i));
 		}
-		set(ControlConstants.WantHoldDown, true); // want to get simulated right-clicks
+		set(ControlConstants.WantHoldDown, true); // want to get simulated
+													// right-clicks
 	}
 
-	public boolean imageBeginDragged(AniImage which,Point pos) {
+	public boolean imageBeginDragged(AniImage which, Point pos) {
 		if (mm.zoomingMode == true) { // zoom
-//			saveMapLoc = pos;
-			//		saveGpsIgnoreStatus = mm.ignoreGps;
-			//	mm.ignoreGps = true;
+			// saveMapLoc = pos;
+			// saveGpsIgnoreStatus = mm.ignoreGps;
+			// mm.ignoreGps = true;
 			return false;
 		}
 		if (mm.getControlsLayer().imageBeginDragged(which, pos)) {
 			return false;
-		}			
+		}
 		// move (drag) map
-		//if (!(which == null || which == mapImage || which instanceof TrackOverlay || which == mm.directionArrows) ) return false;
+		// if (!(which == null || which == mapImage || which instanceof
+		// TrackOverlay || which == mm.directionArrows) ) return false;
 		saveGpsIgnoreStatus = mm.dontUpdatePos;
 		mm.dontUpdatePos = true;
 		saveMapLoc = pos;
 		bringMapToTop();
-		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden ) return super.imageBeginDragged(mapImage, pos);
-		else return super.imageBeginDragged(null, pos);
+		if (mapImage.isOnScreen() &amp;&amp; !mapImage.hidden)
+			return super.imageBeginDragged(mapImage, pos);
+		else
+			return super.imageBeginDragged(null, pos);
 	}
 
-	public boolean imageNotDragged(ImageDragContext dc,Point pos){
-		boolean ret = super.imageNotDragged(dc, pos);
+	public boolean imageNotDragged(ImageDragContext dc, Point pos) {
+		final boolean ret = super.imageNotDragged(dc, pos);
 		bringMaptoBack();
-		if (dc.image == null) moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
-		else mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		if (dc.image == null)
+			moveMap(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
+		else
+			mapMoved(pos.x - saveMapLoc.x, pos.y - saveMapLoc.y);
 		mm.dontUpdatePos = saveGpsIgnoreStatus;
 		this.repaintNow();
 		return ret;
@@ -2148,66 +2511,82 @@
 
 	public void onPenEvent(PenEvent ev) {
 		if (ignoreNextDrag) {
-			// On PDA next event after a Kontext ist a drag, that will move the map unwanted
-			ignoreNextDrag=false;
-			if (ev.type == PenEvent.PEN_DRAG) return; // ignoring now
+			// On PDA next event after a Kontext ist a drag, that will move
+			// the map unwanted
+			ignoreNextDrag = false;
+			if (ev.type == PenEvent.PEN_DRAG)
+				return; // ignoring now
 		}
 		if (ev.type == PenEvent.PEN_DOWN) {
 			if (mm.zoomingMode) {
 				saveGpsIgnoreStatus = mm.dontUpdatePos;
 				mm.dontUpdatePos = true;
-				saveMapLoc = new Point (ev.x, ev.y);
+				saveMapLoc = new Point(ev.x, ev.y);
 				paintingZoomArea = true;
 				mm.zoomingMode = true;
-			}
-			else {
-				saveMapLoc = new Point (ev.x, ev.y);
+			} else {
+				saveMapLoc = new Point(ev.x, ev.y);
 				if (ev.modifiers == PenEvent.RIGHT_BUTTON) {
-					// context penHeld is fired directly on PDA (cause WantHoldDown Control Modifier)
+					// context penHeld is fired directly on PDA (cause
+					// WantHoldDown Control Modifier)
 					// but not on PC (Java) , therefor it is here
-					penHeld(new Point (ev.x, ev.y));
-				}
-				else {
+					penHeld(new Point(ev.x, ev.y));
+				} else {
 					// do it even on left klick
-					onlyIfCache=true;
-					penHeld(new Point (ev.x, ev.y));
+					onlyIfCache = true;
+					penHeld(new Point(ev.x, ev.y));
 				}
 			}
-		}
-		else {
+		} else {
 			if (mm.zoomingMode) {
-				if ( ev.type == PenEvent.PEN_UP ) {
+				if (ev.type == PenEvent.PEN_UP) {
 					paintingZoomArea = false;
 					mm.zoomingMode = false;
 					mm.getControlsLayer().changeRoleState(&quot;zoom_manually&quot;, false);
 					mm.dontUpdatePos = saveGpsIgnoreStatus;
-					if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15)  {
+					if (java.lang.Math.abs(lastZoomWidth) &lt; 15 || java.lang.Math.abs(lastZoomHeight) &lt; 15) {
 						repaintNow();
-						return; // dont make to big zoom jumps - it is most probable not an intentional zoom
+						return; // dont make to big zoom jumps - it is most
+								// probable not an intentional zoom
 					}
 					mm.zoomScreenRect(saveMapLoc, lastZoomWidth, lastZoomHeight);
 				}
-				if (paintingZoomArea &amp;&amp; 
-					(ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
+				if (paintingZoomArea &amp;&amp; (ev.type == PenEvent.PEN_MOVED_ON || ev.type == PenEvent.PEN_MOVE || ev.type == PenEvent.PEN_DRAG)) {
 					int left, top;
-					Graphics dr = this.getGraphics();
-					if (lastZoomWidth &lt; 0)left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
+					final Graphics dr = this.getGraphics();
+					if (lastZoomWidth &lt; 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight &lt; 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
 					left -= 2;
 					top -= 2;
-					if (top &lt; 0) top = 0;
-					if (left &lt; 0) left = 0;
-					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth)+4, java.lang.Math.abs(lastZoomHeight)+4));
+					if (top &lt; 0)
+						top = 0;
+					if (left &lt; 0)
+						left = 0;
+					this.repaintNow(dr, new Rect(left, top, java.lang.Math.abs(lastZoomWidth) + 4, java.lang.Math.abs(lastZoomHeight) + 4));
 					lastZoomWidth = ev.x - saveMapLoc.x;
-					lastZoomHeight =  ev.y - saveMapLoc.y;
-					if (lastZoomWidth &lt; 0) left = saveMapLoc.x + lastZoomWidth;
-					else left = saveMapLoc.x;
-					if (lastZoomHeight &lt; 0)top = saveMapLoc.y + lastZoomHeight;
-					else top = saveMapLoc.y;
-					dr.setPen(new Pen(new Color(255,0,0),Pen.SOLID,3));
-					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug in ewe: thickness parameter is ignored
+					lastZoomHeight = ev.y - saveMapLoc.y;
+					if (lastZoomWidth &lt; 0)
+						left = saveMapLoc.x + lastZoomWidth;
+					else
+						left = saveMapLoc.x;
+					if (lastZoomHeight &lt; 0)
+						top = saveMapLoc.y + lastZoomHeight;
+					else
+						top = saveMapLoc.y;
+					dr.setPen(new Pen(new Color(255, 0, 0), Pen.SOLID, 3));
+					dr.drawRect(left, top, java.lang.Math.abs(lastZoomWidth), java.lang.Math.abs(lastZoomHeight), 0); // bug
+																														// in
+																														// ewe:
+																														// thickness
+																														// parameter
+																														// is
+																														// ignored
 				}
 			}
 		}
@@ -2224,31 +2603,35 @@
 		images.removeAllElements();
 		images.add(mapImage);
 	}
+
 	private void bringMaptoBack() {
-		if (saveImageList == null) return;
+		if (saveImageList == null)
+			return;
 		images = saveImageList;
 		saveImageList = null;
 	}
 
 	public void moveMap(int diffX, int diffY) {
 		Point p = new Point();
-		if (mapImage!= null) {
+		if (mapImage != null) {
 			p = mapImage.locAlways;
-			mapImage.move(p.x+diffX,p.y+diffY);
-			//		if (mm.mapHidden) mapImage.properties |= AniImage.IsInvisible; // this is neccesarry because move will unhide the map if the coos show that the map is on the screen
+			mapImage.move(p.x + diffX, p.y + diffY);
+			// if (mm.mapHidden) mapImage.properties |=
+			// AniImage.IsInvisible; // this is neccesarry because move will
+			// unhide the map if the coos show that the map is on the screen
 		}
 		mapMoved(diffX, diffY);
 	}
 
-	public void mapMoved(int diffX, int diffY){
+	public void mapMoved(int diffX, int diffY) {
 		mm.mapMoved(diffX, diffY);
 		this.repaintNow();
 	}
 
-	public void doPaint(Graphics g,Rect area) {
+	public void doPaint(Graphics g, Rect area) {
 		super.doPaint(g, area);
 		if (mm.gotoPos != null &amp;&amp; mm.paintPosDestLine) {
-			Point dest = mm.getXYonScreen(mm.gotoPos.where);
+			final Point dest = mm.getXYonScreen(mm.gotoPos.where);
 			g.setPen(new Pen(Color.DarkBlue, Pen.SOLID, 3));
 			g.drawLine(mm.posCircleX, mm.posCircleY, dest.x, dest.y);
 		}
@@ -2256,12 +2639,14 @@
 
 	public void chooseMap() {
 		CWPoint gpspos;
-		if (mm.myNavigation.gpsPos.Fix &gt; 0) gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
-		else gpspos = null;
-		ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
-		if(l.execute() == FormBase.IDOK){
+		if (mm.myNavigation.gpsPos.Fix &gt; 0)
+			gpspos = new CWPoint(mm.myNavigation.gpsPos.latDec, mm.myNavigation.gpsPos.lonDec);
+		else
+			gpspos = null;
+		final ListBox l = new ListBox(mm.maps, gpspos, mm.getGotoPos(), mm.currentMap);
+		if (l.execute() == FormBase.IDOK) {
 			mm.autoSelectMap = false;
-			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length()==0) {
+			if (l.selectedMap.isInBound(mm.posCircle.where) || l.selectedMap.getImageFilename().length() == 0) {
 				mm.setMap(l.selectedMap, mm.posCircle.where);
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
 				mm.ignoreGps = false;
@@ -2270,26 +2655,35 @@
 				mm.ignoreGps = true;
 				mm.setMap(l.selectedMap, mm.posCircle.where);
 				if (mm.currentMap.fileNameWFL.length() &gt; 0)
-					mm.setCenterOfScreen(l.selectedMap.center, true); // if map has an image
+					mm.setCenterOfScreen(l.selectedMap.center, true); // if
+																		// map
+																		// has
+																		// an
+																		// image
 				mm.setResModus(MovingMap.NORMAL_KEEP_RESOLUTION);
-				//Point posCXY = new Point (0,0); mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
-				//double lat = mm.currentMap.affine[0]*posCXY.x + mm.currentMap.affine[2]*posCXY.y + mm.currentMap.affine[4];
-				//mm.posCircleX = 0; // place map to the upper left corner of windows
-				//mm.posCircleY = 0;
-				//mm.updateOnlyPosition(mm.currentMap.affine[4], mm.currentMap.affine[5], true);
+				// Point posCXY = new Point (0,0);
+				// mm.getXYinMap(mm.posCircleLat, mm.posCircleLat);
+				// double lat = mm.currentMap.affine[0]*posCXY.x +
+				// mm.currentMap.affine[2]*posCXY.y +
+				// mm.currentMap.affine[4];
+				// mm.posCircleX = 0; // place map to the upper left corner
+				// of windows
+				// mm.posCircleY = 0;
+				// mm.updateOnlyPosition(mm.currentMap.affine[4],
+				// mm.currentMap.affine[5], true);
 			}
 		}
 	}
 
 	/**
-	 *	Method to react to user.
+	 * Method to react to user.
 	 */
-	public void imageClicked(AniImage which, Point pos){
+	public void imageClicked(AniImage which, Point pos) {
 		mm.getControlsLayer().imageClicked(which);
 	}
 
-	public void penHeld(Point p){
-		ignoreNextDrag=true;
+	public void penHeld(Point p) {
+		ignoreNextDrag = true;
 		if (!mm.zoomingMode) {
 			kontextMenu = new Menu();
 			if (!onlyIfCache) {
@@ -2297,123 +2691,160 @@
 				kontextMenu.addItem(newWayPointMenuItem);
 				kontextMenu.addItem(new MenuItem(&quot;-&quot;));
 			}
-			AniImage clickedOnImage = images.findHotImage(p);
+			final AniImage clickedOnImage = images.findHotImage(p);
 			if (clickedOnImage != null &amp;&amp; clickedOnImage instanceof MapSymbol) {
-				if ( ((MapSymbol)clickedOnImage).mapObject instanceof CacheHolder) {
-					clickedCache = (CacheHolder)( ((MapSymbol)clickedOnImage).mapObject);
-					// clickedCache == null can happen if clicked on the goto-symbol
+				if (((MapSymbol) clickedOnImage).mapObject instanceof CacheHolder) {
+					clickedCache = (CacheHolder) (((MapSymbol) clickedOnImage).mapObject);
+					// clickedCache == null can happen if clicked on the
+					// goto-symbol
 					if (clickedCache != null) {
-						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, &quot;Open Desctiption&quot;)+&quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$o&quot;);
+						CacheHolder ch = clickedCache;
+						if (clickedCache.isAddiWpt()) {
+							ch = clickedCache.mainCache;
+						}
+						if (ch != null) {
+							kontextMenu.addItem(new MenuItem(ch.getWayPoint() + &quot; '&quot; + ch.getCacheName() + &quot;'&quot;));
+							if (!ch.isCustomWpt()) {
+								kontextMenu.addItem(new MenuItem( //
+										CacheSize.cw2ExportString(ch.getCacheSize()) + //
+												&quot; D: &quot; + CacheTerrDiff.longDT(ch.getHard()) + //
+												&quot; T: &quot; + CacheTerrDiff.longDT(ch.getTerrain()) + //
+												&quot;&quot;));
+								kontextMenu.addItem(new MenuItem( //
+										&quot;&quot; + ch.getCacheOwner() + //
+												&quot; &quot; + ch.getDateHidden() + //
+												&quot;&quot;));
+							}
+						}
+						if (clickedCache.isAddiWpt()) {
+							kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint() + &quot; '&quot; + clickedCache.getCacheName() + &quot;'&quot;));
+						}
+						kontextMenu.addItem(new MenuItem(&quot;-&quot;));
+						openCacheDescMenuItem = new MenuItem(MyLocale.getMsg(201, &quot;Open Desctiption&quot;) + &quot;$o&quot;);
 						kontextMenu.addItem(openCacheDescMenuItem);
-						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, &quot;Open Details&quot;)+&quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$e&quot;);
+						openCacheDetailMenuItem = new MenuItem(MyLocale.getMsg(200, &quot;Open Details&quot;) + &quot;$e&quot;);
 						kontextMenu.addItem(openCacheDetailMenuItem);
-						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, &quot;Goto&quot;)+ &quot; '&quot;+(clickedCache.getCacheName().length()&gt;0 ? clickedCache.getCacheName() : clickedCache.getWayPoint())+&quot;'$g&quot;); 
+						gotoCacheMenuItem = new MenuItem(MyLocale.getMsg(4279, &quot;Goto&quot;) + &quot;$g&quot;);
 						kontextMenu.addItem(gotoCacheMenuItem);
+						if (!clickedCache.is_found()) {
+							int msgNr = 318; // normal found
+							if (clickedCache.getType() == CacheType.CW_TYPE_WEBCAM) {
+								msgNr = 361;
+							} else if (clickedCache.getType() == CacheType.CW_TYPE_EVENT || clickedCache.getType() == CacheType.CW_TYPE_MEGA_EVENT) {
+								msgNr = 355;
+							}
+							markFoundMenuItem = new MenuItem(MyLocale.getMsg(msgNr, &quot;Found&quot;) + &quot;$m&quot;);
+							kontextMenu.addItem(markFoundMenuItem);
+						}
 						if (Global.mainForm.cacheListVisible) {
-							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199,&quot;Add to cachetour&quot;));
+							addCachetoListMenuItem = new MenuItem(MyLocale.getMsg(199, &quot;Add to cachetour&quot;));
 							kontextMenu.addItem(addCachetoListMenuItem);
 						}
-						String stmp=clickedCache.getCacheDetails(false).Hints;
-						stmp=stmp.substring(0,Math.min(10,stmp.length())).trim();
-						if (!stmp.equals(&quot;&quot;)){
-							kontextMenu.addItem(hintMenuItem=new MenuItem(&quot;Hint: &quot;+stmp));
+						String stmp = clickedCache.getCacheDetails(false).Hints;
+						stmp = stmp.substring(0, Math.min(10, stmp.length())).trim();
+						if (!stmp.equals(&quot;&quot;)) {
+							kontextMenu.addItem(hintMenuItem = new MenuItem(&quot;Hint: &quot; + stmp));
 						}
 						if (clickedCache.getType() == CacheType.CW_TYPE_QUESTION) {
-							stmp=clickedCache.getCacheDetails(false).LongDescription;
+							stmp = clickedCache.getCacheDetails(false).LongDescription;
 							if (!stmp.equals(&quot;&quot;)) {
-								kontextMenu.addItem(missionMenuItem=new MenuItem(&quot;?: &quot;));								
+								kontextMenu.addItem(missionMenuItem = new MenuItem(&quot;?: &quot;));
 							}
 						}
-						kontextMenu.addItem(new MenuItem(&quot;-&quot;));
-						kontextMenu.addItem(new MenuItem(clickedCache.getWayPoint()+&quot; Info:&quot;));
-						kontextMenu.addItem(new MenuItem(&quot;Difficulty: &quot;+CacheTerrDiff.longDT(clickedCache.getHard())));
-						kontextMenu.addItem(new MenuItem(&quot;Terrain: &quot;+CacheTerrDiff.longDT(clickedCache.getTerrain())));
-						kontextMenu.addItem(new MenuItem(&quot;Size: &quot;+CacheSize.cw2ExportString(clickedCache.getCacheSize())));
 					}
 				}
 			}
 			/*
-			 *  this kontext will be replaced by the settings of the rose in the goto panel
-			 *    
-			if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) {
-			}
-			else {
-				for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
-					kontextMenu.addItem(miLuminary[i]);
-					if (i == mm.myNavigation.luminary) miLuminary[i].modifiers |= MenuItem.Checked;
-					else miLuminary[i].modifiers &amp;= MenuItem.Checked;
-				}
-			}
-			*/
-			onlyIfCache=false;
-			if (kontextMenu.items.size()&gt;0) {
+			 * this kontext will be replaced by the settings of the rose in
+			 * the goto panel
+			 * 
+			 * if ( !(mm.directionArrows.onHotArea(p.x, p.y)) ) { } else {
+			 * for (int i=0; i&lt;SkyOrientation.LUMINARY_NAMES.length; i++) {
+			 * kontextMenu.addItem(miLuminary[i]); if (i ==
+			 * mm.myNavigation.luminary) miLuminary[i].modifiers |=
+			 * MenuItem.Checked; else miLuminary[i].modifiers &amp;=
+			 * MenuItem.Checked; } }
+			 */
+			onlyIfCache = false;
+			if (kontextMenu.items.size() &gt; 0) {
 				kontextMenu.exec(this, new Point(p.x, p.y), this);
-			}
-			else kontextMenu=null;
+			} else
+				kontextMenu = null;
 		}
 	}
-	
+
 	public boolean imageMovedOn(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
-				CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
-				this.toolTip=ch.getWayPoint()+&quot;\n&quot;
-							+ ch.cacheName+&quot;\n&quot;
-							+ &quot;Difficulty: &quot;+CacheTerrDiff.longDT(ch.getHard())+&quot;\n&quot;
-							+ &quot;Terrain: &quot;+CacheTerrDiff.longDT(ch.getTerrain())+&quot;\n&quot;
-							+ &quot;Size: &quot;+CacheSize.cw2ExportString(ch.getCacheSize())+&quot;\n&quot;;
-				if (ch.getType() == CacheType.CW_TYPE_QUESTION) {
-					this.toolTip = this.toolTip + ch.getCacheDetails(false).LongDescription;
-				}
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
+				final CacheHolder ch = (CacheHolder) ((MapSymbol) which).mapObject;
+				this.toolTip = ch.getWayPoint() + &quot;\n&quot; + ch.getCacheName();
 			}
 		}
 		return true;
 	}
+
 	public boolean imageMovedOff(AniImage which) {
 		if (which instanceof MapSymbol) {
-			if ( ((MapSymbol)which).mapObject instanceof CacheHolder) {
-				this.toolTip=null;
+			if (((MapSymbol) which).mapObject instanceof CacheHolder) {
+				this.toolTip = null;
 			}
 		}
 		return true;
 	}
 
-	public void onEvent(Event ev){
+	public void onEvent(Event ev) {
 		// nothing selected in kontext
-		if (kontextMenu != null 
-				&amp;&amp; ev instanceof PenEvent 
-				&amp;&amp; ev.type == PenEvent.PEN_DOWN 
-				&amp;&amp; ev.target == this) {
-			kontextMenu.close(); 
-			kontextMenu = null; 
+		if (kontextMenu != null &amp;&amp; ev instanceof PenEvent &amp;&amp; ev.type == PenEvent.PEN_DOWN &amp;&amp; ev.target == this) {
+			kontextMenu.close();
+			kontextMenu = null;
 			return;
 		}
 		// something selected
 		if (ev instanceof MenuEvent) {
 			if (ev.target == kontextMenu) {
-				if ((((MenuEvent)ev).type==MenuEvent.SELECTED)) {
-					MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
+				if ((((MenuEvent) ev).type == MenuEvent.SELECTED)) {
+					final MenuItem action = (MenuItem) kontextMenu.getSelectedItem();
 					if (action == gotoMenuItem) {
 						closeKontextMenu();
 						mm.myNavigation.setDestination(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 					}
 					if (action == openCacheDescMenuItem || action == openCacheDetailMenuItem) {
 						leaveMovingMap();
-						MainTab mainT = Global.mainTab;
-						if (action == openCacheDescMenuItem) 
-							mainT.openPanel(clickedCache,2);
+						final MainTab mainT = Global.mainTab;
+						if (action == openCacheDescMenuItem)
+							mainT.openPanel(clickedCache, 2);
 						else
-							mainT.openPanel(clickedCache,1);
+							mainT.openPanel(clickedCache, 1);
 					}
 					if (action == gotoCacheMenuItem) {
 						closeKontextMenu();
 						mm.myNavigation.setDestination(clickedCache);
 					}
+					if (action == markFoundMenuItem) {
+						closeKontextMenu();
+						final Time dtm = new Time();
+						dtm.setFormat(&quot;yyyy-MM-dd HH:mm&quot;);
+						clickedCache.setCacheStatus(dtm.toString());
+						clickedCache.setFound(true);
+						clickedCache.save();
+						if (clickedCache.hasAddiWpt()) {
+							CacheHolder addiWpt;
+							for (int i = clickedCache.addiWpts.getCount() - 1; i &gt;= 0; i--) {
+								addiWpt = (CacheHolder) clickedCache.addiWpts.get(i);
+								addiWpt.setCacheStatus(dtm.toString());
+								addiWpt.setFound(true);
+								addiWpt.save();
+								mm.removeMapSymbol(addiWpt.getWayPoint());
+							}
+						}
+						mm.removeMapSymbol(clickedCache.getWayPoint());
+						mm.updateSymbolPositions();
+						this.repaintNow();
+					}
 					if (action == newWayPointMenuItem) {
 						leaveMovingMap();
-						CacheHolder newWP = new CacheHolder();
-						newWP.pos = mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y);
-						newWP.setLatLon(newWP.pos.toString());
+						final CacheHolder newWP = new CacheHolder();
+						newWP.setPos(mm.ScreenXY2LatLon(saveMapLoc.x, saveMapLoc.y));
 						Global.mainTab.newWaypoint(newWP);
 					}
 					if (action == addCachetoListMenuItem) {
@@ -2421,21 +2852,19 @@
 						Global.mainForm.cacheList.addCache(clickedCache.getWayPoint());
 					}
 					if (action == hintMenuItem) {
-						(new MessageBox(&quot;Hint&quot;, STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints),&quot;&lt;br&gt;&quot;,&quot;\n&quot;), FormBase.OKB)).execute();
+						(new MessageBox(&quot;Hint&quot;, STRreplace.replace(Common.rot13(clickedCache.getCacheDetails(false).Hints), &quot;&lt;br&gt;&quot;, &quot;\n&quot;), FormBase.OKB)).execute();
 					}
 					if (action == missionMenuItem) {
-						(new MessageBox(&quot;Mission&quot;, STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription,&quot;&lt;br&gt;&quot;,&quot;\n&quot;), FormBase.OKB)).execute();
+						(new MessageBox(&quot;Mission&quot;, STRreplace.replace(clickedCache.getCacheDetails(false).LongDescription, &quot;&lt;br&gt;&quot;, &quot;\n&quot;), FormBase.OKB)).execute();
 					}
 					/*
-					for (int i=0; i&lt;miLuminary.length; i++) {
-						if (action == miLuminary[i]) {
-							kontextMenu.close();
-							mm.myNavigation.setLuminary(i);
-							mm.updateGps(mm.myNavigation.gpsPos.getFix());
-							miLuminary[i].modifiers |= MenuItem.Checked;
-						} else miLuminary[i].modifiers &amp;= ~MenuItem.Checked;
-					}
-					*/
+					 * for (int i=0; i&lt;miLuminary.length; i++) { if (action ==
+					 * miLuminary[i]) { kontextMenu.close();
+					 * mm.myNavigation.setLuminary(i);
+					 * mm.updateGps(mm.myNavigation.gpsPos.getFix());
+					 * miLuminary[i].modifiers |= MenuItem.Checked; } else
+					 * miLuminary[i].modifiers &amp;= ~MenuItem.Checked; }
+					 */
 				}
 			} // if (ev.target == kontextMenu)
 		}
@@ -2445,84 +2874,97 @@
 	private void closeKontextMenu() {
 		kontextMenu.close();
 		// for not to do an additional klick (before reacting on klicks)
-		PenEvent pev = new PenEvent();
-		pev.target=this;
-		pev.type=PenEvent.PEN_DOWN;
+		final PenEvent pev = new PenEvent();
+		pev.target = this;
+		pev.type = PenEvent.PEN_DOWN;
 		this.postEvent(pev);
-		pev.type=PenEvent.PEN_UP;
+		pev.type = PenEvent.PEN_UP;
 		this.postEvent(pev);
 	}
+
 	private void leaveMovingMap() {
 		closeKontextMenu();
-		WindowEvent close = new WindowEvent();
+		final WindowEvent close = new WindowEvent();
 		close.target = this;
 		close.type = WindowEvent.CLOSE;
-		this.postEvent(close);		
+		this.postEvent(close);
 	}
 }
 
 /**
- *	Class to display maps to choose from
+ * Class to display maps to choose from
  */
-class ListBox extends Form{
+class ListBox extends Form {
 	public MapInfoObject selectedMap; // = new MapInfoObject();
 	mButton cancelButton, okButton;
-	mList list = new mList(4,1,false);
+	mList list = new mList(4, 1, false);
 	public boolean selected = false;
 	Vector maps;
 
-	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap){
+	public ListBox(Vector maps, CWPoint Gps, CWPoint gotopos, MapInfoObject curMap) {
 		this.title = MyLocale.getMsg(4271, &quot;Maps&quot;);
-		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100); else
-		// set width to screenwidth *3/4 but to at least 240 if the screen is big engough for 240px width
-		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth()*3/4, java.lang.Math.min(240, MyLocale.getScreenWidth()) ), MyLocale.getScreenHeight()*3/4);
+		// if (Gui.screenIs(Gui.PDA_SCREEN)) this.setPreferredSize(200,100);
+		// else
+		// set width to screenwidth *3/4 but to at least 240 if the screen
+		// is big engough for 240px width
+		this.setPreferredSize(java.lang.Math.max(MyLocale.getScreenWidth() * 3 / 4, java.lang.Math.min(240, MyLocale.getScreenWidth())), MyLocale.getScreenHeight() * 3 / 4);
 		this.maps = maps;
 		MapInfoObject map;
 		MapListEntry ml;
 		String cmp;
 		int oldmap = -1;
 		boolean curMapFound = false;
-		boolean[] inList = new boolean[maps.size()];
+		final boolean[] inList = new boolean[maps.size()];
 		int row = -1;
-		if (curMap == null) curMapFound = true;
+		if (curMap == null)
+			curMapFound = true;
 		if (gotopos != null &amp;&amp; Gps != null) {
 			list.addItem(MyLocale.getMsg(4272, &quot;--- Maps containing GPS and goto pos. ---&quot;));
 			row++;
-			cmp = &quot;FF1&quot;+(new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
-			for(int i = 0; i&lt;maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = &quot;FF1&quot; + (new Area(new CWPoint(Gps.latDec, Gps.lonDec), gotopos)).getEasyFindString();
+			for (int i = 0; i &lt; maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec) &amp;&amp; map.isInBound(gotopos)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound &amp;&amp; curMap != null &amp;&amp; map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
-				} else inList[i] = false;
+				} else
+					inList[i] = false;
 			}
 		}
 		if (Gps != null) {
 			list.addItem(MyLocale.getMsg(4273, &quot;--- Maps containing curr. position ---&quot;));
 			row++;
-			cmp = &quot;FF1&quot;+Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
-			for(int i = 0; i&lt;maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = &quot;FF1&quot; + Area.getEasyFindString(new CWPoint(Gps.latDec, Gps.lonDec), 30);
+			for (int i = 0; i &lt; maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if( map.isInBound(Gps.latDec, Gps.lonDec) )
-				{
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(Gps.latDec, Gps.lonDec)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound &amp;&amp; curMap != null &amp;&amp; map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2532,18 +2974,23 @@
 		if (gotopos != null) {
 			list.addItem(MyLocale.getMsg(4274, &quot;--- Karten des Ziels ---&quot;));
 			row++;
-			cmp = &quot;FF1&quot;+Area.getEasyFindString(gotopos, 30);
-			for(int i = 0; i&lt;maps.size();i++){
-				ml = (MapListEntry)maps.get(i);
+			cmp = &quot;FF1&quot; + Area.getEasyFindString(gotopos, 30);
+			for (int i = 0; i &lt; maps.size(); i++) {
+				ml = (MapListEntry) maps.get(i);
 				try {
-					if (!Area.containsRoughly(ml.sortEntryBBox, cmp)) continue; // TODO if no map available
-					else { map = ml.getMap();}
-				} catch (IOException ex) {continue; } // could not read .wfl-file
-				if(map.isInBound(gotopos)) {
+					if (!Area.containsRoughly(ml.sortEntryBBox, cmp))
+						continue; // TODO if no map available
+					else {
+						map = ml.getMap();
+					}
+				} catch (final IOException ex) {
+					continue;
+				} // could not read .wfl-file
+				if (map.isInBound(gotopos)) {
 					list.addItem(i + &quot;: &quot; + map.mapName);
 					row++;
 					inList[i] = true;
-					if (!curMapFound  &amp;&amp; curMap!=null &amp;&amp; map.mapName.equals(curMap.mapName)) {
+					if (!curMapFound &amp;&amp; curMap != null &amp;&amp; map.mapName.equals(curMap.mapName)) {
 						oldmap = row;
 						curMapFound = true;
 					}
@@ -2552,69 +2999,76 @@
 		}
 		list.addItem(MyLocale.getMsg(4275, &quot;--- andere Karten ---&quot;));
 		row++;
-		for(int i = 0; i&lt;maps.size();i++){
-			ml = (MapListEntry)maps.get(i);
-			if(!inList[i]) {
+		for (int i = 0; i &lt; maps.size(); i++) {
+			ml = (MapListEntry) maps.get(i);
+			if (!inList[i]) {
 				list.addItem(i + &quot;: &quot; + ml.filename);
 				row++;
-				if (!curMapFound &amp;&amp; curMap!=null &amp;&amp; ml.filename.equals(curMap.mapName)) {
+				if (!curMapFound &amp;&amp; curMap != null &amp;&amp; ml.filename.equals(curMap.mapName)) {
 					oldmap = row;
 					curMapFound = true;
 				}
 			}
 		}
 		list.selectItem(oldmap, true);
-		this.addLast(new CacheWolf.MyScrollBarPanel(list),CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(new CacheWolf.MyScrollBarPanel(list), CellConstants.STRETCH, CellConstants.FILL);
 		cancelButton = new mButton(MyLocale.getMsg(4276, &quot;Cancel&quot;));
 		cancelButton.setHotKey(0, KeyEvent.getCancelKey(true));
-		this.addNext(cancelButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addNext(cancelButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton = new mButton(MyLocale.getMsg(4277, &quot;Select&quot;));
 		okButton.setHotKey(0, KeyEvent.getActionKey(true));
-		this.addLast(okButton,CellConstants.STRETCH, CellConstants.FILL);
+		this.addLast(okButton, CellConstants.STRETCH, CellConstants.FILL);
 		okButton.takeFocus(0);
 	}
+
 	public void mapSelected() {
 		try {
 			selectedMap = null;
 			int mapNum = 0;
 			String it = new String();
 			it = list.getText();
-			if (it != &quot;&quot;){
-				it = it.substring(0,it.indexOf(':'));
+			if (it != &quot;&quot;) {
+				it = it.substring(0, it.indexOf(':'));
 				mapNum = Convert.toInt(it);
 				try {
-				selectedMap = ((MapListEntry)maps.get(mapNum)).getMap();
-				selected = true;
-				this.close(FormBase.IDOK);
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;)
-							+ ((MapListEntry)maps.get(mapNum)).filename, FormBase.OKB)).execute();
+					selectedMap = ((MapListEntry) maps.get(mapNum)).getMap();
+					selected = true;
+					this.close(FormBase.IDOK);
+				} catch (final IOException e) {
+					(new MessageBox(MyLocale.getMsg(4207, &quot;Error&quot;), MyLocale.getMsg(4278, &quot;Cannot load wfl-file: \n&quot;) + ((MapListEntry) maps.get(mapNum)).filename, FormBase.OKB)).execute();
 				}
-			}
-			else {
+			} else {
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-		}catch (NegativeArraySizeException e) {
+		} catch (final NegativeArraySizeException e) {
 			// happens in substring when a dividing line selected
 		}
 	}
 
-	public void onEvent(Event ev){
-		if(ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED){
-			if (ev.target == cancelButton){
+	public void onEvent(Event ev) {
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED) {
+			if (ev.target == cancelButton) {
 				selectedMap = null;
 				selected = false;
 				this.close(FormBase.IDCANCEL);
 			}
-			if (ev.target == okButton || ev.target == list){ // ev.target == list is posted by mList if a selection was double clicked
+			if (ev.target == okButton || ev.target == list) { // ev.target
+																// == list
+																// is posted
+																// by mList
+																// if a
+																// selection
+																// was
+																// double
+																// clicked
 				mapSelected();
 			}
 		}
 		super.onEvent(ev);
 	}
 
-	public void  penDoubleClicked(Point where) {
+	public void penDoubleClicked(Point where) {
 		mapSelected();
 	}
 }
@@ -2626,13 +3080,13 @@
 
 	int minY;
 	Graphics draw;
-	private MapInfoObject map=null;
+	private MapInfoObject map = null;
 
-	Color moveDirColor = new Color(255,0,0); // RED
-	final static Color sunDirColor = new Color(255,255,0); // Yellow
-	//final static Color GREEN = new Color(0,255,0);
-	final static Color gotoDirColor = new Color(0,0,128); // dark blue
-	final static Color northDirColor = new Color(0,0,255); // Blue
+	Color moveDirColor = new Color(255, 0, 0); // RED
+	final static Color sunDirColor = new Color(255, 255, 0); // Yellow
+	// final static Color GREEN = new Color(0,255,0);
+	final static Color gotoDirColor = new Color(0, 0, 128); // dark blue
+	final static Color northDirColor = new Color(0, 0, 255); // Blue
 	Point[] sunDirArrow = null;
 	Point[] gotoDirArrow = null;
 	Point[] moveDirArrow = null;
@@ -2642,31 +3096,37 @@
 	int arrowThickness = imageSize / 28;
 
 	/**
-	 * @param gd goto direction
-	 * @param sd sun direction
-	 * @param md moving direction
+	 * @param gd
+	 *            goto direction
+	 * @param sd
+	 *            sun direction
+	 * @param md
+	 *            moving direction
 	 */
-	public ArrowsOnMap(){
+	public ArrowsOnMap() {
 		super();
 		newImage();
-		//	setDirections(90, 180, -90);
+		// setDirections(90, 180, -90);
 	}
 
 	public void newImage() {
-		setImage(new Image(imageSize,imageSize), Color.White);
+		setImage(new Image(imageSize, imageSize), Color.White);
 		draw = new Graphics(image);
 	}
+
 	public void setMap(MapInfoObject m) {
 		map = m;
 		makeArrows();
 	}
 
-	public void setDirections(float gd, float sd, float md ) {
-		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage only update if the is a change of directions of more than 1 degree
-				|| java.lang.Math.abs(sunDir - sd) &gt; 1
-				|| java.lang.Math.abs(moveDir - md) &gt; 1)
-		{
-			//dirsChanged = false;
+	public void setDirections(float gd, float sd, float md) {
+		if (java.lang.Math.abs(gotoDir - gd) &gt; 1 // to save cpu-usage
+													// only update if the is
+													// a change of
+													// directions of more
+													// than 1 degree
+				|| java.lang.Math.abs(sunDir - sd) &gt; 1 || java.lang.Math.abs(moveDir - md) &gt; 1) {
+			// dirsChanged = false;
 			gotoDir = gd;
 			sunDir = sd;
 			moveDir = md;
@@ -2676,98 +3136,123 @@
 
 	/**
 	 * draw arrows for the directions of movement and destination waypoint
-	 * @param ctrl the control to paint on
-	 * @param moveDir degrees of movement
-	 * @param destDir degrees of destination waypoint
+	 * 
+	 * @param ctrl
+	 *            the control to paint on
+	 * @param moveDir
+	 *            degrees of movement
+	 * @param destDir
+	 *            degrees of destination waypoint
 	 */
 
-	public void doDraw(Graphics g,int options) {
-		if (map == null || g == null) return;
+	public void doDraw(Graphics g, int options) {
+		if (map == null || g == null)
+			return;
 		drawArrows(g);
 		return;
-/*		if (!dirsChanged) {
-			g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); // the transparency with a transparent color doesn't work in ewe-vm for pocketpc, it works in java-vm, ewe-vm on pocketpc2003
-			return;
-		}
-		dirsChanged = false;
-		//super.doDraw(g, options);
-		draw.setColor(Color.White);
-		draw.fillRect(0, 0, location.width, location.height);
-		minY = Integer.MAX_VALUE;
-		drawArrows(draw);
-		draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); // this trick (note: wrong transparentColor) forces a redraw
-		g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
-*/	}
+		/*
+		 * if (!dirsChanged) {
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height); //
+		 * the transparency with a transparent color doesn't work in ewe-vm
+		 * for pocketpc, it works in java-vm, ewe-vm on pocketpc2003 return; }
+		 * dirsChanged = false; //super.doDraw(g, options);
+		 * draw.setColor(Color.White); draw.fillRect(0, 0, location.width,
+		 * location.height); minY = Integer.MAX_VALUE; drawArrows(draw);
+		 * draw.drawImage(image,mask,Color.DarkBlue,0,0,location.width,location.height); //
+		 * this trick (note: wrong transparentColor) forces a redraw
+		 * g.drawImage(image,mask,transparentColor,0,-minY,location.width,location.height);
+		 */}
 
-	private void makeArrows(){
-			// draw only valid arrows
-			if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
-				if (moveDirArrow == null) moveDirArrow = new Point[2];
-				makeArrow(moveDirArrow, moveDir, 1.0f);
-			} else moveDirArrow = null;
-			if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) {
-				if (gotoDirArrow == null) gotoDirArrow = new Point[2];
-				makeArrow(gotoDirArrow, gotoDir, 1.0f);
-			} else gotoDirArrow = null;
-			if (sunDir &lt; 360 &amp;&amp; sunDir&gt; -360) {
-				if (sunDirArrow == null ) sunDirArrow = new Point[2];
-				makeArrow(sunDirArrow, sunDir, 0.75f);
-			} else sunDirArrow = null;
-			if (map != null &amp;&amp; java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI)	{ // show northth arrow only if it has more than 1.5 degree deviation from vertical direction
-				if (northDirArrow == null) northDirArrow = new Point[2];
-				makeArrow(northDirArrow, 0, 1.0f); // north direction
-			} else northDirArrow = null;
+	private void makeArrows() {
+		// draw only valid arrows
+		if (moveDir &lt; 360 &amp;&amp; moveDir &gt; -360) {
+			if (moveDirArrow == null)
+				moveDirArrow = new Point[2];
+			makeArrow(moveDirArrow, moveDir, 1.0f);
+		} else
+			moveDirArrow = null;
+		if (gotoDir &lt; 360 &amp;&amp; gotoDir &gt; -360) {
+			if (gotoDirArrow == null)
+				gotoDirArrow = new Point[2];
+			makeArrow(gotoDirArrow, gotoDir, 1.0f);
+		} else
+			gotoDirArrow = null;
+		if (sunDir &lt; 360 &amp;&amp; sunDir &gt; -360) {
+			if (sunDirArrow == null)
+				sunDirArrow = new Point[2];
+			makeArrow(sunDirArrow, sunDir, 0.75f);
+		} else
+			sunDirArrow = null;
+		if (map != null &amp;&amp; java.lang.Math.abs(map.rotationRad) &gt; 1.5 / 180 * java.lang.Math.PI) { // show
+																									// northth
+																									// arrow
+																									// only
+																									// if
+																									// it
+																									// has
+																									// more
+																									// than
+																									// 1.5
+																									// degree
+																									// deviation
+																									// from
+																									// vertical
+																									// direction
+			if (northDirArrow == null)
+				northDirArrow = new Point[2];
+			makeArrow(northDirArrow, 0, 1.0f); // north direction
+		} else
+			northDirArrow = null;
 
-			//select moveDirColor according to difference to gotoDir
-			moveDirColor = new Color(255,0,0); // red
+		// select moveDirColor according to difference to gotoDir
+		moveDirColor = new Color(255, 0, 0); // red
 
-			if (moveDirArrow != null &amp;&amp; gotoDirArrow != null)
-			{
-				float diff = java.lang.Math.abs(moveDir - gotoDir);
-				while (diff &gt; 360)
-				{
-					diff -= 360.0f;
-				}
-				if (diff &gt; 180)
-				{
-					diff = 360.0f - diff;
-				}
+		if (moveDirArrow != null &amp;&amp; gotoDirArrow != null) {
+			float diff = java.lang.Math.abs(moveDir - gotoDir);
+			while (diff &gt; 360) {
+				diff -= 360.0f;
+			}
+			if (diff &gt; 180) {
+				diff = 360.0f - diff;
+			}
 
-				if (diff &lt;= 5.0)
-				{
-					moveDirColor = new Color(0,192,0);// darkgreen
-				}
-				else if (diff &lt;= 22.5)
-				{
-					moveDirColor = new Color(0,255,0);// green
-				}
-				else if (diff &lt;= 45.0)
-				{
-					moveDirColor = new Color(255,128,0);// orange
-				}
+			if (diff &lt;= 5.0) {
+				moveDirColor = new Color(0, 192, 0);// darkgreen
+			} else if (diff &lt;= 22.5) {
+				moveDirColor = new Color(0, 255, 0);// green
+			} else if (diff &lt;= 45.0) {
+				moveDirColor = new Color(255, 128, 0);// orange
 			}
 		}
+	}
 
 	/**
 	 * make (calculate) Pixel array for a single arrow
-	 * @param g handle for drawing
-	 * @param angle angle of arrow
-	 * @param col color of arrow
+	 * 
+	 * @param g
+	 *            handle for drawing
+	 * @param angle
+	 *            angle of arrow
+	 * @param col
+	 *            color of arrow
 	 */
 	private void makeArrow(Point[] arrow, float angle, float scale) {
-		if (map == null) return;
+		if (map == null)
+			return;
 
 		float angleRad;
-		int centerX = location.width/2, centerY = location.height/2;
-		if (arrow[0] == null) arrow[0] = new Point();
-		if (arrow[1] == null) arrow[1] = new Point();
+		final int centerX = location.width / 2, centerY = location.height / 2;
+		if (arrow[0] == null)
+			arrow[0] = new Point();
+		if (arrow[1] == null)
+			arrow[1] = new Point();
 		arrow[0].x = centerX;
 		arrow[0].y = centerY;
-		angleRad = angle * (float)java.lang.Math.PI / 180 + map.rotationRad;
+		angleRad = angle * (float) java.lang.Math.PI / 180 + map.rotationRad;
 		arrow[1].x = centerX + new Float(centerX * java.lang.Math.sin(angleRad) * scale).intValue();
 		arrow[1].y = centerY - new Float(centerY * java.lang.Math.cos(angleRad) * scale).intValue();
-		//	g.setPen(new Pen(Color.Black,Pen.SOLID,7));
-		//	g.drawLine(centerX,centerY,x,y);
+		// g.setPen(new Pen(Color.Black,Pen.SOLID,7));
+		// g.drawLine(centerX,centerY,x,y);
 	}
 
 	public void drawArrows(Graphics g) {
@@ -2778,12 +3263,9 @@
 	}
 
 	public void drawArrow(Graphics g, Point[] arrow, Color col) {
-		if (arrow == null) return;
-		g.setPen(new Pen(col,Pen.SOLID,arrowThickness));
-		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x,arrow[1].y);
+		if (arrow == null)
+			return;
+		g.setPen(new Pen(col, Pen.SOLID, arrowThickness));
+		g.drawLine(arrow[0].x, arrow[0].y, arrow[1].x, arrow[1].y);
 	}
 }
-
-
-
-

Modified: branches/r1.2/src/CacheWolf/navi/Navigate.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/Navigate.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/Navigate.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,30 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi;
- 
+
 import net.ax86.GPS;
 import net.ax86.GPSException;
 
@@ -46,13 +46,13 @@
 import ewe.ui.MessageBox;
 import ewe.util.mString;
 
-
 /**
  * Non-Gui Class to handle all things regarding navigation
  * (GPS, Sun direction etc.)
  * start offset in localisation file: 4400
+ * 
  * @author Pfeffer
- *
+ * 
  */
 public class Navigate {
 	public CWPoint destination = new CWPoint();
@@ -60,7 +60,7 @@
 	public boolean destinationIsCache = false;
 	public CWGPSPoint gpsPos = new CWGPSPoint();
 	public Track curTrack = null;
-	public Color trackColor = new Color(255,0,0); // red
+	public Color trackColor = new Color(255, 0, 0); // red
 	public CWPoint skyOrientationDir = new CWPoint();
 	public int luminary = SkyOrientation.SUN;
 
@@ -78,160 +78,167 @@
 	public void setGotoPanel(GotoPanel gp) {
 		gotoPanel = gp;
 	}
-	public void setMovingMap (MovingMap mm) {
+
+	public void setMovingMap(MovingMap mm) {
 		movingMap = mm;
-		if (gpsRunning) mm.gpsStarted();
+		if (gpsRunning)
+			mm.gpsStarted();
 	}
 
 	public void startGps(boolean loggingOn, int loggingIntervall) {
 		lograw = loggingOn;
 		logIntervall = loggingIntervall; // TODO switch on and off during serthread running
-		
-		switch(Global.getPref().useGPSD) {
-			// Tblue&gt; TODO: NEW vs. OLD: This is ugly! The only line that's
-			//        different is the one where the object is created!
-			case Preferences.GPSD_FORMAT_NEW:
-				try {
-					gpsdThread = new GpsdThread(gpsPos);
-					gpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-						MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;)
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;),
-						FormBase.OKB)).execute();
-				} catch( Exception e ) {
-					// Other error (JSON/GPS).
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-						MyLocale.getMsg(99999, &quot;Could not initialize GPSD connection: &quot;) 
-						+ e.getMessage(),
-						FormBase.OKB)).execute();
-				}
-				break;
 
-			case Preferences.GPSD_FORMAT_OLD:
-				try {
-					oldGpsdThread = new OldGpsdThread(gpsPos);
-					oldGpsdThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-						MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;)
-						+ e.getMessage()
-						+ MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;),
-						FormBase.OKB)).execute();
-				}
-				break;
+		switch (Global.getPref().useGPSD) {
+		// Tblue&gt; TODO: NEW vs. OLD: This is ugly! The only line that's
+		// different is the one where the object is created!
+		case Preferences.GPSD_FORMAT_NEW:
+			try {
+				gpsdThread = new GpsdThread(gpsPos);
+				gpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;) + e.getMessage() + MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;), FormBase.OKB))
+						.execute();
+			} catch (Exception e) {
+				// Other error (JSON/GPS).
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(99999, &quot;Could not initialize GPSD connection: &quot;) + e.getMessage(), FormBase.OKB)).execute();
+			}
+			break;
 
-			case Preferences.GPSD_DISABLED:
-			default:
-				if (serThread != null) if (serThread.isAlive()) return; // TODO use gpsRunning
-				try {
-					serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : &quot;&quot;));
-					if (pref.forwardGPS &amp;&amp; !serThread.tcpForward) {
-						(new MessageBox(MyLocale.getMsg(4400, &quot;Warning&quot;),
-								MyLocale.getMsg(4401, &quot;Ignoring error:\n could not forward GPS data to host:\n&quot;)
-								+ pref.forwardGpsHost+&quot;\n&quot; + serThread.lastError
-								+ MyLocale.getMsg(4402, &quot;\nstop and start GPS to retry&quot;), FormBase.OKB)).exec();
-					}
-					serThread.start();
-					startDisplayTimer();
-					gpsRunning = true;
-					curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
-					if (lograw)	gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
-					if (gotoPanel != null) gotoPanel.gpsStarted();
-					if (movingMap != null) movingMap.gpsStarted();
-				} catch (IOException e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-							MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
-							+ e.getMessage()
-							+ MyLocale.getMsg(4405, &quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;),
-							FormBase.OKB)).execute();
-				} catch (UnsatisfiedLinkError e) {
-					(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;),
-							MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
-							+ MyLocale.getMsg(4406, &quot;Please copy jave_ewe.dll into the directory of the cachewolf program&quot;),
-							FormBase.OKB)).execute();
+		case Preferences.GPSD_FORMAT_OLD:
+			try {
+				oldGpsdThread = new OldGpsdThread(gpsPos);
+				oldGpsdThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4408, &quot;Could not connect to GPSD: &quot;) + e.getMessage() + MyLocale.getMsg(4409, &quot;\nPossible reasons:\nGPSD is not running or GPSD host is not reachable&quot;), FormBase.OKB))
+						.execute();
+			}
+			break;
+
+		case Preferences.GPSD_DISABLED:
+		default:
+			if (serThread != null)
+				if (serThread.isAlive())
+					return; // TODO use gpsRunning
+			try {
+				serThread = new SerialThread(pref.mySPO, gpsPos, (pref.forwardGPS ? pref.forwardGpsHost : &quot;&quot;));
+				if (pref.forwardGPS &amp;&amp; !serThread.tcpForward) {
+					(new MessageBox(MyLocale.getMsg(4400, &quot;Warning&quot;), MyLocale.getMsg(4401, &quot;Ignoring error:\n could not forward GPS data to host:\n&quot;) + pref.forwardGpsHost + &quot;\n&quot; + serThread.lastError
+							+ MyLocale.getMsg(4402, &quot;\nstop and start GPS to retry&quot;), FormBase.OKB)).exec();
 				}
-				break;
+				serThread.start();
+				startDisplayTimer();
+				gpsRunning = true;
+				curTrack = new Track(trackColor); // TODO addTrack here to MovingMap? see MovingMapPanel.snapToGps
+				if (lograw)
+					gpsPos.startLog(Global.getProfile().dataDir, logIntervall, CWGPSPoint.LOGALL);
+				if (gotoPanel != null)
+					gotoPanel.gpsStarted();
+				if (movingMap != null)
+					movingMap.gpsStarted();
+			} catch (IOException e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;) + e.getMessage()
+						+ MyLocale.getMsg(4405, &quot;\npossible reasons:\n Another (GPS-)program is blocking the port\nwrong port\nOn Loox: active infra-red port is blocking GPS&quot;), FormBase.OKB)).execute();
+			} catch (UnsatisfiedLinkError e) {
+				(new MessageBox(MyLocale.getMsg(4403, &quot;Error&quot;), MyLocale.getMsg(4404, &quot;Could not connect to GPS-receiver.\n Error while opening serial Port &quot;)
+						+ MyLocale.getMsg(4406, &quot;Please copy jave_ewe.dll into the directory of the cachewolf program&quot;), FormBase.OKB)).execute();
+			}
+			break;
 		}
 	}
+
 	public void startDisplayTimer() {
 		tickerThread = new UpdateThread(this, 1000);
 		tickerThread.start();
 	}
 
-	public void stopDisplayTimer(){
-		if (tickerThread != null) tickerThread.stop();
+	public void stopDisplayTimer() {
+		if (tickerThread != null)
+			tickerThread.stop();
 	}
 
 	public void stopGps() {
-		if(serThread!=null)	serThread.stop();
-		if(gpsdThread!=null) gpsdThread.stop();
-		if(oldGpsdThread!=null) oldGpsdThread.stop();
+		if (serThread != null)
+			serThread.stop();
+		if (gpsdThread != null)
+			gpsdThread.stop();
+		if (oldGpsdThread != null)
+			oldGpsdThread.stop();
 		stopDisplayTimer();
 		gpsPos.stopLog();
 		gpsRunning = false;
-		if (gotoPanel != null) gotoPanel.gpsStoped();
-		if (movingMap != null) movingMap.gpsStoped();
+		if (gotoPanel != null)
+			gotoPanel.gpsStoped();
+		if (movingMap != null)
+			movingMap.gpsStoped();
 	}
 
 	public boolean isGpsPosValid() {
-		return ((serThread != null &amp;&amp; serThread.isAlive()) ||
-		       (gpsdThread != null &amp;&amp; gpsdThread.isAlive()) ||
-		       (oldGpsdThread != null &amp;&amp; oldGpsdThread.isAlive()))
-		        &amp;&amp; gpsPos.isValid() ; // &amp;&amp; gpsPos.getfiex();
+		return ((serThread != null &amp;&amp; serThread.isAlive()) || (gpsdThread != null &amp;&amp; gpsdThread.isAlive()) || (oldGpsdThread != null &amp;&amp; oldGpsdThread.isAlive())) &amp;&amp; gpsPos.isValid(); // &amp;&amp; gpsPos.getfiex();
 	}
 
-
 	public void setDestination(String LatLon) {
 		setDestination(new CWPoint(LatLon));
 	}
 
-
 	public void setDestination(CWPoint d) {
 		destinationIsCache = false;
-		destination = new CWPoint (d);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(destination);
+		destination = new CWPoint(d);
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(destination);
 	}
 
 	public void setDestination(CacheHolder ch) {
 		destinationIsCache = true;
-		destinationCache=ch;
-		destination = new CWPoint (ch.pos);
-		if (gotoPanel != null) gotoPanel.destChanged(destination);
-		if (movingMap != null) movingMap.destChanged(ch);
+		destinationCache = ch;
+		destination = new CWPoint(ch.getPos());
+		if (gotoPanel != null)
+			gotoPanel.destChanged(destination);
+		if (movingMap != null)
+			movingMap.destChanged(ch);
 	}
 
 	/**
 	 * use the constants SkyOrientation.SUN, SkyOrientation.MOON etc.
+	 * 
 	 * @param lu
 	 */
 	public void setLuminary(int lu) {
 		luminary = lu;
 	}
+
 	public void ticked() {
 		int fix = gpsPos.getFix();
-		if (fix &gt; 0 &amp;&amp; (gpsPos.getSats()&gt;= 0)) {
-			if (curTrack == null) curTrack = new Track(trackColor);
+		if (fix &gt; 0 &amp;&amp; (gpsPos.getSats() &gt;= 0)) {
+			if (curTrack == null)
+				curTrack = new Track(trackColor);
 			try {
 				curTrack.add(gpsPos);
 			} catch (IndexOutOfBoundsException e) { // track full -&gt; create a new one
 				curTrack = new Track(trackColor);
 				curTrack.add(gpsPos);
-				if (movingMap != null) movingMap.addTrack(curTrack);
+				if (movingMap != null)
+					movingMap.addTrack(curTrack);
 			}
 			try {
 				SkyOrientation.getSunAzimut(gpsPos.Time, gpsPos.Date, gpsPos.latDec, gpsPos.lonDec);
@@ -245,14 +252,14 @@
 			skyOrientationDir.set(-361, -361); // any value out of range (bigger than 360) will prevent drawArrows from drawing it
 		}
 		gotoPanel.updateGps(fix);
-		if (movingMap != null) movingMap.updateGps(fix);
+		if (movingMap != null)
+			movingMap.updateGps(fix);
 	}
 }
 
-
 /**
  * Thread for reading data from gpsd.
- *
+ * 
  * @author Tilman Blumenbach
  */
 class GpsdThread extends mThread {
@@ -260,27 +267,24 @@
 	CWGPSPoint myGPS;
 	boolean run;
 
-
 	public GpsdThread(CWGPSPoint GPSPoint) throws IOException, JSONException, GPSException {
 		JSONObject response;
 		int proto_major;
 
 		myGPS = GPSPoint;
 		gpsObj = new GPS(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
-		gpsObj.stream( GPS.WATCH_ENABLE );
+		gpsObj.stream(GPS.WATCH_ENABLE);
 
 		// Check major protocol version:
 		response = gpsObj.read();
 
-		if( ! response.getString( &quot;class&quot; ).equals( &quot;VERSION&quot; ) ) {
-			throw new GPSException( &quot;Expected VERSION object at connect.&quot; );
-		} else if( ( proto_major = response.getInt( &quot;proto_major&quot; ) ) != 3 ) {
-			throw new GPSException( &quot;Invalid protocol API version; got &quot; +
-					proto_major + &quot;, want 3.&quot; );
+		if (!response.getString(&quot;class&quot;).equals(&quot;VERSION&quot;)) {
+			throw new GPSException(&quot;Expected VERSION object at connect.&quot;);
+		} else if ((proto_major = response.getInt(&quot;proto_major&quot;)) != 3) {
+			throw new GPSException(&quot;Invalid protocol API version; got &quot; + proto_major + &quot;, want 3.&quot;);
 		}
 	}
 
-
 	public void run() {
 		JSONObject response;
 		String respClass;
@@ -290,46 +294,46 @@
 
 		run = true;
 		while (run) {
-			if( gpsObj != null ) {
+			if (gpsObj != null) {
 				gotValidData = false;
 
 				try {
-					/* Tblue&gt; This is ugly, but BufferedReader::ready() seems to
-					 *        be broken in Ewe, so instead of only polling when
-					 *        there is no data from gpsd (by checking the return
-					 *        value of GPS::waiting(), we poll on every iteration.
-					 *        Not ideal, but works for now.
+					/*
+					 * Tblue&gt; This is ugly, but BufferedReader::ready() seems to
+					 * be broken in Ewe, so instead of only polling when
+					 * there is no data from gpsd (by checking the return
+					 * value of GPS::waiting(), we poll on every iteration.
+					 * Not ideal, but works for now.
 					 */
 					gpsObj.poll();
 
-					/* Tblue&gt; TODO: I think this call should not block, but
-					 *              my GPS class does not yet support non-blocking
-					 *              reads...
+					/*
+					 * Tblue&gt; TODO: I think this call should not block, but
+					 * my GPS class does not yet support non-blocking
+					 * reads...
 					 */
-					response  = gpsObj.read();
-					
+					response = gpsObj.read();
+
 					// If we get here we have got some data:
 					noData = 0;
 
-					respClass = response.getString( &quot;class&quot; );
-					if( respClass.equals( &quot;DEVICE&quot; ) &amp;&amp; response.has( &quot;activated&quot; ) &amp;&amp;
-						response.getDouble( &quot;activated&quot; ) != 0 )
-					{	// This is a new device, we need to tell gpsd we want to watch it:
-						Global.getPref().log( &quot;New GPS device, sending WATCH command.&quot; );
-						gpsObj.stream( GPS.WATCH_ENABLE );
-					} else if( respClass.equals( &quot;POLL&quot; ) ) {
+					respClass = response.getString(&quot;class&quot;);
+					if (respClass.equals(&quot;DEVICE&quot;) &amp;&amp; response.has(&quot;activated&quot;) &amp;&amp; response.getDouble(&quot;activated&quot;) != 0) { // This is a new device, we need to tell gpsd we want to watch it:
+						Global.getPref().log(&quot;New GPS device, sending WATCH command.&quot;);
+						gpsObj.stream(GPS.WATCH_ENABLE);
+					} else if (respClass.equals(&quot;POLL&quot;)) {
 						gotValidData = myGPS.examineGpsd(response);
-					} else if( respClass.equals( &quot;ERROR&quot; ) ) {
+					} else if (respClass.equals(&quot;ERROR&quot;)) {
 						// Global.getPref().log( &quot;Ignored gpsd error: &quot; + response.getString( &quot;message&quot; ) );
 					}
-				} catch( Exception e ) {
+				} catch (Exception e) {
 					// Something bad happened, will just ignore this JSON
 					// object:
 					// Ignored Exception&quot;, e, true);
 					gotValidData = false;
 				}
 
-				if( gotValidData ) {
+				if (gotValidData) {
 					notInterpreted = 0;
 				} else {
 					notInterpreted++;
@@ -354,18 +358,16 @@
 		myGPS.noData();
 	}
 
-
 	public void stop() {
 		run = false;
 
-		if( gpsObj != null ) {
+		if (gpsObj != null) {
 			gpsObj.cleanup();
 		}
 	}
 }
 
-
-class OldGpsdThread extends mThread{
+class OldGpsdThread extends mThread {
 	Socket gpsdSocket;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -373,7 +375,7 @@
 	String lastError = new String();
 
 	public OldGpsdThread(CWGPSPoint GPSPoint) throws IOException {
-		try{
+		try {
 			gpsdSocket = new Socket(Global.getPref().gpsdHost, Global.getPref().gpsdPort);
 		} catch (IOException e) {
 			throw new IOException(Global.getPref().gpsdHost);
@@ -386,33 +388,36 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(900);
 				noData++;
-				if (noData &gt; 5) { myGPS.noDataError(); }
+				if (noData &gt; 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 			}
-			if (gpsdSocket != null)	{
+			if (gpsdSocket != null) {
 				gpsResult = getGpsdData(&quot;ADPQTV\r\n&quot;);
-				if (gpsResult!=null) {
+				if (gpsResult != null) {
 					noData = 0;
 					if (myGPS.examineOldGpsd(gpsResult))
 						notinterpreted = 0;
 					else
 						notinterpreted++;
-					if (notinterpreted &gt; 22) myGPS.noInterpretableData();
+					if (notinterpreted &gt; 22)
+						myGPS.noInterpretableData();
 				}
 			}
 
-			//myGPS.printAll();
+			// myGPS.printAll();
 		} // while
 		myGPS.noData();
 	}
 
 	private String getGpsdData(String command) {
-		byte[] rcvBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+		byte[] rcvBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 		int rcvLength = 0;
 		try {
 			gpsdSocket.write(command.getBytes());
@@ -430,7 +435,7 @@
 			Global.getPref().log(&quot;Socket exception&quot;, e, true);
 		}
 		String str = null;
-		if (rcvLength &gt; 0)	{
+		if (rcvLength &gt; 0) {
 			str = mString.fromAscii(rcvBuff, 0, rcvLength);
 		}
 		return str;
@@ -438,18 +443,18 @@
 
 	public void stop() {
 		run = false;
-		if (gpsdSocket != null) gpsdSocket.close();
+		if (gpsdSocket != null)
+			gpsdSocket.close();
 	}
 }
 
-
 /**
  * Thread for reading data from COM-port
- *
+ * 
  */
-class SerialThread extends mThread{
+class SerialThread extends mThread {
 	SerialPort comSp;
-	byte[] comBuff = new byte[1024*10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
+	byte[] comBuff = new byte[1024 * 10]; // when some action takes a long time (eg. loading or zooming a map), a lot of data can be in the buffer, read that at once
 	int comLength = 0;
 	CWGPSPoint myGPS;
 	boolean run, tcpForward;
@@ -457,18 +462,22 @@
 	String lastError = new String();
 
 	public SerialThread(SerialPortOptions spo, CWGPSPoint GPSPoint, String forwardIP) throws IOException {
-		try{
+		try {
 			spo.portName = CacheWolf.Common.fixSerialPortName(spo.portName);
 			comSp = new SerialPort(spo);
 		} catch (IOException e) {
 			throw new IOException(spo.portName);
 		} // catch (UnsatisfiedLinkError e) {} // TODO in original java-vm
-		if (forwardIP.length()&gt;0) {
+		if (forwardIP.length() &gt; 0) {
 			try {
 				tcpConn = new Socket(forwardIP, 23);
 				tcpForward = true;
-			} catch (ewe.net.UnknownHostException e) { tcpForward = false; lastError = e.getMessage();
-			} catch (IOException e) { tcpForward = false; lastError = e.getMessage();
+			} catch (ewe.net.UnknownHostException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
+			} catch (IOException e) {
+				tcpForward = false;
+				lastError = e.getMessage();
 			}
 		}
 		myGPS = GPSPoint;
@@ -478,26 +487,34 @@
 		int noData = 0;
 		int notinterpreted = 0;
 		run = true;
-		while (run){
+		while (run) {
 			try {
 				sleep(1000);
 				noData++;
-				if (noData &gt; 5) { myGPS.noDataError(); }
+				if (noData &gt; 5) {
+					myGPS.noDataError();
+				}
 			} catch (InterruptedException e) {
 				// Global.getPref().log(&quot;Ignored Exception&quot;, e, true);
 			}
-			if (comSp != null)	{
-				comLength = comSp.nonBlockingRead(comBuff, 0 ,comBuff.length);
-				if (comLength &gt; 0)	{
+			if (comSp != null) {
+				comLength = comSp.nonBlockingRead(comBuff, 0, comBuff.length);
+				if (comLength &gt; 0) {
 					noData = 0;
 					String str = mString.fromAscii(comBuff, 0, comLength);
 					if (tcpForward) {
 						try {
 							tcpConn.write(comBuff, 0, comLength);
-						} catch (IOException e) { tcpForward = false; }
+						} catch (IOException e) {
+							tcpForward = false;
+						}
 					}
-					if (myGPS.examine(str)) notinterpreted = 0; else notinterpreted++;
-					if (notinterpreted &gt; 22) myGPS.noInterpretableData();
+					if (myGPS.examine(str))
+						notinterpreted = 0;
+					else
+						notinterpreted++;
+					if (notinterpreted &gt; 22)
+						myGPS.noInterpretableData();
 				}
 			}
 		} // while
@@ -507,7 +524,8 @@
 
 	public void stop() {
 		run = false;
-		if (comSp != null) comSp.close();
+		if (comSp != null)
+			comSp.close();
 	}
 }
 
@@ -522,16 +540,21 @@
 	public int calldelay;
 	public Navigate ticked;
 
-	public UpdateThread (Navigate gp, int cd) {
+	public UpdateThread(Navigate gp, int cd) {
 		ticked = gp;
 		calldelay = cd;
 	}
 
-	public void run () {
+	public void run() {
 		run = true;
 		while (run) {
-			try { sleep (calldelay);} catch (InterruptedException e) {	}
-			try { ticked.ticked();} catch (Exception e) {
+			try {
+				sleep(calldelay);
+			} catch (InterruptedException e) {
+			}
+			try {
+				ticked.ticked();
+			} catch (Exception e) {
 				// Global.getPref().log(&quot;Navigate.UpdateThread.run(): Ignored Exception. There should not be an Exception, so please report it in the cachewolf forum at www.geoclub.de&quot;, e, true);
 			}
 		}
@@ -541,6 +564,3 @@
 		run = false;
 	}
 }
-
-
-

Modified: branches/r1.2/src/CacheWolf/navi/Track.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/Track.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/Track.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,81 +1,93 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
-
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
 package CacheWolf.navi;
 
 import ewe.fx.Color;
+import ewe.io.BufferedWriter;
+import ewe.io.FileWriter;
+import ewe.io.IOException;
+import ewe.io.PrintWriter;
+import ewe.sys.Vm;
+import ewe.ui.MessageBox;
+import ewe.util.Utils;
 
 public class Track {
 	public Color trackColor;
-	public TrackPoint TrackPoints[];
-	public int num;
+	private TrackPoint trackPoints[];
+    private int index;
+	private int num;
 	
-	public Track(Color f) {
+	public Track(Color f, int trackSize) {
 		trackColor = f;
-		TrackPoints = new TrackPoint[5000];
+		trackPoints = new TrackPoint[trackSize];
 		num = 0;
+        index = 0;
 	}
-/*===== add is currently not used	
+
+        public Track (Color f){
+            this(f, 5000);
+        }
+
+        public Track (){
+            this (new Color (0xff,0,0));
+        }
+
 	public void add(double lat, double lon) {
-		TrackPoints[num] = new TrackPoint(lat, lon);
-		num++;
+		add(new TrackPoint(lat, lon));
 	}
-=====*/	
+
 	/**
-	 * throws IndexOutOfBoundsException when track is full
 	 */
 	public void add(TrackPoint t) { 
-		if (TrackPoints == null || t == null) return;
-		TrackPoints[num] = new TrackPoint(t);
+		if (t == null) return;
+		
+		trackPoints[index] = new TrackPoint(t);
+        index++;
+        if (index &gt;= trackPoints.length) index = 0;
 		num++;
+        if (num &gt;= trackPoints.length) num = trackPoints.length;
 	}
-/*===== loadTrack/saveTrack are currently not used
+        
+        /**
+         * returns number of Point in this track
+         */
+        public int size(){
+            return num;
+        }
+
+        /**
+          * returns the i.th point in this track
+          */
+        public TrackPoint get (int i){
+            //The array has never been filled, so first position is 0:
+            if (num &lt; trackPoints.length) return trackPoints[i];
+            //Once filled, the least inserted position is marked by index
+            int tmpIndex = (index+i) % trackPoints.length;
+            return trackPoints[tmpIndex];
+        }
+
 	public void loadTrack(String filename){ // TODO untested!
-		byte [] all = ewe.sys.Vm.readResource(null,filename);
+		byte [] all = Vm.readResource(null,filename);
 		if (all == null) return; // TODO error handling
-		num = Utils.readInt(all, 0, 4);
-		for (int i=0; i&lt;=num; i++){
-			TrackPoints[i].latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
-			TrackPoints[i].lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+		int numOfPoints = Utils.readInt(all, 0, 4);
+		for (int i=0; i&lt;=numOfPoints; i++){
+			TrackPoint point = new TrackPoint();
+			point.latDec = Double.longBitsToDouble(Utils.readLong(all, (i*2)*8 + 4));
+			point.lonDec = Double.longBitsToDouble(Utils.readLong(all, (i*2+1)*8 + 4));
+			add (point);
 		}
 	}
 	
-	public void saveTrack(String filename){  // TODO untested!
-	//ByteArray ba=new ByteArray();
-	byte[] ba = new byte[8*2*num+4]; // 8 bytes is one double int has size 4
-	Utils.writeInt(num, ba, 0, 4);
-	for (int i=0; i&lt;=num; i++){
-		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].latDec), ba, (i*2)*8 + 4);
-		Utils.writeLong(Double.doubleToLongBits(TrackPoints[i].lonDec), ba, (i*2+1)*8 + 4);
+	public void saveTrack(String filename) { // TODO untested!
+		byte[] ba = new byte[8 * 2 * size() + 4]; // 8 bytes is one double int has size 4
+		Utils.writeInt(size(), ba, 0, 4);
+		for (int i = 0; i &lt;= size(); i++) {
+			Utils.writeLong(Double.doubleToLongBits(get(i).latDec), ba, (i * 2) * 8 + 4);
+			Utils.writeLong(Double.doubleToLongBits(get(i).lonDec), ba, (i * 2 + 1) * 8 + 4);
+		}
+		try {
+			PrintWriter outp = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
+			outp.print(ba.toString());
+		} catch (IOException e) {
+			(new MessageBox(&quot;Error&quot;, &quot;Error reading trackfile:\n&quot; + e.toString(), MessageBox.OKB)).execute();
+		}
 	}
-	try{
-		PrintWriter outp =  new PrintWriter(new BufferedWriter(new FileWriter(filename)));
-		outp.print(ba.toString());
-	}catch (IOException e) {
-		(new MessageBox(&quot;Error&quot;, &quot;Error reading trackfile:\n&quot;+e.toString(), MessageBox.OKB)).execute();}
-	}
-=====*/
-
 }

Modified: branches/r1.2/src/CacheWolf/navi/TrackOverlay.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/TrackOverlay.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/TrackOverlay.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -107,9 +107,9 @@
 		int tri, i;
 		Track tr;
 		int numberOfTracks = tracks.size();
-		int numberOfPoints = ((Track)tracks.get(numberOfTracks - 1)).num;
+		int numberOfPoints = ((Track)tracks.get(numberOfTracks - 1)).size();
 		if (numberOfTracks &gt; 1){
-			numberOfPoints += (numberOfTracks - 1) * ((Track)tracks.get(0)).num;
+			numberOfPoints += (numberOfTracks - 1) * ((Track)tracks.get(0)).size();
 		}
 		int n = 0;
 		
@@ -117,13 +117,13 @@
 			tr = (Track)tracks.get(tri);
 			//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
 			draw.setColor(tr.trackColor);
-			if (tr.num &gt; 0) {
-				for (i=0; i &lt; tr.num; i++) {
+			if (tr.size() &gt; 0) {
+				for (i=0; i &lt; tr.size(); i++) {
 					n++;
 					if  ((numberOfPoints - n &gt; 5*60) &amp;&amp; ((n &amp; 1) == 0)) continue;
 					if  ((numberOfPoints - n &gt; 15*60) &amp;&amp; ((n &amp; 2) == 0)) continue;
 					if  ((numberOfPoints - n &gt; 30*60) &amp;&amp; ((n &amp; 4) == 0)) continue;
-					paintPoint(tr.trackColor, tr.TrackPoints[i]);
+					paintPoint(tr.trackColor, tr.get(i));
 				}
 			}
 		}
@@ -195,7 +195,7 @@
 	public void paintLastAddedPoint(Track tr) { 
 		//draw.setPen(new Pen((Color) tr.trackColor,Pen.SOLID,3));
 		draw.setColor(tr.trackColor);
-		if (paintPoint(tr.trackColor, tr.TrackPoints[tr.num-1])) notOnThisOverlaySince = 0;
+		if (paintPoint(tr.trackColor, tr.get(tr.size()-1))) notOnThisOverlaySince = 0;
 		else notOnThisOverlaySince++;
 		if (notOnThisOverlaySince &gt; FIXATE_IF_NO_PIXELS_NUM) { // zur Performanceverbesserung: wenn in den letzten 60 Updates keines mehr f&#252;r dieses Overlay dabei war, Overlay Pixels fest schreiben, damit doDraw entlastet wird.
 			fixate();

Modified: branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItem.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,28 +1,28 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
 import CacheWolf.Global;
@@ -87,25 +87,21 @@
 					offsetx = offsety;
 				}
 
-				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH,
-						0);
-				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW,
-						imageH, 0);
+				int[] iconPixels = icon.getPixels(null, 0, 0, 0, iconW, iconH, 0);
+				int[] imagePixels = image.getPixels(null, 0, 0, 0, imageW, imageH, 0);
 
-				for (int line = 0; line &lt; imageH; line++) {
-					for (int pos = 0; pos &lt; imageW; pos++) {
+				for (int y = 0; y &lt; imageH; y++) {
+					for (int x = 0; x &lt; imageW; x++) {
 
-						if (line &gt;= offsety &amp;&amp; pos &gt;= offsetx
-								&amp;&amp; line &lt; offsety + iconH
-								&amp;&amp; pos &lt; offsetx + iconW) {
+						if (y &gt;= offsety &amp;&amp; x &gt;= offsetx &amp;&amp; y &lt; offsety + iconH &amp;&amp; x &lt; offsetx + iconW) {
 
-							int iconx = pos - offsetx;
-							int icony = line - offsety;
+							int iconx = x - offsetx;
+							int icony = y - offsety;
 
-							int index = line * imageW + pos;
+							int index = y * imageW + x;
 							int iconIndex = icony * iconW + iconx;
 							int alphaval = (iconPixels[iconIndex] &gt;&gt; 24) &amp; 0xff;
-							
+
 							if (alphaval &gt; 127) {
 								imagePixels[index] = iconPixels[iconIndex];
 							}
@@ -117,15 +113,14 @@
 				image.setPixels(imagePixels, 0, 0, 0, imageW, imageH, 0);
 
 			} else
-				Global.getPref().log(&quot;icon &quot; + iconSrc + &quot; is bigger than &quot; + source+ &quot;! Icon not loaded&quot;,null);
+				Global.getPref().log(&quot;icon &quot; + iconSrc + &quot; is bigger than &quot; + source + &quot;! Icon not loaded&quot;, null);
 
 		}
 
 		if (alpha &gt;= 0 &amp;&amp; alpha &lt; 256) {
 			alpha = alpha &lt;&lt; 24;
 
-			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(),
-					image.getHeight(), 0);
+			int[] imageBits = image.getPixels(null, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			for (int i = 0; i &lt; imageBits.length; i++) {
 				if (imageBits[i] != 0) {
 					imageBits[i] &amp;= 0xffffff;
@@ -133,8 +128,7 @@
 				}
 
 			}
-			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image
-					.getHeight(), 0);
+			image.setPixels(imageBits, 0, 0, 0, image.getWidth(), image.getHeight(), 0);
 			image.enableAlpha();
 		}
 
@@ -156,6 +150,7 @@
 	public String getContent() {
 		return null;
 	}
+
 	public String getText() {
 		return null;
 	}
@@ -209,7 +204,7 @@
 
 			Boolean thisElement = (Boolean) roles.get(nextKey);
 			if (!overallRoles.containsKey(nextKey)) {
-				Global.getPref().log(&quot;Lookup role &quot; + nextKey + &quot; not possible&quot;,null);
+				Global.getPref().log(&quot;Lookup role &quot; + nextKey + &quot; not possible&quot;, null);
 				return false;
 			}
 

Modified: branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlItemButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,31 +1,30 @@
-    /*
-    GNU General Public License
-    CacheWolf is a software for PocketPC, Win and Linux that
-    enables paperless caching.
-    It supports the sites geocaching.com and opencaching.de
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
 
-    Copyright (C) 2006  CacheWolf development team
-    See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
-    for more information.
-    Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
-    			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; version 2 of the License.
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
 package CacheWolf.navi.touchControls;
 
-
 import ewe.fx.Image;
 import ewe.fx.mImage;
 import ewe.graphics.AniImage;
@@ -34,22 +33,20 @@
 
 	private int command;
 	private AniImageGrayScaled aniImage;
-	
-	public MovingMapControlItemButton(String source,String iconSrc, int actionCommand,
-			int alpha) {
+
+	public MovingMapControlItemButton(String source, String iconSrc, int actionCommand, int alpha) {
 		Image image = MovingMapControlItem.createImage(source, iconSrc, alpha);
 		aniImage = new AniImageGrayScaled(image);
 		aniImage.freeSource();
 		command = actionCommand;
-		aniImage.properties|= mImage.AlwaysOnTop;
-		xProperties|=IS_ICON_WITH_COMMAND;
+		aniImage.properties |= mImage.AlwaysOnTop;
+		xProperties |= IS_ICON_WITH_COMMAND;
 	}
 
 	public int getActionCommand() {
 		return command;
 	}
 
-	
 	public int getWidth() {
 		return aniImage.getWidth();
 	}

Modified: branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java
===================================================================
--- branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/navi/touchControls/MovingMapControlSettings.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -84,7 +84,7 @@
 	public static final String BUTTON_ATTR_FROM_BOTTOM = &quot;fromBottom&quot;;
 	/**
 	 * define when this button is visible. Contains a list of rolenames. Delimiter is '+'. If the role name starts with
-	 * '!' the buttom is shown if this role is inactive [(!)String+(!)String...] Example visibleIf=&quot;menu+!zoom&quot; button
+	 * '!' the button is shown if this role is inactive [(!)String+(!)String...] Example visibleIf=&quot;menu+!zoom&quot; button
 	 * is visible if role &quot;menu&quot; is active and role &quot;zoom&quot; is inactive.
 	 */
 	public static final String BUTTON_ATTR_VISIBILITY = &quot;visibleIf&quot;;

Modified: branches/r1.2/src/CacheWolf/utils/CWWrapper.java
===================================================================
--- branches/r1.2/src/CacheWolf/utils/CWWrapper.java	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/src/CacheWolf/utils/CWWrapper.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -58,6 +58,7 @@
 		return exec(cmd, arg, false, true);
 	}
 	public static int exec(String cmd, String arg, final boolean wait, final boolean surround) throws ewe.io.IOException {
+		// works if there is only one argument
 		if (surround) {
 			if (Vm.getPlatform().equals(&quot;WinCE&quot;) || Vm.getPlatform().equals(&quot;Win32&quot;))
 			{
@@ -70,8 +71,11 @@
 				 * (see ewe/sys/Vm.java)			 *
 				 * on linux (and os x?) we must not have extra quotes, filenames with spaces are unsupported
 				 * */
-				if (cmd.indexOf(' ') &gt; -1) {
-					cmd = &quot;\&quot;&quot; + cmd + &quot;\&quot;&quot;;
+				if (cmd.indexOf(':') == 1) {
+					// java on Windows
+					if (cmd.indexOf(' ') &gt; -1) {
+						cmd = &quot;\&quot;&quot; + cmd + &quot;\&quot;&quot;;
+					}
 				}
 				if (arg.indexOf(' ') &gt; -1) {
 					arg = &quot;\&quot;&quot; + arg + &quot;\&quot;&quot;;


Property changes on: branches/r1.2/src/CacheWolf/view
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/ITravelbugScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,17 @@
+package CacheWolf.view;
+
+public interface ITravelbugScreen {
+
+	/**
+	 * Shows the form
+	 * @return
+	 */
+	int execute();
+
+	/**
+	 * Returns the selected entry if any else &lt;code&gt;null&lt;/code&gt;
+	 * @return
+	 */
+	int getSelectedItem();
+
+}
\ No newline at end of file

Added: branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/TravelBugScreenFactory.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,65 @@
+package CacheWolf.view;
+
+import java.lang.reflect.Constructor;
+
+import CacheWolf.Global;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugScreen;
+import CacheWolf.view.ewe.TravelbugJourneyScreen;
+import CacheWolf.view.pda.PDATravelbugScreen;
+import ewe.reflect.Reflect;
+import ewe.sys.Vm;
+
+public class TravelBugScreenFactory {
+
+	/**
+	 * Variante fuer Desktop unter Java???
+	 */
+	private static boolean isSwing;
+	static {
+		Global.getPref().log(&quot;Static initializer start &quot;);
+		Class swingClass = null;
+		try {
+			swingClass = TravelbugJourneyScreen.class.getClassLoader().loadClass(&quot;javax.swing.JTable&quot;);
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Swing not found&quot;);
+			Global.getPref().log(e.toString());
+			// ignore!
+		}
+		isSwing = swingClass != null &amp;&amp; false;
+	}
+
+	/**
+	 * Variante fuer Android-PDA
+	 */
+	private static final boolean isAndroid = false;
+
+	public static ITravelbugScreen createTravelbugScreen(TravelbugList tbl, String title, Boolean allowNew) {
+		Global.getPref().log(&quot;Mobile-Device: &quot; + Vm.isMobile());
+		Global.getPref().log(&quot;Preference for Mobile-Device: &quot; + Global.getPref().mobileGUI);
+		if (Vm.isMobile() &amp;&amp; Global.getPref().mobileGUI) {
+			try {
+				Class loadClass = Reflect.getForName(&quot;CacheWolf.view.pda.PDATravelbugScreen&quot;).getReflectedClass();
+				Constructor constructor = loadClass.getConstructor(new Class[] { TravelbugList.class, String.class, boolean.class });
+				ITravelbugScreen result = (ITravelbugScreen) constructor.newInstance(new Object[] { tbl, title, allowNew });
+				Global.getPref().log(&quot;TBScreen successfully instantiated&quot;);
+				return result;
+			} catch (Throwable e) {
+				Global.getPref().log(&quot;CacheWolf.view.pda.PDATravelbugScreen not found&quot;);
+				Global.getPref().log(&quot;Error in instantiating TravelBugScreen&quot;, e, true);
+				e.printStackTrace();
+				// ignore?? VM on WinPC seems to have no classloader
+				return new PDATravelbugScreen(tbl, title, allowNew.booleanValue());
+			}
+		} else if (isSwing) {
+			throw new InstantiationError(&quot;No Swing GUI available&quot;);
+			// return new TravelbugJourneyScreen(model);
+		} else if (isAndroid) {
+			throw new InstantiationError(&quot;No Android GUI available&quot;);
+			// return new TravelbugJourneyScreen(model);
+		} else {
+			return new TravelbugScreen(tbl, title, allowNew.booleanValue());
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/TravelbugJourneyScreenFactory.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,77 @@
+package CacheWolf.view;
+
+import java.lang.reflect.Constructor;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.Global;
+import CacheWolf.TravelbugJourneyList;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import CacheWolf.view.ewe.TravelbugJourneyScreen;
+import CacheWolf.view.pda.PDATravelbugJourneyScreen;
+import ewe.reflect.Reflect;
+import ewe.sys.Vm;
+import ewe.ui.Form;
+
+public class TravelbugJourneyScreenFactory {
+
+	/**
+	 * Variante fuer Desktop unter Java???
+	 */
+	private static boolean isSwing ;
+	static{
+		Global.getPref().log(&quot;Static initializer start &quot;);
+		Class swingClass = null;
+		try {
+			swingClass = TravelbugJourneyScreen.class.getClassLoader().loadClass(&quot;javax.swing.JTable&quot;);
+		} catch (Exception e) {
+			Global.getPref().log(&quot;Swing not found&quot;);
+			Global.getPref().log(e.toString());
+			//ignore!
+		}
+		isSwing = swingClass!=null;
+		isSwing = false;
+	}
+
+	/**
+	 * Variante fuer Android-PDA
+	 */
+	private static final boolean isAndroid = false;
+
+	public static Form createTravelbugJourneyScreen() {
+		TravelBugJourneyScreenModel model = new TravelBugJourneyScreenModel();
+		model.onlyLogged = Global.getPref().travelbugShowOnlyNonLogged;
+		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		CacheHolder ch = cacheDB.get(curCacheNo);
+		model.actualCache = ch;
+		TravelbugJourneyList myTravelbugJourneys = new TravelbugJourneyList();
+		myTravelbugJourneys.readTravelbugsFile();
+
+		model.allTravelbugJourneys = myTravelbugJourneys;
+
+		Global.getPref().log(&quot;Mobile-Device: &quot; + Vm.isMobile());
+		Global.getPref().log(&quot;Preference for Mobile-Device: &quot; + Global.getPref().mobileGUI);
+		if (Vm.isMobile() &amp;&amp; Global.getPref().mobileGUI) {
+			try {
+				Class loadClass = Reflect.getForName(&quot;CacheWolf.view.pda.PDATravelbugJourneyScreen&quot;).getReflectedClass();
+				Constructor constructor = loadClass.getConstructor(new Class[]{model.getClass()});
+				Form result = (Form) constructor.newInstance(new Object[] {model});
+				Global.getPref().log(&quot;TBScreen successfully instantiated&quot;);
+				return result;
+			} catch (Throwable e) {
+				Global.getPref().log(&quot;CacheWolf.view.pda.PDATravelbugJourneyScreen not found&quot;);
+				Global.getPref().log(&quot;Error in instantiating TravelBugJourneyScreen&quot;, e, true);
+				e.printStackTrace();
+				//ignore?? VM on WinPC seems to have no classloader
+				return new PDATravelbugJourneyScreen(model);
+			}
+		} else if ( isSwing) {
+			throw new InstantiationError (&quot;No Swing GUI available&quot;);
+		} else if (isAndroid) {
+			throw new InstantiationError (&quot;No Android GUI available&quot;);
+		} else {
+			return new TravelbugJourneyScreen(model);
+		}
+	}
+}


Property changes on: branches/r1.2/src/CacheWolf/view/ewe
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/ewe/TravelbugJourneyScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,773 @@
+/*
+GNU General Public License
+CacheWolf is a software for PocketPC, Win and Linux that
+enables paperless caching.
+It supports the sites geocaching.com and opencaching.de
+
+Copyright (C) 2006  CacheWolf development team
+See <A HREF="http://developer.berlios.de/projects/cachewolf/">http://developer.berlios.de/projects/cachewolf/</A>
+for more information.
+Contact: 	<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">bilbowolf at users.berlios.de</A>
+			<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">kalli at users.berlios.de</A>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+package CacheWolf.view.ewe;
+
+/**
+ * A list to manage the travelbugs. Each row represents one @see TravelbugJourney.
+ * The lower half of the screen which is separated from the top by a splitter bar,
+ * contains four tabs: One for the travelbug, one for the source (where the travelbug 
+ * was picked up), one for the destination (where the travelbug was dropped) and one
+ * for the mission. These tabs are used for inputting data about the travelbug journey.
+ * The travelbugs are read from file travelbugs.xml which is stored in the base directory.
+ * When the screen is closed, all data is written back to the file.
+ * @author salzkammergut
+ */
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.DateTimeChooser;
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.MyScrollBarPanel;
+import CacheWolf.TableColumnChooser;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugPickup;
+import CacheWolf.imp.SpiderGC;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import CacheWolf.utils.CWWrapper;
+import ewe.fx.Color;
+import ewe.fx.Dimension;
+import ewe.fx.FontMetrics;
+import ewe.fx.IImage;
+import ewe.fx.IconAndText;
+import ewe.fx.Image;
+import ewe.fx.Point;
+import ewe.fx.Rect;
+import ewe.fx.mImage;
+import ewe.sys.Convert;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.CellConstants;
+import ewe.ui.CellPanel;
+import ewe.ui.Control;
+import ewe.ui.ControlConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.DataChangeEvent;
+import ewe.ui.Event;
+import ewe.ui.Form;
+import ewe.ui.FormEvent;
+import ewe.ui.Gui;
+import ewe.ui.HtmlDisplay;
+import ewe.ui.IKeys;
+import ewe.ui.Menu;
+import ewe.ui.MenuItem;
+import ewe.ui.MultiPanelEvent;
+import ewe.ui.PanelSplitter;
+import ewe.ui.PenEvent;
+import ewe.ui.ScrollablePanel;
+import ewe.ui.SplittablePanel;
+import ewe.ui.TableCellAttributes;
+import ewe.ui.TableControl;
+import ewe.ui.TableModel;
+import ewe.ui.mButton;
+import ewe.ui.mCheckBox;
+import ewe.ui.mInput;
+import ewe.ui.mLabel;
+import ewe.ui.mTabbedPanel;
+
+public class TravelbugJourneyScreen extends Form {
+
+	// ============= VIEW
+	/** The list control */
+	// Set to Public to implement MVC-Pattern [AP]
+	public tbListControl tcTbJourneyList;
+	/** The list model */
+	// Set to Public to implement MVC-Pattern [AP]
+	public tbListTableModel modTbJourneyList;
+	/** The actual journeys */
+
+	/** The panel for the lower half of the screen */
+	private CellPanel lowerpane;
+	private mInput inpName, inpTrackingNo, inpFromDate, inpFromProfile, inpFromWaypoint, inpToDate, inpToProfile, inpToWaypoint;
+	private mLabel lblId;
+	private mButton btnFromDate, btnToDate;
+	private mCheckBox chkFromLogged, chkToLogged;
+	private HtmlDisplay txtMission;
+	private mTabbedPanel pnlTab;
+
+	/** The currently selected row */
+	// Set to Public to implement MVC-Pattern [AP]
+	public int selectedRow = -1;
+
+	/** A label which holds the number of currently displayed travelbug journeys */
+	private mLabel lblNumVisibleJourneys;
+	private final Color RED = new Color(255, 0, 0);
+	private int exitKeys[] = { 75009 };
+
+	// =========== CONTROLLER
+	public TravelbugMenu mnuTBMenu;
+	// ========== MODEL
+	public TravelBugJourneyScreenModel model;
+
+	/**
+	 * A flag to track whether the current cache has to be saved because a
+	 * travelbug was added to or taken from it.
+	 */
+	// Set to Public to implement MVC-Pattern [AP]
+	public boolean chDmodified = false;
+
+	// =========== MODEL
+	// Set to Public to implement MVC-Pattern [AP]
+	// public TravelbugJourneyList tblMyTravelbugJourneys;
+	/** List of TBs in the current cache */
+	// Set to Public to implement MVC-Pattern [AP]
+	public TravelbugList tblSrcCache;
+	/** The current cache */
+	// Set to Public to implement MVC-Pattern [AP]
+	public CacheHolderDetail chD;
+	/** The base data of the current cache */
+	// Set to Public to implement MVC-Pattern [AP]
+	public CacheHolder ch;
+	/** The name of the current waypoint */
+	// Set to Public to implement MVC-Pattern [AP]
+	public String waypoint = &quot;&quot;;
+
+	public TravelbugJourneyScreen(TravelBugJourneyScreenModel newModel) {
+		model = newModel;
+		CacheDB cacheDB = Global.getProfile().cacheDB;
+		SplittablePanel split = new SplittablePanel(PanelSplitter.VERTICAL);
+		// On modern PDAs the splitter is to small to move it with the stylus.
+		// We will make it a littler thicker
+		MyLocale.setSplitterSize(split);
+		CellPanel tablepane = split.getNextPanel();
+		int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+		String cache = &quot;&quot;;
+		if (curCacheNo &gt;= 0 &amp;&amp; curCacheNo &lt; cacheDB.size()) {
+			ch = cacheDB.get(curCacheNo);
+			cache = MyLocale.getMsg(6022, &quot;: Current cache: &quot;) + ch.getWayPoint() + &quot; - &quot; + ch.getCacheName();
+			waypoint = ch.getWayPoint();
+			chD = ch.getCacheDetails(true);
+			tblSrcCache = ch.getCacheDetails(true).Travelbugs;
+		}
+		title = &quot;Travelbugs&quot; + cache;
+		tcTbJourneyList = new tbListControl(model);
+		tcTbJourneyList.setTableModel(modTbJourneyList = new tbListTableModel());
+		tablepane.addLast(new MyScrollBarPanel(tcTbJourneyList, ScrollablePanel.AlwaysShowVerticalScrollers), STRETCH, FILL);
+
+		lowerpane = split.getNextPanel();
+
+		pnlTab = new mTabbedPanel();
+		pnlTab.extraControlsRight = lblNumVisibleJourneys = new mLabel(&quot;  0&quot;);
+		// ------------------------------------------------
+		// SET Menu
+		// ------------------------------------------------
+		mnuTBMenu = new TravelbugMenu(model);
+		mnuTBMenu.view = this;
+
+		addLast(mnuTBMenu, HSTRETCH, HFILL);
+
+		// ------------------------------------------------
+		// First Tab - Name &amp; Tracking #
+		// ------------------------------------------------
+		CellPanel pnlName = new CellPanel();
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6025, &quot;Name:&quot;)), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpName = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6026, &quot;Tracking #:&quot;)), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(inpTrackingNo = new mInput(), HSTRETCH, HFILL);
+		pnlName.addNext(new mLabel(MyLocale.getMsg(6027, &quot;ID/GUID:&quot;)), DONTSTRETCH, DONTFILL);
+		pnlName.addLast(lblId = new mLabel(&quot;&quot;), HSTRETCH, HFILL);
+		pnlTab.addCard(pnlName, MyLocale.getMsg(6028, &quot;Name&quot;), &quot;Name&quot;);
+
+		// ------------------------------------------------
+		// Second Tab - Where was the TB picked up from
+		// ------------------------------------------------
+		CellPanel pnlFrom = new CellPanel();
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6029, &quot;Profile/Cache:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromProfile = new mInput(), HSTRETCH, HFILL);
+		pnlFrom.addLast(inpFromWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6030, &quot;Date found:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addNext(inpFromDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		pnlFrom.addLast(btnFromDate = new mButton(new mImage(&quot;calendar.png&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		btnFromDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		pnlFrom.addNext(new mLabel(MyLocale.getMsg(6031, &quot;Logged:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlFrom.addLast(chkFromLogged = new mCheckBox(&quot;&quot;), DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged.exitKeys = exitKeys;
+		pnlFrom.addLast(new mLabel(&quot;&quot;));
+
+		pnlTab.addCard(pnlFrom, MyLocale.getMsg(6032, &quot;From&quot;), &quot;From&quot;);
+
+		// ------------------------------------------------
+		// Third Tab - Where was the TB dropped
+		// ------------------------------------------------
+		CellPanel pnlTo = new CellPanel();
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6029, &quot;Profile/Cache:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToProfile = new mInput(), HSTRETCH, HFILL);
+		pnlTo.addLast(inpToWaypoint = new mInput(), HSTRETCH, HFILL);
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6033, &quot;Date dropped:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addNext(inpToDate = new mInput(), CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		// inpToDate.modifyAll(DisplayOnly,0);
+		pnlTo.addLast(btnToDate = new mButton(new mImage(&quot;calendar.png&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		btnToDate.modify(0, ControlConstants.TakesKeyFocus);
+		// pnlTo.addLast(new mLabel(&quot;&quot;));
+
+		pnlTo.addNext(new mLabel(MyLocale.getMsg(6031, &quot;Logged:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		pnlTo.addLast(chkToLogged = new mCheckBox(&quot;&quot;), DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged.exitKeys = exitKeys;
+		pnlTo.addLast(new mLabel(&quot;&quot;));
+
+		pnlTab.addCard(pnlTo, MyLocale.getMsg(6034, &quot;To&quot;), &quot;To&quot;);
+
+		// ------------------------------------------------
+		// Last Panel - TB Mission
+		// ------------------------------------------------
+		CellPanel pnlDest = new CellPanel();
+		pnlDest.addLast(new mLabel(MyLocale.getMsg(6035, &quot;Mission:&quot;)));
+		pnlDest.addLast(txtMission = new HtmlDisplay(), STRETCH, FILL);
+		txtMission.rows = 3;
+		pnlTab.addCard(pnlDest, MyLocale.getMsg(6036, &quot;Mission&quot;), &quot;Mission&quot;);
+
+		lowerpane.addLast(pnlTab, STRETCH, FILL);
+
+		split.setSplitter(PanelSplitter.AFTER | PanelSplitter.HIDDEN, PanelSplitter.BEFORE | PanelSplitter.HIDDEN, 0);
+		addLast(split, STRETCH, FILL);
+
+		modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+		// Get the columns to display and their widths from preferences
+		modTbJourneyList.columnMap = TableColumnChooser.str2Array(Global.getPref().travelbugColMap, 0, 11, 0, -1);
+		modTbJourneyList.colWidth = TableColumnChooser.str2Array(Global.getPref().travelbugColWidth, 10, 1024, 50, -1);
+		modTbJourneyList.numCols = modTbJourneyList.columnMap.length;
+
+		modTbJourneyList.select(0, 12, true);
+		/* Restore the saved setting about showing only non-logged bugs */
+		if (Global.getPref().travelbugShowOnlyNonLogged) {
+			tcTbJourneyList.toggleNonLogged();
+		}
+		updateNumBugs();
+
+	}
+
+	/** Indicate the number of journeys currently displayed */
+	private void updateNumBugs() {
+		lblNumVisibleJourneys.setText(&quot;&quot; + modTbJourneyList.numRows);
+		lblNumVisibleJourneys.repaint();
+	}
+
+	/** The control which had the last focus */
+	private Control currentControl;
+
+	public void onEvent(Event ev) {
+		// Update the table from the input form
+		if ((ev instanceof MultiPanelEvent || ev instanceof ControlEvent || ev instanceof DataChangeEvent) &amp;&amp; selectedRow != -1 &amp;&amp; selectedRow &lt; model.allTravelbugJourneys.size()) {
+			TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(selectedRow);
+			if (currentControl == inpName)
+				tbj.getTb().setName(inpName.getText());
+			else if (currentControl == inpTrackingNo)
+				tbj.getTb().setTrackingNo(inpTrackingNo.getText());
+			else if (currentControl == inpFromProfile)
+				tbj.setFromProfile(inpFromProfile.getText());
+			else if (currentControl == inpFromWaypoint)
+				tbj.setFromWaypoint(inpFromWaypoint.getText());
+			else if (currentControl == inpFromDate)
+				tbj.setFromDate(inpFromDate.getText());
+			else if (currentControl == chkFromLogged)
+				tbj.setFromLogged(chkFromLogged.state);
+			else if (currentControl == inpToProfile)
+				tbj.setToProfile(inpToProfile.getText());
+			else if (currentControl == inpToWaypoint)
+				tbj.setToWaypoint(inpToWaypoint.getText());
+			else if (currentControl == inpToDate)
+				tbj.setToDate(inpToDate.getText());
+			else if (currentControl == chkToLogged)
+				tbj.setToLogged(chkToLogged.state);
+			// else if (ev.target==txtMission)
+			// tb.setMission(txtMission.getText());
+			tcTbJourneyList.repaint();
+		}
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.PRESSED &amp;&amp; selectedRow != -1) {
+			if (ev.target == inpTrackingNo) {
+				pnlTab.selectNextTab(true, true);
+				Gui.takeFocus(inpFromProfile, ControlConstants.ByKeyboard);
+				pnlTab.repaint();
+			}
+			if (ev.target == inpFromDate)
+				Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+			if (ev.target == inpToDate)
+				Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+			if (ev.target == btnFromDate || ev.target == btnToDate) {
+				mInput inpDate = ev.target == btnFromDate ? inpFromDate : inpToDate;
+				DateTimeChooser dc = new DateTimeChooser(Vm.getLocale());
+				dc.title = MyLocale.getMsg(328, &quot;Date found&quot;);
+				dc.setPreferredSize(240, 240);
+				String foundDate = inpDate.getText();
+				Time t = new Time();
+				try {
+					t.parse(foundDate, &quot;y-M-d H:m&quot;);
+				} catch (IllegalArgumentException e) {
+					try {
+						t.parse(foundDate, &quot;y-M-d&quot;);
+					} catch (IllegalArgumentException e1) {
+						// Can't parse date - should not happen
+					}
+				}
+				;
+				dc.reset(t);
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpDate.setText(Convert.toString(dc.year) + &quot;-&quot; + MyLocale.formatLong(dc.month, &quot;00&quot;) + &quot;-&quot; + MyLocale.formatLong(dc.day, &quot;00&quot;) + &quot; &quot; + dc.time);
+					if (ev.target == btnFromDate) {
+						model.allTravelbugJourneys.getTBJourney(selectedRow).setFromDate(inpDate.getText());
+						Gui.takeFocus(chkFromLogged, ControlConstants.ByKeyboard);
+					} else {
+						model.allTravelbugJourneys.getTBJourney(selectedRow).setToDate(inpDate.getText());
+						Gui.takeFocus(chkToLogged, ControlConstants.ByKeyboard);
+					}
+					tcTbJourneyList.repaint();
+				}
+			}
+		}
+		if (ev instanceof ControlEvent &amp;&amp; ev.type == ControlEvent.EXITED) {
+			pnlTab.selectNextTab(true, true);
+			if (ev.target == chkFromLogged)
+				Gui.takeFocus(inpToProfile, ControlConstants.ByKeyboard);
+			if (ev.target == chkToLogged)
+				Gui.takeFocus(txtMission, ControlConstants.ByKeyboard);
+		}
+		// The user closed the travelbugs screen
+		if (ev instanceof FormEvent &amp;&amp; ev.type == FormEvent.CLOSED &amp;&amp; chD != null) {
+			model.allTravelbugJourneys.saveTravelbugsFile();
+			model.allTravelbugJourneys.clear();
+			// Save the flag about showing non-logged journeys only
+			boolean old = Global.getPref().travelbugShowOnlyNonLogged;
+			Global.getPref().travelbugShowOnlyNonLogged = (tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked;
+			String travelbugColWidth = modTbJourneyList.getColWidths();
+			// If the preferences changed, save the pref.xml file
+			Vm.showWait(true);
+			if (!Global.getPref().travelbugColWidth.equals(travelbugColWidth) || old != Global.getPref().travelbugShowOnlyNonLogged) {
+				Global.getPref().travelbugColWidth = travelbugColWidth;
+				Global.getPref().savePreferences();
+			}
+			// If the list of travelbugs in the cache was modified, we need to
+			// save the cache too
+			if (chDmodified) {
+				ch.setHas_bugs(chD.Travelbugs.size() &gt; 0);
+				ch.save();
+			}
+			Vm.showWait(false);
+			chD = null;
+		}
+		updateNumBugs();
+		currentControl = Gui.focusedControl();
+	}
+
+	// ==============================================================
+	// tbListTableModel
+	// ==============================================================
+	class tbListTableModel extends TableModel {
+		private FontMetrics fm;
+		private Image imgRed;
+
+		tbListTableModel() {
+
+			fillToEqualHeights = true;
+			allRowsSameSize = true;
+			hasRowHeaders = false;
+			// shadeAlternateRows=true;
+			cursorSize = new Dimension(12, 1);
+			clipData = true;
+			fm = getFontMetrics();
+			// A red dot indicates that the journey has not been completely
+			// logged
+			imgRed = new Image(&quot;red.png&quot;);
+		}
+
+		private int colWidth[];
+		private int columnMap[];
+
+		public Object getCellText(int row, int col) {
+			return null;
+		}
+
+		public Object getCellData(int row, int col) {
+			if (row == -1) {
+				return TravelbugJourney.getElementNameByNumber(columnMap[col]);
+			} else {
+				int map = columnMap[col];
+				// If we have not yet logged the from or the to, a red dot is
+				// placed in front of the first item
+				if (col == 0 &amp;&amp; (!model.allTravelbugJourneys.getTBJourney(row).getFromLogged() || !model.allTravelbugJourneys.getTBJourney(row).getToLogged())) {
+					// Is it a column with a checkbox?
+					if (map != 7 &amp;&amp; map != 11)
+						return new IconAndText((IImage) imgRed, (String) model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map), fm);
+					else { // Checkbox - special treatment
+						IconAndText iat = new IconAndText(imgRed, &quot;&quot;, fm);
+						iat.addColumn(model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map));
+						return iat;
+					}
+				} else
+					return model.allTravelbugJourneys.getTBJourney(row).getElementByNumber(map);
+			}
+		}
+
+		public int calculateRowHeight(int row) {
+			return charHeight + 2;
+		}
+
+		public int calculateColWidth(int col) {
+			if (col == -1)
+				return 0;
+			else if (col &lt; numCols)
+				return colWidth[columnMap[col]];
+			else
+				return 0;
+		}
+
+		public TableCellAttributes getCellAttributes(int row, int col, boolean isSelected, TableCellAttributes ta) {
+			ta = super.getCellAttributes(row, col, isSelected, ta);
+			ta.alignment = CellConstants.LEFT;
+			ta.anchor = CellConstants.LEFT;
+			// Color the elements red, if we have not yet logged
+			if (row &gt;= 0)
+				switch (columnMap[col]) {
+				case 6: // fromDate
+					if (!model.allTravelbugJourneys.getTBJourney(row).getFromLogged())
+						ta.foreground = RED;
+					break;
+				case 10: // toDate
+					if (!model.allTravelbugJourneys.getTBJourney(row).getToLogged())
+						ta.foreground = RED;
+					break;
+				}
+			return ta;
+		}
+
+		public void showFields(TravelbugJourney tbj) {
+			inpName.setText(tbj.getTb().getName());
+			inpTrackingNo.setText(tbj.getTb().getTrackingNo());
+			lblId.setText(tbj.getTb().getGuid());
+			inpFromProfile.setText(tbj.getFromProfile());
+			inpFromWaypoint.setText(tbj.getFromWaypoint());
+			inpFromDate.setText(tbj.getFromDate());
+			chkFromLogged.setState(tbj.getFromLogged());
+			inpToProfile.setText(tbj.getToProfile());
+			inpToWaypoint.setText(tbj.getToWaypoint());
+			inpToDate.setText(tbj.getToDate());
+			chkToLogged.setState(tbj.getToLogged());
+			txtMission.setHtml(tbj.getTb().getMission());
+		}
+
+		private boolean sortAsc = false;
+		private int sortedBy = -1;
+		private int lastRow = -1;
+		public int penEventModifiers;
+
+		public boolean penPressed(Point onTable, Point cell) {
+			boolean retval = false;
+			if (cell != null &amp;&amp; cell.y == -1) { // Hit a header =&gt; sort the
+				// table accordingly
+				Vm.showWait(true);
+				if (cell.x == sortedBy)
+					sortAsc = !sortAsc;
+				else
+					sortAsc = false;
+				sortedBy = cell.x;
+				// Check whether the list only shows non-logged journeys. If so,
+				// a subset
+				// of the table must be sorted
+				if ((tcTbJourneyList.mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+					model.allTravelbugJourneys.sortFirstHalf(columnMap[cell.x], sortAsc, modTbJourneyList.numRows);
+				} else { // Showing all journeys - sort the full table
+					model.allTravelbugJourneys.sort(columnMap[cell.x], sortAsc);
+				}
+				tcTbJourneyList.repaint();
+				Vm.showWait(false);
+				retval = true;
+			} else if (cell != null &amp;&amp; cell.y &gt;= 0 &amp;&amp; (penEventModifiers &amp; IKeys.SHIFT) &gt; 0) {
+				// A range of rows can be marked by shift-click on the first and
+				// last row
+				if (lastRow != -1) { // Second row being marked with shift key
+					// pressed
+					if (lastRow &lt; cell.y)
+						toggleSelect(lastRow, cell.y);
+					else
+						toggleSelect(cell.y, lastRow);
+					lastRow = -1;
+					retval = true;
+				} else { // Remember this row as start of range, but don't
+					// toggle yet
+					lastRow = cell.y;
+				}
+			} else { // Single row marked
+				lastRow = -1;
+			}
+			return retval;
+		}
+
+		/** Select a range of rows */
+		private void toggleSelect(int fromRow, int toRow) {
+			tcTbJourneyList.clearSelection(null);
+			tcTbJourneyList.addToSelection(new Rect(0, fromRow, numCols, toRow - fromRow + 1), false, true);
+		}
+
+		/**
+		 * Return the column widths as a comma delimited string for storing in
+		 * the preferences
+		 * 
+		 * @return
+		 */
+		private String getColWidths() {
+			// Update the list with the current widths
+			for (int col = 0; col &lt; numCols; col++) {
+				colWidth[columnMap[col]] = getColWidth(col);
+			}
+			// Convert to string
+			StringBuffer sb = new StringBuffer(40);
+			for (int i = 0; i &lt; colWidth.length; i++) {
+				if (sb.length() != 0)
+					sb.append(',');
+				sb.append(colWidth[i]);
+			}
+			return sb.toString();
+		}
+	}
+
+	// ==============================================================
+	// tbListControl
+	// ==============================================================
+	class tbListControl extends TableControl {
+		private MenuItem mnuNewTB, mnuDeleteTB, mnuGetMission, mnuOpenOnline, mnuDropTB, mnuPickupTB, mnuDeleteTBs;
+		public MenuItem mnuToggleList;
+		private Menu mnuFullMenu, mnuDeleteMenu;
+		private TravelBugJourneyScreenModel tbModel;
+
+		tbListControl(TravelBugJourneyScreenModel tbModel) {
+			this.tbModel = tbModel;
+			MenuItem[] TBMenuItems = new MenuItem[10];
+			TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, &quot;Pick up TB from current cache&quot;));
+			TBMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6041, &quot;Drop TB in cache&quot;));
+			TBMenuItems[2] = new MenuItem(&quot;-&quot;);
+			TBMenuItems[3] = mnuNewTB = new MenuItem(MyLocale.getMsg(6042, &quot;New Travelbug&quot;));
+			TBMenuItems[4] = mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043, &quot;Delete Travelbug&quot;));
+			TBMenuItems[5] = new MenuItem(&quot;-&quot;);
+			TBMenuItems[6] = mnuGetMission = new MenuItem(MyLocale.getMsg(6044, &quot;Get Mission&quot;));
+			TBMenuItems[7] = mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045, &quot;Open on-line&quot;));
+			TBMenuItems[8] = new MenuItem(&quot;-&quot;);
+			TBMenuItems[9] = mnuToggleList = new MenuItem(MyLocale.getMsg(6046, &quot;Show only not logged&quot;));
+			mnuFullMenu = new Menu(TBMenuItems, &quot;&quot;);
+			// A second pop-up menu with only one entry, if a range of rows is
+			// selected
+			MenuItem[] TBMenuItemsDel = new MenuItem[1];
+			TBMenuItemsDel[0] = mnuDeleteTBs = new MenuItem(MyLocale.getMsg(6047, &quot;Delete selected Travelbugs&quot;));
+			mnuDeleteMenu = new Menu(TBMenuItemsDel, &quot;&quot;);
+			mnuDropTB.modifiers |= MenuItem.Disabled;
+			mnuDeleteTB.modifiers |= MenuItem.Disabled;
+			mnuGetMission.modifiers |= MenuItem.Disabled;
+			mnuOpenOnline.modifiers |= MenuItem.Disabled;
+		}
+
+		public void onEvent(Event ev) {
+			if (ev instanceof PenEvent) {
+				modTbJourneyList.penEventModifiers = ((PenEvent) ev).modifiers;
+			}
+
+			Rect sel = getSelection();
+			if (sel.y &lt; tbModel.allTravelbugJourneys.size()) {
+				mnuDeleteTB.modifiers &amp;= ~MenuItem.Disabled;
+				mnuGetMission.modifiers &amp;= ~MenuItem.Disabled;
+				mnuOpenOnline.modifiers &amp;= ~MenuItem.Disabled;
+				if (tbModel.allTravelbugJourneys.getTBJourney(sel.y).inMyPosession())
+					mnuDropTB.modifiers &amp;= ~MenuItem.Disabled;
+				else
+					mnuDropTB.modifiers |= MenuItem.Disabled;
+			} else {
+				mnuDeleteTB.modifiers |= MenuItem.Disabled;
+				mnuGetMission.modifiers |= MenuItem.Disabled;
+				mnuOpenOnline.modifiers |= MenuItem.Disabled;
+			}
+			// If more than one row is selected, show the limited pop-up menu
+			if (sel.height &gt; 1)
+				setMenu(mnuDeleteMenu);
+			else
+				setMenu(mnuFullMenu);
+			if (ev instanceof PenEvent)
+				modTbJourneyList.penEventModifiers = ((PenEvent) ev).modifiers;
+			super.onEvent(ev);
+		}
+
+		private Rect getSelection() {
+			Rect sel = getSelection(null);
+			return sel;
+		}
+
+		public void penRightReleased(Point p) {
+			menuState.doShowMenu(p, true, null); // direct call (not through
+			// doMenu) is neccesary
+			// because it will exclude
+			// the whole table
+		}
+
+		public void penHeld(Point p) {
+			menuState.doShowMenu(p, true, null);
+		}
+
+		public void popupMenuEvent(Object selectedItem) {
+			if (selectedItem == mnuPickupTB) {
+				Travelbug tb = TravelbugPickup.pickupTravelbug(tblSrcCache);
+				if (tb != null) {
+					chDmodified = true;
+					tbModel.allTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, waypoint);
+					modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+					tcTbJourneyList.repaint();
+				}
+			}
+			if (selectedItem == mnuDropTB) {
+				if (selectedRow &gt;= 0 &amp;&amp; selectedRow &lt; modTbJourneyList.numRows) {
+					Travelbug tb = tbModel.allTravelbugJourneys.getTBJourney(selectedRow).getTb();
+					chD.Travelbugs.add(tb);
+					tbModel.allTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, waypoint);
+					chDmodified = true;
+					ch.setHas_bugs(true);
+				}
+				repaint();
+			}
+			if (selectedItem == mnuNewTB) {
+				TravelbugJourney tbj = new TravelbugJourney(&quot;New&quot;);
+				tbj.setFromProfile(Global.getProfile().name);
+				tbj.setFromWaypoint(waypoint);
+				tbModel.allTravelbugJourneys.add(tbj);
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+				cursorTo(tbModel.allTravelbugJourneys.size() - 1, 1, true);
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuDeleteTB &amp;&amp; selectedRow &gt;= 0) {
+				tbModel.allTravelbugJourneys.remove(selectedRow);
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+				if (selectedRow &gt; 0)
+					cursorTo(selectedRow - 1, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+				tcTbJourneyList.repaint();
+			}
+			/*
+			 * Delete a group of travelbugs which have been marked with
+			 * Shift-Click
+			 */
+			if (selectedItem == mnuDeleteTBs) {
+				Rect sel = getSelection();
+				for (int i = 0; i &lt; sel.height; i++)
+					tbModel.allTravelbugJourneys.remove(sel.y);
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+				if (sel.y &lt; modTbJourneyList.numRows)
+					cursorTo(sel.y, 0, true);
+				else
+					modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+				tcTbJourneyList.repaint();
+			}
+			if (selectedItem == mnuGetMission &amp;&amp; selectedRow &gt; -1) {
+				TravelbugJourney tbj = tbModel.allTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+
+				// if we have an ID, get mission by ID
+				if (tbj.getTb().getGuid().length() != 0) {
+					tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+				} else {
+					// try to get mission and name by tracking number
+					boolean suceeded = false;
+					if (tbj.getTb().getTrackingNo().length() != 0) {
+						suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+					}
+					// if this has't worked, try to get ID by name
+					if (!suceeded) {
+						tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+						// if we have an ID now, get mission by ID
+						if (tbj.getTb().getGuid().length() != 0) {
+							tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+						}
+					}
+				}
+
+				Vm.showWait(false);
+				tcTbJourneyList.repaint();
+				txtMission.setHtml(tbj.getTb().getMission());
+				inpName.setText(tbj.getTb().getName());
+				lblId.setText(tbj.getTb().getGuid());
+				lowerpane.repaint();
+				Global.getPref().setOldGCLanguage();
+			}
+			if (selectedItem == mnuOpenOnline &amp;&amp; selectedRow &gt;= 0) {
+				TravelbugJourney tbj = tbModel.allTravelbugJourneys.getTBJourney(selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+				// First check whether ID is set, if not get it
+				if (tbj.getTb().getGuid().length() == 0)
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+				if (tbj.getTb().getGuid().length() != 0) {
+					Vm.showWait(false);
+					try {
+						String s;
+						if (tbj.getTb().getGuid().length() &gt; 10)
+							s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot; + tbj.getTb().getGuid();
+						else
+							s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot; + tbj.getTb().getGuid();
+
+						CWWrapper.exec(Global.getPref().browser, s);
+						Global.getPref().log(&quot;Executed: \&quot;&quot; + Global.getPref().browser + &quot;\&quot; \&quot;&quot; + s + &quot;\&quot;&quot;);
+					} catch (Exception ioex) {
+						Global.getPref().log(&quot;Ignored Exception&quot;, ioex, true);
+					}
+				}
+			}
+			if (selectedItem == mnuToggleList) {
+				toggleNonLogged();
+			}
+			updateNumBugs();
+			Global.getPref().setOldGCLanguage();
+		}
+
+		/**
+		 * Toggle between displaying all journeys or just those which still need
+		 * to be logged
+		 */
+		public void toggleNonLogged() {
+			mnuToggleList.modifiers ^= MenuItem.Checked;
+			if ((mnuToggleList.modifiers &amp; MenuItem.Checked) == MenuItem.Checked) {
+				// First sort the non-logged items to the top
+				tbModel.allTravelbugJourneys.sort(TravelbugJourney.BOTHLOGGED, false);
+				// modListTable.numRows=tblMyTravelbugJourneys.size();
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.countNonLogged();
+			} else {
+				modTbJourneyList.numRows = tbModel.allTravelbugJourneys.size();
+			}
+			tcTbJourneyList.repaint();
+		}
+
+		public void cursorTo(int row, int col, boolean selectNew) {
+			super.cursorTo(row, col, selectNew);
+			selectedRow = row;
+			if (row &gt;= 0) {
+				modTbJourneyList.showFields(tbModel.allTravelbugJourneys.getTBJourney(row));
+			} else {
+				modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+			}
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/ewe/TravelbugMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,177 @@
+package CacheWolf.view.ewe;
+
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugPickup;
+import CacheWolf.imp.SpiderGC;
+import CacheWolf.model.DefaultListModel;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import CacheWolf.utils.CWWrapper;
+import ewe.fx.Rect;
+import ewe.sys.Vm;
+import ewe.ui.Event;
+import ewe.ui.Menu;
+import ewe.ui.MenuBar;
+import ewe.ui.MenuEvent;
+import ewe.ui.MenuItem;
+import ewe.ui.PullDownMenu;
+
+/**
+ * Controller for the {@link TravelbugList}. Preferrably used by {@link TravelbugJourneyScreen}
+ * 
+ * @author andi
+ * 
+ */
+public class TravelbugMenu extends MenuBar {
+	private MenuItem mnuNewTB;
+	private MenuItem mnuDeleteTB;
+	private MenuItem mnuGetMission;
+	private MenuItem mnuOpenOnline;
+	private MenuItem mnuDropTB;
+	private MenuItem mnuPickupTB;
+	private MenuItem mnuDeleteTBs;
+
+	/**
+	 * The model controlled by this
+	 */
+	/**
+	 * The View displaying the model for this
+	 */
+	public TravelbugJourneyScreen view;
+	private TravelBugJourneyScreenModel model;
+
+	public TravelbugMenu(TravelBugJourneyScreenModel model) {
+		this.model = model;
+		MenuItem[] TBMenuItems = new MenuItem[9];
+		TBMenuItems[0] = mnuPickupTB = new MenuItem(MyLocale.getMsg(6040, &quot;Pick up TB from current cache&quot;));
+		TBMenuItems[1] = mnuDropTB = new MenuItem(MyLocale.getMsg(6041, &quot;Drop TB in cache&quot;));
+		TBMenuItems[2] = new MenuItem(&quot;-&quot;);
+		TBMenuItems[3] = mnuNewTB = new MenuItem(MyLocale.getMsg(6042, &quot;New Travelbug&quot;));
+		TBMenuItems[4] = mnuDeleteTB = new MenuItem(MyLocale.getMsg(6043, &quot;Delete Travelbug&quot;));
+		TBMenuItems[5] = new MenuItem(&quot;-&quot;);
+		TBMenuItems[6] = mnuGetMission = new MenuItem(MyLocale.getMsg(6044, &quot;Get Mission&quot;));
+		TBMenuItems[7] = mnuOpenOnline = new MenuItem(MyLocale.getMsg(6045, &quot;Open on-line&quot;));
+		TBMenuItems[8] = new MenuItem(&quot;-&quot;);
+		// A second pop-up menu with only one entry, if a range of rows is
+		// selected
+		MenuItem[] TBMenuItemsDel = new MenuItem[1];
+		TBMenuItemsDel[0] = mnuDeleteTBs = new MenuItem(MyLocale.getMsg(6047, &quot;Delete selected Travelbugs&quot;));
+		// mnuDropTB.modifiers |= MenuItem.Disabled;
+		// mnuDeleteTB.modifiers |= MenuItem.Disabled;
+		// mnuGetMission.modifiers |= MenuItem.Disabled;
+		// mnuOpenOnline.modifiers |= MenuItem.Disabled;
+
+		this.addMenu(new PullDownMenu(MyLocale.getMsg(120, &quot;Application&quot;), new Menu(TBMenuItems, null)));
+
+	}
+
+	public void onEvent(Event event) {
+		if (event instanceof MenuEvent) {
+			MenuEvent mev = (MenuEvent) event;
+			if (mev.selectedItem == mnuPickupTB) {
+				Travelbug tb = TravelbugPickup.pickupTravelbug(view.tblSrcCache);
+				if (tb != null) {
+					view.chDmodified = true;
+					model.allTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, view.waypoint);
+					view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+					view.repaint();
+				}
+
+			} else if (mev.selectedItem == mnuDropTB) {
+				if (view.selectedRow &gt;= 0 &amp;&amp; view.selectedRow &lt; view.modTbJourneyList.numRows) {
+					Travelbug tb = model.allTravelbugJourneys.getTBJourney(view.selectedRow).getTb();
+					view.chD.Travelbugs.add(tb);
+					model.allTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, view.waypoint);
+					view.chDmodified = true;
+					view.ch.setHas_bugs(true);
+				}
+				view.repaint();
+			} else if (mev.selectedItem == mnuNewTB) {
+				TravelbugJourney tbj = new TravelbugJourney(&quot;New&quot;);
+				tbj.setFromProfile(Global.getProfile().name);
+				tbj.setFromWaypoint(view.waypoint);
+				model.allTravelbugJourneys.add(tbj);
+				view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+				// view.cursorTo(view.tblMyTravelbugJourneys.size()-1,1,true);
+				view.repaint();
+			} else if (mev.selectedItem == mnuDeleteTB &amp;&amp; view.selectedRow &gt;= 0) {
+				model.allTravelbugJourneys.remove(view.selectedRow);
+				view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+				if (view.selectedRow &gt; 0) {
+					// cursorTo(view.selectedRow-1,0,true);
+				} else {
+					// view.modTbJourneyList.showFields(new
+					// TravelbugJourney(&quot;&quot;));
+				}
+				view.repaint();
+			}
+			/*
+			 * Delete a group of travelbugs which have been marked with
+			 * Shift-Click
+			 */
+			if (mev.selectedItem == mnuDeleteTBs) {
+				Rect sel = view.tcTbJourneyList.getSelection(null);
+				for (int i = 0; i &lt; sel.height; i++)
+					model.allTravelbugJourneys.remove(sel.y);
+				view.modTbJourneyList.numRows = model.allTravelbugJourneys.size();
+				if (sel.y &lt; view.modTbJourneyList.numRows) {
+					// cursorTo(sel.y,0,true);
+				} else {
+					view.modTbJourneyList.showFields(new TravelbugJourney(&quot;&quot;));
+				}
+				view.repaint();
+			} else if (mev.selectedItem == mnuGetMission &amp;&amp; view.selectedRow &gt; -1) {
+				TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(view.selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+
+				// if we have an ID, get mission by ID
+				if (tbj.getTb().getGuid().length() != 0) {
+					tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+				} else {
+					// try to get mission and name by tracking number
+					boolean suceeded = false;
+					if (tbj.getTb().getTrackingNo().length() != 0) {
+						suceeded = spider.getBugMissionAndNameByTrackNr(tbj.getTb());
+					}
+					// if this has't worked, try to get ID by name
+					if (!suceeded) {
+						tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName().trim()));
+						// if we have an ID now, get mission by ID
+						if (tbj.getTb().getGuid().length() != 0) {
+							tbj.getTb().setMission(spider.getBugMissionByGuid(tbj.getTb().getGuid()));
+						}
+					}
+				}
+				Global.getPref().setOldGCLanguage();
+			} else if (mev.selectedItem == mnuOpenOnline &amp;&amp; view.selectedRow &gt;= 0) {
+				TravelbugJourney tbj = model.allTravelbugJourneys.getTBJourney(view.selectedRow);
+				SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+				Vm.showWait(true);
+				// First check whether ID is set, if not get it
+				if (tbj.getTb().getGuid().length() == 0)
+					tbj.getTb().setGuid(spider.getBugId(tbj.getTb().getName()));
+				if (tbj.getTb().getGuid().length() != 0) {
+					Vm.showWait(false);
+					try {
+						String s;
+						if (tbj.getTb().getGuid().length() &gt; 10)
+							s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot; + tbj.getTb().getGuid();
+						else
+							s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot; + tbj.getTb().getGuid();
+
+						CWWrapper.exec(Global.getPref().browser, s);
+						Global.getPref().log(&quot;Executed: \&quot;&quot; + Global.getPref().browser + &quot;\&quot; \&quot;&quot; + s + &quot;\&quot;&quot;);
+					} catch (Exception ioex) {
+						Global.getPref().log(&quot;Ignored Exception&quot;, ioex, true);
+					}
+				}
+				Global.getPref().setOldGCLanguage();
+			}
+
+		}
+	}
+}


Property changes on: branches/r1.2/src/CacheWolf/view/pda
___________________________________________________________________
Added: bugtraq:number
   + true

Added: branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDADateTimeChooser.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,253 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.fx.Rect;
+import ewe.sys.Convert;
+import ewe.sys.Time;
+import ewe.ui.CellPanel;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.ui.Gui;
+import ewe.ui.Panel;
+import ewe.ui.mButton;
+import ewe.ui.mLabel;
+import ewe.util.Grid;
+
+public class PDADateTimeChooser extends Form  {
+
+	private int year; 
+	private int month; 
+	private int day; 
+
+	private int hour; 
+	public int getHour() {
+		return hour;
+	}
+
+	public int getMinute() {
+		return minute;
+	}
+
+	private int minute; 
+
+	private	mLabel lbDay;
+	private mLabel lbMonth;
+	private mLabel lbYear;
+	private mLabel lbHour;
+	private mLabel lbMinute;
+	private mLabel lbSep;
+	
+	private mButton btDayUp;
+	private mButton btMonthUp;
+	private mButton btYearUp;
+	private mButton btHourUp;
+	private mButton btMinuteUp;
+
+	private mButton btDayDown;
+	private mButton btMonthDown;
+	private mButton btYearDown;
+	private mButton btHourDown;
+	private mButton btMinuteDown;
+
+	private mButton btSet;
+	private mButton btTime;
+	private mButton btCalendar;
+	private mButton btCancel;
+
+	public PDADateTimeChooser (){
+		int screenWidth = MyLocale.getScreenWidth();
+		String string = &quot;SET TIME CANCEL&quot;;
+		int fontsize =  screenWidth/string.length();
+		Rect size = Gui.getSize(getFontMetrics(), string, 5,0);
+		while (size.width &lt; screenWidth) {
+			fontsize += 5;
+			font = new Font(getFont().getName(), Font.BOLD,fontsize);
+			size = Gui.getSize(getFontMetrics(), string, 5, 0);
+		}
+
+		backGround = Color.White;
+
+		lbDay = new mLabel(&quot;&quot;);
+		lbDay.anchor=mLabel.CENTER;
+		lbMonth = new mLabel (&quot;&quot;);
+		lbMonth.anchor=mLabel.CENTER;
+		lbYear = new mLabel (&quot;&quot;);
+		lbYear.anchor=mLabel.CENTER;
+		lbHour = new mLabel (&quot;HH&quot;);
+		lbHour.anchor=mLabel.CENTER;
+		lbSep = new mLabel(&quot;:&quot;);
+		lbMinute = new mLabel (&quot;MM&quot;);
+		lbMinute.anchor=mLabel.CENTER;
+
+		btDayUp = new mButton (&quot; ^^ &quot;);btDayUp.backGround=Color.LightBlue;
+		btMonthUp = new mButton (&quot; ^^ &quot;);btMonthUp.backGround=Color.LightBlue;
+		btYearUp = new mButton (&quot;  ^^  &quot;);btYearUp.backGround=Color.LightBlue;
+		btHourUp = new mButton (&quot;  ^^  &quot;);btHourUp.backGround=Color.LightBlue;
+		btMinuteUp = new mButton (&quot;  ^^  &quot;);btMinuteUp.backGround=Color.LightBlue;
+
+		btDayDown = new mButton (&quot;vv&quot;);btDayDown.backGround=Color.LightBlue;
+		btMonthDown = new mButton (&quot;vv&quot;);btMonthDown.backGround=Color.LightBlue;
+		btYearDown = new mButton (&quot; vv &quot;);btYearDown.backGround=Color.LightBlue;
+		btHourDown = new mButton (&quot; vv &quot;);btHourDown.backGround=Color.LightBlue;
+		btMinuteDown = new mButton (&quot; vv &quot;);btMinuteDown.backGround=Color.LightBlue;
+		
+		btSet = new mButton (&quot;Set&quot;);btSet.backGround=Color.Sand;
+		btTime = new mButton (&quot;Time&quot;);btTime.backGround=Color.Sand;
+		btCalendar  = new mButton(&quot;Cal&quot;);btCalendar.backGround=Color.Sand;
+		btCancel = new mButton (&quot;Cancel&quot;);btCancel.backGround=Color.Sand;
+
+		layoutCalendar();
+		
+		addListener(this);
+	}
+
+	
+	private void layoutCalendar() {
+		removeAll();
+		addNext (lbDay,HSTRETCH,HFILL);
+		addNext (lbMonth,HSTRETCH,HFILL);
+		addLast (lbYear,HSTRETCH,HFILL);
+
+		addNext (btDayUp,HSTRETCH,HFILL);
+		addNext (btMonthUp,HSTRETCH,HFILL);
+		addLast (btYearUp,HSTRETCH,HFILL);
+
+		addNext (btDayDown,HSTRETCH,HFILL);
+		addNext (btMonthDown,HSTRETCH,HFILL);
+		addLast (btYearDown,HSTRETCH,HFILL);
+		
+		addNext (btSet, HSTRETCH,CENTER|HFILL);
+		addNext (btTime, HSTRETCH,CENTER|HFILL);
+		addLast (btCancel, HSTRETCH,CENTER|HFILL);
+	}
+	
+	private void layoutTime() {
+		removeAll ();
+		Panel p = new CellPanel();
+		p.addNext (lbHour, HSTRETCH,HFILL);
+		p.addNext (lbSep,DONTSTRETCH,DONTFILL);
+		p.addLast (lbMinute, HSTRETCH,CENTER);
+		p.addNext (btHourUp, HSTRETCH,HFILL);
+		p.addNext(new mLabel(&quot;&quot;));
+		p.addLast (btMinuteUp, HSTRETCH,HFILL);
+		p.addNext (btHourDown, HSTRETCH,HFILL);
+		p.addNext(new mLabel(&quot;&quot;));
+		p.addLast (btMinuteDown, HSTRETCH,HFILL);
+		
+		addLast (p, HSTRETCH,HFILL);
+
+		Panel p1 = new CellPanel();
+		p1.addNext(btSet, HSTRETCH,CENTER|HFILL);
+		p1.addNext(btCalendar, HSTRETCH,CENTER|HFILL);
+		p1.addLast(btCancel, HSTRETCH,CENTER|HFILL);
+		addLast (p1, HSTRETCH,CENTER|HFILL);
+	}
+
+	public int getDay() {
+		return day;
+	}
+
+	public int getMonth() {
+		return month;
+	}
+
+	public String getTime() {
+		return Convert.toString(year) + &quot;-&quot; + MyLocale.formatLong(month, &quot;00&quot;) + &quot;-&quot;
+		+ MyLocale.formatLong(day, &quot;00&quot;) + &quot; &quot; + MyLocale.formatLong(hour, &quot;00&quot;) +
+		&quot;:&quot;+MyLocale.formatLong(minute, &quot;00&quot;);
+	}
+
+	public int getYear() {
+		return year;
+	}
+
+	public void reset(Time t) {
+		year = t.year;
+		month = t.month;
+		day = t.day;
+		hour = t.hour;
+		minute=t.minute;
+
+		lbDay.setText(Integer.toString(day));
+		lbMonth.setText(Integer.toString(month));
+		lbYear.setText(Integer.toString(year));
+		lbHour.setText(Integer.toString(hour));
+		lbMinute.setText(MyLocale.formatLong(minute, &quot;00&quot;));
+	}
+	
+	public void onControlEvent(ControlEvent ev) {
+		switch (ev.type) {
+		case ControlEvent.PRESSED:
+			if (ev.target == btDayUp &amp;&amp; day &lt; 31) {
+				day++;
+				lbDay.setText(Integer.toString(day));
+			}
+			else if (ev.target == btDayDown &amp;&amp; day &gt; 1){
+				day--;
+				lbDay.setText(Integer.toString(day));
+			}
+			
+			else if (ev.target == btMonthUp &amp;&amp; month &lt; 12){
+				month++;
+				lbMonth.setText(Integer.toString(month));
+			}
+			else if (ev.target == btMonthDown &amp;&amp; month &gt; 1){
+				month--;
+				lbMonth.setText(Integer.toString(month));
+			}
+
+			else if (ev.target == btYearUp){
+				year++;
+				lbYear.setText(Integer.toString(year));
+			}
+			else if (ev.target == btYearDown){
+				year--;
+				lbYear.setText(Integer.toString(year));
+			}
+			
+			else if (ev.target == btHourUp &amp;&amp; hour &lt; 23){
+				hour++;
+				lbHour.setText(Integer.toString(hour));
+			}
+			else if (ev.target == btHourDown &amp;&amp; hour &gt; 0){
+				hour--;
+				lbHour.setText(Integer.toString(hour));
+			}
+			else if (ev.target == btMinuteUp &amp;&amp; minute &lt; 59){
+				minute++;
+				lbMinute.setText(MyLocale.formatLong(minute, &quot;00&quot;));
+			}
+			else if (ev.target == btMinuteDown &amp;&amp; minute &gt; 0){
+				minute--;
+				lbMinute.setText(MyLocale.formatLong(minute, &quot;00&quot;));
+			}
+
+			else if (ev.target == btSet){
+				exit(IDOK);
+			}
+			else if (ev.target == btTime){
+				Gui.flashMessage(&quot;Uhrzeit anzeigen&quot;, 1000, this, 0);
+				made=false;
+				layoutTime();
+				make(true);
+				relayoutMe(true);
+				reShow(0,0,width,height);
+			}
+			else if (ev.target == btCalendar){
+				Gui.flashMessage(&quot;Calendar anzeigen!&quot;, 1000, this, 0);
+				made=false;
+				layoutCalendar();
+				make(true);
+				relayoutMe(true);
+				reShow(0,0,width,height);				
+			}
+			else if (ev.target == btCancel){
+				exit(IDNO);
+			}
+			
+		}
+		super.onControlEvent(ev);
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAEmptyButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,7 @@
+package CacheWolf.view.pda;
+
+import ewe.ui.mButton;
+
+public class PDAEmptyButton extends mButton {
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAList.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAList.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAList.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,87 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.model.DefaultListModel;
+import ewe.sys.Vm;
+import ewe.ui.CellConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.util.Vector;
+
+public abstract class PDAList extends Form {
+	protected static final String LINE = &quot;Line&quot;;
+
+	protected static final String NEXT_PAGE = &quot;NextPage&quot;;
+
+	protected static final String PREV_PAGE = &quot;PrevPage&quot;;
+
+	protected static final String MENUE = &quot;Menue&quot;;
+
+	public DefaultListModel model;
+	private int linesOnScreen=7;
+	PDAListButton[] listButtons;
+	protected int firstLine;
+
+	public PDAList() {
+		listButtons = new PDAListButton[linesOnScreen];
+		//Show Full Screen
+		setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
+		addListener(this);
+		setTitle(&quot;Liste&quot;);
+
+		firstLine = 0;
+		for (int i = 0; i &lt; linesOnScreen; i++) {
+			listButtons[i] = new PDAListButton(&quot;&quot;, LINE + i);
+			addLast(listButtons[i], CellConstants.STRETCH, CellConstants.FILL);
+		}
+		setupTBButtons();
+		PDAMenuButton b1 = new PDAMenuButton(&quot;&lt;&lt;&lt;&quot;, PREV_PAGE);
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(MyLocale.getMsg(6052, &quot;MENU&quot;), MENUE);
+		b1.anchor = 0;
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(&quot;&gt;&gt;&gt;&quot;, NEXT_PAGE);
+		b1.anchor = CellConstants.EAST;
+		addLast(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+	}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) &amp;&amp; model.size() &gt; firstLine + linesOnScreen) {
+					firstLine += linesOnScreen;
+					setupTBButtons();
+				} else if (ev.action.equals(PREV_PAGE) &amp;&amp; firstLine &gt; 0) {
+					firstLine -= linesOnScreen;
+					if (firstLine &lt; 0) {
+						firstLine = 0;
+					}
+					setupTBButtons();
+				} else if (ev.action.startsWith(LINE)) {
+					int line = ev.action.charAt(LINE.length()) - '0';
+					Object clickedItem =  model.get(line + firstLine);
+					Vm.debug(&quot;List clicked: &quot; + clickedItem);
+				} else if (ev.action.equals(MENUE)) {
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public void setupTBButtons() {
+		for (int i = 0; i &lt; linesOnScreen; i++) {
+			if (model != null &amp;&amp; i + firstLine &lt; model.size()) {
+				Object modelElement = model.get(i + firstLine);
+				listButtons[i].text = modelElement.toString();
+			} else {
+				listButtons[i].text = listButtons[i].fromText = listButtons[i].toText = &quot;&quot;;
+			}
+			listButtons[i].repaint();
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAListButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,34 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.ui.CellConstants;
+import ewe.ui.mButton;
+
+public class PDAListButton extends mButton {
+
+	public String fromText;
+	public String toText;
+	public boolean toLogged;
+	public boolean fromLogged;
+	
+	public PDAListButton(String newText, String newAction) {
+		super(newText);
+		action = newAction;
+		buttonObject = new PDAListButtonObject(this);
+
+		backGround = Color.White;
+		foreGround = Color.Black;
+
+		font = new Font(getFont().getName(), Font.BOLD, 40);
+		anchor = CellConstants.WEST;
+		textPosition=2;
+	}
+
+	public void make(boolean paramBoolean) {
+		if (this.buttonObject != null)
+			return;
+		this.buttonObject = new PDAListButtonObject(this);
+	}
+	
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAListButtonObject.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,58 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.fx.Graphics;
+import ewe.fx.Rect;
+import ewe.ui.ButtonObject;
+
+public class PDAListButtonObject extends ButtonObject {
+	private PDAListButton pdaListButton;
+
+	public PDAListButtonObject(PDAListButton pdaListButton) {
+		super(pdaListButton);
+		this.pdaListButton = pdaListButton;
+	}
+
+	public void paint(Graphics paramGraphics) {
+		if ((this.soft) &amp;&amp; (this.control != null))
+			this.control.doBackground(paramGraphics);
+		if (this.text == null)
+			this.text = &quot;&quot;;
+		drawButton(paramGraphics);
+		Rect localRect1 = paramGraphics.reduceClip(new Rect(this.borderWidth, this.borderWidth, this.size.width
+				- (this.borderWidth * 2), this.size.height - (this.borderWidth * 2)));
+		try {
+			paramGraphics.setColor(foreground);
+			int x = 10;
+			if (this.image != null) {
+				int y = (size.height - image.getHeight()) / 2;
+				this.image.draw(paramGraphics, 10, y, 0);
+				x += image.getWidth();
+				x += 10;
+			}
+			paramGraphics.setFont(this.font);
+			paramGraphics.drawText(text, x, 10);
+			Font tmpFont = new Font(font.getName(), Font.BOLD, 20);
+			paramGraphics.setFont(tmpFont);
+			if (pdaListButton.fromText != null) {
+				paramGraphics.drawText(pdaListButton.fromText, x + 15, 45);
+			}
+			if (!pdaListButton.fromLogged) {
+				paramGraphics.setColor(new Color(255, 0, 0));
+				paramGraphics.fillEllipse(x, 50, 10, 10);
+				paramGraphics.setColor(foreground);
+			}
+			if (pdaListButton.toText != null) {
+				paramGraphics.drawText(pdaListButton.toText, x + 15, 70);
+			}
+			if (!pdaListButton.toLogged) {
+				paramGraphics.setColor(new Color(255, 0, 0));
+				paramGraphics.fillEllipse(x, 75, 10, 10);
+				paramGraphics.setColor(foreground);
+			}
+		} finally {
+			paramGraphics.restoreClip(localRect1);
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,40 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+
+public abstract class PDAMenu extends Form {
+
+	protected static final String CANCEL = &quot;__Cancel_Exit__&quot;;
+
+	public abstract void actionPerformed(String actionCommand);
+
+	public PDAMenu(){
+		setPreferredSize(MyLocale.getScreenWidth(), MyLocale.getScreenHeight());
+	}
+	
+	public void onControlEvent(ControlEvent paramEvent) {
+		switch (paramEvent.type) {
+		case ControlEvent.PRESSED:
+			if (paramEvent.action.equals(CANCEL)) {
+				exit(0);
+				
+			} else {
+				actionPerformed(paramEvent.action);
+			}
+		}
+		super.onControlEvent(paramEvent);
+	}
+
+	protected void buildMenu() {
+		PDAMenuButton button = new PDAMenuButton(MyLocale.getMsg(6057, &quot;Back&quot;), CANCEL);
+		addLast(button);
+	}
+
+	protected void addMenuItem(String item, String actionCommand) {
+		PDAMenuButton button = new PDAMenuButton(item, actionCommand);
+		addLast(button);
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAMenuButton.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,35 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.ui.CellConstants;
+import ewe.ui.mButton;
+
+public class PDAMenuButton extends mButton {
+
+	public String fromText;
+	public String toText;
+	public boolean toLogged;
+	public boolean fromLogged;
+
+	public PDAMenuButton(String newText, String newAction) {
+		super(newText);
+		action = newAction;
+
+		minHeight = 200;
+		preferredHeight=200;
+		maxHeight=200;
+		backGround = Color.Sand;
+		foreGround = Color.Black;
+
+		font = new Font(getFont().getName(), Font.BOLD, 40);
+		anchor = CellConstants.WEST;
+		textPosition = 2;
+	}
+	
+	public void make(boolean paramBoolean) {
+		if (this.buttonObject != null)
+			return;
+		this.buttonObject = new PDAMenuButtonObject(this);
+	}
+}
\ No newline at end of file

Added: branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAMenuButtonObject.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,24 @@
+package CacheWolf.view.pda;
+
+import ewe.fx.Dimension;
+import ewe.ui.ButtonObject;
+
+public class PDAMenuButtonObject extends ButtonObject{
+	private PDAMenuButton pdaMenuButton;
+	private Dimension calculateSize;
+
+	public PDAMenuButtonObject(PDAMenuButton pdaListButton) {
+		super(pdaListButton);
+		this.pdaMenuButton = pdaListButton;
+	}
+
+	  public Dimension calculateSize(Dimension paramDimension){
+		  calculateSize = super.calculateSize(paramDimension);
+		  if (calculateSize.height &lt; 100){
+			  calculateSize.height=100;
+			  paramDimension.height=100;
+		  }
+		  return calculateSize;
+	  }
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDAOptionPane.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,49 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.Preferences;
+import ewe.fx.Color;
+import ewe.fx.Font;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.ui.Frame;
+import ewe.ui.Gui;
+import ewe.ui.mLabel;
+
+public class PDAOptionPane extends Form {
+	public static final int CANCEL = 0;
+	public static final int OK = 1;
+	private static final String OK_STR = &quot;OK&quot;;
+	private static final String CANCEL_STR = &quot;CANCEL&quot;;
+
+	private int result = CANCEL;
+
+	public static int showConfirmDialog(Frame parent, String title, String message) {
+		PDAOptionPane pane = new PDAOptionPane();
+		pane.title = title;
+		pane.backGround=new Color(255,128,128);
+		Font tmpFont = new Font(&quot;Helvetica&quot;, Font.BOLD, Preferences.getPrefObject().fontSize * 2);
+		mLabel messageLabel = new mLabel(message);
+		messageLabel.font=tmpFont;
+		pane.addLast(messageLabel, HFILL, HSTRETCH);
+		PDAMenuButton button = new PDAMenuButton(&quot;OK&quot;, OK_STR);
+		pane.addNext(button, FILL, STRETCH);
+		button = new PDAMenuButton(&quot;Abbruch&quot;, CANCEL_STR);
+		pane.addLast(button, FILL, STRETCH);
+		pane.setLocation(0, 0);
+		pane.execute(null, Gui.FILL_FRAME);
+		return pane.result;
+	}
+
+	public void onControlEvent(ControlEvent event) {
+		switch (event.type) {
+		case ControlEvent.PRESSED:
+			String action = event.action;
+			if (action.equals(OK_STR)) {
+				result = OK;
+				exit(0);
+			} else if (action.equals(CANCEL_STR)) {
+				exit(0);
+			}
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,188 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.imp.SpiderGC;
+import CacheWolf.utils.CWWrapper;
+import ewe.sys.Vm;
+
+public class PDATravelbugDetailMenu extends PDAMenu {
+
+	private static final String BROWSER = &quot;browser&quot;;
+
+	private static final String SPIDER = &quot;spider&quot;;
+
+	private static final String DELETE = &quot;delete&quot;;
+
+	private static final String EXIT = &quot;exit&quot;;
+
+	private static final String DROP = &quot;drop&quot;;
+
+	private PDATravelbugDetailPanel view;
+
+	private PDATravelbugJourneyScreen journeyScreen;
+
+	public PDATravelbugDetailMenu(PDATravelbugDetailPanel view, PDATravelbugJourneyScreen journeyScreen) {
+		this.view = view;
+		this.journeyScreen = journeyScreen;
+
+		setTitle(&quot;TravelBugDetail - Menu&quot;);
+
+		addMenuItem(MyLocale.getMsg(6041, &quot;Drop TB in cache&quot;), DROP);
+		addMenuItem(MyLocale.getMsg(6044, &quot;Get mission (and name)&quot;), SPIDER);
+		addMenuItem(MyLocale.getMsg(6045, &quot;Open on-line&quot;), BROWSER);
+		addMenuItem(MyLocale.getMsg(6043, &quot;Delete Travelbug&quot;), DELETE);
+		addMenuItem(MyLocale.getMsg(6061, &quot;Close&quot;), EXIT);
+
+		buildMenu();
+
+	}
+
+	public void actionPerformed(String action) {
+		if (action.equals(DROP)) {
+			Travelbug tb = view.getTravelbug().getTb();
+			int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+			CacheDB cacheDB = Global.getProfile().cacheDB;
+			if (curCacheNo &gt;= 0 &amp;&amp; curCacheNo &lt; cacheDB.size()) {
+				CacheHolder ch = cacheDB.get(curCacheNo);
+				CacheHolderDetail cacheDetails = ch.getCacheDetails(true);
+				cacheDetails.Travelbugs.add(tb);
+				journeyScreen.model.allTravelbugJourneys.addTbDrop(tb, Global.getProfile().name, ch.getWayPoint());
+				ch.setHas_bugs(true);
+				ch.save();
+				// Set Input fields to the new Values:
+				view.getInpToWaypoint().setText(view.getTravelbug().getToWaypoint());
+				view.getInpToProfile().setText(view.getTravelbug().getToProfile());
+				view.getInpToDate().setText(view.getTravelbug().getToDate());
+				// Save now. The action won't recognize the changes:
+				journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+			}
+			journeyScreen.setupTBButtons();
+			exit(0);
+		} else if (action.equals(BROWSER)) {
+			SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+			Vm.showWait(true);
+			// First check whether ID is set, if not get it
+			Travelbug tb = view.getTravelbug().getTb();
+			if (tb.getGuid().length() == 0) {
+				tb.setGuid(spider.getBugId(tb.getName()));
+			}
+			if (tb.getGuid().length() != 0) {
+				Vm.showWait(false);
+				try {
+					String s;
+					if (tb.getGuid().length() &gt; 10)
+						s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?guid=">http://www.geocaching.com/track/details.aspx?guid=</A>&quot; + tb.getGuid();
+					else
+						s = &quot;<A HREF="http://www.geocaching.com/track/details.aspx?id=">http://www.geocaching.com/track/details.aspx?id=</A>&quot; + tb.getGuid();
+
+					CWWrapper.exec(Global.getPref().browser, s);
+					Global.getPref().log(&quot;Executed: \&quot;&quot; + Global.getPref().browser + &quot;\&quot; \&quot;&quot; + s + &quot;\&quot;&quot;);
+				} catch (Exception ioex) {
+					Global.getPref().log(&quot;Ignored Exception&quot;, ioex, true);
+				}
+			}
+			Global.getPref().setOldGCLanguage();
+			exit(0);
+		} else if (action.equals(SPIDER)) {
+			Travelbug tb = view.getTravelbug().getTb();
+			SpiderGC spider = new SpiderGC(Global.getPref(), Global.getProfile());
+			Vm.showWait(true);
+
+			// if we have an ID, get mission by ID
+			if (tb.getGuid().length() != 0) {
+				tb.setMission(spider.getBugMissionByGuid(tb.getGuid()));
+			} else {
+				// try to get mission and name by tracking number
+				boolean suceeded = false;
+				if (tb.getTrackingNo().length() != 0) {
+					suceeded = spider.getBugMissionAndNameByTrackNr(tb);
+				}
+				// if this has't worked, try to get ID by name
+				if (!suceeded) {
+					tb.setGuid(spider.getBugId(tb.getName().trim()));
+					// if we have an ID now, get mission by ID
+					if (tb.getGuid().length() != 0) {
+						tb.setMission(spider.getBugMissionByGuid(tb.getGuid()));
+					}
+				}
+			}
+			journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+			Vm.showWait(false);
+			Global.getPref().setOldGCLanguage();
+			exit(0);
+		} else if (action.equals(DELETE)) {
+			// LOESCHEN DES TB's aus der Datenbank ist Boese!!!
+			// Erst mal eine Sicherheitesabfrage bauen:
+			int r = PDAOptionPane.showConfirmDialog(this.getFrame(), &quot;Sind Sie Sicher???&quot;, &quot;Wollen Sie wirklich den TB l&#246;schen??&quot;);
+			if (r == PDAOptionPane.OK) {
+				for (int i = 0; i &lt; journeyScreen.model.allTravelbugJourneys.size(); i++) {
+					TravelbugJourney tbJourney = journeyScreen.model.allTravelbugJourneys.getTBJourney(i);
+					if (tbJourney.getTb().getTrackingNo().equals(view.getTravelbug().getTb().getTrackingNo())) {
+						journeyScreen.model.allTravelbugJourneys.remove(i);
+						journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+						journeyScreen.setupTBButtons();
+						break;
+					}
+				}
+			}
+		} else if (action.equals(EXIT)) {
+			boolean changed = false;
+			if (!view.getInpName().text.equals(view.getTravelbug().getTb().getName())) {
+				view.getTravelbug().getTb().setName(view.getInpName().text);
+				changed = true;
+			}
+			if (!view.getInpTrackingNo().text.equals(view.getTravelbug().getTb().getTrackingNo())) {
+				view.getTravelbug().getTb().setTrackingNo(view.getInpTrackingNo().text);
+				changed = true;
+			}
+
+			if (!view.getInpFromProfile().text.equals(view.getTravelbug().getFromProfile())) {
+				view.getTravelbug().setFromProfile(view.getInpFromProfile().text);
+				changed = true;
+			}
+			if (!view.getInpFromWaypoint().text.equals(view.getTravelbug().getFromWaypoint())) {
+				view.getTravelbug().setFromWaypoint(view.getInpFromWaypoint().text);
+				changed = true;
+			}
+			if (!view.getInpFromDate().text.equals(view.getTravelbug().getFromDate())) {
+				view.getTravelbug().setFromDate(view.getInpFromDate().text);
+				changed = true;
+			}
+			if (view.getTravelbug().getFromLogged() != view.getChkFromLogged().state) {
+				view.getTravelbug().setFromLogged(view.getChkFromLogged().state);
+				changed = true;
+			}
+
+			if (!view.getInpToProfile().text.equals(view.getTravelbug().getToProfile())) {
+				view.getTravelbug().setToProfile(view.getInpToProfile().text);
+				changed = true;
+			}
+			if (!view.getInpToWaypoint().text.equals(view.getTravelbug().getToWaypoint())) {
+				view.getTravelbug().setToWaypoint(view.getInpToWaypoint().text);
+				changed = true;
+			}
+			if (!view.getInpToDate().text.equals(view.getTravelbug().getToDate())) {
+				view.getTravelbug().setToDate(view.getInpToDate().text);
+				changed = true;
+			}
+			if (view.getTravelbug().getToLogged() != view.getChkToLogged().state) {
+				view.getTravelbug().setToLogged(view.getChkToLogged().state);
+				changed = true;
+			}
+
+			if (changed) {
+				journeyScreen.model.allTravelbugJourneys.saveTravelbugsFile();
+				journeyScreen.createShowSet();
+			}
+
+			exit(1);
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugDetailPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,295 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.Preferences;
+import CacheWolf.TravelbugJourney;
+import ewe.fx.Color;
+import ewe.fx.Dimension;
+import ewe.fx.Font;
+import ewe.fx.mImage;
+import ewe.sys.Convert;
+import ewe.sys.Time;
+import ewe.sys.Vm;
+import ewe.ui.CardPanel;
+import ewe.ui.CellConstants;
+import ewe.ui.CellPanel;
+import ewe.ui.ControlConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+import ewe.ui.Gui;
+import ewe.ui.HtmlDisplay;
+import ewe.ui.SipButton;
+import ewe.ui.WindowConstants;
+import ewe.ui.mButton;
+import ewe.ui.mCheckBox;
+import ewe.ui.mInput;
+import ewe.ui.mLabel;
+
+public class PDATravelbugDetailPanel extends Form {
+
+	private static final int BOXWIDTH = 40;
+
+	private static final String MENUE = &quot;MENUE&quot;;
+
+	private static final String BACK = &quot;back&quot;;
+
+	private static final String FORWARD = &quot;Vor&quot;;
+
+	private static final String FROM_DATE = &quot;from_date&quot;;
+
+	private static final String TO_DATE = &quot;to_date&quot;;
+
+	private TravelbugJourney travelbug;
+
+	public TravelbugJourney getTravelbug() {
+		return travelbug;
+	}
+
+	private CardPanel pnlTab;
+
+	private mInput inpName;
+
+	public mInput getInpName() {
+		return inpName;
+	}
+
+	private mInput inpTrackingNo;
+
+	public mInput getInpTrackingNo() {
+		return inpTrackingNo;
+	}
+
+	private mLabel lblId;
+
+	private mInput inpFromProfile;
+
+	public mInput getInpFromProfile() {
+		return inpFromProfile;
+	}
+
+	private mInput inpFromWaypoint;
+
+	public mInput getInpFromWaypoint() {
+		return inpFromWaypoint;
+	}
+
+	private mInput inpFromDate;
+
+	public mInput getInpFromDate() {
+		return inpFromDate;
+	}
+
+	private mButton btnFromDate;
+
+	private mCheckBox chkFromLogged;
+
+	public mCheckBox getChkFromLogged() {
+		return chkFromLogged;
+	}
+
+	private mInput inpToProfile;
+
+	public mInput getInpToProfile() {
+		return inpToProfile;
+	}
+
+	private mInput inpToWaypoint;
+
+	public mInput getInpToWaypoint() {
+		return inpToWaypoint;
+	}
+
+	private mInput inpToDate;
+
+	public mInput getInpToDate() {
+		return inpToDate;
+	}
+
+	private mButton btnToDate;
+
+	private mCheckBox chkToLogged;
+
+	public mCheckBox getChkToLogged() {
+		return chkToLogged;
+	}
+
+	private HtmlDisplay txtMission;
+
+	private PDATravelbugJourneyScreen view;
+
+	public PDATravelbugDetailPanel(TravelbugJourney tbJourney, PDATravelbugJourneyScreen view) {
+		SipButton.sipButtonSize = new Dimension(35, 40);
+		Vm.setSIP(Vm.SIP_LEAVE_BUTTON);
+		this.windowFlagsToSet = WindowConstants.FLAG_SHOW_SIP_BUTTON;
+		travelbug = tbJourney;
+		this.view = view;
+		setTitle(tbJourney.getTb().getName());
+
+		pnlTab = new CardPanel();
+		addLast(pnlTab);
+
+		// ------------------------------------------------
+		// First Tab - Name &amp; Tracking #
+		// ------------------------------------------------
+		CellPanel pnlName = new CellPanel();
+		CellPanel panel = new CellPanel();
+		panel.backGround = Color.White;
+		panel.addNext(new mLabel(MyLocale.getMsg(6025, &quot;Name:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		inpName = new mInput(tbJourney.getTb().getName());
+		inpName.backGround = Color.White;
+		inpName.borderStyle = BDR_OUTLINE | BF_LEFT | BF_TOP | BF_RIGHT | BF_SQUARE;
+		panel.addLast(inpName, HSTRETCH, HFILL);
+		panel.addNext(new mLabel(MyLocale.getMsg(6026, &quot;Tracking #:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		inpTrackingNo = new mInput(tbJourney.getTb().getTrackingNo());
+		inpTrackingNo.backGround = Color.White;
+		inpTrackingNo.borderStyle = BDR_OUTLINE | BF_LEFT | BF_TOP | BF_RIGHT | BF_SQUARE;
+		panel.addLast(inpTrackingNo, HSTRETCH, HFILL);
+		panel.addNext(new mLabel(MyLocale.getMsg(6027, &quot;ID/GUID:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		lblId = new mLabel(tbJourney.getTb().getGuid());
+		lblId.backGround = Color.White;
+		lblId.borderStyle = BDR_OUTLINE | BF_LEFT | BF_TOP | BF_RIGHT | BF_SQUARE;
+		panel.addLast(lblId, HSTRETCH, HFILL);
+		pnlName.addLast(panel, STRETCH, FILL);
+		// VON-Tab
+		mLabel label = new mLabel(MyLocale.getMsg(6058, &quot;Retrieved:&quot;));
+		Font tmpFont = new Font(&quot;Helvetica&quot;, Font.BOLD, Preferences.getPrefObject().fontSize * 2);
+		label.font = tmpFont;
+		panel.addLast(label, DONTSTRETCH, DONTFILL | WEST);
+		panel.addNext(new mLabel(MyLocale.getMsg(6029, &quot;Profile/Cache:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		inpFromProfile = new mInput(tbJourney.getFromProfile());
+		panel.addNext(inpFromProfile, HSTRETCH, HFILL);
+		inpFromWaypoint = new mInput(tbJourney.getFromWaypoint());
+		panel.addLast(inpFromWaypoint, HSTRETCH, HFILL);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6059, &quot;Date:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		inpFromDate = new mInput(tbJourney.getFromDate());
+		panel.addNext(inpFromDate, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		btnFromDate = new mButton(new mImage(&quot;calendar.png&quot;));
+		btnFromDate.action = FROM_DATE;
+		panel.addLast(btnFromDate, DONTSTRETCH, HFILL | WEST);
+		btnFromDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6031, &quot;Logged:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged = new mCheckBox(&quot;&quot;);
+		chkFromLogged.boxWidth = BOXWIDTH;
+		chkFromLogged.font = tmpFont;
+		chkFromLogged.setState(tbJourney.getFromLogged());
+		panel.addLast(chkFromLogged, DONTSTRETCH, DONTFILL | WEST);
+		chkFromLogged.exitKeys = exitKeys;
+		// To-Tab
+		label = new mLabel(MyLocale.getMsg(6060, &quot;Dropped off:&quot;));
+		label.font = tmpFont;
+		panel.addLast(label, DONTSTRETCH, DONTFILL | WEST);
+		panel.addNext(new mLabel(MyLocale.getMsg(6029, &quot;Profile/Cache:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		inpToProfile = new mInput(tbJourney.getToProfile());
+		panel.addNext(inpToProfile, HSTRETCH, HFILL);
+		inpToWaypoint = new mInput(tbJourney.getToWaypoint());
+		panel.addLast(inpToWaypoint, HSTRETCH, HFILL);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6059, &quot;Date:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		inpToDate = new mInput(tbJourney.getToDate());
+		panel.addNext(inpToDate, CellConstants.HSTRETCH, (CellConstants.HFILL | CellConstants.WEST));
+		btnToDate = new mButton(new mImage(&quot;calendar.png&quot;));
+		btnToDate.action = TO_DATE;
+		panel.addLast(btnToDate, DONTSTRETCH, HFILL | WEST);
+		btnToDate.modify(0, ControlConstants.TakesKeyFocus);
+
+		panel.addNext(new mLabel(MyLocale.getMsg(6031, &quot;Logged:&quot;)), DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged = new mCheckBox(&quot;&quot;);
+		chkToLogged.boxWidth = BOXWIDTH;
+		chkToLogged.setState(tbJourney.getToLogged());
+		panel.addLast(chkToLogged, DONTSTRETCH, DONTFILL | WEST);
+		chkToLogged.exitKeys = exitKeys;
+
+		panel = new CellPanel();
+		PDAMenuButton pdaListButton = new PDAMenuButton(&quot;&lt;&lt;&lt;&quot;, BACK);
+		pdaListButton.change(ControlConstants.Disabled, 0);
+		panel.addNext(pdaListButton, HSTRETCH, HFILL);
+		panel.addNext(new PDAMenuButton(MyLocale.getMsg(6052, &quot;MENU&quot;), MENUE));
+		panel.addLast(new PDAMenuButton(&quot;&gt;&gt;&gt;&quot;, FORWARD), HSTRETCH, HFILL);
+		pnlName.addLast(panel, HSTRETCH, HFILL);
+
+		pnlTab.addItem(pnlName, MyLocale.getMsg(6028, &quot;Name&quot;), &quot;Name&quot;);
+
+		// ------------------------------------------------
+		// Last Panel - TB Mission
+		// ------------------------------------------------
+		CellPanel pnlDest = new CellPanel();
+		label = new mLabel(MyLocale.getMsg(6035, &quot;Mission:&quot;));
+		tmpFont = new Font(&quot;Helvetica&quot;, Font.BOLD, Preferences.getPrefObject().fontSize * 2);
+		label.setFont(tmpFont);
+		pnlDest.addLast(label, DONTSTRETCH, DONTFILL);
+		txtMission = new HtmlDisplay();
+		txtMission.setHtml(tbJourney.getTb().getMission());
+		pnlDest.addLast(txtMission, STRETCH, FILL);
+		txtMission.rows = 3;
+
+		panel = new CellPanel();
+		panel.addNext(new PDAMenuButton(&quot;&lt;&lt;&lt;&quot;, BACK), HSTRETCH, HFILL);
+		panel.addNext(new PDAMenuButton(MyLocale.getMsg(6052, &quot;MENU&quot;), MENUE));
+		pdaListButton = new PDAMenuButton(&quot;&gt;&gt;&gt;&quot;, &quot;&quot;);
+		pdaListButton.change(ControlConstants.Disabled, 0);
+		panel.addLast(pdaListButton, HSTRETCH, HFILL);
+		panel.backGround = new Color(250, 0, 0);
+		pnlDest.addLast(panel, DONTSTRETCH, FILL);
+		pnlTab.addItem(pnlDest, MyLocale.getMsg(6036, &quot;Mission&quot;), &quot;Mission&quot;);
+		SipButton.placeIn(this);
+		Gui.takeFocus(null, ControlConstants.ByKeyboard);
+	}
+
+	public void onControlEvent(ControlEvent paramEvent) {
+		switch (paramEvent.type) {
+		case ControlEvent.PRESSED:
+			String action = paramEvent.action;
+			if (action.equals(FORWARD)) {
+				pnlTab.select(pnlTab.getSelectedItem()+1);
+			} else if (action.equals(BACK)) {
+				pnlTab.select(pnlTab.getSelectedItem()-1);
+//				pnlTab.selectNextTab(false, true);
+			} else if (action.equals(MENUE)) {
+				PDATravelbugDetailMenu detailMenu = new PDATravelbugDetailMenu(this, view);
+				int execute = detailMenu.execute();
+				if (execute == 1){
+					exit(0);
+				}				
+			} else if (action.equals(FROM_DATE) || action.equals(TO_DATE)) {
+				mInput inpDate = action.equals(FROM_DATE) ? inpFromDate : inpToDate;
+				PDADateTimeChooser dc = new PDADateTimeChooser();
+				dc.setTitle(MyLocale.getMsg(328, &quot;Date found&quot;));
+				dc.setLocation(0, 0);
+//				dc.setPreferredSize(240, 240);
+				String foundDate = inpDate.getText();
+				Time t = new Time();
+				try {
+					t.parse(foundDate, &quot;y-M-d H:m&quot;);
+				} catch (IllegalArgumentException e) {
+					try {
+						t.parse(foundDate, &quot;y-M-d&quot;);
+					} catch (IllegalArgumentException e1) {
+						// Can't parse date - should not happen
+					}
+				}
+				dc.reset(t);
+				if (dc.execute() == ewe.ui.FormBase.IDOK) {
+					inpDate.setText(Convert.toString(dc.getYear ()) + &quot;-&quot; + MyLocale.formatLong(dc.getMonth (), &quot;00&quot;) + &quot;-&quot;
+							+ MyLocale.formatLong(dc.getDay(), &quot;00&quot;) + &quot; &quot; + dc.getTime() + &quot; &quot; + MyLocale.formatLong(dc.getHour(), &quot;00&quot;) +
+							&quot;:&quot;+MyLocale.formatLong(dc.getMinute(), &quot;00&quot;));
+				}
+			}
+		}
+	}
+
+	public void focusFirst(int paramInt) {
+		super.focusFirst(paramInt);
+		// Erst mal den Focus so setzen, dass die Tastatur nicht aufgeklappt
+		// wird.
+		// Wenn der TB noch nicht abgelegt wurde, dann den Focus auf den Button
+		// zum ablegen, sonst immer auf die Aufnahme
+		if (travelbug.getToDate().length() == 0 &amp;&amp; travelbug.getFromDate().length() &gt; 0) {
+			Gui.takeFocus(btnToDate, paramInt);
+
+		} else {
+			Gui.takeFocus(btnFromDate, paramInt);
+		}
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugJourneyScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,134 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.model.TravelBugJourneyScreenModel;
+import ewe.graphics.AniImage;
+import ewe.sys.Vm;
+import ewe.ui.CellConstants;
+import ewe.ui.ControlConstants;
+import ewe.ui.ControlEvent;
+import ewe.ui.Form;
+
+public class PDATravelbugJourneyScreen extends Form {
+	private static final String LINE = &quot;Line&quot;;
+
+	private static final String NEXT_PAGE = &quot;NextPage&quot;;
+
+	private static final String PREV_PAGE = &quot;PrevPage&quot;;
+
+	private static final String MENUE = &quot;Menue&quot;;
+
+	PDAListButton[] listButtons;
+
+	TravelBugJourneyScreenModel model;
+
+	/**
+	 * The index of the first item in the list shown
+	 */
+	private int firstLine;
+
+	private final int linesOnScreen = 7;
+
+	/**
+	 * The six visible entries in the List
+	 */
+
+	public PDATravelbugJourneyScreen(TravelBugJourneyScreenModel travelbugModel) {
+		listButtons = new PDAListButton[linesOnScreen];
+		addListener(this);
+		setTitle(&quot;TravelBugs&quot;);
+
+		model = travelbugModel;
+
+		// backgroundImage = new Image(&quot;bug_vga.gif&quot;);
+		for (int i = 0; i &lt; model.allTravelbugJourneys.size(); i++) {
+			model.shownTravelbugJourneys.add(model.allTravelbugJourneys.getTBJourney(i));
+		}
+
+		firstLine = 0;
+		for (int i = 0; i &lt; linesOnScreen; i++) {
+			listButtons[i] = new PDAListButton(&quot;&quot;, LINE + i);
+			addLast(listButtons[i], CellConstants.STRETCH, CellConstants.FILL);
+		}
+		model.createShowSet();
+		setupTBButtons();
+		PDAMenuButton b1 = new PDAMenuButton(&quot;&lt;&lt;&lt;&quot;, PREV_PAGE);
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(MyLocale.getMsg(6052, &quot;MENU&quot;), MENUE);
+		b1.anchor = 0;
+		addNext(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+		b1 = new PDAMenuButton(&quot;&gt;&gt;&gt;&quot;, NEXT_PAGE);
+		b1.anchor = CellConstants.EAST;
+		addLast(b1, CellConstants.HSTRETCH, CellConstants.HFILL);
+	}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) &amp;&amp; model.shownTravelbugJourneys.size() &gt; firstLine + linesOnScreen) {
+					firstLine += linesOnScreen;
+					setupTBButtons();
+				} else if (ev.action.equals(PREV_PAGE) &amp;&amp; firstLine &gt; 0) {
+					firstLine -= linesOnScreen;
+					if (firstLine &lt; 0) {
+						firstLine = 0;
+					}
+					setupTBButtons();
+				} else if (ev.action.startsWith(LINE)) {
+					int line = ev.action.charAt(LINE.length()) - '0';
+					TravelbugJourney tbJourney = (TravelbugJourney) model.shownTravelbugJourneys.get(line + firstLine);
+					Form form = new PDATravelbugDetailPanel(tbJourney, this);
+					form.setPreferredSize(800, 600);
+					form.execute();
+					setupTBButtons();
+				} else if (ev.action.equals(MENUE)) {
+					Form form = new PDATravelbugMenuPanel(this);
+					form.setPreferredSize(800, 600);
+					int execute = form.execute();
+					if (execute == 1){
+						exit(0);
+					}
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public void setupTBButtons() {
+		for (int i = 0; i &lt; linesOnScreen; i++) {
+			if (i + firstLine &lt; model.shownTravelbugJourneys.size()) {
+				TravelbugJourney tbJourney = (TravelbugJourney) model.shownTravelbugJourneys.get(i + firstLine);
+				String tbName = tbJourney.getTb().getName();
+				listButtons[i].text = tbName;
+				listButtons[i].fromText = tbJourney.getFromWaypoint() + '/' + tbJourney.getFromProfile();
+				listButtons[i].fromLogged = tbJourney.getFromLogged();
+				listButtons[i].toText = tbJourney.getToWaypoint() + '/' + tbJourney.getToProfile();
+				listButtons[i].toLogged = tbJourney.getToLogged();
+				listButtons[i].image = new AniImage(&quot;bug_vga.gif&quot;);
+				listButtons[i].modify(ControlConstants.Disabled, 1);
+			} else {
+				listButtons[i].text = listButtons[i].fromText =	listButtons[i].toText = &quot;&quot;;
+				listButtons[i].toLogged = listButtons[i].fromLogged = true;
+				listButtons[i].image = null;
+				listButtons[i].modify(ControlConstants.Disabled, 0);
+			}
+			listButtons[i].repaint();
+		}
+	}
+
+	public void toggleOnlyLogged() {
+		model.toggleOnlyLogged();
+		firstLine = 0;
+		setupTBButtons();
+	}
+
+	public void createShowSet() {
+		firstLine = 0;
+		model.createShowSet();
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugMenuPanel.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,101 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.CacheDB;
+import CacheWolf.CacheHolder;
+import CacheWolf.CacheHolderDetail;
+import CacheWolf.Global;
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugJourney;
+import CacheWolf.TravelbugList;
+import CacheWolf.TravelbugPickup;
+import CacheWolf.view.ewe.TravelbugJourneyScreen;
+import ewe.fx.Dimension;
+
+public class PDATravelbugMenuPanel extends PDAMenu {
+
+	private static final String RETRIEVE = &quot;retrieve&quot;;
+	private static final String TOGGLE_LOG = &quot;toggle_log&quot;;
+	private static final String NEW_TB = &quot;new_tb&quot;;
+	private static final String EXPERT = &quot;expert_view&quot;;
+	private static final String SORT = &quot;sort&quot;;
+	private static final String EXIT = &quot;exit&quot;;
+	private PDATravelbugJourneyScreen view;
+
+	public PDATravelbugMenuPanel(PDATravelbugJourneyScreen view) {
+		this.view =view;
+		setTitle(MyLocale.getMsg(6053, &quot;Travelbug - Menu&quot;));
+
+		addMenuItem(view.model.onlyLogged ? MyLocale.getMsg(6054, &quot;Show all&quot;) : MyLocale.getMsg(6046, &quot;Show only not logged&quot;),
+				TOGGLE_LOG);
+		addMenuItem(MyLocale.getMsg(6055, &quot;Sort ...&quot;), SORT);
+		addMenuItem(MyLocale.getMsg(6042, &quot;New Travelbug&quot;), NEW_TB);
+		addMenuItem(MyLocale.getMsg(6040, &quot;Pick up TB from current cache&quot;), RETRIEVE);
+		addMenuItem(MyLocale.getMsg(6056, &quot;Expertview&quot;), EXPERT);
+		addMenuItem(MyLocale.getMsg(6061, &quot;Close&quot;), EXIT);
+		buildMenu ();
+	}
+
+	public void actionPerformed(String actionCommand) {
+		if (actionCommand.equals(RETRIEVE)) {
+			int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+			CacheDB cacheDB = Global.getProfile().cacheDB;
+			if (curCacheNo &gt;= 0 &amp;&amp; curCacheNo &lt; cacheDB.size()) {
+				CacheHolder ch = cacheDB.get(curCacheNo);
+				String waypoint = ch.getWayPoint();
+				TravelbugList tblSrcCache = ch.getCacheDetails(true).Travelbugs;
+
+				Travelbug tb = TravelbugPickup.pickupTravelbug(tblSrcCache);
+				if (tb != null) {
+					view.model.allTravelbugJourneys.addTbPickup(tb, Global.getProfile().name, waypoint);
+					CacheHolderDetail cacheDetails = ch.getCacheDetails(true);
+					ch.setHas_bugs(cacheDetails.Travelbugs.size() &gt; 0);
+					ch.save();
+					view.model.allTravelbugJourneys.saveTravelbugsFile();
+				}
+			}
+			view.createShowSet();
+			view.setupTBButtons();
+			exit(0);
+		} else if (actionCommand.equals(TOGGLE_LOG)) {
+			view.toggleOnlyLogged();
+			exit(0);
+		} else if (actionCommand.equals(EXPERT)) {
+			TravelbugJourneyScreen travelbugJourneyScreen = new TravelbugJourneyScreen(view.model);
+			Dimension arg0 = new Dimension();
+			getSize(arg0);
+			travelbugJourneyScreen.setPreferredSize(arg0.width, arg0.height);
+			travelbugJourneyScreen.execute();
+			exit(0);
+			view.exit(0);
+		} else if (actionCommand.equals(NEW_TB)) {
+			int curCacheNo = Global.mainTab.tbP.getSelectedCache();
+			CacheDB cacheDB = Global.getProfile().cacheDB;
+			CacheHolder ch = cacheDB.get(curCacheNo);
+			TravelbugJourney tbj = new TravelbugJourney(&quot;New&quot;);
+			tbj.setFromProfile(Global.getProfile().name);
+			tbj.setFromWaypoint(&quot;&quot;);
+			tbj.setFromLogged(true);
+			view.model.allTravelbugJourneys.add(tbj);
+			CacheHolderDetail cacheDetails = ch.getCacheDetails(true);
+			ch.setHas_bugs(cacheDetails.Travelbugs.size() &gt; 0);
+			ch.save();
+			view.model.allTravelbugJourneys.saveTravelbugsFile();
+			view.createShowSet();
+			view.setupTBButtons();
+			exit(0);
+		} else if (actionCommand.equals(SORT)) {
+			PDATravelbugSortMenu sortMenu = new PDATravelbugSortMenu();
+			sortMenu.execute();
+			if (sortMenu.sortColumn &gt; 0) {
+				view.model.allTravelbugJourneys.sort(sortMenu.sortColumn, sortMenu.ascending);
+				view.createShowSet();
+				view.setupTBButtons();
+			}
+			exit(0);
+		} else if (actionCommand.equals(EXIT)){
+			exit(1);
+		}
+	}
+
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugScreen.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,68 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import CacheWolf.Travelbug;
+import CacheWolf.TravelbugList;
+import CacheWolf.model.DefaultListModel;
+import CacheWolf.view.ITravelbugScreen;
+import ewe.ui.ControlEvent;
+
+public class PDATravelbugScreen extends PDAList implements ITravelbugScreen{
+
+	/** The index into the list of travelbugs indicating the selected bug */
+	public int selectedItem=-1;
+	
+	/**
+	 * A screen to choose a travelbug from a list of bugs
+	 * @param tbl The list of travelbugs from which to choose
+	 * @param title The title of the screen
+	 * @param allowNew True if a travelbug not on the list can be selected
+	 */
+	public PDATravelbugScreen(TravelbugList tbl, String title, boolean allowNew) {
+		super();
+		model = new DefaultListModel();
+		for (int i=0;i &lt; tbl.size();i++){
+			Travelbug tb = tbl.getTB(i);
+			model.add(tb.getName());
+		}
+		if (allowNew){
+			model.add(MyLocale.getMsg(6015,&quot;*** OTHER ***&quot;));
+		}
+		model.createShowSet();
+		setupTBButtons();
+}
+
+	public void onControlEvent(ControlEvent ev) {
+		if (ev instanceof ControlEvent) {
+			switch (ev.type) {
+			case ControlEvent.PRESSED:
+				if (ev.action.equals(NEXT_PAGE) ||(ev.action.equals(PREV_PAGE))) {
+					super.onControlEvent(ev);	
+				} else if (ev.action.startsWith(LINE)) {
+					selectedItem = ev.action.charAt(LINE.length()) - '0';
+//					Object clickedItem =  model.get(line + firstLine);
+//					Form form = new PDATravelbugDetailPanel(tbJourney, this);
+//					form.setPreferredSize(800, 600);
+//					form.execute();
+//					setupTBButtons();
+					exit(0);
+				} else if (ev.action.equals(MENUE)) {
+//					Form form = new PDATravelbugMenuPanel(this);
+//					form.setPreferredSize(800, 600);
+//					int execute = form.execute();
+//					if (execute == 1){
+//						exit(0);
+//					}
+					setupTBButtons();
+				}
+				break;
+			default:
+				super.onControlEvent(ev);
+			}
+		}
+	}
+
+	public int getSelectedItem() {
+		return selectedItem;
+	}
+}

Added: branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java
===================================================================
--- branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java	                        (rev 0)
+++ branches/r1.2/src/CacheWolf/view/pda/PDATravelbugSortMenu.java	2011-08-01 18:08:06 UTC (rev 3048)
@@ -0,0 +1,86 @@
+package CacheWolf.view.pda;
+
+import CacheWolf.MyLocale;
+import ewe.fx.Rect;
+import ewe.ui.Window;
+
+public class PDATravelbugSortMenu extends PDAMenu {
+	private static final String NAME = &quot;name&quot;;
+	private static final String FROM_WP = &quot;from_wp&quot;;
+	private static final String FROM_DATE = &quot;from_date&quot;;
+	private static final String TO_WP = &quot;to_wp&quot;;
+	private static final String TO_DATE = &quot;to_date&quot;;
+	private static final String TRACK_NR = &quot;track_nw&quot;;
+	private static final String EXIT = &quot;exit&quot;;
+	public int sortColumn = -1;
+	public boolean ascending = true;
+
+	public PDATravelbugSortMenu() {
+		super();
+		PDAMenuButton button = new PDAMenuButton(MyLocale.getMsg(6028, &quot;Name&quot;), NAME);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;^^&quot;, NAME + &quot;_UP&quot;);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;vv&quot;, NAME + &quot;_DOWN&quot;);
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6005, &quot;From Wpt&quot;), FROM_WP);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;^^&quot;, FROM_WP + &quot;_UP&quot;);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;vv&quot;, FROM_WP + &quot;_DOWN&quot;);
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6006, &quot;From Date&quot;), FROM_DATE);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;^^&quot;, FROM_DATE + &quot;_UP&quot;);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;vv&quot;, FROM_DATE + &quot;_DOWN&quot;);
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6009, &quot;To Wpt&quot;), TO_WP);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;^^&quot;, TO_WP + &quot;_UP&quot;);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;vv&quot;, TO_WP + &quot;_DOWN&quot;);
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6010, &quot;To Date&quot;), TO_DATE);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;^^&quot;, TO_DATE + &quot;_UP&quot;);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;vv&quot;, TO_DATE + &quot;_DOWN&quot;);
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6062, &quot;Track-No&quot;), TRACK_NR);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;^^&quot;, TRACK_NR + &quot;_UP&quot;);
+		addNext(button, HSTRETCH, HFILL);
+		button = new PDAMenuButton(&quot;vv&quot;, TRACK_NR + &quot;_DOWN&quot;);
+		addLast(button, HSTRETCH, HFILL);
+
+		button = new PDAMenuButton(MyLocale.getMsg(6057, &quot;Back&quot;), EXIT);
+		addLast(button);
+
+		Rect s = (Rect) Window.getGuiInfo(Window.INFO_SCREEN_RECT, null, new Rect(), 0);
+		setPreferredSize(s.width, s.height);
+	}
+
+	public void actionPerformed(String actionCommand) {
+		if (actionCommand.startsWith(NAME)) {
+			sortColumn = 1;
+		} else if (actionCommand.startsWith(FROM_WP)) {
+			sortColumn = 5;
+		} else if (actionCommand.startsWith(FROM_DATE)) {
+			sortColumn = 6;
+		} else if (actionCommand.startsWith(TO_WP)) {
+			sortColumn = 9;
+		} else if (actionCommand.startsWith(TO_DATE)) {
+			sortColumn = 10;
+		} else if (actionCommand.startsWith(TRACK_NR)) {
+			sortColumn = 2;
+		}
+		ascending = actionCommand.endsWith(&quot;DOWN&quot;);
+		exit(0);
+	}
+}

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Application.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,7 +1,7 @@
 &#239;&#187;&#191;'------------------------------------------------------------------------------
 ' &lt;auto-generated&gt;
 '     Dieser Code wurde von einem Tool generiert.
-'     Laufzeitversion:2.0.50727.3082
+'     Laufzeitversion:4.0.30319.1
 '
 '     &#195;&#132;nderungen an dieser Datei k&#195;&#182;nnen falsches Verhalten verursachen und gehen verloren, wenn
 '     der Code erneut generiert wird.
@@ -16,7 +16,7 @@
     
     'HINWEIS: Diese Datei wird automatisch generiert. &#195;&#132;ndern Sie sie nicht direkt. Zum &#195;&#132;ndern
     ' oder bei in dieser Datei auftretenden Buildfehlern wechseln Sie zum Projekt-Designer.
-    ' (Wechseln Sie dazu zu den Projekteigenschaften, oder doppelklicken Sie auf den Knoten &quot;Eigenes Projekt&quot; im
+    ' (Wechseln Sie dazu zu den Projekteigenschaften, oder doppelklicken Sie auf den Knoten &quot;Mein Projekt&quot; im
     ' Projektmappen-Explorer). Nehmen Sie auf der Registerkarte &quot;Anwendung&quot; entsprechende &#195;&#132;nderungen vor.
     '
     Partial Friend Class MyApplication

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Resources.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,7 +1,7 @@
 &#239;&#187;&#191;'------------------------------------------------------------------------------
 ' &lt;auto-generated&gt;
 '     Dieser Code wurde von einem Tool generiert.
-'     Laufzeitversion:2.0.50727.3082
+'     Laufzeitversion:4.0.30319.1
 '
 '     &#195;&#132;nderungen an dieser Datei k&#195;&#182;nnen falsches Verhalten verursachen und gehen verloren, wenn
 '     der Code erneut generiert wird.
@@ -22,7 +22,7 @@
     '''&lt;summary&gt;
     '''  Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
     '''&lt;/summary&gt;
-    &lt;Global.System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;System.Resources.Tools.StronglyTypedResourceBuilder&quot;, &quot;2.0.0.0&quot;),  _
+    &lt;Global.System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;System.Resources.Tools.StronglyTypedResourceBuilder&quot;, &quot;4.0.0.0&quot;),  _
      Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
      Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
      Global.Microsoft.VisualBasic.HideModuleNameAttribute()&gt;  _

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/My Project/Settings.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,7 +1,7 @@
 &#239;&#187;&#191;'------------------------------------------------------------------------------
 ' &lt;auto-generated&gt;
 '     Dieser Code wurde von einem Tool generiert.
-'     Laufzeitversion:2.0.50727.3082
+'     Laufzeitversion:4.0.30319.1
 '
 '     &#195;&#132;nderungen an dieser Datei k&#195;&#182;nnen falsches Verhalten verursachen und gehen verloren, wenn
 '     der Code erneut generiert wird.
@@ -15,12 +15,12 @@
 Namespace My
     
     &lt;Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute(),  _
-     Global.System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator&quot;, &quot;9.0.0.0&quot;),  _
+     Global.System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator&quot;, &quot;10.0.0.0&quot;),  _
      Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)&gt;  _
     Partial Friend NotInheritable Class MySettings
         Inherits Global.System.Configuration.ApplicationSettingsBase
         
-        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings),MySettings)
+        Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings()),MySettings)
         
 #Region &quot;Funktion zum automatischen Speichern von My.Settings&quot;
 #If _MyType = &quot;WindowsForms&quot; Then

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/bin/Debug/capxml2wms.exe
===================================================================
(Binary files differ)

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.Designer.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -23,298 +23,297 @@
     &lt;System.Diagnostics.DebuggerStepThrough()&gt; _
     Private Sub InitializeComponent()
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(capxml2wms))
-        Me.ButtonErstellen = New System.Windows.Forms.Button
-        Me.TextBoxUrl = New System.Windows.Forms.TextBox
-        Me.Label1 = New System.Windows.Forms.Label
-        Me.TextBoxXML = New System.Windows.Forms.TextBox
-        Me.Label2 = New System.Windows.Forms.Label
-        Me.ComboBoxVersion = New System.Windows.Forms.ComboBox
-        Me.ButtonGetCapabilities = New System.Windows.Forms.Button
-        Me.ButtonShowMap = New System.Windows.Forms.Button
-        Me.CheckedListBoxLayers = New System.Windows.Forms.CheckedListBox
-        Me.Label3 = New System.Windows.Forms.Label
-        Me.ButtonCheckNone = New System.Windows.Forms.Button
-        Me.ButtonCheckAll = New System.Windows.Forms.Button
-        Me.ComboBoxEPSG = New System.Windows.Forms.ComboBox
-        Me.Label4 = New System.Windows.Forms.Label
-        Me.HScrollBar1 = New System.Windows.Forms.HScrollBar
-        Me.Label5 = New System.Windows.Forms.Label
-        Me.ComboBoxFormat = New System.Windows.Forms.ComboBox
-        Me.ComboBoxBBox = New System.Windows.Forms.ComboBox
-        Me.Label6 = New System.Windows.Forms.Label
-        Me.ComboBoxBBoxI = New System.Windows.Forms.ComboBox
-        Me.ButtonFindScale = New System.Windows.Forms.Button
+        Me.ButtonErstellen = New System.Windows.Forms.Button()
+        Me.Panel1 = New System.Windows.Forms.Panel()
+        Me.ComboBoxBBoxI = New System.Windows.Forms.ComboBox()
+        Me.Label6 = New System.Windows.Forms.Label()
+        Me.ComboBoxBBox = New System.Windows.Forms.ComboBox()
+        Me.ComboBoxFormat = New System.Windows.Forms.ComboBox()
+        Me.Label5 = New System.Windows.Forms.Label()
+        Me.Label4 = New System.Windows.Forms.Label()
+        Me.ComboBoxEPSG = New System.Windows.Forms.ComboBox()
+        Me.ButtonFindScale = New System.Windows.Forms.Button()
+        Me.ButtonCheckAll = New System.Windows.Forms.Button()
+        Me.ButtonCheckNone = New System.Windows.Forms.Button()
+        Me.Label3 = New System.Windows.Forms.Label()
+        Me.CheckedListBoxLayers = New System.Windows.Forms.CheckedListBox()
+        Me.Panel2 = New System.Windows.Forms.Panel()
+        Me.TextBoxXML = New System.Windows.Forms.TextBox()
+        Me.ButtonGetCapabilities = New System.Windows.Forms.Button()
+        Me.ComboBoxVersion = New System.Windows.Forms.ComboBox()
+        Me.Label2 = New System.Windows.Forms.Label()
+        Me.Label1 = New System.Windows.Forms.Label()
+        Me.TextBoxUrl = New System.Windows.Forms.TextBox()
+        Me.Panel1.SuspendLayout()
+        Me.Panel2.SuspendLayout()
         Me.SuspendLayout()
         '
         'ButtonErstellen
         '
         Me.ButtonErstellen.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonErstellen.Location = New System.Drawing.Point(540, 552)
+        Me.ButtonErstellen.Location = New System.Drawing.Point(537, 553)
         Me.ButtonErstellen.Name = &quot;ButtonErstellen&quot;
         Me.ButtonErstellen.Size = New System.Drawing.Size(123, 36)
         Me.ButtonErstellen.TabIndex = 1
-        Me.ButtonErstellen.Text = &quot;WMS-Datei erstellen&quot;
+        Me.ButtonErstellen.Text = &quot;3. WMS-Datei erstellen&quot;
         Me.ButtonErstellen.UseVisualStyleBackColor = True
         '
-        'TextBoxUrl
+        'Panel1
         '
-        Me.TextBoxUrl.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+        Me.Panel1.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
+                    Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.TextBoxUrl.Location = New System.Drawing.Point(20, 57)
-        Me.TextBoxUrl.Name = &quot;TextBoxUrl&quot;
-        Me.TextBoxUrl.Size = New System.Drawing.Size(496, 20)
-        Me.TextBoxUrl.TabIndex = 0
+        Me.Panel1.Controls.Add(Me.ComboBoxBBoxI)
+        Me.Panel1.Controls.Add(Me.Label6)
+        Me.Panel1.Controls.Add(Me.ComboBoxBBox)
+        Me.Panel1.Controls.Add(Me.ComboBoxFormat)
+        Me.Panel1.Controls.Add(Me.Label5)
+        Me.Panel1.Controls.Add(Me.Label4)
+        Me.Panel1.Controls.Add(Me.ComboBoxEPSG)
+        Me.Panel1.Controls.Add(Me.ButtonFindScale)
+        Me.Panel1.Controls.Add(Me.ButtonCheckAll)
+        Me.Panel1.Controls.Add(Me.ButtonCheckNone)
+        Me.Panel1.Controls.Add(Me.Label3)
+        Me.Panel1.Controls.Add(Me.CheckedListBoxLayers)
+        Me.Panel1.Location = New System.Drawing.Point(20, 240)
+        Me.Panel1.Name = &quot;Panel1&quot;
+        Me.Panel1.Size = New System.Drawing.Size(643, 306)
+        Me.Panel1.TabIndex = 24
         '
-        'Label1
+        'ComboBoxBBoxI
         '
-        Me.Label1.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
-                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.Label1.AutoSize = True
-        Me.Label1.Location = New System.Drawing.Point(21, 27)
-        Me.Label1.Name = &quot;Label1&quot;
-        Me.Label1.Size = New System.Drawing.Size(205, 13)
-        Me.Label1.TabIndex = 2
-        Me.Label1.Text = &quot;http Adresse des WMS-Servers eingeben:&quot;
+        Me.ComboBoxBBoxI.FormattingEnabled = True
+        Me.ComboBoxBBoxI.Location = New System.Drawing.Point(190, 36)
+        Me.ComboBoxBBoxI.Name = &quot;ComboBoxBBoxI&quot;
+        Me.ComboBoxBBoxI.Size = New System.Drawing.Size(252, 21)
+        Me.ComboBoxBBoxI.TabIndex = 35
+        Me.ComboBoxBBoxI.Visible = False
         '
-        'TextBoxXML
+        'Label6
         '
-        Me.TextBoxXML.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
-                    Or System.Windows.Forms.AnchorStyles.Left) _
+        Me.Label6.AutoSize = True
+        Me.Label6.Location = New System.Drawing.Point(141, 6)
+        Me.Label6.Name = &quot;Label6&quot;
+        Me.Label6.Size = New System.Drawing.Size(35, 13)
+        Me.Label6.TabIndex = 34
+        Me.Label6.Text = &quot;BBox:&quot;
+        '
+        'ComboBoxBBox
+        '
+        Me.ComboBoxBBox.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.TextBoxXML.Location = New System.Drawing.Point(20, 83)
-        Me.TextBoxXML.Multiline = True
-        Me.TextBoxXML.Name = &quot;TextBoxXML&quot;
-        Me.TextBoxXML.ReadOnly = True
-        Me.TextBoxXML.ScrollBars = System.Windows.Forms.ScrollBars.Both
-        Me.TextBoxXML.Size = New System.Drawing.Size(643, 288)
-        Me.TextBoxXML.TabIndex = 4
-        Me.TextBoxXML.WordWrap = False
+        Me.ComboBoxBBox.FormattingEnabled = True
+        Me.ComboBoxBBox.Location = New System.Drawing.Point(144, 23)
+        Me.ComboBoxBBox.Name = &quot;ComboBoxBBox&quot;
+        Me.ComboBoxBBox.Size = New System.Drawing.Size(489, 21)
+        Me.ComboBoxBBox.TabIndex = 33
         '
-        'Label2
+        'ComboBoxFormat
         '
-        Me.Label2.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.Label2.AutoSize = True
-        Me.Label2.Location = New System.Drawing.Point(511, 27)
-        Me.Label2.Name = &quot;Label2&quot;
-        Me.Label2.Size = New System.Drawing.Size(75, 13)
-        Me.Label2.TabIndex = 5
-        Me.Label2.Text = &quot;WMS-Version:&quot;
-        Me.Label2.Visible = False
+        Me.ComboBoxFormat.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ComboBoxFormat.FormattingEnabled = True
+        Me.ComboBoxFormat.Location = New System.Drawing.Point(512, 104)
+        Me.ComboBoxFormat.Name = &quot;ComboBoxFormat&quot;
+        Me.ComboBoxFormat.Size = New System.Drawing.Size(121, 21)
+        Me.ComboBoxFormat.TabIndex = 32
         '
-        'ComboBoxVersion
+        'Label5
         '
-        Me.ComboBoxVersion.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxVersion.FormattingEnabled = True
-        Me.ComboBoxVersion.Items.AddRange(New Object() {&quot;1.0.0&quot;, &quot;1.1.0&quot;, &quot;1.1.1&quot;})
-        Me.ComboBoxVersion.Location = New System.Drawing.Point(588, 24)
-        Me.ComboBoxVersion.MaxDropDownItems = 3
-        Me.ComboBoxVersion.Name = &quot;ComboBoxVersion&quot;
-        Me.ComboBoxVersion.Size = New System.Drawing.Size(75, 21)
-        Me.ComboBoxVersion.TabIndex = 6
+        Me.Label5.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label5.AutoSize = True
+        Me.Label5.Location = New System.Drawing.Point(514, 88)
+        Me.Label5.Name = &quot;Label5&quot;
+        Me.Label5.Size = New System.Drawing.Size(42, 13)
+        Me.Label5.TabIndex = 31
+        Me.Label5.Text = &quot;Format:&quot;
         '
-        'ButtonGetCapabilities
+        'Label4
         '
-        Me.ButtonGetCapabilities.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonGetCapabilities.Location = New System.Drawing.Point(540, 43)
-        Me.ButtonGetCapabilities.Name = &quot;ButtonGetCapabilities&quot;
-        Me.ButtonGetCapabilities.Size = New System.Drawing.Size(123, 36)
-        Me.ButtonGetCapabilities.TabIndex = 7
-        Me.ButtonGetCapabilities.Text = &quot;M&#195;&#182;glichkeiten abfragen&quot;
-        Me.ButtonGetCapabilities.UseVisualStyleBackColor = True
+        Me.Label4.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label4.AutoSize = True
+        Me.Label4.Location = New System.Drawing.Point(514, 47)
+        Me.Label4.Name = &quot;Label4&quot;
+        Me.Label4.Size = New System.Drawing.Size(39, 13)
+        Me.Label4.TabIndex = 30
+        Me.Label4.Text = &quot;EPSG:&quot;
         '
-        'ButtonShowMap
+        'ComboBoxEPSG
         '
-        Me.ButtonShowMap.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonShowMap.Location = New System.Drawing.Point(540, 397)
-        Me.ButtonShowMap.Name = &quot;ButtonShowMap&quot;
-        Me.ButtonShowMap.Size = New System.Drawing.Size(123, 36)
-        Me.ButtonShowMap.TabIndex = 8
-        Me.ButtonShowMap.Text = &quot;Test Karte anzeigen&quot;
-        Me.ButtonShowMap.UseVisualStyleBackColor = True
+        Me.ComboBoxEPSG.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ComboBoxEPSG.FormattingEnabled = True
+        Me.ComboBoxEPSG.Location = New System.Drawing.Point(512, 64)
+        Me.ComboBoxEPSG.Name = &quot;ComboBoxEPSG&quot;
+        Me.ComboBoxEPSG.Size = New System.Drawing.Size(121, 21)
+        Me.ComboBoxEPSG.TabIndex = 29
         '
-        'CheckedListBoxLayers
+        'ButtonFindScale
         '
-        Me.CheckedListBoxLayers.Anchor = CType(((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left) _
-                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.CheckedListBoxLayers.CheckOnClick = True
-        Me.CheckedListBoxLayers.FormattingEnabled = True
-        Me.CheckedListBoxLayers.HorizontalScrollbar = True
-        Me.CheckedListBoxLayers.Location = New System.Drawing.Point(20, 397)
-        Me.CheckedListBoxLayers.Name = &quot;CheckedListBoxLayers&quot;
-        Me.CheckedListBoxLayers.Size = New System.Drawing.Size(496, 109)
-        Me.CheckedListBoxLayers.TabIndex = 9
+        Me.ButtonFindScale.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ButtonFindScale.Location = New System.Drawing.Point(517, 265)
+        Me.ButtonFindScale.Name = &quot;ButtonFindScale&quot;
+        Me.ButtonFindScale.Size = New System.Drawing.Size(123, 36)
+        Me.ButtonFindScale.TabIndex = 28
+        Me.ButtonFindScale.Text = &quot;2. Optimale Scale finden&quot;
+        Me.ButtonFindScale.UseVisualStyleBackColor = True
         '
-        'Label3
+        'ButtonCheckAll
         '
-        Me.Label3.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label3.AutoSize = True
-        Me.Label3.Location = New System.Drawing.Point(21, 381)
-        Me.Label3.Name = &quot;Label3&quot;
-        Me.Label3.Size = New System.Drawing.Size(36, 13)
-        Me.Label3.TabIndex = 10
-        Me.Label3.Text = &quot;Layer:&quot;
+        Me.ButtonCheckAll.Location = New System.Drawing.Point(6, 24)
+        Me.ButtonCheckAll.Name = &quot;ButtonCheckAll&quot;
+        Me.ButtonCheckAll.Size = New System.Drawing.Size(60, 20)
+        Me.ButtonCheckAll.TabIndex = 27
+        Me.ButtonCheckAll.Text = &quot;alle  x&quot;
+        Me.ButtonCheckAll.UseVisualStyleBackColor = True
         '
         'ButtonCheckNone
         '
-        Me.ButtonCheckNone.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ButtonCheckNone.Location = New System.Drawing.Point(212, 377)
+        Me.ButtonCheckNone.Location = New System.Drawing.Point(72, 23)
         Me.ButtonCheckNone.Name = &quot;ButtonCheckNone&quot;
         Me.ButtonCheckNone.Size = New System.Drawing.Size(60, 20)
-        Me.ButtonCheckNone.TabIndex = 13
+        Me.ButtonCheckNone.TabIndex = 26
         Me.ButtonCheckNone.Text = &quot;kein x&quot;
         Me.ButtonCheckNone.UseVisualStyleBackColor = True
         '
-        'ButtonCheckAll
+        'Label3
         '
-        Me.ButtonCheckAll.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ButtonCheckAll.Location = New System.Drawing.Point(149, 377)
-        Me.ButtonCheckAll.Name = &quot;ButtonCheckAll&quot;
-        Me.ButtonCheckAll.Size = New System.Drawing.Size(60, 20)
-        Me.ButtonCheckAll.TabIndex = 14
-        Me.ButtonCheckAll.Text = &quot;alle  x&quot;
-        Me.ButtonCheckAll.UseVisualStyleBackColor = True
+        Me.Label3.AutoSize = True
+        Me.Label3.Location = New System.Drawing.Point(3, 6)
+        Me.Label3.Name = &quot;Label3&quot;
+        Me.Label3.Size = New System.Drawing.Size(36, 13)
+        Me.Label3.TabIndex = 25
+        Me.Label3.Text = &quot;Layer:&quot;
         '
-        'ComboBoxEPSG
+        'CheckedListBoxLayers
         '
-        Me.ComboBoxEPSG.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxEPSG.FormattingEnabled = True
-        Me.ComboBoxEPSG.Location = New System.Drawing.Point(20, 526)
-        Me.ComboBoxEPSG.Name = &quot;ComboBoxEPSG&quot;
-        Me.ComboBoxEPSG.Size = New System.Drawing.Size(121, 21)
-        Me.ComboBoxEPSG.TabIndex = 15
+        Me.CheckedListBoxLayers.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
+                    Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.CheckedListBoxLayers.CheckOnClick = True
+        Me.CheckedListBoxLayers.FormattingEnabled = True
+        Me.CheckedListBoxLayers.HorizontalScrollbar = True
+        Me.CheckedListBoxLayers.Location = New System.Drawing.Point(6, 72)
+        Me.CheckedListBoxLayers.Name = &quot;CheckedListBoxLayers&quot;
+        Me.CheckedListBoxLayers.Size = New System.Drawing.Size(496, 229)
+        Me.CheckedListBoxLayers.TabIndex = 24
         '
-        'Label4
+        'Panel2
         '
-        Me.Label4.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label4.AutoSize = True
-        Me.Label4.Location = New System.Drawing.Point(22, 509)
-        Me.Label4.Name = &quot;Label4&quot;
-        Me.Label4.Size = New System.Drawing.Size(39, 13)
-        Me.Label4.TabIndex = 16
-        Me.Label4.Text = &quot;EPSG:&quot;
+        Me.Panel2.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Panel2.Controls.Add(Me.TextBoxXML)
+        Me.Panel2.Controls.Add(Me.ButtonGetCapabilities)
+        Me.Panel2.Controls.Add(Me.ComboBoxVersion)
+        Me.Panel2.Controls.Add(Me.Label2)
+        Me.Panel2.Controls.Add(Me.Label1)
+        Me.Panel2.Controls.Add(Me.TextBoxUrl)
+        Me.Panel2.Location = New System.Drawing.Point(20, 12)
+        Me.Panel2.Name = &quot;Panel2&quot;
+        Me.Panel2.Size = New System.Drawing.Size(643, 222)
+        Me.Panel2.TabIndex = 25
         '
-        'HScrollBar1
+        'TextBoxXML
         '
-        Me.HScrollBar1.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.HScrollBar1.Location = New System.Drawing.Point(540, 377)
-        Me.HScrollBar1.Minimum = 1
-        Me.HScrollBar1.Name = &quot;HScrollBar1&quot;
-        Me.HScrollBar1.Size = New System.Drawing.Size(123, 17)
-        Me.HScrollBar1.TabIndex = 17
-        Me.HScrollBar1.Value = 1
+        Me.TextBoxXML.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
+                    Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.TextBoxXML.Location = New System.Drawing.Point(6, 52)
+        Me.TextBoxXML.Multiline = True
+        Me.TextBoxXML.Name = &quot;TextBoxXML&quot;
+        Me.TextBoxXML.ReadOnly = True
+        Me.TextBoxXML.ScrollBars = System.Windows.Forms.ScrollBars.Both
+        Me.TextBoxXML.Size = New System.Drawing.Size(627, 167)
+        Me.TextBoxXML.TabIndex = 13
+        Me.TextBoxXML.WordWrap = False
         '
-        'Label5
+        'ButtonGetCapabilities
         '
-        Me.Label5.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label5.AutoSize = True
-        Me.Label5.Location = New System.Drawing.Point(148, 509)
-        Me.Label5.Name = &quot;Label5&quot;
-        Me.Label5.Size = New System.Drawing.Size(42, 13)
-        Me.Label5.TabIndex = 18
-        Me.Label5.Text = &quot;Format:&quot;
+        Me.ButtonGetCapabilities.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ButtonGetCapabilities.Location = New System.Drawing.Point(517, 9)
+        Me.ButtonGetCapabilities.Name = &quot;ButtonGetCapabilities&quot;
+        Me.ButtonGetCapabilities.Size = New System.Drawing.Size(123, 36)
+        Me.ButtonGetCapabilities.TabIndex = 12
+        Me.ButtonGetCapabilities.Text = &quot;1. M&#195;&#182;glichkeiten abfragen&quot;
+        Me.ButtonGetCapabilities.UseVisualStyleBackColor = True
         '
-        'ComboBoxFormat
+        'ComboBoxVersion
         '
-        Me.ComboBoxFormat.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxFormat.FormattingEnabled = True
-        Me.ComboBoxFormat.Location = New System.Drawing.Point(151, 526)
-        Me.ComboBoxFormat.Name = &quot;ComboBoxFormat&quot;
-        Me.ComboBoxFormat.Size = New System.Drawing.Size(121, 21)
-        Me.ComboBoxFormat.TabIndex = 19
+        Me.ComboBoxVersion.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.ComboBoxVersion.FormattingEnabled = True
+        Me.ComboBoxVersion.Items.AddRange(New Object() {&quot;1.0.0&quot;, &quot;1.1.0&quot;, &quot;1.1.1&quot;, &quot;1.3.0&quot;})
+        Me.ComboBoxVersion.Location = New System.Drawing.Point(412, 25)
+        Me.ComboBoxVersion.MaxDropDownItems = 3
+        Me.ComboBoxVersion.Name = &quot;ComboBoxVersion&quot;
+        Me.ComboBoxVersion.Size = New System.Drawing.Size(84, 21)
+        Me.ComboBoxVersion.TabIndex = 11
         '
-        'ComboBoxBBox
+        'Label2
         '
-        Me.ComboBoxBBox.Anchor = CType(((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left) _
-                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxBBox.FormattingEnabled = True
-        Me.ComboBoxBBox.Location = New System.Drawing.Point(20, 567)
-        Me.ComboBoxBBox.Name = &quot;ComboBoxBBox&quot;
-        Me.ComboBoxBBox.Size = New System.Drawing.Size(496, 21)
-        Me.ComboBoxBBox.TabIndex = 20
+        Me.Label2.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label2.AutoSize = True
+        Me.Label2.Location = New System.Drawing.Point(409, 9)
+        Me.Label2.Name = &quot;Label2&quot;
+        Me.Label2.Size = New System.Drawing.Size(75, 13)
+        Me.Label2.TabIndex = 10
+        Me.Label2.Text = &quot;WMS-Version:&quot;
         '
-        'Label6
+        'Label1
         '
-        Me.Label6.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.Label6.AutoSize = True
-        Me.Label6.Location = New System.Drawing.Point(22, 550)
-        Me.Label6.Name = &quot;Label6&quot;
-        Me.Label6.Size = New System.Drawing.Size(35, 13)
-        Me.Label6.TabIndex = 21
-        Me.Label6.Text = &quot;BBox:&quot;
+        Me.Label1.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.Label1.AutoSize = True
+        Me.Label1.Location = New System.Drawing.Point(3, 9)
+        Me.Label1.Name = &quot;Label1&quot;
+        Me.Label1.Size = New System.Drawing.Size(205, 13)
+        Me.Label1.TabIndex = 9
+        Me.Label1.Text = &quot;http Adresse des WMS-Servers eingeben:&quot;
         '
-        'ComboBoxBBoxI
+        'TextBoxUrl
         '
-        Me.ComboBoxBBoxI.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
-        Me.ComboBoxBBoxI.FormattingEnabled = True
-        Me.ComboBoxBBoxI.Location = New System.Drawing.Point(20, 580)
-        Me.ComboBoxBBoxI.Name = &quot;ComboBoxBBoxI&quot;
-        Me.ComboBoxBBoxI.Size = New System.Drawing.Size(252, 21)
-        Me.ComboBoxBBoxI.TabIndex = 22
-        Me.ComboBoxBBoxI.Visible = False
+        Me.TextBoxUrl.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
+                    Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
+        Me.TextBoxUrl.Location = New System.Drawing.Point(6, 25)
+        Me.TextBoxUrl.Name = &quot;TextBoxUrl&quot;
+        Me.TextBoxUrl.Size = New System.Drawing.Size(400, 20)
+        Me.TextBoxUrl.TabIndex = 8
         '
-        'ButtonFindScale
-        '
-        Me.ButtonFindScale.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
-        Me.ButtonFindScale.Location = New System.Drawing.Point(540, 439)
-        Me.ButtonFindScale.Name = &quot;ButtonFindScale&quot;
-        Me.ButtonFindScale.Size = New System.Drawing.Size(123, 36)
-        Me.ButtonFindScale.TabIndex = 23
-        Me.ButtonFindScale.Text = &quot;Optimale Scale finden&quot;
-        Me.ButtonFindScale.UseVisualStyleBackColor = True
-        '
         'capxml2wms
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.ClientSize = New System.Drawing.Size(675, 601)
-        Me.Controls.Add(Me.ButtonFindScale)
-        Me.Controls.Add(Me.ComboBoxBBoxI)
-        Me.Controls.Add(Me.Label6)
-        Me.Controls.Add(Me.ComboBoxBBox)
-        Me.Controls.Add(Me.ComboBoxFormat)
-        Me.Controls.Add(Me.Label5)
-        Me.Controls.Add(Me.HScrollBar1)
-        Me.Controls.Add(Me.Label4)
-        Me.Controls.Add(Me.ComboBoxEPSG)
-        Me.Controls.Add(Me.ButtonCheckAll)
-        Me.Controls.Add(Me.ButtonCheckNone)
-        Me.Controls.Add(Me.Label3)
-        Me.Controls.Add(Me.CheckedListBoxLayers)
-        Me.Controls.Add(Me.ButtonShowMap)
-        Me.Controls.Add(Me.ButtonGetCapabilities)
-        Me.Controls.Add(Me.ComboBoxVersion)
-        Me.Controls.Add(Me.Label2)
-        Me.Controls.Add(Me.TextBoxXML)
-        Me.Controls.Add(Me.Label1)
-        Me.Controls.Add(Me.TextBoxUrl)
+        Me.Controls.Add(Me.Panel2)
+        Me.Controls.Add(Me.Panel1)
         Me.Controls.Add(Me.ButtonErstellen)
         Me.Icon = CType(resources.GetObject(&quot;$this.Icon&quot;), System.Drawing.Icon)
         Me.Name = &quot;capxml2wms&quot;
         Me.Text = &quot;capxml2wms&quot;
+        Me.Panel1.ResumeLayout(False)
+        Me.Panel1.PerformLayout()
+        Me.Panel2.ResumeLayout(False)
+        Me.Panel2.PerformLayout()
         Me.ResumeLayout(False)
-        Me.PerformLayout()
 
     End Sub
     Private WithEvents ButtonErstellen As System.Windows.Forms.Button
-    Private WithEvents TextBoxUrl As System.Windows.Forms.TextBox
-    Private WithEvents Label1 As System.Windows.Forms.Label
-    Private WithEvents TextBoxXML As System.Windows.Forms.TextBox
-    Private WithEvents ComboBoxVersion As System.Windows.Forms.ComboBox
-    Private WithEvents Label2 As System.Windows.Forms.Label
-    Private WithEvents ButtonGetCapabilities As System.Windows.Forms.Button
-    Private WithEvents ButtonShowMap As System.Windows.Forms.Button
-    Private WithEvents CheckedListBoxLayers As System.Windows.Forms.CheckedListBox
-    Private WithEvents Label3 As System.Windows.Forms.Label
-    Private WithEvents ButtonCheckNone As System.Windows.Forms.Button
+    Friend WithEvents Panel1 As System.Windows.Forms.Panel
+    Private WithEvents ButtonFindScale As System.Windows.Forms.Button
     Private WithEvents ButtonCheckAll As System.Windows.Forms.Button
+    Private WithEvents ButtonCheckNone As System.Windows.Forms.Button
+    Private WithEvents Label3 As System.Windows.Forms.Label
+    Private WithEvents CheckedListBoxLayers As System.Windows.Forms.CheckedListBox
+    Private WithEvents ComboBoxBBoxI As System.Windows.Forms.ComboBox
+    Private WithEvents Label6 As System.Windows.Forms.Label
+    Private WithEvents ComboBoxBBox As System.Windows.Forms.ComboBox
+    Private WithEvents ComboBoxFormat As System.Windows.Forms.ComboBox
+    Private WithEvents Label5 As System.Windows.Forms.Label
     Private WithEvents Label4 As System.Windows.Forms.Label
     Private WithEvents ComboBoxEPSG As System.Windows.Forms.ComboBox
-    Private WithEvents HScrollBar1 As System.Windows.Forms.HScrollBar
-    Private WithEvents Label5 As System.Windows.Forms.Label
-    Private WithEvents ComboBoxFormat As System.Windows.Forms.ComboBox
-    Private WithEvents ComboBoxBBox As System.Windows.Forms.ComboBox
-    Private WithEvents Label6 As System.Windows.Forms.Label
-    Private WithEvents ComboBoxBBoxI As System.Windows.Forms.ComboBox
-    Private WithEvents ButtonFindScale As System.Windows.Forms.Button
+    Friend WithEvents Panel2 As System.Windows.Forms.Panel
+    Private WithEvents TextBoxXML As System.Windows.Forms.TextBox
+    Private WithEvents ButtonGetCapabilities As System.Windows.Forms.Button
+    Private WithEvents ComboBoxVersion As System.Windows.Forms.ComboBox
+    Private WithEvents Label2 As System.Windows.Forms.Label
+    Private WithEvents Label1 As System.Windows.Forms.Label
+    Private WithEvents TextBoxUrl As System.Windows.Forms.TextBox
 
 End Class

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.resx	2011-08-01 18:08:06 UTC (rev 3048)
@@ -112,12 +112,12 @@
     &lt;value&gt;2.0&lt;/value&gt;
   &lt;/resheader&gt;
   &lt;resheader name=&quot;reader&quot;&gt;
-    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+    &lt;value&gt;System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
   &lt;/resheader&gt;
   &lt;resheader name=&quot;writer&quot;&gt;
-    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
+    &lt;value&gt;System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&lt;/value&gt;
   &lt;/resheader&gt;
-  &lt;assembly alias=&quot;System.Drawing&quot; name=&quot;System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot; /&gt;
+  &lt;assembly alias=&quot;System.Drawing&quot; name=&quot;System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&quot; /&gt;
   &lt;data name=&quot;$this.Icon&quot; type=&quot;System.Drawing.Icon, System.Drawing&quot; mimetype=&quot;application/x-microsoft.net.object.bytearray.base64&quot;&gt;
     &lt;value&gt;
         AAABAAEAMC8AAAEAGAAQHAAAFgAAACgAAAAwAAAAXgAAAAEAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vb	2011-08-01 18:08:06 UTC (rev 3048)
@@ -85,39 +85,13 @@
         End If
         CheckedListBoxLayers.Items.Add(Layername, False)
     End Sub
-
-    Private Sub ButtonGetCapabilities_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonGetCapabilities.Click
-        GotCapabilities = GetCapabilities()
-        maxScale = 1000
-        minScale = 0
-        If Not recScale Is Nothing Then
-            recScale.Clear()
-        End If
-    End Sub
-
-    Private Sub ButtonShowMap_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonShowMap.Click
-        Dim MeineSkalierung As Double
-        MeineSkalierung = 2.0 * Me.HScrollBar1.Value
-        mapUrl = makeGetMapUrl(MeineSkalierung)
-        Dim center As point
-        center.x = 0
-        center.y = 0
-        Dim SM As New Map(mapUrl, 0, 0, 0, center)
-        'MsgBox(&quot;Noch nicht vorhanden!&quot;, MsgBoxStyle.Information, &quot;Hinweis!&quot;)
-        SM.ButtonAddToRecommendedScale.Visible = False
-        SM.ButtonHelp.Visible = False
-        SM.ButtonScaleDown.Visible = False
-        SM.ButtonScaleUp.Visible = False
-        SM.ButtonUseAsMaxScale.Visible = False
-        SM.ButtonUseAsMinScale.Visible = False
-        SM.LabelScaleDiagonal.Visible = False
-        SM.LabelScaleVertical.Visible = False
-        SM.ShowDialog()
-    End Sub
     Friend _srs As Integer
     Friend _pixelwidth As Integer
     Private Sub ButtonFindScale_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonFindScale.Click
         Dim BBoxString As String
+        If Me.ComboBoxEPSG.Items.Count = 0 Then
+            Return
+        End If
 
         _srs = Me.ComboBoxEPSG.SelectedItem
 
@@ -199,75 +173,7 @@
         mapUrl += &quot;&amp;FORMAT=&quot; &amp; Me.ComboBoxFormat.SelectedItem.ToString
         makeGetMapUrlFromBBox = mapUrl
     End Function
-    Private Function makeGetMapUrl(ByVal scale As Double) As String
-        '<A HREF="http://">http://</A> www.lv-bw.de/dv/service/getrds2.asp?login=dv&amp;pw=anonymous
-        '&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetMap
-        '&amp;SRS=EPSG:31467
-        '&amp;BBOX=3500394.51 , 5371405.09 , 3520394.51 , 5391405.09 
-        '&amp;WIDTH=1000
-        '&amp;HEIGHT=1000
-        '&amp;LAYERS=DVTK50K
-        '&amp;STYLES=
-        '&amp;FORMAT=image/png
-
-
-        mapUrl = wmsUrl &amp; &quot;SERVICE=WMS&amp;VERSION=&quot; &amp; Version &amp; &quot;&amp;REQUEST=GetMap&quot;
-
-        mapUrl += &quot;&amp;SRS=EPSG:&quot; &amp; Me.ComboBoxEPSG.SelectedItem
-
-        Dim rxmin As Double
-        Dim rxmax As Double
-        Dim rymin As Double
-        Dim rymax As Double
-
-        If Me.ComboBoxEPSG.SelectedItem = &quot;4326&quot; Then
-            Me.ComboBoxBBoxI.SelectedIndex = Me.ComboBoxBBox.SelectedIndex
-            GetBBoxValues(Me.ComboBoxBBoxI.SelectedItem)
-        Else
-            Try
-                GetBBoxValues(Me.OBBoxes.Item(&quot;EPSG:&quot; &amp; Me.ComboBoxEPSG.SelectedItem))
-            Catch ex As Exception
-                'todo: und jetzt umrechnen !
-                'das spar ich mir wohl, oder !
-                Me.ComboBoxBBoxI.SelectedIndex = Me.ComboBoxBBox.SelectedIndex
-                GetBBoxValues(Me.ComboBoxBBoxI.SelectedItem)
-                ' jetzt haben wir die BBox zum WGS84
-                MsgBox(&quot;Kartenansicht f&#252;r diese Auswahl nicht implementiert&quot;, MsgBoxStyle.Exclamation)
-                Exit Function
-            End Try
-        End If
-
-        Dim HalbeKantenlaengex As Double = (rmaxx - rminx) / scale
-        Dim HalbeKantenlaengey As Double = (rmaxy - rminy) / scale
-        Dim HalbeKantenlaenge As Double = HalbeKantenlaengex
-        If HalbeKantenlaengex &gt; HalbeKantenlaengey Then
-            HalbeKantenlaenge = HalbeKantenlaengey
-        End If
-        ' is in x und y die gleiche Einheit?
-        rxmin = rxmitte - HalbeKantenlaenge
-        rxmax = rxmitte + HalbeKantenlaenge
-        rymin = rymitte - HalbeKantenlaenge
-        rymax = rymitte + HalbeKantenlaenge
-
-        Dim BBox As String = &quot;&amp;BBox=&quot; &amp; rxmin.ToString(DPunkt) &amp; &quot;,&quot; &amp; rymin.ToString(DPunkt) &amp; &quot;,&quot;
-        BBox += rxmax.ToString(DPunkt) &amp; &quot;,&quot; &amp; rymax.ToString(DPunkt)
-
-        mapUrl += BBox
-        mapUrl += &quot;&amp;WIDTH=500&quot;
-        mapUrl += &quot;&amp;HEIGHT=500&quot;
-        ' und die gew&#228;hlten Layer durch Komma getrennt
-        Dim SelectedLayers As String = &quot;&quot;
-        For Each s As String In CheckedListBoxLayers.CheckedItems
-            SelectedLayers += &quot;,&quot; &amp; s.Split(&quot;|&quot;)(0)
-        Next
-        If SelectedLayers &lt;&gt; &quot;&quot; Then
-            mapUrl += &quot;&amp;LAYERS=&quot; &amp; SelectedLayers.Substring(1).Replace(&quot; &quot;, &quot;%20&quot;)
-        End If
-        mapUrl += &quot;&amp;STYLES=&quot;
-        mapUrl += &quot;&amp;FORMAT=&quot; &amp; Me.ComboBoxFormat.SelectedItem.ToString
-        makeGetMapUrl = mapUrl
-    End Function
-
+    
     Friend Function metersToBBoxVertical(ByVal epsg As Integer) As Double
         If epsg = 4326 Then
             metersToBBoxVertical = 360 / (WGS84.a * Math.PI * 2)
@@ -297,15 +203,19 @@
     End Function
     Private Sub ButtonErstellen_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonErstellen.Click
 
+        If Not GotCapabilities Then
+            GotCapabilities = GetCapabilities()
+        End If
+        If Not GotCapabilities Then
+            Return
+        End If
+
+
         Dim wmsFileName As String = IO.Path.ChangeExtension(xmlFileName, &quot;.wms&quot;)
         IO.File.Delete(wmsFileName) 'vorsichtshalber
         Dim encoding As System.Text.Encoding = New System.Text.UTF8Encoding(False)
         Dim F As New System.IO.StreamWriter(wmsFileName, False, encoding)
 
-        If Not GotCapabilities Then
-            GotCapabilities = GetCapabilities()
-        End If
-
         Me.ComboBoxBBoxI.SelectedIndex = Me.ComboBoxBBox.SelectedIndex
         GetBBoxValues(Me.ComboBoxBBoxI.SelectedItem)
 
@@ -337,7 +247,7 @@
         F.WriteLine(&quot;StylesUrlPart:     STYLES=&quot;)
         F.WriteLine(&quot;ImageFormatUrlPart:FORMAT=&quot; &amp; Me.ComboBoxFormat.SelectedItem.ToString)
         F.WriteLine(&quot;BoundingBoxTopLeftWGS84: &quot; &amp; maxy &amp; &quot; &quot; &amp; minx)
-        F.WriteLine(&quot;BoundingBoxButtomRightWGS84: &quot; &amp; miny &amp; &quot; &quot; &amp; maxx)
+        F.WriteLine(&quot;BoundingBoxBottomRightWGS84: &quot; &amp; miny &amp; &quot; &quot; &amp; maxx)
         F.WriteLine(&quot;#BBox_Mitte: &quot; &amp; mittey &amp; &quot; &quot; &amp; mittex)
         F.WriteLine(&quot;MinScale:   &quot; &amp; (Math.Ceiling(minScale * 10000) / 10000).ToString(DPunkt))
         F.WriteLine(&quot;MaxScale:   &quot; &amp; (Math.Floor(maxScale * 10000) / 10000).ToString(DPunkt))
@@ -425,7 +335,6 @@
 
     Private Sub TextBoxUrl_TextChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles TextBoxUrl.TextChanged
         GotCapabilities = False
-        Me.ButtonShowMap.Enabled = False
         wmsUrl = Me.TextBoxUrl.Text
         capsUrl = Me.TextBoxUrl.Text
     End Sub
@@ -500,8 +409,6 @@
         Me.TextBoxXML.Text = System.Text.Encoding.UTF8.GetString(ms.GetBuffer())
         ms.Close()
 
-        Me.ButtonShowMap.Enabled = True
-
         '1. Version aus WMT_MS_Capabilities
         For Each nl As XmlNode In xd.GetElementsByTagName(&quot;WMT_MS_Capabilities&quot;)
             If nl.NodeType = XmlNodeType.Element Then
@@ -522,16 +429,22 @@
             End If
         Next
 
+        If Caps Is Nothing Then
+            Return False
+        End If
+
         '2. OnlineResource  aus Service
-        For Each nl As XmlNode In Service
-            If nl.NodeType = XmlNodeType.Element Then
-                If nl.Name = &quot;OnlineResource&quot; Then
-                    Dim ne As XmlElement = nl
-                    OnlineResource = ne.GetAttribute(&quot;xlink:href&quot;)
-                    Exit For
+        If Not Service Is Nothing Then
+            For Each nl As XmlNode In Service
+                If nl.NodeType = XmlNodeType.Element Then
+                    If nl.Name = &quot;OnlineResource&quot; Then
+                        Dim ne As XmlElement = nl
+                        OnlineResource = ne.GetAttribute(&quot;xlink:href&quot;)
+                        Exit For
+                    End If
                 End If
-            End If
-        Next
+            Next
+        End If
 
         Dim Request As XmlElement = Nothing
         Dim Exception As XmlElement = Nothing
@@ -558,7 +471,7 @@
             End If
         Next
         If Layer Is Nothing Then
-            Exit Function
+            Return False
         End If
 
         Dim ltmp() As String
@@ -589,16 +502,6 @@
                 End If
             Next
         Next
-        Me.ComboBoxEPSG.SelectedIndex = -1
-        For i As Integer = 0 To Me.ComboBoxEPSG.Items.Count - 1
-            If Me.ComboBoxEPSG.Items.Item(i) = &quot;4326&quot; Then
-                Me.ComboBoxEPSG.SelectedIndex = i
-                Exit For
-            Else
-                'falls &#252;berhaupt was drin steht
-                Me.ComboBoxEPSG.SelectedIndex = 0
-            End If
-        Next
 
         '11.
         Me.ComboBoxFormat.Items.Clear()
@@ -676,23 +579,45 @@
             If n.NodeType = XmlNodeType.Element Then
                 Dim e As XmlElement = n
                 Dim stmp As String = e.GetAttribute(&quot;SRS&quot;)
-                If Not OBBoxes.ContainsKey(stmp) Then
-                    OBBoxes.Add(stmp, e)
+                If Not stmp = &quot;EPSG:4326&quot; Then
+                    If Not OBBoxes.ContainsKey(stmp) Then
+                        OBBoxes.Add(stmp, e)
+                    End If
                 End If
             End If
         Next
+        '&lt;LatLonBoundingBox minx=&quot;8.334125&quot; miny=&quot;44.552846&quot; maxx=&quot;11.658327&quot; maxy=&quot;46.739748&quot; /&gt;
         If Not OBBoxes.ContainsKey(&quot;EPSG:4326&quot;) Then
             For Each n As XmlNode In Layer.GetElementsByTagName(&quot;LatLonBoundingBox&quot;)
                 If n.NodeType = XmlNodeType.Element Then
                     Dim e As XmlElement = n
-                    Dim stmp As String = e.GetAttribute(&quot;SRS&quot;)
-                    If Not stmp = &quot;&quot; And Not OBBoxes.ContainsKey(stmp) Then
+                    If Not OBBoxes.ContainsKey(&quot;EPSG:4326&quot;) Then
                         OBBoxes.Add(&quot;EPSG:4326&quot;, e)
+                        If Me.ComboBoxEPSG.Items.Count = 0 Then
+                            Dim s As String = &quot;4326&quot;
+                            SRSD.Add(&quot;SRS=EPSG:&quot; &amp; s, &quot; &quot;)
+                            SRS = SRS &amp; &quot;SRS=EPSG:&quot; &amp; s &amp; &quot; &quot;
+                            SRSCW = SRSCW &amp; &quot; &quot; &amp; s
+                            ComboBoxEPSG.Items.Add(s)
+                        End If
                     End If
                 End If
             Next
         End If
 
+        ' 14 Nacharbeiten
+        Me.ComboBoxEPSG.SelectedIndex = -1
+        For i As Integer = 0 To Me.ComboBoxEPSG.Items.Count - 1
+            If Me.ComboBoxEPSG.Items.Item(i) = &quot;4326&quot; Then
+                Me.ComboBoxEPSG.SelectedIndex = i
+                Exit For
+            Else
+                'falls &#252;berhaupt was drin steht
+                Me.ComboBoxEPSG.SelectedIndex = 0
+            End If
+        Next
+
+
         ButtonCheckAll_Click(Nothing, Nothing)
         Return True
 
@@ -709,6 +634,9 @@
         'Dim rminy As Double
         'Dim rmaxx As Double
         'Dim rmaxy As Double
+        If e Is Nothing Then
+            Return
+        End If
         minx = e.GetAttribute(&quot;minx&quot;)
         rminx = Double.Parse(minx, DPunkt.NumberFormat)
         minx = Format(rminx, &quot;0.0000&quot;).Replace(&quot;,&quot;, &quot;.&quot;)
@@ -798,4 +726,12 @@
 
     End Function
 
+    Private Sub ButtonGetCapabilities_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ButtonGetCapabilities.Click
+        GotCapabilities = GetCapabilities()
+        maxScale = 1000
+        minScale = 0
+        If Not recScale Is Nothing Then
+            recScale.Clear()
+        End If
+    End Sub
 End Class

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,5 +1,5 @@
 &#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
-&lt;Project DefaultTargets=&quot;Build&quot; xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot; ToolsVersion=&quot;3.5&quot;&gt;
+&lt;Project DefaultTargets=&quot;Build&quot; xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot; ToolsVersion=&quot;4.0&quot;&gt;
   &lt;PropertyGroup&gt;
     &lt;Configuration Condition=&quot; '$(Configuration)' == '' &quot;&gt;Debug&lt;/Configuration&gt;
     &lt;Platform Condition=&quot; '$(Platform)' == '' &quot;&gt;AnyCPU&lt;/Platform&gt;
@@ -14,10 +14,11 @@
     &lt;ApplicationIcon&gt;gc.ico&lt;/ApplicationIcon&gt;
     &lt;FileUpgradeFlags&gt;
     &lt;/FileUpgradeFlags&gt;
-    &lt;OldToolsVersion&gt;2.0&lt;/OldToolsVersion&gt;
-    &lt;TargetFrameworkVersion&gt;v3.5&lt;/TargetFrameworkVersion&gt;
+    &lt;OldToolsVersion&gt;3.5&lt;/OldToolsVersion&gt;
+    &lt;TargetFrameworkVersion&gt;v4.0&lt;/TargetFrameworkVersion&gt;
     &lt;UpgradeBackupLocation&gt;
     &lt;/UpgradeBackupLocation&gt;
+    &lt;IsWebBootstrapper&gt;false&lt;/IsWebBootstrapper&gt;
     &lt;PublishUrl&gt;publish\&lt;/PublishUrl&gt;
     &lt;Install&gt;true&lt;/Install&gt;
     &lt;InstallFrom&gt;Disk&lt;/InstallFrom&gt;
@@ -30,7 +31,6 @@
     &lt;MapFileExtensions&gt;true&lt;/MapFileExtensions&gt;
     &lt;ApplicationRevision&gt;0&lt;/ApplicationRevision&gt;
     &lt;ApplicationVersion&gt;1.0.0.%2a&lt;/ApplicationVersion&gt;
-    &lt;IsWebBootstrapper&gt;false&lt;/IsWebBootstrapper&gt;
     &lt;UseApplicationTrust&gt;false&lt;/UseApplicationTrust&gt;
     &lt;BootstrapperEnabled&gt;true&lt;/BootstrapperEnabled&gt;
   &lt;/PropertyGroup&gt;
@@ -41,7 +41,7 @@
     &lt;DefineTrace&gt;true&lt;/DefineTrace&gt;
     &lt;OutputPath&gt;bin\Debug\&lt;/OutputPath&gt;
     &lt;DocumentationFile&gt;capxml2wms.xml&lt;/DocumentationFile&gt;
-    &lt;NoWarn&gt;42016,41999,42017,42018,42019,42032,42036,42020,42021,42022&lt;/NoWarn&gt;
+    &lt;NoWarn&gt;42016,41999,42017,42018,42019,42032,42036,42020,42021,42022,42353,42354,42355&lt;/NoWarn&gt;
   &lt;/PropertyGroup&gt;
   &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Release|AnyCPU' &quot;&gt;
     &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
@@ -50,7 +50,7 @@
     &lt;Optimize&gt;true&lt;/Optimize&gt;
     &lt;OutputPath&gt;bin\Release\&lt;/OutputPath&gt;
     &lt;DocumentationFile&gt;capxml2wms.xml&lt;/DocumentationFile&gt;
-    &lt;NoWarn&gt;42016,41999,42017,42018,42019,42032,42036,42020,42021,42022&lt;/NoWarn&gt;
+    &lt;NoWarn&gt;42016,41999,42017,42018,42019,42032,42036,42020,42021,42022,42353,42354,42355&lt;/NoWarn&gt;
   &lt;/PropertyGroup&gt;
   &lt;ItemGroup&gt;
     &lt;Reference Include=&quot;System&quot; /&gt;
@@ -133,7 +133,7 @@
   &lt;ItemGroup&gt;
     &lt;BootstrapperPackage Include=&quot;Microsoft.Net.Client.3.5&quot;&gt;
       &lt;Visible&gt;False&lt;/Visible&gt;
-      &lt;ProductName&gt;.NET Framework Client Profile&lt;/ProductName&gt;
+      &lt;ProductName&gt;.NET Framework 3.5 SP1 Client Profile&lt;/ProductName&gt;
       &lt;Install&gt;false&lt;/Install&gt;
     &lt;/BootstrapperPackage&gt;
     &lt;BootstrapperPackage Include=&quot;Microsoft.Net.Framework.2.0&quot;&gt;

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms/capxml2wms.vbproj.user	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,4 +1,5 @@
-&#239;&#187;&#191;&lt;Project xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
+&#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;Project xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
   &lt;PropertyGroup&gt;
     &lt;PublishUrlHistory&gt;<A HREF="http://localhost/capxml2wms/&lt;/PublishUrlHistory">http://localhost/capxml2wms/&lt;/PublishUrlHistory</A>&gt;
     &lt;InstallUrlHistory&gt;

Modified: branches/r1.2/tools/MakeWMSFile/capxml2wms.sln
===================================================================
--- branches/r1.2/tools/MakeWMSFile/capxml2wms.sln	2011-07-23 10:09:26 UTC (rev 3047)
+++ branches/r1.2/tools/MakeWMSFile/capxml2wms.sln	2011-08-01 18:08:06 UTC (rev 3048)
@@ -1,6 +1,6 @@
 &#239;&#187;&#191;
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual Basic Express 2008
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Basic Express 2010
 Project(&quot;{F184B08F-C81C-45F6-A57F-5ABD9991F28F}&quot;) = &quot;capxml2wms&quot;, &quot;capxml2wms\capxml2wms.vbproj&quot;, &quot;{623B1E12-B5BF-4835-A982-AE5500BFADC8}&quot;
 EndProject
 Global


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="003040.html">[Cachewolf-svn] r3049 - in branches/r1.2/src/CacheWolf: . navi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3039">[ date ]</a>
              <a href="thread.html#3039">[ thread ]</a>
              <a href="subject.html#3039">[ subject ]</a>
              <a href="author.html#3039">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
