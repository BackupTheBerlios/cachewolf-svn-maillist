<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3059 - in trunk/src/CacheWolf: . utils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-August/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3059%20-%20in%20trunk/src/CacheWolf%3A%20.%20utils&In-Reply-To=%3C20110825005940.1997D481462%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003049.html">
   <LINK REL="Next"  HREF="003051.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3059 - in trunk/src/CacheWolf: . utils</H1>
    <B>pfeffer at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3059%20-%20in%20trunk/src/CacheWolf%3A%20.%20utils&In-Reply-To=%3C20110825005940.1997D481462%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3059 - in trunk/src/CacheWolf: . utils">pfeffer at mail.berlios.de
       </A><BR>
    <I>Thu Aug 25 02:59:39 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003049.html">[Cachewolf-svn] r3058 - in trunk/src: . org org/bouncycastle	org/bouncycastle/asn1 org/bouncycastle/asn1/nist	org/bouncycastle/asn1/oiw org/bouncycastle/asn1/pkcs	org/bouncycastle/asn1/sec org/bouncycastle/asn1/teletrust	org/bouncycastle/asn1/x500 org/bouncycastle/asn1/x500/style	org/bouncycastle/asn1/x509 org/bouncycastle/asn1/x9	org/bouncycastle/crypto org/bouncycastle/crypto/agreement	org/bouncycastle/crypto/digests org/bouncycastle/crypto/encodings	org/bouncycastle/crypto/engines	org/bouncycastle/crypto/generators org/bouncycastle/crypto/io	org/bouncycastle/crypto/macs org/bouncycastle/crypto/modes	org/bouncycastle/crypto/params org/bouncycastle/crypto/prng	org/bouncycastle/crypto/signers org/bouncycastle/crypto/tls	org/bouncycastle/crypto/util org/bouncycastle/math	org/bouncycastle/math/ec org/bouncycastle/util	org/bouncycastle/util/encoders org/bouncycastle/util/io
</A></li>
        <LI>Next message: <A HREF="003051.html">[Cachewolf-svn] r3060 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3050">[ date ]</a>
              <a href="thread.html#3050">[ thread ]</a>
              <a href="subject.html#3050">[ subject ]</a>
              <a href="author.html#3050">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pfeffer
Date: 2011-08-25 02:59:39 +0200 (Thu, 25 Aug 2011)
New Revision: 3059

Added:
   trunk/src/CacheWolf/utils/CWPartialInputStream.java
Modified:
   trunk/src/CacheWolf/HttpConnection.java
   trunk/src/CacheWolf/UrlFetcher.java
Log:
Integration of SSL/TLS Library into HttpConnection.java and UrlFetcher.java - just call the methods with &quot;<A HREF="https://">https://</A>&quot; instead of &quot;<A HREF="http://">http://</A>&quot; and SSL/TLS will be negotiated

Modified: trunk/src/CacheWolf/HttpConnection.java
===================================================================
--- trunk/src/CacheWolf/HttpConnection.java	2011-08-25 00:55:34 UTC (rev 3058)
+++ trunk/src/CacheWolf/HttpConnection.java	2011-08-25 00:59:39 UTC (rev 3059)
@@ -1,4 +1,4 @@
-    /*
+/*
     GNU General Public License
     CacheWolf is a software for PocketPC, Win and Linux that
     enables paperless caching.
@@ -22,7 +22,7 @@
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-    */
+ */
 package CacheWolf;
 
 import ewe.data.Property;
@@ -31,11 +31,10 @@
 import ewe.io.FileBase;
 import ewe.io.IOException;
 import ewe.io.IOHandle;
-import ewe.io.IOTransfer;
 import ewe.io.InputStream;
 import ewe.io.MemoryFile;
 import ewe.io.MemoryStream;
-import ewe.io.PartialInputStream;
+import ewe.io.OutputStream;
 import ewe.io.Stream;
 import ewe.io.StreamAdapter;
 import ewe.io.StreamUtils;
@@ -51,6 +50,12 @@
 import ewe.util.Vector;
 import ewe.util.mString;
 
+import org.bouncycastle.crypto.tls.AlwaysValidVerifyer;
+import org.bouncycastle.crypto.tls.TlsProtocolHandler;
+
+import org.bouncycastle.crypto.tls.TlsSocket;
+import CacheWolf.utils.CWPartialInputStream;
+
 /**
 Use this class to create an HttpConnection with a Web Server and to read
 in the data for the connection.&lt;p&gt;
@@ -72,522 +77,561 @@
 &lt;li&gt;Call readInData() with the connected Socket to read in the raw data bytes of the requested
 document or call readInText() to read in and convert the document to text.
 &lt;/ol&gt;
-**/
+ **/
 //##################################################################
 public class HttpConnection {
-//##################################################################
-/**
-* The host to connect to.
-**/
-private String host;
-/**
-* The port to connect to.
-**/
-private int port;
-/**
-* The document to fetch/submit.
-**/
-private String document;
-/**
-* This is the command to be sent to the server. By default it is &quot;GET&quot;. If you call
-* setPostData() and command is &quot;GET&quot; then the command will be replaced by &quot;POST&quot;.
-**/
-private String command = &quot;GET&quot;;
-/**
-* This is the version sent to the server. By default it is &quot;HTTP/1.1&quot;. You could
-* change it to something else if necessary.
-**/
-private String requestVersion = &quot;HTTP/1.1&quot;;
-/**
-* These are the properties that will be sent to the WebServer. These are sent after the
-* initial GET/POST line. This is initially null, so you will have to create a new PropertyList
-* for it, or use one of the setRequestorProperty() or addRequestorProperty() methods.
-**/
-private ewe.data.PropertyList requestorProperties;
-/**
-* This is the list of properties for the server and document. It is only valid after a connection has
-* been made since it is sent by the server to the requestor. One properties that will always be in
-* this list will be &quot;response&quot; (the first line sent by the server in response to the request).
-* All other properties will be as specified by the server, and &lt;b&gt;the property names will be
-* converted to all lowercase letters&lt;/b&gt;.
-**/
-public ewe.data.PropertyList documentProperties;
-/**
-* This is the response code from the server. It is only valid after a connection has
-* been made.
-**/
-public int responseCode;
-/**
-* If the document you supplied is already URL encoded, set this to true.
-**/
-public boolean documentIsEncoded;
-/**
-* Set this to true for keep alive mode requests.
-**/
-private boolean keepAliveMode;
-/**
-* This is the length of the document &lt;b&gt;read in&lt;/b&gt;, valid after a connection call. If it is -1, then the
-* web server has not provided the length of the document.
-**/
-private int contentLength = -1;
-/**
-* This is the codec used when sending data to the server. 
-**/
-private TextCodec textCodec;
+//	##################################################################
+	/**
+	 * The host to connect to.
+	 **/
+	private String host;
+	/**
+	 * The port to connect to.
+	 **/
+	private int port;
 
-private Stream bytesToPost;
-private Object originalPostData;
+	private boolean useSslTls;
+	/**
+	 * The document to fetch/submit.
+	 **/
+	private String document;
+	/**
+	 * This is the command to be sent to the server. By default it is &quot;GET&quot;. If you call
+	 * setPostData() and command is &quot;GET&quot; then the command will be replaced by &quot;POST&quot;.
+	 **/
+	private String command = &quot;GET&quot;;
+	/**
+	 * This is the version sent to the server. By default it is &quot;HTTP/1.1&quot;. You could
+	 * change it to something else if necessary.
+	 **/
+	private String requestVersion = &quot;HTTP/1.1&quot;;
+	/**
+	 * These are the properties that will be sent to the WebServer. These are sent after the
+	 * initial GET/POST line. This is initially null, so you will have to create a new PropertyList
+	 * for it, or use one of the setRequestorProperty() or addRequestorProperty() methods.
+	 **/
+	private ewe.data.PropertyList requestorProperties;
+	/**
+	 * This is the list of properties for the server and document. It is only valid after a connection has
+	 * been made since it is sent by the server to the requestor. One properties that will always be in
+	 * this list will be &quot;response&quot; (the first line sent by the server in response to the request).
+	 * All other properties will be as specified by the server, and &lt;b&gt;the property names will be
+	 * converted to all lowercase letters&lt;/b&gt;.
+	 **/
+	public ewe.data.PropertyList documentProperties;
+	/**
+	 * This is the response code from the server. It is only valid after a connection has
+	 * been made.
+	 **/
+	public int responseCode;
+	/**
+	 * If the document you supplied is already URL encoded, set this to true.
+	 **/
+	public boolean documentIsEncoded;
+	/**
+	 * Set this to true for keep alive mode requests.
+	 **/
+	private boolean keepAliveMode;
+	/**
+	 * This is the length of the document &lt;b&gt;read in&lt;/b&gt;, valid after a connection call. If it is -1, then the
+	 * web server has not provided the length of the document.
+	 **/
+	private int contentLength = -1;
+	/**
+	 * This is the codec used when sending data to the server.
+	 **/
+	private TextCodec textCodec;
 
-/**
- * Set these when the class is instantiated the first time.
- * afterwards you don't need to set proxy parameters anymore
- */
+	private Stream bytesToPost;
+	private Object originalPostData;
 
-private static String proxy = Global.getPref().myproxy;
-private static int proxyPort = Common.parseInt(Global.getPref().myproxyport);
-private static boolean useProxy = Global.getPref().proxyActive;
+	/**
+	 * Set these when the class is instantiated the first time.
+	 * afterwards you don't need to set proxy parameters anymore
+	 */
 
-//FIXME: why is this called immediately from preferences screen? shouldn't we read it from preferences instead?
-public static void setProxy(String proxyi, int proxyporti, boolean useproxyi) {
-	proxy = proxyi;
-	proxyPort = proxyporti;
-	useProxy = useproxyi;
-}
+	private static String proxy = Global.getPref().myproxy;
+	private static int proxyPort = Common.parseInt(Global.getPref().myproxyport);
+	private static boolean useProxy = Global.getPref().proxyActive;
 
-/**
- * This returns true if post data has been set for this connection.
- * FIXME: unreferenced!
- */
-//public boolean hasPostData()
-//{
+//	FIXME: why is this called immediately from preferences screen? shouldn't we read it from preferences instead?
+	public static void setProxy(String proxyi, int proxyporti, boolean useproxyi) {
+		proxy = proxyi;
+		proxyPort = proxyporti;
+		useProxy = useproxyi;
+	}
+
+	/**
+	 * This returns true if post data has been set for this connection.
+	 * FIXME: unreferenced!
+	 */
+//	public boolean hasPostData()
+//	{
 //	return bytesToPost != null;
-//}
-/**
- * Get a new HttpConnection whose parameters are copied from this HttpConnection
- * but which directs its request to a different host/document as directed by
- * a redirect response from an initial request.&lt;p&gt;
- * Note that if this is a POST request and if the post-data source is an InputStream
- * or Stream, then you will need to call setPostData() again to set up the post data
- * for the new connection. Otherwise, the post data will be copied to this device.
- * Call hasPostData() to determine if the post data was copied across successfully.
- * 
- * @param redirectTo the URL that the server instructed the client to redirect to.
- * @return a new HttpConnection with parameters copied from this one.
- */
-public HttpConnection getRedirectedConnection(String redirectTo)
-{
-	HttpConnection c = new HttpConnection(redirectTo);
-	c.keepAliveMode = keepAliveMode;
-	c.contentLength = contentLength;
-	c.getRequestorProperties().set(getRequestorProperties());
-	if (originalPostData != null) c.setPostData(originalPostData);
-	c.documentIsEncoded = documentIsEncoded;
-	c.command = command;
-	c.textCodec = textCodec == null ? null : (TextCodec)textCodec.getCopy();
-	c.requestVersion = requestVersion;
-	return c;
-}
-/**
+//	}
+	/**
+	 * Get a new HttpConnection whose parameters are copied from this HttpConnection
+	 * but which directs its request to a different host/document as directed by
+	 * a redirect response from an initial request.&lt;p&gt;
+	 * Note that if this is a POST request and if the post-data source is an InputStream
+	 * or Stream, then you will need to call setPostData() again to set up the post data
+	 * for the new connection. Otherwise, the post data will be copied to this device.
+	 * Call hasPostData() to determine if the post data was copied across successfully.
+	 *
+	 * @param redirectTo the URL that the server instructed the client to redirect to.
+	 * @return a new HttpConnection with parameters copied from this one.
+	 */
+	public HttpConnection getRedirectedConnection(String redirectTo)
+	{
+		HttpConnection c = new HttpConnection(redirectTo);
+		c.keepAliveMode = keepAliveMode;
+		c.contentLength = contentLength;
+		c.getRequestorProperties().set(getRequestorProperties());
+		if (originalPostData != null) c.setPostData(originalPostData);
+		c.documentIsEncoded = documentIsEncoded;
+		c.command = command;
+		c.textCodec = textCodec == null ? null : (TextCodec)textCodec.getCopy();
+		c.requestVersion = requestVersion;
+		return c;
+	}
+	/**
 Returns the requestor properties. These are the property commands sent to the server when the
 connection is made. You can add directly to this OR you can call setRequestorProperty() or
 addRequestorProperty();
- */
-//===================================================================
-private PropertyList getRequestorProperties()
-//===================================================================
-{
-	if (requestorProperties == null) requestorProperties = new PropertyList();
-	return requestorProperties;
-}
-/**
- * Set the data to post out as either a Stream, InputStream,byte[],ByteArray or String.
- * If the data is a Stream or InputStream then you must also call setPostDataLength() 
- * which in turn sets the &quot;Content-Length&quot; property of the requestor properties - otherwise
- * if &quot;Content-Length&quot; is not already set it will be set to the length of the byte[] or ByteArray.
- * @param data the data to post either as a Stream, InputStream, byte[] or ByteArray
- */
-//===================================================================
-public void setPostData(Object data)
-//===================================================================
-{
-	if (data instanceof Stream) bytesToPost = (Stream)data;
-	else if (data instanceof ByteArray) {
-		originalPostData = data;
-		bytesToPost = new MemoryFile((ByteArray)data);
-		getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((ByteArray)data).length));
+	 */
+//	===================================================================
+	private PropertyList getRequestorProperties()
+//	===================================================================
+	{
+		if (requestorProperties == null) requestorProperties = new PropertyList();
+		return requestorProperties;
 	}
-	else if (data instanceof byte[]) {
-		originalPostData = data;
-		bytesToPost = new MemoryFile(new ByteArray((byte[])data));
-		getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((byte[])data).length));
-	}else if (data instanceof String){
-		String s = (String)data;
-		TextCodec td = textCodec;
-		if (td == null) td = new AsciiCodec();
-		try{
-			ByteArray got = td.encodeText(Vm.getStringChars(s),0,s.length(),true,null);
-			setPostData(got.toBytes());
-		}catch(IOException e){
-			// Global.getPref().log(&quot;Ignored exception&quot;, e, true);
+	/**
+	 * Set the data to post out as either a Stream, InputStream,byte[],ByteArray or String.
+	 * If the data is a Stream or InputStream then you must also call setPostDataLength()
+	 * which in turn sets the &quot;Content-Length&quot; property of the requestor properties - otherwise
+	 * if &quot;Content-Length&quot; is not already set it will be set to the length of the byte[] or ByteArray.
+	 * @param data the data to post either as a Stream, InputStream, byte[] or ByteArray
+	 */
+//	===================================================================
+	public void setPostData(Object data)
+//	===================================================================
+	{
+		if (data instanceof Stream) bytesToPost = (Stream)data;
+		else if (data instanceof ByteArray) {
+			originalPostData = data;
+			bytesToPost = new MemoryFile((ByteArray)data);
+			getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((ByteArray)data).length));
 		}
+		else if (data instanceof byte[]) {
+			originalPostData = data;
+			bytesToPost = new MemoryFile(new ByteArray((byte[])data));
+			getRequestorProperties().defaultTo(&quot;Content-Length&quot;,Convert.toString(((byte[])data).length));
+		}else if (data instanceof String){
+			String s = (String)data;
+			TextCodec td = textCodec;
+			if (td == null) td = new AsciiCodec();
+			try{
+				ByteArray got = td.encodeText(Vm.getStringChars(s),0,s.length(),true,null);
+				setPostData(got.toBytes());
+			}catch(IOException e){
+				// Global.getPref().log(&quot;Ignored exception&quot;, e, true);
+			}
+		}
+		else if (data instanceof InputStream) bytesToPost = new StreamAdapter((InputStream)data);
+		if (bytesToPost != null &amp;&amp; command.equalsIgnoreCase(&quot;get&quot;))
+			command = &quot;POST&quot;;
 	}
-	else if (data instanceof InputStream) bytesToPost = new StreamAdapter((InputStream)data);
-	if (bytesToPost != null &amp;&amp; command.equalsIgnoreCase(&quot;get&quot;))
-		command = &quot;POST&quot;;
-}
-/**
- * This sets the &quot;Content-Length&quot; requestor property to be the specified length.
- * @param length the number of bytes to be posted.
- * FIXME: not referenced
- */
-//===================================================================
-//public void setPostDataLength(int length)
-////===================================================================
-//{
+	/**
+	 * This sets the &quot;Content-Length&quot; requestor property to be the specified length.
+	 * @param length the number of bytes to be posted.
+	 * FIXME: not referenced
+	 */
+//	===================================================================
+//	public void setPostDataLength(int length)
+////	===================================================================
+//	{
 //	getRequestorProperties().set(&quot;Content-Length&quot;,Convert.toString(length));
-//}
-/**
- * Set an exclusive requestor property. These are sent to the web server after the initial request line.
- * @param name The name of the property.
- * @param property The value of the property.
- */
-//===================================================================
-public void setRequestorProperty(String name, String property)
-//===================================================================
-{
-	getRequestorProperties().set(name,property);
-}
-public void setRequestorProperty(PropertyList pl)
-//===================================================================
-{
-	getRequestorProperties().set(pl);
-}
-/**
- * Add a non-exclusive requestor property. These are sent to the web server after the initial request line.
- * @param name The name of the property.
- * @param property The value of the property.
- * FIXME: not referenced
- */
-////===================================================================
-//public void addRequestorProperty(String name, String property)
-////===================================================================
-//{
+//	}
+	/**
+	 * Set an exclusive requestor property. These are sent to the web server after the initial request line.
+	 * @param name The name of the property.
+	 * @param property The value of the property.
+	 */
+//	===================================================================
+	public void setRequestorProperty(String name, String property)
+//	===================================================================
+	{
+		getRequestorProperties().set(name,property);
+	}
+	public void setRequestorProperty(PropertyList pl)
+//	===================================================================
+	{
+		getRequestorProperties().set(pl);
+	}
+	/**
+	 * Add a non-exclusive requestor property. These are sent to the web server after the initial request line.
+	 * @param name The name of the property.
+	 * @param property The value of the property.
+	 * FIXME: not referenced
+	 */
+////	===================================================================
+//	public void addRequestorProperty(String name, String property)
+////	===================================================================
+//	{
 //	getRequestorProperties().add(name,property);
-//}
-/**
- * Set the default value of a requestor property. If the value is already set
- * this will have no effect. Otherwise the value will be set to defaultValue.
- * @param name the name of the property.
- * @param defaultValue the value to default to.
- * FIXME: not referenced
- */
-//public void defaultRequestorProperty(String name, String defaultValue)
-//{
+//	}
+	/**
+	 * Set the default value of a requestor property. If the value is already set
+	 * this will have no effect. Otherwise the value will be set to defaultValue.
+	 * @param name the name of the property.
+	 * @param defaultValue the value to default to.
+	 * FIXME: not referenced
+	 */
+//	public void defaultRequestorProperty(String name, String defaultValue)
+//	{
 //	getRequestorProperties().defaultTo(name,defaultValue);
-//}
-protected Socket openSocket;
-protected Socket connectedSocket;
+//	}
+	protected TlsSocket openSocket;
+	protected TlsSocket connectedSocket;
 
-/**
-* If a connection has already been made to the server, then you can call
-* this method and the HttpConnection protocol will be done over this Socket.
-* @param sock The already connected socket.
-* FIXME: not referenced
-*/
-////===================================================================
-//public void setAlreadyOpenSocket(Socket sock)
-////===================================================================
-//{	
+	/**
+	 * If a connection has already been made to the server, then you can call
+	 * this method and the HttpConnection protocol will be done over this Socket.
+	 * @param sock The already connected socket.
+	 * FIXME: not referenced
+	 */
+////	===================================================================
+//	public void setAlreadyOpenSocket(Socket sock)
+////	===================================================================
+//	{
 //	openSocket = sock;
-//}
+//	}
 
-/**
- * Create a new HttpConnection to the specified host and port to fetch the specified document.
- * @param host The host to connect to.
- * @param port The port to connect on.
- * @param document the document to get.
- * FIXME: not referenced
- */
-////===================================================================
-//public HttpConnection(String host, int port, String document)
-////===================================================================
-//{
+	/**
+	 * Create a new HttpConnection to the specified host and port to fetch the specified document.
+	 * @param host The host to connect to.
+	 * @param port The port to connect on.
+	 * @param document the document to get.
+	 * FIXME: not referenced
+	 */
+////	===================================================================
+//	public HttpConnection(String host, int port, String document)
+////	===================================================================
+//	{
 //	this.host = host;
 //	this.port = port;
 //	this.document = document;
-//}
-/**
- * Create an HttpConnection with an <A HREF="http://">http://</A> URL.
- * @param url The full url, starting with <A HREF="http://">http://</A>
- */
-//===================================================================
-public HttpConnection(String url)
-//===================================================================
-{
-	setUrl(url);
-}
-public void setUrl(String url)
-{
-	if (useProxy) { 
-		host = proxy;
-		port = proxyPort;
-		document = url;
-	} else {
-		url = FileBase.fixupPath(url);
-		port = 80;
-		String uu = url.toLowerCase();
-		if (uu.startsWith(&quot;<A HREF="http://">http://</A>&quot;)){
-			uu = url.replace('\\','/');
-			host = uu.substring(7);
-			int first = host.indexOf('/');
-			if (first == -1) document = &quot;/&quot;;
-			else {
-				document = host.substring(first);
-				host = host.substring(0,first);
+//	}
+	/**
+	 * Create an HttpConnection with an <A HREF="http://">http://</A> URL.
+	 * @param url The full url, starting with <A HREF="http://">http://</A>
+	 */
+//	===================================================================
+	public HttpConnection(String url)
+//	===================================================================
+	{
+		setUrl(url);
+	}
+	public void setUrl(String url)
+	{
+		if (useProxy) {
+			host = proxy;
+			port = proxyPort;
+			document = url;
+		} else {
+			url = FileBase.fixupPath(url);
+			port = 80;
+			String uu = url.toLowerCase();
+			if (uu.startsWith(&quot;<A HREF="https://">https://</A>&quot;)) {
+				useSslTls = true;
+				port = 443;
+				uu = &quot;<A HREF="http://">http://</A>&quot; + uu.substring(8);
+			} else useSslTls = false;
+			if (uu.startsWith(&quot;<A HREF="http://">http://</A>&quot;)){
+				uu = uu.replace('\\','/');
+				host = uu.substring(7);
+				int first = host.indexOf('/');
+				if (first == -1) document = &quot;/&quot;;
+				else {
+					document = host.substring(first);
+					host = host.substring(0,first);
+				}
+				int colon = host.indexOf(':');
+				if (colon != -1){
+					port = ewe.sys.Convert.toInt(host.substring(colon+1));
+					host = host.substring(0,colon);
+				}
 			}
-			int colon = host.indexOf(':');
-			if (colon != -1){
-				port = ewe.sys.Convert.toInt(host.substring(colon+1));
-				host = host.substring(0,colon);
-			}
 		}
+		getRequestorProperties().clear();
+		command = &quot;GET&quot;;
 	}
-	getRequestorProperties().clear();
-	command = &quot;GET&quot;;
-}
 
-//FIXME: never referenced
-////===================================================================
-//public HttpConnection(URL url)
-////===================================================================
-//{
+//	FIXME: never referenced
+////	===================================================================
+//	public HttpConnection(URL url)
+////	===================================================================
+//	{
 //	this(url.toString());
 //	documentIsEncoded = true;
-//}
-//private static char [] space = {' '}, percentSpace = {'%','2','0'};
+//	}
+//	private static char [] space = {' '}, percentSpace = {'%','2','0'};
 
-// FIXME: never referenced
-////===================================================================
-//public String toURLString()
-////===================================================================
-//{
+//	FIXME: never referenced
+////	===================================================================
+//	public String toURLString()
+////	===================================================================
+//	{
 //	return &quot;<A HREF="http://">http://</A>&quot;+host+&quot;:&quot;+port+document;
-//}
-//===================================================================
-private String getEncodedDocument()
-//===================================================================
-{
-	if (documentIsEncoded) return document;
-	else return URL.encodeURL(document,false);
-}
-//===================================================================
-private Object waitOnIO(Handle h,String errorMessage) throws IOException
-//===================================================================
-{
-	try{
-		h.waitOn(Handle.Success);
-		return h.returnValue;
-	}catch(Exception e){
-		if (h.errorObject instanceof IOException) throw (IOException)h.errorObject;
-		else throw new IOException(errorMessage);
+//	}
+//	===================================================================
+	private String getEncodedDocument()
+//	===================================================================
+	{
+		if (documentIsEncoded) return document;
+		else return URL.encodeURL(document,false);
 	}
-}
-private static final int SocketConnected = 0x1;
-// never referenced
-//private static final int DataReady = 0x2;
+//	===================================================================
+	private Object waitOnIO(Handle h,String errorMessage) throws IOException
+//	===================================================================
+	{
+		try{
+			h.waitOn(Handle.Success);
+			return h.returnValue;
+		}catch(Exception e){
+			if (h.errorObject instanceof IOException) throw (IOException)h.errorObject;
+			else throw new IOException(errorMessage);
+		}
+	}
+	private static final int SocketConnected = 0x1;
+//	never referenced
+//	private static final int DataReady = 0x2;
 
-private static Vector lines;
-private static SubString data;
+	private static Vector lines;
+	private static SubString data;
 
-//===================================================================
-private int makeRequest(Socket sock,TextCodec td) throws IOException
-//===================================================================
-{
-	responseCode = -1;
-	if (td == null) td = textCodec;
-	if (td == null) td = new AsciiCodec();
-	PropertyList pl = new PropertyList();
-	if (requestorProperties != null) pl.set(requestorProperties);
-	pl.defaultTo(&quot;Connection&quot;,&quot;close&quot;);
-	pl.defaultTo(&quot;Host&quot;,host);
-	StringBuffer sb = new StringBuffer();
-	sb.append(command+&quot; &quot;+getEncodedDocument()+&quot; &quot;+requestVersion+&quot;\r\n&quot;);
-	for (int i = 0; i&lt;pl.size(); i++){
-		Property p = (Property)pl.get(i);
-		if (p.value != null) sb.append(p.name+&quot;: &quot;+p.value+&quot;\r\n&quot;);
-	}
-	sb.append(&quot;\r\n&quot;);
-	String req = sb.toString();
-	char [] rc = ewe.sys.Vm.getStringChars(req);
-	ByteArray ba = ((TextCodec)td.getCopy()).encodeText(rc,0,rc.length,true,null);
-	sock.write(ba.data,0,ba.length);
-	sock.flush();
-	//
-	if (bytesToPost != null){
-		IOTransfer iot = new IOTransfer();
-		iot.transfer(bytesToPost,sock);
-		sock.flush();
-		bytesToPost.close();
-		/*
+//	===================================================================
+	private int makeRequest(InputStream is, OutputStream os,TextCodec td) throws IOException
+//	===================================================================
+	{
+		responseCode = -1;
+		if (td == null) td = textCodec;
+		if (td == null) td = new AsciiCodec();
+		PropertyList pl = new PropertyList();
+		if (requestorProperties != null) pl.set(requestorProperties);
+		pl.defaultTo(&quot;Connection&quot;,&quot;close&quot;);
+		pl.defaultTo(&quot;Host&quot;,host);
+		StringBuffer sb = new StringBuffer();
+		sb.append(command+&quot; &quot;+getEncodedDocument()+&quot; &quot;+requestVersion+&quot;\r\n&quot;);
+		for (int i = 0; i&lt;pl.size(); i++){
+			Property p = (Property)pl.get(i);
+			if (p.value != null) sb.append(p.name+&quot;: &quot;+p.value+&quot;\r\n&quot;);
+		}
+		sb.append(&quot;\r\n&quot;);
+		String req = sb.toString();
+		char [] rc = ewe.sys.Vm.getStringChars(req);
+		ByteArray ba = ((TextCodec)td.getCopy()).encodeText(rc,0,rc.length,true,null);
+		os.write(ba.data,0,ba.length);
+		os.flush();
+		//
+		if (bytesToPost != null){
+//			IOTransfer iot = new IOTransfer();
+//			iot.transfer(bytesToPost,sock);
+			transfer(bytesToPost,os);
+			os.flush();
+			bytesToPost.close();
+			/*
 		// For debugging - output eol and a blank line.
 		byte[] ret = new byte[]{(byte)'\r',(byte)'\n'};
 		sock.write(ret);
 		sock.write(ret);
 		sock.flush();
-		*/
-	}
-	//
-	int lastReceived = -1;
-	//
-	ba.clear();
-	while(true){
-		int got = sock.read();
-		if (got == -1) throw new IOException(&quot;Unexpected end of stream.&quot;);
-		if (got == 10){
-			if (lastReceived == 10) break; //Got all the data now.
-		}else if (got == 13) continue; //Ignore CR.
-		ba.append((byte)got);
-		lastReceived = got;
-	}
-	//
-	CharArray all = ((TextCodec)td.getCopy()).decodeText(ba.data,0,ba.length,true,null);
-	if (data == null){
-		data = new SubString();
-		lines = new Vector();
-	}
-	data.set(all.data,0,all.length);
-	int got = data.split('\n',lines);
-	documentProperties = new ewe.data.PropertyList();
-	if (got == 0) throw new IOException(&quot;No response&quot;);
+			 */
+		}
+		//
+		int lastReceived = -1;
+		//
+		ba.clear();
+		while(true){
+			int got = is.read();
+			if (got == -1) throw new IOException(&quot;Unexpected end of stream.&quot;);
+			if (got == 10){
+				if (lastReceived == 10) break; //Got all the data now.
+			}else if (got == 13) continue; //Ignore CR.
+			ba.append((byte)got);
+			lastReceived = got;
+		}
+		//
+		CharArray all = ((TextCodec)td.getCopy()).decodeText(ba.data,0,ba.length,true,null);
+		if (data == null){
+			data = new SubString();
+			lines = new Vector();
+		}
+		data.set(all.data,0,all.length);
+		int got = data.split('\n',lines);
+		documentProperties = new ewe.data.PropertyList();
+		if (got == 0) throw new IOException(&quot;No response&quot;);
 
 
-	String response = lines.get(0).toString();
-	documentProperties.set(&quot;response&quot;,response);
-	{
-		int idx = response.indexOf(' ');
-		if (idx != -1){
-			int id2 = response.indexOf(' ',idx+1);
-			if (id2 != -1){
-				responseCode = ewe.sys.Convert.toInt(response.substring(idx+1,id2));
+		String response = lines.get(0).toString();
+		documentProperties.set(&quot;response&quot;,response);
+		{
+			int idx = response.indexOf(' ');
+			if (idx != -1){
+				int id2 = response.indexOf(' ',idx+1);
+				if (id2 != -1){
+					responseCode = ewe.sys.Convert.toInt(response.substring(idx+1,id2));
+				}
 			}
 		}
+		for (int i = 1; i&lt;got; i++){
+			String s = lines.get(i).toString();
+			int idx = s.indexOf(':');
+			if (idx == -1) continue;
+			String name = s.substring(0,idx).trim().toLowerCase();
+			String value = s.substring(idx+1).trim();
+			documentProperties.add(name,value);
+		}
+		contentLength = documentProperties.getInt(&quot;content-length&quot;,-1);
+		return responseCode;
 	}
-	for (int i = 1; i&lt;got; i++){
-		String s = lines.get(i).toString();
-		int idx = s.indexOf(':');
-		if (idx == -1) continue;
-		String name = s.substring(0,idx).trim().toLowerCase();
-		String value = s.substring(idx+1).trim();
-		documentProperties.add(name,value);
-	}
-	contentLength = documentProperties.getInt(&quot;content-length&quot;,-1);
-	return responseCode;
-}
 
-private static final String [] encodings = {&quot;transfer-coding&quot;,&quot;transfer-encoding&quot;};
-private byte [] buffer;
+	private static final String [] encodings = {&quot;transfer-coding&quot;,&quot;transfer-encoding&quot;};
+	private byte [] buffer;
 
+	/**
+	 * Copy from the &quot;in&quot; stream to the &quot;out&quot; stream. The streams are NOT closed.
+	 **/
+//	===================================================================
+	public void transfer(Stream in, OutputStream out) throws IOException
+//	===================================================================
+	{
+		int bufferSize = 1;
+		byte [] buff = new byte[bufferSize];
+		while(true){
+			/**
+			 * This readBytes method will block the current Coroutine until at
+			 * least one byte is read. It will let other Coroutines run if it
+			 * has to wait.
+			 **/
+			int read = in.read(buff,0,buff.length);
+			if (read == -1) break;
+			if (read == 0) continue;
+			/**
+			 * This writeBytes method will block the current Coroutine until
+			 * all bytes are written. It will let other Coroutines run if it
+			 * has to wait.
+			 **/
+			out.write(buff,0,read);
+			// copied += read;
+			/**
+			 * Allow other threads to have some time to execute.
+			 **/
+		}
+		out.flush();
+	}
 
 
-/**
- * Call this after a successful connection. If the server requested a redirect (a 3xx code) then
- * this will return an HttpConnection to the new location which you can connect to again. You must
- * setup any post data or requestor properties again before re-connecting.
- * Alternatively you could also call getRedirectTo() and then if that returns a non-null
- * String, you can call getRedirectedConnection() to get copies.
- * If there is no redirection required or possible the method will return this same HttpConnection.
- * 
- * FIXME: never referenced
- */
-////===================================================================
-//public HttpConnection redirectTo()
-////===================================================================
-//{
+	/**
+	 * Call this after a successful connection. If the server requested a redirect (a 3xx code) then
+	 * this will return an HttpConnection to the new location which you can connect to again. You must
+	 * setup any post data or requestor properties again before re-connecting.
+	 * Alternatively you could also call getRedirectTo() and then if that returns a non-null
+	 * String, you can call getRedirectedConnection() to get copies.
+	 * If there is no redirection required or possible the method will return this same HttpConnection.
+	 *
+	 * FIXME: never referenced
+	 */
+////	===================================================================
+//	public HttpConnection redirectTo()
+////	===================================================================
+//	{
 //	if (responseCode &lt; 300 || responseCode &gt; 399) return this;
 //	String newURL = documentProperties.getString(&quot;location&quot;,null);
 //	if (newURL == null) return this;
 //	return new HttpConnection(newURL);
-//}					
+//	}
 
-/**
- * Call this after a success connection. If it returns a non-null String then
- * you need to redirect the connection to the new location. If this returns non-null
- * you can call getRedirectedConnection() to get a new HttpConnection that you can
- * use to redirect the connection without having to setup the connection parameters
- * again.
- * @return null if no redirection is needed, otherwise the location directed to.
- */
-public String getRedirectTo()
-{
-	if (responseCode &lt; 300 || responseCode &gt; 399) return null;
-	return documentProperties.getString(&quot;location&quot;,null);
-}
-//===================================================================
-private int readInChunkedHeader(Socket connection,ByteArray buff,CharArray chBuff) throws IOException
-//===================================================================
-{
- 	if (buffer == null) buffer = new byte[10240];
-	if (buff == null) buff = new ByteArray();
-	buff.clear();
-	while(true){
-		int got = connection.read();
-		if (got == -1) throw new IOException();
-		if (got == '\n') break;
-		buff.append((byte)got);
+	/**
+	 * Call this after a success connection. If it returns a non-null String then
+	 * you need to redirect the connection to the new location. If this returns non-null
+	 * you can call getRedirectedConnection() to get a new HttpConnection that you can
+	 * use to redirect the connection without having to setup the connection parameters
+	 * again.
+	 * @return null if no redirection is needed, otherwise the location directed to.
+	 */
+	public String getRedirectTo()
+	{
+		if (responseCode &lt; 300 || responseCode &gt; 399) return null;
+		return documentProperties.getString(&quot;location&quot;,null);
 	}
-	chBuff = new AsciiCodec().decodeText(buff.data,0,buff.length,true,chBuff);
-	String s = new String(chBuff.data,0,chBuff.length);
-	String length = mString.leftOf(s,';').trim().toUpperCase();
-	int clen = 0;
-	for (int i = 0; i&lt;length.length(); i++){
-		char c = length.charAt(i);
-		clen *= 16;
-		clen += c &lt;= '9' ? c-'0' : c-'A'+10;
+//	===================================================================
+	private int readInChunkedHeader(InputStream connection,ByteArray buff,CharArray chBuff) throws IOException
+//	===================================================================
+	{
+		if (buffer == null) buffer = new byte[10240];
+		if (buff == null) buff = new ByteArray();
+		buff.clear();
+		while(true){
+			int got = connection.read();
+			if (got == -1) throw new IOException();
+			if (got == '\n') break;
+			buff.append((byte)got);
+		}
+		chBuff = new AsciiCodec().decodeText(buff.data,0,buff.length,true,chBuff);
+		String s = new String(chBuff.data,0,chBuff.length);
+		String length = mString.leftOf(s,';').trim().toUpperCase();
+		int clen = 0;
+		for (int i = 0; i&lt;length.length(); i++){
+			char c = length.charAt(i);
+			clen *= 16;
+			clen += c &lt;= '9' ? c-'0' : c-'A'+10;
+		}
+		return clen;
 	}
-	return clen;
-}
-/**
- * Read in all the data from the Socket.
- * @param connection The socket returned by a connect() call.
- * @return A Handle with which you can monitor the connection. When the Handle
+	/**
+	 * Read in all the data from the Socket.
+	 * @param connection The Inputstream returned by a connect() call.
+	 * @return A Handle with which you can monitor the connection. When the Handle
 	reports Success, then the returnValue of the Handle will be a ewe.util.ByteArray
 	object that holds the data read in.
- */
-//===================================================================
-private Handle readInData(final Socket connection) 
-//===================================================================
-{
-	int length = documentProperties.getInt(&quot;content-length&quot;,-1);
-	if (length == 0)
-		return new Handle(Handle.Succeeded,new ByteArray());
-	getInputStream();
-	return StreamUtils.readAllBytes(getInputStream(),null,length,0);
-}
-/**
- * Read in all the data from the Socket.
- * @return A Handle with which you can monitor the connection. When the Handle
+	 */
+//	===================================================================
+	private Handle readInData(final InputStream connection)
+//	===================================================================
+	{
+		int length = documentProperties.getInt(&quot;content-length&quot;,-1);
+		if (length == 0)
+			return new Handle(Handle.Succeeded,new ByteArray());
+		getInputStream();
+		return StreamUtils.readAllBytes(getInputStream(),null,length,0);
+	}
+	/**
+	 * Read in all the data from the Socket.
+	 * @return A Handle with which you can monitor the connection. When the Handle
 	reports Success, then the returnValue of the Handle will be a ewe.util.ByteArray
 	object that holds the data read in.
-	
+
 	FIXME: never referenced
- */
-//===================================================================
-public Handle readInData() 
-//===================================================================
-{
-	return readInData(connectedSocket);
-}
-/**
-* Get an InputStream to read in the data. This is a very important method as it is used by
-* the readInData() method.
-**/
-//===================================================================
-private InputStream getInputStream()
-//===================================================================
-{
-	int length = documentProperties.getInt(&quot;content-length&quot;,-1);
-	if (&quot;chunked&quot;.equals(documentProperties.getValue(encodings,null)))
-		return new MemoryStream(true){
+	 */
+//	===================================================================
+	public Handle readInData()
+//	===================================================================
+	{
+		return readInData(connectedSocket.inputStream);
+	}
+	/**
+	 * Get an InputStream to read in the data. This is a very important method as it is used by
+	 * the readInData() method.
+	 **/
+//	===================================================================
+	private InputStream getInputStream()
+//	===================================================================
+	{
+		int length = documentProperties.getInt(&quot;content-length&quot;,-1);
+		if (&quot;chunked&quot;.equals(documentProperties.getValue(encodings,null)))
+			return new MemoryStream(true){
 			private byte[] buff = new byte[10240];
 			private int leftInBlock = 0;
 			private ByteArray ba = new ByteArray();
@@ -597,18 +641,18 @@
 			//-------------------------------------------------------------------
 			{
 				if (leftInBlock &lt;= 0){
-					leftInBlock = readInChunkedHeader(connectedSocket,ba,ca);
+					leftInBlock = readInChunkedHeader(connectedSocket.inputStream,ba,ca);
 					if (leftInBlock &lt;= 0) return false;
 				}
 				int toRead = leftInBlock;
 				if (toRead &gt; buff.length) toRead = buff.length;
-				int got = connectedSocket.read(buff,0,toRead);
+				int got = connectedSocket.inputStream.read(buff,0,toRead);
 				if (got == -1) throw new IOException();
 				leftInBlock -= got;
 				putInBuffer(buff,0,got);
 				if (leftInBlock == 0){
 					while(true){
-						got = connectedSocket.read();
+						got = connectedSocket.inputStream.read();
 						if (got == -1) throw new IOException();
 						if (got == '\n') break;
 					}
@@ -617,36 +661,39 @@
 			}
 		}.toInputStream();
 		//throw new IOException(&quot;Cannot get input stream from this!&quot;);
-	else return 
-		new PartialInputStream(connectedSocket,length).toInputStream();
-}
-/**
- * Read in the document body from the Socket. This method blocks until the complete
- * data is read in. readInData() is a non-blocking version.
- * @param connection The socket returned by a connect() call.
- * @return A ByteArray containing the read in data.
- */
+		else return
+		new CWPartialInputStream(connectedSocket.inputStream,length).toInputStream();
+	}
+	/**
+	 * Read in the document body from the Socket. This method blocks until the complete
+	 * data is read in. readInData() is a non-blocking version.
+	 * @param connection The socket returned by a connect() call.
+	 * @return A ByteArray containing the read in data.
+	 */
+	/*
 //===================================================================
 public ByteArray readData(Socket connection) throws IOException
 //===================================================================
 {
 	return (ByteArray)waitOnIO(readInData(connection),&quot;Error reading data.&quot;);
 }
-public ByteArray readData() throws IOException
-//===================================================================
-{
-	return (ByteArray)waitOnIO(readInData(openSocket),&quot;Error reading data.&quot;);
-}
-/**
- * Read in all the data from the Socket, converting it to text using the specified
- * codec. 
- * @param connection The socket returned by a connect() call.
- * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
- * this is null then a simple Ascii codec will be used.
- * @return A Handle with which you can monitor the connection. When the Handle
+	 */
+	public ByteArray readData() throws IOException
+//	===================================================================
+	{
+		return (ByteArray)waitOnIO(readInData(openSocket.inputStream),&quot;Error reading data.&quot;);
+	}
+	/**
+	 * Read in all the data from the Socket, converting it to text using the specified
+	 * codec.
+	 * @param connection The socket returned by a connect() call.
+	 * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
+	 * this is null then a simple Ascii codec will be used.
+	 * @return A Handle with which you can monitor the connection. When the Handle
 	reports Success, then the returnValue of the Handle will be a ewe.util.CharArray
 	object that holds the text read in.
- */
+	 */
+	/*
 //===================================================================
 private Handle readInText(final Socket connection,TextCodec documentTextDecoder)
 //===================================================================
@@ -668,109 +715,115 @@
 		}
 	}.startTask();
 }
-/**
- * Read in the document body from the Socket. This method blocks until the complete
- * data is read in. readInText() is a non-blocking version.
- * @param connection The socket returned by a connect() call.
- * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
- * this is null then a simple Ascii codec will be used.
- * @return A CharArray containing the text that was read in.
- */
+	 */
+	/**
+	 * Read in the document body from the Socket. This method blocks until the complete
+	 * data is read in. readInText() is a non-blocking version.
+	 * @param connection The socket returned by a connect() call.
+	 * @param documentTextDecoder The text codec to use to convert the bytes read in into text. If
+	 * this is null then a simple Ascii codec will be used.
+	 * @return A CharArray containing the text that was read in.
+	 */
+	/*
 //===================================================================
 public CharArray readText(Socket connection,TextCodec documentTextDecoder) throws IOException
 //===================================================================
 {
 	return (CharArray)waitOnIO(readInText(connection,documentTextDecoder),&quot;Error reading data.&quot;);
 }
-/**
- * Connect asynchronously. This makes the connection, sends the request and requestor properties
- * reads in the reply and server properties and then returns the connected Socket ready for
- * for reading in the actual data.
- * @return A Handle used to monitor the connection. When the Handle reports a state of
- * Success, then the returnValue of the IOHandle will hold the connected socket.
- */
-//===================================================================
-public Handle connectAsync()
-//===================================================================
-{
-	return connectAsync(new AsciiCodec());
-}
-/**
- * Connect asynchronously. This makes the connection, sends the request and requestor properties
- * reads in the reply and server properties and then returns the connected Socket ready for
- * for reading in the actual data.
- * @param serverTextDecoder The text decoder to convert the server and requestor properties data into text.
- * @return A Handle used to monitor the connection. When the Handle reports a state of
- * Success, then the returnValue of the Handle will hold the connected socket.
- */
-//===================================================================
-private Handle connectAsync(final TextCodec serverTextDecoder)
-//===================================================================
-{
-	return new ewe.sys.TaskObject(){
-		protected void doRun(){
-			while(true){
-			//
-			// Create a Socket using an IOHandle.
-			//
-			Handle sh;
-			Socket sock;
-			if (openSocket != null) {
-				sh = new Handle(Handle.Succeeded,openSocket);
-				sock = openSocket;
-			}
-			else {
-				sh = new IOHandle();
-				sock = new Socket(host,port,(IOHandle)sh);
-				// openSocket = sock;
-			}
-			// Handle sh = (openSocket != null) ? new Handle(Handle.Succeeded,openSocket) : new IOHandle();
-			// Socket sock = (openSocket != null) ? openSocket : new Socket(host,port,(IOHandle)sh);
-			try{
-				//
-				// Now wait until connected.
-				//
-				if (!waitOnSuccess(sh,true)) return;
-				//
-				// Report that the socket connection was made.
-				// Now have to decode the data.
-				//
-				handle.setFlags(SocketConnected,0);
-				//
-				makeRequest(sock,serverTextDecoder);
-				handle.returnValue = connectedSocket = sock;
-				handle.setFlags(Handle.Success,0);
-				return;
-			}catch(Exception e){
-				if (openSocket == null){
-					handle.failed(e);
-					return;
-				}else{
-					openSocket = null;
-					continue;
-				}
-			}
-		}}
-	}.startTask();
-}
-/**
- * This makes the connection, blocking the current thread.
- * @return A Socket that you can read the data from. The document properties will be in
- * the document properties list.
- * @exception IOException if there was an error connecting or getting the data.
- */
-public Socket connect() throws IOException {
-	openSocket = (Socket)waitOnIO(connectAsync(),&quot;Could not connect.&quot;);
-	return openSocket;
-}
-public void disconnect() {
-	if (openSocket.isOpen()) {
-		openSocket.close(); // releases the handles of the system
+	 */
+	/**
+	 * Connect asynchronously. This makes the connection, sends the request and requestor properties
+	 * reads in the reply and server properties and then returns the connected Socket ready for
+	 * for reading in the actual data.
+	 * @return A Handle used to monitor the connection. When the Handle reports a state of
+	 * Success, then the returnValue of the IOHandle will hold the connected socket.
+	 */
+//	===================================================================
+	public Handle connectAsync()
+//	===================================================================
+	{
+		return connectAsync(new AsciiCodec());
 	}
+	/**
+	 * Connect asynchronously. This makes the connection, sends the request and requestor properties
+	 * reads in the reply and server properties and then returns the connected Socket ready for
+	 * for reading in the actual data.
+	 * @param serverTextDecoder The text decoder to convert the server and requestor properties data into text.
+	 * @return A Handle used to monitor the connection. When the Handle reports a state of
+	 * Success, then the returnValue of the Handle will hold the connected socket.
+	 */
+//	===================================================================
+	private Handle connectAsync(final TextCodec serverTextDecoder)
+//	===================================================================
+	{
+		return new ewe.sys.TaskObject(){
+			protected void doRun(){
+				while(true){
+					//
+					// Create a Socket using an IOHandle.
+					//
+					Handle sh;
+					Socket sock;
+					if (openSocket != null) {
+						sh = new Handle(Handle.Succeeded,openSocket);
+						sock = openSocket.socket;
+					}
+					else {
+						sh = new IOHandle();
+						sock = new Socket(host,port,(IOHandle)sh);
+						// openSocket = sock;
+					}
+					// Handle sh = (openSocket != null) ? new Handle(Handle.Succeeded,openSocket) : new IOHandle();
+					// Socket sock = (openSocket != null) ? openSocket : new Socket(host,port,(IOHandle)sh);
+					try{
+						//
+						// Now wait until connected.
+						//
+						if (!waitOnSuccess(sh,true)) return;
+						//
+						// Report that the socket connection was made.
+						// Now have to decode the data.
+						//
+						handle.setFlags(SocketConnected,0);
+
+						TlsSocket tls = new TlsSocket(
+								(useSslTls ?  new AlwaysValidVerifyer() : null),
+								sock);
+						makeRequest(tls.inputStream, tls.outputStream, serverTextDecoder);
+						handle.returnValue = connectedSocket = tls;
+						handle.setFlags(Handle.Success,0);
+						return;
+					}catch(Exception e){
+						if (openSocket == null){
+							handle.failed(e);
+							return;
+						}else{
+							openSocket = null;
+							continue;
+						}
+					}
+				}}
+		}.startTask();
+	}
+	/**
+	 * This makes the connection, blocking the current thread.
+	 * @return A Socket that you can read the data from. The document properties will be in
+	 * the document properties list.
+	 * @exception IOException if there was an error connecting or getting the data.
+	 */
+	public TlsSocket connect() throws IOException {
+		openSocket = (TlsSocket)waitOnIO(connectAsync(),&quot;Could not connect.&quot;);
+		return openSocket;
+	}
+	public void disconnect() {
+		if (openSocket.socket.isOpen()) {
+			openSocket.close(); // releases the handles of the system
+		}
+	}
+	public boolean isOpen() {
+		return openSocket.socket.isOpen();
+	}
 }
-public boolean isOpen() {
-	return openSocket.isOpen();
-}
-}
 
 

Modified: trunk/src/CacheWolf/UrlFetcher.java
===================================================================
--- trunk/src/CacheWolf/UrlFetcher.java	2011-08-25 00:55:34 UTC (rev 3058)
+++ trunk/src/CacheWolf/UrlFetcher.java	2011-08-25 00:59:39 UTC (rev 3059)
@@ -109,9 +109,13 @@
 	}
 
 	public static void fetchDataFile(String address, String target) throws IOException {
-		FileOutputStream outp = new FileOutputStream(new File(target));
+		FileOutputStream outp = null;
+		try {
+		outp = new FileOutputStream(new File(target));
 		outp.write(fetchByteArray(address).toBytes());
-		outp.close();
+		} finally {
+		if (outp != null) outp.close();
+		}
 	}
 
 	/**
@@ -133,7 +137,7 @@
 				i = i - 1;
 			}
 			realUrl = urltmp;
-			if (!urltmp.startsWith(&quot;http&quot;)) {
+			if (!( urltmp.startsWith(&quot;http&quot;) || urltmp.startsWith(&quot;https&quot;) )) {
 				url = FileBase.fixupPath(url);
 				String uu = url.toLowerCase();
 				String host;
@@ -145,7 +149,7 @@
 				}
 				if (!urltmp.startsWith(&quot;/&quot;))
 					host = host + &quot;/&quot;;
-				urltmp = &quot;<A HREF="http://">http://</A>&quot; + host + urltmp;
+				urltmp = &quot;<A HREF="http://">http://</A>&quot; + host + urltmp; // TODO https?
 			}
 			conn.setUrl(urltmp);
 			conn.documentIsEncoded = isUrlEncoded(urltmp);
@@ -226,7 +230,7 @@
 	 * This method encodes an URL containing special characters using the UTF-8 codec in %nn%nn notation&lt;br&gt;
 	 * Note that the encoding for URLs is not generally defined. Usually cp1252 or UTF-8 is used. It depends on what the
 	 * server expects, what encoding you must use.
-	 * 
+	 *
 	 * @param cc
 	 * @return
 	 * @throws IOException
@@ -246,7 +250,7 @@
 	/**
 	 * Encode the URL using %## notation. Note: this fixes a bug in ewe.net.URL.encodeURL(): that routine assumes all
 	 * chars to be &lt; 127. This method is mainly copied from there
-	 * 
+	 *
 	 * @param url
 	 *            The unencoded URL.
 	 * @param spaceToPlus

Added: trunk/src/CacheWolf/utils/CWPartialInputStream.java
===================================================================
--- trunk/src/CacheWolf/utils/CWPartialInputStream.java	                        (rev 0)
+++ trunk/src/CacheWolf/utils/CWPartialInputStream.java	2011-08-25 00:59:39 UTC (rev 3059)
@@ -0,0 +1,148 @@
+/*********************************************************************************
+ *  Ewe Virtual Machine - Version 1.14, January 24, 2002                         *
+ *  Copyright (C) 1999-2002 Michael L Brereton &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">michael_brereton at ewesoft.com</A>&gt;    *
+ *  All Rights Reserved                                                          *
+ *                                                                               *
+ *  This library and virtual machine is free software; you can redistribute      *
+ *  it and/or modify it under the terms of the Amended GNU Lesser General        *
+ *  Public License distributed with this software.                               *
+ *                                                                               *
+ *  Under this license, linking this library or part thereof with other files to *
+ *  produce an executable does not in itself require the executable to be        *
+ *  covered by the GNU Lesser General Public License.                            *
+ *                                                                               *
+ *  This library and virtual machine is distributed in the hope that it will     *
+ *  be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of    *
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                         *
+ *                                                                               *
+ *  You should have received a copy of the License along with this software;     *
+ *  if not, please download it at: www.ewesoft.com/LGPL.txt                      *
+ *                                                                               *
+ *********************************************************************************/
+package CacheWolf.utils;
+// import ewe.sys.*;
+// import ewe.util.ByteArray;
+import ewe.io.InputStream;
+import ewe.io.StreamAdapter;
+import ewe.io.BufferedStream;
+import ewe.io.RandomAccessStream;
+import ewe.io.IOException;
+
+/**
+* This class is used to get a &quot;sub-stream&quot; of data from another Stream. The
+* partial stream can limit the amount of data which can be read from the original
+* Stream. Note the following:
+* &lt;nl&gt;
+* &lt;li&gt;Calling close() on a PartialInputStream does not close the original stream, unless closeUnderlying is true.
+* &lt;li&gt;Setting a limit of -1 will not impose any limit on the number of bytes which
+* can be read.
+* &lt;li&gt;Input begins at the current point in the source input stream.
+*&lt;/nl&gt;
+
+**/
+//##################################################################
+public class CWPartialInputStream extends StreamAdapter{
+//##################################################################
+//
+// Do not move the next 2 variables.
+long limit;
+long filepos;
+/**
+* If this is true, then a call to close() will close the underlying stream
+* as well.
+**/
+public boolean closeUnderlying = false;
+/**
+* Creates a new PartialInputStream with the specified limit. If the limit
+* is -1, then there will be no limit imposed
+**/
+//===================================================================
+public CWPartialInputStream(InputStream input,int limit)
+//===================================================================
+{
+	super(input);
+	this.limit = limit;
+	filepos = -1;
+}
+//===================================================================
+
+/**
+* Creates a new PartialInputStream with the specified limit. If the limit
+* is -1, then there will be no limit imposed
+**/
+//===================================================================
+public CWPartialInputStream(InputStream input,long limit)
+//===================================================================
+{
+	super(input);
+	this.limit = limit;
+	filepos = -1;
+}
+//===================================================================
+
+//===================================================================
+public boolean pushback(byte [] bytes,int start,int count)
+//===================================================================
+{
+	if (stream instanceof BufferedStream)
+		return ((BufferedStream)stream).pushback(bytes,start,count);
+	return super.pushback(bytes,start,count);
+}
+//===================================================================
+public int nonBlockingWrite(byte [] buff,int start,int length) {return READWRITE_ERROR;}
+//===================================================================
+
+//===================================================================
+public int nonBlockingRead(byte [] buff,int offset,int count)
+//===================================================================
+{
+	if (limit == 0) return READWRITE_CLOSED;
+	if (limit &lt; -1) return READWRITE_ERROR;
+	if (limit != -1)
+		if ((long)count &gt; limit) count = (int)limit;
+	if (filepos &gt;= 0){
+		try{
+			((RandomAccessStream)stream).seek(filepos);
+		}catch(IOException e){
+			error = e.getMessage();
+			return READWRITE_ERROR;
+		}
+	}
+	int got = super.nonBlockingRead(buff,offset,count);
+	if (got == 0) return 0;
+	if (got == READWRITE_CLOSED){
+		limit = 0;
+		return READWRITE_CLOSED;
+	}
+	if (got &gt; 0) {
+		if (limit &gt; 0){
+			limit -= got;
+			if (limit &lt; 0) limit = 0;
+		}
+		if (filepos &gt;= 0) filepos += got;
+		return got;
+	}
+	// An error occured.
+	limit = -2;
+	return READWRITE_ERROR;
+}
+/**
+* This will not close the underlying stream unless closeUnderlying is true.
+**/
+//===================================================================
+public boolean closeStream() throws ewe.io.IOException
+//===================================================================
+{
+	closed = (closeUnderlying) ?  stream.close() : true;
+	return closed;
+}
+//===================================================================
+public boolean isOpen()
+//===================================================================
+{
+	return !closed;
+}
+//##################################################################
+}
+//##################################################################
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003049.html">[Cachewolf-svn] r3058 - in trunk/src: . org org/bouncycastle	org/bouncycastle/asn1 org/bouncycastle/asn1/nist	org/bouncycastle/asn1/oiw org/bouncycastle/asn1/pkcs	org/bouncycastle/asn1/sec org/bouncycastle/asn1/teletrust	org/bouncycastle/asn1/x500 org/bouncycastle/asn1/x500/style	org/bouncycastle/asn1/x509 org/bouncycastle/asn1/x9	org/bouncycastle/crypto org/bouncycastle/crypto/agreement	org/bouncycastle/crypto/digests org/bouncycastle/crypto/encodings	org/bouncycastle/crypto/engines	org/bouncycastle/crypto/generators org/bouncycastle/crypto/io	org/bouncycastle/crypto/macs org/bouncycastle/crypto/modes	org/bouncycastle/crypto/params org/bouncycastle/crypto/prng	org/bouncycastle/crypto/signers org/bouncycastle/crypto/tls	org/bouncycastle/crypto/util org/bouncycastle/math	org/bouncycastle/math/ec org/bouncycastle/util	org/bouncycastle/util/encoders org/bouncycastle/util/io
</A></li>
	<LI>Next message: <A HREF="003051.html">[Cachewolf-svn] r3060 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3050">[ date ]</a>
              <a href="thread.html#3050">[ thread ]</a>
              <a href="subject.html#3050">[ subject ]</a>
              <a href="author.html#3050">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
