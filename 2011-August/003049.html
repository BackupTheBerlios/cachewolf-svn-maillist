<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Cachewolf-svn] r3058 - in trunk/src: . org org/bouncycastle	org/bouncycastle/asn1 org/bouncycastle/asn1/nist	org/bouncycastle/asn1/oiw org/bouncycastle/asn1/pkcs	org/bouncycastle/asn1/sec org/bouncycastle/asn1/teletrust	org/bouncycastle/asn1/x500 org/bouncycastle/asn1/x500/style	org/bouncycastle/asn1/x509 org/bouncycastle/asn1/x9	org/bouncycastle/crypto org/bouncycastle/crypto/agreement	org/bouncycastle/crypto/digests org/bouncycastle/crypto/encodings	org/bouncycastle/crypto/engines	org/bouncycastle/crypto/generators org/bouncycastle/crypto/io	org/bouncycastle/crypto/macs org/bouncycastle/crypto/modes	org/bouncycastle/crypto/params org/bouncycastle/crypto/prng	org/bouncycastle/crypto/signers org/bouncycastle/crypto/tls	org/bouncycastle/crypto/util org/bouncycastle/math	org/bouncycastle/math/ec org/bouncycastle/util	org/bouncycastle/util/encoders org/bouncycastle/util/io
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/cachewolf-svn/2011-August/index.html" >
   <LINK REL="made" HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3058%20-%20in%20trunk/src%3A%20.%20org%20org/bouncycastle%0A%09org/bouncycastle/asn1%20org/bouncycastle/asn1/nist%0A%09org/bouncycastle/asn1/oiw%20org/bouncycastle/asn1/pkcs%0A%09org/bouncycastle/asn1/sec%20org/bouncycastle/asn1/teletrust%0A%09org/bouncycastle/asn1/x500%20org/bouncycastle/asn1/x500/style%0A%09org/bouncycastle/asn1/x509%20org/bouncycastle/asn1/x9%0A%09org/bouncycastle/crypto%20org/bouncycastle/crypto/agreement%0A%09org/bouncycastle/crypto/digests%20org/bouncycastle/crypto/encodings%0A%09org/bouncycastle/crypto/engines%0A%09org/bouncycastle/crypto/generators%20org/bouncycastle/crypto/io%0A%09org/bouncycastle/crypto/macs%20org/bouncycastle/crypto/modes%0A%09org/bouncycastle/crypto/params%20org/bouncycastle/crypto/prng%0A%09org/bouncycastle/crypto/signers%20org/bouncycastle/crypto/tls%0A%09org/bouncycastle/crypto/util%20org/bouncycastle/math%0A%09org/bouncycastle/math/ec%20org/bouncycastle/util%0A%09org/bouncycastle/util/encoders%20org/bouncycastle/util/io&In-Reply-To=%3C20110825005535.DB195481462%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003053.html">
   <LINK REL="Next"  HREF="003050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Cachewolf-svn] r3058 - in trunk/src: . org org/bouncycastle	org/bouncycastle/asn1 org/bouncycastle/asn1/nist	org/bouncycastle/asn1/oiw org/bouncycastle/asn1/pkcs	org/bouncycastle/asn1/sec org/bouncycastle/asn1/teletrust	org/bouncycastle/asn1/x500 org/bouncycastle/asn1/x500/style	org/bouncycastle/asn1/x509 org/bouncycastle/asn1/x9	org/bouncycastle/crypto org/bouncycastle/crypto/agreement	org/bouncycastle/crypto/digests org/bouncycastle/crypto/encodings	org/bouncycastle/crypto/engines	org/bouncycastle/crypto/generators org/bouncycastle/crypto/io	org/bouncycastle/crypto/macs org/bouncycastle/crypto/modes	org/bouncycastle/crypto/params org/bouncycastle/crypto/prng	org/bouncycastle/crypto/signers org/bouncycastle/crypto/tls	org/bouncycastle/crypto/util org/bouncycastle/math	org/bouncycastle/math/ec org/bouncycastle/util	org/bouncycastle/util/encoders org/bouncycastle/util/io</H1>
    <B>pfeffer at mail.berlios.de</B> 
    <A HREF="mailto:cachewolf-svn%40lists.berlios.de?Subject=Re%3A%20%5BCachewolf-svn%5D%20r3058%20-%20in%20trunk/src%3A%20.%20org%20org/bouncycastle%0A%09org/bouncycastle/asn1%20org/bouncycastle/asn1/nist%0A%09org/bouncycastle/asn1/oiw%20org/bouncycastle/asn1/pkcs%0A%09org/bouncycastle/asn1/sec%20org/bouncycastle/asn1/teletrust%0A%09org/bouncycastle/asn1/x500%20org/bouncycastle/asn1/x500/style%0A%09org/bouncycastle/asn1/x509%20org/bouncycastle/asn1/x9%0A%09org/bouncycastle/crypto%20org/bouncycastle/crypto/agreement%0A%09org/bouncycastle/crypto/digests%20org/bouncycastle/crypto/encodings%0A%09org/bouncycastle/crypto/engines%0A%09org/bouncycastle/crypto/generators%20org/bouncycastle/crypto/io%0A%09org/bouncycastle/crypto/macs%20org/bouncycastle/crypto/modes%0A%09org/bouncycastle/crypto/params%20org/bouncycastle/crypto/prng%0A%09org/bouncycastle/crypto/signers%20org/bouncycastle/crypto/tls%0A%09org/bouncycastle/crypto/util%20org/bouncycastle/math%0A%09org/bouncycastle/math/ec%20org/bouncycastle/util%0A%09org/bouncycastle/util/encoders%20org/bouncycastle/util/io&In-Reply-To=%3C20110825005535.DB195481462%40sheep.berlios.de%3E"
       TITLE="[Cachewolf-svn] r3058 - in trunk/src: . org org/bouncycastle	org/bouncycastle/asn1 org/bouncycastle/asn1/nist	org/bouncycastle/asn1/oiw org/bouncycastle/asn1/pkcs	org/bouncycastle/asn1/sec org/bouncycastle/asn1/teletrust	org/bouncycastle/asn1/x500 org/bouncycastle/asn1/x500/style	org/bouncycastle/asn1/x509 org/bouncycastle/asn1/x9	org/bouncycastle/crypto org/bouncycastle/crypto/agreement	org/bouncycastle/crypto/digests org/bouncycastle/crypto/encodings	org/bouncycastle/crypto/engines	org/bouncycastle/crypto/generators org/bouncycastle/crypto/io	org/bouncycastle/crypto/macs org/bouncycastle/crypto/modes	org/bouncycastle/crypto/params org/bouncycastle/crypto/prng	org/bouncycastle/crypto/signers org/bouncycastle/crypto/tls	org/bouncycastle/crypto/util org/bouncycastle/math	org/bouncycastle/math/ec org/bouncycastle/util	org/bouncycastle/util/encoders org/bouncycastle/util/io">pfeffer at mail.berlios.de
       </A><BR>
    <I>Thu Aug 25 02:55:34 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="003053.html">[Cachewolf-svn] r3062 - trunk
</A></li>
        <LI>Next message: <A HREF="003050.html">[Cachewolf-svn] r3059 - in trunk/src/CacheWolf: . utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3049">[ date ]</a>
              <a href="thread.html#3049">[ thread ]</a>
              <a href="subject.html#3049">[ subject ]</a>
              <a href="author.html#3049">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pfeffer
Date: 2011-08-25 02:55:34 +0200 (Thu, 25 Aug 2011)
New Revision: 3058

Added:
   trunk/src/org/
   trunk/src/org/bouncycastle/
   trunk/src/org/bouncycastle/asn1/
   trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
   trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java
   trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
   trunk/src/org/bouncycastle/asn1/ASN1Boolean.java
   trunk/src/org/bouncycastle/asn1/ASN1Choice.class
   trunk/src/org/bouncycastle/asn1/ASN1Choice.java
   trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
   trunk/src/org/bouncycastle/asn1/ASN1Encodable.java
   trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
   trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java
   trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
   trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java
   trunk/src/org/bouncycastle/asn1/ASN1Exception.class
   trunk/src/org/bouncycastle/asn1/ASN1Exception.java
   trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
   trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java
   trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
   trunk/src/org/bouncycastle/asn1/ASN1InputStream.java
   trunk/src/org/bouncycastle/asn1/ASN1Integer.class
   trunk/src/org/bouncycastle/asn1/ASN1Integer.java
   trunk/src/org/bouncycastle/asn1/ASN1Null.class
   trunk/src/org/bouncycastle/asn1/ASN1Null.java
   trunk/src/org/bouncycastle/asn1/ASN1Object.class
   trunk/src/org/bouncycastle/asn1/ASN1Object.java
   trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
   trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java
   trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
   trunk/src/org/bouncycastle/asn1/ASN1OctetString.java
   trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
   trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java
   trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
   trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java
   trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
   trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java
   trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
   trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
   trunk/src/org/bouncycastle/asn1/ASN1Sequence.java
   trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
   trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java
   trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
   trunk/src/org/bouncycastle/asn1/ASN1Set.class
   trunk/src/org/bouncycastle/asn1/ASN1Set.java
   trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
   trunk/src/org/bouncycastle/asn1/ASN1SetParser.java
   trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
   trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java
   trunk/src/org/bouncycastle/asn1/ASN1String.class
   trunk/src/org/bouncycastle/asn1/ASN1String.java
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
   trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java
   trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
   trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
   trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java
   trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
   trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java
   trunk/src/org/bouncycastle/asn1/BERFactory.class
   trunk/src/org/bouncycastle/asn1/BERFactory.java
   trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
   trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java
   trunk/src/org/bouncycastle/asn1/BEROutputStream.class
   trunk/src/org/bouncycastle/asn1/BEROutputStream.java
   trunk/src/org/bouncycastle/asn1/BERSequence.class
   trunk/src/org/bouncycastle/asn1/BERSequence.java
   trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
   trunk/src/org/bouncycastle/asn1/BERSequenceParser.java
   trunk/src/org/bouncycastle/asn1/BERSet.class
   trunk/src/org/bouncycastle/asn1/BERSet.java
   trunk/src/org/bouncycastle/asn1/BERSetParser.class
   trunk/src/org/bouncycastle/asn1/BERSetParser.java
   trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
   trunk/src/org/bouncycastle/asn1/BERTaggedObject.java
   trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
   trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java
   trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
   trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java
   trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
   trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java
   trunk/src/org/bouncycastle/asn1/DERBMPString.class
   trunk/src/org/bouncycastle/asn1/DERBMPString.java
   trunk/src/org/bouncycastle/asn1/DERBitString.class
   trunk/src/org/bouncycastle/asn1/DERBitString.java
   trunk/src/org/bouncycastle/asn1/DERBoolean.class
   trunk/src/org/bouncycastle/asn1/DERBoolean.java
   trunk/src/org/bouncycastle/asn1/DEREncodable.class
   trunk/src/org/bouncycastle/asn1/DEREncodable.java
   trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
   trunk/src/org/bouncycastle/asn1/DEREncodableVector.java
   trunk/src/org/bouncycastle/asn1/DEREnumerated.class
   trunk/src/org/bouncycastle/asn1/DEREnumerated.java
   trunk/src/org/bouncycastle/asn1/DERExternal.class
   trunk/src/org/bouncycastle/asn1/DERExternal.java
   trunk/src/org/bouncycastle/asn1/DERExternalParser.class
   trunk/src/org/bouncycastle/asn1/DERExternalParser.java
   trunk/src/org/bouncycastle/asn1/DERFactory.class
   trunk/src/org/bouncycastle/asn1/DERFactory.java
   trunk/src/org/bouncycastle/asn1/DERGeneralString.class
   trunk/src/org/bouncycastle/asn1/DERGeneralString.java
   trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
   trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java
   trunk/src/org/bouncycastle/asn1/DERIA5String.class
   trunk/src/org/bouncycastle/asn1/DERIA5String.java
   trunk/src/org/bouncycastle/asn1/DERInteger.class
   trunk/src/org/bouncycastle/asn1/DERInteger.java
   trunk/src/org/bouncycastle/asn1/DERNull.class
   trunk/src/org/bouncycastle/asn1/DERNull.java
   trunk/src/org/bouncycastle/asn1/DERNumericString.class
   trunk/src/org/bouncycastle/asn1/DERNumericString.java
   trunk/src/org/bouncycastle/asn1/DERObject.class
   trunk/src/org/bouncycastle/asn1/DERObject.java
   trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
   trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java
   trunk/src/org/bouncycastle/asn1/DEROctetString.class
   trunk/src/org/bouncycastle/asn1/DEROctetString.java
   trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
   trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java
   trunk/src/org/bouncycastle/asn1/DEROutputStream.class
   trunk/src/org/bouncycastle/asn1/DEROutputStream.java
   trunk/src/org/bouncycastle/asn1/DERPrintableString.class
   trunk/src/org/bouncycastle/asn1/DERPrintableString.java
   trunk/src/org/bouncycastle/asn1/DERSequence.class
   trunk/src/org/bouncycastle/asn1/DERSequence.java
   trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
   trunk/src/org/bouncycastle/asn1/DERSequenceParser.java
   trunk/src/org/bouncycastle/asn1/DERSet.class
   trunk/src/org/bouncycastle/asn1/DERSet.java
   trunk/src/org/bouncycastle/asn1/DERSetParser.class
   trunk/src/org/bouncycastle/asn1/DERSetParser.java
   trunk/src/org/bouncycastle/asn1/DERString.class
   trunk/src/org/bouncycastle/asn1/DERString.java
   trunk/src/org/bouncycastle/asn1/DERT61String.class
   trunk/src/org/bouncycastle/asn1/DERT61String.java
   trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
   trunk/src/org/bouncycastle/asn1/DERTaggedObject.java
   trunk/src/org/bouncycastle/asn1/DERTags.class
   trunk/src/org/bouncycastle/asn1/DERTags.java
   trunk/src/org/bouncycastle/asn1/DERUTCTime.class
   trunk/src/org/bouncycastle/asn1/DERUTCTime.java
   trunk/src/org/bouncycastle/asn1/DERUTF8String.class
   trunk/src/org/bouncycastle/asn1/DERUTF8String.java
   trunk/src/org/bouncycastle/asn1/DERUniversalString.class
   trunk/src/org/bouncycastle/asn1/DERUniversalString.java
   trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
   trunk/src/org/bouncycastle/asn1/DERUnknownTag.java
   trunk/src/org/bouncycastle/asn1/DERVisibleString.class
   trunk/src/org/bouncycastle/asn1/DERVisibleString.java
   trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
   trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java
   trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
   trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java
   trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
   trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java
   trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
   trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java
   trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
   trunk/src/org/bouncycastle/asn1/LazyDERSequence.java
   trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
   trunk/src/org/bouncycastle/asn1/LimitedInputStream.java
   trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
   trunk/src/org/bouncycastle/asn1/OIDTokenizer.java
   trunk/src/org/bouncycastle/asn1/nist/
   trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
   trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java
   trunk/src/org/bouncycastle/asn1/nist/package.html
   trunk/src/org/bouncycastle/asn1/oiw/
   trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
   trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java
   trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/oiw/package.html
   trunk/src/org/bouncycastle/asn1/pkcs/
   trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
   trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java
   trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/pkcs/package.html
   trunk/src/org/bouncycastle/asn1/sec/
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
   trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java
   trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/sec/package.html
   trunk/src/org/bouncycastle/asn1/teletrust/
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/teletrust/package.html
   trunk/src/org/bouncycastle/asn1/x500/
   trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
   trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java
   trunk/src/org/bouncycastle/asn1/x500/RDN.class
   trunk/src/org/bouncycastle/asn1/x500/RDN.java
   trunk/src/org/bouncycastle/asn1/x500/X500Name.class
   trunk/src/org/bouncycastle/asn1/x500/X500Name.java
   trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
   trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java
   trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
   trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java
   trunk/src/org/bouncycastle/asn1/x500/style/
   trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
   trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java
   trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
   trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java
   trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
   trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java
   trunk/src/org/bouncycastle/asn1/x509/
   trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
   trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java
   trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
   trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java
   trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
   trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java
   trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
   trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java
   trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
   trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java
   trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
   trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java
   trunk/src/org/bouncycastle/asn1/x509/Time.class
   trunk/src/org/bouncycastle/asn1/x509/Time.java
   trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
   trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java
   trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
   trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java
   trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
   trunk/src/org/bouncycastle/asn1/x509/X509Extension.java
   trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
   trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java
   trunk/src/org/bouncycastle/asn1/x509/X509Name.class
   trunk/src/org/bouncycastle/asn1/x509/X509Name.java
   trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
   trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java
   trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
   trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java
   trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/x509/package.html
   trunk/src/org/bouncycastle/asn1/x9/
   trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
   trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java
   trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
   trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java
   trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
   trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
   trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java
   trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
   trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java
   trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
   trunk/src/org/bouncycastle/asn1/x9/X9Curve.java
   trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java
   trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java
   trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
   trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java
   trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
   trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java
   trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
   trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java
   trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
   trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java
   trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
   trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java
   trunk/src/org/bouncycastle/asn1/x9/package.html
   trunk/src/org/bouncycastle/crypto/
   trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
   trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java
   trunk/src/org/bouncycastle/crypto/BasicAgreement.class
   trunk/src/org/bouncycastle/crypto/BasicAgreement.java
   trunk/src/org/bouncycastle/crypto/BlockCipher.class
   trunk/src/org/bouncycastle/crypto/BlockCipher.java
   trunk/src/org/bouncycastle/crypto/CipherParameters.class
   trunk/src/org/bouncycastle/crypto/CipherParameters.java
   trunk/src/org/bouncycastle/crypto/CryptoException.class
   trunk/src/org/bouncycastle/crypto/CryptoException.java
   trunk/src/org/bouncycastle/crypto/DSA.class
   trunk/src/org/bouncycastle/crypto/DSA.java
   trunk/src/org/bouncycastle/crypto/DataLengthException.class
   trunk/src/org/bouncycastle/crypto/DataLengthException.java
   trunk/src/org/bouncycastle/crypto/Digest.class
   trunk/src/org/bouncycastle/crypto/Digest.java
   trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
   trunk/src/org/bouncycastle/crypto/ExtendedDigest.java
   trunk/src/org/bouncycastle/crypto/ExtensionType.class
   trunk/src/org/bouncycastle/crypto/ExtensionType.java
   trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
   trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java
   trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java
   trunk/src/org/bouncycastle/crypto/Mac.class
   trunk/src/org/bouncycastle/crypto/Mac.java
   trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
   trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java
   trunk/src/org/bouncycastle/crypto/Signer.class
   trunk/src/org/bouncycastle/crypto/Signer.java
   trunk/src/org/bouncycastle/crypto/agreement/
   trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
   trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java
   trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
   trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java
   trunk/src/org/bouncycastle/crypto/agreement/package.html
   trunk/src/org/bouncycastle/crypto/digests/
   trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
   trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java
   trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
   trunk/src/org/bouncycastle/crypto/digests/LongDigest.java
   trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
   trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java
   trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
   trunk/src/org/bouncycastle/crypto/digests/NullDigest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java
   trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
   trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java
   trunk/src/org/bouncycastle/crypto/digests/package.html
   trunk/src/org/bouncycastle/crypto/encodings/
   trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
   trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java
   trunk/src/org/bouncycastle/crypto/encodings/package.html
   trunk/src/org/bouncycastle/crypto/engines/
   trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
   trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java
   trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
   trunk/src/org/bouncycastle/crypto/engines/DESEngine.java
   trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
   trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java
   trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
   trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java
   trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
   trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java
   trunk/src/org/bouncycastle/crypto/engines/package.html
   trunk/src/org/bouncycastle/crypto/generators/
   trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java
   trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
   trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java
   trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
   trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java
   trunk/src/org/bouncycastle/crypto/generators/package.html
   trunk/src/org/bouncycastle/crypto/io/
   trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
   trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java
   trunk/src/org/bouncycastle/crypto/io/package.html
   trunk/src/org/bouncycastle/crypto/macs/
   trunk/src/org/bouncycastle/crypto/macs/HMac.class
   trunk/src/org/bouncycastle/crypto/macs/HMac.java
   trunk/src/org/bouncycastle/crypto/macs/package.html
   trunk/src/org/bouncycastle/crypto/modes/
   trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
   trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java
   trunk/src/org/bouncycastle/crypto/modes/package.html
   trunk/src/org/bouncycastle/crypto/package.html
   trunk/src/org/bouncycastle/crypto/params/
   trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
   trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java
   trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
   trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java
   trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
   trunk/src/org/bouncycastle/crypto/params/KeyParameter.java
   trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
   trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java
   trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
   trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java
   trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
   trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java
   trunk/src/org/bouncycastle/crypto/params/package.html
   trunk/src/org/bouncycastle/crypto/prng/
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
   trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java
   trunk/src/org/bouncycastle/crypto/prng/package.html
   trunk/src/org/bouncycastle/crypto/signers/
   trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
   trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java
   trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
   trunk/src/org/bouncycastle/crypto/signers/DSASigner.java
   trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
   trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java
   trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
   trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java
   trunk/src/org/bouncycastle/crypto/signers/package.html
   trunk/src/org/bouncycastle/crypto/tls/
   trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
   trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java
   trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
   trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java
   trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
   trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java
   trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
   trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java
   trunk/src/org/bouncycastle/crypto/tls/Certificate.class
   trunk/src/org/bouncycastle/crypto/tls/Certificate.java
   trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
   trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java
   trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
   trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java
   trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
   trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java
   trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
   trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java
   trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
   trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java
   trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
   trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java
   trunk/src/org/bouncycastle/crypto/tls/ContentType.class
   trunk/src/org/bouncycastle/crypto/tls/ContentType.java
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java
   trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java
   trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
   trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java
   trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java
   trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
   trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java
   trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
   trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java
   trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
   trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java
   trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
   trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java
   trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
   trunk/src/org/bouncycastle/crypto/tls/RecordStream.java
   trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
   trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java
   trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java
   trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
   trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java
   trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java
   trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClient.java
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
   trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java
   trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
   trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java
   trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
   trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java
   trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
   trunk/src/org/bouncycastle/crypto/tls/TlsMac.java
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
   trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java
   trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
   trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java
   trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
   trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java
   trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java
   trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
   trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java
   trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java
   trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java
   trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
   trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java
   trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
   trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java
   trunk/src/org/bouncycastle/crypto/tls/package.html
   trunk/src/org/bouncycastle/crypto/util/
   trunk/src/org/bouncycastle/crypto/util/Pack.class
   trunk/src/org/bouncycastle/crypto/util/Pack.java
   trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
   trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java
   trunk/src/org/bouncycastle/crypto/util/package.html
   trunk/src/org/bouncycastle/math/
   trunk/src/org/bouncycastle/math/ec/
   trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
   trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java
   trunk/src/org/bouncycastle/math/ec/ECConstants.class
   trunk/src/org/bouncycastle/math/ec/ECConstants.java
   trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECCurve.class
   trunk/src/org/bouncycastle/math/ec/ECCurve.java
   trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
   trunk/src/org/bouncycastle/math/ec/ECFieldElement.java
   trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
   trunk/src/org/bouncycastle/math/ec/ECMultiplier.java
   trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
   trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
   trunk/src/org/bouncycastle/math/ec/ECPoint.class
   trunk/src/org/bouncycastle/math/ec/ECPoint.java
   trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java
   trunk/src/org/bouncycastle/math/ec/IntArray.class
   trunk/src/org/bouncycastle/math/ec/IntArray.java
   trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/PreCompInfo.java
   trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
   trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java
   trunk/src/org/bouncycastle/math/ec/Tnaf.class
   trunk/src/org/bouncycastle/math/ec/Tnaf.java
   trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java
   trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java
   trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
   trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java
   trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
   trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java
   trunk/src/org/bouncycastle/math/ec/ZTauElement.class
   trunk/src/org/bouncycastle/math/ec/ZTauElement.java
   trunk/src/org/bouncycastle/math/ec/package.html
   trunk/src/org/bouncycastle/util/
   trunk/src/org/bouncycastle/util/Arrays.class
   trunk/src/org/bouncycastle/util/Arrays.java
   trunk/src/org/bouncycastle/util/BigIntegers.class
   trunk/src/org/bouncycastle/util/BigIntegers.java
   trunk/src/org/bouncycastle/util/Strings.class
   trunk/src/org/bouncycastle/util/Strings.java
   trunk/src/org/bouncycastle/util/encoders/
   trunk/src/org/bouncycastle/util/encoders/Encoder.class
   trunk/src/org/bouncycastle/util/encoders/Encoder.java
   trunk/src/org/bouncycastle/util/encoders/Hex.class
   trunk/src/org/bouncycastle/util/encoders/Hex.java
   trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
   trunk/src/org/bouncycastle/util/encoders/HexEncoder.java
   trunk/src/org/bouncycastle/util/encoders/package.html
   trunk/src/org/bouncycastle/util/io/
   trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
   trunk/src/org/bouncycastle/util/io/StreamOverflowException.java
   trunk/src/org/bouncycastle/util/io/Streams.class
   trunk/src/org/bouncycastle/util/io/Streams.java
Log:
the tls/ssl library

Added: trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1ApplicationSpecificParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1ApplicationSpecificParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    DEREncodable readObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Boolean.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Boolean.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Boolean.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Boolean.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,15 @@
+package org.bouncycastle.asn1;
+
+public class ASN1Boolean
+    extends DERBoolean
+{
+    public ASN1Boolean(boolean value)
+    {
+        super(value);
+    }
+
+    ASN1Boolean(byte[] value)
+    {
+        super(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Choice.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Choice.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Choice.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Choice.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Choice.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,14 @@
+package org.bouncycastle.asn1;
+
+/**
+ * Marker interface for CHOICE objects - if you implement this in a role your
+ * own object any attempt to tag the object implicitly will convert the tag to
+ * an explicit one as the encoding rules require.
+ * &lt;p&gt;
+ * If you use this interface your class should also implement the getInstance
+ * pattern which takes a tag object and the tagging mode used. 
+ */
+public interface ASN1Choice
+{
+    // marker interface
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Encodable.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Encodable.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Encodable.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Encodable.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,102 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+/**
+ * Base class for objects which can be written directly to ASN.1 output streams.
+ */
+public abstract class ASN1Encodable
+    implements DEREncodable
+{
+    public static final String DER = &quot;DER&quot;;
+    public static final String BER = &quot;BER&quot;;
+
+    /**
+     * Return the default BER or DER encoding for this object.
+     *
+     * @return BER/DER byte encoded object.
+     * @throws IOException on encoding error.
+     */
+    public byte[] getEncoded()
+        throws IOException
+    {
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        ASN1OutputStream        aOut = new ASN1OutputStream(bOut);
+
+        aOut.writeObject(this);
+
+        return bOut.toByteArray();
+    }
+
+    /**
+     * Return either the default for &quot;BER&quot; or a DER encoding if &quot;DER&quot; is specified.
+     *
+     * @param encoding name of encoding to use.
+     * @return byte encoded object.
+     * @throws IOException on encoding error.
+     */
+    public byte[] getEncoded(
+        String encoding)
+        throws IOException
+    {
+        if (encoding.equals(DER))
+        {
+            ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+            DEROutputStream         dOut = new DEROutputStream(bOut);
+
+            dOut.writeObject(this);
+
+            return bOut.toByteArray();
+        }
+
+        return this.getEncoded();
+    }
+
+    /**
+     * Return the DER encoding of the object, null if the DER encoding can not be made.
+     *
+     * @return a DER byte array, null otherwise.
+     */
+    public byte[] getDEREncoded()
+    {
+        try
+        {
+            return this.getEncoded(DER);
+        }
+        catch (IOException e)
+        {
+            return null;
+        }
+    }
+
+    public int hashCode()
+    {
+        return this.toASN1Object().hashCode();
+    }
+
+    public boolean equals(
+        Object  o)
+    {
+        if (this == o)
+        {
+            return true;
+        }
+
+        if (!(o instanceof DEREncodable))
+        {
+            return false;
+        }
+
+        DEREncodable other = (DEREncodable)o;
+
+        return this.toASN1Object().equals(other.getDERObject());
+    }
+
+    public DERObject getDERObject()
+    {
+        return this.toASN1Object();
+    }
+
+    public abstract DERObject toASN1Object();
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1EncodableVector.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,32 @@
+package org.bouncycastle.asn1;
+
+import ewe.util.Vector;
+
+/**
+ * the parent class for this will eventually disappear. Use this one!
+ */
+public class ASN1EncodableVector
+    extends DEREncodableVector
+{
+    Vector v = new Vector();
+
+    public ASN1EncodableVector()
+    {
+
+    }
+
+    public void add(DEREncodable obj)
+    {
+        v.addElement(obj);
+    }
+
+    public DEREncodable get(int i)
+    {
+        return (DEREncodable)v.elementAt(i);
+    }
+
+    public int size()
+    {
+        return v.size();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Enumerated.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Enumerated.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+import ewe.math.BigInteger;
+
+public class ASN1Enumerated
+    extends DEREnumerated
+{
+    ASN1Enumerated(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+    public ASN1Enumerated(BigInteger value)
+    {
+        super(value);
+    }
+
+    public ASN1Enumerated(int value)
+    {
+        super(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Exception.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Exception.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Exception.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Exception.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Exception.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class ASN1Exception
+    extends IOException
+{
+    private Throwable cause;
+
+    ASN1Exception(String message)
+    {
+        super(message);
+    }
+
+    ASN1Exception(String message, Throwable cause)
+    {
+        super(message);
+        this.cause = cause;
+    }
+
+    public Throwable getCause()
+    {
+        return cause;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1GeneralizedTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+import ewe.sys.Date;
+
+public class ASN1GeneralizedTime
+    extends DERGeneralizedTime
+{
+    ASN1GeneralizedTime(byte[] bytes)
+    {
+        super(bytes);
+    }
+/*
+    public ASN1GeneralizedTime(Date time)
+    {
+        super(time);
+    }
+*/
+    public ASN1GeneralizedTime(String time)
+    {
+        super(time);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1InputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1InputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1InputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1InputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,401 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.EOFException;
+import ewe.io.FilterInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.io.Streams;
+
+/**
+ * a general purpose ASN.1 decoder - note: this class differs from the
+ * others in that it returns null after it has read the last object in
+ * the stream. If an ASN.1 NULL is encountered a DER/BER Null object is
+ * returned.
+ */
+public class ASN1InputStream
+    extends FilterInputStream
+    implements DERTags
+{
+    private final int limit;
+    private final boolean lazyEvaluate;
+
+    static int findLimit(InputStream in)
+    {
+        if (in instanceof LimitedInputStream)
+        {
+            return ((LimitedInputStream)in).getRemaining();
+        }
+        else if (in instanceof ByteArrayInputStream)
+        {
+            return ((ByteArrayInputStream)in).available();
+        }
+
+        return Integer.MAX_VALUE;
+    }
+
+    public ASN1InputStream(
+        InputStream is)
+    {
+        this(is, findLimit(is));
+    }
+
+    /**
+     * Create an ASN1InputStream based on the input byte array. The length of DER objects in
+     * the stream is automatically limited to the length of the input array.
+     *
+     * @param input array containing ASN.1 encoded data.
+     */
+    public ASN1InputStream(
+        byte[] input)
+    {
+        this(new ByteArrayInputStream(input), input.length);
+    }
+
+    /**
+     * Create an ASN1InputStream based on the input byte array. The length of DER objects in
+     * the stream is automatically limited to the length of the input array.
+     *
+     * @param input array containing ASN.1 encoded data.
+     * @param lazyEvaluate true if parsing inside constructed objects can be delayed.
+     */
+    public ASN1InputStream(
+        byte[] input,
+        boolean lazyEvaluate)
+    {
+        this(new ByteArrayInputStream(input), input.length, lazyEvaluate);
+    }
+
+    /**
+     * Create an ASN1InputStream where no DER object will be longer than limit.
+     *
+     * @param input stream containing ASN.1 encoded data.
+     * @param limit maximum size of a DER encoded object.
+     */
+    public ASN1InputStream(
+        InputStream input,
+        int         limit)
+    {
+        this(input, limit, false);
+    }
+
+    /**
+     * Create an ASN1InputStream where no DER object will be longer than limit, and constructed
+     * objects such as sequences will be parsed lazily.
+     *
+     * @param input stream containing ASN.1 encoded data.
+     * @param limit maximum size of a DER encoded object.
+     * @param lazyEvaluate true if parsing inside constructed objects can be delayed.
+     */
+    public ASN1InputStream(
+        InputStream input,
+        int         limit,
+        boolean     lazyEvaluate)
+    {
+        super(input);
+        this.limit = limit;
+        this.lazyEvaluate = lazyEvaluate;
+    }
+
+    protected int readLength()
+        throws IOException
+    {
+        return readLength(this, limit);
+    }
+
+    protected void readFully(
+        byte[]  bytes)
+        throws IOException
+    {
+        if (Streams.readFully(this, bytes) != bytes.length)
+        {
+            throw new EOFException(&quot;EOF encountered in middle of object&quot;);
+        }
+    }
+
+    /**
+     * build an object given its tag and the number of bytes to construct it from.
+     */
+    protected DERObject buildObject(
+        int       tag,
+        int       tagNo,
+        int       length)
+        throws IOException
+    {
+        boolean isConstructed = (tag &amp; CONSTRUCTED) != 0;
+
+        DefiniteLengthInputStream defIn = new DefiniteLengthInputStream(this, length);
+
+        if ((tag &amp; APPLICATION) != 0)
+        {
+            return new DERApplicationSpecific(isConstructed, tagNo, defIn.toByteArray());
+        }
+
+        if ((tag &amp; TAGGED) != 0)
+        {
+            return new ASN1StreamParser(defIn).readTaggedObject(isConstructed, tagNo);
+        }
+
+        if (isConstructed)
+        {
+            // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+            switch (tagNo)
+            {
+                case OCTET_STRING:
+                    //
+                    // yes, people actually do this...
+                    //
+                    return new BERConstructedOctetString(buildDEREncodableVector(defIn).v);
+                case SEQUENCE:
+                    if (lazyEvaluate)
+                    {
+                        return new LazyDERSequence(defIn.toByteArray());
+                    }
+                    else
+                    {
+                        return DERFactory.createSequence(buildDEREncodableVector(defIn));
+                    }
+                case SET:
+                    return DERFactory.createSet(buildDEREncodableVector(defIn), false);
+                case EXTERNAL:
+                    return new DERExternal(buildDEREncodableVector(defIn));
+                default:
+                    return new DERUnknownTag(true, tagNo, defIn.toByteArray());
+            }
+        }
+
+        return createPrimitiveDERObject(tagNo, defIn.toByteArray());
+    }
+
+    ASN1EncodableVector buildEncodableVector()
+        throws IOException
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        DERObject o;
+
+        while ((o = readObject()) != null)
+        {
+            v.add(o);
+        }
+
+        return v;
+    }
+
+    ASN1EncodableVector buildDEREncodableVector(
+        DefiniteLengthInputStream dIn) throws IOException
+    {
+        return new ASN1InputStream(dIn).buildEncodableVector();
+    }
+
+    public DERObject readObject()
+        throws IOException
+    {
+        int tag = read();
+        if (tag &lt;= 0)
+        {
+            if (tag == 0)
+            {
+                throw new IOException(&quot;unexpected end-of-contents marker&quot;);
+            }
+
+            return null;
+        }
+
+        //
+        // calculate tag number
+        //
+        int tagNo = readTagNumber(this, tag);
+
+        boolean isConstructed = (tag &amp; CONSTRUCTED) != 0;
+
+        //
+        // calculate length
+        //
+        int length = readLength();
+
+        if (length &lt; 0) // indefinite length method
+        {
+            if (!isConstructed)
+            {
+                throw new IOException(&quot;indefinite length primitive encoding encountered&quot;);
+            }
+
+            IndefiniteLengthInputStream indIn = new IndefiniteLengthInputStream(this, limit);
+            ASN1StreamParser sp = new ASN1StreamParser(indIn, limit);
+
+            if ((tag &amp; APPLICATION) != 0)
+            {
+                return new BERApplicationSpecificParser(tagNo, sp).getLoadedObject();
+            }
+
+            if ((tag &amp; TAGGED) != 0)
+            {
+                return new BERTaggedObjectParser(true, tagNo, sp).getLoadedObject();
+            }
+
+            // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+            switch (tagNo)
+            {
+                case OCTET_STRING:
+                    return new BEROctetStringParser(sp).getLoadedObject();
+                case SEQUENCE:
+                    return new BERSequenceParser(sp).getLoadedObject();
+                case SET:
+                    return new BERSetParser(sp).getLoadedObject();
+                case EXTERNAL:
+                    return new DERExternalParser(sp).getLoadedObject();
+                default:
+                    throw new IOException(&quot;unknown BER object encountered&quot;);
+            }
+        }
+        else
+        {
+            try
+            {
+                return buildObject(tag, tagNo, length);
+            }
+            catch (IllegalArgumentException e)
+            {
+                throw new ASN1Exception(&quot;corrupted stream detected&quot;, e);
+            }
+        }
+    }
+
+    static int readTagNumber(InputStream s, int tag)
+        throws IOException
+    {
+        int tagNo = tag &amp; 0x1f;
+
+        //
+        // with tagged object tag number is bottom 5 bits, or stored at the start of the content
+        //
+        if (tagNo == 0x1f)
+        {
+            tagNo = 0;
+
+            int b = s.read();
+
+            // X.690-0207 8.1.2.4.2
+            // &quot;c) bits 7 to 1 of the first subsequent octet shall not all be zero.&quot;
+            if ((b &amp; 0x7f) == 0) // Note: -1 will pass
+            {
+                throw new IOException(&quot;corrupted stream - invalid high tag number found&quot;);
+            }
+
+            while ((b &gt;= 0) &amp;&amp; ((b &amp; 0x80) != 0))
+            {
+                tagNo |= (b &amp; 0x7f);
+                tagNo &lt;&lt;= 7;
+                b = s.read();
+            }
+
+            if (b &lt; 0)
+            {
+                throw new EOFException(&quot;EOF found inside tag value.&quot;);
+            }
+
+            tagNo |= (b &amp; 0x7f);
+        }
+
+        return tagNo;
+    }
+
+    static int readLength(InputStream s, int limit)
+        throws IOException
+    {
+        int length = s.read();
+        if (length &lt; 0)
+        {
+            throw new EOFException(&quot;EOF found when length expected&quot;);
+        }
+
+        if (length == 0x80)
+        {
+            return -1;      // indefinite-length encoding
+        }
+
+        if (length &gt; 127)
+        {
+            int size = length &amp; 0x7f;
+
+            // Note: The invalid long form &quot;0xff&quot; (see X.690 8.1.3.5c) will be caught here
+            if (size &gt; 4)
+            {
+                throw new IOException(&quot;DER length more than 4 bytes: &quot; + size);
+            }
+
+            length = 0;
+            for (int i = 0; i &lt; size; i++)
+            {
+                int next = s.read();
+
+                if (next &lt; 0)
+                {
+                    throw new EOFException(&quot;EOF found reading length&quot;);
+                }
+
+                length = (length &lt;&lt; 8) + next;
+            }
+
+            if (length &lt; 0)
+            {
+                throw new IOException(&quot;corrupted stream - negative length found&quot;);
+            }
+
+            if (length &gt;= limit)   // after all we must have read at least 1 byte
+            {
+                throw new IOException(&quot;corrupted stream - out of bounds length found&quot;);
+            }
+        }
+
+        return length;
+    }
+
+    static DERObject createPrimitiveDERObject(
+        int     tagNo,
+        byte[]  bytes)
+    {
+        switch (tagNo)
+        {
+            case BIT_STRING:
+                return DERBitString.fromOctetString(bytes);
+            case BMP_STRING:
+                return new DERBMPString(bytes);
+            case BOOLEAN:
+                return new ASN1Boolean(bytes);
+            case ENUMERATED:
+                return new ASN1Enumerated(bytes);
+            case GENERALIZED_TIME:
+                return new ASN1GeneralizedTime(bytes);
+            case GENERAL_STRING:
+                return new DERGeneralString(bytes);
+            case IA5_STRING:
+                return new DERIA5String(bytes);
+            case INTEGER:
+                return new ASN1Integer(bytes);
+            case NULL:
+                return DERNull.INSTANCE;   // actual content is ignored (enforce 0 length?)
+            case NUMERIC_STRING:
+                return new DERNumericString(bytes);
+            case OBJECT_IDENTIFIER:
+                return new ASN1ObjectIdentifier(bytes);
+            case OCTET_STRING:
+                return new DEROctetString(bytes);
+            case PRINTABLE_STRING:
+                return new DERPrintableString(bytes);
+            case T61_STRING:
+                return new DERT61String(bytes);
+            case UNIVERSAL_STRING:
+                return new DERUniversalString(bytes);
+            case UTC_TIME:
+                return new ASN1UTCTime(bytes);
+            case UTF8_STRING:
+                return new DERUTF8String(bytes);
+            case VISIBLE_STRING:
+                return new DERVisibleString(bytes);
+            default:
+                return new DERUnknownTag(false, tagNo, bytes);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Integer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Integer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Integer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Integer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Integer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+import ewe.math.BigInteger;
+
+public class ASN1Integer
+    extends DERInteger
+{
+    ASN1Integer(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+    public ASN1Integer(BigInteger value)
+    {
+        super(value);
+    }
+
+    public ASN1Integer(int value)
+    {
+        super(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Null.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Null.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Null.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Null.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Null.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * A NULL object.
+ */
+public abstract class ASN1Null
+    extends ASN1Object
+{
+    public ASN1Null()
+    {
+    }
+
+    public int hashCode()
+    {
+        return -1;
+    }
+
+    boolean asn1Equals(
+        DERObject o)
+    {
+        if (!(o instanceof ASN1Null))
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+
+    public String toString()
+    {
+         return &quot;NULL&quot;;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Object.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Object.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Object.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Object.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Object.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,45 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public abstract  class ASN1Object
+    extends DERObject
+{
+    /**
+     * Create a base ASN.1 object from a byte stream.
+     *
+     * @param data the byte stream to parse.
+     * @return the base ASN.1 object represented by the byte stream.
+     * @exception IOException if there is a problem parsing the data.
+     */
+    public static ASN1Object fromByteArray(byte[] data)
+        throws IOException
+    {
+        ASN1InputStream aIn = new ASN1InputStream(data);
+
+        try
+        {
+            return (ASN1Object)aIn.readObject();
+        }
+        catch (ClassCastException e)
+        {
+            throw new IOException(&quot;cannot recognise object in stream&quot;);
+        }
+    }
+
+    public final boolean equals(Object o)
+    {
+        if (this == o)
+        {
+            return true;
+        }
+
+        return (o instanceof DEREncodable) &amp;&amp; asn1Equals(((DEREncodable)o).getDERObject());
+    }
+
+    public abstract int hashCode();
+
+    abstract void encode(DEROutputStream out) throws IOException;
+
+    abstract boolean asn1Equals(DERObject o);
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1ObjectIdentifier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,26 @@
+package org.bouncycastle.asn1;
+
+public class ASN1ObjectIdentifier
+    extends DERObjectIdentifier
+{
+    public ASN1ObjectIdentifier(String identifier)
+    {
+        super(identifier);
+    }
+
+    ASN1ObjectIdentifier(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+    /**
+     * Return an OID that creates a branch under the current one.
+     *
+     * @param branchID node numbers for the new branch.
+     * @return
+     */
+    public ASN1ObjectIdentifier branch(String branchID)
+    {
+        return new ASN1ObjectIdentifier(getId() + &quot;.&quot; + branchID);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1OctetString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1OctetString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1OctetString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,135 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.Arrays;
+import org.bouncycastle.util.encoders.Hex;
+
+public abstract class ASN1OctetString
+    extends ASN1Object
+    implements ASN1OctetStringParser
+{
+    byte[]  string;
+
+    /**
+     * return an Octet String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want.
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *              be converted.
+     */
+    public static ASN1OctetString getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof ASN1OctetString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return BERConstructedOctetString.fromSequence(ASN1Sequence.getInstance(o));
+        }
+    }
+
+    /**
+     * return an Octet String from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static ASN1OctetString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof ASN1OctetString)
+        {
+            return (ASN1OctetString)obj;
+        }
+
+        // TODO: this needs to be deleted in V2
+        if (obj instanceof ASN1TaggedObject)
+        {
+            return getInstance(((ASN1TaggedObject)obj).getObject());
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * @param string the octets making up the octet string.
+     */
+    public ASN1OctetString(
+        byte[]  string)
+    {
+        if (string == null)
+        {
+            throw new NullPointerException(&quot;string cannot be null&quot;);
+        }
+        this.string = string;
+    }
+
+    public ASN1OctetString(
+        DEREncodable obj)
+    {
+        try
+        {
+            this.string = obj.getDERObject().getEncoded(ASN1Encodable.DER);
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException(&quot;Error processing object : &quot; + e.toString());
+        }
+    }
+
+    public InputStream getOctetStream()
+    {
+        return new ByteArrayInputStream(string);
+    }
+
+    public ASN1OctetStringParser parser()
+    {
+        return this;
+    }
+
+    public byte[] getOctets()
+    {
+        return string;
+    }
+
+    public int hashCode()
+    {
+        return Arrays.hashCode(this.getOctets());
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof ASN1OctetString))
+        {
+            return false;
+        }
+
+        ASN1OctetString  other = (ASN1OctetString)o;
+
+        return Arrays.areEqual(string, other.string);
+    }
+
+    public DERObject getLoadedObject()
+    {
+        return this.getDERObject();
+    }
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+
+    public String toString()
+    {
+      return &quot;#&quot;+new String(Hex.encode(string));
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1OctetStringParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,9 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.InputStream;
+
+public interface ASN1OctetStringParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    public InputStream getOctetStream();
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1OutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1OutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class ASN1OutputStream
+    extends DEROutputStream
+{
+    public ASN1OutputStream(
+        OutputStream    os)
+    {
+        super(os);
+    }
+
+    public void writeObject(
+        Object    obj)
+        throws IOException
+    {
+        if (obj == null)
+        {
+            writeNull();
+        }
+        else if (obj instanceof DERObject)
+        {
+            ((DERObject)obj).encode(this);
+        }
+        else if (obj instanceof DEREncodable)
+        {
+            ((DEREncodable)obj).getDERObject().encode(this);
+        }
+        else
+        {
+            throw new IOException(&quot;object not ASN1Encodable&quot;);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1ParsingException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1ParsingException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.asn1;
+
+public class ASN1ParsingException
+    extends IllegalStateException
+{
+    private Throwable cause;
+
+    ASN1ParsingException(String message)
+    {
+        super(message);
+    }
+
+    ASN1ParsingException(String message, Throwable cause)
+    {
+        super(message);
+        this.cause = cause;
+    }
+
+    public Throwable getCause()
+    {
+        return cause;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Sequence$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Sequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Sequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Sequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Sequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,247 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Vector;
+
+public abstract class ASN1Sequence
+    extends ASN1Object
+{
+    private Vector seq = new Vector();
+
+    /**
+     * return an ASN1Sequence from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static ASN1Sequence getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof ASN1Sequence)
+        {
+            return (ASN1Sequence)obj;
+        }
+        else if (obj instanceof byte[])
+        {
+            try
+            {
+                return ASN1Sequence.getInstance(ASN1Object.fromByteArray((byte[])obj));
+            }
+            catch (IOException e)
+            {
+                throw new IllegalArgumentException(&quot;failed to construct sequence from byte[]: &quot; + e.getMessage());
+            }
+        }
+
+        throw new IllegalArgumentException(&quot;unknown object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * Return an ASN1 sequence from a tagged object. There is a special
+     * case here, if an object appears to have been explicitly tagged on
+     * reading but we were expecting it to be implicitly tagged in the
+     * normal course of events it indicates that we lost the surrounding
+     * sequence - so we need to add it back (this will happen if the tagged
+     * object is a sequence that contains other sequences). If you are
+     * dealing with implicitly tagged sequences you really &lt;b&gt;should&lt;/b&gt;
+     * be using this method.
+     *
+     * @param obj the tagged object.
+     * @param explicit true if the object is meant to be explicitly tagged,
+     *          false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *          be converted.
+     */
+    public static ASN1Sequence getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        if (explicit)
+        {
+            if (!obj.isExplicit())
+            {
+                throw new IllegalArgumentException(&quot;object implicit - explicit expected.&quot;);
+            }
+
+            return (ASN1Sequence)obj.getObject();
+        }
+        else
+        {
+            //
+            // constructed object which appears to be explicitly tagged
+            // when it should be implicit means we have to add the
+            // surrounding sequence.
+            //
+            if (obj.isExplicit())
+            {
+                if (obj instanceof BERTaggedObject)
+                {
+                    return new BERSequence(obj.getObject());
+                }
+                else
+                {
+                    return new DERSequence(obj.getObject());
+                }
+            }
+            else
+            {
+                if (obj.getObject() instanceof ASN1Sequence)
+                {
+                    return (ASN1Sequence)obj.getObject();
+                }
+            }
+        }
+
+        throw new IllegalArgumentException(&quot;unknown object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    public Enumeration getObjects()
+    {
+        return seq.elements();
+    }
+
+    public ASN1SequenceParser parser()
+    {
+        final ASN1Sequence outer = this;
+
+        return new ASN1SequenceParser()
+        {
+            private final int max = size();
+
+            private int index;
+
+            public DEREncodable readObject() throws IOException
+            {
+                if (index == max)
+                {
+                    return null;
+                }
+
+                DEREncodable obj = getObjectAt(index++);
+                if (obj instanceof ASN1Sequence)
+                {
+                    return ((ASN1Sequence)obj).parser();
+                }
+                if (obj instanceof ASN1Set)
+                {
+                    return ((ASN1Set)obj).parser();
+                }
+
+                return obj;
+            }
+
+            public DERObject getLoadedObject()
+            {
+                return outer;
+            }
+
+            public DERObject getDERObject()
+            {
+                return outer;
+            }
+        };
+    }
+
+    /**
+     * return the object at the sequence position indicated by index.
+     *
+     * @param index the sequence number (starting at zero) of the object
+     * @return the object at the sequence position indicated by index.
+     */
+    public DEREncodable getObjectAt(
+        int index)
+    {
+        return (DEREncodable)seq.elementAt(index);
+    }
+
+    /**
+     * return the number of objects in this sequence.
+     *
+     * @return the number of objects in this sequence.
+     */
+    public int size()
+    {
+        return seq.size();
+    }
+
+    public int hashCode()
+    {
+        Enumeration             e = this.getObjects();
+        int                     hashCode = size();
+
+        while (e.hasMoreElements())
+        {
+            Object o = getNext(e);
+            hashCode *= 17;
+
+            hashCode ^= o.hashCode();
+        }
+
+        return hashCode;
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof ASN1Sequence))
+        {
+            return false;
+        }
+
+        ASN1Sequence   other = (ASN1Sequence)o;
+
+        if (this.size() != other.size())
+        {
+            return false;
+        }
+
+        Enumeration s1 = this.getObjects();
+        Enumeration s2 = other.getObjects();
+
+        while (s1.hasMoreElements())
+        {
+            DEREncodable  obj1 = getNext(s1);
+            DEREncodable  obj2 = getNext(s2);
+
+            DERObject  o1 = obj1.getDERObject();
+            DERObject  o2 = obj2.getDERObject();
+
+            if (o1 == o2 || o1.equals(o2))
+            {
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private DEREncodable getNext(Enumeration e)
+    {
+        DEREncodable encObj = (DEREncodable)e.nextElement();
+
+        // unfortunately null was allowed as a substitute for DER null
+        if (encObj == null)
+        {
+            return DERNull.INSTANCE;
+        }
+
+        return encObj;
+    }
+
+    protected void addObject(
+        DEREncodable obj)
+    {
+        seq.addElement(obj);
+    }
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+
+    public String toString()
+    {
+      return seq.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1SequenceParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1SequenceParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    DEREncodable readObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Set$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Set.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1Set.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1Set.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1Set.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1Set.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,345 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Vector;
+
+abstract public class ASN1Set
+    extends ASN1Object
+{
+    protected Vector set = new Vector();
+
+    /**
+     * return an ASN1Set from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static ASN1Set getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof ASN1Set)
+        {
+            return (ASN1Set)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;unknown object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * Return an ASN1 set from a tagged object. There is a special
+     * case here, if an object appears to have been explicitly tagged on
+     * reading but we were expecting it to be implicitly tagged in the
+     * normal course of events it indicates that we lost the surrounding
+     * set - so we need to add it back (this will happen if the tagged
+     * object is a sequence that contains other sequences). If you are
+     * dealing with implicitly tagged sets you really &lt;b&gt;should&lt;/b&gt;
+     * be using this method.
+     *
+     * @param obj the tagged object.
+     * @param explicit true if the object is meant to be explicitly tagged
+     *          false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *          be converted.
+     */
+    public static ASN1Set getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        if (explicit)
+        {
+            if (!obj.isExplicit())
+            {
+                throw new IllegalArgumentException(&quot;object implicit - explicit expected.&quot;);
+            }
+
+            return (ASN1Set)obj.getObject();
+        }
+        else
+        {
+            //
+            // constructed object which appears to be explicitly tagged
+            // and it's really implicit means we have to add the
+            // surrounding sequence.
+            //
+            if (obj.isExplicit())
+            {
+                ASN1Set    set = new DERSet(obj.getObject());
+
+                return set;
+            }
+            else
+            {
+                if (obj.getObject() instanceof ASN1Set)
+                {
+                    return (ASN1Set)obj.getObject();
+                }
+
+                //
+                // in this case the parser returns a sequence, convert it
+                // into a set.
+                //
+                ASN1EncodableVector  v = new ASN1EncodableVector();
+
+                if (obj.getObject() instanceof ASN1Sequence)
+                {
+                    ASN1Sequence s = (ASN1Sequence)obj.getObject();
+                    Enumeration e = s.getObjects();
+
+                    while (e.hasMoreElements())
+                    {
+                        v.add((DEREncodable)e.nextElement());
+                    }
+
+                    return new DERSet(v, false);
+                }
+            }
+        }
+
+        throw new IllegalArgumentException(&quot;unknown object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    public ASN1Set()
+    {
+    }
+
+    public Enumeration getObjects()
+    {
+        return set.elements();
+    }
+
+    /**
+     * return the object at the set position indicated by index.
+     *
+     * @param index the set number (starting at zero) of the object
+     * @return the object at the set position indicated by index.
+     */
+    public DEREncodable getObjectAt(
+        int index)
+    {
+        return (DEREncodable)set.elementAt(index);
+    }
+
+    /**
+     * return the number of objects in this set.
+     *
+     * @return the number of objects in this set.
+     */
+    public int size()
+    {
+        return set.size();
+    }
+
+    public ASN1Encodable[] toArray()
+    {
+        ASN1Encodable[] values = new ASN1Encodable[this.size()];
+
+        for (int i = 0; i != this.size(); i++)
+        {
+            values[i] = (ASN1Encodable)this.getObjectAt(i);
+        }
+
+        return values;
+    }
+
+    public ASN1SetParser parser()
+    {
+        final ASN1Set outer = this;
+
+        return new ASN1SetParser()
+        {
+            private final int max = size();
+
+            private int index;
+
+            public DEREncodable readObject() throws IOException
+            {
+                if (index == max)
+                {
+                    return null;
+                }
+
+                DEREncodable obj = getObjectAt(index++);
+                if (obj instanceof ASN1Sequence)
+                {
+                    return ((ASN1Sequence)obj).parser();
+                }
+                if (obj instanceof ASN1Set)
+                {
+                    return ((ASN1Set)obj).parser();
+                }
+
+                return obj;
+            }
+
+            public DERObject getLoadedObject()
+            {
+                return outer;
+            }
+
+            public DERObject getDERObject()
+            {
+                return outer;
+            }
+        };
+    }
+
+    public int hashCode()
+    {
+        Enumeration             e = this.getObjects();
+        int                     hashCode = size();
+
+        while (e.hasMoreElements())
+        {
+            Object o = getNext(e);
+            hashCode *= 17;
+
+            hashCode ^= o.hashCode();
+        }
+
+        return hashCode;
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof ASN1Set))
+        {
+            return false;
+        }
+
+        ASN1Set   other = (ASN1Set)o;
+
+        if (this.size() != other.size())
+        {
+            return false;
+        }
+
+        Enumeration s1 = this.getObjects();
+        Enumeration s2 = other.getObjects();
+
+        while (s1.hasMoreElements())
+        {
+            DEREncodable  obj1 = getNext(s1);
+            DEREncodable  obj2 = getNext(s2);
+
+            DERObject  o1 = obj1.getDERObject();
+            DERObject  o2 = obj2.getDERObject();
+
+            if (o1 == o2 || o1.equals(o2))
+            {
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private DEREncodable getNext(Enumeration e)
+    {
+        DEREncodable encObj = (DEREncodable)e.nextElement();
+
+        // unfortunately null was allowed as a substitute for DER null
+        if (encObj == null)
+        {
+            return DERNull.INSTANCE;
+        }
+
+        return encObj;
+    }
+
+    /**
+     * return true if a &lt;= b (arrays are assumed padded with zeros).
+     */
+    private boolean lessThanOrEqual(
+         byte[] a,
+         byte[] b)
+    {
+        int len = Math.min(a.length, b.length);
+        for (int i = 0; i != len; ++i)
+        {
+            if (a[i] != b[i])
+            {
+                return (a[i] &amp; 0xff) &lt; (b[i] &amp; 0xff);
+            }
+        }
+        return len == a.length;
+    }
+
+    private byte[] getEncoded(
+        DEREncodable obj)
+    {
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        ASN1OutputStream        aOut = new ASN1OutputStream(bOut);
+
+        try
+        {
+            aOut.writeObject(obj);
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException(&quot;cannot encode object added to SET&quot;);
+        }
+
+        return bOut.toByteArray();
+    }
+
+    protected void sort()
+    {
+        if (set.size() &gt; 1)
+        {
+            boolean    swapped = true;
+            int        lastSwap = set.size() - 1;
+
+            while (swapped)
+            {
+                int    index = 0;
+                int    swapIndex = 0;
+                byte[] a = getEncoded((DEREncodable)set.elementAt(0));
+
+                swapped = false;
+
+                while (index != lastSwap)
+                {
+                    byte[] b = getEncoded((DEREncodable)set.elementAt(index + 1));
+
+                    if (lessThanOrEqual(a, b))
+                    {
+                        a = b;
+                    }
+                    else
+                    {
+                        Object  o = set.elementAt(index);
+
+                        set.setElementAt(set.elementAt(index + 1), index);
+                        set.setElementAt(o, index + 1);
+
+                        swapped = true;
+                        swapIndex = index;
+                    }
+
+                    index++;
+                }
+
+                lastSwap = swapIndex;
+            }
+        }
+    }
+
+    protected void addObject(
+        DEREncodable obj)
+    {
+        set.addElement(obj);
+    }
+
+    abstract void encode(DEROutputStream out)
+            throws IOException;
+
+    public String toString()
+    {
+      return set.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1SetParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1SetParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1SetParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1SetParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1SetParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    public DEREncodable readObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1StreamParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1StreamParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,245 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+public class ASN1StreamParser
+{
+    private final InputStream _in;
+    private final int         _limit;
+
+    public ASN1StreamParser(
+        InputStream in)
+    {
+        this(in, ASN1InputStream.findLimit(in));
+    }
+
+    public ASN1StreamParser(
+        InputStream in,
+        int         limit)
+    {
+        this._in = in;
+        this._limit = limit;
+    }
+
+    public ASN1StreamParser(
+        byte[] encoding)
+    {
+        this(new ByteArrayInputStream(encoding), encoding.length);
+    }
+
+    DEREncodable readIndef(int tagValue) throws IOException
+    {
+        // Note: INDEF =&gt; CONSTRUCTED
+
+        // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+        switch (tagValue)
+        {
+            case DERTags.EXTERNAL:
+                return new DERExternalParser(this);
+            case DERTags.OCTET_STRING:
+                return new BEROctetStringParser(this);
+            case DERTags.SEQUENCE:
+                return new BERSequenceParser(this);
+            case DERTags.SET:
+                return new BERSetParser(this);
+            default:
+                throw new ASN1Exception(&quot;unknown BER object encountered: 0x&quot; + Integer.toHexString(tagValue));
+        }
+    }
+
+    DEREncodable readImplicit(boolean constructed, int tag) throws IOException
+    {
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            if (!constructed)
+            {
+                throw new IOException(&quot;indefinite length primitive encoding encountered&quot;);
+            }
+
+            return readIndef(tag);
+        }
+
+        if (constructed)
+        {
+            switch (tag)
+            {
+                case DERTags.SET:
+                    return new DERSetParser(this);
+                case DERTags.SEQUENCE:
+                    return new DERSequenceParser(this);
+                case DERTags.OCTET_STRING:
+                    return new BEROctetStringParser(this);
+            }
+        }
+        else
+        {
+            switch (tag)
+            {
+                case DERTags.SET:
+                    throw new ASN1Exception(&quot;sequences must use constructed encoding (see X.690 8.9.1/8.10.1)&quot;);
+                case DERTags.SEQUENCE:
+                    throw new ASN1Exception(&quot;sets must use constructed encoding (see X.690 8.11.1/8.12.1)&quot;);
+                case DERTags.OCTET_STRING:
+                    return new DEROctetStringParser((DefiniteLengthInputStream)_in);
+            }
+        }
+
+        // TODO ASN1Exception
+        throw new RuntimeException(&quot;implicit tagging not implemented&quot;);
+    }
+
+    DERObject readTaggedObject(boolean constructed, int tag) throws IOException
+    {
+        if (!constructed)
+        {
+            // Note: !CONSTRUCTED =&gt; IMPLICIT
+            DefiniteLengthInputStream defIn = (DefiniteLengthInputStream)_in;
+            return new DERTaggedObject(false, tag, new DEROctetString(defIn.toByteArray()));
+        }
+
+        ASN1EncodableVector v = readVector();
+
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            return v.size() == 1
+                ?   new BERTaggedObject(true, tag, v.get(0))
+                :   new BERTaggedObject(false, tag, BERFactory.createSequence(v));
+        }
+
+        return v.size() == 1
+            ?   new DERTaggedObject(true, tag, v.get(0))
+            :   new DERTaggedObject(false, tag, DERFactory.createSequence(v));
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        int tag = _in.read();
+        if (tag == -1)
+        {
+            return null;
+        }
+
+        //
+        // turn of looking for &quot;00&quot; while we resolve the tag
+        //
+        set00Check(false);
+
+        //
+        // calculate tag number
+        //
+        int tagNo = ASN1InputStream.readTagNumber(_in, tag);
+
+        boolean isConstructed = (tag &amp; DERTags.CONSTRUCTED) != 0;
+
+        //
+        // calculate length
+        //
+        int length = ASN1InputStream.readLength(_in, _limit);
+
+        if (length &lt; 0) // indefinite length method
+        {
+            if (!isConstructed)
+            {
+                throw new IOException(&quot;indefinite length primitive encoding encountered&quot;);
+            }
+
+            IndefiniteLengthInputStream indIn = new IndefiniteLengthInputStream(_in, _limit);
+            ASN1StreamParser sp = new ASN1StreamParser(indIn, _limit);
+
+            if ((tag &amp; DERTags.APPLICATION) != 0)
+            {
+                return new BERApplicationSpecificParser(tagNo, sp);
+            }
+
+            if ((tag &amp; DERTags.TAGGED) != 0)
+            {
+                return new BERTaggedObjectParser(true, tagNo, sp);
+            }
+
+            return sp.readIndef(tagNo);
+        }
+        else
+        {
+            DefiniteLengthInputStream defIn = new DefiniteLengthInputStream(_in, length);
+
+            if ((tag &amp; DERTags.APPLICATION) != 0)
+            {
+                return new DERApplicationSpecific(isConstructed, tagNo, defIn.toByteArray());
+            }
+
+            if ((tag &amp; DERTags.TAGGED) != 0)
+            {
+                return new BERTaggedObjectParser(isConstructed, tagNo, new ASN1StreamParser(defIn));
+            }
+
+            if (isConstructed)
+            {
+                // TODO There are other tags that may be constructed (e.g. BIT_STRING)
+                switch (tagNo)
+                {
+                    case DERTags.OCTET_STRING:
+                        //
+                        // yes, people actually do this...
+                        //
+                        return new BEROctetStringParser(new ASN1StreamParser(defIn));
+                    case DERTags.SEQUENCE:
+                        return new DERSequenceParser(new ASN1StreamParser(defIn));
+                    case DERTags.SET:
+                        return new DERSetParser(new ASN1StreamParser(defIn));
+                    case DERTags.EXTERNAL:
+                        return new DERExternalParser(new ASN1StreamParser(defIn));
+                    default:
+                        // TODO Add DERUnknownTagParser class?
+                        return new DERUnknownTag(true, tagNo, defIn.toByteArray());
+                }
+            }
+
+            // Some primitive encodings can be handled by parsers too...
+            switch (tagNo)
+            {
+                case DERTags.OCTET_STRING:
+                    return new DEROctetStringParser(defIn);
+            }
+
+            try
+            {
+                return ASN1InputStream.createPrimitiveDERObject(tagNo, defIn.toByteArray());
+            }
+            catch (IllegalArgumentException e)
+            {
+                throw new ASN1Exception(&quot;corrupted stream detected&quot;, e);
+            }
+        }
+    }
+
+    private void set00Check(boolean enabled)
+    {
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            ((IndefiniteLengthInputStream)_in).setEofOn00(enabled);
+        }
+    }
+
+    ASN1EncodableVector readVector() throws IOException
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        DEREncodable obj;
+        while ((obj = readObject()) != null)
+        {
+            if (obj instanceof InMemoryRepresentable)
+            {
+                v.add(((InMemoryRepresentable)obj).getLoadedObject());
+            }
+            else
+            {
+                v.add(obj.getDERObject());
+            }
+        }
+
+        return v;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,6 @@
+package org.bouncycastle.asn1;
+
+public interface ASN1String
+{
+    public String getString();
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1TaggedObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,215 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * ASN.1 TaggedObject - in ASN.1 notation this is any object preceded by
+ * a [n] where n is some number - these are assumed to follow the construction
+ * rules (as with sequences).
+ */
+public abstract class ASN1TaggedObject
+    extends ASN1Object
+    implements ASN1TaggedObjectParser
+{
+    int             tagNo;
+    boolean         empty = false;
+    boolean         explicit = true;
+    DEREncodable    obj = null;
+
+    static public ASN1TaggedObject getInstance(
+        ASN1TaggedObject    obj,
+        boolean             explicit)
+    {
+        if (explicit)
+        {
+            return (ASN1TaggedObject)obj.getObject();
+        }
+
+        throw new IllegalArgumentException(&quot;implicitly tagged tagged object&quot;);
+    }
+
+    static public ASN1TaggedObject getInstance(
+        Object obj)
+    {
+        if (obj == null || obj instanceof ASN1TaggedObject)
+        {
+                return (ASN1TaggedObject)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;unknown object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * Create a tagged object in the explicit style.
+     *
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public ASN1TaggedObject(
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        this.explicit = true;
+        this.tagNo = tagNo;
+        this.obj = obj;
+    }
+
+    /**
+     * Create a tagged object with the style given by the value of explicit.
+     * &lt;p&gt;
+     * If the object implements ASN1Choice the tag style will always be changed
+     * to explicit in accordance with the ASN.1 encoding rules.
+     * &lt;/p&gt;
+     * @param explicit true if the object is explicitly tagged.
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public ASN1TaggedObject(
+        boolean         explicit,
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        if (obj instanceof ASN1Choice)
+        {
+            this.explicit = true;
+        }
+        else
+        {
+            this.explicit = explicit;
+        }
+
+        this.tagNo = tagNo;
+        this.obj = obj;
+    }
+
+    boolean asn1Equals(
+        DERObject o)
+    {
+        if (!(o instanceof ASN1TaggedObject))
+        {
+            return false;
+        }
+
+        ASN1TaggedObject other = (ASN1TaggedObject)o;
+
+        if (tagNo != other.tagNo || empty != other.empty || explicit != other.explicit)
+        {
+            return false;
+        }
+
+        if(obj == null)
+        {
+            if (other.obj != null)
+            {
+                return false;
+            }
+        }
+        else
+        {
+            if (!(obj.getDERObject().equals(other.obj.getDERObject())))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public int hashCode()
+    {
+        int code = tagNo;
+
+        // TODO: actually this is wrong - the problem is that a re-encoded
+        // object may end up with a different hashCode due to implicit
+        // tagging. As implicit tagging is ambiguous if a sequence is involved
+        // it seems the only correct method for both equals and hashCode is to
+        // compare the encodings...
+        if (obj != null)
+        {
+            code ^= obj.hashCode();
+        }
+
+        return code;
+    }
+
+    public int getTagNo()
+    {
+        return tagNo;
+    }
+
+    /**
+     * return whether or not the object may be explicitly tagged.
+     * &lt;p&gt;
+     * Note: if the object has been read from an input stream, the only
+     * time you can be sure if isExplicit is returning the true state of
+     * affairs is if it returns false. An implicitly tagged object may appear
+     * to be explicitly tagged, so you need to understand the context under
+     * which the reading was done as well, see getObject below.
+     */
+    public boolean isExplicit()
+    {
+        return explicit;
+    }
+
+    public boolean isEmpty()
+    {
+        return empty;
+    }
+
+    /**
+     * return whatever was following the tag.
+     * &lt;p&gt;
+     * Note: tagged objects are generally context dependent if you're
+     * trying to extract a tagged object you should be going via the
+     * appropriate getInstance method.
+     */
+    public DERObject getObject()
+    {
+        if (obj != null)
+        {
+            return obj.getDERObject();
+        }
+
+        return null;
+    }
+
+    /**
+     * Return the object held in this tagged object as a parser assuming it has
+     * the type of the passed in tag. If the object doesn't have a parser
+     * associated with it, the base object is returned.
+     */
+    public DEREncodable getObjectParser(
+        int     tag,
+        boolean isExplicit)
+    {
+        switch (tag)
+        {
+        case DERTags.SET:
+            return ASN1Set.getInstance(this, isExplicit).parser();
+        case DERTags.SEQUENCE:
+            return ASN1Sequence.getInstance(this, isExplicit).parser();
+        case DERTags.OCTET_STRING:
+            return ASN1OctetString.getInstance(this, isExplicit).parser();
+        }
+
+        if (isExplicit)
+        {
+            return getObject();
+        }
+
+        throw new RuntimeException(&quot;implicit tagging not implemented for tag: &quot; + tag);
+    }
+
+    public DERObject getLoadedObject()
+    {
+        return this.getDERObject();
+    }
+
+    abstract void encode(DEROutputStream  out)
+        throws IOException;
+
+    public String toString()
+    {
+        return &quot;[&quot; + tagNo + &quot;]&quot; + obj;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1TaggedObjectParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface ASN1TaggedObjectParser
+    extends DEREncodable, InMemoryRepresentable
+{
+    public int getTagNo();
+
+    public DEREncodable getObjectParser(int tag, boolean isExplicit)
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ASN1UTCTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ASN1UTCTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+
+public class ASN1UTCTime
+    extends DERUTCTime
+{
+    ASN1UTCTime(byte[] bytes)
+    {
+        super(bytes);
+    }
+
+  /*  public ASN1UTCTime(Date time)
+    {
+        super(time);
+    }
+*/
+ /*   public ASN1UTCTime(String time)
+    {
+        super(time);
+    }
+    */
+}

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERApplicationSpecific.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+public class BERApplicationSpecific
+    extends DERApplicationSpecific
+{
+    public BERApplicationSpecific(int tagNo, ASN1EncodableVector vec)
+    {
+        super(tagNo, vec);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERApplicationSpecificParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class BERApplicationSpecificParser
+    implements ASN1ApplicationSpecificParser
+{
+    private final int tag;
+    private final ASN1StreamParser parser;
+
+    BERApplicationSpecificParser(int tag, ASN1StreamParser parser)
+    {
+        this.tag = tag;
+        this.parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+         return new BERApplicationSpecific(tag, parser.readVector());
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage(), e);
+        }
+    }
+
+}

Added: trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERConstructedOctetString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,157 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Vector;
+
+public class BERConstructedOctetString
+    extends DEROctetString
+{
+    private static final int MAX_LENGTH = 1000;
+
+    /**
+     * convert a vector of octet strings into a single byte string
+     */
+    static private byte[] toBytes(
+        Vector  octs)
+    {
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+
+        for (int i = 0; i != octs.size(); i++)
+        {
+            try
+            {
+                DEROctetString  o = (DEROctetString)octs.elementAt(i);
+
+                bOut.write(o.getOctets());
+            }
+            catch (ClassCastException e)
+            {
+                throw new IllegalArgumentException(octs.elementAt(i).getClass().getName() + &quot; found in input should only contain DEROctetString&quot;);
+            }
+            catch (IOException e)
+            {
+                throw new IllegalArgumentException(&quot;exception converting octets &quot; + e.toString());
+            }
+        }
+
+        return bOut.toByteArray();
+    }
+
+    private Vector  octs;
+
+    /**
+     * @param string the octets making up the octet string.
+     */
+    public BERConstructedOctetString(
+        byte[]  string)
+    {
+        super(string);
+    }
+
+    public BERConstructedOctetString(
+        Vector  octs)
+    {
+        super(toBytes(octs));
+
+        this.octs = octs;
+    }
+
+    public BERConstructedOctetString(
+        DERObject  obj)
+    {
+        super(obj);
+    }
+
+    public BERConstructedOctetString(
+        DEREncodable  obj)
+    {
+        super(obj.getDERObject());
+    }
+
+    public byte[] getOctets()
+    {
+        return string;
+    }
+
+    /**
+     * return the DER octets that make up this string.
+     */
+    public Enumeration getObjects()
+    {
+        if (octs == null)
+        {
+            return generateOcts().elements();
+        }
+
+        return octs.elements();
+    }
+
+    private Vector generateOcts()
+    {
+        Vector vec = new Vector();
+        for (int i = 0; i &lt; string.length; i += MAX_LENGTH)
+        {
+            int end;
+
+            if (i + MAX_LENGTH &gt; string.length)
+            {
+                end = string.length;
+            }
+            else
+            {
+                end = i + MAX_LENGTH;
+            }
+
+            byte[] nStr = new byte[end - i];
+
+            System.arraycopy(string, i, nStr, 0, nStr.length);
+
+            vec.addElement(new DEROctetString(nStr));
+         }
+
+         return vec;
+    }
+
+    public void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.write(CONSTRUCTED | OCTET_STRING);
+
+            out.write(0x80);
+
+            //
+            // write out the octet array
+            //
+            Enumeration e = getObjects();
+            while (e.hasMoreElements())
+            {
+                out.writeObject(e.nextElement());
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+
+    public static BERConstructedOctetString fromSequence(ASN1Sequence seq)
+    {
+        Vector      v = new Vector();
+        Enumeration e = seq.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            v.addElement(e.nextElement());
+        }
+
+        return new BERConstructedOctetString(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERFactory.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+class BERFactory
+{
+    static final BERSequence EMPTY_SEQUENCE = new BERSequence();
+    static final BERSet EMPTY_SET = new BERSet();
+
+    static BERSequence createSequence(ASN1EncodableVector v)
+    {
+        return v.size() &lt; 1 ? EMPTY_SEQUENCE : new BERSequence(v);
+    }
+
+    static BERSet createSet(ASN1EncodableVector v)
+    {
+        return v.size() &lt; 1 ? EMPTY_SET : new BERSet(v);
+    }
+
+    static BERSet createSet(ASN1EncodableVector v, boolean needsSorting)
+    {
+        return v.size() &lt; 1 ? EMPTY_SET : new BERSet(v, needsSorting);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BEROctetStringParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BEROctetStringParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.io.Streams;
+
+public class BEROctetStringParser
+    implements ASN1OctetStringParser
+{
+    private ASN1StreamParser _parser;
+
+    BEROctetStringParser(
+        ASN1StreamParser parser)
+    {
+        _parser = parser;
+    }
+
+    public InputStream getOctetStream()
+    {
+        return new ConstructedOctetStream(_parser);
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new BERConstructedOctetString(Streams.readAll(getOctetStream()));
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(&quot;IOException converting stream to byte array: &quot; + e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BEROutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BEROutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BEROutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BEROutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BEROutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class BEROutputStream
+    extends DEROutputStream
+{
+    public BEROutputStream(
+        OutputStream    os)
+    {
+        super(os);
+    }
+
+    public void writeObject(
+        Object    obj)
+        throws IOException
+    {
+        if (obj == null)
+        {
+            writeNull();
+        }
+        else if (obj instanceof DERObject)
+        {
+            ((DERObject)obj).encode(this);
+        }
+        else if (obj instanceof DEREncodable)
+        {
+            ((DEREncodable)obj).getDERObject().encode(this);
+        }
+        else
+        {
+            throw new IOException(&quot;object not BEREncodable&quot;);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,59 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class BERSequence
+    extends DERSequence
+{
+    /**
+     * create an empty sequence
+     */
+    public BERSequence()
+    {
+    }
+
+    /**
+     * create a sequence containing one object
+     */
+    public BERSequence(
+        DEREncodable    obj)
+    {
+        super(obj);
+    }
+
+    /**
+     * create a sequence containing a vector of objects.
+     */
+    public BERSequence(
+        ASN1EncodableVector   v)
+    {
+        super(v);
+    }
+
+    /*
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.write(SEQUENCE | CONSTRUCTED);
+            out.write(0x80);
+
+            Enumeration e = getObjects();
+            while (e.hasMoreElements())
+            {
+                out.writeObject(e.nextElement());
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSequenceParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSequenceParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSequenceParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSequenceParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class BERSequenceParser
+    implements ASN1SequenceParser
+{
+    private ASN1StreamParser _parser;
+
+    BERSequenceParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new BERSequence(_parser.readVector());
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException(e.getMessage());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSet.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSet.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSet.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSet.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSet.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,69 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class BERSet
+    extends DERSet
+{
+    /**
+     * create an empty sequence
+     */
+    public BERSet()
+    {
+    }
+
+    /**
+     * create a set containing one object
+     */
+    public BERSet(
+        DEREncodable    obj)
+    {
+        super(obj);
+    }
+
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    public BERSet(
+        ASN1EncodableVector   v)
+    {
+        super(v, false);
+    }
+
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    BERSet(
+        ASN1EncodableVector  v,
+        boolean              needsSorting)
+    {
+        super(v, needsSorting);
+    }
+
+    /*
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.write(SET | CONSTRUCTED);
+            out.write(0x80);
+
+            Enumeration e = getObjects();
+            while (e.hasMoreElements())
+            {
+                out.writeObject(e.nextElement());
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERSetParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERSetParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERSetParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERSetParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERSetParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class BERSetParser
+    implements ASN1SetParser
+{
+    private ASN1StreamParser _parser;
+
+    BERSetParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new BERSet(_parser.readVector(), false);
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERTaggedObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERTaggedObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERTaggedObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,107 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+/**
+ * BER TaggedObject - in ASN.1 notation this is any object preceded by
+ * a [n] where n is some number - these are assumed to follow the construction
+ * rules (as with sequences).
+ */
+public class BERTaggedObject
+    extends DERTaggedObject
+{
+    /**
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public BERTaggedObject(
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(tagNo, obj);
+    }
+
+    /**
+     * @param explicit true if an explicitly tagged object.
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public BERTaggedObject(
+        boolean         explicit,
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(explicit, tagNo, obj);
+    }
+
+    /**
+     * create an implicitly tagged object that contains a zero
+     * length sequence.
+     */
+    public BERTaggedObject(
+        int             tagNo)
+    {
+        super(false, tagNo, new BERSequence());
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        if (out instanceof ASN1OutputStream || out instanceof BEROutputStream)
+        {
+            out.writeTag(CONSTRUCTED | TAGGED, tagNo);
+            out.write(0x80);
+
+            if (!empty)
+            {
+                if (!explicit)
+                {
+                    Enumeration e;
+                    if (obj instanceof ASN1OctetString)
+                    {
+                        if (obj instanceof BERConstructedOctetString)
+                        {
+                            e = ((BERConstructedOctetString)obj).getObjects();
+                        }
+                        else
+                        {
+                            ASN1OctetString             octs = (ASN1OctetString)obj;
+                            BERConstructedOctetString   berO = new BERConstructedOctetString(octs.getOctets());
+                            e = berO.getObjects();
+                        }
+                    }
+                    else if (obj instanceof ASN1Sequence)
+                    {
+                        e = ((ASN1Sequence)obj).getObjects();
+                    }
+                    else if (obj instanceof ASN1Set)
+                    {
+                        e = ((ASN1Set)obj).getObjects();
+                    }
+                    else
+                    {
+                        throw new RuntimeException(&quot;not implemented: &quot; + obj.getClass().getName());
+                    }
+
+                    while (e.hasMoreElements())
+                    {
+                        out.writeObject(e.nextElement());
+                    }
+                }
+                else
+                {
+                    out.writeObject(obj);
+                }
+            }
+
+            out.write(0x00);
+            out.write(0x00);
+        }
+        else
+        {
+            super.encode(out);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/BERTaggedObjectParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,78 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+public class BERTaggedObjectParser
+    implements ASN1TaggedObjectParser
+{
+    private boolean _constructed;
+    private int _tagNumber;
+    private ASN1StreamParser _parser;
+
+    /**
+     * @deprecated
+     */
+    protected BERTaggedObjectParser(
+        int         baseTag,
+        int         tagNumber,
+        InputStream contentStream)
+    {
+        this((baseTag &amp; DERTags.CONSTRUCTED) != 0, tagNumber, new ASN1StreamParser(contentStream));
+    }
+
+    BERTaggedObjectParser(
+        boolean             constructed,
+        int                 tagNumber,
+        ASN1StreamParser    parser)
+    {
+        _constructed = constructed;
+        _tagNumber = tagNumber;
+        _parser = parser;
+    }
+
+    public boolean isConstructed()
+    {
+        return _constructed;
+    }
+
+    public int getTagNo()
+    {
+        return _tagNumber;
+    }
+
+    public DEREncodable getObjectParser(
+        int     tag,
+        boolean isExplicit)
+        throws IOException
+    {
+        if (isExplicit)
+        {
+            if (!_constructed)
+            {
+                throw new IOException(&quot;Explicit tags must be constructed (see X.690 8.14.2)&quot;);
+            }
+            return _parser.readObject();
+        }
+
+        return _parser.readImplicit(_constructed, tag);
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return _parser.readTaggedObject(_constructed, _tagNumber);
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return this.getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/ConstructedOctetStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,111 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.InputStream;
+import ewe.io.IOException;
+
+class ConstructedOctetStream
+    extends InputStream
+{
+    private final ASN1StreamParser _parser;
+
+    private boolean                _first = true;
+    private InputStream            _currentStream;
+
+    ConstructedOctetStream(
+        ASN1StreamParser parser)
+    {
+        _parser = parser;
+    }
+
+    public int read(byte[] b, int off, int len) throws IOException
+    {
+        if (_currentStream == null)
+        {
+            if (!_first)
+            {
+                return -1;
+            }
+
+            ASN1OctetStringParser s = (ASN1OctetStringParser)_parser.readObject();
+
+            if (s == null)
+            {
+                return -1;
+            }
+
+            _first = false;
+            _currentStream = s.getOctetStream();
+        }
+
+        int totalRead = 0;
+
+        for (;;)
+        {
+            int numRead = _currentStream.read(b, off + totalRead, len - totalRead);
+
+            if (numRead &gt;= 0)
+            {
+                totalRead += numRead;
+
+                if (totalRead == len)
+                {
+                    return totalRead;
+                }
+            }
+            else
+            {
+                ASN1OctetStringParser aos = (ASN1OctetStringParser)_parser.readObject();
+
+                if (aos == null)
+                {
+                    _currentStream = null;
+                    return totalRead &lt; 1 ? -1 : totalRead;
+                }
+
+                _currentStream = aos.getOctetStream();
+            }
+        }
+    }
+
+    public int read()
+        throws IOException
+    {
+        if (_currentStream == null)
+        {
+            if (!_first)
+            {
+                return -1;
+            }
+
+            ASN1OctetStringParser s = (ASN1OctetStringParser)_parser.readObject();
+    
+            if (s == null)
+            {
+                return -1;
+            }
+    
+            _first = false;
+            _currentStream = s.getOctetStream();
+        }
+
+        for (;;)
+        {
+            int b = _currentStream.read();
+
+            if (b &gt;= 0)
+            {
+                return b;
+            }
+
+            ASN1OctetStringParser s = (ASN1OctetStringParser)_parser.readObject();
+
+            if (s == null)
+            {
+                _currentStream = null;
+                return -1;
+            }
+
+            _currentStream = s.getOctetStream();
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERApplicationSpecific.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,225 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Arrays;
+
+/**
+ * Base class for an application specific object
+ */
+public class DERApplicationSpecific
+    extends ASN1Object
+{
+    private final boolean   isConstructed;
+    private final int       tag;
+    private final byte[]    octets;
+
+    DERApplicationSpecific(
+        boolean isConstructed,
+        int     tag,
+        byte[]  octets)
+    {
+        this.isConstructed = isConstructed;
+        this.tag = tag;
+        this.octets = octets;
+    }
+
+    public DERApplicationSpecific(
+        int    tag,
+        byte[] octets)
+    {
+        this(false, tag, octets);
+    }
+
+    public DERApplicationSpecific(
+        int                  tag,
+        DEREncodable         object)
+        throws IOException
+    {
+        this(true, tag, object);
+    }
+
+    public DERApplicationSpecific(
+        boolean      explicit,
+        int          tag,
+        DEREncodable object)
+        throws IOException
+    {
+        byte[] data = object.getDERObject().getDEREncoded();
+
+        this.isConstructed = explicit;
+        this.tag = tag;
+
+        if (explicit)
+        {
+            this.octets = data;
+        }
+        else
+        {
+            int lenBytes = getLengthOfLength(data);
+            byte[] tmp = new byte[data.length - lenBytes];
+            System.arraycopy(data, lenBytes, tmp, 0, tmp.length);
+            this.octets = tmp;
+        }
+    }
+
+    public DERApplicationSpecific(int tagNo, ASN1EncodableVector vec)
+    {
+        this.tag = tagNo;
+        this.isConstructed = true;
+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+
+        for (int i = 0; i != vec.size(); i++)
+        {
+            try
+            {
+                bOut.write(((ASN1Encodable)vec.get(i)).getEncoded());
+            }
+            catch (IOException e)
+            {
+                throw new ASN1ParsingException(&quot;malformed object: &quot; + e, e);
+            }
+        }
+        this.octets = bOut.toByteArray();
+    }
+
+    private int getLengthOfLength(byte[] data)
+    {
+        int count = 2;               // TODO: assumes only a 1 byte tag number
+
+        while((data[count - 1] &amp; 0x80) != 0)
+        {
+            count++;
+        }
+
+        return count;
+    }
+
+    public boolean isConstructed()
+    {
+        return isConstructed;
+    }
+
+    public byte[] getContents()
+    {
+        return octets;
+    }
+
+    public int getApplicationTag()
+    {
+        return tag;
+    }
+
+    /**
+     * Return the enclosed object assuming explicit tagging.
+     *
+     * @return  the resulting object
+     * @throws IOException if reconstruction fails.
+     */
+    public DERObject getObject()
+        throws IOException
+    {
+        return new ASN1InputStream(getContents()).readObject();
+    }
+
+    /**
+     * Return the enclosed object assuming implicit tagging.
+     *
+     * @param derTagNo the type tag that should be applied to the object's contents.
+     * @return  the resulting object
+     * @throws IOException if reconstruction fails.
+     */
+    public DERObject getObject(int derTagNo)
+        throws IOException
+    {
+        if (derTagNo &gt;= 0x1f)
+        {
+            throw new IOException(&quot;unsupported tag number&quot;);
+        }
+
+        byte[] orig = this.getEncoded();
+        byte[] tmp = replaceTagNumber(derTagNo, orig);
+
+        if ((orig[0] &amp; DERTags.CONSTRUCTED) != 0)
+        {
+            tmp[0] |= DERTags.CONSTRUCTED;
+        }
+
+        return new ASN1InputStream(tmp).readObject();
+    }
+
+    /* (non-Javadoc)
+     * @see org.bouncycastle.asn1.DERObject#encode(org.bouncycastle.asn1.DEROutputStream)
+     */
+    void encode(DEROutputStream out) throws IOException
+    {
+        int classBits = DERTags.APPLICATION;
+        if (isConstructed)
+        {
+            classBits |= DERTags.CONSTRUCTED;
+        }
+
+        out.writeEncoded(classBits, tag, octets);
+    }
+
+    boolean asn1Equals(
+        DERObject o)
+    {
+        if (!(o instanceof DERApplicationSpecific))
+        {
+            return false;
+        }
+
+        DERApplicationSpecific other = (DERApplicationSpecific)o;
+
+        return isConstructed == other.isConstructed
+            &amp;&amp; tag == other.tag
+            &amp;&amp; Arrays.areEqual(octets, other.octets);
+    }
+
+    public int hashCode()
+    {
+        return (isConstructed ? 1 : 0) ^ tag ^ Arrays.hashCode(octets);
+    }
+
+    private byte[] replaceTagNumber(int newTag, byte[] input)
+        throws IOException
+    {
+        int tagNo = input[0] &amp; 0x1f;
+        int index = 1;
+        //
+        // with tagged object tag number is bottom 5 bits, or stored at the start of the content
+        //
+        if (tagNo == 0x1f)
+        {
+            tagNo = 0;
+
+            int b = input[index++] &amp; 0xff;
+
+            // X.690-0207 8.1.2.4.2
+            // &quot;c) bits 7 to 1 of the first subsequent octet shall not all be zero.&quot;
+            if ((b &amp; 0x7f) == 0) // Note: -1 will pass
+            {
+                throw new ASN1ParsingException(&quot;corrupted stream - invalid high tag number found&quot;);
+            }
+
+            while ((b &gt;= 0) &amp;&amp; ((b &amp; 0x80) != 0))
+            {
+                tagNo |= (b &amp; 0x7f);
+                tagNo &lt;&lt;= 7;
+                b = input[index++] &amp; 0xff;
+            }
+
+            tagNo |= (b &amp; 0x7f);
+        }
+
+        byte[] tmp = new byte[input.length - index + 1];
+
+        System.arraycopy(input, index, tmp, 1, tmp.length - 1);
+
+        tmp[0] = (byte)newTag;
+
+        return tmp;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERBMPString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERBMPString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERBMPString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERBMPString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERBMPString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,125 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER BMPString object.
+ */
+public class DERBMPString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a BMP String from the given object.
+     *
+     * @param obj the object we want converted.
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERBMPString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERBMPString)
+        {
+            return (DERBMPString)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return a BMP String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *              be converted.
+     */
+    public static DERBMPString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERBMPString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERBMPString(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+    
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERBMPString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length / 2];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)((string[2 * i] &lt;&lt; 8) | (string[2 * i + 1] &amp; 0xff));
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor
+     */
+    public DERBMPString(
+        String   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    protected boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERBMPString))
+        {
+            return false;
+        }
+
+        DERBMPString  s = (DERBMPString)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        char[]  c = string.toCharArray();
+        byte[]  b = new byte[c.length * 2];
+
+        for (int i = 0; i != c.length; i++)
+        {
+            b[2 * i] = (byte)(c[i] &gt;&gt; 8);
+            b[2 * i + 1] = (byte)c[i];
+        }
+
+        out.writeEncoded(BMP_STRING, b);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERBitString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERBitString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERBitString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERBitString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERBitString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,277 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Arrays;
+
+public class DERBitString
+    extends ASN1Object
+    implements DERString
+{
+    private static final char[]  table = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+
+    protected byte[]      data;
+    protected int         padBits;
+
+    /**
+     * return the correct number of pad bits for a bit string defined in
+     * a 32 bit constant
+     */
+    static protected int getPadBits(
+        int bitString)
+    {
+        int val = 0;
+        for (int i = 3; i &gt;= 0; i--)
+        {
+            //
+            // this may look a little odd, but if it isn't done like this pre jdk1.2
+            // JVM's break!
+            //
+            if (i != 0)
+            {
+                if ((bitString &gt;&gt; (i * 8)) != 0)
+                {
+                    val = (bitString &gt;&gt; (i * 8)) &amp; 0xFF;
+                    break;
+                }
+            }
+            else
+            {
+                if (bitString != 0)
+                {
+                    val = bitString &amp; 0xFF;
+                    break;
+                }
+            }
+        }
+
+        if (val == 0)
+        {
+            return 7;
+        }
+
+
+        int bits = 1;
+
+        while (((val &lt;&lt;= 1) &amp; 0xFF) != 0)
+        {
+            bits++;
+        }
+
+        return 8 - bits;
+    }
+
+    /**
+     * return the correct number of bytes for a bit string defined in
+     * a 32 bit constant
+     */
+    static protected byte[] getBytes(int bitString)
+    {
+        int bytes = 4;
+        for (int i = 3; i &gt;= 1; i--)
+        {
+            if ((bitString &amp; (0xFF &lt;&lt; (i * 8))) != 0)
+            {
+                break;
+            }
+            bytes--;
+        }
+
+        byte[] result = new byte[bytes];
+        for (int i = 0; i &lt; bytes; i++)
+        {
+            result[i] = (byte) ((bitString &gt;&gt; (i * 8)) &amp; 0xFF);
+        }
+
+        return result;
+    }
+
+    /**
+     * return a Bit String from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERBitString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERBitString)
+        {
+            return (DERBitString)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return a Bit String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERBitString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERBitString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return fromOctetString(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    protected DERBitString(
+        byte    data,
+        int     padBits)
+    {
+        this.data = new byte[1];
+        this.data[0] = data;
+        this.padBits = padBits;
+    }
+
+    /**
+     * @param data the octets making up the bit string.
+     * @param padBits the number of extra bits at the end of the string.
+     */
+    public DERBitString(
+        byte[]  data,
+        int     padBits)
+    {
+        this.data = data;
+        this.padBits = padBits;
+    }
+
+    public DERBitString(
+        byte[]  data)
+    {
+        this(data, 0);
+    }
+
+    public DERBitString(
+        DEREncodable  obj)
+    {
+        try
+        {
+            this.data = obj.getDERObject().getEncoded(ASN1Encodable.DER);
+            this.padBits = 0;
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException(&quot;Error processing object : &quot; + e.toString());
+        }
+    }
+
+    public byte[] getBytes()
+    {
+        return data;
+    }
+
+    public int getPadBits()
+    {
+        return padBits;
+    }
+
+
+    /**
+     * @return the value of the bit string as an int (truncating if necessary)
+     */
+    public int intValue()
+    {
+        int value = 0;
+
+        for (int i = 0; i != data.length &amp;&amp; i != 4; i++)
+        {
+            value |= (data[i] &amp; 0xff) &lt;&lt; (8 * i);
+        }
+
+        return value;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        byte[]  bytes = new byte[getBytes().length + 1];
+
+        bytes[0] = (byte)getPadBits();
+        System.arraycopy(getBytes(), 0, bytes, 1, bytes.length - 1);
+
+        out.writeEncoded(BIT_STRING, bytes);
+    }
+
+    public int hashCode()
+    {
+        return padBits ^ Arrays.hashCode(data);
+    }
+
+    protected boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERBitString))
+        {
+            return false;
+        }
+
+        DERBitString other = (DERBitString)o;
+
+        return this.padBits == other.padBits
+            &amp;&amp; Arrays.areEqual(this.data, other.data);
+    }
+
+    public String getString()
+    {
+        StringBuffer          buf = new StringBuffer(&quot;#&quot;);
+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+        ASN1OutputStream      aOut = new ASN1OutputStream(bOut);
+
+        try
+        {
+            aOut.writeObject(this);
+        }
+        catch (IOException e)
+        {
+           throw new RuntimeException(&quot;internal error encoding BitString&quot;);
+        }
+
+        byte[]    string = bOut.toByteArray();
+
+        for (int i = 0; i != string.length; i++)
+        {
+            buf.append(table[(string[i] &gt;&gt;&gt; 4) &amp; 0xf]);
+            buf.append(table[string[i] &amp; 0xf]);
+        }
+
+        return buf.toString();
+    }
+
+    public String toString()
+    {
+        return getString();
+    }
+
+    static DERBitString fromOctetString(byte[] bytes)
+    {
+        if (bytes.length &lt; 1)
+        {
+            throw new IllegalArgumentException(&quot;truncated BIT STRING detected&quot;);
+        }
+
+        int padBits = bytes[0];
+        byte[] data = new byte[bytes.length - 1];
+
+        if (data.length != 0)
+        {
+            System.arraycopy(bytes, 1, data, 0, bytes.length - 1);
+        }
+
+        return new DERBitString(data, padBits);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERBoolean.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERBoolean.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERBoolean.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERBoolean.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERBoolean.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,117 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERBoolean
+    extends ASN1Object
+{
+    byte         value;
+
+    public static final DERBoolean FALSE = new DERBoolean(false);
+    public static final DERBoolean TRUE  = new DERBoolean(true);
+
+    /**
+     * return a boolean from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERBoolean getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERBoolean)
+        {
+            return (DERBoolean)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return a DERBoolean from the passed in boolean.
+     */
+    public static DERBoolean getInstance(
+        boolean  value)
+    {
+        return (value ? TRUE : FALSE);
+    }
+
+    /**
+     * return a Boolean from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERBoolean getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERBoolean)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERBoolean(((ASN1OctetString)o).getOctets());
+        }
+    }
+    
+    public DERBoolean(
+        byte[]       value)
+    {
+        if (value.length != 1)
+        {
+            throw new IllegalArgumentException(&quot;byte value should have 1 byte in it&quot;);
+        }
+        
+        this.value = value[0];
+    }
+
+    public DERBoolean(
+        boolean     value)
+    {
+        this.value = (value) ? (byte)0xff : (byte)0;
+    }
+
+    public boolean isTrue()
+    {
+        return (value != 0);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        byte[]  bytes = new byte[1];
+
+        bytes[0] = value;
+
+        out.writeEncoded(BOOLEAN, bytes);
+    }
+    
+    protected boolean asn1Equals(
+        DERObject  o)
+    {
+        if ((o == null) || !(o instanceof DERBoolean))
+        {
+            return false;
+        }
+
+        return (value == ((DERBoolean)o).value);
+    }
+    
+    public int hashCode()
+    {
+        return value;
+    }
+
+
+    public String toString()
+    {
+      return (value != 0) ? &quot;TRUE&quot; : &quot;FALSE&quot;;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEREncodable.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEREncodable.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEREncodable.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEREncodable.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEREncodable.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,6 @@
+package org.bouncycastle.asn1;
+
+public interface DEREncodable
+{
+    public DERObject getDERObject();
+}

Added: trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEREncodableVector.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEREncodableVector.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEREncodableVector.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEREncodableVector.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.util.Vector;
+
+/**
+ * a general class for building up a vector of DER encodable objects -
+ * this will eventually be superceded by ASN1EncodableVector so you should
+ * use that class in preference.
+ */
+public class DEREncodableVector
+{
+    Vector v = new Vector();
+
+    /**
+     * @deprecated use ASN1EncodableVector instead.
+     */
+    public DEREncodableVector()
+    {
+
+    }
+
+    public void add(
+        DEREncodable   obj)
+    {
+        v.addElement(obj);
+    }
+
+    public DEREncodable get(
+        int i)
+    {
+        return (DEREncodable)v.elementAt(i);
+    }
+
+    public int size()
+    {
+        return v.size();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEREnumerated.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEREnumerated.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEREnumerated.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEREnumerated.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEREnumerated.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,101 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.util.Arrays;
+
+public class DEREnumerated
+    extends ASN1Object
+{
+    byte[]      bytes;
+
+    /**
+     * return an integer from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DEREnumerated getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DEREnumerated)
+        {
+            return (DEREnumerated)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return an Enumerated from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DEREnumerated getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DEREnumerated)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DEREnumerated(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    public DEREnumerated(
+        int         value)
+    {
+        bytes = BigInteger.valueOf(value).toByteArray();
+    }
+
+    public DEREnumerated(
+        BigInteger   value)
+    {
+        bytes = value.toByteArray();
+    }
+
+    public DEREnumerated(
+        byte[]   bytes)
+    {
+        this.bytes = bytes;
+    }
+
+    public BigInteger getValue()
+    {
+        return new BigInteger(bytes);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(ENUMERATED, bytes);
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DEREnumerated))
+        {
+            return false;
+        }
+
+        DEREnumerated other = (DEREnumerated)o;
+
+        return Arrays.areEqual(this.bytes, other.bytes);
+    }
+
+    public int hashCode()
+    {
+        return Arrays.hashCode(bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERExternal.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERExternal.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERExternal.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERExternal.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERExternal.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,283 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+/**
+ * Class representing the DER-type External
+ */
+public class DERExternal
+    extends ASN1Object
+{
+    private DERObjectIdentifier directReference;
+    private DERInteger indirectReference;
+    private ASN1Object dataValueDescriptor;
+    private int encoding;
+    private DERObject externalContent;
+
+    public DERExternal(ASN1EncodableVector vector)
+    {
+        int offset = 0;
+
+        DERObject enc = getObjFromVector(vector, offset);
+        if (enc instanceof DERObjectIdentifier)
+        {
+            directReference = (DERObjectIdentifier)enc;
+            offset++;
+            enc = getObjFromVector(vector, offset);
+        }
+        if (enc instanceof DERInteger)
+        {
+            indirectReference = (DERInteger) enc;
+            offset++;
+            enc = getObjFromVector(vector, offset);
+        }
+        if (!(enc instanceof DERTaggedObject))
+        {
+            dataValueDescriptor = (ASN1Object) enc;
+            offset++;
+            enc = getObjFromVector(vector, offset);
+        }
+
+        if (vector.size() != offset + 1)
+        {
+            throw new IllegalArgumentException(&quot;input vector too large&quot;);
+        }
+
+        if (!(enc instanceof DERTaggedObject))
+        {
+            throw new IllegalArgumentException(&quot;No tagged object found in vector. Structure doesn't seem to be of type External&quot;);
+        }
+        DERTaggedObject obj = (DERTaggedObject)enc;
+        setEncoding(obj.getTagNo());
+        externalContent = obj.getObject();
+    }
+
+    private DERObject getObjFromVector(ASN1EncodableVector v, int index)
+    {
+        if (v.size() &lt;= index)
+        {
+            throw new IllegalArgumentException(&quot;too few objects in input vector&quot;);
+        }
+
+        return v.get(index).getDERObject();
+    }
+    /**
+     * Creates a new instance of DERExternal
+     * See X.690 for more informations about the meaning of these parameters
+     * @param directReference The direct reference or &lt;code&gt;null&lt;/code&gt; if not set.
+     * @param indirectReference The indirect reference or &lt;code&gt;null&lt;/code&gt; if not set.
+     * @param dataValueDescriptor The data value descriptor or &lt;code&gt;null&lt;/code&gt; if not set.
+     * @param externalData The external data in its encoded form.
+     */
+    public DERExternal(DERObjectIdentifier directReference, DERInteger indirectReference, ASN1Object dataValueDescriptor, DERTaggedObject externalData)
+    {
+        this(directReference, indirectReference, dataValueDescriptor, externalData.getTagNo(), externalData.getDERObject());
+    }
+
+    /**
+     * Creates a new instance of DERExternal.
+     * See X.690 for more informations about the meaning of these parameters
+     * @param directReference The direct reference or &lt;code&gt;null&lt;/code&gt; if not set.
+     * @param indirectReference The indirect reference or &lt;code&gt;null&lt;/code&gt; if not set.
+     * @param dataValueDescriptor The data value descriptor or &lt;code&gt;null&lt;/code&gt; if not set.
+     * @param encoding The encoding to be used for the external data
+     * @param externalData The external data
+     */
+    public DERExternal(DERObjectIdentifier directReference, DERInteger indirectReference, ASN1Object dataValueDescriptor, int encoding, DERObject externalData)
+    {
+        setDirectReference(directReference);
+        setIndirectReference(indirectReference);
+        setDataValueDescriptor(dataValueDescriptor);
+        setEncoding(encoding);
+        setExternalContent(externalData.getDERObject());
+    }
+
+    /* (non-Javadoc)
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode()
+    {
+        int ret = 0;
+        if (directReference != null)
+        {
+            ret = directReference.hashCode();
+        }
+        if (indirectReference != null)
+        {
+            ret ^= indirectReference.hashCode();
+        }
+        if (dataValueDescriptor != null)
+        {
+            ret ^= dataValueDescriptor.hashCode();
+        }
+        ret ^= externalContent.hashCode();
+        return ret;
+    }
+
+    /* (non-Javadoc)
+     * @see org.bouncycastle.asn1.DERObject#encode(org.bouncycastle.asn1.DEROutputStream)
+     */
+    void encode(DEROutputStream out)
+        throws IOException
+    {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        if (directReference != null)
+        {
+            baos.write(directReference.getDEREncoded());
+        }
+        if (indirectReference != null)
+        {
+            baos.write(indirectReference.getDEREncoded());
+        }
+        if (dataValueDescriptor != null)
+        {
+            baos.write(dataValueDescriptor.getDEREncoded());
+        }
+        DERTaggedObject obj = new DERTaggedObject(encoding, externalContent);
+        baos.write(obj.getDEREncoded());
+        out.writeEncoded(DERTags.CONSTRUCTED, DERTags.EXTERNAL, baos.toByteArray());
+    }
+
+    /* (non-Javadoc)
+     * @see org.bouncycastle.asn1.ASN1Object#asn1Equals(org.bouncycastle.asn1.DERObject)
+     */
+    boolean asn1Equals(DERObject o)
+    {
+        if (!(o instanceof DERExternal))
+        {
+            return false;
+        }
+        if (this == o)
+        {
+            return true;
+        }
+        DERExternal other = (DERExternal)o;
+        if (directReference != null)
+        {
+            if (other.directReference == null || !other.directReference.equals(directReference))
+            {
+                return false;
+            }
+        }
+        if (indirectReference != null)
+        {
+            if (other.indirectReference == null || !other.indirectReference.equals(indirectReference))
+            {
+                return false;
+            }
+        }
+        if (dataValueDescriptor != null)
+        {
+            if (other.dataValueDescriptor == null || !other.dataValueDescriptor.equals(dataValueDescriptor))
+            {
+                return false;
+            }
+        }
+        return externalContent.equals(other.externalContent);
+    }
+
+    /**
+     * Returns the data value descriptor
+     * @return The descriptor
+     */
+    public ASN1Object getDataValueDescriptor()
+    {
+        return dataValueDescriptor;
+    }
+
+    /**
+     * Returns the direct reference of the external element
+     * @return The reference
+     */
+    public DERObjectIdentifier getDirectReference()
+    {
+        return directReference;
+    }
+
+    /**
+     * Returns the encoding of the content. Valid values are
+     * &lt;ul&gt;
+     * &lt;li&gt;&lt;code&gt;0&lt;/code&gt; single-ASN1-type&lt;/li&gt;
+     * &lt;li&gt;&lt;code&gt;1&lt;/code&gt; OCTET STRING&lt;/li&gt;
+     * &lt;li&gt;&lt;code&gt;2&lt;/code&gt; BIT STRING&lt;/li&gt;
+     * &lt;/ul&gt;
+     * @return The encoding
+     */
+    public int getEncoding()
+    {
+        return encoding;
+    }
+
+    /**
+     * Returns the content of this element
+     * @return The content
+     */
+    public DERObject getExternalContent()
+    {
+        return externalContent;
+    }
+
+    /**
+     * Returns the indirect reference of this element
+     * @return The reference
+     */
+    public DERInteger getIndirectReference()
+    {
+        return indirectReference;
+    }
+
+    /**
+     * Sets the data value descriptor
+     * @param dataValueDescriptor The descriptor
+     */
+    private void setDataValueDescriptor(ASN1Object dataValueDescriptor)
+    {
+        this.dataValueDescriptor = dataValueDescriptor;
+    }
+
+    /**
+     * Sets the direct reference of the external element
+     * @param directReferemce The reference
+     */
+    private void setDirectReference(DERObjectIdentifier directReferemce)
+    {
+        this.directReference = directReferemce;
+    }
+
+    /**
+     * Sets the encoding of the content. Valid values are
+     * &lt;ul&gt;
+     * &lt;li&gt;&lt;code&gt;0&lt;/code&gt; single-ASN1-type&lt;/li&gt;
+     * &lt;li&gt;&lt;code&gt;1&lt;/code&gt; OCTET STRING&lt;/li&gt;
+     * &lt;li&gt;&lt;code&gt;2&lt;/code&gt; BIT STRING&lt;/li&gt;
+     * &lt;/ul&gt;
+     * @param encoding The encoding
+     */
+    private void setEncoding(int encoding)
+    {
+        if (encoding &lt; 0 || encoding &gt; 2)
+        {
+            throw new IllegalArgumentException(&quot;invalid encoding value: &quot; + encoding);
+        }
+        this.encoding = encoding;
+    }
+
+    /**
+     * Sets the content of this element
+     * @param externalContent The content
+     */
+    private void setExternalContent(DERObject externalContent)
+    {
+        this.externalContent = externalContent;
+    }
+
+    /**
+     * Sets the indirect reference of this element
+     * @param indirectReference The reference
+     */
+    private void setIndirectReference(DERInteger indirectReference)
+    {
+        this.indirectReference = indirectReference;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERExternalParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERExternalParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERExternalParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERExternalParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERExternalParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,52 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERExternalParser
+    implements DEREncodable, InMemoryRepresentable
+{
+    private ASN1StreamParser _parser;
+
+    /**
+     * 
+     */
+    public DERExternalParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        try
+        {
+            return new DERExternal(_parser.readVector());
+        }
+        catch (IllegalArgumentException e)
+        {
+            throw new ASN1Exception(e.getMessage(), e);
+        }
+    }
+    
+    public DERObject getDERObject()
+    {
+        try 
+        {
+            return getLoadedObject();
+        }
+        catch (IOException ioe) 
+        {
+            throw new ASN1ParsingException(&quot;unable to get DER object&quot;, ioe);
+        }
+        catch (IllegalArgumentException ioe) 
+        {
+            throw new ASN1ParsingException(&quot;unable to get DER object&quot;, ioe);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERFactory.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.asn1;
+
+class DERFactory
+{
+    static final DERSequence EMPTY_SEQUENCE = new DERSequence();
+    static final DERSet EMPTY_SET = new DERSet();
+
+    static DERSequence createSequence(ASN1EncodableVector v)
+    {
+        return v.size() &lt; 1 ? EMPTY_SEQUENCE : new DERSequence(v);
+    }
+
+    static DERSet createSet(ASN1EncodableVector v)
+    {
+        return v.size() &lt; 1 ? EMPTY_SET : new DERSet(v);
+    }
+
+    static DERSet createSet(ASN1EncodableVector v, boolean needsSorting)
+    {
+        return v.size() &lt; 1 ? EMPTY_SET : new DERSet(v, needsSorting);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERGeneralString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERGeneralString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERGeneralString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERGeneralString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERGeneralString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,94 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERGeneralString 
+    extends ASN1Object implements DERString
+{
+    private String string;
+
+    public static DERGeneralString getInstance(
+        Object obj) 
+    {
+        if (obj == null || obj instanceof DERGeneralString) 
+        {
+            return (DERGeneralString) obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot;
+                + obj.getClass().getName());
+    }
+
+    public static DERGeneralString getInstance(
+        ASN1TaggedObject obj, 
+        boolean explicit) 
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERGeneralString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERGeneralString(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    public DERGeneralString(byte[] string) 
+    {
+        char[] cs = new char[string.length];
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] &amp; 0xff);
+        }
+        this.string = new String(cs);
+    }
+
+    public DERGeneralString(String string) 
+    {
+        this.string = string;
+    }
+    
+    public String getString() 
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets() 
+    {
+        char[] cs = string.toCharArray();
+        byte[] bs = new byte[cs.length];
+        for (int i = 0; i != cs.length; i++) 
+        {
+            bs[i] = (byte) cs[i];
+        }
+        return bs;
+    }
+    
+    void encode(DEROutputStream out) 
+        throws IOException 
+    {
+        out.writeEncoded(GENERAL_STRING, this.getOctets());
+    }
+    
+    public int hashCode() 
+    {
+        return this.getString().hashCode();
+    }
+    
+    boolean asn1Equals(DERObject o)
+    {
+        if (!(o instanceof DERGeneralString)) 
+        {
+            return false;
+        }
+        DERGeneralString s = (DERGeneralString) o;
+        return this.getString().equals(s.getString());
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERGeneralizedTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,338 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+// import java.text.ParseException;
+// import java.text.SimpleDateFormat;
+import ewe.sys.Date;
+// import java.util.SimpleTimeZone;
+// import java.util.TimeZone;
+
+/**
+ * Generalized time object.
+ */
+public class DERGeneralizedTime
+    extends ASN1Object
+{
+    String      time;
+
+    /**
+     * return a generalized time from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERGeneralizedTime getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERGeneralizedTime)
+        {
+            return (DERGeneralizedTime)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return a Generalized Time object from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERGeneralizedTime getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERGeneralizedTime)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERGeneralizedTime(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * The correct format for this is YYYYMMDDHHMMSS[.f]Z, or without the Z
+     * for local time, or Z+-HHMM on the end, for difference between local
+     * time and UTC time. The fractional second amount f must consist of at
+     * least one number with trailing zeroes removed.
+     *
+     * @param time the time string.
+     * @exception IllegalArgumentException if String is an illegal format.
+     */
+    public DERGeneralizedTime(
+        String  time)
+    {
+        this.time = time;
+        try
+        {
+            this.getDate();
+        }
+        catch (IllegalArgumentException e)
+        {
+            throw new IllegalArgumentException(&quot;invalid date string: &quot; + e.getMessage());
+        }
+    }
+
+    /**
+     * base constructer from a java.util.date object
+     */
+  /*  public DERGeneralizedTime(
+        Date time)
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmss'Z'&quot;);
+
+        dateF.setTimeZone(new SimpleTimeZone(0,&quot;Z&quot;));
+
+        this.time = dateF.format(time);
+    }
+*/
+    DERGeneralizedTime(
+        byte[]  bytes)
+    {
+        //
+        // explicitly convert to characters
+        //
+        char[]  dateC = new char[bytes.length];
+
+        for (int i = 0; i != dateC.length; i++)
+        {
+            dateC[i] = (char)(bytes[i] &amp; 0xff);
+        }
+
+        this.time = new String(dateC);
+    }
+
+    /**
+     * Return the time.
+     * @return The time string as it appeared in the encoded object.
+     */
+    public String getTimeString()
+    {
+        return time;
+    }
+
+    /**
+     * return the time - always in the form of
+     *  YYYYMMDDhhmmssGMT(+hh:mm|-hh:mm).
+     * &lt;p&gt;
+     * Normally in a certificate we would expect &quot;Z&quot; rather than &quot;GMT&quot;,
+     * however adding the &quot;GMT&quot; means we can just use:
+     * &lt;pre&gt;
+     *     dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmssz&quot;);
+     * &lt;/pre&gt;
+     * To read in the time and get a date which is compatible with our local
+     * time zone.
+     */
+    public String getTime()
+    {
+        //
+        // standardise the format.
+        //
+        if (time.charAt(time.length() - 1) == 'Z')
+        {
+            return time.substring(0, time.length() - 1) + &quot;GMT+00:00&quot;;
+        }
+        else
+        {
+            int signPos = time.length() - 5;
+            char sign = time.charAt(signPos);
+            if (sign == '-' || sign == '+')
+            {
+                return time.substring(0, signPos)
+                    + &quot;GMT&quot;
+                    + time.substring(signPos, signPos + 3)
+                    + &quot;:&quot;
+                    + time.substring(signPos + 3);
+            }
+            else
+            {
+                signPos = time.length() - 3;
+                sign = time.charAt(signPos);
+                if (sign == '-' || sign == '+')
+                {
+                    return time.substring(0, signPos)
+                        + &quot;GMT&quot;
+                        + time.substring(signPos)
+                        + &quot;:00&quot;;
+                }
+            }
+        }
+        return time + calculateGMTOffset();
+    }
+
+    private String calculateGMTOffset()
+    {
+ //       String sign = &quot;+&quot;;
+/*        TimeZone timeZone = TimeZone.getDefault();
+        int offset = timeZone.getRawOffset();
+        if (offset &lt; 0)
+        {
+            sign = &quot;-&quot;;
+            offset = -offset;
+        }
+        int hours = offset / (60 * 60 * 1000);
+        int minutes = (offset - (hours * 60 * 60 * 1000)) / (60 * 1000);
+*/
+        /* commented out for ewe        try
+        {
+     if (timeZone.useDaylightTime() &amp;&amp; timeZone.inDaylightTime(this.getDate()))
+            {
+                hours += sign.equals(&quot;+&quot;) ? 1 : -1;
+            }
+        }
+        catch (ParseException e)
+        {
+            // we'll do our best and ignore daylight savings
+        }
+        */
+        return &quot;GMT&quot; + &quot;+00:00&quot;; // commented out for ewe + sign + convert(hours) + &quot;:&quot; + convert(minutes);
+    }
+
+    private String convert(int time)
+    {
+        if (time &lt; 10)
+        {
+            return &quot;0&quot; + time;
+        }
+
+        return Integer.toString(time);
+    }
+
+    public Date getDate()
+        throws IllegalArgumentException
+    {
+  //      SimpleDateFormat dateF;
+        String dateFewe;
+        String d = time;
+
+        if (time.endsWith(&quot;Z&quot;))
+        {
+            if (hasFractionalSeconds())
+            {
+                dateFewe = &quot;yyyyMMddHHmmss.SSS'Z'&quot;;
+            	// dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmss.SSS'Z'&quot;);
+            }
+            else
+            {
+            	dateFewe = &quot;yyyyMMddHHmmss'Z'&quot;;
+                //dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmss'Z'&quot;);
+            }
+
+       // TODO commented out for ewe   dateF.setTimeZone(new SimpleTimeZone(0, &quot;Z&quot;));
+        }
+        else if (time.indexOf('-') &gt; 0 || time.indexOf('+') &gt; 0)
+        {
+            d = this.getTime();
+            if (hasFractionalSeconds())
+            {
+            	dateFewe = &quot;yyyyMMddHHmmss.SSSz&quot;;
+                // dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmss.SSSz&quot;);
+            }
+            else
+            {
+            	dateFewe = &quot;yyyyMMddHHmmssz&quot;;
+                // dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmssz&quot;);
+            }
+
+//          TODO commented out for ewe    dateF.setTimeZone(new SimpleTimeZone(0, &quot;Z&quot;));
+        }
+        else
+        {
+            if (hasFractionalSeconds())
+            {
+            	dateFewe = &quot;yyyyMMddHHmmss.SSS&quot;;
+                // dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmss.SSS&quot;);
+            }
+            else
+            {
+            	dateFewe = &quot;yyyyMMddHHmmss&quot;;
+                // dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
+            }
+
+//          TODO commented out for ewe     dateF.setTimeZone(new SimpleTimeZone(0, TimeZone.getDefault().getID()));
+        }
+
+        if (hasFractionalSeconds())
+        {
+            // java misinterprets extra digits as being milliseconds...
+            String frac = d.substring(14);
+            int    index;
+            for (index = 1; index &lt; frac.length(); index++)
+            {
+                char ch = frac.charAt(index);
+                if (!('0' &lt;= ch &amp;&amp; ch &lt;= '9'))
+                {
+                    break;
+                }
+            }
+
+            if (index - 1 &gt; 3)
+            {
+                frac = frac.substring(0, 4) + frac.substring(index);
+                d = d.substring(0, 14) + frac;
+            }
+            else if (index - 1 == 1)
+            {
+                frac = frac.substring(0, index) + &quot;00&quot; + frac.substring(index);
+                d = d.substring(0, 14) + frac;
+            }
+            else if (index - 1 == 2)
+            {
+                frac = frac.substring(0, index) + &quot;0&quot; + frac.substring(index);
+                d = d.substring(0, 14) + frac;
+            }
+        }
+
+        Date ret = new Date();
+        ret.parse(d, dateFewe);
+        return ret; // dateF.parse(d);
+    }
+
+    private boolean hasFractionalSeconds()
+    {
+        return time.indexOf('.') == 14;
+    }
+
+    private byte[] getOctets()
+    {
+        char[]  cs = time.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs;
+    }
+
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(GENERALIZED_TIME, this.getOctets());
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERGeneralizedTime))
+        {
+            return false;
+        }
+
+        return time.equals(((DERGeneralizedTime)o).time);
+    }
+
+    public int hashCode()
+    {
+        return time.hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERIA5String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERIA5String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERIA5String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERIA5String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERIA5String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,173 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER IA5String object - this is an ascii string.
+ */
+public class DERIA5String
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a IA5 string from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERIA5String getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERIA5String)
+        {
+            return (DERIA5String)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return an IA5 String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERIA5String getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERIA5String)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERIA5String(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - with bytes.
+     */
+    public DERIA5String(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] &amp; 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor - without validation.
+     */
+    public DERIA5String(
+        String   string)
+    {
+        this(string, false);
+    }
+
+    /**
+     * Constructor with optional validation.
+     *
+     * @param string the base string to wrap.
+     * @param validate whether or not to check the string.
+     * @throws IllegalArgumentException if validate is true and the string
+     * contains characters that should not be in an IA5String.
+     */
+    public DERIA5String(
+        String   string,
+        boolean  validate)
+    {
+        if (string == null)
+        {
+            throw new NullPointerException(&quot;string cannot be null&quot;);
+        }
+        if (validate &amp;&amp; !isIA5String(string))
+        {
+            throw new IllegalArgumentException(&quot;string contains illegal characters&quot;);
+        }
+
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(IA5_STRING, this.getOctets());
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERIA5String))
+        {
+            return false;
+        }
+
+        DERIA5String  s = (DERIA5String)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    /**
+     * return true if the passed in String can be represented without
+     * loss as an IA5String, false otherwise.
+     *
+     * @return true if in printable set, false otherwise.
+     */
+    public static boolean isIA5String(
+        String  str)
+    {
+        for (int i = str.length() - 1; i &gt;= 0; i--)
+        {
+            char    ch = str.charAt(i);
+
+            if (ch &gt; 0x007f)
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERInteger.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERInteger.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERInteger.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERInteger.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERInteger.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,122 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.util.Arrays;
+
+public class DERInteger
+    extends ASN1Object
+{
+    byte[]      bytes;
+
+    /**
+     * return an integer from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERInteger getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERInteger)
+        {
+            return (DERInteger)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return an Integer from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERInteger getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERInteger)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new ASN1Integer(ASN1OctetString.getInstance(obj.getObject()).getOctets());
+        }
+    }
+
+    public DERInteger(
+        int         value)
+    {
+        bytes = BigInteger.valueOf(value).toByteArray();
+    }
+
+    public DERInteger(
+        BigInteger   value)
+    {
+        bytes = value.toByteArray();
+    }
+
+    public DERInteger(
+        byte[]   bytes)
+    {
+        this.bytes = bytes;
+    }
+
+    public BigInteger getValue()
+    {
+        return new BigInteger(bytes);
+    }
+
+    /**
+     * in some cases positive values get crammed into a space,
+     * that's not quite big enough...
+     */
+    public BigInteger getPositiveValue()
+    {
+        return new BigInteger(1, bytes);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(INTEGER, bytes);
+    }
+    
+    public int hashCode()
+    {
+         int     value = 0;
+ 
+         for (int i = 0; i != bytes.length; i++)
+         {
+             value ^= (bytes[i] &amp; 0xff) &lt;&lt; (i % 4);
+         }
+ 
+         return value;
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERInteger))
+        {
+            return false;
+        }
+
+        DERInteger other = (DERInteger)o;
+
+        return Arrays.areEqual(bytes, other.bytes);
+    }
+
+    public String toString()
+    {
+      return getValue().toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERNull.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERNull.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERNull.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERNull.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERNull.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * A NULL object.
+ */
+public class DERNull
+    extends ASN1Null
+{
+    public static final DERNull INSTANCE = new DERNull();
+
+    byte[]  zeroBytes = new byte[0];
+
+    public DERNull()
+    {
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(NULL, zeroBytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERNumericString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERNumericString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERNumericString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERNumericString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERNumericString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,176 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER NumericString object - this is an ascii string of characters {0,1,2,3,4,5,6,7,8,9, }.
+ */
+public class DERNumericString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a Numeric string from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERNumericString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERNumericString)
+        {
+            return (DERNumericString)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return an Numeric String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERNumericString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERNumericString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERNumericString(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - with bytes.
+     */
+    public DERNumericString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] &amp; 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor -  without validation..
+     */
+    public DERNumericString(
+        String   string)
+    {
+        this(string, false);
+    }
+
+    /**
+     * Constructor with optional validation.
+     *
+     * @param string the base string to wrap.
+     * @param validate whether or not to check the string.
+     * @throws IllegalArgumentException if validate is true and the string
+     * contains characters that should not be in a NumericString.
+     */
+    public DERNumericString(
+        String   string,
+        boolean  validate)
+    {
+        if (validate &amp;&amp; !isNumericString(string))
+        {
+            throw new IllegalArgumentException(&quot;string contains illegal characters&quot;);
+        }
+
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(NUMERIC_STRING, this.getOctets());
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERNumericString))
+        {
+            return false;
+        }
+
+        DERNumericString  s = (DERNumericString)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    /**
+     * Return true if the string can be represented as a NumericString ('0'..'9', ' ')
+     *
+     * @param str string to validate.
+     * @return true if numeric, fale otherwise.
+     */
+    public static boolean isNumericString(
+        String  str)
+    {
+        for (int i = str.length() - 1; i &gt;= 0; i--)
+        {
+            char    ch = str.charAt(i);
+
+            if (ch &gt; 0x007f)
+            {
+                return false;
+            }
+
+            if (('0' &lt;= ch &amp;&amp; ch &lt;= '9') || ch == ' ')
+            {
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,20 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public abstract class DERObject
+    extends ASN1Encodable
+    implements DERTags
+{
+    public DERObject toASN1Object()
+    {
+        return this;
+    }
+
+    public abstract int hashCode();
+
+    public abstract boolean equals(Object o);
+
+    abstract void encode(DEROutputStream out)
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERObjectIdentifier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,268 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+import ewe.math.BigInteger;
+
+public class DERObjectIdentifier
+    extends ASN1Object
+{
+    String      identifier;
+
+    /**
+     * return an OID from the passed in object
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERObjectIdentifier getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERObjectIdentifier)
+        {
+            return (DERObjectIdentifier)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return an Object Identifier from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERObjectIdentifier getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERObjectIdentifier)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new ASN1ObjectIdentifier(ASN1OctetString.getInstance(obj.getObject()).getOctets());
+        }
+    }
+    
+
+    DERObjectIdentifier(
+        byte[]  bytes)
+    {
+        StringBuffer    objId = new StringBuffer();
+        long            value = 0;
+        BigInteger      bigValue = null;
+        boolean         first = true;
+
+        for (int i = 0; i != bytes.length; i++)
+        {
+            int b = bytes[i] &amp; 0xff;
+
+            if (value &lt; 0x80000000000000L) 
+            {
+                value = value * 128 + (b &amp; 0x7f);
+                if ((b &amp; 0x80) == 0)             // end of number reached
+                {
+                    if (first)
+                    {
+                        switch ((int)value / 40)
+                        {
+                        case 0:
+                            objId.append('0');
+                            break;
+                        case 1:
+                            objId.append('1');
+                            value -= 40;
+                            break;
+                        default:
+                            objId.append('2');
+                            value -= 80;
+                        }
+                        first = false;
+                    }
+
+                    objId.append('.');
+                    objId.append(value);
+                    value = 0;
+                }
+            } 
+            else 
+            {
+                if (bigValue == null)
+                {
+                    bigValue = BigInteger.valueOf(value);
+                }
+                bigValue = bigValue.shiftLeft(7);
+                bigValue = bigValue.or(BigInteger.valueOf(b &amp; 0x7f));
+                if ((b &amp; 0x80) == 0) 
+                {
+                    objId.append('.');
+                    objId.append(bigValue);
+                    bigValue = null;
+                    value = 0;
+                }
+            }
+        }
+
+        this.identifier = objId.toString();
+    }
+
+    public DERObjectIdentifier(
+        String  identifier)
+    {
+        if (!isValidIdentifier(identifier))
+        {
+            throw new IllegalArgumentException(&quot;string &quot; + identifier + &quot; not an OID&quot;);
+        }
+
+        this.identifier = identifier;
+    }
+
+    public String getId()
+    {
+        return identifier;
+    }
+
+    private void writeField(
+        OutputStream    out,
+        long            fieldValue)
+        throws IOException
+    {
+        byte[] result = new byte[9];
+        int pos = 8;
+        result[pos] = (byte)((int)fieldValue &amp; 0x7f);
+        while (fieldValue &gt;= (1L &lt;&lt; 7))
+        {
+            fieldValue &gt;&gt;= 7;
+            result[--pos] = (byte)((int)fieldValue &amp; 0x7f | 0x80);
+        }
+        out.write(result, pos, 9 - pos);
+    }
+
+    private void writeField(
+        OutputStream    out,
+        BigInteger      fieldValue)
+        throws IOException
+    {
+        int byteCount = (fieldValue.bitLength()+6)/7;
+        if (byteCount == 0) 
+        {
+            out.write(0);
+        }  
+        else 
+        {
+            BigInteger tmpValue = fieldValue;
+            byte[] tmp = new byte[byteCount];
+            for (int i = byteCount-1; i &gt;= 0; i--) 
+            {
+                tmp[i] = (byte) ((tmpValue.intValue() &amp; 0x7f) | 0x80);
+                tmpValue = tmpValue.shiftRight(7); 
+            }
+            tmp[byteCount-1] &amp;= 0x7f;
+            out.write(tmp);
+        }
+
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        OIDTokenizer            tok = new OIDTokenizer(identifier);
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        DEROutputStream         dOut = new DEROutputStream(bOut);
+
+        writeField(bOut, 
+                    Integer.parseInt(tok.nextToken()) * 40
+                    + Integer.parseInt(tok.nextToken()));
+
+        while (tok.hasMoreTokens())
+        {
+            String token = tok.nextToken();
+            if (token.length() &lt; 18) 
+            {
+                writeField(bOut, Long.parseLong(token));
+            }
+            else
+            {
+                writeField(bOut, new BigInteger(token));
+            }
+        }
+
+        dOut.close();
+
+        byte[]  bytes = bOut.toByteArray();
+
+        out.writeEncoded(OBJECT_IDENTIFIER, bytes);
+    }
+
+    public int hashCode()
+    {
+        return identifier.hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERObjectIdentifier))
+        {
+            return false;
+        }
+
+        return identifier.equals(((DERObjectIdentifier)o).identifier);
+    }
+
+    public String toString()
+    {
+        return getId();
+    }
+
+    private static boolean isValidIdentifier(
+        String identifier)
+    {
+        if (identifier.length() &lt; 3
+            || identifier.charAt(1) != '.')
+        {
+            return false;
+        }
+
+        char first = identifier.charAt(0);
+        if (first &lt; '0' || first &gt; '2')
+        {
+            return false;
+        }
+
+        boolean periodAllowed = false;
+        for (int i = identifier.length() - 1; i &gt;= 2; i--)
+        {
+            char ch = identifier.charAt(i);
+
+            if ('0' &lt;= ch &amp;&amp; ch &lt;= '9')
+            {
+                periodAllowed = true;
+                continue;
+            }
+
+            if (ch == '.')
+            {
+                if (!periodAllowed)
+                {
+                    return false;
+                }
+
+                periodAllowed = false;
+                continue;
+            }
+
+            return false;
+        }
+
+        return periodAllowed;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEROctetString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEROctetString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEROctetString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEROctetString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEROctetString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DEROctetString
+    extends ASN1OctetString
+{
+    /**
+     * @param string the octets making up the octet string.
+     */
+    public DEROctetString(
+        byte[]  string)
+    {
+        super(string);
+    }
+
+    public DEROctetString(
+        DEREncodable  obj)
+    {
+        super(obj);
+    }
+
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(OCTET_STRING, string);
+    }
+
+    static void encode(
+        DEROutputStream derOut,
+        byte[]          bytes)
+        throws IOException
+    {
+        derOut.writeEncoded(DERTags.OCTET_STRING, bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEROctetStringParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEROctetStringParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+public class DEROctetStringParser
+    implements ASN1OctetStringParser
+{
+    private DefiniteLengthInputStream stream;
+
+    DEROctetStringParser(
+        DefiniteLengthInputStream stream)
+    {
+        this.stream = stream;
+    }
+
+    public InputStream getOctetStream()
+    {
+        return stream;
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new DEROctetString(stream.toByteArray());
+    }
+    
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(&quot;IOException converting stream to byte array: &quot; + e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DEROutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DEROutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DEROutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DEROutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DEROutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,134 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.FilterOutputStream;
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class DEROutputStream
+    extends FilterOutputStream implements DERTags
+{
+    public DEROutputStream(
+        OutputStream    os)
+    {
+        super(os);
+    }
+
+    private void writeLength(
+        int length)
+        throws IOException
+    {
+        if (length &gt; 127)
+        {
+            int size = 1;
+            int val = length;
+
+            while ((val &gt;&gt;&gt;= 8) != 0)
+            {
+                size++;
+            }
+
+            write((byte)(size | 0x80));
+
+            for (int i = (size - 1) * 8; i &gt;= 0; i -= 8)
+            {
+                write((byte)(length &gt;&gt; i));
+            }
+        }
+        else
+        {
+            write((byte)length);
+        }
+    }
+
+    void writeEncoded(
+        int     tag,
+        byte[]  bytes)
+        throws IOException
+    {
+        write(tag);
+        writeLength(bytes.length);
+        write(bytes);
+    }
+
+    void writeTag(int flags, int tagNo)
+        throws IOException
+    {
+        if (tagNo &lt; 31)
+        {
+            write(flags | tagNo);
+        }
+        else
+        {
+            write(flags | 0x1f);
+            if (tagNo &lt; 128)
+            {
+                write(tagNo);
+            }
+            else
+            {
+                byte[] stack = new byte[5];
+                int pos = stack.length;
+
+                stack[--pos] = (byte)(tagNo &amp; 0x7F);
+
+                do
+                {
+                    tagNo &gt;&gt;= 7;
+                    stack[--pos] = (byte)(tagNo &amp; 0x7F | 0x80);
+                }
+                while (tagNo &gt; 127);
+
+                write(stack, pos, stack.length - pos);
+            }
+        }
+    }
+
+    void writeEncoded(int flags, int tagNo, byte[] bytes)
+        throws IOException
+    {
+        writeTag(flags, tagNo);
+        writeLength(bytes.length);
+        write(bytes);
+    }
+
+    protected void writeNull()
+        throws IOException
+    {
+        write(NULL);
+        write(0x00);
+    }
+
+    public void write(byte[] buf)
+        throws IOException
+    {
+        out.write(buf, 0, buf.length);
+    }
+
+    public void write(byte[] buf, int offSet, int len)
+        throws IOException
+    {
+        out.write(buf, offSet, len);
+    }
+
+    public void writeObject(
+        Object    obj)
+        throws IOException
+    {
+        if (obj == null)
+        {
+            writeNull();
+        }
+        else if (obj instanceof DERObject)
+        {
+            ((DERObject)obj).encode(this);
+        }
+        else if (obj instanceof DEREncodable)
+        {
+            ((DEREncodable)obj).getDERObject().encode(this);
+        }
+        else
+        {
+            throw new IOException(&quot;object not DEREncodable&quot;);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERPrintableString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERPrintableString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERPrintableString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERPrintableString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERPrintableString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,203 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER PrintableString object.
+ */
+public class DERPrintableString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a printable string from the passed in object.
+     * 
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERPrintableString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERPrintableString)
+        {
+            return (DERPrintableString)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return a Printable String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERPrintableString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERPrintableString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERPrintableString(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERPrintableString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] &amp; 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor - this does not validate the string
+     */
+    public DERPrintableString(
+        String   string)
+    {
+        this(string, false);
+    }
+
+    /**
+     * Constructor with optional validation.
+     *
+     * @param string the base string to wrap.
+     * @param validate whether or not to check the string.
+     * @throws IllegalArgumentException if validate is true and the string
+     * contains characters that should not be in a PrintableString.
+     */
+    public DERPrintableString(
+        String   string,
+        boolean  validate)
+    {
+        if (validate &amp;&amp; !isPrintableString(string))
+        {
+            throw new IllegalArgumentException(&quot;string contains illegal characters&quot;);
+        }
+
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(PRINTABLE_STRING, this.getOctets());
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERPrintableString))
+        {
+            return false;
+        }
+
+        DERPrintableString  s = (DERPrintableString)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    /**
+     * return true if the passed in String can be represented without
+     * loss as a PrintableString, false otherwise.
+     *
+     * @return true if in printable set, false otherwise.
+     */
+    public static boolean isPrintableString(
+        String  str)
+    {
+        for (int i = str.length() - 1; i &gt;= 0; i--)
+        {
+            char    ch = str.charAt(i);
+
+            if (ch &gt; 0x007f)
+            {
+                return false;
+            }
+
+            if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z')
+            {
+                continue;
+            }
+
+            if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z')
+            {
+                continue;
+            }
+
+            if ('0' &lt;= ch &amp;&amp; ch &lt;= '9')
+            {
+                continue;
+            }
+
+            switch (ch)
+            {
+            case ' ':
+            case '\'':
+            case '(':
+            case ')':
+            case '+':
+            case '-':
+            case '.':
+            case ':':
+            case '=':
+            case '?':
+            case '/':
+            case ',':
+                continue;
+            }
+
+            return false;
+        }
+
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,80 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class DERSequence
+    extends ASN1Sequence
+{
+    /**
+     * create an empty sequence
+     */
+    public DERSequence()
+    {
+    }
+
+    /**
+     * create a sequence containing one object
+     */
+    public DERSequence(
+        DEREncodable    obj)
+    {
+        this.addObject(obj);
+    }
+
+    /**
+     * create a sequence containing a vector of objects.
+     */
+    public DERSequence(
+        ASN1EncodableVector   v)
+    {
+        for (int i = 0; i != v.size(); i++)
+        {
+            this.addObject(v.get(i));
+        }
+    }
+
+    /**
+     * create a sequence containing an array of objects.
+     */
+    public DERSequence(
+        ASN1Encodable[]   a)
+    {
+        for (int i = 0; i != a.length; i++)
+        {
+            this.addObject(a[i]);
+        }
+    }
+    
+    /*
+     * A note on the implementation:
+     * &lt;p&gt;
+     * As DER requires the constructed, definite-length model to
+     * be used for structured types, this varies slightly from the
+     * ASN.1 descriptions given. Rather than just outputing SEQUENCE,
+     * we also have to specify CONSTRUCTED, and the objects length.
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        // TODO Intermediate buffer could be avoided if we could calculate expected length
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        DEROutputStream         dOut = new DEROutputStream(bOut);
+        Enumeration             e = this.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            Object    obj = e.nextElement();
+
+            dOut.writeObject(obj);
+        }
+
+        dOut.close();
+
+        byte[]  bytes = bOut.toByteArray();
+
+        out.writeEncoded(SEQUENCE | CONSTRUCTED, bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSequenceParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSequenceParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSequenceParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSequenceParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERSequenceParser
+    implements ASN1SequenceParser
+{
+    private ASN1StreamParser _parser;
+
+    DERSequenceParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+         return new DERSequence(_parser.readVector());
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException(e.getMessage());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSet.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSet.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSet.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSet.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSet.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,100 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+/**
+ * A DER encoded set object
+ */
+public class DERSet
+    extends ASN1Set
+{
+    /**
+     * create an empty set
+     */
+    public DERSet()
+    {
+    }
+
+    /**
+     * @param obj - a single object that makes up the set.
+     */
+    public DERSet(
+        DEREncodable   obj)
+    {
+        this.addObject(obj);
+    }
+
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    public DERSet(
+        ASN1EncodableVector   v)
+    {
+        this(v, true);
+    }
+    
+    /**
+     * create a set from an array of objects.
+     */
+    public DERSet(
+        ASN1Encodable[]   a)
+    {
+        for (int i = 0; i != a.length; i++)
+        {
+            this.addObject(a[i]);
+        }
+        
+        this.sort();
+    }
+    
+    /**
+     * @param v - a vector of objects making up the set.
+     */
+    DERSet(
+        ASN1EncodableVector  v,
+        boolean              needsSorting)
+    {
+        for (int i = 0; i != v.size(); i++)
+        {
+            this.addObject(v.get(i));
+        }
+
+        if (needsSorting)
+        {
+            this.sort();
+        }
+    }
+
+    /*
+     * A note on the implementation:
+     * &lt;p&gt;
+     * As DER requires the constructed, definite-length model to
+     * be used for structured types, this varies slightly from the
+     * ASN.1 descriptions given. Rather than just outputing SET,
+     * we also have to specify CONSTRUCTED, and the objects length.
+     */
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        // TODO Intermediate buffer could be avoided if we could calculate expected length
+        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
+        DEROutputStream         dOut = new DEROutputStream(bOut);
+        Enumeration             e = this.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            Object    obj = e.nextElement();
+
+            dOut.writeObject(obj);
+        }
+
+        dOut.close();
+
+        byte[]  bytes = bOut.toByteArray();
+
+        out.writeEncoded(SET | CONSTRUCTED, bytes);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERSetParser.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERSetParser.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERSetParser.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERSetParser.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERSetParser.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,38 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public class DERSetParser
+    implements ASN1SetParser
+{
+    private ASN1StreamParser _parser;
+
+    DERSetParser(ASN1StreamParser parser)
+    {
+        this._parser = parser;
+    }
+
+    public DEREncodable readObject()
+        throws IOException
+    {
+        return _parser.readObject();
+    }
+
+    public DERObject getLoadedObject()
+        throws IOException
+    {
+        return new DERSet(_parser.readVector(), false);
+    }
+
+    public DERObject getDERObject()
+    {
+        try
+        {
+            return getLoadedObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(e.getMessage(), e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.asn1;
+
+/**
+ * basic interface for DER string objects.
+ */
+public interface DERString
+    extends ASN1String
+{
+
+}

Added: trunk/src/org/bouncycastle/asn1/DERT61String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERT61String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERT61String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERT61String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERT61String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,125 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER T61String (also the teletex string)
+ */
+public class DERT61String
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a T61 string from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERT61String getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERT61String)
+        {
+            return (DERT61String)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return an T61 String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERT61String getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERT61String(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - with bytes.
+     */
+    public DERT61String(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] &amp; 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor - with string.
+     */
+    public DERT61String(
+        String   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(T61_STRING, this.getOctets());
+    }
+    
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs; 
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERT61String))
+        {
+            return false;
+        }
+
+        return this.getString().equals(((DERT61String)o).getString());
+    }
+    
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERTaggedObject.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERTaggedObject.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERTaggedObject.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERTaggedObject.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,85 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER TaggedObject - in ASN.1 notation this is any object preceded by
+ * a [n] where n is some number - these are assumed to follow the construction
+ * rules (as with sequences).
+ */
+public class DERTaggedObject
+    extends ASN1TaggedObject
+{
+    private static final byte[] ZERO_BYTES = new byte[0];
+
+    /**
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public DERTaggedObject(
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(tagNo, obj);
+    }
+
+    /**
+     * @param explicit true if an explicitly tagged object.
+     * @param tagNo the tag number for this object.
+     * @param obj the tagged object.
+     */
+    public DERTaggedObject(
+        boolean         explicit,
+        int             tagNo,
+        DEREncodable    obj)
+    {
+        super(explicit, tagNo, obj);
+    }
+
+    /**
+     * create an implicitly tagged object that contains a zero
+     * length sequence.
+     */
+    public DERTaggedObject(
+        int             tagNo)
+    {
+        super(false, tagNo, new DERSequence());
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        if (!empty)
+        {
+            byte[] bytes = obj.getDERObject().getEncoded(DER);
+
+            if (explicit)
+            {
+                out.writeEncoded(CONSTRUCTED | TAGGED, tagNo, bytes);
+            }
+            else
+            {
+                //
+                // need to mark constructed types...
+                //
+                int flags;
+                if ((bytes[0] &amp; CONSTRUCTED) != 0)
+                {
+                    flags = CONSTRUCTED | TAGGED;
+                }
+                else
+                {
+                    flags = TAGGED;
+                }
+
+                out.writeTag(flags, tagNo);
+                out.write(bytes, 1, bytes.length - 1);
+            }
+        }
+        else
+        {
+            out.writeEncoded(CONSTRUCTED | TAGGED, tagNo, ZERO_BYTES);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERTags.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERTags.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERTags.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERTags.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERTags.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.asn1;
+
+public interface DERTags
+{
+    public static final int BOOLEAN             = 0x01;
+    public static final int INTEGER             = 0x02;
+    public static final int BIT_STRING          = 0x03;
+    public static final int OCTET_STRING        = 0x04;
+    public static final int NULL                = 0x05;
+    public static final int OBJECT_IDENTIFIER   = 0x06;
+    public static final int EXTERNAL            = 0x08;
+    public static final int ENUMERATED          = 0x0a;
+    public static final int SEQUENCE            = 0x10;
+    public static final int SEQUENCE_OF         = 0x10; // for completeness
+    public static final int SET                 = 0x11;
+    public static final int SET_OF              = 0x11; // for completeness
+
+
+    public static final int NUMERIC_STRING      = 0x12;
+    public static final int PRINTABLE_STRING    = 0x13;
+    public static final int T61_STRING          = 0x14;
+    public static final int VIDEOTEX_STRING     = 0x15;
+    public static final int IA5_STRING          = 0x16;
+    public static final int UTC_TIME            = 0x17;
+    public static final int GENERALIZED_TIME    = 0x18;
+    public static final int GRAPHIC_STRING      = 0x19;
+    public static final int VISIBLE_STRING      = 0x1a;
+    public static final int GENERAL_STRING      = 0x1b;
+    public static final int UNIVERSAL_STRING    = 0x1c;
+    public static final int BMP_STRING          = 0x1e;
+    public static final int UTF8_STRING         = 0x0c;
+    
+    public static final int CONSTRUCTED         = 0x20;
+    public static final int APPLICATION         = 0x40;
+    public static final int TAGGED              = 0x80;
+}

Added: trunk/src/org/bouncycastle/asn1/DERUTCTime.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUTCTime.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUTCTime.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUTCTime.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUTCTime.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,258 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+// import java.text.ParseException;
+// import java.text.SimpleDateFormat;
+// import ewe.sys.Date;
+// import java.util.SimpleTimeZone;
+
+/**
+ * UTC time object.
+ */
+public class DERUTCTime
+    extends ASN1Object
+{
+    String      time;
+
+    /**
+     * return an UTC Time from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERUTCTime getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERUTCTime)
+        {
+            return (DERUTCTime)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return an UTC Time from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERUTCTime getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERUTCTime)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERUTCTime(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * The correct format for this is YYMMDDHHMMSSZ (it used to be that seconds were
+     * never encoded. When you're creating one of these objects from scratch, that's
+     * what you want to use, otherwise we'll try to deal with whatever gets read from
+     * the input stream... (this is why the input format is different from the getTime()
+     * method output).
+     * &lt;p&gt;
+     *
+     * @param time the time string.
+     */
+ /*   public DERUTCTime(
+        String  time)
+    {
+        this.time = time;
+        try
+        {
+            this.getDate();
+        }
+        catch (ParseException e)
+        {
+            throw new IllegalArgumentException(&quot;invalid date string: &quot; + e.getMessage());
+        }
+    }
+*/
+    /**
+     * base constructer from a java.util.date object
+     */
+ /*   public DERUTCTime(
+        Date time)
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat(&quot;yyMMddHHmmss'Z'&quot;);
+
+        dateF.setTimeZone(new SimpleTimeZone(0,&quot;Z&quot;));
+
+        this.time = dateF.format(time);
+    }
+*/
+    DERUTCTime(
+        byte[]  bytes)
+    {
+        //
+        // explicitly convert to characters
+        //
+        char[]  dateC = new char[bytes.length];
+
+        for (int i = 0; i != dateC.length; i++)
+        {
+            dateC[i] = (char)(bytes[i] &amp; 0xff);
+        }
+
+        this.time = new String(dateC);
+    }
+
+    /**
+     * return the time as a date based on whatever a 2 digit year will return. For
+     * standardised processing use getAdjustedDate().
+     *
+     * @return the resulting date
+     * @exception ParseException if the date string cannot be parsed.
+     */
+  /*  public Date getDate()
+        throws ParseException
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat(&quot;yyMMddHHmmssz&quot;);
+
+        return dateF.parse(getTime());
+    }
+*/
+    /**
+     * return the time as an adjusted date
+     * in the range of 1950 - 2049.
+     *
+     * @return a date in the range of 1950 to 2049.
+     * @exception ParseException if the date string cannot be parsed.
+     */
+  /*  public Date getAdjustedDate()
+        throws ParseException
+    {
+        SimpleDateFormat dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmssz&quot;);
+
+        dateF.setTimeZone(new SimpleTimeZone(0, &quot;Z&quot;));
+
+        return dateF.parse(getAdjustedTime());
+    }
+*/
+    /**
+     * return the time - always in the form of
+     *  YYMMDDhhmmssGMT(+hh:mm|-hh:mm).
+     * &lt;p&gt;
+     * Normally in a certificate we would expect &quot;Z&quot; rather than &quot;GMT&quot;,
+     * however adding the &quot;GMT&quot; means we can just use:
+     * &lt;pre&gt;
+     *     dateF = new SimpleDateFormat(&quot;yyMMddHHmmssz&quot;);
+     * &lt;/pre&gt;
+     * To read in the time and get a date which is compatible with our local
+     * time zone.
+     * &lt;p&gt;
+     * &lt;b&gt;Note:&lt;/b&gt; In some cases, due to the local date processing, this
+     * may lead to unexpected results. If you want to stick the normal
+     * convention of 1950 to 2049 use the getAdjustedTime() method.
+     */
+    public String getTime()
+    {
+        //
+        // standardise the format.
+        //
+        if (time.indexOf('-') &lt; 0 &amp;&amp; time.indexOf('+') &lt; 0)
+        {
+            if (time.length() == 11)
+            {
+                return time.substring(0, 10) + &quot;00GMT+00:00&quot;;
+            }
+            else
+            {
+                return time.substring(0, 12) + &quot;GMT+00:00&quot;;
+            }
+        }
+        else
+        {
+            int index = time.indexOf('-');
+            if (index &lt; 0)
+            {
+                index = time.indexOf('+');
+            }
+            String d = time;
+
+            if (index == time.length() - 3)
+            {
+                d += &quot;00&quot;;
+            }
+
+            if (index == 10)
+            {
+                return d.substring(0, 10) + &quot;00GMT&quot; + d.substring(10, 13) + &quot;:&quot; + d.substring(13, 15);
+            }
+            else
+            {
+                return d.substring(0, 12) + &quot;GMT&quot; + d.substring(12, 15) + &quot;:&quot; +  d.substring(15, 17);
+            }
+        }
+    }
+
+    /**
+     * return a time string as an adjusted date with a 4 digit year. This goes
+     * in the range of 1950 - 2049.
+     */
+    public String getAdjustedTime()
+    {
+        String   d = this.getTime();
+
+        if (d.charAt(0) &lt; '5')
+        {
+            return &quot;20&quot; + d;
+        }
+        else
+        {
+            return &quot;19&quot; + d;
+        }
+    }
+
+    private byte[] getOctets()
+    {
+        char[]  cs = time.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(UTC_TIME, this.getOctets());
+    }
+
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERUTCTime))
+        {
+            return false;
+        }
+
+        return time.equals(((DERUTCTime)o).time);
+    }
+
+    public int hashCode()
+    {
+        return time.hashCode();
+    }
+
+    public String toString()
+    {
+      return time;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERUTF8String.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUTF8String.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUTF8String.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUTF8String.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUTF8String.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,115 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Strings;
+
+/**
+ * DER UTF8String object.
+ */
+public class DERUTF8String
+    extends ASN1Object
+    implements DERString
+{
+    String string;
+
+    /**
+     * return an UTF8 string from the passed in object.
+     * 
+     * @exception IllegalArgumentException
+     *                if the object cannot be converted.
+     */
+    public static DERUTF8String getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DERUTF8String)
+        {
+            return (DERUTF8String)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot;
+                + obj.getClass().getName());
+    }
+
+    /**
+     * return an UTF8 String from a tagged object.
+     * 
+     * @param obj
+     *            the tagged object holding the object we want
+     * @param explicit
+     *            true if the object is meant to be explicitly tagged false
+     *            otherwise.
+     * @exception IllegalArgumentException
+     *                if the tagged object cannot be converted.
+     */
+    public static DERUTF8String getInstance(
+        ASN1TaggedObject obj,
+        boolean explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERUTF8String)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERUTF8String(ASN1OctetString.getInstance(o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERUTF8String(byte[] string)
+    {
+        try
+        {
+            this.string = Strings.fromUTF8ByteArray(string);
+        }
+        catch (ArrayIndexOutOfBoundsException e)
+        {
+            throw new IllegalArgumentException(&quot;UTF8 encoding invalid&quot;);
+        }
+    }
+
+    /**
+     * basic constructor
+     */
+    public DERUTF8String(String string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+
+    boolean asn1Equals(DERObject o)
+    {
+        if (!(o instanceof DERUTF8String))
+        {
+            return false;
+        }
+
+        DERUTF8String s = (DERUTF8String)o;
+
+        return this.getString().equals(s.getString());
+    }
+
+    void encode(DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(UTF8_STRING, Strings.toUTF8ByteArray(string));
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERUniversalString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUniversalString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUniversalString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUniversalString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUniversalString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,124 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+/**
+ * DER UniversalString object.
+ */
+public class DERUniversalString
+    extends ASN1Object
+    implements DERString
+{
+    private static final char[]  table = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+    private byte[] string;
+    
+    /**
+     * return a Universal String from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERUniversalString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERUniversalString)
+        {
+            return (DERUniversalString)obj;
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return a Universal String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERUniversalString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        DERObject o = obj.getObject();
+
+        if (explicit || o instanceof DERUniversalString)
+        {
+            return getInstance(o);
+        }
+        else
+        {
+            return new DERUniversalString(((ASN1OctetString)o).getOctets());
+        }
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERUniversalString(
+        byte[]   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        StringBuffer    buf = new StringBuffer(&quot;#&quot;);
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        ASN1OutputStream            aOut = new ASN1OutputStream(bOut);
+        
+        try
+        {
+            aOut.writeObject(this);
+        }
+        catch (IOException e)
+        {
+           throw new RuntimeException(&quot;internal error encoding BitString&quot;);
+        }
+        
+        byte[]    string = bOut.toByteArray();
+        
+        for (int i = 0; i != string.length; i++)
+        {
+            buf.append(table[(string[i] &gt;&gt;&gt; 4) &amp; 0xf]);
+            buf.append(table[string[i] &amp; 0xf]);
+        }
+        
+        return buf.toString();
+    }
+
+    public String toString()
+    {
+        return getString();
+    }
+
+    public byte[] getOctets()
+    {
+        return string;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(UNIVERSAL_STRING, this.getOctets());
+    }
+    
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERUniversalString))
+        {
+            return false;
+        }
+
+        return this.getString().equals(((DERUniversalString)o).getString());
+    }
+    
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERUnknownTag.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERUnknownTag.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERUnknownTag.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERUnknownTag.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,79 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.util.Arrays;
+
+/**
+ * We insert one of these when we find a tag we don't recognise.
+ */
+public class DERUnknownTag
+    extends DERObject
+{
+    private boolean   isConstructed;
+    private int       tag;
+    private byte[]    data;
+
+    /**
+     * @param tag the tag value.
+     * @param data the contents octets.
+     */
+    public DERUnknownTag(
+        int     tag,
+        byte[]  data)
+    {
+        this(false, tag, data);
+    }
+
+    public DERUnknownTag(
+        boolean isConstructed,
+        int     tag,
+        byte[]  data)
+    {
+        this.isConstructed = isConstructed;
+        this.tag = tag;
+        this.data = data;
+    }
+
+    public boolean isConstructed()
+    {
+        return isConstructed;
+    }
+
+    public int getTag()
+    {
+        return tag;
+    }
+
+    public byte[] getData()
+    {
+        return data;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(isConstructed ? DERTags.CONSTRUCTED : 0, tag, data);
+    }
+    
+    public boolean equals(
+        Object o)
+    {
+        if (!(o instanceof DERUnknownTag))
+        {
+            return false;
+        }
+        
+        DERUnknownTag other = (DERUnknownTag)o;
+
+        return isConstructed == other.isConstructed
+            &amp;&amp; tag == other.tag
+            &amp;&amp; Arrays.areEqual(data, other.data);
+    }
+    
+    public int hashCode()
+    {
+        return (isConstructed ? ~0 : 0) ^ tag ^ Arrays.hashCode(data);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DERVisibleString.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DERVisibleString.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DERVisibleString.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DERVisibleString.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DERVisibleString.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+/**
+ * DER VisibleString object.
+ */
+public class DERVisibleString
+    extends ASN1Object
+    implements DERString
+{
+    String  string;
+
+    /**
+     * return a Visible String from the passed in object.
+     *
+     * @exception IllegalArgumentException if the object cannot be converted.
+     */
+    public static DERVisibleString getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof DERVisibleString)
+        {
+            return (DERVisibleString)obj;
+        }
+
+        if (obj instanceof ASN1OctetString)
+        {
+            return new DERVisibleString(((ASN1OctetString)obj).getOctets());
+        }
+
+        if (obj instanceof ASN1TaggedObject)
+        {
+            return getInstance(((ASN1TaggedObject)obj).getObject());
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * return a Visible String from a tagged object.
+     *
+     * @param obj the tagged object holding the object we want
+     * @param explicit true if the object is meant to be explicitly
+     *              tagged false otherwise.
+     * @exception IllegalArgumentException if the tagged object cannot
+     *               be converted.
+     */
+    public static DERVisibleString getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(obj.getObject());
+    }
+
+    /**
+     * basic constructor - byte encoded string.
+     */
+    public DERVisibleString(
+        byte[]   string)
+    {
+        char[]  cs = new char[string.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(string[i] &amp; 0xff);
+        }
+
+        this.string = new String(cs);
+    }
+
+    /**
+     * basic constructor
+     */
+    public DERVisibleString(
+        String   string)
+    {
+        this.string = string;
+    }
+
+    public String getString()
+    {
+        return string;
+    }
+
+    public String toString()
+    {
+        return string;
+    }
+
+    public byte[] getOctets()
+    {
+        char[]  cs = string.toCharArray();
+        byte[]  bs = new byte[cs.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            bs[i] = (byte)cs[i];
+        }
+
+        return bs;
+    }
+
+    void encode(
+        DEROutputStream  out)
+        throws IOException
+    {
+        out.writeEncoded(VISIBLE_STRING, this.getOctets());
+    }
+    
+    boolean asn1Equals(
+        DERObject  o)
+    {
+        if (!(o instanceof DERVisibleString))
+        {
+            return false;
+        }
+
+        return this.getString().equals(((DERVisibleString)o).getString());
+    }
+    
+    public int hashCode()
+    {
+        return this.getString().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/DefiniteLengthInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,105 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.EOFException;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.util.io.Streams;
+
+class DefiniteLengthInputStream
+        extends LimitedInputStream
+{
+    private static final byte[] EMPTY_BYTES = new byte[0];
+
+    private final int _originalLength;
+    private int _remaining;
+
+    DefiniteLengthInputStream(
+        InputStream in,
+        int         length)
+    {
+        super(in, length);
+
+        if (length &lt; 0)
+        {
+            throw new IllegalArgumentException(&quot;negative lengths not allowed&quot;);
+        }
+
+        this._originalLength = length;
+        this._remaining = length;
+
+        if (length == 0)
+        {
+            setParentEofDetect(true);
+        }
+    }
+
+    int getRemaining()
+    {
+        return _remaining;
+    }
+
+    public int read()
+        throws IOException
+    {
+        if (_remaining == 0)
+        {
+            return -1;
+        }
+
+        int b = _in.read();
+
+        if (b &lt; 0)
+        {
+            throw new EOFException(&quot;DEF length &quot; + _originalLength + &quot; object truncated by &quot; + _remaining);
+        }
+
+        if (--_remaining == 0)
+        {
+            setParentEofDetect(true);
+        }
+
+        return b;
+    }
+
+    public int read(byte[] buf, int off, int len)
+        throws IOException
+    {
+        if (_remaining == 0)
+        {
+            return -1;
+        }
+
+        int toRead = Math.min(len, _remaining);
+        int numRead = _in.read(buf, off, toRead);
+
+        if (numRead &lt; 0)
+        {
+            throw new EOFException(&quot;DEF length &quot; + _originalLength + &quot; object truncated by &quot; + _remaining);
+        }
+
+        if ((_remaining -= numRead) == 0)
+        {
+            setParentEofDetect(true);
+        }
+
+        return numRead;
+    }
+
+    byte[] toByteArray()
+        throws IOException
+    {
+        if (_remaining == 0)
+        {
+            return EMPTY_BYTES;
+        }
+
+        byte[] bytes = new byte[_remaining];
+        if ((_remaining -= Streams.readFully(_in, bytes)) != 0)
+        {
+            throw new EOFException(&quot;DEF length &quot; + _originalLength + &quot; object truncated by &quot; + _remaining);
+        }
+        setParentEofDetect(true);
+        return bytes;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/InMemoryRepresentable.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,9 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+
+public interface InMemoryRepresentable
+{
+    DERObject getLoadedObject()
+        throws IOException;
+}

Added: trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/IndefiniteLengthInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,111 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.EOFException;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+class IndefiniteLengthInputStream
+    extends LimitedInputStream
+{
+    private int _b1;
+    private int _b2;
+    private boolean _eofReached = false;
+    private boolean _eofOn00 = true;
+
+    IndefiniteLengthInputStream(
+        InputStream in,
+        int         limit)
+        throws IOException
+    {
+        super(in, limit);
+
+        _b1 = in.read();
+        _b2 = in.read();
+
+        if (_b2 &lt; 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        checkForEof();
+    }
+
+    void setEofOn00(
+        boolean eofOn00)
+    {
+        _eofOn00 = eofOn00;
+        checkForEof();
+    }
+
+    private boolean checkForEof()
+    {
+        if (!_eofReached &amp;&amp; _eofOn00 &amp;&amp; (_b1 == 0x00 &amp;&amp; _b2 == 0x00))
+        {
+            _eofReached = true;
+            setParentEofDetect(true);
+        }
+        return _eofReached;
+    }
+
+    public int read(byte[] b, int off, int len)
+        throws IOException
+    {
+        // Only use this optimisation if we aren't checking for 00
+        if (_eofOn00 || len &lt; 3)
+        {
+            return super.read(b, off, len);
+        }
+
+        if (_eofReached)
+        {
+            return -1;
+        }
+
+        int numRead = _in.read(b, off + 2, len - 2);
+
+        if (numRead &lt; 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        b[off] = (byte)_b1;
+        b[off + 1] = (byte)_b2;
+
+        _b1 = _in.read();
+        _b2 = _in.read();
+
+        if (_b2 &lt; 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        return numRead + 2;
+    }
+
+    public int read()
+        throws IOException
+    {
+        if (checkForEof())
+        {
+            return -1;
+        }
+
+        int b = _in.read();
+
+        if (b &lt; 0)
+        {
+            // Corrupted stream
+            throw new EOFException();
+        }
+
+        int v = _b1;
+
+        _b1 = _b2;
+        _b2 = b;
+
+        return v;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/LazyDERConstructionEnumeration.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,43 @@
+package org.bouncycastle.asn1;
+
+import ewe.util.Enumeration;
+import ewe.io.IOException;
+
+class LazyDERConstructionEnumeration
+    implements Enumeration
+{
+    private ASN1InputStream aIn;
+    private Object          nextObj;
+
+    public LazyDERConstructionEnumeration(byte[] encoded)
+    {
+        aIn = new ASN1InputStream(encoded, true);
+        nextObj = readObject();
+    }
+
+    public boolean hasMoreElements()
+    {
+        return nextObj != null;
+    }
+
+    public Object nextElement()
+    {
+        Object o = nextObj;
+
+        nextObj = readObject();
+
+        return o;
+    }
+
+    private Object readObject()
+    {
+        try
+        {
+            return aIn.readObject();
+        }
+        catch (IOException e)
+        {
+            throw new ASN1ParsingException(&quot;malformed DER construction: &quot; + e, e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/LazyDERSequence.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/LazyDERSequence.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/LazyDERSequence.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/LazyDERSequence.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,75 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+public class LazyDERSequence
+    extends DERSequence
+{
+    private byte[] encoded;
+    private boolean parsed = false;
+    private int size = -1;
+
+    LazyDERSequence(
+        byte[] encoded)
+        throws IOException
+    {
+        this.encoded = encoded;
+    }
+
+    private void parse()
+    {
+        Enumeration en = new LazyDERConstructionEnumeration(encoded);
+
+        while (en.hasMoreElements())
+        {
+            addObject((DEREncodable)en.nextElement());
+        }
+
+        parsed = true;
+    }
+
+    public synchronized DEREncodable getObjectAt(int index)
+    {
+        if (!parsed)
+        {
+            parse();
+        }
+
+        return super.getObjectAt(index);
+    }
+
+    public synchronized Enumeration getObjects()
+    {
+        if (parsed)
+        {
+            return super.getObjects();
+        }
+
+        return new LazyDERConstructionEnumeration(encoded);
+    }
+
+    public int size()
+    {
+        if (size &lt; 0)
+        {
+            Enumeration en = new LazyDERConstructionEnumeration(encoded);
+
+            size = 0;
+            while (en.hasMoreElements())
+            {
+                en.nextElement();
+                size++;
+            }
+        }
+
+        return size;
+    }
+    
+    void encode(
+        DEROutputStream out)
+        throws IOException
+    {
+        out.writeEncoded(SEQUENCE | CONSTRUCTED, encoded);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/LimitedInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/LimitedInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/LimitedInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/LimitedInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,32 @@
+package org.bouncycastle.asn1;
+
+import ewe.io.InputStream;
+
+abstract class LimitedInputStream
+        extends InputStream
+{
+    protected final InputStream _in;
+    private int _limit;
+
+    LimitedInputStream(
+        InputStream in,
+        int         limit)
+    {
+        this._in = in;
+        this._limit = limit;
+    }
+
+    int getRemaining()
+    {
+        // TODO: maybe one day this can become more accurate
+        return _limit;
+    }
+    
+    protected void setParentEofDetect(boolean on)
+    {
+        if (_in instanceof IndefiniteLengthInputStream)
+        {
+            ((IndefiniteLengthInputStream)_in).setEofOn00(on);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/OIDTokenizer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/OIDTokenizer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/OIDTokenizer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/OIDTokenizer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.asn1;
+
+/**
+ * class for breaking up an OID into it's component tokens, ala
+ * java.util.StringTokenizer. We need this class as some of the
+ * lightweight Java environment don't support classes like
+ * StringTokenizer.
+ */
+public class OIDTokenizer
+{
+    private String  oid;
+    private int     index;
+
+    public OIDTokenizer(
+        String oid)
+    {
+        this.oid = oid;
+        this.index = 0;
+    }
+
+    public boolean hasMoreTokens()
+    {
+        return (index != -1);
+    }
+
+    public String nextToken()
+    {
+        if (index == -1)
+        {
+            return null;
+        }
+
+        String  token;
+        int     end = oid.indexOf('.', index);
+
+        if (end == -1)
+        {
+            token = oid.substring(index);
+            index = -1;
+            return token;
+        }
+
+        token = oid.substring(index, end);
+
+        index = end + 1;
+        return token;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/nist/NISTNamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,96 @@
+package org.bouncycastle.asn1.nist;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.sec.SECNamedCurves;
+import org.bouncycastle.asn1.sec.SECObjectIdentifiers;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.util.Strings;
+
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+/**
+ * Utility class for fetching curves using their NIST names as published in FIPS-PUB 186-2
+ */
+public class NISTNamedCurves
+{
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+    }
+
+    static
+    {
+        // TODO Missing the &quot;K-&quot; curves
+
+        defineCurve(&quot;B-571&quot;, SECObjectIdentifiers.sect571r1);
+        defineCurve(&quot;B-409&quot;, SECObjectIdentifiers.sect409r1);
+        defineCurve(&quot;B-283&quot;, SECObjectIdentifiers.sect283r1);
+        defineCurve(&quot;B-233&quot;, SECObjectIdentifiers.sect233r1);
+        defineCurve(&quot;B-163&quot;, SECObjectIdentifiers.sect163r2);
+        defineCurve(&quot;P-521&quot;, SECObjectIdentifiers.secp521r1);
+        defineCurve(&quot;P-384&quot;, SECObjectIdentifiers.secp384r1);
+        defineCurve(&quot;P-256&quot;, SECObjectIdentifiers.secp256r1);
+        defineCurve(&quot;P-224&quot;, SECObjectIdentifiers.secp224r1);
+        defineCurve(&quot;P-192&quot;, SECObjectIdentifiers.secp192r1);
+    }
+
+    public static X9ECParameters getByName(
+        String  name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toUpperCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier  oid)
+    {
+        return SECNamedCurves.getByOID(oid);
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String  name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toUpperCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier  oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/nist/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/nist/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/nist/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Support classes for NIST related objects.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/oiw/ElGamalParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,49 @@
+package org.bouncycastle.asn1.oiw;
+
+import ewe.math.*;
+import ewe.util.*;
+
+import org.bouncycastle.asn1.*;
+
+public class ElGamalParameter
+    extends ASN1Encodable
+{
+    DERInteger      p, g;
+
+    public ElGamalParameter(
+        BigInteger  p,
+        BigInteger  g)
+    {
+        this.p = new DERInteger(p);
+        this.g = new DERInteger(g);
+    }
+
+    public ElGamalParameter(
+        ASN1Sequence  seq)
+    {
+        Enumeration     e = seq.getObjects();
+
+        p = (DERInteger)e.nextElement();
+        g = (DERInteger)e.nextElement();
+    }
+
+    public BigInteger getP()
+    {
+        return p.getPositiveValue();
+    }
+
+    public BigInteger getG()
+    {
+        return g.getPositiveValue();
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(p);
+        v.add(g);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/oiw/OIWObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,31 @@
+package org.bouncycastle.asn1.oiw;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface OIWObjectIdentifiers
+{
+    // id-SHA1 OBJECT IDENTIFIER ::=    
+    //   {iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2) 26 }    //
+    static final ASN1ObjectIdentifier    md4WithRSA              = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.2&quot;);
+    static final ASN1ObjectIdentifier    md5WithRSA              = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.3&quot;);
+    static final ASN1ObjectIdentifier    md4WithRSAEncryption    = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.4&quot;);
+    
+    static final ASN1ObjectIdentifier    desECB                  = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.6&quot;);
+    static final ASN1ObjectIdentifier    desCBC                  = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.7&quot;);
+    static final ASN1ObjectIdentifier    desOFB                  = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.8&quot;);
+    static final ASN1ObjectIdentifier    desCFB                  = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.9&quot;);
+
+    static final ASN1ObjectIdentifier    desEDE                  = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.17&quot;);
+    
+    static final ASN1ObjectIdentifier    idSHA1                  = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.26&quot;);
+
+    static final ASN1ObjectIdentifier    dsaWithSHA1             = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.27&quot;);
+
+    static final ASN1ObjectIdentifier    sha1WithRSA             = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.29&quot;);
+    
+    // ElGamal Algorithm OBJECT IDENTIFIER ::=    
+    // {iso(1) identified-organization(3) oiw(14) dirservsig(7) algorithm(2) encryption(1) 1 }
+    //
+    static final ASN1ObjectIdentifier    elGamalAlgorithm        = new ASN1ObjectIdentifier(&quot;1.3.14.7.2.1.1&quot;);
+
+}

Added: trunk/src/org/bouncycastle/asn1/oiw/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/oiw/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/oiw/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Objects and OID for the support of ISO OIW.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/pkcs/DHParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,88 @@
+package org.bouncycastle.asn1.pkcs;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DHParameter
+    extends ASN1Encodable
+{
+    DERInteger      p, g, l;
+
+    public DHParameter(
+        BigInteger  p,
+        BigInteger  g,
+        int         l)
+    {
+        this.p = new DERInteger(p);
+        this.g = new DERInteger(g);
+
+        if (l != 0)
+        {
+            this.l = new DERInteger(l);
+        }
+        else
+        {
+            this.l = null;
+        }
+    }
+
+    public DHParameter(
+        ASN1Sequence  seq)
+    {
+        Enumeration     e = seq.getObjects();
+
+        p = (DERInteger)e.nextElement();
+        g = (DERInteger)e.nextElement();
+
+        if (e.hasMoreElements())
+        {
+            l = (DERInteger)e.nextElement();
+        }
+        else
+        {
+            l = null;
+        }
+    }
+
+    public BigInteger getP()
+    {
+        return p.getPositiveValue();
+    }
+
+    public BigInteger getG()
+    {
+        return g.getPositiveValue();
+    }
+
+    public BigInteger getL()
+    {
+        if (l == null)
+        {
+            return null;
+        }
+
+        return l.getPositiveValue();
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(p);
+        v.add(g);
+
+        if (this.getL() != null)
+        {
+            v.add(l);
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/pkcs/PKCSObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,252 @@
+package org.bouncycastle.asn1.pkcs;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface PKCSObjectIdentifiers
+{
+    //
+    // pkcs-1 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_1                    = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.1&quot;);
+    static final ASN1ObjectIdentifier    rsaEncryption             = pkcs_1.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    md2WithRSAEncryption      = pkcs_1.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier    md4WithRSAEncryption      = pkcs_1.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier    md5WithRSAEncryption      = pkcs_1.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier    sha1WithRSAEncryption     = pkcs_1.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier    srsaOAEPEncryptionSET     = pkcs_1.branch(&quot;6&quot;);
+    static final ASN1ObjectIdentifier    id_RSAES_OAEP             = pkcs_1.branch(&quot;7&quot;);
+    static final ASN1ObjectIdentifier    id_mgf1                   = pkcs_1.branch(&quot;8&quot;);
+    static final ASN1ObjectIdentifier    id_pSpecified             = pkcs_1.branch(&quot;9&quot;);
+    static final ASN1ObjectIdentifier    id_RSASSA_PSS             = pkcs_1.branch(&quot;10&quot;);
+    static final ASN1ObjectIdentifier    sha256WithRSAEncryption   = pkcs_1.branch(&quot;11&quot;);
+    static final ASN1ObjectIdentifier    sha384WithRSAEncryption   = pkcs_1.branch(&quot;12&quot;);
+    static final ASN1ObjectIdentifier    sha512WithRSAEncryption   = pkcs_1.branch(&quot;13&quot;);
+    static final ASN1ObjectIdentifier    sha224WithRSAEncryption   = pkcs_1.branch(&quot;14&quot;);
+
+    //
+    // pkcs-3 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 3 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_3                  = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.3&quot;);
+    static final ASN1ObjectIdentifier    dhKeyAgreement          = pkcs_3.branch(&quot;1&quot;);
+
+    //
+    // pkcs-5 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 5 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_5                  = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5&quot;);
+
+    static final ASN1ObjectIdentifier    pbeWithMD2AndDES_CBC    = pkcs_5.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    pbeWithMD2AndRC2_CBC    = pkcs_5.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier    pbeWithMD5AndDES_CBC    = pkcs_5.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier    pbeWithMD5AndRC2_CBC    = pkcs_5.branch(&quot;6&quot;);
+    static final ASN1ObjectIdentifier    pbeWithSHA1AndDES_CBC   = pkcs_5.branch(&quot;10&quot;);
+    static final ASN1ObjectIdentifier    pbeWithSHA1AndRC2_CBC   = pkcs_5.branch(&quot;11&quot;);
+
+    static final ASN1ObjectIdentifier    id_PBES2                = pkcs_5.branch(&quot;13&quot;);
+
+    static final ASN1ObjectIdentifier    id_PBKDF2               = pkcs_5.branch(&quot;12&quot;);
+
+    //
+    // encryptionAlgorithm OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) 3 }
+    //
+    static final ASN1ObjectIdentifier    encryptionAlgorithm     = new ASN1ObjectIdentifier(&quot;1.2.840.113549.3&quot;);
+
+    static final ASN1ObjectIdentifier    des_EDE3_CBC            = encryptionAlgorithm.branch(&quot;7&quot;);
+    static final ASN1ObjectIdentifier    RC2_CBC                 = encryptionAlgorithm.branch(&quot;2&quot;);
+
+    //
+    // object identifiers for digests
+    //
+    static final ASN1ObjectIdentifier    digestAlgorithm        = new ASN1ObjectIdentifier(&quot;1.2.840.113549.2&quot;);
+    //
+    // md2 OBJECT IDENTIFIER ::=
+    //      {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 2}
+    //
+    static final ASN1ObjectIdentifier    md2                    = digestAlgorithm.branch(&quot;2&quot;);
+
+    //
+    // md4 OBJECT IDENTIFIER ::=
+    //      {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 4}
+    //
+    static final ASN1ObjectIdentifier    md4 = digestAlgorithm.branch(&quot;4&quot;);
+
+    //
+    // md5 OBJECT IDENTIFIER ::=
+    //      {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 5}
+    //
+    static final ASN1ObjectIdentifier    md5                     = digestAlgorithm.branch(&quot;5&quot;);
+
+    static final ASN1ObjectIdentifier    id_hmacWithSHA1         = digestAlgorithm.branch(&quot;7&quot;);
+    static final ASN1ObjectIdentifier    id_hmacWithSHA224       = digestAlgorithm.branch(&quot;8&quot;);
+    static final ASN1ObjectIdentifier    id_hmacWithSHA256       = digestAlgorithm.branch(&quot;9&quot;);
+    static final ASN1ObjectIdentifier    id_hmacWithSHA384       = digestAlgorithm.branch(&quot;10&quot;);
+    static final ASN1ObjectIdentifier    id_hmacWithSHA512       = digestAlgorithm.branch(&quot;11&quot;);
+
+    //
+    // pkcs-7 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 7 }
+    //
+    static final String                 pkcs_7                  = &quot;1.2.840.113549.1.7&quot;;
+    static final ASN1ObjectIdentifier    data                    = new ASN1ObjectIdentifier(pkcs_7 + &quot;.1&quot;);
+    static final ASN1ObjectIdentifier    signedData              = new ASN1ObjectIdentifier(pkcs_7 + &quot;.2&quot;);
+    static final ASN1ObjectIdentifier    envelopedData           = new ASN1ObjectIdentifier(pkcs_7 + &quot;.3&quot;);
+    static final ASN1ObjectIdentifier    signedAndEnvelopedData  = new ASN1ObjectIdentifier(pkcs_7 + &quot;.4&quot;);
+    static final ASN1ObjectIdentifier    digestedData            = new ASN1ObjectIdentifier(pkcs_7 + &quot;.5&quot;);
+    static final ASN1ObjectIdentifier    encryptedData           = new ASN1ObjectIdentifier(pkcs_7 + &quot;.6&quot;);
+
+    //
+    // pkcs-9 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 9 }
+    //
+    static final ASN1ObjectIdentifier    pkcs_9                  = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.9&quot;);
+
+    static final ASN1ObjectIdentifier    pkcs_9_at_emailAddress  = pkcs_9.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_unstructuredName = pkcs_9.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_contentType = pkcs_9.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_messageDigest = pkcs_9.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_signingTime = pkcs_9.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_counterSignature = pkcs_9.branch(&quot;6&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_challengePassword = pkcs_9.branch(&quot;7&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_unstructuredAddress = pkcs_9.branch(&quot;8&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_extendedCertificateAttributes = pkcs_9.branch(&quot;9&quot;);
+
+    static final ASN1ObjectIdentifier    pkcs_9_at_signingDescription = pkcs_9.branch(&quot;13&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_extensionRequest = pkcs_9.branch(&quot;14&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_smimeCapabilities = pkcs_9.branch(&quot;15&quot;);
+
+    static final ASN1ObjectIdentifier    pkcs_9_at_friendlyName  = pkcs_9.branch(&quot;20&quot;);
+    static final ASN1ObjectIdentifier    pkcs_9_at_localKeyId    = pkcs_9.branch(&quot;21&quot;);
+
+    /** @deprecated use x509Certificate instead */
+    static final ASN1ObjectIdentifier    x509certType            = pkcs_9.branch(&quot;22.1&quot;);
+
+    static final ASN1ObjectIdentifier    certTypes               = pkcs_9.branch(&quot;22&quot;);
+    static final ASN1ObjectIdentifier    x509Certificate         = certTypes.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    sdsiCertificate         = certTypes.branch(&quot;2&quot;);
+
+    static final ASN1ObjectIdentifier    crlTypes                = pkcs_9.branch(&quot;23&quot;);
+    static final ASN1ObjectIdentifier    x509Crl                 = crlTypes.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier    id_alg_PWRI_KEK    = pkcs_9.branch(&quot;16.3.9&quot;);
+
+    //
+    // SMIME capability sub oids.
+    //
+    static final ASN1ObjectIdentifier    preferSignedData        = pkcs_9.branch(&quot;15.1&quot;);
+    static final ASN1ObjectIdentifier    canNotDecryptAny        = pkcs_9.branch(&quot;15.2&quot;);
+    static final ASN1ObjectIdentifier    sMIMECapabilitiesVersions = pkcs_9.branch(&quot;15.3&quot;);
+
+    //
+    // id-ct OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) ct(1)}
+    //
+    static final ASN1ObjectIdentifier    id_ct = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.9.16.1&quot;);
+
+    static final ASN1ObjectIdentifier    id_ct_authData          = id_ct.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier    id_ct_TSTInfo           = id_ct.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier    id_ct_compressedData    = id_ct.branch(&quot;9&quot;);
+    static final ASN1ObjectIdentifier    id_ct_authEnvelopedData = id_ct.branch(&quot;23&quot;);
+    static final ASN1ObjectIdentifier    id_ct_timestampedData   = id_ct.branch(&quot;31&quot;);
+
+    //
+    // id-cti OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) cti(6)}
+    //
+    static final ASN1ObjectIdentifier    id_cti = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.9.16.6&quot;);
+    
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfOrigin  = id_cti.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfReceipt = id_cti.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfDelivery = id_cti.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfSender = id_cti.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfApproval = id_cti.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier    id_cti_ets_proofOfCreation = id_cti.branch(&quot;6&quot;);
+    
+    //
+    // id-aa OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) attributes(2)}
+    //
+    static final ASN1ObjectIdentifier    id_aa = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.9.16.2&quot;);
+
+
+    static final ASN1ObjectIdentifier id_aa_receiptRequest = id_aa.branch(&quot;1&quot;);
+    
+    static final ASN1ObjectIdentifier id_aa_contentHint = id_aa.branch(&quot;4&quot;); // See RFC 2634
+    static final ASN1ObjectIdentifier id_aa_msgSigDigest = id_aa.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier id_aa_contentReference = id_aa.branch(&quot;10&quot;);
+    /*
+     * id-aa-encrypKeyPref OBJECT IDENTIFIER ::= {id-aa 11}
+     * 
+     */
+    static final ASN1ObjectIdentifier id_aa_encrypKeyPref = id_aa.branch(&quot;11&quot;);
+    static final ASN1ObjectIdentifier id_aa_signingCertificate = id_aa.branch(&quot;12&quot;);
+    static final ASN1ObjectIdentifier id_aa_signingCertificateV2 = id_aa.branch(&quot;47&quot;);
+
+    static final ASN1ObjectIdentifier id_aa_contentIdentifier = id_aa.branch(&quot;7&quot;); // See RFC 2634
+
+    /*
+     * RFC 3126
+     */
+    static final ASN1ObjectIdentifier id_aa_signatureTimeStampToken = id_aa.branch(&quot;14&quot;);
+    
+    static final ASN1ObjectIdentifier id_aa_ets_sigPolicyId = id_aa.branch(&quot;15&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_commitmentType = id_aa.branch(&quot;16&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_signerLocation = id_aa.branch(&quot;17&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_signerAttr = id_aa.branch(&quot;18&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_otherSigCert = id_aa.branch(&quot;19&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_contentTimestamp = id_aa.branch(&quot;20&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_certificateRefs = id_aa.branch(&quot;21&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_revocationRefs = id_aa.branch(&quot;22&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_certValues = id_aa.branch(&quot;23&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_revocationValues = id_aa.branch(&quot;24&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_escTimeStamp = id_aa.branch(&quot;25&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_certCRLTimestamp = id_aa.branch(&quot;26&quot;);
+    static final ASN1ObjectIdentifier id_aa_ets_archiveTimestamp = id_aa.branch(&quot;27&quot;);
+
+    /** @deprecated use id_aa_ets_sigPolicyId instead */
+    static final ASN1ObjectIdentifier id_aa_sigPolicyId = id_aa_ets_sigPolicyId;
+    /** @deprecated use id_aa_ets_commitmentType instead */
+    static final ASN1ObjectIdentifier id_aa_commitmentType = id_aa_ets_commitmentType;
+    /** @deprecated use id_aa_ets_signerLocation instead */
+    static final ASN1ObjectIdentifier id_aa_signerLocation = id_aa_ets_signerLocation;
+    /** @deprecated use id_aa_ets_otherSigCert instead */
+    static final ASN1ObjectIdentifier id_aa_otherSigCert = id_aa_ets_otherSigCert;
+    
+    //
+    // id-spq OBJECT IDENTIFIER ::= {iso(1) member-body(2) usa(840)
+    // rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-spq(5)}
+    //
+    final String id_spq = &quot;1.2.840.113549.1.9.16.5&quot;;
+
+    static final ASN1ObjectIdentifier id_spq_ets_uri = new ASN1ObjectIdentifier(id_spq + &quot;.1&quot;);
+    static final ASN1ObjectIdentifier id_spq_ets_unotice = new ASN1ObjectIdentifier(id_spq + &quot;.2&quot;);
+
+    //
+    // pkcs-12 OBJECT IDENTIFIER ::= {
+    //       iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 12 }
+    //
+    static final ASN1ObjectIdentifier   pkcs_12                  = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.12&quot;);
+    static final ASN1ObjectIdentifier   bagtypes                 = pkcs_12.branch(&quot;10.1&quot;);
+
+    static final ASN1ObjectIdentifier    keyBag                  = bagtypes.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    pkcs8ShroudedKeyBag     = bagtypes.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier    certBag                 = bagtypes.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier    crlBag                  = bagtypes.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier    secretBag               = bagtypes.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier    safeContentsBag         = bagtypes.branch(&quot;6&quot;);
+
+    static final ASN1ObjectIdentifier    pkcs_12PbeIds  = pkcs_12.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd128BitRC4 = pkcs_12PbeIds.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd40BitRC4  = pkcs_12PbeIds.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd3_KeyTripleDES_CBC = pkcs_12PbeIds.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd2_KeyTripleDES_CBC = pkcs_12PbeIds.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier    pbeWithSHAAnd128BitRC2_CBC = pkcs_12PbeIds.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier    pbewithSHAAnd40BitRC2_CBC = pkcs_12PbeIds.branch(&quot;6&quot;);
+
+    static final ASN1ObjectIdentifier    id_alg_CMS3DESwrap = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.9.16.3.6&quot;);
+    static final ASN1ObjectIdentifier    id_alg_CMSRC2wrap = new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.9.16.3.7&quot;);
+}
+

Added: trunk/src/org/bouncycastle/asn1/pkcs/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/pkcs/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/pkcs/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Support classes useful for encoding and supporting the various RSA PKCS documents.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$10.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$11.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$12.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$13.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$14.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$15.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$16.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$17.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$18.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$19.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$2.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$20.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$21.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$22.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$23.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$24.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$25.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$26.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$27.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$28.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$29.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$3.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$30.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$31.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$32.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$33.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$4.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$5.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$6.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$7.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$8.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves$9.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/sec/SECNamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1029 @@
+package org.bouncycastle.asn1.sec;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.asn1.x9.X9ECParametersHolder;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+public class SECNamedCurves
+{
+    private static BigInteger fromHex(
+        String hex)
+    {
+        return new BigInteger(1, Hex.decode(hex));
+    }
+
+    /*
+     * secp112r1
+     */
+    static X9ECParametersHolder secp112r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = (2^128 - 3) / 76439
+            BigInteger p = fromHex(&quot;DB7C2ABF62E35E668076BEAD208B&quot;);
+            BigInteger a = fromHex(&quot;DB7C2ABF62E35E668076BEAD2088&quot;);
+            BigInteger b = fromHex(&quot;659EF8BA043916EEDE8911702B22&quot;);
+            byte[] S = Hex.decode(&quot;00F50B028E4D696E676875615175290472783FB1&quot;);
+            BigInteger n = fromHex(&quot;DB7C2ABF62E35E7628DFAC6561C5&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;09487239995A5EE76B55F9C2F098&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;09487239995A5EE76B55F9C2F098&quot;
+                + &quot;A89CE5AF8724C0A23E0E0FF77500&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp112r2
+     */
+    static X9ECParametersHolder secp112r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = (2^128 - 3) / 76439
+            BigInteger p = fromHex(&quot;DB7C2ABF62E35E668076BEAD208B&quot;);
+            BigInteger a = fromHex(&quot;6127C24C05F38A0AAAF65C0EF02C&quot;);
+            BigInteger b = fromHex(&quot;51DEF1815DB5ED74FCC34C85D709&quot;);
+            byte[] S = Hex.decode(&quot;002757A1114D696E6768756151755316C05E0BD4&quot;);
+            BigInteger n = fromHex(&quot;36DF0AAFD8B8D7597CA10520D04B&quot;);
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;4BA30AB5E892B4E1649DD0928643&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;4BA30AB5E892B4E1649DD0928643&quot;
+                + &quot;ADCD46F5882E3747DEF36E956E97&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp128r1
+     */
+    static X9ECParametersHolder secp128r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^128 - 2^97 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF&quot;);
+            BigInteger a = fromHex(&quot;FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC&quot;);
+            BigInteger b = fromHex(&quot;E87579C11079F43DD824993C2CEE5ED3&quot;);
+            byte[] S = Hex.decode(&quot;000E0D4D696E6768756151750CC03A4473D03679&quot;);
+            BigInteger n = fromHex(&quot;FFFFFFFE0000000075A30D1B9038A115&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;161FF7528B899B2D0C28607CA52C5B86&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;161FF7528B899B2D0C28607CA52C5B86&quot;
+                + &quot;CF5AC8395BAFEB13C02DA292DDED7A83&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp128r2
+     */
+    static X9ECParametersHolder secp128r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^128 - 2^97 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF&quot;);
+            BigInteger a = fromHex(&quot;D6031998D1B3BBFEBF59CC9BBFF9AEE1&quot;);
+            BigInteger b = fromHex(&quot;5EEEFCA380D02919DC2C6558BB6D8A5D&quot;);
+            byte[] S = Hex.decode(&quot;004D696E67687561517512D8F03431FCE63B88F4&quot;);
+            BigInteger n = fromHex(&quot;3FFFFFFF7FFFFFFFBE0024720613B5A3&quot;);
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;7B6AA5D85E572983E6FB32A7CDEBC140&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;7B6AA5D85E572983E6FB32A7CDEBC140&quot;
+                + &quot;27B6916A894D3AEE7106FE805FC34B44&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp160k1
+     */
+    static X9ECParametersHolder secp160k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73&quot;);
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(7);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;0100000000000000000001B8FA16DFAB9ACA16B6B3&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+//            ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+//                + &quot;3B4C382CE37AA192A4019E763036F4F5DD4D7EBB&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;3B4C382CE37AA192A4019E763036F4F5DD4D7EBB&quot;
+                + &quot;938CF935318FDCED6BC28286531733C3F03C4FEE&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp160r1
+     */
+    static X9ECParametersHolder secp160r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^160 - 2^31 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF&quot;);
+            BigInteger a = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC&quot;);
+            BigInteger b = fromHex(&quot;1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45&quot;);
+            byte[] S = Hex.decode(&quot;1053CDE42C14D696E67687561517533BF3F83345&quot;);
+            BigInteger n = fromHex(&quot;0100000000000000000001F4C8F927AED3CA752257&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+                //+ &quot;4A96B5688EF573284664698968C38BB913CBFC82&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;4A96B5688EF573284664698968C38BB913CBFC82&quot;
+                + &quot;23A628553168947D59DCC912042351377AC5FB32&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp160r2
+     */
+    static X9ECParametersHolder secp160r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73&quot;);
+            BigInteger a = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC70&quot;);
+            BigInteger b = fromHex(&quot;B4E134D3FB59EB8BAB57274904664D5AF50388BA&quot;);
+            byte[] S = Hex.decode(&quot;B99B99B099B323E02709A4D696E6768756151751&quot;);
+            BigInteger n = fromHex(&quot;0100000000000000000000351EE786A818F3A1A16B&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;52DCB034293A117E1F4FF11B30F7199D3144CE6D&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;52DCB034293A117E1F4FF11B30F7199D3144CE6D&quot;
+                + &quot;FEAFFEF2E331F296E071FA0DF9982CFEA7D43F2E&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp192k1
+     */
+    static X9ECParametersHolder secp192k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37&quot;);
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(3);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D&quot;
+                + &quot;9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp192r1
+     */
+    static X9ECParametersHolder secp192r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^192 - 2^64 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF&quot;);
+            BigInteger a = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC&quot;);
+            BigInteger b = fromHex(&quot;64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1&quot;);
+            byte[] S = Hex.decode(&quot;3045AE6FC8422F64ED579528D38120EAE12196D5&quot;);
+            BigInteger n = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012&quot;
+                + &quot;07192B95FFC8DA78631011ED6B24CDD573F977A11E794811&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp224k1
+     */
+    static X9ECParametersHolder secp224k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^224 - 2^32 - 2^12 - 2^11 - 2^9 - 2^7 - 2^4 - 2 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D&quot;);
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(5);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;010000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C&quot;
+                + &quot;7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp224r1
+     */
+    static X9ECParametersHolder secp224r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^224 - 2^96 + 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001&quot;);
+            BigInteger a = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE&quot;);
+            BigInteger b = fromHex(&quot;B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4&quot;);
+            byte[] S = Hex.decode(&quot;BD71344799D5C7FCDC45B59FA3B9AB8F6A948BC5&quot;);
+            BigInteger n = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21&quot;
+                + &quot;BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp256k1
+     */
+    static X9ECParametersHolder secp256k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F&quot;);
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(7);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798&quot;
+                + &quot;483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp256r1
+     */
+    static X9ECParametersHolder secp256r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF&quot;);
+            BigInteger a = fromHex(&quot;FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC&quot;);
+            BigInteger b = fromHex(&quot;5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B&quot;);
+            byte[] S = Hex.decode(&quot;C49D360886E704936A6678E1139D26B7819F7E90&quot;);
+            BigInteger n = fromHex(&quot;FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296&quot;
+                + &quot;4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp384r1
+     */
+    static X9ECParametersHolder secp384r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^384 - 2^128 - 2^96 + 2^32 - 1
+            BigInteger p = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF&quot;);
+            BigInteger a = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC&quot;);
+            BigInteger b = fromHex(&quot;B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF&quot;);
+            byte[] S = Hex.decode(&quot;A335926AA319A27A1D00896A6773A4827ACDAC73&quot;);
+            BigInteger n = fromHex(&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7&quot;
+                + &quot;3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * secp521r1
+     */
+    static X9ECParametersHolder secp521r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            // p = 2^521 - 1
+            BigInteger p = fromHex(&quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;);
+            BigInteger a = fromHex(&quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC&quot;);
+            BigInteger b = fromHex(&quot;0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00&quot;);
+            byte[] S = Hex.decode(&quot;D09E8800291CB85396CC6717393284AAA0DA64BA&quot;);
+            BigInteger n = fromHex(&quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409&quot;);
+            BigInteger h = BigInteger.valueOf(1);
+
+            ECCurve curve = new ECCurve.Fp(p, a, b);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66&quot;
+                + &quot;011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+    
+    /*
+     * sect113r1
+     */
+    static X9ECParametersHolder sect113r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 113;
+            int k = 9;
+
+            BigInteger a = fromHex(&quot;003088250CA6E7C7FE649CE85820F7&quot;);
+            BigInteger b = fromHex(&quot;00E8BEE4D3E2260744188BE0E9C723&quot;);
+            byte[] S = Hex.decode(&quot;10E723AB14D696E6768756151756FEBF8FCB49A9&quot;);
+            BigInteger n = fromHex(&quot;0100000000000000D9CCEC8A39E56F&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;009D73616F35F4AB1407D73562C10F&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;009D73616F35F4AB1407D73562C10F&quot;
+                + &quot;00A52830277958EE84D1315ED31886&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect113r2
+     */
+    static X9ECParametersHolder sect113r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 113;
+            int k = 9;
+
+            BigInteger a = fromHex(&quot;00689918DBEC7E5A0DD6DFC0AA55C7&quot;);
+            BigInteger b = fromHex(&quot;0095E9A9EC9B297BD4BF36E059184F&quot;);
+            byte[] S = Hex.decode(&quot;10C0FB15760860DEF1EEF4D696E676875615175D&quot;);
+            BigInteger n = fromHex(&quot;010000000000000108789B2496AF93&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;01A57A6A7B26CA5EF52FCDB8164797&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;01A57A6A7B26CA5EF52FCDB8164797&quot;
+                + &quot;00B3ADC94ED1FE674C06E695BABA1D&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect131r1
+     */
+    static X9ECParametersHolder sect131r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 131;
+            int k1 = 2;
+            int k2 = 3;
+            int k3 = 8;
+
+            BigInteger a = fromHex(&quot;07A11B09A76B562144418FF3FF8C2570B8&quot;);
+            BigInteger b = fromHex(&quot;0217C05610884B63B9C6C7291678F9D341&quot;);
+            byte[] S = Hex.decode(&quot;4D696E676875615175985BD3ADBADA21B43A97E2&quot;);
+            BigInteger n = fromHex(&quot;0400000000000000023123953A9464B54D&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;0081BAF91FDF9833C40F9C181343638399&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;0081BAF91FDF9833C40F9C181343638399&quot;
+                + &quot;078C6E7EA38C001F73C8134B1B4EF9E150&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect131r2
+     */
+    static X9ECParametersHolder sect131r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 131;
+            int k1 = 2;
+            int k2 = 3;
+            int k3 = 8;
+
+            BigInteger a = fromHex(&quot;03E5A88919D7CAFCBF415F07C2176573B2&quot;);
+            BigInteger b = fromHex(&quot;04B8266A46C55657AC734CE38F018F2192&quot;);
+            byte[] S = Hex.decode(&quot;985BD3ADBAD4D696E676875615175A21B43A97E3&quot;);
+            BigInteger n = fromHex(&quot;0400000000000000016954A233049BA98F&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;0356DCD8F2F95031AD652D23951BB366A8&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;0356DCD8F2F95031AD652D23951BB366A8&quot;
+                + &quot;0648F06D867940A5366D9E265DE9EB240F&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect163k1
+     */
+    static X9ECParametersHolder sect163k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 163;
+            int k1 = 3;
+            int k2 = 6;
+            int k3 = 7;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;04000000000000000000020108A2E0CC0D99F8A5EF&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;02FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE8&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;02FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE8&quot;
+                + &quot;0289070FB05D38FF58321F2E800536D538CCDAA3D9&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect163r1
+     */
+    static X9ECParametersHolder sect163r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 163;
+            int k1 = 3;
+            int k2 = 6;
+            int k3 = 7;
+
+            BigInteger a = fromHex(&quot;07B6882CAAEFA84F9554FF8428BD88E246D2782AE2&quot;);
+            BigInteger b = fromHex(&quot;0713612DCDDCB40AAB946BDA29CA91F73AF958AFD9&quot;);
+            byte[] S = Hex.decode(&quot;24B7B137C8A14D696E6768756151756FD0DA2E5C&quot;);
+            BigInteger n = fromHex(&quot;03FFFFFFFFFFFFFFFFFFFF48AAB689C29CA710279B&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;0369979697AB43897789566789567F787A7876A654&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;0369979697AB43897789566789567F787A7876A654&quot;
+                + &quot;00435EDB42EFAFB2989D51FEFCE3C80988F41FF883&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect163r2
+     */
+    static X9ECParametersHolder sect163r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 163;
+            int k1 = 3;
+            int k2 = 6;
+            int k3 = 7;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex(&quot;020A601907B8C953CA1481EB10512F78744A3205FD&quot;);
+            byte[] S = Hex.decode(&quot;85E25BFE5C86226CDB12016F7553F9D0E693A268&quot;);
+            BigInteger n = fromHex(&quot;040000000000000000000292FE77E70C12A4234C33&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;03F0EBA16286A2D57EA0991168D4994637E8343E36&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;03F0EBA16286A2D57EA0991168D4994637E8343E36&quot;
+                + &quot;00D51FBC6C71A0094FA2CDD545B11C5C0C797324F1&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect193r1
+     */
+    static X9ECParametersHolder sect193r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 193;
+            int k = 15;
+
+            BigInteger a = fromHex(&quot;0017858FEB7A98975169E171F77B4087DE098AC8A911DF7B01&quot;);
+            BigInteger b = fromHex(&quot;00FDFB49BFE6C3A89FACADAA7A1E5BBC7CC1C2E5D831478814&quot;);
+            byte[] S = Hex.decode(&quot;103FAEC74D696E676875615175777FC5B191EF30&quot;);
+            BigInteger n = fromHex(&quot;01000000000000000000000000C7F34A778F443ACC920EBA49&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;01F481BC5F0FF84A74AD6CDF6FDEF4BF6179625372D8C0C5E1&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;01F481BC5F0FF84A74AD6CDF6FDEF4BF6179625372D8C0C5E1&quot;
+                + &quot;0025E399F2903712CCF3EA9E3A1AD17FB0B3201B6AF7CE1B05&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect193r2
+     */
+    static X9ECParametersHolder sect193r2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 193;
+            int k = 15;
+
+            BigInteger a = fromHex(&quot;0163F35A5137C2CE3EA6ED8667190B0BC43ECD69977702709B&quot;);
+            BigInteger b = fromHex(&quot;00C9BB9E8927D4D64C377E2AB2856A5B16E3EFB7F61D4316AE&quot;);
+            byte[] S = Hex.decode(&quot;10B7B4D696E676875615175137C8A16FD0DA2211&quot;);
+            BigInteger n = fromHex(&quot;010000000000000000000000015AAB561B005413CCD4EE99D5&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;00D9B67D192E0367C803F39E1A7E82CA14A651350AAE617E8F&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;00D9B67D192E0367C803F39E1A7E82CA14A651350AAE617E8F&quot;
+                + &quot;01CE94335607C304AC29E7DEFBD9CA01F596F927224CDECF6C&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect233k1
+     */
+    static X9ECParametersHolder sect233k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 233;
+            int k = 74;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;8000000000000000000000000000069D5BB915BCD46EFB1AD5F173ABDF&quot;);
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;017232BA853A7E731AF129F22FF4149563A419C26BF50A4C9D6EEFAD6126&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;017232BA853A7E731AF129F22FF4149563A419C26BF50A4C9D6EEFAD6126&quot;
+                + &quot;01DB537DECE819B7F70F555A67C427A8CD9BF18AEB9B56E0C11056FAE6A3&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect233r1
+     */
+    static X9ECParametersHolder sect233r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 233;
+            int k = 74;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex(&quot;0066647EDE6C332C7F8C0923BB58213B333B20E9CE4281FE115F7D8F90AD&quot;);
+            byte[] S = Hex.decode(&quot;74D59FF07F6B413D0EA14B344B20A2DB049B50C3&quot;);
+            BigInteger n = fromHex(&quot;01000000000000000000000000000013E974E72F8A6922031D2603CFE0D7&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;00FAC9DFCBAC8313BB2139F1BB755FEF65BC391F8B36F8F8EB7371FD558B&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;00FAC9DFCBAC8313BB2139F1BB755FEF65BC391F8B36F8F8EB7371FD558B&quot;
+                + &quot;01006A08A41903350678E58528BEBF8A0BEFF867A7CA36716F7E01F81052&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect239k1
+     */
+    static X9ECParametersHolder sect239k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 239;
+            int k = 158;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;2000000000000000000000000000005A79FEC67CB6E91F1C1DA800E478A5&quot;);
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;29A0B6A887A983E9730988A68727A8B2D126C44CC2CC7B2A6555193035DC&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;29A0B6A887A983E9730988A68727A8B2D126C44CC2CC7B2A6555193035DC&quot;
+                + &quot;76310804F12E549BDB011C103089E73510ACB275FC312A5DC6B76553F0CA&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect283k1
+     */
+    static X9ECParametersHolder sect283k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 283;
+            int k1 = 5;
+            int k2 = 7;
+            int k3 = 12;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9AE2ED07577265DFF7F94451E061E163C61&quot;);
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;0503213F78CA44883F1A3B8162F188E553CD265F23C1567A16876913B0C2AC2458492836&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;0503213F78CA44883F1A3B8162F188E553CD265F23C1567A16876913B0C2AC2458492836&quot;
+                + &quot;01CCDA380F1C9E318D90F95D07E5426FE87E45C0E8184698E45962364E34116177DD2259&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect283r1
+     */
+    static X9ECParametersHolder sect283r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 283;
+            int k1 = 5;
+            int k2 = 7;
+            int k3 = 12;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex(&quot;027B680AC8B8596DA5A4AF8A19A0303FCA97FD7645309FA2A581485AF6263E313B79A2F5&quot;);
+            byte[] S = Hex.decode(&quot;77E2B07370EB0F832A6DD5B62DFC88CD06BB84BE&quot;);
+            BigInteger n = fromHex(&quot;03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEF90399660FC938A90165B042A7CEFADB307&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;05F939258DB7DD90E1934F8C70B0DFEC2EED25B8557EAC9C80E2E198F8CDBECD86B12053&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;05F939258DB7DD90E1934F8C70B0DFEC2EED25B8557EAC9C80E2E198F8CDBECD86B12053&quot;
+                + &quot;03676854FE24141CB98FE6D4B20D02B4516FF702350EDDB0826779C813F0DF45BE8112F4&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect409k1
+     */
+    static X9ECParametersHolder sect409k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 409;
+            int k = 87;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5F83B2D4EA20400EC4557D5ED3E3E7CA5B4B5C83B8E01E5FCF&quot;);
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;0060F05F658F49C1AD3AB1890F7184210EFD0987E307C84C27ACCFB8F9F67CC2C460189EB5AAAA62EE222EB1B35540CFE9023746&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;0060F05F658F49C1AD3AB1890F7184210EFD0987E307C84C27ACCFB8F9F67CC2C460189EB5AAAA62EE222EB1B35540CFE9023746&quot;
+                + &quot;01E369050B7C4E42ACBA1DACBF04299C3460782F918EA427E6325165E9EA10E3DA5F6C42E9C55215AA9CA27A5863EC48D8E0286B&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect409r1
+     */
+    static X9ECParametersHolder sect409r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 409;
+            int k = 87;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex(&quot;0021A5C2C8EE9FEB5C4B9A753B7B476B7FD6422EF1F3DD674761FA99D6AC27C8A9A197B272822F6CD57A55AA4F50AE317B13545F&quot;);
+            byte[] S = Hex.decode(&quot;4099B5A457F9D69F79213D094C4BCD4D4262210B&quot;);
+            BigInteger n = fromHex(&quot;010000000000000000000000000000000000000000000000000001E2AAD6A612F33307BE5FA47C3C9E052F838164CD37D9A21173&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;015D4860D088DDB3496B0C6064756260441CDE4AF1771D4DB01FFE5B34E59703DC255A868A1180515603AEAB60794E54BB7996A7&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;015D4860D088DDB3496B0C6064756260441CDE4AF1771D4DB01FFE5B34E59703DC255A868A1180515603AEAB60794E54BB7996A7&quot;
+                + &quot;0061B1CFAB6BE5F32BBFA78324ED106A7636B9C5A7BD198D0158AA4F5488D08F38514F1FDF4B4F40D2181B3681C364BA0273C706&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect571k1
+     */
+    static X9ECParametersHolder sect571k1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 571;
+            int k1 = 2;
+            int k2 = 5;
+            int k3 = 10;
+
+            BigInteger a = ECConstants.ZERO;
+            BigInteger b = BigInteger.valueOf(1);
+            byte[] S = null;
+            BigInteger n = fromHex(&quot;020000000000000000000000000000000000000000000000000000000000000000000000131850E1F19A63E4B391A8DB917F4138B630D84BE5D639381E91DEB45CFE778F637C1001&quot;);
+            BigInteger h = BigInteger.valueOf(4);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;02&quot;
+            //+ &quot;026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972&quot;
+                + &quot;0349DC807F4FBF374F4AEADE3BCA95314DD58CEC9F307A54FFC61EFC006D8A2C9D4979C0AC44AEA74FBEBBB9F772AEDCB620B01A7BA7AF1B320430C8591984F601CD4C143EF1C7A3&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+    /*
+     * sect571r1
+     */
+    static X9ECParametersHolder sect571r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            int m = 571;
+            int k1 = 2;
+            int k2 = 5;
+            int k3 = 10;
+
+            BigInteger a = BigInteger.valueOf(1);
+            BigInteger b = fromHex(&quot;02F40E7E2221F295DE297117B7F3D62F5C6A97FFCB8CEFF1CD6BA8CE4A9A18AD84FFABBD8EFA59332BE7AD6756A66E294AFD185A78FF12AA520E4DE739BACA0C7FFEFF7F2955727A&quot;);
+            byte[] S = Hex.decode(&quot;2AA058F73A0E33AB486B0F610410C53A7F132310&quot;);
+            BigInteger n = fromHex(&quot;03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE661CE18FF55987308059B186823851EC7DD9CA1161DE93D5174D66E8382E9BB2FE84E47&quot;);
+            BigInteger h = BigInteger.valueOf(2);
+
+            ECCurve curve = new ECCurve.F2m(m, k1, k2, k3, a, b, n, h);
+            //ECPoint G = curve.decodePoint(Hex.decode(&quot;03&quot;
+            //+ &quot;0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4C850D927E1E7769C8EEC2D19&quot;));
+            ECPoint G = curve.decodePoint(Hex.decode(&quot;04&quot;
+                + &quot;0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4C850D927E1E7769C8EEC2D19&quot;
+                + &quot;037BF27342DA639B6DCCFFFEB73D69D78C6C27A6009CBBCA1980F8533921E8A684423E43BAB08A576291AF8F461BB2A8B3531D2F0485C19B16E2F1516E23DD3C1A4827AF1B8AC15B&quot;));
+
+            return new X9ECParameters(curve, G, n, h, S);
+        }
+    };
+
+
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable curves = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid, X9ECParametersHolder holder)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+        curves.put(oid, holder);
+    }
+
+    static
+    {
+        defineCurve(&quot;secp112r1&quot;, SECObjectIdentifiers.secp112r1, secp112r1);
+        defineCurve(&quot;secp112r2&quot;, SECObjectIdentifiers.secp112r2, secp112r2);
+        defineCurve(&quot;secp128r1&quot;, SECObjectIdentifiers.secp128r1, secp128r1);
+        defineCurve(&quot;secp128r2&quot;, SECObjectIdentifiers.secp128r2, secp128r2);
+        defineCurve(&quot;secp160k1&quot;, SECObjectIdentifiers.secp160k1, secp160k1);
+        defineCurve(&quot;secp160r1&quot;, SECObjectIdentifiers.secp160r1, secp160r1);
+        defineCurve(&quot;secp160r2&quot;, SECObjectIdentifiers.secp160r2, secp160r2);
+        defineCurve(&quot;secp192k1&quot;, SECObjectIdentifiers.secp192k1, secp192k1);
+        defineCurve(&quot;secp192r1&quot;, SECObjectIdentifiers.secp192r1, secp192r1);
+        defineCurve(&quot;secp224k1&quot;, SECObjectIdentifiers.secp224k1, secp224k1);
+        defineCurve(&quot;secp224r1&quot;, SECObjectIdentifiers.secp224r1, secp224r1); 
+        defineCurve(&quot;secp256k1&quot;, SECObjectIdentifiers.secp256k1, secp256k1);
+        defineCurve(&quot;secp256r1&quot;, SECObjectIdentifiers.secp256r1, secp256r1); 
+        defineCurve(&quot;secp384r1&quot;, SECObjectIdentifiers.secp384r1, secp384r1); 
+        defineCurve(&quot;secp521r1&quot;, SECObjectIdentifiers.secp521r1, secp521r1); 
+
+        defineCurve(&quot;sect113r1&quot;, SECObjectIdentifiers.sect113r1, sect113r1);
+        defineCurve(&quot;sect113r2&quot;, SECObjectIdentifiers.sect113r2, sect113r2);
+        defineCurve(&quot;sect131r1&quot;, SECObjectIdentifiers.sect131r1, sect131r1);
+        defineCurve(&quot;sect131r2&quot;, SECObjectIdentifiers.sect131r2, sect131r2);
+        defineCurve(&quot;sect163k1&quot;, SECObjectIdentifiers.sect163k1, sect163k1);
+        defineCurve(&quot;sect163r1&quot;, SECObjectIdentifiers.sect163r1, sect163r1);
+        defineCurve(&quot;sect163r2&quot;, SECObjectIdentifiers.sect163r2, sect163r2);
+        defineCurve(&quot;sect193r1&quot;, SECObjectIdentifiers.sect193r1, sect193r1);
+        defineCurve(&quot;sect193r2&quot;, SECObjectIdentifiers.sect193r2, sect193r2);
+        defineCurve(&quot;sect233k1&quot;, SECObjectIdentifiers.sect233k1, sect233k1);
+        defineCurve(&quot;sect233r1&quot;, SECObjectIdentifiers.sect233r1, sect233r1);
+        defineCurve(&quot;sect239k1&quot;, SECObjectIdentifiers.sect239k1, sect239k1);
+        defineCurve(&quot;sect283k1&quot;, SECObjectIdentifiers.sect283k1, sect283k1);
+        defineCurve(&quot;sect283r1&quot;, SECObjectIdentifiers.sect283r1, sect283r1);
+        defineCurve(&quot;sect409k1&quot;, SECObjectIdentifiers.sect409k1, sect409k1);
+        defineCurve(&quot;sect409r1&quot;, SECObjectIdentifiers.sect409r1, sect409r1);
+        defineCurve(&quot;sect571k1&quot;, SECObjectIdentifiers.sect571k1, sect571k1);
+        defineCurve(&quot;sect571r1&quot;, SECObjectIdentifiers.sect571r1, sect571r1); 
+    }
+
+    public static X9ECParameters getByName(
+        String name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier oid)
+    {
+        X9ECParametersHolder holder = (X9ECParametersHolder)curves.get(oid);
+
+        if (holder != null)
+        {
+            return holder.getParameters();
+        }
+
+        return null;
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/sec/SECObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,50 @@
+package org.bouncycastle.asn1.sec;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
+
+public interface SECObjectIdentifiers
+{
+    /**
+     *  ellipticCurve OBJECT IDENTIFIER ::= {
+     *        iso(1) identified-organization(3) certicom(132) curve(0)
+     *  }
+     */
+    static final ASN1ObjectIdentifier ellipticCurve = new ASN1ObjectIdentifier(&quot;1.3.132.0&quot;);
+
+    static final ASN1ObjectIdentifier sect163k1 = ellipticCurve.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier sect163r1 = ellipticCurve.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier sect239k1 = ellipticCurve.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier sect113r1 = ellipticCurve.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier sect113r2 = ellipticCurve.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier secp112r1 = ellipticCurve.branch(&quot;6&quot;);
+    static final ASN1ObjectIdentifier secp112r2 = ellipticCurve.branch(&quot;7&quot;);
+    static final ASN1ObjectIdentifier secp160r1 = ellipticCurve.branch(&quot;8&quot;);
+    static final ASN1ObjectIdentifier secp160k1 = ellipticCurve.branch(&quot;9&quot;);
+    static final ASN1ObjectIdentifier secp256k1 = ellipticCurve.branch(&quot;10&quot;);
+    static final ASN1ObjectIdentifier sect163r2 = ellipticCurve.branch(&quot;15&quot;);
+    static final ASN1ObjectIdentifier sect283k1 = ellipticCurve.branch(&quot;16&quot;);
+    static final ASN1ObjectIdentifier sect283r1 = ellipticCurve.branch(&quot;17&quot;);
+    static final ASN1ObjectIdentifier sect131r1 = ellipticCurve.branch(&quot;22&quot;);
+    static final ASN1ObjectIdentifier sect131r2 = ellipticCurve.branch(&quot;23&quot;);
+    static final ASN1ObjectIdentifier sect193r1 = ellipticCurve.branch(&quot;24&quot;);
+    static final ASN1ObjectIdentifier sect193r2 = ellipticCurve.branch(&quot;25&quot;);
+    static final ASN1ObjectIdentifier sect233k1 = ellipticCurve.branch(&quot;26&quot;);
+    static final ASN1ObjectIdentifier sect233r1 = ellipticCurve.branch(&quot;27&quot;);
+    static final ASN1ObjectIdentifier secp128r1 = ellipticCurve.branch(&quot;28&quot;);
+    static final ASN1ObjectIdentifier secp128r2 = ellipticCurve.branch(&quot;29&quot;);
+    static final ASN1ObjectIdentifier secp160r2 = ellipticCurve.branch(&quot;30&quot;);
+    static final ASN1ObjectIdentifier secp192k1 = ellipticCurve.branch(&quot;31&quot;);
+    static final ASN1ObjectIdentifier secp224k1 = ellipticCurve.branch(&quot;32&quot;);
+    static final ASN1ObjectIdentifier secp224r1 = ellipticCurve.branch(&quot;33&quot;);
+    static final ASN1ObjectIdentifier secp384r1 = ellipticCurve.branch(&quot;34&quot;);
+    static final ASN1ObjectIdentifier secp521r1 = ellipticCurve.branch(&quot;35&quot;);
+    static final ASN1ObjectIdentifier sect409k1 = ellipticCurve.branch(&quot;36&quot;);
+    static final ASN1ObjectIdentifier sect409r1 = ellipticCurve.branch(&quot;37&quot;);
+    static final ASN1ObjectIdentifier sect571k1 = ellipticCurve.branch(&quot;38&quot;);
+    static final ASN1ObjectIdentifier sect571r1 = ellipticCurve.branch(&quot;39&quot;);
+
+    static final ASN1ObjectIdentifier secp192r1 = X9ObjectIdentifiers.prime192v1;
+    static final ASN1ObjectIdentifier secp256r1 = X9ObjectIdentifiers.prime256v1;
+
+}

Added: trunk/src/org/bouncycastle/asn1/sec/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/sec/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/sec/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Classes for support of the SEC standard for Elliptic Curve.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$10.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$11.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$12.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$13.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$14.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$2.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$3.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$4.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$5.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$6.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$7.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$8.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves$9.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTNamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,351 @@
+package org.bouncycastle.asn1.teletrust;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.asn1.x9.X9ECParametersHolder;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+/**
+ * elliptic curves defined in &quot;ECC Brainpool Standard Curves and Curve Generation&quot;
+ * <A HREF="http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt">http://www.ecc-brainpool.org/download/draft_pkix_additional_ecc_dp.txt</A>
+ */
+public class TeleTrusTNamedCurves
+{
+    static X9ECParametersHolder brainpoolP160r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger(&quot;E95E4A5F737059DC60DFC7AD95B3D8139515620F&quot;, 16), // q
+                new BigInteger(&quot;340E7BE2A280EB74E2BE61BADA745D97E8F7C300&quot;, 16), // a
+                new BigInteger(&quot;1E589A8595423412134FAA2DBDEC95C8D8675E58&quot;, 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;04BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC31667CB477A1A8EC338F94741669C976316DA6321&quot;)), // G
+                new BigInteger(&quot;E95E4A5F737059DC60DF5991D45029409E60FC09&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP160t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //   new BigInteger(&quot;24DBFF5DEC9B986BBFE5295A29BFBAE45E0F5D0B&quot;, 16), // Z
+                new BigInteger(&quot;E95E4A5F737059DC60DFC7AD95B3D8139515620F&quot;, 16), // q
+                new BigInteger(&quot;E95E4A5F737059DC60DFC7AD95B3D8139515620C&quot;, 16), // a'
+                new BigInteger(&quot;7A556B6DAE535B7B51ED2C4D7DAA7A0B5C55F380&quot;, 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;04B199B13B9B34EFC1397E64BAEB05ACC265FF2378ADD6718B7C7C1961F0991B842443772152C9E0AD&quot;)), // G
+                new BigInteger(&quot;E95E4A5F737059DC60DF5991D45029409E60FC09&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP192r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger(&quot;C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297&quot;, 16), // q
+                new BigInteger(&quot;6A91174076B1E0E19C39C031FE8685C1CAE040E5C69A28EF&quot;, 16), // a
+                new BigInteger(&quot;469A28EF7C28CCA3DC721D044F4496BCCA7EF4146FBF25C9&quot;, 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;04C0A0647EAAB6A48753B033C56CB0F0900A2F5C4853375FD614B690866ABD5BB88B5F4828C1490002E6773FA2FA299B8F&quot;)), // G
+                new BigInteger(&quot;C302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP192t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger(&quot;1B6F5CC8DB4DC7AF19458A9CB80DC2295E5EB9C3732104CB&quot;) //Z
+                new BigInteger(&quot;C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86297&quot;, 16), // q
+                new BigInteger(&quot;C302F41D932A36CDA7A3463093D18DB78FCE476DE1A86294&quot;, 16), // a'
+                new BigInteger(&quot;13D56FFAEC78681E68F9DEB43B35BEC2FB68542E27897B79&quot;, 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;043AE9E58C82F63C30282E1FE7BBF43FA72C446AF6F4618129097E2C5667C2223A902AB5CA449D0084B7E5B3DE7CCC01C9&quot;)), // G'
+                new BigInteger(&quot;C302F41D932A36CDA7A3462F9E9E916B5BE8F1029AC4ACC1&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+
+    static X9ECParametersHolder brainpoolP224r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger(&quot;D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF&quot;, 16), // q
+                new BigInteger(&quot;68A5E62CA9CE6C1C299803A6C1530B514E182AD8B0042A59CAD29F43&quot;, 16), // a
+                new BigInteger(&quot;2580F63CCFE44138870713B1A92369E33E2135D266DBB372386C400B&quot;, 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;040D9029AD2C7E5CF4340823B2A87DC68C9E4CE3174C1E6EFDEE12C07D58AA56F772C0726F24C6B89E4ECDAC24354B9E99CAA3F6D3761402CD&quot;)), // G
+                new BigInteger(&quot;D7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // n
+        }
+    };
+    static X9ECParametersHolder brainpoolP224t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger(&quot;2DF271E14427A346910CF7A2E6CFA7B3F484E5C2CCE1C8B730E28B3F&quot;) //Z
+                new BigInteger(&quot;D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FF&quot;, 16), // q
+                new BigInteger(&quot;D7C134AA264366862A18302575D1D787B09F075797DA89F57EC8C0FC&quot;, 16), // a'
+                new BigInteger(&quot;4B337D934104CD7BEF271BF60CED1ED20DA14C08B3BB64F18A60888D&quot;, 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;046AB1E344CE25FF3896424E7FFE14762ECB49F8928AC0C76029B4D5800374E9F5143E568CD23F3F4D7C0D4B1E41C8CC0D1C6ABD5F1A46DB4C&quot;)), // G'
+                new BigInteger(&quot;D7C134AA264366862A18302575D0FB98D116BC4B6DDEBCA3A5A7939F&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP256r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger(&quot;A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377&quot;, 16), // q
+                new BigInteger(&quot;7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9&quot;, 16), // a
+                new BigInteger(&quot;26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6&quot;, 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;048BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997&quot;)), // G
+                new BigInteger(&quot;A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP256t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger(&quot;3E2D4BD9597B58639AE7AA669CAB9837CF5CF20A2C852D10F655668DFC150EF0&quot;) //Z
+                new BigInteger(&quot;A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377&quot;, 16), // q
+                new BigInteger(&quot;A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5374&quot;, 16), // a'
+                new BigInteger(&quot;662C61C430D84EA4FE66A7733D0B76B7BF93EBC4AF2F49256AE58101FEE92B04&quot;, 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;04A3E8EB3CC1CFE7B7732213B23A656149AFA142C47AAFBC2B79A191562E1305F42D996C823439C56D7F7B22E14644417E69BCB6DE39D027001DABE8F35B25C9BE&quot;)), // G'
+                new BigInteger(&quot;A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP320r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger(&quot;D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27&quot;, 16), // q
+                new BigInteger(&quot;3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F492F375A97D860EB4&quot;, 16), // a
+                new BigInteger(&quot;520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD884539816F5EB4AC8FB1F1A6&quot;, 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;0443BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C710AF8D0D39E2061114FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7D35245D1692E8EE1&quot;)), // G
+                new BigInteger(&quot;D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP320t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger(&quot;15F75CAF668077F7E85B42EB01F0A81FF56ECD6191D55CB82B7D861458A18FEFC3E5AB7496F3C7B1&quot;) //Z
+                new BigInteger(&quot;D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27&quot;, 16), // q
+                new BigInteger(&quot;D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E24&quot;, 16), // a'
+                new BigInteger(&quot;A7F561E038EB1ED560B3D147DB782013064C19F27ED27C6780AAF77FB8A547CEB5B4FEF422340353&quot;, 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;04925BE9FB01AFC6FB4D3E7D4990010F813408AB106C4F09CB7EE07868CC136FFF3357F624A21BED5263BA3A7A27483EBF6671DBEF7ABB30EBEE084E58A0B077AD42A5A0989D1EE71B1B9BC0455FB0D2C3&quot;)), // G'
+                new BigInteger(&quot;D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP384r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger(&quot;8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53&quot;, 16), // q
+                new BigInteger(&quot;7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22CE2826&quot;, 16), // a
+                new BigInteger(&quot;4A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62D57CB4390295DBC9943AB78696FA504C11&quot;, 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;041D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315&quot;)), // G
+                new BigInteger(&quot;8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP384t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger(&quot;41DFE8DD399331F7166A66076734A89CD0D2BCDB7D068E44E1F378F41ECBAE97D2D63DBC87BCCDDCCC5DA39E8589291C&quot;) //Z
+                new BigInteger(&quot;8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53&quot;, 16), // q
+                new BigInteger(&quot;8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC50&quot;, 16), // a'
+                new BigInteger(&quot;7F519EADA7BDA81BD826DBA647910F8C4B9346ED8CCDC64E4B1ABD11756DCE1D2074AA263B88805CED70355A33B471EE&quot;, 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;0418DE98B02DB9A306F2AFCD7235F72A819B80AB12EBD653172476FECD462AABFFC4FF191B946A5F54D8D0AA2F418808CC25AB056962D30651A114AFD2755AD336747F93475B7A1FCA3B88F2B6A208CCFE469408584DC2B2912675BF5B9E582928&quot;)), // G'
+                new BigInteger(&quot;8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP512r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                new BigInteger(&quot;AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3&quot;, 16), // q
+                new BigInteger(&quot;7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA&quot;, 16), // a
+                new BigInteger(&quot;3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723&quot;, 16)); // b
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;0481AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F8227DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892&quot;)), // G
+                new BigInteger(&quot;AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+    static X9ECParametersHolder brainpoolP512t1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve curve = new ECCurve.Fp(
+                //new BigInteger(&quot;12EE58E6764838B69782136F0F2D3BA06E27695716054092E60A80BEDB212B64E585D90BCE13761F85C3F1D2A64E3BE8FEA2220F01EBA5EEB0F35DBD29D922AB&quot;) //Z
+                new BigInteger(&quot;AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3&quot;, 16), // q
+                new BigInteger(&quot;AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F0&quot;, 16), // a'
+                new BigInteger(&quot;7CBBBCF9441CFAB76E1890E46884EAE321F70C0BCB4981527897504BEC3E36A62BCDFA2304976540F6450085F2DAE145C22553B465763689180EA2571867423E&quot;, 16)); // b'
+
+            return new X9ECParameters(
+                curve,
+                curve.decodePoint(Hex.decode(&quot;04640ECE5C12788717B9C1BA06CBC2A6FEBA85842458C56DDE9DB1758D39C0313D82BA51735CDB3EA499AA77A7D6943A64F7A3F25FE26F06B51BAA2696FA9035DA5B534BD595F5AF0FA2C892376C84ACE1BB4E3019B71634C01131159CAE03CEE9D9932184BEEF216BD71DF2DADF86A627306ECFF96DBB8BACE198B61E00F8B332&quot;)), // G'
+                new BigInteger(&quot;AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069&quot;, 16), //n
+                new BigInteger(&quot;01&quot;, 16)); // h
+        }
+    };
+
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable curves = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid, X9ECParametersHolder holder)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+        curves.put(oid, holder);
+    }
+
+    static
+    {
+        defineCurve(&quot;brainpoolp160r1&quot;, TeleTrusTObjectIdentifiers.brainpoolP160r1, brainpoolP160r1);
+        defineCurve(&quot;brainpoolp160t1&quot;, TeleTrusTObjectIdentifiers.brainpoolP160t1, brainpoolP160t1);
+        defineCurve(&quot;brainpoolp192r1&quot;, TeleTrusTObjectIdentifiers.brainpoolP192r1, brainpoolP192r1);
+        defineCurve(&quot;brainpoolp192t1&quot;, TeleTrusTObjectIdentifiers.brainpoolP192t1, brainpoolP192t1);
+        defineCurve(&quot;brainpoolp224r1&quot;, TeleTrusTObjectIdentifiers.brainpoolP224r1, brainpoolP224r1);
+        defineCurve(&quot;brainpoolp224t1&quot;, TeleTrusTObjectIdentifiers.brainpoolP224t1, brainpoolP224t1);
+        defineCurve(&quot;brainpoolp256r1&quot;, TeleTrusTObjectIdentifiers.brainpoolP256r1, brainpoolP256r1);
+        defineCurve(&quot;brainpoolp256t1&quot;, TeleTrusTObjectIdentifiers.brainpoolP256t1, brainpoolP256t1);
+        defineCurve(&quot;brainpoolp320r1&quot;, TeleTrusTObjectIdentifiers.brainpoolP320r1, brainpoolP320r1);
+        defineCurve(&quot;brainpoolp320t1&quot;, TeleTrusTObjectIdentifiers.brainpoolP320t1, brainpoolP320t1);
+        defineCurve(&quot;brainpoolp384r1&quot;, TeleTrusTObjectIdentifiers.brainpoolP384r1, brainpoolP384r1);
+        defineCurve(&quot;brainpoolp384t1&quot;, TeleTrusTObjectIdentifiers.brainpoolP384t1, brainpoolP384t1);
+        defineCurve(&quot;brainpoolp512r1&quot;, TeleTrusTObjectIdentifiers.brainpoolP512r1, brainpoolP512r1);
+        defineCurve(&quot;brainpoolp512t1&quot;, TeleTrusTObjectIdentifiers.brainpoolP512t1, brainpoolP512t1);
+    }
+
+    public static X9ECParameters getByName(
+        String name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier oid)
+    {
+        X9ECParametersHolder holder = (X9ECParametersHolder)curves.get(oid);
+
+        if (holder != null)
+        {
+            return holder.getParameters();
+        }
+
+        return null;
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+
+    public static DERObjectIdentifier getOID(short curvesize, boolean twisted)
+    {
+        return getOID(&quot;brainpoolP&quot; + curvesize + (twisted ? &quot;t&quot; : &quot;r&quot;) + &quot;1&quot;);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/teletrust/TeleTrusTObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,42 @@
+package org.bouncycastle.asn1.teletrust;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface TeleTrusTObjectIdentifiers
+{
+    static final ASN1ObjectIdentifier teleTrusTAlgorithm = new ASN1ObjectIdentifier(&quot;1.3.36.3&quot;);
+
+    static final ASN1ObjectIdentifier    ripemd160           = teleTrusTAlgorithm.branch(&quot;2.1&quot;);
+    static final ASN1ObjectIdentifier    ripemd128           = teleTrusTAlgorithm.branch(&quot;2.2&quot;);
+    static final ASN1ObjectIdentifier    ripemd256           = teleTrusTAlgorithm.branch(&quot;2.3&quot;);
+
+    static final ASN1ObjectIdentifier teleTrusTRSAsignatureAlgorithm = teleTrusTAlgorithm.branch(&quot;3.1&quot;);
+
+    static final ASN1ObjectIdentifier    rsaSignatureWithripemd160           = teleTrusTRSAsignatureAlgorithm.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier    rsaSignatureWithripemd128           = teleTrusTRSAsignatureAlgorithm.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier    rsaSignatureWithripemd256           = teleTrusTRSAsignatureAlgorithm.branch(&quot;4&quot;);
+
+    static final ASN1ObjectIdentifier    ecSign = teleTrusTAlgorithm.branch(&quot;3.2&quot;);
+
+    static final ASN1ObjectIdentifier    ecSignWithSha1  = ecSign.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier    ecSignWithRipemd160  = ecSign.branch(&quot;2&quot;);
+
+    static final ASN1ObjectIdentifier ecc_brainpool = teleTrusTAlgorithm.branch(&quot;3.2.8&quot;);
+    static final ASN1ObjectIdentifier ellipticCurve = ecc_brainpool.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier versionOne = ellipticCurve.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier brainpoolP160r1 = versionOne.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier brainpoolP160t1 = versionOne.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier brainpoolP192r1 = versionOne.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier brainpoolP192t1 = versionOne.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier brainpoolP224r1 = versionOne.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier brainpoolP224t1 = versionOne.branch(&quot;6&quot;);
+    static final ASN1ObjectIdentifier brainpoolP256r1 = versionOne.branch(&quot;7&quot;);
+    static final ASN1ObjectIdentifier brainpoolP256t1 = versionOne.branch(&quot;8&quot;);
+    static final ASN1ObjectIdentifier brainpoolP320r1 = versionOne.branch(&quot;9&quot;);
+    static final ASN1ObjectIdentifier brainpoolP320t1 = versionOne.branch(&quot;10&quot;);
+    static final ASN1ObjectIdentifier brainpoolP384r1 = versionOne.branch(&quot;11&quot;);
+    static final ASN1ObjectIdentifier brainpoolP384t1 = versionOne.branch(&quot;12&quot;);
+    static final ASN1ObjectIdentifier brainpoolP512r1 = versionOne.branch(&quot;13&quot;);
+    static final ASN1ObjectIdentifier brainpoolP512t1 = versionOne.branch(&quot;14&quot;);
+}

Added: trunk/src/org/bouncycastle/asn1/teletrust/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/teletrust/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/teletrust/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Support classes for TeleTrust related objects.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/AttributeTypeAndValue.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,71 @@
+package org.bouncycastle.asn1.x500;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class AttributeTypeAndValue
+    extends ASN1Encodable
+{
+    private ASN1ObjectIdentifier type;
+    private ASN1Encodable       value;
+
+    private AttributeTypeAndValue(ASN1Sequence seq)
+    {
+        type = (ASN1ObjectIdentifier)seq.getObjectAt(0);
+        value = (ASN1Encodable)seq.getObjectAt(1);
+    }
+
+    public static AttributeTypeAndValue getInstance(Object o)
+    {
+        if (o instanceof AttributeTypeAndValue)
+        {
+            return (AttributeTypeAndValue)o;
+        }
+        else if (o != null)
+        {
+            return new AttributeTypeAndValue(ASN1Sequence.getInstance(o));
+        }
+
+        throw new IllegalArgumentException(&quot;null value in getInstance()&quot;);
+    }
+
+    public AttributeTypeAndValue(
+        ASN1ObjectIdentifier type,
+        ASN1Encodable value)
+    {
+        this.type = type;
+        this.value = value;
+    }
+
+    public ASN1ObjectIdentifier getType()
+    {
+        return type;
+    }
+
+    public ASN1Encodable getValue()
+    {
+        return value;
+    }
+
+    /**
+     * &lt;pre&gt;
+     * AttributeTypeAndValue ::= SEQUENCE {
+     *           type         OBJECT IDENTIFIER,
+     *           value        ANY DEFINED BY type }
+     * &lt;/pre&gt;
+     * @return a basic ASN.1 object representation.
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(type);
+        v.add(value);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/RDN.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/RDN.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/RDN.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/RDN.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/RDN.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,106 @@
+package org.bouncycastle.asn1.x500;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Set;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.DERSet;
+
+public class RDN
+    extends ASN1Encodable
+{
+    private ASN1Set values;
+
+    private RDN(ASN1Set values)
+    {
+        this.values = values;
+    }
+
+    public static RDN getInstance(Object obj)
+    {
+        if (obj instanceof RDN)
+        {
+            return (RDN)obj;
+        }
+        else if (obj != null)
+        {
+            return new RDN(ASN1Set.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    /**
+     * Create a single valued RDN.
+     *
+     * @param oid
+     * @param value
+     */
+    public RDN(ASN1ObjectIdentifier oid, ASN1Encodable value)
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(oid);
+        v.add(value);
+
+        this.values = new DERSet(new DERSequence(v));
+    }
+
+    public RDN(AttributeTypeAndValue attrTAndV)
+    {
+        this.values = new DERSet(attrTAndV);
+    }
+
+    /**
+     * Create a multi-valued RDN.
+     */
+    public RDN(AttributeTypeAndValue[] aAndVs)
+    {
+        this.values = new DERSet(aAndVs);
+    }
+
+    public boolean isMultiValued()
+    {
+        return this.values.size() &gt; 1;
+    }
+
+    public AttributeTypeAndValue getFirst()
+    {
+        if (this.values.size() == 0)
+        {
+            return null;
+        }
+
+        return AttributeTypeAndValue.getInstance(this.values.getObjectAt(0));
+    }
+
+    public AttributeTypeAndValue[] getTypesAndValues()
+    {
+        AttributeTypeAndValue[] tmp = new AttributeTypeAndValue[values.size()];
+
+        for (int i = 0; i != tmp.length; i++)
+        {
+            tmp[i] = AttributeTypeAndValue.getInstance(values.getObjectAt(i));
+        }
+
+        return tmp;
+    }
+
+    /**
+     * &lt;pre&gt;
+     * RelativeDistinguishedName ::=
+     *                     SET OF AttributeTypeAndValue
+
+     * AttributeTypeAndValue ::= SEQUENCE {
+     *        type     AttributeType,
+     *        value    AttributeValue }
+     * &lt;/pre&gt;
+     * @return
+     */
+    public DERObject toASN1Object()
+    {
+        return values;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/X500Name.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/X500Name.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/X500Name.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/X500Name.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/X500Name.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,274 @@
+package org.bouncycastle.asn1.x500;
+
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Choice;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.x500.style.BCStyle;
+import org.bouncycastle.asn1.x509.X509Name;
+
+/**
+ * &lt;pre&gt;
+ *     Name ::= CHOICE {
+ *                       RDNSequence }
+ *
+ *     RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
+ *
+ *     RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
+ *
+ *     AttributeTypeAndValue ::= SEQUENCE {
+ *                                   type  OBJECT IDENTIFIER,
+ *                                   value ANY }
+ * &lt;/pre&gt;
+ */
+public class X500Name
+    extends ASN1Encodable
+    implements ASN1Choice
+{
+    private static X500NameStyle    defaultStyle = BCStyle.INSTANCE;
+
+    private boolean                 isHashCodeCalculated;
+    private int                     hashCodeValue;
+
+    private X500NameStyle style;
+    private RDN[] rdns;
+
+//    public X500Name(X500NameStyle style, X500Name name)
+//    {
+//        this.rdns = name.rdns;
+//        this.style = style;
+//    }
+
+    /**
+     * Return a X509Name based on the passed in tagged object.
+     *
+     * @param obj tag object holding name.
+     * @param explicit true if explicitly tagged false otherwise.
+     * @return the X509Name
+     */
+    public static X500Name getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        // must be true as choice item
+        return getInstance(ASN1Sequence.getInstance(obj, true));
+    }
+
+    public static X500Name getInstance(
+        Object  obj)
+    {
+        if (obj instanceof X500Name)
+        {
+            return (X500Name)obj;
+        }
+        else if (obj instanceof X509Name)
+        {
+            return new X500Name(ASN1Sequence.getInstance(((X509Name)obj).getDERObject()));
+        }
+        else if (obj != null)
+        {
+            return new X500Name(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    /**
+     * Constructor from ASN1Sequence
+     *
+     * the principal will be a list of constructed sets, each containing an (OID, String) pair.
+     */
+    private X500Name(
+        ASN1Sequence  seq)
+    {
+        this(defaultStyle, seq);
+    }
+
+    private X500Name(
+        X500NameStyle style,
+        ASN1Sequence  seq)
+    {
+        this.style = style;
+        this.rdns = new RDN[seq.size()];
+
+        int index = 0;
+
+        for (Enumeration e = seq.getObjects(); e.hasMoreElements();)
+        {
+            rdns[index++] = RDN.getInstance(e.nextElement());
+        }
+    }
+
+    public X500Name(
+        RDN[] rDNs)
+    {
+        this(defaultStyle, rDNs);
+    }
+
+    public X500Name(
+        X500NameStyle style,
+        RDN[]         rDNs)
+    {
+        this.rdns = rDNs;
+        this.style = style;
+    }
+
+    public X500Name(
+        String dirName)
+    {
+        this(defaultStyle, dirName);
+    }
+
+    public X500Name(
+        X500NameStyle style,
+        String        dirName)
+    {
+        this(style.fromString(dirName));
+
+        this.style = style;
+    }
+
+    /**
+     * return an array of RDNs in structure order.
+     *
+     * @return an array of RDN objects.
+     */
+    public RDN[] getRDNs()
+    {
+        RDN[] tmp = new RDN[this.rdns.length];
+
+        System.arraycopy(rdns, 0, tmp, 0, tmp.length);
+
+        return tmp;
+    }
+
+    /**
+     * return an array of RDNs containing the attribute type given by OID in structure order.
+     *
+     * @param oid the type OID we are looking for.
+     * @return an array, possibly zero length, of RDN objects.
+     */
+    public RDN[] getRDNs(ASN1ObjectIdentifier oid)
+    {
+        RDN[] res = new RDN[rdns.length];
+        int   count = 0;
+
+        for (int i = 0; i != rdns.length; i++)
+        {
+            RDN rdn = rdns[i];
+
+            if (rdn.isMultiValued())
+            {
+                AttributeTypeAndValue[] attr = rdn.getTypesAndValues();
+                for (int j = 0; j != attr.length; j++)
+                {
+                    if (attr[j].getType().equals(oid))
+                    {
+                        res[count++] = rdn;
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                if (rdn.getFirst().getType().equals(oid))
+                {
+                    res[count++] = rdn;
+                }
+            }
+        }
+
+        RDN[] tmp = new RDN[count];
+
+        System.arraycopy(res, 0, tmp, 0, tmp.length);
+
+        return tmp;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return new DERSequence(rdns);
+    }
+
+    public int hashCode()
+    {
+        if (isHashCodeCalculated)
+        {
+            return hashCodeValue;
+        }
+
+        isHashCodeCalculated = true;
+
+        hashCodeValue = style.calculateHashCode(this);
+
+        return hashCodeValue;
+    }
+
+    /**
+     * test for equality - note: case is ignored.
+     */
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+
+        if (!(obj instanceof X500Name || obj instanceof ASN1Sequence))
+        {
+            return false;
+        }
+
+        DERObject derO = ((DEREncodable)obj).getDERObject();
+
+        if (this.getDERObject().equals(derO))
+        {
+            return true;
+        }
+
+        try
+        {
+            return style.areEqual(this, new X500Name(ASN1Sequence.getInstance(((DEREncodable)obj).getDERObject())));
+        }
+        catch (Exception e)
+        {
+            return false;
+        }
+    }
+
+    public String toString()
+    {
+        return style.toString(this);
+    }
+
+    /**
+     * Set the default style for X500Name construction.
+     *
+     * @param style  an X500NameStyle
+     */
+    public static void setDefaultStyle(X500NameStyle style)
+    {
+        if (style == null)
+        {
+            throw new NullPointerException(&quot;cannot set style to null&quot;);
+        }
+
+        defaultStyle = style;
+    }
+
+    /**
+     * Return the current default style.
+     *
+     * @return default style for X500Name construction.
+     */
+    public static X500NameStyle getDefaultStyle()
+    {
+        return defaultStyle;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/X500NameBuilder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,81 @@
+package org.bouncycastle.asn1.x500;
+
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public class X500NameBuilder
+{
+    private X500NameStyle template;
+    private Vector rdns = new Vector();
+
+    public X500NameBuilder(X500NameStyle template)
+    {
+        this.template = template;
+    }
+
+    public X500NameBuilder addRDN(ASN1ObjectIdentifier oid, String value)
+    {
+        this.addRDN(oid, template.stringToValue(oid, value));
+
+        return this;
+    }
+
+    public X500NameBuilder addRDN(ASN1ObjectIdentifier oid, ASN1Encodable value)
+    {
+        rdns.addElement(new RDN(oid, value));
+
+        return this;
+    }
+
+    public X500NameBuilder addRDN(AttributeTypeAndValue attrTAndV)
+    {
+        rdns.addElement(new RDN(attrTAndV));
+
+        return this;
+    }
+
+    public X500NameBuilder addMultiValuedRDN(ASN1ObjectIdentifier[] oids, String[] values)
+    {
+        ASN1Encodable[] vals = new ASN1Encodable[values.length];
+
+        for (int i = 0; i != vals.length; i++)
+        {
+            vals[i] = template.stringToValue(oids[i], values[i]);
+        }
+
+        return addMultiValuedRDN(oids, vals);
+    }
+
+    public X500NameBuilder addMultiValuedRDN(ASN1ObjectIdentifier[] oids, ASN1Encodable[] values)
+    {
+        AttributeTypeAndValue[] avs = new AttributeTypeAndValue[oids.length];
+
+        for (int i = 0; i != oids.length; i++)
+        {
+            avs[i] = new AttributeTypeAndValue(oids[i], values[i]);
+        }
+
+        return addMultiValuedRDN(avs);
+    }
+
+    public X500NameBuilder addMultiValuedRDN(AttributeTypeAndValue[] attrTAndVs)
+    {
+        rdns.addElement(new RDN(attrTAndVs));
+
+        return this;
+    }
+
+    public X500Name build()
+    {
+        RDN[] vals = new RDN[rdns.size()];
+
+        for (int i = 0; i != vals.length; i++)
+        {
+            vals[i] = (RDN)rdns.elementAt(i);
+        }
+
+        return new X500Name(template, vals);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/X500NameStyle.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,34 @@
+package org.bouncycastle.asn1.x500;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+/**
+ * It turns out that the number of standard ways the fields in a DN should be 
+ * encoded into their ASN.1 counterparts is rapidly approaching the
+ * number of machines on the internet. By default the X500Name class
+ * will produce UTF8Strings in line with the current recommendations (RFC 3280).
+ * &lt;p&gt;
+ */
+public interface X500NameStyle
+{
+    /**
+     * Convert the passed in String value into the appropriate ASN.1
+     * encoded object.
+     * 
+     * @param oid the oid associated with the value in the DN.
+     * @param value the value of the particular DN component.
+     * @return the ASN.1 equivalent for the value.
+     */
+    ASN1Encodable stringToValue(ASN1ObjectIdentifier oid, String value);
+
+    ASN1ObjectIdentifier attrNameToOID(String attrName);
+
+    boolean areEqual(X500Name name1, X500Name name2);
+
+    RDN[] fromString(String dirName);
+
+    int calculateHashCode(X500Name name);
+
+    String toString(X500Name name);
+}

Added: trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/style/BCStyle.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,544 @@
+package org.bouncycastle.asn1.x500.style;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.DERGeneralizedTime;
+import org.bouncycastle.asn1.DERIA5String;
+import org.bouncycastle.asn1.DERPrintableString;
+import org.bouncycastle.asn1.DERUTF8String;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+import org.bouncycastle.asn1.x500.AttributeTypeAndValue;
+import org.bouncycastle.asn1.x500.RDN;
+import org.bouncycastle.asn1.x500.X500Name;
+import org.bouncycastle.asn1.x500.X500NameStyle;
+import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
+
+public class BCStyle
+    implements X500NameStyle
+{
+    public static final X500NameStyle INSTANCE = new BCStyle();
+
+    /**
+     * country code - StringType(SIZE(2))
+     */
+    public static final ASN1ObjectIdentifier C = new ASN1ObjectIdentifier(&quot;2.5.4.6&quot;);
+
+    /**
+     * organization - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier O = new ASN1ObjectIdentifier(&quot;2.5.4.10&quot;);
+
+    /**
+     * organizational unit name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier OU = new ASN1ObjectIdentifier(&quot;2.5.4.11&quot;);
+
+    /**
+     * Title
+     */
+    public static final ASN1ObjectIdentifier T = new ASN1ObjectIdentifier(&quot;2.5.4.12&quot;);
+
+    /**
+     * common name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier CN = new ASN1ObjectIdentifier(&quot;2.5.4.3&quot;);
+
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier SN = new ASN1ObjectIdentifier(&quot;2.5.4.5&quot;);
+
+    /**
+     * street - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier STREET = new ASN1ObjectIdentifier(&quot;2.5.4.9&quot;);
+
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier SERIALNUMBER = SN;
+
+    /**
+     * locality name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier L = new ASN1ObjectIdentifier(&quot;2.5.4.7&quot;);
+
+    /**
+     * state, or province name - StringType(SIZE(1..64))
+     */
+    public static final ASN1ObjectIdentifier ST = new ASN1ObjectIdentifier(&quot;2.5.4.8&quot;);
+
+    /**
+     * Naming attributes of type X520name
+     */
+    public static final ASN1ObjectIdentifier SURNAME = new ASN1ObjectIdentifier(&quot;2.5.4.4&quot;);
+    public static final ASN1ObjectIdentifier GIVENNAME = new ASN1ObjectIdentifier(&quot;2.5.4.42&quot;);
+    public static final ASN1ObjectIdentifier INITIALS = new ASN1ObjectIdentifier(&quot;2.5.4.43&quot;);
+    public static final ASN1ObjectIdentifier GENERATION = new ASN1ObjectIdentifier(&quot;2.5.4.44&quot;);
+    public static final ASN1ObjectIdentifier UNIQUE_IDENTIFIER = new ASN1ObjectIdentifier(&quot;2.5.4.45&quot;);
+
+    /**
+     * businessCategory - DirectoryString(SIZE(1..128)
+     */
+    public static final ASN1ObjectIdentifier BUSINESS_CATEGORY = new ASN1ObjectIdentifier(
+        &quot;2.5.4.15&quot;);
+
+    /**
+     * postalCode - DirectoryString(SIZE(1..40)
+     */
+    public static final ASN1ObjectIdentifier POSTAL_CODE = new ASN1ObjectIdentifier(
+        &quot;2.5.4.17&quot;);
+
+    /**
+     * dnQualifier - DirectoryString(SIZE(1..64)
+     */
+    public static final ASN1ObjectIdentifier DN_QUALIFIER = new ASN1ObjectIdentifier(
+        &quot;2.5.4.46&quot;);
+
+    /**
+     * RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
+     */
+    public static final ASN1ObjectIdentifier PSEUDONYM = new ASN1ObjectIdentifier(
+        &quot;2.5.4.65&quot;);
+
+
+    /**
+     * RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
+     */
+    public static final ASN1ObjectIdentifier DATE_OF_BIRTH = new ASN1ObjectIdentifier(
+        &quot;1.3.6.1.5.5.7.9.1&quot;);
+
+    /**
+     * RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
+     */
+    public static final ASN1ObjectIdentifier PLACE_OF_BIRTH = new ASN1ObjectIdentifier(
+        &quot;1.3.6.1.5.5.7.9.2&quot;);
+
+    /**
+     * RFC 3039 Gender - PrintableString (SIZE(1)) -- &quot;M&quot;, &quot;F&quot;, &quot;m&quot; or &quot;f&quot;
+     */
+    public static final ASN1ObjectIdentifier GENDER = new ASN1ObjectIdentifier(
+        &quot;1.3.6.1.5.5.7.9.3&quot;);
+
+    /**
+     * RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final ASN1ObjectIdentifier COUNTRY_OF_CITIZENSHIP = new ASN1ObjectIdentifier(
+        &quot;1.3.6.1.5.5.7.9.4&quot;);
+
+    /**
+     * RFC 3039 CountryOfResidence - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final ASN1ObjectIdentifier COUNTRY_OF_RESIDENCE = new ASN1ObjectIdentifier(
+        &quot;1.3.6.1.5.5.7.9.5&quot;);
+
+
+    /**
+     * ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
+     */
+    public static final ASN1ObjectIdentifier NAME_AT_BIRTH = new ASN1ObjectIdentifier(&quot;1.3.36.8.3.14&quot;);
+
+    /**
+     * RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
+     * DirectoryString(SIZE(1..30))
+     */
+    public static final ASN1ObjectIdentifier POSTAL_ADDRESS = new ASN1ObjectIdentifier(&quot;2.5.4.16&quot;);
+
+    /**
+     * RFC 2256 dmdName
+     */
+    public static final ASN1ObjectIdentifier DMD_NAME = new ASN1ObjectIdentifier(&quot;2.5.4.54&quot;);
+
+    /**
+     * id-at-telephoneNumber
+     */
+    public static final ASN1ObjectIdentifier TELEPHONE_NUMBER = X509ObjectIdentifiers.id_at_telephoneNumber;
+
+    /**
+     * id-at-name
+     */
+    public static final ASN1ObjectIdentifier NAME = X509ObjectIdentifiers.id_at_name;
+
+    /**
+     * Email address (RSA PKCS#9 extension) - IA5String.
+     * &lt;p&gt;Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.
+     */
+    public static final ASN1ObjectIdentifier EmailAddress = PKCSObjectIdentifiers.pkcs_9_at_emailAddress;
+
+    /**
+     * more from PKCS#9
+     */
+    public static final ASN1ObjectIdentifier UnstructuredName = PKCSObjectIdentifiers.pkcs_9_at_unstructuredName;
+    public static final ASN1ObjectIdentifier UnstructuredAddress = PKCSObjectIdentifiers.pkcs_9_at_unstructuredAddress;
+
+    /**
+     * email address in Verisign certificates
+     */
+    public static final ASN1ObjectIdentifier E = EmailAddress;
+
+    /*
+    * others...
+    */
+    public static final ASN1ObjectIdentifier DC = new ASN1ObjectIdentifier(&quot;0.9.2342.19200300.100.1.25&quot;);
+
+    /**
+     * LDAP User id.
+     */
+    public static final ASN1ObjectIdentifier UID = new ASN1ObjectIdentifier(&quot;0.9.2342.19200300.100.1.1&quot;);
+
+    /**
+     * default look up table translating OID values into their common symbols following
+     * the convention in RFC 2253 with a few extras
+     */
+    private static final Hashtable DefaultSymbols = new Hashtable();
+
+    /**
+     * look up table translating common symbols into their OIDS.
+     */
+    private static final Hashtable DefaultLookUp = new Hashtable();
+
+    static
+    {
+        DefaultSymbols.put(C, &quot;C&quot;);
+        DefaultSymbols.put(O, &quot;O&quot;);
+        DefaultSymbols.put(T, &quot;T&quot;);
+        DefaultSymbols.put(OU, &quot;OU&quot;);
+        DefaultSymbols.put(CN, &quot;CN&quot;);
+        DefaultSymbols.put(L, &quot;L&quot;);
+        DefaultSymbols.put(ST, &quot;ST&quot;);
+        DefaultSymbols.put(SN, &quot;SERIALNUMBER&quot;);
+        DefaultSymbols.put(EmailAddress, &quot;E&quot;);
+        DefaultSymbols.put(DC, &quot;DC&quot;);
+        DefaultSymbols.put(UID, &quot;UID&quot;);
+        DefaultSymbols.put(STREET, &quot;STREET&quot;);
+        DefaultSymbols.put(SURNAME, &quot;SURNAME&quot;);
+        DefaultSymbols.put(GIVENNAME, &quot;GIVENNAME&quot;);
+        DefaultSymbols.put(INITIALS, &quot;INITIALS&quot;);
+        DefaultSymbols.put(GENERATION, &quot;GENERATION&quot;);
+        DefaultSymbols.put(UnstructuredAddress, &quot;unstructuredAddress&quot;);
+        DefaultSymbols.put(UnstructuredName, &quot;unstructuredName&quot;);
+        DefaultSymbols.put(UNIQUE_IDENTIFIER, &quot;UniqueIdentifier&quot;);
+        DefaultSymbols.put(DN_QUALIFIER, &quot;DN&quot;);
+        DefaultSymbols.put(PSEUDONYM, &quot;Pseudonym&quot;);
+        DefaultSymbols.put(POSTAL_ADDRESS, &quot;PostalAddress&quot;);
+        DefaultSymbols.put(NAME_AT_BIRTH, &quot;NameAtBirth&quot;);
+        DefaultSymbols.put(COUNTRY_OF_CITIZENSHIP, &quot;CountryOfCitizenship&quot;);
+        DefaultSymbols.put(COUNTRY_OF_RESIDENCE, &quot;CountryOfResidence&quot;);
+        DefaultSymbols.put(GENDER, &quot;Gender&quot;);
+        DefaultSymbols.put(PLACE_OF_BIRTH, &quot;PlaceOfBirth&quot;);
+        DefaultSymbols.put(DATE_OF_BIRTH, &quot;DateOfBirth&quot;);
+        DefaultSymbols.put(POSTAL_CODE, &quot;PostalCode&quot;);
+        DefaultSymbols.put(BUSINESS_CATEGORY, &quot;BusinessCategory&quot;);
+        DefaultSymbols.put(TELEPHONE_NUMBER, &quot;TelephoneNumber&quot;);
+        DefaultSymbols.put(NAME, &quot;Name&quot;);
+
+        DefaultLookUp.put(&quot;c&quot;, C);
+        DefaultLookUp.put(&quot;o&quot;, O);
+        DefaultLookUp.put(&quot;t&quot;, T);
+        DefaultLookUp.put(&quot;ou&quot;, OU);
+        DefaultLookUp.put(&quot;cn&quot;, CN);
+        DefaultLookUp.put(&quot;l&quot;, L);
+        DefaultLookUp.put(&quot;st&quot;, ST);
+        DefaultLookUp.put(&quot;sn&quot;, SN);
+        DefaultLookUp.put(&quot;serialnumber&quot;, SN);
+        DefaultLookUp.put(&quot;street&quot;, STREET);
+        DefaultLookUp.put(&quot;emailaddress&quot;, E);
+        DefaultLookUp.put(&quot;dc&quot;, DC);
+        DefaultLookUp.put(&quot;e&quot;, E);
+        DefaultLookUp.put(&quot;uid&quot;, UID);
+        DefaultLookUp.put(&quot;surname&quot;, SURNAME);
+        DefaultLookUp.put(&quot;givenname&quot;, GIVENNAME);
+        DefaultLookUp.put(&quot;initials&quot;, INITIALS);
+        DefaultLookUp.put(&quot;generation&quot;, GENERATION);
+        DefaultLookUp.put(&quot;unstructuredaddress&quot;, UnstructuredAddress);
+        DefaultLookUp.put(&quot;unstructuredname&quot;, UnstructuredName);
+        DefaultLookUp.put(&quot;uniqueidentifier&quot;, UNIQUE_IDENTIFIER);
+        DefaultLookUp.put(&quot;dn&quot;, DN_QUALIFIER);
+        DefaultLookUp.put(&quot;pseudonym&quot;, PSEUDONYM);
+        DefaultLookUp.put(&quot;postaladdress&quot;, POSTAL_ADDRESS);
+        DefaultLookUp.put(&quot;nameofbirth&quot;, NAME_AT_BIRTH);
+        DefaultLookUp.put(&quot;countryofcitizenship&quot;, COUNTRY_OF_CITIZENSHIP);
+        DefaultLookUp.put(&quot;countryofresidence&quot;, COUNTRY_OF_RESIDENCE);
+        DefaultLookUp.put(&quot;gender&quot;, GENDER);
+        DefaultLookUp.put(&quot;placeofbirth&quot;, PLACE_OF_BIRTH);
+        DefaultLookUp.put(&quot;dateofbirth&quot;, DATE_OF_BIRTH);
+        DefaultLookUp.put(&quot;postalcode&quot;, POSTAL_CODE);
+        DefaultLookUp.put(&quot;businesscategory&quot;, BUSINESS_CATEGORY);
+        DefaultLookUp.put(&quot;telephonenumber&quot;, TELEPHONE_NUMBER);
+        DefaultLookUp.put(&quot;name&quot;, NAME);
+    }
+
+    protected BCStyle()
+    {
+
+    }
+    
+    public ASN1Encodable stringToValue(ASN1ObjectIdentifier oid, String value)
+    {
+        if (value.length() != 0 &amp;&amp; value.charAt(0) == '#')
+        {
+            try
+            {
+                return IETFUtils.valueFromHexString(value, 1);
+            }
+            catch (IOException e)
+            {
+                throw new RuntimeException(&quot;can't recode value for oid &quot; + oid.getId());
+            }
+        }
+        else
+        {
+            if (value.length() != 0 &amp;&amp; value.charAt(0) == '\\')
+            {
+                value = value.substring(1);
+            }
+            if (oid.equals(EmailAddress) || oid.equals(DC))
+            {
+                return new DERIA5String(value);
+            }
+            else if (oid.equals(DATE_OF_BIRTH))  // accept time string as well as # (for compatibility)
+            {
+                return new DERGeneralizedTime(value);
+            }
+            else if (oid.equals(C) || oid.equals(SN) || oid.equals(DN_QUALIFIER)
+                || oid.equals(TELEPHONE_NUMBER))
+            {
+                return new DERPrintableString(value);
+            }
+        }
+
+        return new DERUTF8String(value);
+    }
+
+    public ASN1ObjectIdentifier attrNameToOID(String attrName)
+    {
+        return IETFUtils.decodeAttrName(attrName, DefaultLookUp);
+    }
+
+    public boolean areEqual(X500Name name1, X500Name name2)
+    {
+        RDN[] rdns1 = name1.getRDNs();
+        RDN[] rdns2 = name2.getRDNs();
+
+        if (rdns1.length != rdns2.length)
+        {
+            return false;
+        }
+
+        boolean reverse = false;
+
+        if (rdns1[0].getFirst() != null &amp;&amp; rdns2[0].getFirst() != null)
+        {
+            reverse = !rdns1[0].getFirst().getType().equals(rdns2[0].getFirst().getType());  // guess forward
+        }
+
+        for (int i = 0; i != rdns1.length; i++)
+        {
+            if (!foundMatch(reverse, rdns1[i], rdns2))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean foundMatch(boolean reverse, RDN rdn, RDN[] possRDNs)
+    {
+        if (reverse)
+        {
+            for (int i = possRDNs.length - 1; i &gt;= 0; i--)
+            {
+                if (possRDNs[i] != null &amp;&amp; rdnAreEqual(rdn, possRDNs[i]))
+                {
+                    possRDNs[i] = null;
+                    return true;
+                }
+            }
+        }
+        else
+        {
+            for (int i = 0; i != possRDNs.length; i++)
+            {
+                if (possRDNs[i] != null &amp;&amp; rdnAreEqual(rdn, possRDNs[i]))
+                {
+                    possRDNs[i] = null;
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected boolean rdnAreEqual(RDN rdn1, RDN rdn2)
+    {
+        if (rdn1.isMultiValued())
+        {
+            if (rdn2.isMultiValued())
+            {
+                AttributeTypeAndValue[] atvs1 = rdn1.getTypesAndValues();
+                AttributeTypeAndValue[] atvs2 = rdn2.getTypesAndValues();
+
+                if (atvs1.length != atvs2.length)
+                {
+                    return false;
+                }
+
+                for (int i = 0; i != atvs1.length; i++)
+                {
+                    if (!atvAreEqual(atvs1[i], atvs2[i]))
+                    {
+                        return false;
+                    }
+                }
+            }
+            else
+            {
+                return false;
+            }
+        }
+        else
+        {
+            if (!rdn2.isMultiValued())
+            {
+                return atvAreEqual(rdn1.getFirst(), rdn2.getFirst());
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean atvAreEqual(AttributeTypeAndValue atv1, AttributeTypeAndValue atv2)
+    {
+        if (atv1 == atv2)
+        {
+            return true;
+        }
+
+        if (atv1 == null)
+        {
+            return false;
+        }
+
+        if (atv2 == null)
+        {
+            return false;
+        }
+
+        ASN1ObjectIdentifier o1 = atv1.getType();
+        ASN1ObjectIdentifier o2 = atv2.getType();
+
+        if (!o1.equals(o2))
+        {
+            return false;
+        }
+
+        String v1 = IETFUtils.canonicalize(IETFUtils.valueToString(atv1.getValue()));
+        String v2 = IETFUtils.canonicalize(IETFUtils.valueToString(atv2.getValue()));
+
+        if (!v1.equals(v2))
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    public RDN[] fromString(String dirName)
+    {
+        return IETFUtils.rDNsFromString(dirName, this);
+    }
+
+    public int calculateHashCode(X500Name name)
+    {
+        int hashCodeValue = 0;
+        RDN[] rdns = name.getRDNs();
+
+        // this needs to be order independent, like equals
+        for (int i = 0; i != rdns.length; i++)
+        {
+            if (rdns[i].isMultiValued())
+            {
+                AttributeTypeAndValue[] atv = rdns[i].getTypesAndValues();
+
+                for (int j = 0; j != atv.length; j++)
+                {
+                    hashCodeValue ^= atv[j].getType().hashCode();
+                    hashCodeValue ^= calcHashCode(atv[j].getValue());
+                }
+            }
+            else
+            {
+                hashCodeValue ^= rdns[i].getFirst().getType().hashCode();
+                hashCodeValue ^= calcHashCode(rdns[i].getFirst().getValue());
+            }
+        }
+
+        return hashCodeValue;
+    }
+
+    private int calcHashCode(ASN1Encodable enc)
+    {
+        String value = IETFUtils.valueToString(enc);
+
+        value = IETFUtils.canonicalize(value);
+
+        return value.hashCode();
+    }
+
+    public String toString(X500Name name)
+    {
+        StringBuffer buf = new StringBuffer();
+        boolean first = true;
+
+        RDN[] rdns = name.getRDNs();
+
+        for (int i = 0; i &lt; rdns.length; i++)
+        {
+            if (first)
+            {
+                first = false;
+            }
+            else
+            {
+                buf.append(',');
+            }
+
+            if (rdns[i].isMultiValued())
+            {
+                AttributeTypeAndValue[] atv = rdns[i].getTypesAndValues();
+                boolean firstAtv = true;
+
+                for (int j = 0; j != atv.length; j++)
+                {
+                    if (firstAtv)
+                    {
+                        firstAtv = false;
+                    }
+                    else
+                    {
+                        buf.append('+');
+                    }
+                    
+                    IETFUtils.appendTypeAndValue(buf, atv[j], DefaultSymbols);
+                }
+            }
+            else
+            {
+                IETFUtils.appendTypeAndValue(buf, rdns[i].getFirst(), DefaultSymbols);
+            }
+        }
+
+        return buf.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/style/IETFUtils.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,294 @@
+package org.bouncycastle.asn1.x500.style;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1String;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERUniversalString;
+import org.bouncycastle.asn1.x500.AttributeTypeAndValue;
+import org.bouncycastle.asn1.x500.RDN;
+import org.bouncycastle.asn1.x500.X500NameBuilder;
+import org.bouncycastle.asn1.x500.X500NameStyle;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+public class IETFUtils
+{
+    public static RDN[] rDNsFromString(String name, X500NameStyle x500Style)
+    {
+        X500NameTokenizer nTok = new X500NameTokenizer(name);
+        X500NameBuilder builder = new X500NameBuilder(x500Style);
+
+        while (nTok.hasMoreTokens())
+        {
+            String  token = nTok.nextToken();
+            int     index = token.indexOf('=');
+
+            if (index == -1)
+            {
+                throw new IllegalArgumentException(&quot;badly formated directory string&quot;);
+            }
+
+            String               attr = token.substring(0, index);
+            String               value = token.substring(index + 1);
+            ASN1ObjectIdentifier oid = x500Style.attrNameToOID(attr);
+
+            if (value.indexOf('+') &gt; 0)
+            {
+                X500NameTokenizer   vTok = new X500NameTokenizer(value, '+');
+                String  v = vTok.nextToken();
+
+                Vector oids = new Vector();
+                Vector values = new Vector();
+
+                oids.addElement(oid);
+                values.addElement(v);
+
+                while (vTok.hasMoreTokens())
+                {
+                    String  sv = vTok.nextToken();
+                    int     ndx = sv.indexOf('=');
+
+                    String  nm = sv.substring(0, ndx);
+                    String  vl = sv.substring(ndx + 1);
+
+                    oids.addElement(x500Style.attrNameToOID(nm));
+                    values.addElement(vl);
+                }
+
+                builder.addMultiValuedRDN(toOIDArray(oids), toValueArray(values));
+            }
+            else
+            {
+                builder.addRDN(oid, value);
+            }
+        }
+
+        return builder.build().getRDNs();
+    }
+
+    private static String[] toValueArray(Vector values)
+    {
+        String[] tmp = new String[values.size()];
+
+        for (int i = 0; i != tmp.length; i++)
+        {
+            tmp[i] = (String)values.elementAt(i);
+        }
+
+        return tmp;
+    }
+
+    private static ASN1ObjectIdentifier[] toOIDArray(Vector oids)
+    {
+        ASN1ObjectIdentifier[] tmp = new ASN1ObjectIdentifier[oids.size()];
+
+        for (int i = 0; i != tmp.length; i++)
+        {
+            tmp[i] = (ASN1ObjectIdentifier)oids.elementAt(i);
+        }
+
+        return tmp;
+    }
+
+    public static ASN1ObjectIdentifier decodeAttrName(
+        String      name,
+        Hashtable   lookUp)
+    {
+        if (Strings.toUpperCase(name).startsWith(&quot;OID.&quot;))
+        {
+            return new ASN1ObjectIdentifier(name.substring(4));
+        }
+        else if (name.charAt(0) &gt;= '0' &amp;&amp; name.charAt(0) &lt;= '9')
+        {
+            return new ASN1ObjectIdentifier(name);
+        }
+
+        ASN1ObjectIdentifier oid = (ASN1ObjectIdentifier)lookUp.get(Strings.toLowerCase(name));
+        if (oid == null)
+        {
+            throw new IllegalArgumentException(&quot;Unknown object id - &quot; + name + &quot; - passed to distinguished name&quot;);
+        }
+
+        return oid;
+    }
+
+    public static ASN1Encodable valueFromHexString(
+        String  str,
+        int     off)
+        throws IOException
+    {
+        str = Strings.toLowerCase(str);
+        byte[] data = new byte[(str.length() - off) / 2];
+        for (int index = 0; index != data.length; index++)
+        {
+            char left = str.charAt((index * 2) + off);
+            char right = str.charAt((index * 2) + off + 1);
+
+            if (left &lt; 'a')
+            {
+                data[index] = (byte)((left - '0') &lt;&lt; 4);
+            }
+            else
+            {
+                data[index] = (byte)((left - 'a' + 10) &lt;&lt; 4);
+            }
+            if (right &lt; 'a')
+            {
+                data[index] |= (byte)(right - '0');
+            }
+            else
+            {
+                data[index] |= (byte)(right - 'a' + 10);
+            }
+        }
+
+        return ASN1Object.fromByteArray(data);
+    }
+
+    public static void appendTypeAndValue(
+        StringBuffer          buf,
+        AttributeTypeAndValue typeAndValue,
+        Hashtable             oidSymbols)
+    {
+        String  sym = (String)oidSymbols.get(typeAndValue.getType());
+
+        if (sym != null)
+        {
+            buf.append(sym);
+        }
+        else
+        {
+            buf.append(typeAndValue.getType().getId());
+        }
+
+        buf.append('=');
+
+        buf.append(valueToString(typeAndValue.getValue()));
+    }
+
+    public static String valueToString(ASN1Encodable value)
+    {
+        StringBuffer vBuf = new StringBuffer();
+
+        if (value instanceof ASN1String &amp;&amp; !(value instanceof DERUniversalString))
+        {
+            String v = ((ASN1String)value).getString();
+            if (v.length() &gt; 0 &amp;&amp; v.charAt(0) == '#')
+            {
+                vBuf.append(&quot;\\&quot; + v);
+            }
+            else
+            {
+                vBuf.append(v);
+            }
+        }
+        else
+        {
+            vBuf.append(&quot;#&quot; + bytesToString(Hex.encode(value.getDERObject().getDEREncoded())));
+        }
+
+        int     end = vBuf.length();
+        int     index = 0;
+
+        if (vBuf.length() &gt;= 2 &amp;&amp; vBuf.charAt(0) == '\\' &amp;&amp; vBuf.charAt(1) == '#')
+        {
+            index += 2;
+        }
+
+        while (index != end)
+        {
+            if ((vBuf.charAt(index) == ',')
+               || (vBuf.charAt(index) == '&quot;')
+               || (vBuf.charAt(index) == '\\')
+               || (vBuf.charAt(index) == '+')
+               || (vBuf.charAt(index) == '=')
+               || (vBuf.charAt(index) == '&lt;')
+               || (vBuf.charAt(index) == '&gt;')
+               || (vBuf.charAt(index) == ';'))
+            {
+                vBuf.insert(index, &quot;\\&quot;);
+                index++;
+                end++;
+            }
+
+            index++;
+        }
+
+        return vBuf.toString();
+    }
+
+    private static String bytesToString(
+        byte[] data)
+    {
+        char[]  cs = new char[data.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(data[i] &amp; 0xff);
+        }
+
+        return new String(cs);
+    }
+
+    public static String canonicalize(String s)
+    {
+        String value = Strings.toLowerCase(s.trim());
+
+        if (value.length() &gt; 0 &amp;&amp; value.charAt(0) == '#')
+        {
+            DERObject obj = decodeObject(value);
+
+            if (obj instanceof ASN1String)
+            {
+                value = Strings.toLowerCase(((ASN1String)obj).getString().trim());
+            }
+        }
+
+        value = stripInternalSpaces(value);
+
+        return value;
+    }
+
+    private static ASN1Object decodeObject(String oValue)
+    {
+        try
+        {
+            return ASN1Object.fromByteArray(Hex.decode(oValue.substring(1)));
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException(&quot;unknown encoding in name: &quot; + e);
+        }
+    }
+
+    public static String stripInternalSpaces(
+        String str)
+    {
+        StringBuffer res = new StringBuffer();
+
+        if (str.length() != 0)
+        {
+            char c1 = str.charAt(0);
+
+            res.append(c1);
+
+            for (int k = 1; k &lt; str.length(); k++)
+            {
+                char c2 = str.charAt(k);
+                if (!(c1 == ' ' &amp;&amp; c2 == ' '))
+                {
+                    res.append(c2);
+                }
+                c1 = c2;
+            }
+        }
+
+        return res.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x500/style/X500NameTokenizer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,99 @@
+package org.bouncycastle.asn1.x500.style;
+
+/**
+ * class for breaking up an X500 Name into it's component tokens, ala
+ * java.util.StringTokenizer. We need this class as some of the
+ * lightweight Java environment don't support classes like
+ * StringTokenizer.
+ */
+class X500NameTokenizer
+{
+    private String          value;
+    private int             index;
+    private char            seperator;
+    private StringBuffer    buf = new StringBuffer();
+
+    public X500NameTokenizer(
+        String  oid)
+    {
+        this(oid, ',');
+    }
+    
+    public X500NameTokenizer(
+        String  oid,
+        char    seperator)
+    {
+        this.value = oid;
+        this.index = -1;
+        this.seperator = seperator;
+    }
+
+    public boolean hasMoreTokens()
+    {
+        return (index != value.length());
+    }
+
+    public String nextToken()
+    {
+        if (index == value.length())
+        {
+            return null;
+        }
+
+        int     end = index + 1;
+        boolean quoted = false;
+        boolean escaped = false;
+
+        buf.setLength(0);
+
+        while (end != value.length())
+        {
+            char    c = value.charAt(end);
+
+            if (c == '&quot;')
+            {
+                if (!escaped)
+                {
+                    quoted = !quoted;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+                escaped = false;
+            }
+            else
+            {
+                if (escaped || quoted)
+                {
+                    if (c == '#' &amp;&amp; buf.charAt(buf.length() - 1) == '=')
+                    {
+                        buf.append('\\');
+                    }
+                    else if (c == '+' &amp;&amp; seperator != '+')
+                    {
+                        buf.append('\\');
+                    }
+                    buf.append(c);
+                    escaped = false;
+                }
+                else if (c == '\\')
+                {
+                    escaped = true;
+                }
+                else if (c == seperator)
+                {
+                    break;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+            }
+            end++;
+        }
+
+        index = end;
+        return buf.toString().trim();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/AlgorithmIdentifier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,144 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERNull;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+
+public class AlgorithmIdentifier
+    extends ASN1Encodable
+{
+    private DERObjectIdentifier objectId;
+    private DEREncodable        parameters;
+    private boolean             parametersDefined = false;
+
+    public static AlgorithmIdentifier getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+    
+    public static AlgorithmIdentifier getInstance(
+        Object  obj)
+    {
+        if (obj== null || obj instanceof AlgorithmIdentifier)
+        {
+            return (AlgorithmIdentifier)obj;
+        }
+        
+        if (obj instanceof DERObjectIdentifier)
+        {
+            return new AlgorithmIdentifier((DERObjectIdentifier)obj);
+        }
+
+        if (obj instanceof String)
+        {
+            return new AlgorithmIdentifier((String)obj);
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new AlgorithmIdentifier((ASN1Sequence)obj);
+        }
+
+        throw new IllegalArgumentException(&quot;unknown object in factory: &quot; + obj.getClass().getName());
+    }
+
+    public AlgorithmIdentifier(
+        DERObjectIdentifier     objectId)
+    {
+        this.objectId = objectId;
+    }
+
+    public AlgorithmIdentifier(
+        String     objectId)
+    {
+        this.objectId = new DERObjectIdentifier(objectId);
+    }
+
+    public AlgorithmIdentifier(
+        DERObjectIdentifier     objectId,
+        DEREncodable            parameters)
+    {
+        parametersDefined = true;
+        this.objectId = objectId;
+        this.parameters = parameters;
+    }
+
+    public AlgorithmIdentifier(
+        ASN1Sequence   seq)
+    {
+        if (seq.size() &lt; 1 || seq.size() &gt; 2)
+        {
+            throw new IllegalArgumentException(&quot;Bad sequence size: &quot;
+                    + seq.size());
+        }
+        
+        objectId = DERObjectIdentifier.getInstance(seq.getObjectAt(0));
+
+        if (seq.size() == 2)
+        {
+            parametersDefined = true;
+            parameters = seq.getObjectAt(1);
+        }
+        else
+        {
+            parameters = null;
+        }
+    }
+
+    public ASN1ObjectIdentifier getAlgorithm()
+    {
+        return new ASN1ObjectIdentifier(objectId.getId());
+    }
+
+    /**
+     * @deprecated use getAlgorithm
+     * @return
+     */
+    public DERObjectIdentifier getObjectId()
+    {
+        return objectId;
+    }
+
+    public DEREncodable getParameters()
+    {
+        return parameters;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     *      AlgorithmIdentifier ::= SEQUENCE {
+     *                            algorithm OBJECT IDENTIFIER,
+     *                            parameters ANY DEFINED BY algorithm OPTIONAL }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(objectId);
+
+        if (parametersDefined)
+        {
+            if (parameters != null)
+            {
+                v.add(parameters);
+            }
+            else
+            {
+                v.add(DERNull.INSTANCE);
+            }
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/DSAParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/DSAParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,92 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DSAParameter
+    extends ASN1Encodable
+{
+    DERInteger      p, q, g;
+
+    public static DSAParameter getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static DSAParameter getInstance(
+        Object obj)
+    {
+        if(obj == null || obj instanceof DSAParameter) 
+        {
+            return (DSAParameter)obj;
+        }
+        
+        if(obj instanceof ASN1Sequence) 
+        {
+            return new DSAParameter((ASN1Sequence)obj);
+        }
+        
+        throw new IllegalArgumentException(&quot;Invalid DSAParameter: &quot; + obj.getClass().getName());
+    }
+
+    public DSAParameter(
+        BigInteger  p,
+        BigInteger  q,
+        BigInteger  g)
+    {
+        this.p = new DERInteger(p);
+        this.q = new DERInteger(q);
+        this.g = new DERInteger(g);
+    }
+
+    public DSAParameter(
+        ASN1Sequence  seq)
+    {
+        if (seq.size() != 3)
+        {
+            throw new IllegalArgumentException(&quot;Bad sequence size: &quot; + seq.size());
+        }
+        
+        Enumeration     e = seq.getObjects();
+
+        p = DERInteger.getInstance(e.nextElement());
+        q = DERInteger.getInstance(e.nextElement());
+        g = DERInteger.getInstance(e.nextElement());
+    }
+
+    public BigInteger getP()
+    {
+        return p.getPositiveValue();
+    }
+
+    public BigInteger getQ()
+    {
+        return q.getPositiveValue();
+    }
+
+    public BigInteger getG()
+    {
+        return g.getPositiveValue();
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(p);
+        v.add(q);
+        v.add(g);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/KeyUsage.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/KeyUsage.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,77 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.DERBitString;
+
+/**
+ * The KeyUsage object.
+ * &lt;pre&gt;
+ *    id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
+ *
+ *    KeyUsage ::= BIT STRING {
+ *         digitalSignature        (0),
+ *         nonRepudiation          (1),
+ *         keyEncipherment         (2),
+ *         dataEncipherment        (3),
+ *         keyAgreement            (4),
+ *         keyCertSign             (5),
+ *         cRLSign                 (6),
+ *         encipherOnly            (7),
+ *         decipherOnly            (8) }
+ * &lt;/pre&gt;
+ */
+public class KeyUsage
+    extends DERBitString
+{
+    public static final int        digitalSignature = (1 &lt;&lt; 7); 
+    public static final int        nonRepudiation   = (1 &lt;&lt; 6);
+    public static final int        keyEncipherment  = (1 &lt;&lt; 5);
+    public static final int        dataEncipherment = (1 &lt;&lt; 4);
+    public static final int        keyAgreement     = (1 &lt;&lt; 3);
+    public static final int        keyCertSign      = (1 &lt;&lt; 2);
+    public static final int        cRLSign          = (1 &lt;&lt; 1);
+    public static final int        encipherOnly     = (1 &lt;&lt; 0);
+    public static final int        decipherOnly     = (1 &lt;&lt; 15);
+
+    public static DERBitString getInstance(Object obj)   // needs to be DERBitString for other VMs
+    {
+        if (obj instanceof KeyUsage)
+        {
+            return (KeyUsage)obj;
+        }
+
+        if (obj instanceof X509Extension)
+        {
+            return new KeyUsage(DERBitString.getInstance(X509Extension.convertValueToObject((X509Extension)obj)));
+        }
+
+        return new KeyUsage(DERBitString.getInstance(obj));
+    }
+    
+    /**
+     * Basic constructor.
+     * 
+     * @param usage - the bitwise OR of the Key Usage flags giving the
+     * allowed uses for the key.
+     * e.g. (KeyUsage.keyEncipherment | KeyUsage.dataEncipherment)
+     */
+    public KeyUsage(
+        int usage)
+    {
+        super(getBytes(usage), getPadBits(usage));
+    }
+
+    public KeyUsage(
+        DERBitString usage)
+    {
+        super(usage.getBytes(), usage.getPadBits());
+    }
+
+    public String toString()
+    {
+        if (data.length == 1)
+        {
+            return &quot;KeyUsage: 0x&quot; + Integer.toHexString(data[0] &amp; 0xff);
+        }
+        return &quot;KeyUsage: 0x&quot; + Integer.toHexString((data[1] &amp; 0xff) &lt;&lt; 8 | (data[0] &amp; 0xff));
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/RSAPublicKeyStructure.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,95 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class RSAPublicKeyStructure
+    extends ASN1Encodable
+{
+    private BigInteger  modulus;
+    private BigInteger  publicExponent;
+
+    public static RSAPublicKeyStructure getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static RSAPublicKeyStructure getInstance(
+        Object obj)
+    {
+        if(obj == null || obj instanceof RSAPublicKeyStructure) 
+        {
+            return (RSAPublicKeyStructure)obj;
+        }
+        
+        if(obj instanceof ASN1Sequence) 
+        {
+            return new RSAPublicKeyStructure((ASN1Sequence)obj);
+        }
+        
+        throw new IllegalArgumentException(&quot;Invalid RSAPublicKeyStructure: &quot; + obj.getClass().getName());
+    }
+    
+    public RSAPublicKeyStructure(
+        BigInteger  modulus,
+        BigInteger  publicExponent)
+    {
+        this.modulus = modulus;
+        this.publicExponent = publicExponent;
+    }
+
+    public RSAPublicKeyStructure(
+        ASN1Sequence  seq)
+    {
+        if (seq.size() != 2)
+        {
+            throw new IllegalArgumentException(&quot;Bad sequence size: &quot;
+                    + seq.size());
+        }
+
+        Enumeration e = seq.getObjects();
+
+        modulus = DERInteger.getInstance(e.nextElement()).getPositiveValue();
+        publicExponent = DERInteger.getInstance(e.nextElement()).getPositiveValue();
+    }
+
+    public BigInteger getModulus()
+    {
+        return modulus;
+    }
+
+    public BigInteger getPublicExponent()
+    {
+        return publicExponent;
+    }
+
+    /**
+     * This outputs the key in PKCS1v2 format.
+     * &lt;pre&gt;
+     *      RSAPublicKey ::= SEQUENCE {
+     *                          modulus INTEGER, -- n
+     *                          publicExponent INTEGER, -- e
+     *                      }
+     * &lt;/pre&gt;
+     * &lt;p&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(new DERInteger(getModulus()));
+        v.add(new DERInteger(getPublicExponent()));
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+/**
+ * The object that contains the public key stored in a certficate.
+ * &lt;p&gt;
+ * The getEncoded() method in the public keys in the JCE produces a DER
+ * encoded one of these.
+ */
+public class SubjectPublicKeyInfo
+    extends ASN1Encodable
+{
+    private AlgorithmIdentifier     algId;
+    private DERBitString            keyData;
+
+    public static SubjectPublicKeyInfo getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static SubjectPublicKeyInfo getInstance(
+        Object  obj)
+    {
+        if (obj instanceof SubjectPublicKeyInfo)
+        {
+            return (SubjectPublicKeyInfo)obj;
+        }
+        else if (obj != null)
+        {
+            return new SubjectPublicKeyInfo(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    public SubjectPublicKeyInfo(
+        AlgorithmIdentifier algId,
+        DEREncodable        publicKey)
+    {
+        this.keyData = new DERBitString(publicKey);
+        this.algId = algId;
+    }
+
+    public SubjectPublicKeyInfo(
+        AlgorithmIdentifier algId,
+        byte[]              publicKey)
+    {
+        this.keyData = new DERBitString(publicKey);
+        this.algId = algId;
+    }
+
+    public SubjectPublicKeyInfo(
+        ASN1Sequence  seq)
+    {
+        if (seq.size() != 2)
+        {
+            throw new IllegalArgumentException(&quot;Bad sequence size: &quot;
+                    + seq.size());
+        }
+
+        Enumeration         e = seq.getObjects();
+
+        this.algId = AlgorithmIdentifier.getInstance(e.nextElement());
+        this.keyData = DERBitString.getInstance(e.nextElement());
+    }
+
+    public AlgorithmIdentifier getAlgorithmId()
+    {
+        return algId;
+    }
+
+    /**
+     * for when the public key is an encoded object - if the bitstring
+     * can't be decoded this routine throws an IOException.
+     *
+     * @exception IOException - if the bit string doesn't represent a DER
+     * encoded object.
+     */
+    public DERObject getPublicKey()
+        throws IOException
+    {
+        ASN1InputStream         aIn = new ASN1InputStream(keyData.getBytes());
+
+        return aIn.readObject();
+    }
+
+    /**
+     * for when the public key is raw bits...
+     */
+    public DERBitString getPublicKeyData()
+    {
+        return keyData;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     * SubjectPublicKeyInfo ::= SEQUENCE {
+     *                          algorithm AlgorithmIdentifier,
+     *                          publicKey BIT STRING }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector  v = new ASN1EncodableVector();
+
+        v.add(algId);
+        v.add(keyData);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/TBSCertificateStructure.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,193 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERTaggedObject;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+
+/**
+ * The TBSCertificate object.
+ * &lt;pre&gt;
+ * TBSCertificate ::= SEQUENCE {
+ *      version          [ 0 ]  Version DEFAULT v1(0),
+ *      serialNumber            CertificateSerialNumber,
+ *      signature               AlgorithmIdentifier,
+ *      issuer                  Name,
+ *      validity                Validity,
+ *      subject                 Name,
+ *      subjectPublicKeyInfo    SubjectPublicKeyInfo,
+ *      issuerUniqueID    [ 1 ] IMPLICIT UniqueIdentifier OPTIONAL,
+ *      subjectUniqueID   [ 2 ] IMPLICIT UniqueIdentifier OPTIONAL,
+ *      extensions        [ 3 ] Extensions OPTIONAL
+ *      }
+ * &lt;/pre&gt;
+ * &lt;p&gt;
+ * Note: issuerUniqueID and subjectUniqueID are both deprecated by the IETF. This class
+ * will parse them, but you really shouldn't be creating new ones.
+ */
+public class TBSCertificateStructure
+    extends ASN1Encodable
+    implements X509ObjectIdentifiers, PKCSObjectIdentifiers
+{
+    ASN1Sequence            seq;
+
+    DERInteger              version;
+    DERInteger              serialNumber;
+    AlgorithmIdentifier     signature;
+    X509Name                issuer;
+    Time                    startDate, endDate;
+    X509Name                subject;
+    SubjectPublicKeyInfo    subjectPublicKeyInfo;
+    DERBitString            issuerUniqueId;
+    DERBitString            subjectUniqueId;
+    X509Extensions          extensions;
+
+    public static TBSCertificateStructure getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static TBSCertificateStructure getInstance(
+        Object  obj)
+    {
+        if (obj instanceof TBSCertificateStructure)
+        {
+            return (TBSCertificateStructure)obj;
+        }
+        else if (obj != null)
+        {
+            return new TBSCertificateStructure(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    public TBSCertificateStructure(
+        ASN1Sequence  seq)
+    {
+        int         seqStart = 0;
+
+        this.seq = seq;
+
+        //
+        // some certficates don't include a version number - we assume v1
+        //
+        if (seq.getObjectAt(0) instanceof DERTaggedObject)
+        {
+            version = DERInteger.getInstance((ASN1TaggedObject)seq.getObjectAt(0), true);
+        }
+        else
+        {
+            seqStart = -1;          // field 0 is missing!
+            version = new DERInteger(0);
+        }
+
+        serialNumber = DERInteger.getInstance(seq.getObjectAt(seqStart + 1));
+
+        signature = AlgorithmIdentifier.getInstance(seq.getObjectAt(seqStart + 2));
+        issuer = X509Name.getInstance(seq.getObjectAt(seqStart + 3));
+
+        //
+        // before and after dates
+        //
+        ASN1Sequence  dates = (ASN1Sequence)seq.getObjectAt(seqStart + 4);
+
+        startDate = Time.getInstance(dates.getObjectAt(0));
+        endDate = Time.getInstance(dates.getObjectAt(1));
+
+        subject = X509Name.getInstance(seq.getObjectAt(seqStart + 5));
+
+        //
+        // public key info.
+        //
+        subjectPublicKeyInfo = SubjectPublicKeyInfo.getInstance(seq.getObjectAt(seqStart + 6));
+
+        for (int extras = seq.size() - (seqStart + 6) - 1; extras &gt; 0; extras--)
+        {
+            DERTaggedObject extra = (DERTaggedObject)seq.getObjectAt(seqStart + 6 + extras);
+
+            switch (extra.getTagNo())
+            {
+            case 1:
+                issuerUniqueId = DERBitString.getInstance(extra, false);
+                break;
+            case 2:
+                subjectUniqueId = DERBitString.getInstance(extra, false);
+                break;
+            case 3:
+                extensions = X509Extensions.getInstance(extra);
+            }
+        }
+    }
+
+    public int getVersion()
+    {
+        return version.getValue().intValue() + 1;
+    }
+
+    public DERInteger getVersionNumber()
+    {
+        return version;
+    }
+
+    public DERInteger getSerialNumber()
+    {
+        return serialNumber;
+    }
+
+    public AlgorithmIdentifier getSignature()
+    {
+        return signature;
+    }
+
+    public X509Name getIssuer()
+    {
+        return issuer;
+    }
+
+    public Time getStartDate()
+    {
+        return startDate;
+    }
+
+    public Time getEndDate()
+    {
+        return endDate;
+    }
+
+    public X509Name getSubject()
+    {
+        return subject;
+    }
+
+    public SubjectPublicKeyInfo getSubjectPublicKeyInfo()
+    {
+        return subjectPublicKeyInfo;
+    }
+
+    public DERBitString getIssuerUniqueId()
+    {
+        return issuerUniqueId;
+    }
+
+    public DERBitString getSubjectUniqueId()
+    {
+        return subjectUniqueId;
+    }
+
+    public X509Extensions getExtensions()
+    {
+        return extensions;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return seq;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/Time.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/Time.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/Time.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/Time.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/Time.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,133 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Choice;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERGeneralizedTime;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERUTCTime;
+
+// import java.text.ParseException;
+// import java.text.SimpleDateFormat;
+// import ewe.sys.Date;
+// import java.util.SimpleTimeZone;
+
+public class Time
+    extends ASN1Encodable
+    implements ASN1Choice
+{
+    DERObject   time;
+
+    public static Time getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(obj.getObject()); // must be explicitly tagged
+    }
+
+    public Time(
+        DERObject   time)
+    {
+        if (!(time instanceof DERUTCTime)
+            &amp;&amp; !(time instanceof DERGeneralizedTime))
+        {
+            throw new IllegalArgumentException(&quot;unknown object passed to Time&quot;);
+        }
+
+        this.time = time;
+    }
+
+    /**
+     * creates a time object from a given date - if the date is between 1950
+     * and 2049 a UTCTime object is generated, otherwise a GeneralizedTime
+     * is used.
+     */
+  /*  public Time(
+        Date    date)
+    {
+        SimpleTimeZone      tz = new SimpleTimeZone(0, &quot;Z&quot;);
+        SimpleDateFormat    dateF = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
+
+        dateF.setTimeZone(tz);
+
+        String  d = dateF.format(date) + &quot;Z&quot;;
+        int     year = Integer.parseInt(d.substring(0, 4));
+
+        if (year &lt; 1950 || year &gt; 2049)
+        {
+            time = new DERGeneralizedTime(d);
+        }
+        else
+        {
+            time = new DERUTCTime(d.substring(2));
+        }
+    }
+*/
+    public static Time getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof Time)
+        {
+            return (Time)obj;
+        }
+        else if (obj instanceof DERUTCTime)
+        {
+            return new Time((DERUTCTime)obj);
+        }
+        else if (obj instanceof DERGeneralizedTime)
+        {
+            return new Time((DERGeneralizedTime)obj);
+        }
+
+        throw new IllegalArgumentException(&quot;unknown object in factory: &quot; + obj.getClass().getName());
+    }
+
+    public String getTime()
+    {
+        if (time instanceof DERUTCTime)
+        {
+            return ((DERUTCTime)time).getAdjustedTime();
+        }
+        else
+        {
+            return ((DERGeneralizedTime)time).getTime();
+        }
+    }
+/*
+    public Date getDate()
+    {
+        try
+        {
+            if (time instanceof DERUTCTime)
+            {
+                return ((DERUTCTime)time).getAdjustedDate();
+            }
+            else
+            {
+                return ((DERGeneralizedTime)time).getDate();
+            }
+        }
+        catch (ParseException e)
+        {         // this should never happen
+            throw new IllegalStateException(&quot;invalid date string: &quot; + e.getMessage());
+        }
+    }
+*/
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     * Time ::= CHOICE {
+     *             utcTime        UTCTime,
+     *             generalTime    GeneralizedTime }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        return time;
+    }
+
+    public String toString()
+    {
+        return getTime();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509CertificateStructure.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,127 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+
+/**
+ * an X509Certificate structure.
+ * &lt;pre&gt;
+ *  Certificate ::= SEQUENCE {
+ *      tbsCertificate          TBSCertificate,
+ *      signatureAlgorithm      AlgorithmIdentifier,
+ *      signature               BIT STRING
+ *  }
+ * &lt;/pre&gt;
+ */
+public class X509CertificateStructure
+    extends ASN1Encodable
+    implements X509ObjectIdentifiers, PKCSObjectIdentifiers
+{
+    ASN1Sequence  seq;
+    TBSCertificateStructure tbsCert;
+    AlgorithmIdentifier     sigAlgId;
+    DERBitString            sig;
+
+    public static X509CertificateStructure getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static X509CertificateStructure getInstance(
+        Object  obj)
+    {
+        if (obj instanceof X509CertificateStructure)
+        {
+            return (X509CertificateStructure)obj;
+        }
+        else if (obj != null)
+        {
+            return new X509CertificateStructure(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    public X509CertificateStructure(
+        ASN1Sequence  seq)
+    {
+        this.seq = seq;
+
+        //
+        // correct x509 certficate
+        //
+        if (seq.size() == 3)
+        {
+            tbsCert = TBSCertificateStructure.getInstance(seq.getObjectAt(0));
+            sigAlgId = AlgorithmIdentifier.getInstance(seq.getObjectAt(1));
+
+            sig = DERBitString.getInstance(seq.getObjectAt(2));
+        }
+        else
+        {
+            throw new IllegalArgumentException(&quot;sequence wrong size for a certificate&quot;);
+        }
+    }
+
+    public TBSCertificateStructure getTBSCertificate()
+    {
+        return tbsCert;
+    }
+
+    public int getVersion()
+    {
+        return tbsCert.getVersion();
+    }
+
+    public DERInteger getSerialNumber()
+    {
+        return tbsCert.getSerialNumber();
+    }
+
+    public X509Name getIssuer()
+    {
+        return tbsCert.getIssuer();
+    }
+
+    public Time getStartDate()
+    {
+        return tbsCert.getStartDate();
+    }
+
+    public Time getEndDate()
+    {
+        return tbsCert.getEndDate();
+    }
+
+    public X509Name getSubject()
+    {
+        return tbsCert.getSubject();
+    }
+
+    public SubjectPublicKeyInfo getSubjectPublicKeyInfo()
+    {
+        return tbsCert.getSubjectPublicKeyInfo();
+    }
+
+    public AlgorithmIdentifier getSignatureAlgorithm()
+    {
+        return sigAlgId;
+    }
+
+    public DERBitString getSignature()
+    {
+        return sig;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return seq;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509DefaultEntryConverter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,65 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.DERGeneralizedTime;
+import org.bouncycastle.asn1.DERIA5String;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERPrintableString;
+import org.bouncycastle.asn1.DERUTF8String;
+
+import ewe.io.IOException;
+
+/**
+ * The default converter for X509 DN entries when going from their
+ * string value to ASN.1 strings.
+ */
+public class X509DefaultEntryConverter
+    extends X509NameEntryConverter
+{
+    /**
+     * Apply default coversion for the given value depending on the oid
+     * and the character range of the value.
+     * 
+     * @param oid the object identifier for the DN entry
+     * @param value the value associated with it
+     * @return the ASN.1 equivalent for the string value.
+     */
+    public DERObject getConvertedValue(
+        DERObjectIdentifier  oid,
+        String               value)
+    {
+        if (value.length() != 0 &amp;&amp; value.charAt(0) == '#')
+        {
+            try
+            {
+                return convertHexEncoded(value, 1);
+            }
+            catch (IOException e)
+            {
+                throw new RuntimeException(&quot;can't recode value for oid &quot; + oid.getId());
+            }
+        }
+        else
+        {
+            if (value.length() != 0 &amp;&amp; value.charAt(0) == '\\')
+            {
+                value = value.substring(1);
+            }
+            if (oid.equals(X509Name.EmailAddress) || oid.equals(X509Name.DC))
+            {
+                return new DERIA5String(value);
+            }
+            else if (oid.equals(X509Name.DATE_OF_BIRTH))  // accept time string as well as # (for compatibility)
+            {
+                return new DERGeneralizedTime(value);
+            }
+            else if (oid.equals(X509Name.C) || oid.equals(X509Name.SN) || oid.equals(X509Name.DN_QUALIFIER)
+                || oid.equals(X509Name.TELEPHONE_NUMBER))
+            {
+                 return new DERPrintableString(value);
+            }
+        }
+        
+        return new DERUTF8String(value);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509Extension.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extension.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509Extension.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509Extension.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,249 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.DERBoolean;
+
+/**
+ * an object for the elements in the X.509 V3 extension block.
+ */
+public class X509Extension
+{
+    /**
+     * Subject Directory Attributes
+     */
+    public static final ASN1ObjectIdentifier subjectDirectoryAttributes = new ASN1ObjectIdentifier(&quot;2.5.29.9&quot;);
+    
+    /**
+     * Subject Key Identifier 
+     */
+    public static final ASN1ObjectIdentifier subjectKeyIdentifier = new ASN1ObjectIdentifier(&quot;2.5.29.14&quot;);
+
+    /**
+     * Key Usage 
+     */
+    public static final ASN1ObjectIdentifier keyUsage = new ASN1ObjectIdentifier(&quot;2.5.29.15&quot;);
+
+    /**
+     * Private Key Usage Period 
+     */
+    public static final ASN1ObjectIdentifier privateKeyUsagePeriod = new ASN1ObjectIdentifier(&quot;2.5.29.16&quot;);
+
+    /**
+     * Subject Alternative Name 
+     */
+    public static final ASN1ObjectIdentifier subjectAlternativeName = new ASN1ObjectIdentifier(&quot;2.5.29.17&quot;);
+
+    /**
+     * Issuer Alternative Name 
+     */
+    public static final ASN1ObjectIdentifier issuerAlternativeName = new ASN1ObjectIdentifier(&quot;2.5.29.18&quot;);
+
+    /**
+     * Basic Constraints 
+     */
+    public static final ASN1ObjectIdentifier basicConstraints = new ASN1ObjectIdentifier(&quot;2.5.29.19&quot;);
+
+    /**
+     * CRL Number 
+     */
+    public static final ASN1ObjectIdentifier cRLNumber = new ASN1ObjectIdentifier(&quot;2.5.29.20&quot;);
+
+    /**
+     * Reason code 
+     */
+    public static final ASN1ObjectIdentifier reasonCode = new ASN1ObjectIdentifier(&quot;2.5.29.21&quot;);
+
+    /**
+     * Hold Instruction Code 
+     */
+    public static final ASN1ObjectIdentifier instructionCode = new ASN1ObjectIdentifier(&quot;2.5.29.23&quot;);
+
+    /**
+     * Invalidity Date 
+     */
+    public static final ASN1ObjectIdentifier invalidityDate = new ASN1ObjectIdentifier(&quot;2.5.29.24&quot;);
+
+    /**
+     * Delta CRL indicator 
+     */
+    public static final ASN1ObjectIdentifier deltaCRLIndicator = new ASN1ObjectIdentifier(&quot;2.5.29.27&quot;);
+
+    /**
+     * Issuing Distribution Point 
+     */
+    public static final ASN1ObjectIdentifier issuingDistributionPoint = new ASN1ObjectIdentifier(&quot;2.5.29.28&quot;);
+
+    /**
+     * Certificate Issuer 
+     */
+    public static final ASN1ObjectIdentifier certificateIssuer = new ASN1ObjectIdentifier(&quot;2.5.29.29&quot;);
+
+    /**
+     * Name Constraints 
+     */
+    public static final ASN1ObjectIdentifier nameConstraints = new ASN1ObjectIdentifier(&quot;2.5.29.30&quot;);
+
+    /**
+     * CRL Distribution Points 
+     */
+    public static final ASN1ObjectIdentifier cRLDistributionPoints = new ASN1ObjectIdentifier(&quot;2.5.29.31&quot;);
+
+    /**
+     * Certificate Policies 
+     */
+    public static final ASN1ObjectIdentifier certificatePolicies = new ASN1ObjectIdentifier(&quot;2.5.29.32&quot;);
+
+    /**
+     * Policy Mappings 
+     */
+    public static final ASN1ObjectIdentifier policyMappings = new ASN1ObjectIdentifier(&quot;2.5.29.33&quot;);
+
+    /**
+     * Authority Key Identifier 
+     */
+    public static final ASN1ObjectIdentifier authorityKeyIdentifier = new ASN1ObjectIdentifier(&quot;2.5.29.35&quot;);
+
+    /**
+     * Policy Constraints 
+     */
+    public static final ASN1ObjectIdentifier policyConstraints = new ASN1ObjectIdentifier(&quot;2.5.29.36&quot;);
+
+    /**
+     * Extended Key Usage 
+     */
+    public static final ASN1ObjectIdentifier extendedKeyUsage = new ASN1ObjectIdentifier(&quot;2.5.29.37&quot;);
+
+    /**
+     * Freshest CRL
+     */
+    public static final ASN1ObjectIdentifier freshestCRL = new ASN1ObjectIdentifier(&quot;2.5.29.46&quot;);
+     
+    /**
+     * Inhibit Any Policy
+     */
+    public static final ASN1ObjectIdentifier inhibitAnyPolicy = new ASN1ObjectIdentifier(&quot;2.5.29.54&quot;);
+
+    /**
+     * Authority Info Access
+     */
+    public static final ASN1ObjectIdentifier authorityInfoAccess = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.1&quot;);
+
+    /**
+     * Subject Info Access
+     */
+    public static final ASN1ObjectIdentifier subjectInfoAccess = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.11&quot;);
+    
+    /**
+     * Logo Type
+     */
+    public static final ASN1ObjectIdentifier logoType = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.12&quot;);
+
+    /**
+     * BiometricInfo
+     */
+    public static final ASN1ObjectIdentifier biometricInfo = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.2&quot;);
+    
+    /**
+     * QCStatements
+     */
+    public static final ASN1ObjectIdentifier qCStatements = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.3&quot;);
+
+    /**
+     * Audit identity extension in attribute certificates.
+     */
+    public static final ASN1ObjectIdentifier auditIdentity = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.4&quot;);
+    
+    /**
+     * NoRevAvail extension in attribute certificates.
+     */
+    public static final ASN1ObjectIdentifier noRevAvail = new ASN1ObjectIdentifier(&quot;2.5.29.56&quot;);
+
+    /**
+     * TargetInformation extension in attribute certificates.
+     */
+    public static final ASN1ObjectIdentifier targetInformation = new ASN1ObjectIdentifier(&quot;2.5.29.55&quot;);
+        
+    boolean             critical;
+    ASN1OctetString      value;
+
+    public X509Extension(
+        DERBoolean              critical,
+        ASN1OctetString         value)
+    {
+        this.critical = critical.isTrue();
+        this.value = value;
+    }
+
+    public X509Extension(
+        boolean                 critical,
+        ASN1OctetString         value)
+    {
+        this.critical = critical;
+        this.value = value;
+    }
+
+    public boolean isCritical()
+    {
+        return critical;
+    }
+
+    public ASN1OctetString getValue()
+    {
+        return value;
+    }
+
+    public ASN1Encodable getParsedValue()
+    {
+        return convertValueToObject(this);
+    }
+
+    public int hashCode()
+    {
+        if (this.isCritical())
+        {
+            return this.getValue().hashCode();
+        }
+
+        
+        return ~this.getValue().hashCode();
+    }
+
+    public boolean equals(
+        Object  o)
+    {
+        if (!(o instanceof X509Extension))
+        {
+            return false;
+        }
+
+        X509Extension   other = (X509Extension)o;
+
+        return other.getValue().equals(this.getValue())
+            &amp;&amp; (other.isCritical() == this.isCritical());
+    }
+
+    /**
+     * Convert the value of the passed in extension to an object
+     * @param ext the extension to parse
+     * @return the object the value string contains
+     * @exception IllegalArgumentException if conversion is not possible
+     */
+    public static ASN1Object convertValueToObject(
+        X509Extension ext)
+        throws IllegalArgumentException
+    {
+        try
+        {
+            return ASN1Object.fromByteArray(ext.getValue().getOctets());
+        }
+        catch (IOException e)
+        {
+            throw new IllegalArgumentException(&quot;can't convert extension: &quot; +  e);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509Extensions.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509Extensions.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,479 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBoolean;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+
+public class X509Extensions
+    extends ASN1Encodable
+{
+    /**
+     * Subject Directory Attributes
+     * @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectDirectoryAttributes = new ASN1ObjectIdentifier(&quot;2.5.29.9&quot;);
+    
+    /**
+     * Subject Key Identifier
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectKeyIdentifier = new ASN1ObjectIdentifier(&quot;2.5.29.14&quot;);
+
+    /**
+     * Key Usage
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier KeyUsage = new ASN1ObjectIdentifier(&quot;2.5.29.15&quot;);
+
+    /**
+     * Private Key Usage Period
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier PrivateKeyUsagePeriod = new ASN1ObjectIdentifier(&quot;2.5.29.16&quot;);
+
+    /**
+     * Subject Alternative Name
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectAlternativeName = new ASN1ObjectIdentifier(&quot;2.5.29.17&quot;);
+
+    /**
+     * Issuer Alternative Name
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier IssuerAlternativeName = new ASN1ObjectIdentifier(&quot;2.5.29.18&quot;);
+
+    /**
+     * Basic Constraints
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier BasicConstraints = new ASN1ObjectIdentifier(&quot;2.5.29.19&quot;);
+
+    /**
+     * CRL Number
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CRLNumber = new ASN1ObjectIdentifier(&quot;2.5.29.20&quot;);
+
+    /**
+     * Reason code
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier ReasonCode = new ASN1ObjectIdentifier(&quot;2.5.29.21&quot;);
+
+    /**
+     * Hold Instruction Code
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier InstructionCode = new ASN1ObjectIdentifier(&quot;2.5.29.23&quot;);
+
+    /**
+     * Invalidity Date
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier InvalidityDate = new ASN1ObjectIdentifier(&quot;2.5.29.24&quot;);
+
+    /**
+     * Delta CRL indicator
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier DeltaCRLIndicator = new ASN1ObjectIdentifier(&quot;2.5.29.27&quot;);
+
+    /**
+     * Issuing Distribution Point
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier IssuingDistributionPoint = new ASN1ObjectIdentifier(&quot;2.5.29.28&quot;);
+
+    /**
+     * Certificate Issuer
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CertificateIssuer = new ASN1ObjectIdentifier(&quot;2.5.29.29&quot;);
+
+    /**
+     * Name Constraints
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier NameConstraints = new ASN1ObjectIdentifier(&quot;2.5.29.30&quot;);
+
+    /**
+     * CRL Distribution Points
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CRLDistributionPoints = new ASN1ObjectIdentifier(&quot;2.5.29.31&quot;);
+
+    /**
+     * Certificate Policies
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier CertificatePolicies = new ASN1ObjectIdentifier(&quot;2.5.29.32&quot;);
+
+    /**
+     * Policy Mappings
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier PolicyMappings = new ASN1ObjectIdentifier(&quot;2.5.29.33&quot;);
+
+    /**
+     * Authority Key Identifier
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier AuthorityKeyIdentifier = new ASN1ObjectIdentifier(&quot;2.5.29.35&quot;);
+
+    /**
+     * Policy Constraints
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier PolicyConstraints = new ASN1ObjectIdentifier(&quot;2.5.29.36&quot;);
+
+    /**
+     * Extended Key Usage
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier ExtendedKeyUsage = new ASN1ObjectIdentifier(&quot;2.5.29.37&quot;);
+
+    /**
+     * Freshest CRL
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier FreshestCRL = new ASN1ObjectIdentifier(&quot;2.5.29.46&quot;);
+     
+    /**
+     * Inhibit Any Policy
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier InhibitAnyPolicy = new ASN1ObjectIdentifier(&quot;2.5.29.54&quot;);
+
+    /**
+     * Authority Info Access
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier AuthorityInfoAccess = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.1&quot;);
+
+    /**
+     * Subject Info Access
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier SubjectInfoAccess = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.11&quot;);
+    
+    /**
+     * Logo Type
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier LogoType = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.12&quot;);
+
+    /**
+     * BiometricInfo
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier BiometricInfo = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.2&quot;);
+    
+    /**
+     * QCStatements
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier QCStatements = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.3&quot;);
+
+    /**
+     * Audit identity extension in attribute certificates.
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier AuditIdentity = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7.1.4&quot;);
+    
+    /**
+     * NoRevAvail extension in attribute certificates.
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier NoRevAvail = new ASN1ObjectIdentifier(&quot;2.5.29.56&quot;);
+
+    /**
+     * TargetInformation extension in attribute certificates.
+     *  @deprecated use X509Extension value.
+     */
+    public static final ASN1ObjectIdentifier TargetInformation = new ASN1ObjectIdentifier(&quot;2.5.29.55&quot;);
+    
+    private Hashtable               extensions = new Hashtable();
+    private Vector                  ordering = new Vector();
+
+    public static X509Extensions getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static X509Extensions getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof X509Extensions)
+        {
+            return (X509Extensions)obj;
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new X509Extensions((ASN1Sequence)obj);
+        }
+
+        if (obj instanceof ASN1TaggedObject)
+        {
+            return getInstance(((ASN1TaggedObject)obj).getObject());
+        }
+
+        throw new IllegalArgumentException(&quot;illegal object in getInstance: &quot; + obj.getClass().getName());
+    }
+
+    /**
+     * Constructor from ASN1Sequence.
+     *
+     * the extensions are a list of constructed sequences, either with (OID, OctetString) or (OID, Boolean, OctetString)
+     */
+    public X509Extensions(
+        ASN1Sequence  seq)
+    {
+        Enumeration e = seq.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            ASN1Sequence            s = ASN1Sequence.getInstance(e.nextElement());
+
+            if (s.size() == 3)
+            {
+                extensions.put(s.getObjectAt(0), new X509Extension(DERBoolean.getInstance(s.getObjectAt(1)), ASN1OctetString.getInstance(s.getObjectAt(2))));
+            }
+            else if (s.size() == 2)
+            {
+                extensions.put(s.getObjectAt(0), new X509Extension(false, ASN1OctetString.getInstance(s.getObjectAt(1))));
+            }
+            else
+            {
+                throw new IllegalArgumentException(&quot;Bad sequence size: &quot; + s.size());
+            }
+
+            ordering.addElement(s.getObjectAt(0));
+        }
+    }
+
+    /**
+     * constructor from a table of extensions.
+     * &lt;p&gt;
+     * it's is assumed the table contains OID/String pairs.
+     */
+    public X509Extensions(
+        Hashtable  extensions)
+    {
+        this(null, extensions);
+    }
+
+    /**
+     * Constructor from a table of extensions with ordering.
+     * &lt;p&gt;
+     * It's is assumed the table contains OID/String pairs.
+     */
+    public X509Extensions(
+        Vector      ordering,
+        Hashtable   extensions)
+    {
+        Enumeration e;
+
+        if (ordering == null)
+        {
+            e = extensions.keys();
+        }
+        else
+        {
+            e = ordering.elements();
+        }
+
+        while (e.hasMoreElements())
+        {
+            this.ordering.addElement(new ASN1ObjectIdentifier(((DERObjectIdentifier)e.nextElement()).getId())); 
+        }
+
+        e = this.ordering.elements();
+
+        while (e.hasMoreElements())
+        {
+            ASN1ObjectIdentifier     oid = new ASN1ObjectIdentifier(((DERObjectIdentifier)e.nextElement()).getId());
+            X509Extension           ext = (X509Extension)extensions.get(oid);
+
+            this.extensions.put(oid, ext);
+        }
+    }
+
+    /**
+     * Constructor from two vectors
+     * 
+     * @param objectIDs a vector of the object identifiers.
+     * @param values a vector of the extension values.
+     */
+    public X509Extensions(
+        Vector      objectIDs,
+        Vector      values)
+    {
+        Enumeration e = objectIDs.elements();
+
+        while (e.hasMoreElements())
+        {
+            this.ordering.addElement(e.nextElement()); 
+        }
+
+        int count = 0;
+        
+        e = this.ordering.elements();
+
+        while (e.hasMoreElements())
+        {
+            ASN1ObjectIdentifier     oid = (ASN1ObjectIdentifier)e.nextElement();
+            X509Extension           ext = (X509Extension)values.elementAt(count);
+
+            this.extensions.put(oid, ext);
+            count++;
+        }
+    }
+    
+    /**
+     * return an Enumeration of the extension field's object ids.
+     */
+    public Enumeration oids()
+    {
+        return ordering.elements();
+    }
+
+    /**
+     * return the extension represented by the object identifier
+     * passed in.
+     *
+     * @return the extension if it's present, null otherwise.
+     */
+    public X509Extension getExtension(
+        ASN1ObjectIdentifier oid)
+    {
+        return (X509Extension)extensions.get(oid);
+    }
+
+    /**
+     * @deprecated
+     * @param oid
+     * @return
+     */
+    public X509Extension getExtension(
+        DERObjectIdentifier oid)
+    {
+        return (X509Extension)extensions.get(oid);
+    }
+
+    /**
+     * &lt;pre&gt;
+     *     Extensions        ::=   SEQUENCE SIZE (1..MAX) OF Extension
+     *
+     *     Extension         ::=   SEQUENCE {
+     *        extnId            EXTENSION.&amp;id ({ExtensionSet}),
+     *        critical          BOOLEAN DEFAULT FALSE,
+     *        extnValue         OCTET STRING }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector     vec = new ASN1EncodableVector();
+        Enumeration             e = ordering.elements();
+
+        while (e.hasMoreElements())
+        {
+            ASN1ObjectIdentifier     oid = (ASN1ObjectIdentifier)e.nextElement();
+            X509Extension           ext = (X509Extension)extensions.get(oid);
+            ASN1EncodableVector     v = new ASN1EncodableVector();
+
+            v.add(oid);
+
+            if (ext.isCritical())
+            {
+                v.add(new DERBoolean(true));
+            }
+
+            v.add(ext.getValue());
+
+            vec.add(new DERSequence(v));
+        }
+
+        return new DERSequence(vec);
+    }
+
+    public boolean equivalent(
+        X509Extensions other)
+    {
+        if (extensions.size() != other.extensions.size())
+        {
+            return false;
+        }
+
+        Enumeration     e1 = extensions.keys();
+
+        while (e1.hasMoreElements())
+        {
+            Object  key = e1.nextElement();
+
+            if (!extensions.get(key).equals(other.extensions.get(key)))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public ASN1ObjectIdentifier[] getExtensionOIDs()
+    {
+        return toOidArray(ordering);
+    }
+    
+    public ASN1ObjectIdentifier[] getNonCriticalExtensionOIDs()
+    {
+        return getExtensionOIDs(false);
+    }
+
+    public ASN1ObjectIdentifier[] getCriticalExtensionOIDs()
+    {
+        return getExtensionOIDs(true);
+    }
+
+    private ASN1ObjectIdentifier[] getExtensionOIDs(boolean isCritical)
+    {
+        Vector oidVec = new Vector();
+
+        for (int i = 0; i != ordering.size(); i++)
+        {
+            Object oid = ordering.elementAt(i);
+
+            if (((X509Extension)extensions.get(oid)).isCritical() == isCritical)
+            {
+                oidVec.addElement(oid);
+            }
+        }
+
+        return toOidArray(oidVec);
+    }
+
+    private ASN1ObjectIdentifier[] toOidArray(Vector oidVec)
+    {
+        ASN1ObjectIdentifier[] oids = new ASN1ObjectIdentifier[oidVec.size()];
+
+        for (int i = 0; i != oids.length; i++)
+        {
+            oids[i] = (ASN1ObjectIdentifier)oidVec.elementAt(i);
+        }
+        return oids;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509Name.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509Name.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509Name.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509Name.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509Name.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1267 @@
+package org.bouncycastle.asn1.x509;
+
+import ewe.io.IOException;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1Set;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.DERSet;
+import org.bouncycastle.asn1.DERString;
+import org.bouncycastle.asn1.DERUniversalString;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+import org.bouncycastle.asn1.x500.X500Name;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+/**
+ * &lt;pre&gt;
+ *     RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
+ *
+ *     RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
+ *
+ *     AttributeTypeAndValue ::= SEQUENCE {
+ *                                   type  OBJECT IDENTIFIER,
+ *                                   value ANY }
+ * &lt;/pre&gt;
+ * @deprecated use org.bouncycastle.asn1.x500.X500Name.
+ */
+public class X509Name
+    extends ASN1Encodable
+{
+    /**
+     * country code - StringType(SIZE(2))
+     */
+    public static final DERObjectIdentifier C = new DERObjectIdentifier(&quot;2.5.4.6&quot;);
+
+    /**
+     * organization - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier O = new DERObjectIdentifier(&quot;2.5.4.10&quot;);
+
+    /**
+     * organizational unit name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier OU = new DERObjectIdentifier(&quot;2.5.4.11&quot;);
+
+    /**
+     * Title
+     */
+    public static final DERObjectIdentifier T = new DERObjectIdentifier(&quot;2.5.4.12&quot;);
+
+    /**
+     * common name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier CN = new DERObjectIdentifier(&quot;2.5.4.3&quot;);
+
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier SN = new DERObjectIdentifier(&quot;2.5.4.5&quot;);
+
+    /**
+     * street - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier STREET = new DERObjectIdentifier(&quot;2.5.4.9&quot;);
+    
+    /**
+     * device serial number name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier SERIALNUMBER = SN;
+
+    /**
+     * locality name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier L = new DERObjectIdentifier(&quot;2.5.4.7&quot;);
+
+    /**
+     * state, or province name - StringType(SIZE(1..64))
+     */
+    public static final DERObjectIdentifier ST = new DERObjectIdentifier(&quot;2.5.4.8&quot;);
+
+    /**
+     * Naming attributes of type X520name
+     */
+    public static final DERObjectIdentifier SURNAME = new DERObjectIdentifier(&quot;2.5.4.4&quot;);
+    public static final DERObjectIdentifier GIVENNAME = new DERObjectIdentifier(&quot;2.5.4.42&quot;);
+    public static final DERObjectIdentifier INITIALS = new DERObjectIdentifier(&quot;2.5.4.43&quot;);
+    public static final DERObjectIdentifier GENERATION = new DERObjectIdentifier(&quot;2.5.4.44&quot;);
+    public static final DERObjectIdentifier UNIQUE_IDENTIFIER = new DERObjectIdentifier(&quot;2.5.4.45&quot;);
+
+    /**
+     * businessCategory - DirectoryString(SIZE(1..128)
+     */
+    public static final DERObjectIdentifier BUSINESS_CATEGORY = new DERObjectIdentifier(
+                    &quot;2.5.4.15&quot;);
+
+    /**
+     * postalCode - DirectoryString(SIZE(1..40)
+     */
+    public static final DERObjectIdentifier POSTAL_CODE = new DERObjectIdentifier(
+                    &quot;2.5.4.17&quot;);
+    
+    /**
+     * dnQualifier - DirectoryString(SIZE(1..64)
+     */
+    public static final DERObjectIdentifier DN_QUALIFIER = new DERObjectIdentifier(
+                    &quot;2.5.4.46&quot;);
+
+    /**
+     * RFC 3039 Pseudonym - DirectoryString(SIZE(1..64)
+     */
+    public static final DERObjectIdentifier PSEUDONYM = new DERObjectIdentifier(
+                    &quot;2.5.4.65&quot;);
+
+
+    /**
+     * RFC 3039 DateOfBirth - GeneralizedTime - YYYYMMDD000000Z
+     */
+    public static final DERObjectIdentifier DATE_OF_BIRTH = new DERObjectIdentifier(
+                    &quot;1.3.6.1.5.5.7.9.1&quot;);
+
+    /**
+     * RFC 3039 PlaceOfBirth - DirectoryString(SIZE(1..128)
+     */
+    public static final DERObjectIdentifier PLACE_OF_BIRTH = new DERObjectIdentifier(
+                    &quot;1.3.6.1.5.5.7.9.2&quot;);
+
+    /**
+     * RFC 3039 Gender - PrintableString (SIZE(1)) -- &quot;M&quot;, &quot;F&quot;, &quot;m&quot; or &quot;f&quot;
+     */
+    public static final DERObjectIdentifier GENDER = new DERObjectIdentifier(
+                    &quot;1.3.6.1.5.5.7.9.3&quot;);
+
+    /**
+     * RFC 3039 CountryOfCitizenship - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final DERObjectIdentifier COUNTRY_OF_CITIZENSHIP = new DERObjectIdentifier(
+                    &quot;1.3.6.1.5.5.7.9.4&quot;);
+
+    /**
+     * RFC 3039 CountryOfResidence - PrintableString (SIZE (2)) -- ISO 3166
+     * codes only
+     */
+    public static final DERObjectIdentifier COUNTRY_OF_RESIDENCE = new DERObjectIdentifier(
+                    &quot;1.3.6.1.5.5.7.9.5&quot;);
+
+
+    /**
+     * ISIS-MTT NameAtBirth - DirectoryString(SIZE(1..64)
+     */
+    public static final DERObjectIdentifier NAME_AT_BIRTH =  new DERObjectIdentifier(&quot;1.3.36.8.3.14&quot;);
+
+    /**
+     * RFC 3039 PostalAddress - SEQUENCE SIZE (1..6) OF
+     * DirectoryString(SIZE(1..30))
+     */
+    public static final DERObjectIdentifier POSTAL_ADDRESS = new DERObjectIdentifier(&quot;2.5.4.16&quot;);
+
+    /**
+     * RFC 2256 dmdName
+     */
+    public static final DERObjectIdentifier DMD_NAME = new DERObjectIdentifier(&quot;2.5.4.54&quot;);
+
+    /**
+     * id-at-telephoneNumber
+     */
+    public static final DERObjectIdentifier TELEPHONE_NUMBER = X509ObjectIdentifiers.id_at_telephoneNumber;
+
+    /**
+     * id-at-name
+     */
+    public static final DERObjectIdentifier NAME = X509ObjectIdentifiers.id_at_name;
+
+    /**
+     * Email address (RSA PKCS#9 extension) - IA5String.
+     * &lt;p&gt;Note: if you're trying to be ultra orthodox, don't use this! It shouldn't be in here.
+     */
+    public static final DERObjectIdentifier EmailAddress = PKCSObjectIdentifiers.pkcs_9_at_emailAddress;
+    
+    /**
+     * more from PKCS#9
+     */
+    public static final DERObjectIdentifier UnstructuredName = PKCSObjectIdentifiers.pkcs_9_at_unstructuredName;
+    public static final DERObjectIdentifier UnstructuredAddress = PKCSObjectIdentifiers.pkcs_9_at_unstructuredAddress;
+    
+    /**
+     * email address in Verisign certificates
+     */
+    public static final DERObjectIdentifier E = EmailAddress;
+    
+    /*
+     * others...
+     */
+    public static final DERObjectIdentifier DC = new DERObjectIdentifier(&quot;0.9.2342.19200300.100.1.25&quot;);
+
+    /**
+     * LDAP User id.
+     */
+    public static final DERObjectIdentifier UID = new DERObjectIdentifier(&quot;0.9.2342.19200300.100.1.1&quot;);
+
+    /**
+     * determines whether or not strings should be processed and printed
+     * from back to front.
+     */
+    public static boolean DefaultReverse = false;
+
+    /**
+     * default look up table translating OID values into their common symbols following
+     * the convention in RFC 2253 with a few extras
+     */
+    public static final Hashtable DefaultSymbols = new Hashtable();
+
+    /**
+     * look up table translating OID values into their common symbols following the convention in RFC 2253
+     * 
+     */
+    public static final Hashtable RFC2253Symbols = new Hashtable();
+
+    /**
+     * look up table translating OID values into their common symbols following the convention in RFC 1779
+     * 
+     */
+    public static final Hashtable RFC1779Symbols = new Hashtable();
+
+    /**
+     * look up table translating common symbols into their OIDS.
+     */
+    public static final Hashtable DefaultLookUp = new Hashtable();
+
+    /**
+     * look up table translating OID values into their common symbols
+     * @deprecated use DefaultSymbols
+     */
+    public static final Hashtable OIDLookUp = DefaultSymbols;
+
+    /**
+     * look up table translating string values into their OIDS -
+     * @deprecated use DefaultLookUp
+     */
+    public static final Hashtable SymbolLookUp = DefaultLookUp;
+
+    private static final Boolean TRUE = new Boolean(true); // for J2ME compatibility
+    private static final Boolean FALSE = new Boolean(false);
+
+    static
+    {
+        DefaultSymbols.put(C, &quot;C&quot;);
+        DefaultSymbols.put(O, &quot;O&quot;);
+        DefaultSymbols.put(T, &quot;T&quot;);
+        DefaultSymbols.put(OU, &quot;OU&quot;);
+        DefaultSymbols.put(CN, &quot;CN&quot;);
+        DefaultSymbols.put(L, &quot;L&quot;);
+        DefaultSymbols.put(ST, &quot;ST&quot;);
+        DefaultSymbols.put(SN, &quot;SERIALNUMBER&quot;);
+        DefaultSymbols.put(EmailAddress, &quot;E&quot;);
+        DefaultSymbols.put(DC, &quot;DC&quot;);
+        DefaultSymbols.put(UID, &quot;UID&quot;);
+        DefaultSymbols.put(STREET, &quot;STREET&quot;);
+        DefaultSymbols.put(SURNAME, &quot;SURNAME&quot;);
+        DefaultSymbols.put(GIVENNAME, &quot;GIVENNAME&quot;);
+        DefaultSymbols.put(INITIALS, &quot;INITIALS&quot;);
+        DefaultSymbols.put(GENERATION, &quot;GENERATION&quot;);
+        DefaultSymbols.put(UnstructuredAddress, &quot;unstructuredAddress&quot;);
+        DefaultSymbols.put(UnstructuredName, &quot;unstructuredName&quot;);
+        DefaultSymbols.put(UNIQUE_IDENTIFIER, &quot;UniqueIdentifier&quot;);
+        DefaultSymbols.put(DN_QUALIFIER, &quot;DN&quot;);
+        DefaultSymbols.put(PSEUDONYM, &quot;Pseudonym&quot;);
+        DefaultSymbols.put(POSTAL_ADDRESS, &quot;PostalAddress&quot;);
+        DefaultSymbols.put(NAME_AT_BIRTH, &quot;NameAtBirth&quot;);
+        DefaultSymbols.put(COUNTRY_OF_CITIZENSHIP, &quot;CountryOfCitizenship&quot;);
+        DefaultSymbols.put(COUNTRY_OF_RESIDENCE, &quot;CountryOfResidence&quot;);
+        DefaultSymbols.put(GENDER, &quot;Gender&quot;);
+        DefaultSymbols.put(PLACE_OF_BIRTH, &quot;PlaceOfBirth&quot;);
+        DefaultSymbols.put(DATE_OF_BIRTH, &quot;DateOfBirth&quot;);
+        DefaultSymbols.put(POSTAL_CODE, &quot;PostalCode&quot;);
+        DefaultSymbols.put(BUSINESS_CATEGORY, &quot;BusinessCategory&quot;);
+        DefaultSymbols.put(TELEPHONE_NUMBER, &quot;TelephoneNumber&quot;);
+        DefaultSymbols.put(NAME, &quot;Name&quot;);
+
+        RFC2253Symbols.put(C, &quot;C&quot;);
+        RFC2253Symbols.put(O, &quot;O&quot;);
+        RFC2253Symbols.put(OU, &quot;OU&quot;);
+        RFC2253Symbols.put(CN, &quot;CN&quot;);
+        RFC2253Symbols.put(L, &quot;L&quot;);
+        RFC2253Symbols.put(ST, &quot;ST&quot;);
+        RFC2253Symbols.put(STREET, &quot;STREET&quot;);
+        RFC2253Symbols.put(DC, &quot;DC&quot;);
+        RFC2253Symbols.put(UID, &quot;UID&quot;);
+
+        RFC1779Symbols.put(C, &quot;C&quot;);
+        RFC1779Symbols.put(O, &quot;O&quot;);
+        RFC1779Symbols.put(OU, &quot;OU&quot;);
+        RFC1779Symbols.put(CN, &quot;CN&quot;);
+        RFC1779Symbols.put(L, &quot;L&quot;);
+        RFC1779Symbols.put(ST, &quot;ST&quot;);
+        RFC1779Symbols.put(STREET, &quot;STREET&quot;);
+
+        DefaultLookUp.put(&quot;c&quot;, C);
+        DefaultLookUp.put(&quot;o&quot;, O);
+        DefaultLookUp.put(&quot;t&quot;, T);
+        DefaultLookUp.put(&quot;ou&quot;, OU);
+        DefaultLookUp.put(&quot;cn&quot;, CN);
+        DefaultLookUp.put(&quot;l&quot;, L);
+        DefaultLookUp.put(&quot;st&quot;, ST);
+        DefaultLookUp.put(&quot;sn&quot;, SN);
+        DefaultLookUp.put(&quot;serialnumber&quot;, SN);
+        DefaultLookUp.put(&quot;street&quot;, STREET);
+        DefaultLookUp.put(&quot;emailaddress&quot;, E);
+        DefaultLookUp.put(&quot;dc&quot;, DC);
+        DefaultLookUp.put(&quot;e&quot;, E);
+        DefaultLookUp.put(&quot;uid&quot;, UID);
+        DefaultLookUp.put(&quot;surname&quot;, SURNAME);
+        DefaultLookUp.put(&quot;givenname&quot;, GIVENNAME);
+        DefaultLookUp.put(&quot;initials&quot;, INITIALS);
+        DefaultLookUp.put(&quot;generation&quot;, GENERATION);
+        DefaultLookUp.put(&quot;unstructuredaddress&quot;, UnstructuredAddress);
+        DefaultLookUp.put(&quot;unstructuredname&quot;, UnstructuredName);
+        DefaultLookUp.put(&quot;uniqueidentifier&quot;, UNIQUE_IDENTIFIER);
+        DefaultLookUp.put(&quot;dn&quot;, DN_QUALIFIER);
+        DefaultLookUp.put(&quot;pseudonym&quot;, PSEUDONYM);
+        DefaultLookUp.put(&quot;postaladdress&quot;, POSTAL_ADDRESS);
+        DefaultLookUp.put(&quot;nameofbirth&quot;, NAME_AT_BIRTH);
+        DefaultLookUp.put(&quot;countryofcitizenship&quot;, COUNTRY_OF_CITIZENSHIP);
+        DefaultLookUp.put(&quot;countryofresidence&quot;, COUNTRY_OF_RESIDENCE);
+        DefaultLookUp.put(&quot;gender&quot;, GENDER);
+        DefaultLookUp.put(&quot;placeofbirth&quot;, PLACE_OF_BIRTH);
+        DefaultLookUp.put(&quot;dateofbirth&quot;, DATE_OF_BIRTH);
+        DefaultLookUp.put(&quot;postalcode&quot;, POSTAL_CODE);
+        DefaultLookUp.put(&quot;businesscategory&quot;, BUSINESS_CATEGORY);
+        DefaultLookUp.put(&quot;telephonenumber&quot;, TELEPHONE_NUMBER);
+        DefaultLookUp.put(&quot;name&quot;, NAME);
+    }
+
+    private X509NameEntryConverter  converter = null;
+    private Vector                  ordering = new Vector();
+    private Vector                  values = new Vector();
+    private Vector                  added = new Vector();
+
+    private ASN1Sequence            seq;
+
+    private boolean                 isHashCodeCalculated;
+    private int                     hashCodeValue;
+
+    /**
+     * Return a X509Name based on the passed in tagged object.
+     * 
+     * @param obj tag object holding name.
+     * @param explicit true if explicitly tagged false otherwise.
+     * @return the X509Name
+     */
+    public static X509Name getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static X509Name getInstance(
+        Object  obj)
+    {
+        if (obj == null || obj instanceof X509Name)
+        {
+            return (X509Name)obj;
+        }
+        else if (obj instanceof X500Name)
+        {
+            return new X509Name(ASN1Sequence.getInstance(((X500Name)obj).getDERObject()));
+        }
+        else if (obj != null)
+        {
+            return new X509Name(ASN1Sequence.getInstance(obj));
+        }
+
+        return null;
+    }
+
+    protected X509Name()
+    {
+        // constructure use by new X500 Name class
+    }
+    /**
+     * Constructor from ASN1Sequence
+     *
+     * the principal will be a list of constructed sets, each containing an (OID, String) pair.
+     */
+    public X509Name(
+        ASN1Sequence  seq)
+    {
+        this.seq = seq;
+
+        Enumeration e = seq.getObjects();
+
+        while (e.hasMoreElements())
+        {
+            ASN1Set         set = ASN1Set.getInstance(((DEREncodable)e.nextElement()).getDERObject());
+
+            for (int i = 0; i &lt; set.size(); i++) 
+            {
+                   ASN1Sequence s = ASN1Sequence.getInstance(set.getObjectAt(i));
+
+                   if (s.size() != 2)
+                   {
+                       throw new IllegalArgumentException(&quot;badly sized pair&quot;);
+                   }
+
+                   ordering.addElement(DERObjectIdentifier.getInstance(s.getObjectAt(0)));
+                   
+                   DEREncodable value = s.getObjectAt(1);
+                   if (value instanceof DERString &amp;&amp; !(value instanceof DERUniversalString))
+                   {
+                       String v = ((DERString)value).getString();
+                       if (v.length() &gt; 0 &amp;&amp; v.charAt(0) == '#')
+                       {
+                           values.addElement(&quot;\\&quot; + v);
+                       }
+                       else
+                       {
+                           values.addElement(v);
+                       }
+                   }
+                   else
+                   {
+                       values.addElement(&quot;#&quot; + bytesToString(Hex.encode(value.getDERObject().getDEREncoded())));
+                   }
+                   added.addElement((i != 0) ? TRUE : FALSE);  // to allow earlier JDK compatibility
+            }
+        }
+    }
+
+    /**
+     * constructor from a table of attributes.
+     * &lt;p&gt;
+     * it's is assumed the table contains OID/String pairs, and the contents
+     * of the table are copied into an internal table as part of the
+     * construction process.
+     * &lt;p&gt;
+     * &lt;b&gt;Note:&lt;/b&gt; if the name you are trying to generate should be
+     * following a specific ordering, you should use the constructor
+     * with the ordering specified below.
+     * @deprecated use an ordered constructor! The hashtable ordering is rarely correct
+     */
+    public X509Name(
+        Hashtable  attributes)
+    {
+        this(null, attributes);
+    }
+
+    /**
+     * Constructor from a table of attributes with ordering.
+     * &lt;p&gt;
+     * it's is assumed the table contains OID/String pairs, and the contents
+     * of the table are copied into an internal table as part of the
+     * construction process. The ordering vector should contain the OIDs
+     * in the order they are meant to be encoded or printed in toString.
+     */
+    public X509Name(
+        Vector      ordering,
+        Hashtable   attributes)
+    {
+        this(ordering, attributes, new X509DefaultEntryConverter());
+    }
+
+    /**
+     * Constructor from a table of attributes with ordering.
+     * &lt;p&gt;
+     * it's is assumed the table contains OID/String pairs, and the contents
+     * of the table are copied into an internal table as part of the
+     * construction process. The ordering vector should contain the OIDs
+     * in the order they are meant to be encoded or printed in toString.
+     * &lt;p&gt;
+     * The passed in converter will be used to convert the strings into their
+     * ASN.1 counterparts.
+     */
+    public X509Name(
+        Vector                   ordering,
+        Hashtable                attributes,
+        X509NameEntryConverter   converter)
+    {
+        this.converter = converter;
+
+        if (ordering != null)
+        {
+            for (int i = 0; i != ordering.size(); i++)
+            {
+                this.ordering.addElement(ordering.elementAt(i));
+                this.added.addElement(FALSE);
+            }
+        }
+        else
+        {
+            Enumeration     e = attributes.keys();
+
+            while (e.hasMoreElements())
+            {
+                this.ordering.addElement(e.nextElement());
+                this.added.addElement(FALSE);
+            }
+        }
+
+        for (int i = 0; i != this.ordering.size(); i++)
+        {
+            DERObjectIdentifier     oid = (DERObjectIdentifier)this.ordering.elementAt(i);
+
+            if (attributes.get(oid) == null)
+            {
+                throw new IllegalArgumentException(&quot;No attribute for object id - &quot; + oid.getId() + &quot; - passed to distinguished name&quot;);
+            }
+
+            this.values.addElement(attributes.get(oid)); // copy the hash table
+        }
+    }
+
+    /**
+     * Takes two vectors one of the oids and the other of the values.
+     */
+    public X509Name(
+        Vector  oids,
+        Vector  values)
+    {
+        this(oids, values, new X509DefaultEntryConverter());
+    }
+
+    /**
+     * Takes two vectors one of the oids and the other of the values.
+     * &lt;p&gt;
+     * The passed in converter will be used to convert the strings into their
+     * ASN.1 counterparts.
+     */
+    public X509Name(
+        Vector                  oids,
+        Vector                  values,
+        X509NameEntryConverter  converter)
+    {
+        this.converter = converter;
+
+        if (oids.size() != values.size())
+        {
+            throw new IllegalArgumentException(&quot;oids vector must be same length as values.&quot;);
+        }
+
+        for (int i = 0; i &lt; oids.size(); i++)
+        {
+            this.ordering.addElement(oids.elementAt(i));
+            this.values.addElement(values.elementAt(i));
+            this.added.addElement(FALSE);
+        }
+    }
+
+//    private Boolean isEncoded(String s)
+//    {
+//        if (s.charAt(0) == '#')
+//        {
+//            return TRUE;
+//        }
+//
+//        return FALSE;
+//    }
+
+    /**
+     * Takes an X509 dir name as a string of the format &quot;C=AU, ST=Victoria&quot;, or
+     * some such, converting it into an ordered set of name attributes.
+     */
+    public X509Name(
+        String  dirName)
+    {
+        this(DefaultReverse, DefaultLookUp, dirName);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format &quot;C=AU, ST=Victoria&quot;, or
+     * some such, converting it into an ordered set of name attributes with each
+     * string value being converted to its associated ASN.1 type using the passed
+     * in converter.
+     */
+    public X509Name(
+        String                  dirName,
+        X509NameEntryConverter  converter)
+    {
+        this(DefaultReverse, DefaultLookUp, dirName, converter);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format &quot;C=AU, ST=Victoria&quot;, or
+     * some such, converting it into an ordered set of name attributes. If reverse
+     * is true, create the encoded version of the sequence starting from the
+     * last element in the string.
+     */
+    public X509Name(
+        boolean reverse,
+        String  dirName)
+    {
+        this(reverse, DefaultLookUp, dirName);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format &quot;C=AU, ST=Victoria&quot;, or
+     * some such, converting it into an ordered set of name attributes with each
+     * string value being converted to its associated ASN.1 type using the passed
+     * in converter. If reverse is true the ASN.1 sequence representing the DN will
+     * be built by starting at the end of the string, rather than the start.
+     */
+    public X509Name(
+        boolean                 reverse,
+        String                  dirName,
+        X509NameEntryConverter  converter)
+    {
+        this(reverse, DefaultLookUp, dirName, converter);
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format &quot;C=AU, ST=Victoria&quot;, or
+     * some such, converting it into an ordered set of name attributes. lookUp
+     * should provide a table of lookups, indexed by lowercase only strings and
+     * yielding a DERObjectIdentifier, other than that OID. and numeric oids
+     * will be processed automatically.
+     * &lt;br&gt;
+     * If reverse is true, create the encoded version of the sequence
+     * starting from the last element in the string.
+     * @param reverse true if we should start scanning from the end (RFC 2553).
+     * @param lookUp table of names and their oids.
+     * @param dirName the X.500 string to be parsed.
+     */
+    public X509Name(
+        boolean     reverse,
+        Hashtable   lookUp,
+        String      dirName)
+    {
+        this(reverse, lookUp, dirName, new X509DefaultEntryConverter());
+    }
+
+    private DERObjectIdentifier decodeOID(
+        String      name,
+        Hashtable   lookUp)
+    {
+        if (Strings.toUpperCase(name).startsWith(&quot;OID.&quot;))
+        {
+            return new DERObjectIdentifier(name.substring(4));
+        }
+        else if (name.charAt(0) &gt;= '0' &amp;&amp; name.charAt(0) &lt;= '9')
+        {
+            return new DERObjectIdentifier(name);
+        }
+
+        DERObjectIdentifier oid = (DERObjectIdentifier)lookUp.get(Strings.toLowerCase(name));
+        if (oid == null)
+        {
+            throw new IllegalArgumentException(&quot;Unknown object id - &quot; + name + &quot; - passed to distinguished name&quot;);
+        }
+
+        return oid;
+    }
+
+    /**
+     * Takes an X509 dir name as a string of the format &quot;C=AU, ST=Victoria&quot;, or
+     * some such, converting it into an ordered set of name attributes. lookUp
+     * should provide a table of lookups, indexed by lowercase only strings and
+     * yielding a DERObjectIdentifier, other than that OID. and numeric oids
+     * will be processed automatically. The passed in converter is used to convert the
+     * string values to the right of each equals sign to their ASN.1 counterparts.
+     * &lt;br&gt;
+     * @param reverse true if we should start scanning from the end, false otherwise.
+     * @param lookUp table of names and oids.
+     * @param dirName the string dirName
+     * @param converter the converter to convert string values into their ASN.1 equivalents
+     */
+    public X509Name(
+        boolean                 reverse,
+        Hashtable               lookUp,
+        String                  dirName,
+        X509NameEntryConverter  converter)
+    {
+        this.converter = converter;
+        X509NameTokenizer   nTok = new X509NameTokenizer(dirName);
+
+        while (nTok.hasMoreTokens())
+        {
+            String  token = nTok.nextToken();
+            int     index = token.indexOf('=');
+
+            if (index == -1)
+            {
+                throw new IllegalArgumentException(&quot;badly formated directory string&quot;);
+            }
+
+            String              name = token.substring(0, index);
+            String              value = token.substring(index + 1);
+            DERObjectIdentifier oid = decodeOID(name, lookUp);
+
+            if (value.indexOf('+') &gt; 0)
+            {
+                X509NameTokenizer   vTok = new X509NameTokenizer(value, '+');
+                String  v = vTok.nextToken();
+
+                this.ordering.addElement(oid);
+                this.values.addElement(v);
+                this.added.addElement(FALSE);
+
+                while (vTok.hasMoreTokens())
+                {
+                    String  sv = vTok.nextToken();
+                    int     ndx = sv.indexOf('=');
+
+                    String  nm = sv.substring(0, ndx);
+                    String  vl = sv.substring(ndx + 1);
+                    this.ordering.addElement(decodeOID(nm, lookUp));
+                    this.values.addElement(vl);
+                    this.added.addElement(TRUE);
+                }
+            }
+            else
+            {
+                this.ordering.addElement(oid);
+                this.values.addElement(value);
+                this.added.addElement(FALSE);
+            }
+        }
+
+        if (reverse)
+        {
+            Vector  o = new Vector();
+            Vector  v = new Vector();
+            Vector  a = new Vector();
+
+            int count = 1;
+
+            for (int i = 0; i &lt; this.ordering.size(); i++)
+            {
+                if (((Boolean)this.added.elementAt(i)).booleanValue())
+                {
+                    o.insertElementAt(this.ordering.elementAt(i), count);
+                    v.insertElementAt(this.values.elementAt(i), count);
+                    a.insertElementAt(this.added.elementAt(i), count);
+                    count++;
+                }
+                else
+                {
+                    o.insertElementAt(this.ordering.elementAt(i), 0);
+                    v.insertElementAt(this.values.elementAt(i), 0);
+                    a.insertElementAt(this.added.elementAt(i), 0);
+                    count = 1;
+                }
+            }
+
+            this.ordering = o;
+            this.values = v;
+            this.added = a;
+        }
+    }
+
+    /**
+     * return a vector of the oids in the name, in the order they were found.
+     */
+    public Vector getOIDs()
+    {
+        Vector  v = new Vector();
+
+        for (int i = 0; i != ordering.size(); i++)
+        {
+            v.addElement(ordering.elementAt(i));
+        }
+
+        return v;
+    }
+
+    /**
+     * return a vector of the values found in the name, in the order they
+     * were found.
+     */
+    public Vector getValues()
+    {
+        Vector  v = new Vector();
+
+        for (int i = 0; i != values.size(); i++)
+        {
+            v.addElement(values.elementAt(i));
+        }
+
+        return v;
+    }
+
+    /**
+     * return a vector of the values found in the name, in the order they
+     * were found, with the DN label corresponding to passed in oid.
+     */
+    public Vector getValues(
+        DERObjectIdentifier oid)
+    {
+        Vector  v = new Vector();
+
+        for (int i = 0; i != values.size(); i++)
+        {
+            if (ordering.elementAt(i).equals(oid))
+            {
+                String val = (String)values.elementAt(i);
+
+                if (val.length() &gt; 2 &amp;&amp; val.charAt(0) == '\\' &amp;&amp; val.charAt(1) == '#')
+                {
+                    v.addElement(val.substring(1));
+                }
+                else
+                {
+                    v.addElement(val);
+                }
+            }
+        }
+
+        return v;
+    }
+
+    public DERObject toASN1Object()
+    {
+        if (seq == null)
+        {
+            ASN1EncodableVector  vec = new ASN1EncodableVector();
+            ASN1EncodableVector  sVec = new ASN1EncodableVector();
+            DERObjectIdentifier  lstOid = null;
+            
+            for (int i = 0; i != ordering.size(); i++)
+            {
+                ASN1EncodableVector     v = new ASN1EncodableVector();
+                DERObjectIdentifier     oid = (DERObjectIdentifier)ordering.elementAt(i);
+
+                v.add(oid);
+
+                String  str = (String)values.elementAt(i);
+
+                v.add(converter.getConvertedValue(oid, str));
+ 
+                if (lstOid == null 
+                    || ((Boolean)this.added.elementAt(i)).booleanValue())
+                {
+                    sVec.add(new DERSequence(v));
+                }
+                else
+                {
+                    vec.add(new DERSet(sVec));
+                    sVec = new ASN1EncodableVector();
+                    
+                    sVec.add(new DERSequence(v));
+                }
+                
+                lstOid = oid;
+            }
+            
+            vec.add(new DERSet(sVec));
+            
+            seq = new DERSequence(vec);
+        }
+
+        return seq;
+    }
+
+    /**
+     * @param inOrder if true the order of both X509 names must be the same,
+     * as well as the values associated with each element.
+     */
+    public boolean equals(Object obj, boolean inOrder)
+    {
+        if (!inOrder)
+        {
+            return this.equals(obj);
+        }
+
+        if (obj == this)
+        {
+            return true;
+        }
+
+        if (!(obj instanceof X509Name || obj instanceof ASN1Sequence))
+        {
+            return false;
+        }
+
+        DERObject derO = ((DEREncodable)obj).getDERObject();
+
+        if (this.getDERObject().equals(derO))
+        {
+            return true;
+        }
+
+        X509Name other;
+
+        try
+        {
+            other = X509Name.getInstance(obj);
+        }
+        catch (IllegalArgumentException e)
+        {
+            return false;
+        }
+
+        int      orderingSize = ordering.size();
+
+        if (orderingSize != other.ordering.size())
+        {
+            return false;
+        }
+
+        for (int i = 0; i &lt; orderingSize; i++)
+        {
+            DERObjectIdentifier  oid = (DERObjectIdentifier)ordering.elementAt(i);
+            DERObjectIdentifier  oOid = (DERObjectIdentifier)other.ordering.elementAt(i);
+
+            if (oid.equals(oOid))
+            {
+                String value = (String)values.elementAt(i);
+                String oValue = (String)other.values.elementAt(i);
+
+                if (!equivalentStrings(value, oValue))
+                {
+                    return false;
+                }
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public int hashCode()
+    {
+        if (isHashCodeCalculated)
+        {
+            return hashCodeValue;
+        }
+
+        isHashCodeCalculated = true;
+
+        // this needs to be order independent, like equals
+        for (int i = 0; i != ordering.size(); i += 1)
+        {
+            String value = (String)values.elementAt(i);
+
+            value = canonicalize(value);
+            value = stripInternalSpaces(value);
+
+            hashCodeValue ^= ordering.elementAt(i).hashCode();
+            hashCodeValue ^= value.hashCode();
+        }
+
+        return hashCodeValue;
+    }
+
+    /**
+     * test for equality - note: case is ignored.
+     */
+    public boolean equals(Object obj)
+    {
+        if (obj == this)
+        {
+            return true;
+        }
+
+        if (!(obj instanceof X509Name || obj instanceof ASN1Sequence))
+        {
+            return false;
+        }
+        
+        DERObject derO = ((DEREncodable)obj).getDERObject();
+        
+        if (this.getDERObject().equals(derO))
+        {
+            return true;
+        }
+
+        X509Name other;
+
+        try
+        {
+            other = X509Name.getInstance(obj);
+        }
+        catch (IllegalArgumentException e)
+        { 
+            return false;
+        }
+
+        int      orderingSize = ordering.size();
+
+        if (orderingSize != other.ordering.size())
+        {
+            return false;
+        }
+        
+        boolean[] indexes = new boolean[orderingSize];
+        int       start, end, delta;
+
+        if (ordering.elementAt(0).equals(other.ordering.elementAt(0)))   // guess forward
+        {
+            start = 0;
+            end = orderingSize;
+            delta = 1;
+        }
+        else  // guess reversed - most common problem
+        {
+            start = orderingSize - 1;
+            end = -1;
+            delta = -1;
+        }
+
+        for (int i = start; i != end; i += delta)
+        {
+            boolean              found = false;
+            DERObjectIdentifier  oid = (DERObjectIdentifier)ordering.elementAt(i);
+            String               value = (String)values.elementAt(i);
+
+            for (int j = 0; j &lt; orderingSize; j++)
+            {
+                if (indexes[j])
+                {
+                    continue;
+                }
+
+                DERObjectIdentifier oOid = (DERObjectIdentifier)other.ordering.elementAt(j);
+
+                if (oid.equals(oOid))
+                {
+                    String oValue = (String)other.values.elementAt(j);
+
+                    if (equivalentStrings(value, oValue))
+                    {
+                        indexes[j] = true;
+                        found      = true;
+                        break;
+                    }
+                }
+            }
+
+            if (!found)
+            {
+                return false;
+            }
+        }
+        
+        return true;
+    }
+
+    private boolean equivalentStrings(String s1, String s2)
+    {
+        String value = canonicalize(s1);
+        String oValue = canonicalize(s2);
+        
+        if (!value.equals(oValue))
+        {
+            value = stripInternalSpaces(value);
+            oValue = stripInternalSpaces(oValue);
+
+            if (!value.equals(oValue))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private String canonicalize(String s)
+    {
+        String value = Strings.toLowerCase(s.trim());
+        
+        if (value.length() &gt; 0 &amp;&amp; value.charAt(0) == '#')
+        {
+            DERObject obj = decodeObject(value);
+
+            if (obj instanceof DERString)
+            {
+                value = Strings.toLowerCase(((DERString)obj).getString().trim());
+            }
+        }
+
+        return value;
+    }
+
+    private ASN1Object decodeObject(String oValue)
+    {
+        try
+        {
+            return ASN1Object.fromByteArray(Hex.decode(oValue.substring(1)));
+        }
+        catch (IOException e)
+        {
+            throw new IllegalStateException(&quot;unknown encoding in name: &quot; + e);
+        }
+    }
+
+    private String stripInternalSpaces(
+        String str)
+    {
+        StringBuffer res = new StringBuffer();
+
+        if (str.length() != 0)
+        {
+            char    c1 = str.charAt(0);
+
+            res.append(c1);
+
+            for (int k = 1; k &lt; str.length(); k++)
+            {
+                char    c2 = str.charAt(k);
+                if (!(c1 == ' ' &amp;&amp; c2 == ' '))
+                {
+                    res.append(c2);
+                }
+                c1 = c2;
+            }
+        }
+
+        return res.toString();
+    }
+
+    private void appendValue(
+        StringBuffer        buf,
+        Hashtable           oidSymbols,
+        DERObjectIdentifier oid,
+        String              value)
+    {
+        String  sym = (String)oidSymbols.get(oid);
+
+        if (sym != null)
+        {
+            buf.append(sym);
+        }
+        else
+        {
+            buf.append(oid.getId());
+        }
+
+        buf.append('=');
+
+        int     index = buf.length();
+        
+        buf.append(value);
+
+        int     end = buf.length();
+
+        if (value.length() &gt;= 2 &amp;&amp; value.charAt(0) == '\\' &amp;&amp; value.charAt(1) == '#')
+        {
+            index += 2;   
+        }
+
+        while (index != end)
+        {
+            if ((buf.charAt(index) == ',')
+               || (buf.charAt(index) == '&quot;')
+               || (buf.charAt(index) == '\\')
+               || (buf.charAt(index) == '+')
+               || (buf.charAt(index) == '=')
+               || (buf.charAt(index) == '&lt;')
+               || (buf.charAt(index) == '&gt;')
+               || (buf.charAt(index) == ';'))
+            {
+                buf.insert(index, &quot;\\&quot;);
+                index++;
+                end++;
+            }
+
+            index++;
+        }
+    }
+
+    /**
+     * convert the structure to a string - if reverse is true the
+     * oids and values are listed out starting with the last element
+     * in the sequence (ala RFC 2253), otherwise the string will begin
+     * with the first element of the structure. If no string definition
+     * for the oid is found in oidSymbols the string value of the oid is
+     * added. Two standard symbol tables are provided DefaultSymbols, and
+     * RFC2253Symbols as part of this class.
+     *
+     * @param reverse if true start at the end of the sequence and work back.
+     * @param oidSymbols look up table strings for oids.
+     */
+    public String toString(
+        boolean     reverse,
+        Hashtable   oidSymbols)
+    {
+        StringBuffer            buf = new StringBuffer();
+        Vector                  components = new Vector();
+        boolean                 first = true;
+
+        StringBuffer ava = null;
+
+        for (int i = 0; i &lt; ordering.size(); i++)
+        {
+            if (((Boolean)added.elementAt(i)).booleanValue())
+            {
+                ava.append('+');
+                appendValue(ava, oidSymbols,
+                    (DERObjectIdentifier)ordering.elementAt(i),
+                    (String)values.elementAt(i));
+            }
+            else
+            {
+                ava = new StringBuffer();
+                appendValue(ava, oidSymbols,
+                    (DERObjectIdentifier)ordering.elementAt(i),
+                    (String)values.elementAt(i));
+                components.addElement(ava);
+            }
+        }
+
+        if (reverse)
+        {
+            for (int i = components.size() - 1; i &gt;= 0; i--)
+            {
+                if (first)
+                {
+                    first = false;
+                }
+                else
+                {
+                    buf.append(',');
+                }
+
+                buf.append(components.elementAt(i).toString());
+            }
+        }
+        else
+        {
+            for (int i = 0; i &lt; components.size(); i++)
+            {
+                if (first)
+                {
+                    first = false;
+                }
+                else
+                {
+                    buf.append(',');
+                }
+
+                buf.append(components.elementAt(i).toString());
+            }
+        }
+
+        return buf.toString();
+    }
+
+    private String bytesToString(
+        byte[] data)
+    {
+        char[]  cs = new char[data.length];
+
+        for (int i = 0; i != cs.length; i++)
+        {
+            cs[i] = (char)(data[i] &amp; 0xff);
+        }
+
+        return new String(cs);
+    }
+    
+    public String toString()
+    {
+        return toString(DefaultReverse, DefaultSymbols);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509NameEntryConverter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,113 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERPrintableString;
+import org.bouncycastle.util.Strings;
+
+import ewe.io.IOException;
+
+/**
+ * It turns out that the number of standard ways the fields in a DN should be 
+ * encoded into their ASN.1 counterparts is rapidly approaching the
+ * number of machines on the internet. By default the X509Name class 
+ * will produce UTF8Strings in line with the current recommendations (RFC 3280).
+ * &lt;p&gt;
+ * An example of an encoder look like below:
+ * &lt;pre&gt;
+ * public class X509DirEntryConverter
+ *     extends X509NameEntryConverter
+ * {
+ *     public DERObject getConvertedValue(
+ *         DERObjectIdentifier  oid,
+ *         String               value)
+ *     {
+ *         if (str.length() != 0 &amp;&amp; str.charAt(0) == '#')
+ *         {
+ *             return convertHexEncoded(str, 1);
+ *         }
+ *         if (oid.equals(EmailAddress))
+ *         {
+ *             return new DERIA5String(str);
+ *         }
+ *         else if (canBePrintable(str))
+ *         {
+ *             return new DERPrintableString(str);
+ *         }
+ *         else if (canBeUTF8(str))
+ *         {
+ *             return new DERUTF8String(str);
+ *         }
+ *         else
+ *         {
+ *             return new DERBMPString(str);
+ *         }
+ *     }
+ * }
+ */
+public abstract class X509NameEntryConverter
+{
+    /**
+     * Convert an inline encoded hex string rendition of an ASN.1
+     * object back into its corresponding ASN.1 object.
+     * 
+     * @param str the hex encoded object
+     * @param off the index at which the encoding starts
+     * @return the decoded object
+     */
+    protected DERObject convertHexEncoded(
+        String  str,
+        int     off)
+        throws IOException
+    {
+        str = Strings.toLowerCase(str);
+        byte[] data = new byte[(str.length() - off) / 2];
+        for (int index = 0; index != data.length; index++)
+        {
+            char left = str.charAt((index * 2) + off);
+            char right = str.charAt((index * 2) + off + 1);
+            
+            if (left &lt; 'a')
+            {
+                data[index] = (byte)((left - '0') &lt;&lt; 4);
+            }
+            else
+            {
+                data[index] = (byte)((left - 'a' + 10) &lt;&lt; 4);
+            }
+            if (right &lt; 'a')
+            {
+                data[index] |= (byte)(right - '0');
+            }
+            else
+            {
+                data[index] |= (byte)(right - 'a' + 10);
+            }
+        }
+
+        ASN1InputStream aIn = new ASN1InputStream(data);
+                                            
+        return aIn.readObject();
+    }
+    
+    /**
+     * return true if the passed in String can be represented without
+     * loss as a PrintableString, false otherwise.
+     */
+    protected boolean canBePrintable(
+        String  str)
+    {
+        return DERPrintableString.isPrintableString(str);
+    }
+    
+    /**
+     * Convert the passed in String value into the appropriate ASN.1
+     * encoded object.
+     * 
+     * @param oid the oid associated with the value in the DN.
+     * @param value the value of the particular DN component.
+     * @return the ASN.1 equivalent for the value.
+     */
+    public abstract DERObject getConvertedValue(DERObjectIdentifier oid, String value);
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509NameTokenizer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,99 @@
+package org.bouncycastle.asn1.x509;
+
+/**
+ * class for breaking up an X500 Name into it's component tokens, ala
+ * java.util.StringTokenizer. We need this class as some of the
+ * lightweight Java environment don't support classes like
+ * StringTokenizer.
+ */
+public class X509NameTokenizer
+{
+    private String          value;
+    private int             index;
+    private char            seperator;
+    private StringBuffer    buf = new StringBuffer();
+
+    public X509NameTokenizer(
+        String  oid)
+    {
+        this(oid, ',');
+    }
+    
+    public X509NameTokenizer(
+        String  oid,
+        char    seperator)
+    {
+        this.value = oid;
+        this.index = -1;
+        this.seperator = seperator;
+    }
+
+    public boolean hasMoreTokens()
+    {
+        return (index != value.length());
+    }
+
+    public String nextToken()
+    {
+        if (index == value.length())
+        {
+            return null;
+        }
+
+        int     end = index + 1;
+        boolean quoted = false;
+        boolean escaped = false;
+
+        buf.setLength(0);
+
+        while (end != value.length())
+        {
+            char    c = value.charAt(end);
+
+            if (c == '&quot;')
+            {
+                if (!escaped)
+                {
+                    quoted = !quoted;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+                escaped = false;
+            }
+            else
+            {
+                if (escaped || quoted)
+                {
+                    if (c == '#' &amp;&amp; buf.charAt(buf.length() - 1) == '=')
+                    {
+                        buf.append('\\');
+                    }
+                    else if (c == '+' &amp;&amp; seperator != '+')
+                    {
+                        buf.append('\\');
+                    }
+                    buf.append(c);
+                    escaped = false;
+                }
+                else if (c == '\\')
+                {
+                    escaped = true;
+                }
+                else if (c == seperator)
+                {
+                    break;
+                }
+                else
+                {
+                    buf.append(c);
+                }
+            }
+            end++;
+        }
+
+        index = end;
+        return buf.toString().trim();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/X509ObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,62 @@
+package org.bouncycastle.asn1.x509;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface X509ObjectIdentifiers
+{
+    //
+    // base id
+    //
+    static final String                 id                      = &quot;2.5.4&quot;;
+
+    static final ASN1ObjectIdentifier    commonName              = new ASN1ObjectIdentifier(id + &quot;.3&quot;);
+    static final ASN1ObjectIdentifier    countryName             = new ASN1ObjectIdentifier(id + &quot;.6&quot;);
+    static final ASN1ObjectIdentifier    localityName            = new ASN1ObjectIdentifier(id + &quot;.7&quot;);
+    static final ASN1ObjectIdentifier    stateOrProvinceName     = new ASN1ObjectIdentifier(id + &quot;.8&quot;);
+    static final ASN1ObjectIdentifier    organization            = new ASN1ObjectIdentifier(id + &quot;.10&quot;);
+    static final ASN1ObjectIdentifier    organizationalUnitName  = new ASN1ObjectIdentifier(id + &quot;.11&quot;);
+
+    static final ASN1ObjectIdentifier    id_at_telephoneNumber   = new ASN1ObjectIdentifier(&quot;2.5.4.20&quot;);
+    static final ASN1ObjectIdentifier    id_at_name              = new ASN1ObjectIdentifier(id + &quot;.41&quot;);
+
+    // id-SHA1 OBJECT IDENTIFIER ::=    
+    //   {iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2) 26 }    //
+    static final ASN1ObjectIdentifier    id_SHA1                 = new ASN1ObjectIdentifier(&quot;1.3.14.3.2.26&quot;);
+
+    //
+    // ripemd160 OBJECT IDENTIFIER ::=
+    //      {iso(1) identified-organization(3) TeleTrust(36) algorithm(3) hashAlgorithm(2) RIPEMD-160(1)}
+    //
+    static final ASN1ObjectIdentifier    ripemd160               = new ASN1ObjectIdentifier(&quot;1.3.36.3.2.1&quot;);
+
+    //
+    // ripemd160WithRSAEncryption OBJECT IDENTIFIER ::=
+    //      {iso(1) identified-organization(3) TeleTrust(36) algorithm(3) signatureAlgorithm(3) rsaSignature(1) rsaSignatureWithripemd160(2) }
+    //
+    static final ASN1ObjectIdentifier    ripemd160WithRSAEncryption = new ASN1ObjectIdentifier(&quot;1.3.36.3.3.1.2&quot;);
+
+
+    static final ASN1ObjectIdentifier    id_ea_rsa = new ASN1ObjectIdentifier(&quot;2.5.8.1.1&quot;);
+    
+    // id-pkix
+    static final ASN1ObjectIdentifier id_pkix = new ASN1ObjectIdentifier(&quot;1.3.6.1.5.5.7&quot;);
+
+    //
+    // private internet extensions
+    //
+    static final ASN1ObjectIdentifier  id_pe = new ASN1ObjectIdentifier(id_pkix + &quot;.1&quot;);
+
+    //
+    // authority information access
+    //
+    static final ASN1ObjectIdentifier  id_ad = new ASN1ObjectIdentifier(id_pkix + &quot;.48&quot;);
+    static final ASN1ObjectIdentifier  id_ad_caIssuers = new ASN1ObjectIdentifier(id_ad + &quot;.2&quot;);
+    static final ASN1ObjectIdentifier  id_ad_ocsp = new ASN1ObjectIdentifier(id_ad + &quot;.1&quot;);
+
+    //
+    //    OID for ocsp and crl uri in AuthorityInformationAccess extension
+    //
+    static final ASN1ObjectIdentifier ocspAccessMethod = id_ad_ocsp;
+    static final ASN1ObjectIdentifier crlAccessMethod = id_ad_caIssuers;
+}
+

Added: trunk/src/org/bouncycastle/asn1/x509/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/x509/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x509/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Support classes useful for encoding and processing X.509 certificates.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/DHDomainParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,139 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.util.Enumeration;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DHDomainParameters
+    extends ASN1Encodable
+{
+    private DERInteger p, g, q, j;
+    private DHValidationParms validationParms;
+
+    public static DHDomainParameters getInstance(ASN1TaggedObject obj, boolean explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static DHDomainParameters getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DHDomainParameters)
+        {
+            return (DHDomainParameters)obj;
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new DHDomainParameters((ASN1Sequence)obj);
+        }
+
+        throw new IllegalArgumentException(&quot;Invalid DHDomainParameters: &quot;
+            + obj.getClass().getName());
+    }
+
+    public DHDomainParameters(DERInteger p, DERInteger g, DERInteger q, DERInteger j,
+        DHValidationParms validationParms)
+    {
+        if (p == null)
+        {
+            throw new IllegalArgumentException(&quot;'p' cannot be null&quot;);
+        }
+        if (g == null)
+        {
+            throw new IllegalArgumentException(&quot;'g' cannot be null&quot;);
+        }
+        if (q == null)
+        {
+            throw new IllegalArgumentException(&quot;'q' cannot be null&quot;);
+        }
+
+        this.p = p;
+        this.g = g;
+        this.q = q;
+        this.j = j;
+        this.validationParms = validationParms;
+    }
+
+    private DHDomainParameters(ASN1Sequence seq)
+    {
+        if (seq.size() &lt; 3 || seq.size() &gt; 5)
+        {
+            throw new IllegalArgumentException(&quot;Bad sequence size: &quot; + seq.size());
+        }
+
+        Enumeration e = seq.getObjects();
+        this.p = DERInteger.getInstance(e.nextElement());
+        this.g = DERInteger.getInstance(e.nextElement());
+        this.q = DERInteger.getInstance(e.nextElement());
+
+        DEREncodable next = getNext(e);
+
+        if (next != null &amp;&amp; next instanceof DERInteger)
+        {
+            this.j = DERInteger.getInstance(next);
+            next = getNext(e);
+        }
+
+        if (next != null)
+        {
+            this.validationParms = DHValidationParms.getInstance(next.getDERObject());
+        }
+    }
+
+    private static DEREncodable getNext(Enumeration e)
+    {
+        return e.hasMoreElements() ? (DEREncodable)e.nextElement() : null;
+    }
+
+    public DERInteger getP()
+    {
+        return this.p;
+    }
+
+    public DERInteger getG()
+    {
+        return this.g;
+    }
+
+    public DERInteger getQ()
+    {
+        return this.q;
+    }
+
+    public DERInteger getJ()
+    {
+        return this.j;
+    }
+
+    public DHValidationParms getValidationParms()
+    {
+        return this.validationParms;
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        v.add(this.p);
+        v.add(this.g);
+        v.add(this.q);
+
+        if (this.j != null)
+        {
+            v.add(this.j);
+        }
+
+        if (this.validationParms != null)
+        {
+            v.add(this.validationParms);
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/DHPublicKey.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,52 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+
+public class DHPublicKey
+    extends ASN1Encodable
+{
+    private DERInteger y;
+
+    public static DHPublicKey getInstance(ASN1TaggedObject obj, boolean explicit)
+    {
+        return getInstance(DERInteger.getInstance(obj, explicit));
+    }
+
+    public static DHPublicKey getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DHPublicKey)
+        {
+            return (DHPublicKey)obj;
+        }
+
+        if (obj instanceof DERInteger)
+        {
+            return new DHPublicKey((DERInteger)obj);
+        }
+
+        throw new IllegalArgumentException(&quot;Invalid DHPublicKey: &quot; + obj.getClass().getName());
+    }
+
+    public DHPublicKey(DERInteger y)
+    {
+        if (y == null)
+        {
+            throw new IllegalArgumentException(&quot;'y' cannot be null&quot;);
+        }
+
+        this.y = y;
+    }
+
+    public DERInteger getY()
+    {
+        return this.y;
+    }
+
+    public DERObject toASN1Object()
+    {
+        return this.y;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/DHValidationParms.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,80 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+
+public class DHValidationParms extends ASN1Encodable
+{
+    private DERBitString seed;
+    private DERInteger pgenCounter;
+
+    public static DHValidationParms getInstance(ASN1TaggedObject obj, boolean explicit)
+    {
+        return getInstance(ASN1Sequence.getInstance(obj, explicit));
+    }
+
+    public static DHValidationParms getInstance(Object obj)
+    {
+        if (obj == null || obj instanceof DHDomainParameters)
+        {
+            return (DHValidationParms)obj;
+        }
+
+        if (obj instanceof ASN1Sequence)
+        {
+            return new DHValidationParms((ASN1Sequence)obj);
+        }
+
+        throw new IllegalArgumentException(&quot;Invalid DHValidationParms: &quot; + obj.getClass().getName());
+    }
+
+    public DHValidationParms(DERBitString seed, DERInteger pgenCounter)
+    {
+        if (seed == null)
+        {
+            throw new IllegalArgumentException(&quot;'seed' cannot be null&quot;);
+        }
+        if (pgenCounter == null)
+        {
+            throw new IllegalArgumentException(&quot;'pgenCounter' cannot be null&quot;);
+        }
+
+        this.seed = seed;
+        this.pgenCounter = pgenCounter;
+    }
+
+    private DHValidationParms(ASN1Sequence seq)
+    {
+        if (seq.size() != 2)
+        {
+            throw new IllegalArgumentException(&quot;Bad sequence size: &quot; + seq.size());
+        }
+
+        this.seed = DERBitString.getInstance(seq.getObjectAt(0));
+        this.pgenCounter = DERInteger.getInstance(seq.getObjectAt(1));
+    }
+
+    public DERBitString getSeed()
+    {
+        return this.seed;
+    }
+
+    public DERInteger getPgenCounter()
+    {
+        return this.pgenCounter;
+    }
+
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        v.add(this.seed);
+        v.add(this.pgenCounter);
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$1.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$10.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$11.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$12.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$13.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$14.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$15.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$16.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$17.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$18.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$19.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$2.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$20.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$21.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$22.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$23.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$3.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$4.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$5.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$6.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$7.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$8.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves$9.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X962NamedCurves.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,621 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.encoders.Hex;
+
+import ewe.math.BigInteger;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+
+
+/**
+ * table of the current named curves defined in X.962 EC-DSA.
+ */
+public class X962NamedCurves
+{
+    static X9ECParametersHolder prime192v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp192v1 = new ECCurve.Fp(
+                new BigInteger(&quot;6277101735386680763835789423207666416083908700390324961279&quot;),
+                new BigInteger(&quot;fffffffffffffffffffffffffffffffefffffffffffffffc&quot;, 16),
+                new BigInteger(&quot;64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1&quot;, 16));
+
+            return new X9ECParameters(
+                cFp192v1,
+                cFp192v1.decodePoint(
+                    Hex.decode(&quot;03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012&quot;)),
+                new BigInteger(&quot;ffffffffffffffffffffffff99def836146bc9b1b4d22831&quot;, 16),
+                BigInteger.valueOf(1),
+                Hex.decode(&quot;3045AE6FC8422f64ED579528D38120EAE12196D5&quot;));
+        }
+    };
+
+    static X9ECParametersHolder prime192v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp192v2 = new ECCurve.Fp(
+                new BigInteger(&quot;6277101735386680763835789423207666416083908700390324961279&quot;),
+                new BigInteger(&quot;fffffffffffffffffffffffffffffffefffffffffffffffc&quot;, 16),
+                new BigInteger(&quot;cc22d6dfb95c6b25e49c0d6364a4e5980c393aa21668d953&quot;, 16));
+
+            return new X9ECParameters(
+                cFp192v2,
+                cFp192v2.decodePoint(
+                    Hex.decode(&quot;03eea2bae7e1497842f2de7769cfe9c989c072ad696f48034a&quot;)),
+                new BigInteger(&quot;fffffffffffffffffffffffe5fb1a724dc80418648d8dd31&quot;, 16),
+                BigInteger.valueOf(1),
+                Hex.decode(&quot;31a92ee2029fd10d901b113e990710f0d21ac6b6&quot;));
+        }
+    };
+
+    static X9ECParametersHolder prime192v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp192v3 = new ECCurve.Fp(
+                new BigInteger(&quot;6277101735386680763835789423207666416083908700390324961279&quot;),
+                new BigInteger(&quot;fffffffffffffffffffffffffffffffefffffffffffffffc&quot;, 16),
+                new BigInteger(&quot;22123dc2395a05caa7423daeccc94760a7d462256bd56916&quot;, 16));
+
+            return new X9ECParameters(
+                cFp192v3,
+                cFp192v3.decodePoint(
+                    Hex.decode(&quot;027d29778100c65a1da1783716588dce2b8b4aee8e228f1896&quot;)),
+                new BigInteger(&quot;ffffffffffffffffffffffff7a62d031c83f4294f640ec13&quot;, 16),
+                BigInteger.valueOf(1),
+                Hex.decode(&quot;c469684435deb378c4b65ca9591e2a5763059a2e&quot;));
+        }
+    };
+
+    static X9ECParametersHolder prime239v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp239v1 = new ECCurve.Fp(
+                new BigInteger(&quot;883423532389192164791648750360308885314476597252960362792450860609699839&quot;),
+                new BigInteger(&quot;7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc&quot;, 16),
+                new BigInteger(&quot;6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a&quot;, 16));
+
+            return new X9ECParameters(
+                cFp239v1,
+                cFp239v1.decodePoint(
+                    Hex.decode(&quot;020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf&quot;)),
+                new BigInteger(&quot;7fffffffffffffffffffffff7fffff9e5e9a9f5d9071fbd1522688909d0b&quot;, 16),
+                BigInteger.valueOf(1),
+                Hex.decode(&quot;e43bb460f0b80cc0c0b075798e948060f8321b7d&quot;));
+        }
+    };
+
+    static X9ECParametersHolder prime239v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp239v2 = new ECCurve.Fp(
+                new BigInteger(&quot;883423532389192164791648750360308885314476597252960362792450860609699839&quot;),
+                new BigInteger(&quot;7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc&quot;, 16),
+                new BigInteger(&quot;617fab6832576cbbfed50d99f0249c3fee58b94ba0038c7ae84c8c832f2c&quot;, 16));
+
+            return new X9ECParameters(
+                cFp239v2,
+                cFp239v2.decodePoint(
+                    Hex.decode(&quot;0238af09d98727705120c921bb5e9e26296a3cdcf2f35757a0eafd87b830e7&quot;)),
+                new BigInteger(&quot;7fffffffffffffffffffffff800000cfa7e8594377d414c03821bc582063&quot;, 16),
+                BigInteger.valueOf(1),
+                Hex.decode(&quot;e8b4011604095303ca3b8099982be09fcb9ae616&quot;));
+        }
+    };
+
+    static X9ECParametersHolder prime239v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp239v3 = new ECCurve.Fp(
+                new BigInteger(&quot;883423532389192164791648750360308885314476597252960362792450860609699839&quot;),
+                new BigInteger(&quot;7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc&quot;, 16),
+                new BigInteger(&quot;255705fa2a306654b1f4cb03d6a750a30c250102d4988717d9ba15ab6d3e&quot;, 16));
+
+            return new X9ECParameters(
+                cFp239v3,
+                cFp239v3.decodePoint(
+                    Hex.decode(&quot;036768ae8e18bb92cfcf005c949aa2c6d94853d0e660bbf854b1c9505fe95a&quot;)),
+                new BigInteger(&quot;7fffffffffffffffffffffff7fffff975deb41b3a6057c3c432146526551&quot;, 16),
+                BigInteger.valueOf(1),
+                Hex.decode(&quot;7d7374168ffe3471b60a857686a19475d3bfa2ff&quot;));
+        }
+    };
+
+    static X9ECParametersHolder prime256v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            ECCurve cFp256v1 = new ECCurve.Fp(
+                new BigInteger(&quot;115792089210356248762697446949407573530086143415290314195533631308867097853951&quot;),
+                new BigInteger(&quot;ffffffff00000001000000000000000000000000fffffffffffffffffffffffc&quot;, 16),
+                new BigInteger(&quot;5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b&quot;, 16));
+
+            return new X9ECParameters(
+                cFp256v1,
+                cFp256v1.decodePoint(
+                    Hex.decode(&quot;036b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296&quot;)),
+                new BigInteger(&quot;ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551&quot;, 16),
+                BigInteger.valueOf(1),
+                Hex.decode(&quot;c49d360886e704936a6678e1139d26b7819f7e90&quot;));
+        }
+    };
+
+    /*
+     * F2m Curves
+     */
+    static X9ECParametersHolder c2pnb163v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m163v1n = new BigInteger(&quot;0400000000000000000001E60FC8821CC74DAEAFC1&quot;, 16);
+            BigInteger c2m163v1h = BigInteger.valueOf(2);
+
+            ECCurve c2m163v1 = new ECCurve.F2m(
+                163,
+                1, 2, 8,
+                new BigInteger(&quot;072546B5435234A422E0789675F432C89435DE5242&quot;, 16),
+                new BigInteger(&quot;00C9517D06D5240D3CFF38C74B20B6CD4D6F9DD4D9&quot;, 16),
+                c2m163v1n, c2m163v1h);
+
+            return new X9ECParameters(
+                c2m163v1,
+                c2m163v1.decodePoint(
+                    Hex.decode(&quot;0307AF69989546103D79329FCC3D74880F33BBE803CB&quot;)),
+                c2m163v1n, c2m163v1h,
+                Hex.decode(&quot;D2COFB15760860DEF1EEF4D696E6768756151754&quot;));
+        }
+    };
+
+    static X9ECParametersHolder c2pnb163v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m163v2n = new BigInteger(&quot;03FFFFFFFFFFFFFFFFFFFDF64DE1151ADBB78F10A7&quot;, 16);
+            BigInteger c2m163v2h = BigInteger.valueOf(2);
+
+            ECCurve c2m163v2 = new ECCurve.F2m(
+                163,
+                1, 2, 8,
+                new BigInteger(&quot;0108B39E77C4B108BED981ED0E890E117C511CF072&quot;, 16),
+                new BigInteger(&quot;0667ACEB38AF4E488C407433FFAE4F1C811638DF20&quot;, 16),
+                c2m163v2n, c2m163v2h);
+
+            return new X9ECParameters(
+                c2m163v2,
+                c2m163v2.decodePoint(
+                    Hex.decode(&quot;030024266E4EB5106D0A964D92C4860E2671DB9B6CC5&quot;)),
+                c2m163v2n, c2m163v2h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb163v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m163v3n = new BigInteger(&quot;03FFFFFFFFFFFFFFFFFFFE1AEE140F110AFF961309&quot;, 16);
+            BigInteger c2m163v3h = BigInteger.valueOf(2);
+
+            ECCurve c2m163v3 = new ECCurve.F2m(
+                163,
+                1, 2, 8,
+                new BigInteger(&quot;07A526C63D3E25A256A007699F5447E32AE456B50E&quot;, 16),
+                new BigInteger(&quot;03F7061798EB99E238FD6F1BF95B48FEEB4854252B&quot;, 16),
+                c2m163v3n, c2m163v3h);
+
+            return new X9ECParameters(
+                c2m163v3,
+                c2m163v3.decodePoint(
+                    Hex.decode(&quot;0202F9F87B7C574D0BDECF8A22E6524775F98CDEBDCB&quot;)),
+                c2m163v3n, c2m163v3h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb176w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m176w1n = new BigInteger(&quot;010092537397ECA4F6145799D62B0A19CE06FE26AD&quot;, 16);
+            BigInteger c2m176w1h = BigInteger.valueOf(0xFF6E);
+
+            ECCurve c2m176w1 = new ECCurve.F2m(
+                176,
+                1, 2, 43,
+                new BigInteger(&quot;00E4E6DB2995065C407D9D39B8D0967B96704BA8E9C90B&quot;, 16),
+                new BigInteger(&quot;005DDA470ABE6414DE8EC133AE28E9BBD7FCEC0AE0FFF2&quot;, 16),
+                c2m176w1n, c2m176w1h);
+
+            return new X9ECParameters(
+                c2m176w1,
+                c2m176w1.decodePoint(
+                    Hex.decode(&quot;038D16C2866798B600F9F08BB4A8E860F3298CE04A5798&quot;)),
+                c2m176w1n, c2m176w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb191v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m191v1n = new BigInteger(&quot;40000000000000000000000004A20E90C39067C893BBB9A5&quot;, 16);
+            BigInteger c2m191v1h = BigInteger.valueOf(2);
+
+            ECCurve c2m191v1 = new ECCurve.F2m(
+                191,
+                9,
+                new BigInteger(&quot;2866537B676752636A68F56554E12640276B649EF7526267&quot;, 16),
+                new BigInteger(&quot;2E45EF571F00786F67B0081B9495A3D95462F5DE0AA185EC&quot;, 16),
+                c2m191v1n, c2m191v1h);
+
+            return new X9ECParameters(
+                c2m191v1,
+                c2m191v1.decodePoint(
+                    Hex.decode(&quot;0236B3DAF8A23206F9C4F299D7B21A9C369137F2C84AE1AA0D&quot;)),
+                c2m191v1n, c2m191v1h,
+                Hex.decode(&quot;4E13CA542744D696E67687561517552F279A8C84&quot;));
+        }
+    };
+
+    static X9ECParametersHolder c2tnb191v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m191v2n = new BigInteger(&quot;20000000000000000000000050508CB89F652824E06B8173&quot;, 16);
+            BigInteger c2m191v2h = BigInteger.valueOf(4);
+
+            ECCurve c2m191v2 = new ECCurve.F2m(
+                191,
+                9,
+                new BigInteger(&quot;401028774D7777C7B7666D1366EA432071274F89FF01E718&quot;, 16),
+                new BigInteger(&quot;0620048D28BCBD03B6249C99182B7C8CD19700C362C46A01&quot;, 16),
+                c2m191v2n, c2m191v2h);
+
+            return new X9ECParameters(
+                c2m191v2,
+                c2m191v2.decodePoint(
+                    Hex.decode(&quot;023809B2B7CC1B28CC5A87926AAD83FD28789E81E2C9E3BF10&quot;)),
+                c2m191v2n, c2m191v2h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb191v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m191v3n = new BigInteger(&quot;155555555555555555555555610C0B196812BFB6288A3EA3&quot;, 16);
+            BigInteger c2m191v3h = BigInteger.valueOf(6);
+
+            ECCurve c2m191v3 = new ECCurve.F2m(
+                191,
+                9,
+                new BigInteger(&quot;6C01074756099122221056911C77D77E77A777E7E7E77FCB&quot;, 16),
+                new BigInteger(&quot;71FE1AF926CF847989EFEF8DB459F66394D90F32AD3F15E8&quot;, 16),
+                c2m191v3n, c2m191v3h);
+
+            return new X9ECParameters(
+                c2m191v3,
+                c2m191v3.decodePoint(
+                    Hex.decode(&quot;03375D4CE24FDE434489DE8746E71786015009E66E38A926DD&quot;)),
+                c2m191v3n, c2m191v3h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb208w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m208w1n = new BigInteger(&quot;0101BAF95C9723C57B6C21DA2EFF2D5ED588BDD5717E212F9D&quot;, 16);
+            BigInteger c2m208w1h = BigInteger.valueOf(0xFE48);
+
+            ECCurve c2m208w1 = new ECCurve.F2m(
+                208,
+                1, 2, 83,
+                new BigInteger(&quot;0&quot;, 16),
+                new BigInteger(&quot;00C8619ED45A62E6212E1160349E2BFA844439FAFC2A3FD1638F9E&quot;, 16),
+                c2m208w1n, c2m208w1h);
+
+            return new X9ECParameters(
+                c2m208w1,
+                c2m208w1.decodePoint(
+                    Hex.decode(&quot;0289FDFBE4ABE193DF9559ECF07AC0CE78554E2784EB8C1ED1A57A&quot;)),
+                c2m208w1n, c2m208w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb239v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m239v1n = new BigInteger(&quot;2000000000000000000000000000000F4D42FFE1492A4993F1CAD666E447&quot;, 16);
+            BigInteger c2m239v1h = BigInteger.valueOf(4);
+
+            ECCurve c2m239v1 = new ECCurve.F2m(
+                239,
+                36,
+                new BigInteger(&quot;32010857077C5431123A46B808906756F543423E8D27877578125778AC76&quot;, 16),
+                new BigInteger(&quot;790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16&quot;, 16),
+                c2m239v1n, c2m239v1h);
+
+            return new X9ECParameters(
+                c2m239v1,
+                c2m239v1.decodePoint(
+                    Hex.decode(&quot;0257927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D&quot;)),
+                c2m239v1n, c2m239v1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb239v2 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m239v2n = new BigInteger(&quot;1555555555555555555555555555553C6F2885259C31E3FCDF154624522D&quot;, 16);
+            BigInteger c2m239v2h = BigInteger.valueOf(6);
+
+            ECCurve c2m239v2 = new ECCurve.F2m(
+                239,
+                36,
+                new BigInteger(&quot;4230017757A767FAE42398569B746325D45313AF0766266479B75654E65F&quot;, 16),
+                new BigInteger(&quot;5037EA654196CFF0CD82B2C14A2FCF2E3FF8775285B545722F03EACDB74B&quot;, 16),
+                c2m239v2n, c2m239v2h);
+
+            return new X9ECParameters(
+                c2m239v2,
+                c2m239v2.decodePoint(
+                    Hex.decode(&quot;0228F9D04E900069C8DC47A08534FE76D2B900B7D7EF31F5709F200C4CA205&quot;)),
+                c2m239v2n, c2m239v2h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb239v3 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m239v3n = new BigInteger(&quot;0CCCCCCCCCCCCCCCCCCCCCCCCCCCCCAC4912D2D9DF903EF9888B8A0E4CFF&quot;, 16);
+            BigInteger c2m239v3h = BigInteger.valueOf(10);
+
+            ECCurve c2m239v3 = new ECCurve.F2m(
+                239,
+                36,
+                new BigInteger(&quot;01238774666A67766D6676F778E676B66999176666E687666D8766C66A9F&quot;, 16),
+                new BigInteger(&quot;6A941977BA9F6A435199ACFC51067ED587F519C5ECB541B8E44111DE1D40&quot;, 16),
+                c2m239v3n, c2m239v3h);
+
+            return new X9ECParameters(
+                c2m239v3,
+                c2m239v3.decodePoint(
+                    Hex.decode(&quot;0370F6E9D04D289C4E89913CE3530BFDE903977D42B146D539BF1BDE4E9C92&quot;)),
+                c2m239v3n, c2m239v3h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb272w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m272w1n = new BigInteger(&quot;0100FAF51354E0E39E4892DF6E319C72C8161603FA45AA7B998A167B8F1E629521&quot;, 16);
+            BigInteger c2m272w1h = BigInteger.valueOf(0xFF06);
+
+            ECCurve c2m272w1 = new ECCurve.F2m(
+                272,
+                1, 3, 56,
+                new BigInteger(&quot;0091A091F03B5FBA4AB2CCF49C4EDD220FB028712D42BE752B2C40094DBACDB586FB20&quot;, 16),
+                new BigInteger(&quot;7167EFC92BB2E3CE7C8AAAFF34E12A9C557003D7C73A6FAF003F99F6CC8482E540F7&quot;, 16),
+                c2m272w1n, c2m272w1h);
+
+            return new X9ECParameters(
+                c2m272w1,
+                c2m272w1.decodePoint(
+                    Hex.decode(&quot;026108BABB2CEEBCF787058A056CBE0CFE622D7723A289E08A07AE13EF0D10D171DD8D&quot;)),
+                c2m272w1n, c2m272w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb304w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m304w1n = new BigInteger(&quot;0101D556572AABAC800101D556572AABAC8001022D5C91DD173F8FB561DA6899164443051D&quot;, 16);
+            BigInteger c2m304w1h = BigInteger.valueOf(0xFE2E);
+
+            ECCurve c2m304w1 = new ECCurve.F2m(
+                304,
+                1, 2, 11,
+                new BigInteger(&quot;00FD0D693149A118F651E6DCE6802085377E5F882D1B510B44160074C1288078365A0396C8E681&quot;, 16),
+                new BigInteger(&quot;00BDDB97E555A50A908E43B01C798EA5DAA6788F1EA2794EFCF57166B8C14039601E55827340BE&quot;, 16),
+                c2m304w1n, c2m304w1h);
+
+            return new X9ECParameters(
+                c2m304w1,
+                c2m304w1.decodePoint(
+                    Hex.decode(&quot;02197B07845E9BE2D96ADB0F5F3C7F2CFFBD7A3EB8B6FEC35C7FD67F26DDF6285A644F740A2614&quot;)),
+                c2m304w1n, c2m304w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb359v1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m359v1n = new BigInteger(&quot;01AF286BCA1AF286BCA1AF286BCA1AF286BCA1AF286BC9FB8F6B85C556892C20A7EB964FE7719E74F490758D3B&quot;, 16);
+            BigInteger c2m359v1h = BigInteger.valueOf(0x4C);
+
+            ECCurve c2m359v1 = new ECCurve.F2m(
+                359,
+                68,
+                new BigInteger(&quot;5667676A654B20754F356EA92017D946567C46675556F19556A04616B567D223A5E05656FB549016A96656A557&quot;, 16),
+                new BigInteger(&quot;2472E2D0197C49363F1FE7F5B6DB075D52B6947D135D8CA445805D39BC345626089687742B6329E70680231988&quot;, 16),
+                c2m359v1n, c2m359v1h);
+
+            return new X9ECParameters(
+                c2m359v1,
+                c2m359v1.decodePoint(
+                    Hex.decode(&quot;033C258EF3047767E7EDE0F1FDAA79DAEE3841366A132E163ACED4ED2401DF9C6BDCDE98E8E707C07A2239B1B097&quot;)),
+                c2m359v1n, c2m359v1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2pnb368w1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m368w1n = new BigInteger(&quot;010090512DA9AF72B08349D98A5DD4C7B0532ECA51CE03E2D10F3B7AC579BD87E909AE40A6F131E9CFCE5BD967&quot;, 16);
+            BigInteger c2m368w1h = BigInteger.valueOf(0xFF70);
+
+            ECCurve c2m368w1 = new ECCurve.F2m(
+                368,
+                1, 2, 85,
+                new BigInteger(&quot;00E0D2EE25095206F5E2A4F9ED229F1F256E79A0E2B455970D8D0D865BD94778C576D62F0AB7519CCD2A1A906AE30D&quot;, 16),
+                new BigInteger(&quot;00FC1217D4320A90452C760A58EDCD30C8DD069B3C34453837A34ED50CB54917E1C2112D84D164F444F8F74786046A&quot;, 16),
+                c2m368w1n, c2m368w1h);
+
+            return new X9ECParameters(
+                c2m368w1,
+                c2m368w1.decodePoint(
+                    Hex.decode(&quot;021085E2755381DCCCE3C1557AFA10C2F0C0C2825646C5B34A394CBCFA8BC16B22E7E789E927BE216F02E1FB136A5F&quot;)),
+                c2m368w1n, c2m368w1h,
+                null);
+        }
+    };
+
+    static X9ECParametersHolder c2tnb431r1 = new X9ECParametersHolder()
+    {
+        protected X9ECParameters createParameters()
+        {
+            BigInteger c2m431r1n = new BigInteger(&quot;0340340340340340340340340340340340340340340340340340340323C313FAB50589703B5EC68D3587FEC60D161CC149C1AD4A91&quot;, 16);
+            BigInteger c2m431r1h = BigInteger.valueOf(0x2760);
+
+            ECCurve c2m431r1 = new ECCurve.F2m(
+                431,
+                120,
+                new BigInteger(&quot;1A827EF00DD6FC0E234CAF046C6A5D8A85395B236CC4AD2CF32A0CADBDC9DDF620B0EB9906D0957F6C6FEACD615468DF104DE296CD8F&quot;, 16),
+                new BigInteger(&quot;10D9B4A3D9047D8B154359ABFB1B7F5485B04CEB868237DDC9DEDA982A679A5A919B626D4E50A8DD731B107A9962381FB5D807BF2618&quot;, 16),
+                c2m431r1n, c2m431r1h);
+
+            return new X9ECParameters(
+                c2m431r1,
+                c2m431r1.decodePoint(
+                    Hex.decode(&quot;02120FC05D3C67A99DE161D2F4092622FECA701BE4F50F4758714E8A87BBF2A658EF8C21E7C5EFE965361F6C2999C0C247B0DBD70CE6B7&quot;)),
+                c2m431r1n, c2m431r1h,
+                null);
+        }
+    };
+
+    static final Hashtable objIds = new Hashtable();
+    static final Hashtable curves = new Hashtable();
+    static final Hashtable names = new Hashtable();
+
+    static void defineCurve(String name, DERObjectIdentifier oid, X9ECParametersHolder holder)
+    {
+        objIds.put(name, oid);
+        names.put(oid, name);
+        curves.put(oid, holder);
+    }
+
+    static
+    {
+        defineCurve(&quot;prime192v1&quot;, X9ObjectIdentifiers.prime192v1, prime192v1);
+        defineCurve(&quot;prime192v2&quot;, X9ObjectIdentifiers.prime192v2, prime192v2);
+        defineCurve(&quot;prime192v3&quot;, X9ObjectIdentifiers.prime192v3, prime192v3);
+        defineCurve(&quot;prime239v1&quot;, X9ObjectIdentifiers.prime239v1, prime239v1);
+        defineCurve(&quot;prime239v2&quot;, X9ObjectIdentifiers.prime239v2, prime239v2);
+        defineCurve(&quot;prime239v3&quot;, X9ObjectIdentifiers.prime239v3, prime239v3);
+        defineCurve(&quot;prime256v1&quot;, X9ObjectIdentifiers.prime256v1, prime256v1);
+        defineCurve(&quot;c2pnb163v1&quot;, X9ObjectIdentifiers.c2pnb163v1, c2pnb163v1);
+        defineCurve(&quot;c2pnb163v2&quot;, X9ObjectIdentifiers.c2pnb163v2, c2pnb163v2);
+        defineCurve(&quot;c2pnb163v3&quot;, X9ObjectIdentifiers.c2pnb163v3, c2pnb163v3);
+        defineCurve(&quot;c2pnb176w1&quot;, X9ObjectIdentifiers.c2pnb176w1, c2pnb176w1);
+        defineCurve(&quot;c2tnb191v1&quot;, X9ObjectIdentifiers.c2tnb191v1, c2tnb191v1);
+        defineCurve(&quot;c2tnb191v2&quot;, X9ObjectIdentifiers.c2tnb191v2, c2tnb191v2);
+        defineCurve(&quot;c2tnb191v3&quot;, X9ObjectIdentifiers.c2tnb191v3, c2tnb191v3);
+        defineCurve(&quot;c2pnb208w1&quot;, X9ObjectIdentifiers.c2pnb208w1, c2pnb208w1);
+        defineCurve(&quot;c2tnb239v1&quot;, X9ObjectIdentifiers.c2tnb239v1, c2tnb239v1);
+        defineCurve(&quot;c2tnb239v2&quot;, X9ObjectIdentifiers.c2tnb239v2, c2tnb239v2);
+        defineCurve(&quot;c2tnb239v3&quot;, X9ObjectIdentifiers.c2tnb239v3, c2tnb239v3);
+        defineCurve(&quot;c2pnb272w1&quot;, X9ObjectIdentifiers.c2pnb272w1, c2pnb272w1);
+        defineCurve(&quot;c2pnb304w1&quot;, X9ObjectIdentifiers.c2pnb304w1, c2pnb304w1);
+        defineCurve(&quot;c2tnb359v1&quot;, X9ObjectIdentifiers.c2tnb359v1, c2tnb359v1);
+        defineCurve(&quot;c2pnb368w1&quot;, X9ObjectIdentifiers.c2pnb368w1, c2pnb368w1);
+        defineCurve(&quot;c2tnb431r1&quot;, X9ObjectIdentifiers.c2tnb431r1, c2tnb431r1);
+    }
+
+    public static X9ECParameters getByName(
+        String name)
+    {
+        DERObjectIdentifier oid = (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+
+        if (oid != null)
+        {
+            return getByOID(oid);
+        }
+
+        return null;
+    }
+
+    /**
+     * return the X9ECParameters object for the named curve represented by
+     * the passed in object identifier. Null if the curve isn't present.
+     *
+     * @param oid an object identifier representing a named curve, if present.
+     */
+    public static X9ECParameters getByOID(
+        DERObjectIdentifier oid)
+    {
+        X9ECParametersHolder holder = (X9ECParametersHolder)curves.get(oid);
+
+        if (holder != null)
+        {
+            return holder.getParameters();
+        }
+
+        return null;
+    }
+
+    /**
+     * return the object identifier signified by the passed in name. Null
+     * if there is no object identifier associated with name.
+     *
+     * @return the object identifier associated with name, if present.
+     */
+    public static DERObjectIdentifier getOID(
+        String name)
+    {
+        return (DERObjectIdentifier)objIds.get(Strings.toLowerCase(name));
+    }
+
+    /**
+     * return the named curve name represented by the given object identifier.
+     */
+    public static String getName(
+        DERObjectIdentifier oid)
+    {
+        return (String)names.get(oid);
+    }
+
+    /**
+     * returns an enumeration containing the name strings for curves
+     * contained in this structure.
+     */
+    public static Enumeration getNames()
+    {
+        return objIds.keys();
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X962Parameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X962Parameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,86 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Choice;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1Null;
+import org.bouncycastle.asn1.ASN1TaggedObject;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+
+public class X962Parameters
+    extends ASN1Encodable
+    implements ASN1Choice
+{
+    private DERObject           params = null;
+
+    public static X962Parameters getInstance(
+        Object obj)
+    {
+        if (obj == null || obj instanceof X962Parameters) 
+        {
+            return (X962Parameters)obj;
+        }
+        
+        if (obj instanceof DERObject) 
+        {
+            return new X962Parameters((DERObject)obj);
+        }
+        
+        throw new IllegalArgumentException(&quot;unknown object in getInstance()&quot;);
+    }
+    
+    public static X962Parameters getInstance(
+        ASN1TaggedObject obj,
+        boolean          explicit)
+    {
+        return getInstance(obj.getObject()); // must be explicitly tagged
+    }
+    
+    public X962Parameters(
+        X9ECParameters      ecParameters)
+    {
+        this.params = ecParameters.getDERObject();
+    }
+
+    public X962Parameters(
+        DERObjectIdentifier  namedCurve)
+    {
+        this.params = namedCurve;
+    }
+
+    public X962Parameters(
+        DERObject           obj)
+    {
+        this.params = obj;
+    }
+
+    public boolean isNamedCurve()
+    {
+        return (params instanceof DERObjectIdentifier);
+    }
+
+    public boolean isImplicitlyCA()
+    {
+        return (params instanceof ASN1Null);
+    }
+
+    public DERObject getParameters()
+    {
+        return params;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     * Parameters ::= CHOICE {
+     *    ecParameters ECParameters,
+     *    namedCurve   CURVES.&amp;id({CurveNames}),
+     *    implicitlyCA NULL
+     * }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        return params;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9Curve.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9Curve.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9Curve.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9Curve.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,161 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.math.ec.ECCurve;
+
+/**
+ * ASN.1 def for Elliptic-Curve Curve structure. See
+ * X9.62, for further details.
+ */
+public class X9Curve
+    extends ASN1Encodable
+    implements X9ObjectIdentifiers
+{
+    private ECCurve     curve;
+    private byte[]      seed;
+    private DERObjectIdentifier fieldIdentifier = null;
+
+    public X9Curve(
+        ECCurve     curve)
+    {
+        this.curve = curve;
+        this.seed = null;
+        setFieldIdentifier();
+    }
+
+    public X9Curve(
+        ECCurve     curve,
+        byte[]      seed)
+    {
+        this.curve = curve;
+        this.seed = seed;
+        setFieldIdentifier();
+    }
+
+    public X9Curve(
+        X9FieldID     fieldID,
+        ASN1Sequence  seq)
+    {
+        fieldIdentifier = fieldID.getIdentifier();
+        if (fieldIdentifier.equals(prime_field))
+        {
+            BigInteger      p = ((DERInteger)fieldID.getParameters()).getValue();
+            X9FieldElement  x9A = new X9FieldElement(p, (ASN1OctetString)seq.getObjectAt(0));
+            X9FieldElement  x9B = new X9FieldElement(p, (ASN1OctetString)seq.getObjectAt(1));
+            curve = new ECCurve.Fp(p, x9A.getValue().toBigInteger(), x9B.getValue().toBigInteger());
+        }
+        else
+        {
+            if (fieldIdentifier.equals(characteristic_two_field)) 
+            {
+                // Characteristic two field
+                DERSequence parameters = (DERSequence)fieldID.getParameters();
+                int m = ((DERInteger)parameters.getObjectAt(0)).getValue().
+                    intValue();
+                DERObjectIdentifier representation
+                    = (DERObjectIdentifier)parameters.getObjectAt(1);
+
+                int k1 = 0;
+                int k2 = 0;
+                int k3 = 0;
+                if (representation.equals(tpBasis)) 
+                {
+                    // Trinomial basis representation
+                    k1 = ((DERInteger)parameters.getObjectAt(2)).getValue().
+                        intValue();
+                }
+                else 
+                {
+                    // Pentanomial basis representation
+                    DERSequence pentanomial
+                        = (DERSequence)parameters.getObjectAt(2);
+                    k1 = ((DERInteger)pentanomial.getObjectAt(0)).getValue().
+                        intValue();
+                    k2 = ((DERInteger)pentanomial.getObjectAt(1)).getValue().
+                        intValue();
+                    k3 = ((DERInteger)pentanomial.getObjectAt(2)).getValue().
+                        intValue();
+                }
+                X9FieldElement x9A = new X9FieldElement(m, k1, k2, k3, (ASN1OctetString)seq.getObjectAt(0));
+                X9FieldElement x9B = new X9FieldElement(m, k1, k2, k3, (ASN1OctetString)seq.getObjectAt(1));
+                // TODO Is it possible to get the order (n) and cofactor(h) too?
+                curve = new ECCurve.F2m(m, k1, k2, k3, x9A.getValue().toBigInteger(), x9B.getValue().toBigInteger());
+            }
+        }
+
+        if (seq.size() == 3)
+        {
+            seed = ((DERBitString)seq.getObjectAt(2)).getBytes();
+        }
+    }
+
+    private void setFieldIdentifier()
+    {
+        if (curve instanceof ECCurve.Fp)
+        {
+            fieldIdentifier = prime_field;
+        }
+        else if (curve instanceof ECCurve.F2m)
+        {
+            fieldIdentifier = characteristic_two_field;
+        }
+        else
+        {
+            throw new IllegalArgumentException(&quot;This type of ECCurve is not &quot;
+                    + &quot;implemented&quot;);
+        }
+    }
+
+    public ECCurve  getCurve()
+    {
+        return curve;
+    }
+
+    public byte[]   getSeed()
+    {
+        return seed;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     *  Curve ::= SEQUENCE {
+     *      a               FieldElement,
+     *      b               FieldElement,
+     *      seed            BIT STRING      OPTIONAL
+     *  }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        if (fieldIdentifier.equals(prime_field)) 
+        { 
+            v.add(new X9FieldElement(curve.getA()).getDERObject());
+            v.add(new X9FieldElement(curve.getB()).getDERObject());
+        } 
+        else if (fieldIdentifier.equals(characteristic_two_field)) 
+        {
+            v.add(new X9FieldElement(curve.getA()).getDERObject());
+            v.add(new X9FieldElement(curve.getB()).getDERObject());
+        }
+
+        if (seed != null)
+        {
+            v.add(new DERBitString(seed));
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ECParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,161 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+
+import ewe.math.BigInteger;
+
+/**
+ * ASN.1 def for Elliptic-Curve ECParameters structure. See
+ * X9.62, for further details.
+ */
+public class X9ECParameters
+    extends ASN1Encodable
+    implements X9ObjectIdentifiers
+{
+    private static final BigInteger   ONE = BigInteger.valueOf(1);
+
+    private X9FieldID           fieldID;
+    private ECCurve             curve;
+    private ECPoint             g;
+    private BigInteger          n;
+    private BigInteger          h;
+    private byte[]              seed;
+
+    public X9ECParameters(
+        ASN1Sequence  seq)
+    {
+        if (!(seq.getObjectAt(0) instanceof DERInteger)
+           || !((DERInteger)seq.getObjectAt(0)).getValue().equals(ONE))
+        {
+            throw new IllegalArgumentException(&quot;bad version in X9ECParameters&quot;);
+        }
+
+        X9Curve     x9c = new X9Curve(
+                        new X9FieldID((ASN1Sequence)seq.getObjectAt(1)),
+                        (ASN1Sequence)seq.getObjectAt(2));
+
+        this.curve = x9c.getCurve();
+        this.g = new X9ECPoint(curve, (ASN1OctetString)seq.getObjectAt(3)).getPoint();
+        this.n = ((DERInteger)seq.getObjectAt(4)).getValue();
+        this.seed = x9c.getSeed();
+
+        if (seq.size() == 6)
+        {
+            this.h = ((DERInteger)seq.getObjectAt(5)).getValue();
+        }
+    }
+
+    public X9ECParameters(
+        ECCurve     curve,
+        ECPoint     g,
+        BigInteger  n)
+    {
+        this(curve, g, n, ONE, null);
+    }
+
+    public X9ECParameters(
+        ECCurve     curve,
+        ECPoint     g,
+        BigInteger  n,
+        BigInteger  h)
+    {
+        this(curve, g, n, h, null);
+    }
+
+    public X9ECParameters(
+        ECCurve     curve,
+        ECPoint     g,
+        BigInteger  n,
+        BigInteger  h,
+        byte[]      seed)
+    {
+        this.curve = curve;
+        this.g = g;
+        this.n = n;
+        this.h = h;
+        this.seed = seed;
+
+        if (curve instanceof ECCurve.Fp)
+        {
+            this.fieldID = new X9FieldID(((ECCurve.Fp)curve).getQ());
+        }
+        else
+        {
+            if (curve instanceof ECCurve.F2m)
+            {
+                ECCurve.F2m curveF2m = (ECCurve.F2m)curve;
+                this.fieldID = new X9FieldID(curveF2m.getM(), curveF2m.getK1(),
+                    curveF2m.getK2(), curveF2m.getK3());
+            }
+        }
+    }
+
+    public ECCurve getCurve()
+    {
+        return curve;
+    }
+
+    public ECPoint getG()
+    {
+        return g;
+    }
+
+    public BigInteger getN()
+    {
+        return n;
+    }
+
+    public BigInteger getH()
+    {
+        if (h == null)
+        {
+            return ONE;        // TODO - this should be calculated, it will cause issues with custom curves.
+        }
+
+        return h;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     *  ECParameters ::= SEQUENCE {
+     *      version         INTEGER { ecpVer1(1) } (ecpVer1),
+     *      fieldID         FieldID {{FieldTypes}},
+     *      curve           X9Curve,
+     *      base            X9ECPoint,
+     *      order           INTEGER,
+     *      cofactor        INTEGER OPTIONAL
+     *  }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(new DERInteger(1));
+        v.add(fieldID);
+        v.add(new X9Curve(curve, seed));
+        v.add(new X9ECPoint(g));
+        v.add(new DERInteger(n));
+
+        if (h != null)
+        {
+            v.add(new DERInteger(h));
+        }
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ECParametersHolder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.asn1.x9;
+
+public abstract class X9ECParametersHolder
+{
+    private X9ECParameters params;
+
+    public X9ECParameters getParameters()
+    {
+        if (params == null)
+        {
+            params = createParameters();
+        }
+
+        return params;
+    }
+
+    protected abstract X9ECParameters createParameters();
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ECPoint.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DEROctetString;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+
+/**
+ * class for describing an ECPoint as a DER object.
+ */
+public class X9ECPoint
+    extends ASN1Encodable
+{
+    ECPoint p;
+
+    public X9ECPoint(
+        ECPoint p)
+    {
+        this.p = p;
+    }
+
+    public X9ECPoint(
+        ECCurve          c,
+        ASN1OctetString  s)
+    {
+        this.p = c.decodePoint(s.getOctets());
+    }
+
+    public ECPoint getPoint()
+    {
+        return p;
+    }
+
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     *  ECPoint ::= OCTET STRING
+     * &lt;/pre&gt;
+     * &lt;p&gt;
+     * Octet string produced using ECPoint.getEncoded().
+     */
+    public DERObject toASN1Object()
+    {
+        return new DEROctetString(p.getEncoded());
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9FieldElement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,64 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DEROctetString;
+import org.bouncycastle.math.ec.ECFieldElement;
+
+/**
+ * class for processing an FieldElement as a DER object.
+ */
+public class X9FieldElement
+    extends ASN1Encodable
+{
+    protected ECFieldElement  f;
+    
+    private static X9IntegerConverter converter = new X9IntegerConverter();
+
+    public X9FieldElement(ECFieldElement f)
+    {
+        this.f = f;
+    }
+    
+    public X9FieldElement(BigInteger p, ASN1OctetString s)
+    {
+        this(new ECFieldElement.Fp(p, new BigInteger(1, s.getOctets())));
+    }
+    
+    public X9FieldElement(int m, int k1, int k2, int k3, ASN1OctetString s)
+    {
+        this(new ECFieldElement.F2m(m, k1, k2, k3, new BigInteger(1, s.getOctets())));
+    }
+    
+    public ECFieldElement getValue()
+    {
+        return f;
+    }
+    
+    /**
+     * Produce an object suitable for an ASN1OutputStream.
+     * &lt;pre&gt;
+     *  FieldElement ::= OCTET STRING
+     * &lt;/pre&gt;
+     * &lt;p&gt;
+     * &lt;ol&gt;
+     * &lt;li&gt; if &lt;i&gt;q&lt;/i&gt; is an odd prime then the field element is
+     * processed as an Integer and converted to an octet string
+     * according to x 9.62 4.3.1.&lt;/li&gt;
+     * &lt;li&gt; if &lt;i&gt;q&lt;/i&gt; is 2&lt;sup&gt;m&lt;/sup&gt; then the bit string
+     * contained in the field element is converted into an octet
+     * string with the same ordering padded at the front if necessary.
+     * &lt;/li&gt;
+     * &lt;/ol&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        int byteCount = converter.getByteLength(f);
+        byte[] paddedBigInteger = converter.integerToBytes(f.toBigInteger(), byteCount);
+
+        return new DEROctetString(paddedBigInteger);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9FieldID.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9FieldID.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,109 @@
+package org.bouncycastle.asn1.x9;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DERSequence;
+
+/**
+ * ASN.1 def for Elliptic-Curve Field ID structure. See
+ * X9.62, for further details.
+ */
+public class X9FieldID
+    extends ASN1Encodable
+    implements X9ObjectIdentifiers
+{
+    private DERObjectIdentifier     id;
+    private DERObject               parameters;
+
+    /**
+     * Constructor for elliptic curves over prime fields
+     * &lt;code&gt;F&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;.
+     * @param primeP The prime &lt;code&gt;p&lt;/code&gt; defining the prime field.
+     */
+    public X9FieldID(BigInteger primeP)
+    {
+        this.id = prime_field;
+        this.parameters = new DERInteger(primeP);
+    }
+
+    /**
+     * Constructor for elliptic curves over binary fields
+     * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+     * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+     * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+     * @param k1 The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+     * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+     * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+     * @param k2 The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+     * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+     * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+     * @param k3 The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+     * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+     * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;..
+     */
+    public X9FieldID(int m, int k1, int k2, int k3)
+    {
+        this.id = characteristic_two_field;
+        ASN1EncodableVector fieldIdParams = new ASN1EncodableVector();
+        fieldIdParams.add(new DERInteger(m));
+        
+        if (k2 == 0) 
+        {
+            fieldIdParams.add(tpBasis);
+            fieldIdParams.add(new DERInteger(k1));
+        } 
+        else 
+        {
+            fieldIdParams.add(ppBasis);
+            ASN1EncodableVector pentanomialParams = new ASN1EncodableVector();
+            pentanomialParams.add(new DERInteger(k1));
+            pentanomialParams.add(new DERInteger(k2));
+            pentanomialParams.add(new DERInteger(k3));
+            fieldIdParams.add(new DERSequence(pentanomialParams));
+        }
+        
+        this.parameters = new DERSequence(fieldIdParams);
+    }
+
+    public X9FieldID(
+        ASN1Sequence  seq)
+    {
+        this.id = (DERObjectIdentifier)seq.getObjectAt(0);
+        this.parameters = (DERObject)seq.getObjectAt(1);
+    }
+
+    public DERObjectIdentifier getIdentifier()
+    {
+        return id;
+    }
+
+    public DERObject getParameters()
+    {
+        return parameters;
+    }
+
+    /**
+     * Produce a DER encoding of the following structure.
+     * &lt;pre&gt;
+     *  FieldID ::= SEQUENCE {
+     *      fieldType       FIELD-ID.&amp;id({IOSet}),
+     *      parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
+     *  }
+     * &lt;/pre&gt;
+     */
+    public DERObject toASN1Object()
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+
+        v.add(this.id);
+        v.add(this.parameters);
+
+        return new DERSequence(v);
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9IntegerConverter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,47 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECFieldElement;
+
+import ewe.math.BigInteger;
+
+public class X9IntegerConverter
+{
+    public int getByteLength(
+        ECCurve c)
+    {
+        return (c.getFieldSize() + 7) / 8;
+    }
+
+    public int getByteLength(
+        ECFieldElement fe)
+    {
+        return (fe.getFieldSize() + 7) / 8;
+    }
+
+    public byte[] integerToBytes(
+        BigInteger s,
+        int        qLength)
+    {
+        byte[] bytes = s.toByteArray();
+        
+        if (qLength &lt; bytes.length)
+        {
+            byte[] tmp = new byte[qLength];
+        
+            System.arraycopy(bytes, bytes.length - tmp.length, tmp, 0, tmp.length);
+            
+            return tmp;
+        }
+        else if (qLength &gt; bytes.length)
+        {
+            byte[] tmp = new byte[qLength];
+        
+            System.arraycopy(bytes, 0, tmp, tmp.length - bytes.length, bytes.length);
+            
+            return tmp; 
+        }
+    
+        return bytes;
+    }
+}

Added: trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/X9ObjectIdentifiers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,132 @@
+package org.bouncycastle.asn1.x9;
+
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+
+public interface X9ObjectIdentifiers
+{
+    //
+    // X9.62
+    //
+    // ansi-X9-62 OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+    //            us(840) ansi-x962(10045) }
+    //
+    static final ASN1ObjectIdentifier ansi_X9_62 = new ASN1ObjectIdentifier(&quot;1.2.840.10045&quot;);
+    static final ASN1ObjectIdentifier id_fieldType = ansi_X9_62.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier prime_field = id_fieldType.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier characteristic_two_field = id_fieldType.branch(&quot;2&quot;);
+
+    static final ASN1ObjectIdentifier gnBasis = id_fieldType.branch(&quot;2.3.1&quot;);
+
+    static final ASN1ObjectIdentifier tpBasis = id_fieldType.branch(&quot;2.3.2&quot;);
+
+    static final ASN1ObjectIdentifier ppBasis = id_fieldType.branch(&quot;2.3.3&quot;);
+
+    static final ASN1ObjectIdentifier id_ecSigType = ansi_X9_62.branch(&quot;4&quot;);
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA1 = new ASN1ObjectIdentifier(id_ecSigType + &quot;.1&quot;);
+
+    static final ASN1ObjectIdentifier id_publicKeyType = ansi_X9_62.branch(&quot;2&quot;);
+
+    static final ASN1ObjectIdentifier id_ecPublicKey = id_publicKeyType.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA2 = id_ecSigType.branch(&quot;3&quot;);
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA224 = ecdsa_with_SHA2.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA256 = ecdsa_with_SHA2.branch(&quot;2&quot;);
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA384 = ecdsa_with_SHA2.branch(&quot;3&quot;);
+
+    static final ASN1ObjectIdentifier ecdsa_with_SHA512 = ecdsa_with_SHA2.branch(&quot;4&quot;);
+
+    //
+    // named curves
+    //
+    static final ASN1ObjectIdentifier ellipticCurve = ansi_X9_62.branch(&quot;3&quot;);
+
+    //
+    // Two Curves
+    //
+    static final ASN1ObjectIdentifier  cTwoCurve = ellipticCurve.branch(&quot;0&quot;);
+
+    static final ASN1ObjectIdentifier c2pnb163v1 = cTwoCurve.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier c2pnb163v2 = cTwoCurve.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier c2pnb163v3 = cTwoCurve.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier c2pnb176w1 = cTwoCurve.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier c2tnb191v1 = cTwoCurve.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier c2tnb191v2 = cTwoCurve.branch(&quot;6&quot;);
+    static final ASN1ObjectIdentifier c2tnb191v3 = cTwoCurve.branch(&quot;7&quot;);
+    static final ASN1ObjectIdentifier c2onb191v4 = cTwoCurve.branch(&quot;8&quot;);
+    static final ASN1ObjectIdentifier c2onb191v5 = cTwoCurve.branch(&quot;9&quot;);
+    static final ASN1ObjectIdentifier c2pnb208w1 = cTwoCurve.branch(&quot;10&quot;);
+    static final ASN1ObjectIdentifier c2tnb239v1 = cTwoCurve.branch(&quot;11&quot;);
+    static final ASN1ObjectIdentifier c2tnb239v2 = cTwoCurve.branch(&quot;12&quot;);
+    static final ASN1ObjectIdentifier c2tnb239v3 = cTwoCurve.branch(&quot;13&quot;);
+    static final ASN1ObjectIdentifier c2onb239v4 = cTwoCurve.branch(&quot;14&quot;);
+    static final ASN1ObjectIdentifier c2onb239v5 = cTwoCurve.branch(&quot;15&quot;);
+    static final ASN1ObjectIdentifier c2pnb272w1 = cTwoCurve.branch(&quot;16&quot;);
+    static final ASN1ObjectIdentifier c2pnb304w1 = cTwoCurve.branch(&quot;17&quot;);
+    static final ASN1ObjectIdentifier c2tnb359v1 = cTwoCurve.branch(&quot;18&quot;);
+    static final ASN1ObjectIdentifier c2pnb368w1 = cTwoCurve.branch(&quot;19&quot;);
+    static final ASN1ObjectIdentifier c2tnb431r1 = cTwoCurve.branch(&quot;20&quot;);
+
+    //
+    // Prime
+    //
+    static final ASN1ObjectIdentifier primeCurve = ellipticCurve.branch(&quot;1&quot;);
+
+    static final ASN1ObjectIdentifier prime192v1 = primeCurve.branch(&quot;1&quot;);
+    static final ASN1ObjectIdentifier prime192v2 = primeCurve.branch(&quot;2&quot;);
+    static final ASN1ObjectIdentifier prime192v3 = primeCurve.branch(&quot;3&quot;);
+    static final ASN1ObjectIdentifier prime239v1 = primeCurve.branch(&quot;4&quot;);
+    static final ASN1ObjectIdentifier prime239v2 = primeCurve.branch(&quot;5&quot;);
+    static final ASN1ObjectIdentifier prime239v3 = primeCurve.branch(&quot;6&quot;);
+    static final ASN1ObjectIdentifier prime256v1 = primeCurve.branch(&quot;7&quot;);
+
+    //
+    // DSA
+    //
+    // dsapublicnumber OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+    //            us(840) ansi-x957(10040) number-type(4) 1 }
+    static final ASN1ObjectIdentifier id_dsa = new ASN1ObjectIdentifier(&quot;1.2.840.10040.4.1&quot;);
+
+    /**
+     * id-dsa-with-sha1 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) x9-57
+     * (10040) x9cm(4) 3 }
+     */
+    public static final ASN1ObjectIdentifier id_dsa_with_sha1 = new ASN1ObjectIdentifier(&quot;1.2.840.10040.4.3&quot;);
+
+    /**
+     * X9.63
+     */
+    public static final ASN1ObjectIdentifier x9_63_scheme = new ASN1ObjectIdentifier(&quot;1.3.133.16.840.63.0&quot;);
+    public static final ASN1ObjectIdentifier dhSinglePass_stdDH_sha1kdf_scheme = x9_63_scheme.branch(&quot;2&quot;);
+    public static final ASN1ObjectIdentifier dhSinglePass_cofactorDH_sha1kdf_scheme = x9_63_scheme.branch(&quot;3&quot;);
+    public static final ASN1ObjectIdentifier mqvSinglePass_sha1kdf_scheme = x9_63_scheme.branch(&quot;16&quot;);
+
+    /**
+     * X9.42
+     */
+
+    static final ASN1ObjectIdentifier ansi_X9_42 = new ASN1ObjectIdentifier(&quot;1.2.840.10046&quot;);
+
+    //
+    // Diffie-Hellman
+    //
+    // dhpublicnumber OBJECT IDENTIFIER ::= { iso(1) member-body(2)
+    //            us(840) ansi-x942(10046) number-type(2) 1 }
+    //
+    public static final ASN1ObjectIdentifier dhpublicnumber = ansi_X9_42.branch(&quot;2.1&quot;);
+
+    public static final ASN1ObjectIdentifier x9_42_schemes = ansi_X9_42.branch(&quot;3&quot;);
+    public static final ASN1ObjectIdentifier dhStatic = x9_42_schemes.branch(&quot;1&quot;);
+    public static final ASN1ObjectIdentifier dhEphem = x9_42_schemes.branch(&quot;2&quot;);
+    public static final ASN1ObjectIdentifier dhOneFlow = x9_42_schemes.branch(&quot;3&quot;);
+    public static final ASN1ObjectIdentifier dhHybrid1 = x9_42_schemes.branch(&quot;4&quot;);
+    public static final ASN1ObjectIdentifier dhHybrid2 = x9_42_schemes.branch(&quot;5&quot;);
+    public static final ASN1ObjectIdentifier dhHybridOneFlow = x9_42_schemes.branch(&quot;6&quot;);
+    public static final ASN1ObjectIdentifier mqv2 = x9_42_schemes.branch(&quot;7&quot;);
+    public static final ASN1ObjectIdentifier mqv1 = x9_42_schemes.branch(&quot;8&quot;);
+}

Added: trunk/src/org/bouncycastle/asn1/x9/package.html
===================================================================
--- trunk/src/org/bouncycastle/asn1/x9/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/asn1/x9/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Support classes useful for encoding and supporting X9.62 elliptic curve.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/AsymmetricBlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,45 @@
+package org.bouncycastle.crypto;
+
+
+/**
+ * base interface that a public/private key block cipher needs
+ * to conform to.
+ */
+public interface AsymmetricBlockCipher
+{
+    /**
+     * initialise the cipher.
+     *
+     * @param forEncryption if true the cipher is initialised for 
+     *  encryption, if false for decryption.
+     * @param param the key and other data required by the cipher.
+     */
+    public void init(boolean forEncryption, CipherParameters param);
+
+    /**
+     * returns the largest size an input block can be.
+     *
+     * @return maximum size for an input block.
+     */
+    public int getInputBlockSize();
+
+    /**
+     * returns the maximum size of the block produced by this cipher.
+     *
+     * @return maximum size of the output block produced by the cipher.
+     */
+    public int getOutputBlockSize();
+
+    /**
+     * process the block of len bytes stored in in from offset inOff.
+     *
+     * @param in the input data
+     * @param inOff offset into the in array where the data starts
+     * @param len the length of the block to be processed.
+     * @return the resulting byte array of the encryption/decryption process.
+     * @exception InvalidCipherTextException data decrypts improperly.
+     * @exception DataLengthException the input data is too large for the cipher.
+     */
+    public byte[] processBlock(byte[] in, int inOff, int len)
+        throws InvalidCipherTextException;
+}

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPair.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,44 @@
+package org.bouncycastle.crypto;
+
+/**
+ * a holding class for public/private parameter pairs.
+ */
+public class AsymmetricCipherKeyPair
+{
+    private CipherParameters    publicParam;
+    private CipherParameters    privateParam;
+
+    /**
+     * basic constructor.
+     *
+     * @param publicParam a public key parameters object.
+     * @param privateParam the corresponding private key parameters.
+     */
+    public AsymmetricCipherKeyPair(
+        CipherParameters    publicParam,
+        CipherParameters    privateParam)
+    {
+        this.publicParam = publicParam;
+        this.privateParam = privateParam;
+    }
+
+    /**
+     * return the public key parameters.
+     *
+     * @return the public key parameters.
+     */
+    public CipherParameters getPublic()
+    {
+        return publicParam;
+    }
+
+    /**
+     * return the private key parameters.
+     *
+     * @return the private key parameters.
+     */
+    public CipherParameters getPrivate()
+    {
+        return privateParam;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/AsymmetricCipherKeyPairGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.crypto;
+
+/**
+ * interface that a public/private key pair generator should conform to.
+ */
+public interface AsymmetricCipherKeyPairGenerator
+{
+    /**
+     * intialise the key pair generator.
+     *
+     * @param param the parameters the key pair is to be initialised with.
+     */
+    public void init(KeyGenerationParameters param);
+
+    /**
+     * return an AsymmetricCipherKeyPair containing the generated keys.
+     *
+     * @return an AsymmetricCipherKeyPair containing the generated keys.
+     */
+    public AsymmetricCipherKeyPair generateKeyPair();
+}
+

Added: trunk/src/org/bouncycastle/crypto/BasicAgreement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/BasicAgreement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/BasicAgreement.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/BasicAgreement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/BasicAgreement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,21 @@
+package org.bouncycastle.crypto;
+
+import ewe.math.BigInteger;
+
+/**
+ * The basic interface that basic Diffie-Hellman implementations
+ * conforms to.
+ */
+public interface BasicAgreement
+{
+    /**
+     * initialise the agreement engine.
+     */
+    public void init(CipherParameters param);
+
+    /**
+     * given a public key from a given party calculate the next
+     * message in the agreement sequence. 
+     */
+    public BigInteger calculateAgreement(CipherParameters pubKey);
+}

Added: trunk/src/org/bouncycastle/crypto/BlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/BlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/BlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/BlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/BlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,56 @@
+package org.bouncycastle.crypto;
+
+
+/**
+ * Block cipher engines are expected to conform to this interface.
+ */
+public interface BlockCipher
+{
+    /**
+     * Initialise the cipher.
+     *
+     * @param forEncryption if true the cipher is initialised for
+     *  encryption, if false for decryption.
+     * @param params the key and other data required by the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(boolean forEncryption, CipherParameters params)
+        throws IllegalArgumentException;
+
+    /**
+     * Return the name of the algorithm the cipher implements.
+     *
+     * @return the name of the algorithm the cipher implements.
+     */
+    public String getAlgorithmName();
+
+    /**
+     * Return the block size for this cipher (in bytes).
+     *
+     * @return the block size for this cipher in bytes.
+     */
+    public int getBlockSize();
+
+    /**
+     * Process one block of input from the array in and write it to
+     * the out array.
+     *
+     * @param in the array containing the input data.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the output data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    public int processBlock(byte[] in, int inOff, byte[] out, int outOff)
+        throws DataLengthException, IllegalStateException;
+
+    /**
+     * Reset the cipher. After resetting the cipher is in the same state
+     * as it was after the last init (if there was one).
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/CipherParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/CipherParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/CipherParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/CipherParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/CipherParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,8 @@
+package org.bouncycastle.crypto;
+
+/**
+ * all parameter classes implement this.
+ */
+public interface CipherParameters
+{
+}

Added: trunk/src/org/bouncycastle/crypto/CryptoException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/CryptoException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/CryptoException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/CryptoException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/CryptoException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,26 @@
+package org.bouncycastle.crypto;
+
+/**
+ * the foundation class for the hard exceptions thrown by the crypto packages.
+ */
+public class CryptoException 
+    extends Exception
+{
+    /**
+     * base constructor.
+     */
+    public CryptoException()
+    {
+    }
+
+    /**
+     * create a CryptoException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public CryptoException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/DSA.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/DSA.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/DSA.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/DSA.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/DSA.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.crypto;
+
+import ewe.math.BigInteger;
+
+/**
+ * interface for classes implementing algorithms modeled similar to the Digital Signature Alorithm.
+ */
+public interface DSA
+{
+    /**
+     * initialise the signer for signature generation or signature
+     * verification.
+     *
+     * @param forSigning true if we are generating a signature, false
+     * otherwise.
+     * @param param key parameters for signature generation.
+     */
+    public void init(boolean forSigning, CipherParameters param);
+
+    /**
+     * sign the passed in message (usually the output of a hash function).
+     *
+     * @param message the message to be signed.
+     * @return two big integers representing the r and s values respectively.
+     */
+    public BigInteger[] generateSignature(byte[] message);
+
+    /**
+     * verify the message message against the signature values r and s.
+     *
+     * @param message the message that was supposed to have been signed.
+     * @param r the r signature value.
+     * @param s the s signature value.
+     */
+    public boolean verifySignature(byte[] message, BigInteger  r, BigInteger s);
+}

Added: trunk/src/org/bouncycastle/crypto/DataLengthException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/DataLengthException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/DataLengthException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/DataLengthException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/DataLengthException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,29 @@
+package org.bouncycastle.crypto;
+
+/**
+ * this exception is thrown if a buffer that is meant to have output
+ * copied into it turns out to be too short, or if we've been given 
+ * insufficient input. In general this exception will get thrown rather
+ * than an ArrayOutOfBounds exception.
+ */
+public class DataLengthException 
+    extends RuntimeCryptoException
+{
+    /**
+     * base constructor.
+     */
+    public DataLengthException()
+    {
+    }
+
+    /**
+     * create a DataLengthException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public DataLengthException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,51 @@
+package org.bouncycastle.crypto;
+
+/**
+ * interface that a message digest conforms to.
+ */
+public interface Digest
+{
+    /**
+     * return the algorithm name
+     *
+     * @return the algorithm name
+     */
+    public String getAlgorithmName();
+
+    /**
+     * return the size, in bytes, of the digest produced by this message digest.
+     *
+     * @return the size, in bytes, of the digest produced by this message digest.
+     */
+    public int getDigestSize();
+
+    /**
+     * update the message digest with a single byte.
+     *
+     * @param in the input byte to be entered.
+     */
+    public void update(byte in);
+
+    /**
+     * update the message digest with a block of bytes.
+     *
+     * @param in the byte array containing the data.
+     * @param inOff the offset into the byte array where the data starts.
+     * @param len the length of the data.
+     */
+    public void update(byte[] in, int inOff, int len);
+
+    /**
+     * close the digest, producing the final digest value. The doFinal
+     * call leaves the digest reset.
+     *
+     * @param out the array the digest is to be copied into.
+     * @param outOff the offset into the out array the digest is to start at.
+     */
+    public int doFinal(byte[] out, int outOff);
+
+    /**
+     * reset the digest back to it's initial state.
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/ExtendedDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/ExtendedDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/ExtendedDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/ExtendedDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,13 @@
+package org.bouncycastle.crypto;
+
+public interface ExtendedDigest 
+    extends Digest
+{
+    /**
+     * Return the size in bytes of the internal buffer the digest applies it's compression
+     * function to.
+     * 
+     * @return byte length of the digests internal buffer.
+     */
+    public int getByteLength();
+}

Added: trunk/src/org/bouncycastle/crypto/ExtensionType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/ExtensionType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/ExtensionType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/ExtensionType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/ExtensionType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto;
+
+/**
+ * RFC 4366 2.3
+ */
+public class ExtensionType
+{
+    public static final int server_name = 0;
+    public static final int max_fragment_length = 1;
+    public static final int client_certificate_url = 2;
+    public static final int trusted_ca_keys = 3;
+    public static final int truncated_hmac = 4;
+    public static final int status_request = 5;
+
+    /*
+     * RFC 4492
+     */
+    public static final int elliptic_curves = 10;
+    public static final int ec_point_formats = 11;
+
+    /*
+     * RFC 5054 2.8.1
+     */
+    public static final int srp = 12;
+
+    /*
+     * RFC 5746 6
+     */
+    public static final int renegotiation_info = 0xff01;
+}

Added: trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/InvalidCipherTextException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,27 @@
+package org.bouncycastle.crypto;
+
+/**
+ * this exception is thrown whenever we find something we don't expect in a
+ * message.
+ */
+public class InvalidCipherTextException 
+    extends CryptoException
+{
+    /**
+     * base constructor.
+     */
+    public InvalidCipherTextException()
+    {
+    }
+
+    /**
+     * create a InvalidCipherTextException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public InvalidCipherTextException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/KeyGenerationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.crypto;
+
+import ewe.security.SecureRandom;
+
+/**
+ * The base class for parameters to key generators.
+ */
+public class KeyGenerationParameters
+{
+    private SecureRandom    random;
+    private int             strength;
+
+    /**
+     * initialise the generator with a source of randomness
+     * and a strength (in bits).
+     *
+     * @param random the random byte source.
+     * @param strength the size, in bits, of the keys we want to produce.
+     */
+    public KeyGenerationParameters(
+        SecureRandom    random,
+        int             strength)
+    {
+        this.random = random;
+        this.strength = strength;
+    }
+
+    /**
+     * return the random source associated with this
+     * generator.
+     *
+     * @return the generators random source.
+     */
+    public SecureRandom getRandom()
+    {
+        return random;
+    }
+
+    /**
+     * return the bit strength for keys produced by this generator,
+     *
+     * @return the strength of the keys this generator produces (in bits).
+     */
+    public int getStrength()
+    {
+        return strength;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/Mac.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/Mac.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/Mac.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/Mac.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/Mac.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,71 @@
+package org.bouncycastle.crypto;
+
+
+/**
+ * The base interface for implementations of message authentication codes (MACs).
+ */
+public interface Mac
+{
+    /**
+     * Initialise the MAC.
+     *
+     * @param params the key and other data required by the MAC.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(CipherParameters params)
+        throws IllegalArgumentException;
+
+    /**
+     * Return the name of the algorithm the MAC implements.
+     *
+     * @return the name of the algorithm the MAC implements.
+     */
+    public String getAlgorithmName();
+
+    /**
+     * Return the block size for this MAC (in bytes).
+     *
+     * @return the block size for this MAC in bytes.
+     */
+    public int getMacSize();
+
+    /**
+     * add a single byte to the mac for processing.
+     *
+     * @param in the byte to be processed.
+     * @exception IllegalStateException if the MAC is not initialised.
+     */
+    public void update(byte in)
+        throws IllegalStateException;
+
+    /**
+     * @param in the array containing the input.
+     * @param inOff the index in the array the data begins at.
+     * @param len the length of the input starting at inOff.
+     * @exception IllegalStateException if the MAC is not initialised.
+     * @exception DataLengthException if there isn't enough data in in.
+     */
+    public void update(byte[] in, int inOff, int len)
+        throws DataLengthException, IllegalStateException;
+
+    /**
+     * Compute the final stage of the MAC writing the output to the out
+     * parameter.
+     * &lt;p&gt;
+     * doFinal leaves the MAC in the same state it was after the last init.
+     *
+     * @param out the array the MAC is to be output to.
+     * @param outOff the offset into the out buffer the output is to start at.
+     * @exception DataLengthException if there isn't enough space in out.
+     * @exception IllegalStateException if the MAC is not initialised.
+     */
+    public int doFinal(byte[] out, int outOff)
+        throws DataLengthException, IllegalStateException;
+
+    /**
+     * Reset the MAC. At the end of resetting the MAC should be in the
+     * in the same state it was after the last init (if there was one).
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/RuntimeCryptoException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,26 @@
+package org.bouncycastle.crypto;
+
+/**
+ * the foundation class for the exceptions thrown by the crypto packages.
+ */
+public class RuntimeCryptoException 
+    extends RuntimeException
+{
+    /**
+     * base constructor.
+     */
+    public RuntimeCryptoException()
+    {
+    }
+
+    /**
+     * create a RuntimeCryptoException with the given message.
+     *
+     * @param message the message to be carried with the exception.
+     */
+    public RuntimeCryptoException(
+        String  message)
+    {
+        super(message);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/Signer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/Signer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/Signer.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/Signer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/Signer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,43 @@
+package org.bouncycastle.crypto;
+
+/**
+ * Generic signer interface for hash based and message recovery signers.
+ */
+public interface Signer 
+{
+    /**
+     * Initialise the signer for signing or verification.
+     * 
+     * @param forSigning true if for signing, false otherwise
+     * @param param necessary parameters.
+     */
+    public void init(boolean forSigning, CipherParameters param);
+
+    /**
+     * update the internal digest with the byte b
+     */
+    public void update(byte b);
+
+    /**
+     * update the internal digest with the byte array in
+     */
+    public void update(byte[] in, int off, int len);
+
+    /**
+     * generate a signature for the message we've been loaded with using
+     * the key we were initialised with.
+     */
+    public byte[] generateSignature()
+        throws CryptoException, DataLengthException;
+
+    /**
+     * return true if the internal state represents the signature described
+     * in the passed in array.
+     */
+    public boolean verifySignature(byte[] signature);
+    
+    /**
+     * reset the internal state
+     */
+    public void reset();
+}

Added: trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/agreement/DHBasicAgreement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,66 @@
+package org.bouncycastle.crypto.agreement;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.BasicAgreement;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+/**
+ * a Diffie-Hellman key agreement class.
+ * &lt;p&gt;
+ * note: This is only the basic algorithm, it doesn't take advantage of
+ * long term public keys if they are available. See the DHAgreement class
+ * for a &quot;better&quot; implementation.
+ */
+public class DHBasicAgreement
+    implements BasicAgreement
+{
+    private DHPrivateKeyParameters  key;
+    private DHParameters            dhParams;
+
+    public void init(
+        CipherParameters    param)
+    {
+        AsymmetricKeyParameter  kParam;
+
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom rParam = (ParametersWithRandom)param;
+            kParam = (AsymmetricKeyParameter)rParam.getParameters();
+        }
+        else
+        {
+            kParam = (AsymmetricKeyParameter)param;
+        }
+
+        if (!(kParam instanceof DHPrivateKeyParameters))
+        {
+            throw new IllegalArgumentException(&quot;DHEngine expects DHPrivateKeyParameters&quot;);
+        }
+
+        this.key = (DHPrivateKeyParameters)kParam;
+        this.dhParams = key.getParameters();
+    }
+
+    /**
+     * given a short term public key from a given party calculate the next
+     * message in the agreement sequence. 
+     */
+    public BigInteger calculateAgreement(
+        CipherParameters   pubKey)
+    {
+        DHPublicKeyParameters   pub = (DHPublicKeyParameters)pubKey;
+
+        if (!pub.getParameters().equals(dhParams))
+        {
+            throw new IllegalArgumentException(&quot;Diffie-Hellman public key has wrong parameters.&quot;);
+        }
+
+        return pub.getY().modPow(key.getX(), dhParams.getP());
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/agreement/ECDHBasicAgreement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,47 @@
+package org.bouncycastle.crypto.agreement;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.math.ec.ECPoint;
+
+import org.bouncycastle.crypto.BasicAgreement;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+
+/**
+ * P1363 7.2.1 ECSVDP-DH
+ *
+ * ECSVDP-DH is Elliptic Curve Secret Value Derivation Primitive,
+ * Diffie-Hellman version. It is based on the work of [DH76], [Mil86],
+ * and [Kob87]. This primitive derives a shared secret value from one
+ * party's private key and another party's public key, where both have
+ * the same set of EC domain parameters. If two parties correctly
+ * execute this primitive, they will produce the same output. This
+ * primitive can be invoked by a scheme to derive a shared secret key;
+ * specifically, it may be used with the schemes ECKAS-DH1 and
+ * DL/ECKAS-DH2. It assumes that the input keys are valid (see also
+ * Section 7.2.2).
+ */
+public class ECDHBasicAgreement
+    implements BasicAgreement
+{
+    private ECPrivateKeyParameters key;
+
+    public void init(
+        CipherParameters key)
+    {
+        this.key = (ECPrivateKeyParameters)key;
+    }
+
+    public BigInteger calculateAgreement(
+        CipherParameters pubKey)
+    {
+        ECPublicKeyParameters pub = (ECPublicKeyParameters)pubKey;
+        ECPoint P = pub.getQ().multiply(key.getD());
+
+        // if (p.isInfinity()) throw new RuntimeException(&quot;d*Q == infinity&quot;);
+
+        return P.getX().toBigInteger();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/agreement/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/agreement/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/agreement/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Basic key agreement classes.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/GeneralDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,135 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.ExtendedDigest;
+
+/**
+ * base implementation of MD4 family style digest as outlined in
+ * &quot;Handbook of Applied Cryptography&quot;, pages 344 - 347.
+ */
+public abstract class GeneralDigest
+    implements ExtendedDigest
+{
+    private static final int BYTE_LENGTH = 64;
+    private byte[]  xBuf;
+    private int     xBufOff;
+
+    private long    byteCount;
+
+    /**
+     * Standard constructor
+     */
+    protected GeneralDigest()
+    {
+        xBuf = new byte[4];
+        xBufOff = 0;
+    }
+
+    /**
+     * Copy constructor.  We are using copy constructors in place
+     * of the Object.clone() interface as this interface is not
+     * supported by J2ME.
+     */
+    protected GeneralDigest(GeneralDigest t)
+    {
+        xBuf = new byte[t.xBuf.length];
+        System.arraycopy(t.xBuf, 0, xBuf, 0, t.xBuf.length);
+
+        xBufOff = t.xBufOff;
+        byteCount = t.byteCount;
+    }
+
+    public void update(
+        byte in)
+    {
+        xBuf[xBufOff++] = in;
+
+        if (xBufOff == xBuf.length)
+        {
+            processWord(xBuf, 0);
+            xBufOff = 0;
+        }
+
+        byteCount++;
+    }
+
+    public void update(
+        byte[]  in,
+        int     inOff,
+        int     len)
+    {
+        //
+        // fill the current word
+        //
+        while ((xBufOff != 0) &amp;&amp; (len &gt; 0))
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+
+        //
+        // process whole words.
+        //
+        while (len &gt; xBuf.length)
+        {
+            processWord(in, inOff);
+
+            inOff += xBuf.length;
+            len -= xBuf.length;
+            byteCount += xBuf.length;
+        }
+
+        //
+        // load in the remainder.
+        //
+        while (len &gt; 0)
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+    }
+
+    public void finish()
+    {
+        long    bitLength = (byteCount &lt;&lt; 3);
+
+        //
+        // add the pad bytes.
+        //
+        update((byte)128);
+
+        while (xBufOff != 0)
+        {
+            update((byte)0);
+        }
+
+        processLength(bitLength);
+
+        processBlock();
+    }
+
+    public void reset()
+    {
+        byteCount = 0;
+
+        xBufOff = 0;
+        for (int i = 0; i &lt; xBuf.length; i++)
+        {
+            xBuf[i] = 0;
+        }
+    }
+
+    public int getByteLength()
+    {
+        return BYTE_LENGTH;
+    }
+    
+    protected abstract void processWord(byte[] in, int inOff);
+
+    protected abstract void processLength(long bitLength);
+
+    protected abstract void processBlock();
+}

Added: trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/LongDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/LongDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/LongDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/LongDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,354 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.ExtendedDigest;
+import org.bouncycastle.crypto.util.Pack;
+
+/**
+ * Base class for SHA-384 and SHA-512.
+ */
+public abstract class LongDigest
+    implements ExtendedDigest
+{
+    private static final int BYTE_LENGTH = 128;
+    
+    private byte[]  xBuf;
+    private int     xBufOff;
+
+    private long    byteCount1;
+    private long    byteCount2;
+
+    protected long    H1, H2, H3, H4, H5, H6, H7, H8;
+
+    private long[]  W = new long[80];
+    private int     wOff;
+
+    /**
+     * Constructor for variable length word
+     */
+    protected LongDigest()
+    {
+        xBuf = new byte[8];
+        xBufOff = 0;
+
+        reset();
+    }
+
+    /**
+     * Copy constructor.  We are using copy constructors in place
+     * of the Object.clone() interface as this interface is not
+     * supported by J2ME.
+     */
+    protected LongDigest(LongDigest t)
+    {
+        xBuf = new byte[t.xBuf.length];
+        System.arraycopy(t.xBuf, 0, xBuf, 0, t.xBuf.length);
+
+        xBufOff = t.xBufOff;
+        byteCount1 = t.byteCount1;
+        byteCount2 = t.byteCount2;
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+        H5 = t.H5;
+        H6 = t.H6;
+        H7 = t.H7;
+        H8 = t.H8;
+
+        System.arraycopy(t.W, 0, W, 0, t.W.length);
+        wOff = t.wOff;
+    }
+
+    public void update(
+        byte in)
+    {
+        xBuf[xBufOff++] = in;
+
+        if (xBufOff == xBuf.length)
+        {
+            processWord(xBuf, 0);
+            xBufOff = 0;
+        }
+
+        byteCount1++;
+    }
+
+    public void update(
+        byte[]  in,
+        int     inOff,
+        int     len)
+    {
+        //
+        // fill the current word
+        //
+        while ((xBufOff != 0) &amp;&amp; (len &gt; 0))
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+
+        //
+        // process whole words.
+        //
+        while (len &gt; xBuf.length)
+        {
+            processWord(in, inOff);
+
+            inOff += xBuf.length;
+            len -= xBuf.length;
+            byteCount1 += xBuf.length;
+        }
+
+        //
+        // load in the remainder.
+        //
+        while (len &gt; 0)
+        {
+            update(in[inOff]);
+
+            inOff++;
+            len--;
+        }
+    }
+
+    public void finish()
+    {
+        adjustByteCounts();
+
+        long    lowBitLength = byteCount1 &lt;&lt; 3;
+        long    hiBitLength = byteCount2;
+
+        //
+        // add the pad bytes.
+        //
+        update((byte)128);
+
+        while (xBufOff != 0)
+        {
+            update((byte)0);
+        }
+
+        processLength(lowBitLength, hiBitLength);
+
+        processBlock();
+    }
+
+    public void reset()
+    {
+        byteCount1 = 0;
+        byteCount2 = 0;
+
+        xBufOff = 0;
+        for (int i = 0; i &lt; xBuf.length; i++)
+        {
+            xBuf[i] = 0;
+        }
+
+        wOff = 0;
+        for (int i = 0; i != W.length; i++)
+        {
+            W[i] = 0;
+        }
+    }
+
+    public int getByteLength()
+    {
+        return BYTE_LENGTH;
+    }
+    
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        W[wOff] = Pack.bigEndianToLong(in, inOff);
+
+        if (++wOff == 16)
+        {
+            processBlock();
+        }
+    }
+
+    /**
+     * adjust the byte counts so that byteCount2 represents the
+     * upper long (less 3 bits) word of the byte count.
+     */
+    private void adjustByteCounts()
+    {
+        if (byteCount1 &gt; 0x1fffffffffffffffL)
+        {
+            byteCount2 += (byteCount1 &gt;&gt;&gt; 61);
+            byteCount1 &amp;= 0x1fffffffffffffffL;
+        }
+    }
+
+    protected void processLength(
+        long    lowW,
+        long    hiW)
+    {
+        if (wOff &gt; 14)
+        {
+            processBlock();
+        }
+
+        W[14] = hiW;
+        W[15] = lowW;
+    }
+
+    protected void processBlock()
+    {
+        adjustByteCounts();
+
+        //
+        // expand 16 word block into 80 word blocks.
+        //
+        for (int t = 16; t &lt;= 79; t++)
+        {
+            W[t] = Sigma1(W[t - 2]) + W[t - 7] + Sigma0(W[t - 15]) + W[t - 16];
+        }
+
+        //
+        // set up working variables.
+        //
+        long     a = H1;
+        long     b = H2;
+        long     c = H3;
+        long     d = H4;
+        long     e = H5;
+        long     f = H6;
+        long     g = H7;
+        long     h = H8;
+
+        int t = 0;     
+        for(int i = 0; i &lt; 10; i ++)
+        {
+          // t = 8 * i
+          h += Sum1(e) + Ch(e, f, g) + K[t] + W[t++];
+          d += h;
+          h += Sum0(a) + Maj(a, b, c);
+
+          // t = 8 * i + 1
+          g += Sum1(d) + Ch(d, e, f) + K[t] + W[t++];
+          c += g;
+          g += Sum0(h) + Maj(h, a, b);
+
+          // t = 8 * i + 2
+          f += Sum1(c) + Ch(c, d, e) + K[t] + W[t++];
+          b += f;
+          f += Sum0(g) + Maj(g, h, a);
+
+          // t = 8 * i + 3
+          e += Sum1(b) + Ch(b, c, d) + K[t] + W[t++];
+          a += e;
+          e += Sum0(f) + Maj(f, g, h);
+
+          // t = 8 * i + 4
+          d += Sum1(a) + Ch(a, b, c) + K[t] + W[t++];
+          h += d;
+          d += Sum0(e) + Maj(e, f, g);
+
+          // t = 8 * i + 5
+          c += Sum1(h) + Ch(h, a, b) + K[t] + W[t++];
+          g += c;
+          c += Sum0(d) + Maj(d, e, f);
+
+          // t = 8 * i + 6
+          b += Sum1(g) + Ch(g, h, a) + K[t] + W[t++];
+          f += b;
+          b += Sum0(c) + Maj(c, d, e);
+
+          // t = 8 * i + 7
+          a += Sum1(f) + Ch(f, g, h) + K[t] + W[t++];
+          e += a;
+          a += Sum0(b) + Maj(b, c, d);
+        }
+ 
+        H1 += a;
+        H2 += b;
+        H3 += c;
+        H4 += d;
+        H5 += e;
+        H6 += f;
+        H7 += g;
+        H8 += h;
+
+        //
+        // reset the offset and clean out the word buffer.
+        //
+        wOff = 0;
+        for (int i = 0; i &lt; 16; i++)
+        {
+            W[i] = 0;
+        }
+    }
+
+    /* SHA-384 and SHA-512 functions (as for SHA-256 but for longs) */
+    private long Ch(
+        long    x,
+        long    y,
+        long    z)
+    {
+        return ((x &amp; y) ^ ((~x) &amp; z));
+    }
+
+    private long Maj(
+        long    x,
+        long    y,
+        long    z)
+    {
+        return ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z));
+    }
+
+    private long Sum0(
+        long    x)
+    {
+        return ((x &lt;&lt; 36)|(x &gt;&gt;&gt; 28)) ^ ((x &lt;&lt; 30)|(x &gt;&gt;&gt; 34)) ^ ((x &lt;&lt; 25)|(x &gt;&gt;&gt; 39));
+    }
+
+    private long Sum1(
+        long    x)
+    {
+        return ((x &lt;&lt; 50)|(x &gt;&gt;&gt; 14)) ^ ((x &lt;&lt; 46)|(x &gt;&gt;&gt; 18)) ^ ((x &lt;&lt; 23)|(x &gt;&gt;&gt; 41));
+    }
+
+    private long Sigma0(
+        long    x)
+    {
+        return ((x &lt;&lt; 63)|(x &gt;&gt;&gt; 1)) ^ ((x &lt;&lt; 56)|(x &gt;&gt;&gt; 8)) ^ (x &gt;&gt;&gt; 7);
+    }
+
+    private long Sigma1(
+        long    x)
+    {
+        return ((x &lt;&lt; 45)|(x &gt;&gt;&gt; 19)) ^ ((x &lt;&lt; 3)|(x &gt;&gt;&gt; 61)) ^ (x &gt;&gt;&gt; 6);
+    }
+
+    /* SHA-384 and SHA-512 Constants
+     * (represent the first 64 bits of the fractional parts of the
+     * cube roots of the first sixty-four prime numbers)
+     */
+    static final long K[] = {
+0x428a2f98d728ae22L, 0x7137449123ef65cdL, 0xb5c0fbcfec4d3b2fL, 0xe9b5dba58189dbbcL,
+0x3956c25bf348b538L, 0x59f111f1b605d019L, 0x923f82a4af194f9bL, 0xab1c5ed5da6d8118L,
+0xd807aa98a3030242L, 0x12835b0145706fbeL, 0x243185be4ee4b28cL, 0x550c7dc3d5ffb4e2L,
+0x72be5d74f27b896fL, 0x80deb1fe3b1696b1L, 0x9bdc06a725c71235L, 0xc19bf174cf692694L,
+0xe49b69c19ef14ad2L, 0xefbe4786384f25e3L, 0x0fc19dc68b8cd5b5L, 0x240ca1cc77ac9c65L,
+0x2de92c6f592b0275L, 0x4a7484aa6ea6e483L, 0x5cb0a9dcbd41fbd4L, 0x76f988da831153b5L,
+0x983e5152ee66dfabL, 0xa831c66d2db43210L, 0xb00327c898fb213fL, 0xbf597fc7beef0ee4L,
+0xc6e00bf33da88fc2L, 0xd5a79147930aa725L, 0x06ca6351e003826fL, 0x142929670a0e6e70L,
+0x27b70a8546d22ffcL, 0x2e1b21385c26c926L, 0x4d2c6dfc5ac42aedL, 0x53380d139d95b3dfL,
+0x650a73548baf63deL, 0x766a0abb3c77b2a8L, 0x81c2c92e47edaee6L, 0x92722c851482353bL,
+0xa2bfe8a14cf10364L, 0xa81a664bbc423001L, 0xc24b8b70d0f89791L, 0xc76c51a30654be30L,
+0xd192e819d6ef5218L, 0xd69906245565a910L, 0xf40e35855771202aL, 0x106aa07032bbd1b8L,
+0x19a4c116b8d2d0c8L, 0x1e376c085141ab53L, 0x2748774cdf8eeb99L, 0x34b0bcb5e19b48a8L,
+0x391c0cb3c5c95a63L, 0x4ed8aa4ae3418acbL, 0x5b9cca4f7763e373L, 0x682e6ff3d6b2b8a3L,
+0x748f82ee5defb2fcL, 0x78a5636f43172f60L, 0x84c87814a1f0ab72L, 0x8cc702081a6439ecL,
+0x90befffa23631e28L, 0xa4506cebde82bde9L, 0xbef9a3f7b2c67915L, 0xc67178f2e372532bL,
+0xca273eceea26619cL, 0xd186b8c721c0c207L, 0xeada7dd6cde0eb1eL, 0xf57d4f7fee6ed178L,
+0x06f067aa72176fbaL, 0x0a637dc5a2c898a6L, 0x113f9804bef90daeL, 0x1b710b35131c471bL,
+0x28db77f523047d84L, 0x32caab7b40c72493L, 0x3c9ebe0a15c9bebcL, 0x431d67c49c100d4cL,
+0x4cc5d4becb3e42b6L, 0x597f299cfc657e2aL, 0x5fcb6fab3ad6faecL, 0x6c44198c4a475817L
+    };
+}

Added: trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/MD5Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/MD5Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,302 @@
+package org.bouncycastle.crypto.digests;
+
+
+/**
+ * implementation of MD5 as outlined in &quot;Handbook of Applied Cryptography&quot;, pages 346 - 347.
+ */
+public class MD5Digest
+    extends GeneralDigest
+{
+    private static final int    DIGEST_LENGTH = 16;
+
+    private int     H1, H2, H3, H4;         // IV's
+
+    private int[]   X = new int[16];
+    private int     xOff;
+
+    /**
+     * Standard constructor
+     */
+    public MD5Digest()
+    {
+        reset();
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public MD5Digest(MD5Digest t)
+    {
+        super(t);
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+
+        System.arraycopy(t.X, 0, X, 0, t.X.length);
+        xOff = t.xOff;
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;MD5&quot;;
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        X[xOff++] = (in[inOff] &amp; 0xff) | ((in[inOff + 1] &amp; 0xff) &lt;&lt; 8)
+            | ((in[inOff + 2] &amp; 0xff) &lt;&lt; 16) | ((in[inOff + 3] &amp; 0xff) &lt;&lt; 24); 
+
+        if (xOff == 16)
+        {
+            processBlock();
+        }
+    }
+
+    protected void processLength(
+        long    bitLength)
+    {
+        if (xOff &gt; 14)
+        {
+            processBlock();
+        }
+
+        X[14] = (int)(bitLength &amp; 0xffffffff);
+        X[15] = (int)(bitLength &gt;&gt;&gt; 32);
+    }
+
+    private void unpackWord(
+        int     word,
+        byte[]  out,
+        int     outOff)
+    {
+        out[outOff]     = (byte)word;
+        out[outOff + 1] = (byte)(word &gt;&gt;&gt; 8);
+        out[outOff + 2] = (byte)(word &gt;&gt;&gt; 16);
+        out[outOff + 3] = (byte)(word &gt;&gt;&gt; 24);
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        unpackWord(H1, out, outOff);
+        unpackWord(H2, out, outOff + 4);
+        unpackWord(H3, out, outOff + 8);
+        unpackWord(H4, out, outOff + 12);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables to the IV values.
+     */
+    public void reset()
+    {
+        super.reset();
+
+        H1 = 0x67452301;
+        H2 = 0xefcdab89;
+        H3 = 0x98badcfe;
+        H4 = 0x10325476;
+
+        xOff = 0;
+
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    //
+    // round 1 left rotates
+    //
+    private static final int S11 = 7;
+    private static final int S12 = 12;
+    private static final int S13 = 17;
+    private static final int S14 = 22;
+
+    //
+    // round 2 left rotates
+    //
+    private static final int S21 = 5;
+    private static final int S22 = 9;
+    private static final int S23 = 14;
+    private static final int S24 = 20;
+
+    //
+    // round 3 left rotates
+    //
+    private static final int S31 = 4;
+    private static final int S32 = 11;
+    private static final int S33 = 16;
+    private static final int S34 = 23;
+
+    //
+    // round 4 left rotates
+    //
+    private static final int S41 = 6;
+    private static final int S42 = 10;
+    private static final int S43 = 15;
+    private static final int S44 = 21;
+
+    /*
+     * rotate int x left n bits.
+     */
+    private int rotateLeft(
+        int x,
+        int n)
+    {
+        return (x &lt;&lt; n) | (x &gt;&gt;&gt; (32 - n));
+    }
+
+    /*
+     * F, G, H and I are the basic MD5 functions.
+     */
+    private int F(
+        int u,
+        int v,
+        int w)
+    {
+        return (u &amp; v) | (~u &amp; w);
+    }
+
+    private int G(
+        int u,
+        int v,
+        int w)
+    {
+        return (u &amp; w) | (v &amp; ~w);
+    }
+
+    private int H(
+        int u,
+        int v,
+        int w)
+    {
+        return u ^ v ^ w;
+    }
+
+    private int K(
+        int u,
+        int v,
+        int w)
+    {
+        return v ^ (u | ~w);
+    }
+
+    protected void processBlock()
+    {
+        int a = H1;
+        int b = H2;
+        int c = H3;
+        int d = H4;
+
+        //
+        // Round 1 - F cycle, 16 times.
+        //
+        a = rotateLeft(a + F(b, c, d) + X[ 0] + 0xd76aa478, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[ 1] + 0xe8c7b756, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[ 2] + 0x242070db, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[ 3] + 0xc1bdceee, S14) + c;
+        a = rotateLeft(a + F(b, c, d) + X[ 4] + 0xf57c0faf, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[ 5] + 0x4787c62a, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[ 6] + 0xa8304613, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[ 7] + 0xfd469501, S14) + c;
+        a = rotateLeft(a + F(b, c, d) + X[ 8] + 0x698098d8, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[ 9] + 0x8b44f7af, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[10] + 0xffff5bb1, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[11] + 0x895cd7be, S14) + c;
+        a = rotateLeft(a + F(b, c, d) + X[12] + 0x6b901122, S11) + b;
+        d = rotateLeft(d + F(a, b, c) + X[13] + 0xfd987193, S12) + a;
+        c = rotateLeft(c + F(d, a, b) + X[14] + 0xa679438e, S13) + d;
+        b = rotateLeft(b + F(c, d, a) + X[15] + 0x49b40821, S14) + c;
+
+        //
+        // Round 2 - G cycle, 16 times.
+        //
+        a = rotateLeft(a + G(b, c, d) + X[ 1] + 0xf61e2562, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[ 6] + 0xc040b340, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[11] + 0x265e5a51, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[ 0] + 0xe9b6c7aa, S24) + c;
+        a = rotateLeft(a + G(b, c, d) + X[ 5] + 0xd62f105d, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[10] + 0x02441453, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[15] + 0xd8a1e681, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[ 4] + 0xe7d3fbc8, S24) + c;
+        a = rotateLeft(a + G(b, c, d) + X[ 9] + 0x21e1cde6, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[14] + 0xc33707d6, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[ 3] + 0xf4d50d87, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[ 8] + 0x455a14ed, S24) + c;
+        a = rotateLeft(a + G(b, c, d) + X[13] + 0xa9e3e905, S21) + b;
+        d = rotateLeft(d + G(a, b, c) + X[ 2] + 0xfcefa3f8, S22) + a;
+        c = rotateLeft(c + G(d, a, b) + X[ 7] + 0x676f02d9, S23) + d;
+        b = rotateLeft(b + G(c, d, a) + X[12] + 0x8d2a4c8a, S24) + c;
+
+        //
+        // Round 3 - H cycle, 16 times.
+        //
+        a = rotateLeft(a + H(b, c, d) + X[ 5] + 0xfffa3942, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[ 8] + 0x8771f681, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[11] + 0x6d9d6122, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[14] + 0xfde5380c, S34) + c;
+        a = rotateLeft(a + H(b, c, d) + X[ 1] + 0xa4beea44, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[ 4] + 0x4bdecfa9, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[ 7] + 0xf6bb4b60, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[10] + 0xbebfbc70, S34) + c;
+        a = rotateLeft(a + H(b, c, d) + X[13] + 0x289b7ec6, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[ 0] + 0xeaa127fa, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[ 3] + 0xd4ef3085, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[ 6] + 0x04881d05, S34) + c;
+        a = rotateLeft(a + H(b, c, d) + X[ 9] + 0xd9d4d039, S31) + b;
+        d = rotateLeft(d + H(a, b, c) + X[12] + 0xe6db99e5, S32) + a;
+        c = rotateLeft(c + H(d, a, b) + X[15] + 0x1fa27cf8, S33) + d;
+        b = rotateLeft(b + H(c, d, a) + X[ 2] + 0xc4ac5665, S34) + c;
+
+        //
+        // Round 4 - K cycle, 16 times.
+        //
+        a = rotateLeft(a + K(b, c, d) + X[ 0] + 0xf4292244, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[ 7] + 0x432aff97, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[14] + 0xab9423a7, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[ 5] + 0xfc93a039, S44) + c;
+        a = rotateLeft(a + K(b, c, d) + X[12] + 0x655b59c3, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[ 3] + 0x8f0ccc92, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[10] + 0xffeff47d, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[ 1] + 0x85845dd1, S44) + c;
+        a = rotateLeft(a + K(b, c, d) + X[ 8] + 0x6fa87e4f, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[15] + 0xfe2ce6e0, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[ 6] + 0xa3014314, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[13] + 0x4e0811a1, S44) + c;
+        a = rotateLeft(a + K(b, c, d) + X[ 4] + 0xf7537e82, S41) + b;
+        d = rotateLeft(d + K(a, b, c) + X[11] + 0xbd3af235, S42) + a;
+        c = rotateLeft(c + K(d, a, b) + X[ 2] + 0x2ad7d2bb, S43) + d;
+        b = rotateLeft(b + K(c, d, a) + X[ 9] + 0xeb86d391, S44) + c;
+
+        H1 += a;
+        H2 += b;
+        H3 += c;
+        H4 += d;
+
+        //
+        // reset the offset and clean out the word buffer.
+        //
+        xOff = 0;
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/NullDigest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/NullDigest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/NullDigest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/NullDigest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,48 @@
+package org.bouncycastle.crypto.digests;
+
+import ewe.io.ByteArrayOutputStream;
+
+import org.bouncycastle.crypto.Digest;
+
+
+public class NullDigest
+    implements Digest
+{
+    private ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+
+    public String getAlgorithmName()
+    {
+        return &quot;NULL&quot;;
+    }
+
+    public int getDigestSize()
+    {
+        return bOut.size();
+    }
+
+    public void update(byte in)
+    {
+        bOut.write(in);
+    }
+
+    public void update(byte[] in, int inOff, int len)
+    {
+        bOut.write(in, inOff, len);
+    }
+
+    public int doFinal(byte[] out, int outOff)
+    {
+        byte[] res = bOut.toByteArray();
+
+        System.arraycopy(res, 0, out, outOff, res.length);
+
+        reset();
+        
+        return res.length;
+    }
+
+    public void reset()
+    {
+        bOut.reset();
+    }
+}
\ No newline at end of file

Added: trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA1Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,290 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.util.Pack;
+
+/**
+ * implementation of SHA-1 as outlined in &quot;Handbook of Applied Cryptography&quot;, pages 346 - 349.
+ *
+ * It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
+ * is the &quot;endienness&quot; of the word processing!
+ */
+public class SHA1Digest
+    extends GeneralDigest
+{
+    private static final int    DIGEST_LENGTH = 20;
+
+    private int     H1, H2, H3, H4, H5;
+
+    private int[]   X = new int[80];
+    private int     xOff;
+
+    /**
+     * Standard constructor
+     */
+    public SHA1Digest()
+    {
+        reset();
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA1Digest(SHA1Digest t)
+    {
+        super(t);
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+        H5 = t.H5;
+
+        System.arraycopy(t.X, 0, X, 0, t.X.length);
+        xOff = t.xOff;
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;SHA-1&quot;;
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        // Note: Inlined for performance
+//        X[xOff] = Pack.bigEndianToInt(in, inOff);
+        int n = in[  inOff] &lt;&lt; 24;
+        n |= (in[++inOff] &amp; 0xff) &lt;&lt; 16;
+        n |= (in[++inOff] &amp; 0xff) &lt;&lt; 8;
+        n |= (in[++inOff] &amp; 0xff);
+        X[xOff] = n;
+
+        if (++xOff == 16)
+        {
+            processBlock();
+        }        
+    }
+
+    protected void processLength(
+        long    bitLength)
+    {
+        if (xOff &gt; 14)
+        {
+            processBlock();
+        }
+
+        X[14] = (int)(bitLength &gt;&gt;&gt; 32);
+        X[15] = (int)(bitLength &amp; 0xffffffff);
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.intToBigEndian(H1, out, outOff);
+        Pack.intToBigEndian(H2, out, outOff + 4);
+        Pack.intToBigEndian(H3, out, outOff + 8);
+        Pack.intToBigEndian(H4, out, outOff + 12);
+        Pack.intToBigEndian(H5, out, outOff + 16);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        H1 = 0x67452301;
+        H2 = 0xefcdab89;
+        H3 = 0x98badcfe;
+        H4 = 0x10325476;
+        H5 = 0xc3d2e1f0;
+
+        xOff = 0;
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    //
+    // Additive constants
+    //
+    private static final int    Y1 = 0x5a827999;
+    private static final int    Y2 = 0x6ed9eba1;
+    private static final int    Y3 = 0x8f1bbcdc;
+    private static final int    Y4 = 0xca62c1d6;
+   
+    private int f(
+        int    u,
+        int    v,
+        int    w)
+    {
+        return ((u &amp; v) | ((~u) &amp; w));
+    }
+
+    private int h(
+        int    u,
+        int    v,
+        int    w)
+    {
+        return (u ^ v ^ w);
+    }
+
+    private int g(
+        int    u,
+        int    v,
+        int    w)
+    {
+        return ((u &amp; v) | (u &amp; w) | (v &amp; w));
+    }
+
+    protected void processBlock()
+    {
+        //
+        // expand 16 word block into 80 word block.
+        //
+        for (int i = 16; i &lt; 80; i++)
+        {
+            int t = X[i - 3] ^ X[i - 8] ^ X[i - 14] ^ X[i - 16];
+            X[i] = t &lt;&lt; 1 | t &gt;&gt;&gt; 31;
+        }
+
+        //
+        // set up working variables.
+        //
+        int     A = H1;
+        int     B = H2;
+        int     C = H3;
+        int     D = H4;
+        int     E = H5;
+
+        //
+        // round 1
+        //
+        int idx = 0;
+        
+        for (int j = 0; j &lt; 4; j++)
+        {
+            // E = rotateLeft(A, 5) + f(B, C, D) + E + X[idx++] + Y1
+            // B = rotateLeft(B, 30)
+            E += (A &lt;&lt; 5 | A &gt;&gt;&gt; 27) + f(B, C, D) + X[idx++] + Y1;
+            B = B &lt;&lt; 30 | B &gt;&gt;&gt; 2;
+        
+            D += (E &lt;&lt; 5 | E &gt;&gt;&gt; 27) + f(A, B, C) + X[idx++] + Y1;
+            A = A &lt;&lt; 30 | A &gt;&gt;&gt; 2;
+       
+            C += (D &lt;&lt; 5 | D &gt;&gt;&gt; 27) + f(E, A, B) + X[idx++] + Y1;
+            E = E &lt;&lt; 30 | E &gt;&gt;&gt; 2;
+       
+            B += (C &lt;&lt; 5 | C &gt;&gt;&gt; 27) + f(D, E, A) + X[idx++] + Y1;
+            D = D &lt;&lt; 30 | D &gt;&gt;&gt; 2;
+
+            A += (B &lt;&lt; 5 | B &gt;&gt;&gt; 27) + f(C, D, E) + X[idx++] + Y1;
+            C = C &lt;&lt; 30 | C &gt;&gt;&gt; 2;
+        }
+        
+        //
+        // round 2
+        //
+        for (int j = 0; j &lt; 4; j++)
+        {
+            // E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y2
+            // B = rotateLeft(B, 30)
+            E += (A &lt;&lt; 5 | A &gt;&gt;&gt; 27) + h(B, C, D) + X[idx++] + Y2;
+            B = B &lt;&lt; 30 | B &gt;&gt;&gt; 2;   
+            
+            D += (E &lt;&lt; 5 | E &gt;&gt;&gt; 27) + h(A, B, C) + X[idx++] + Y2;
+            A = A &lt;&lt; 30 | A &gt;&gt;&gt; 2;
+            
+            C += (D &lt;&lt; 5 | D &gt;&gt;&gt; 27) + h(E, A, B) + X[idx++] + Y2;
+            E = E &lt;&lt; 30 | E &gt;&gt;&gt; 2;
+            
+            B += (C &lt;&lt; 5 | C &gt;&gt;&gt; 27) + h(D, E, A) + X[idx++] + Y2;
+            D = D &lt;&lt; 30 | D &gt;&gt;&gt; 2;
+
+            A += (B &lt;&lt; 5 | B &gt;&gt;&gt; 27) + h(C, D, E) + X[idx++] + Y2;
+            C = C &lt;&lt; 30 | C &gt;&gt;&gt; 2;
+        }
+        
+        //
+        // round 3
+        //
+        for (int j = 0; j &lt; 4; j++)
+        {
+            // E = rotateLeft(A, 5) + g(B, C, D) + E + X[idx++] + Y3
+            // B = rotateLeft(B, 30)
+            E += (A &lt;&lt; 5 | A &gt;&gt;&gt; 27) + g(B, C, D) + X[idx++] + Y3;
+            B = B &lt;&lt; 30 | B &gt;&gt;&gt; 2;
+            
+            D += (E &lt;&lt; 5 | E &gt;&gt;&gt; 27) + g(A, B, C) + X[idx++] + Y3;
+            A = A &lt;&lt; 30 | A &gt;&gt;&gt; 2;
+            
+            C += (D &lt;&lt; 5 | D &gt;&gt;&gt; 27) + g(E, A, B) + X[idx++] + Y3;
+            E = E &lt;&lt; 30 | E &gt;&gt;&gt; 2;
+            
+            B += (C &lt;&lt; 5 | C &gt;&gt;&gt; 27) + g(D, E, A) + X[idx++] + Y3;
+            D = D &lt;&lt; 30 | D &gt;&gt;&gt; 2;
+
+            A += (B &lt;&lt; 5 | B &gt;&gt;&gt; 27) + g(C, D, E) + X[idx++] + Y3;
+            C = C &lt;&lt; 30 | C &gt;&gt;&gt; 2;
+        }
+
+        //
+        // round 4
+        //
+        for (int j = 0; j &lt;= 3; j++)
+        {
+            // E = rotateLeft(A, 5) + h(B, C, D) + E + X[idx++] + Y4
+            // B = rotateLeft(B, 30)
+            E += (A &lt;&lt; 5 | A &gt;&gt;&gt; 27) + h(B, C, D) + X[idx++] + Y4;
+            B = B &lt;&lt; 30 | B &gt;&gt;&gt; 2;
+            
+            D += (E &lt;&lt; 5 | E &gt;&gt;&gt; 27) + h(A, B, C) + X[idx++] + Y4;
+            A = A &lt;&lt; 30 | A &gt;&gt;&gt; 2;
+            
+            C += (D &lt;&lt; 5 | D &gt;&gt;&gt; 27) + h(E, A, B) + X[idx++] + Y4;
+            E = E &lt;&lt; 30 | E &gt;&gt;&gt; 2;
+            
+            B += (C &lt;&lt; 5 | C &gt;&gt;&gt; 27) + h(D, E, A) + X[idx++] + Y4;
+            D = D &lt;&lt; 30 | D &gt;&gt;&gt; 2;
+
+            A += (B &lt;&lt; 5 | B &gt;&gt;&gt; 27) + h(C, D, E) + X[idx++] + Y4;
+            C = C &lt;&lt; 30 | C &gt;&gt;&gt; 2;
+        }
+
+
+        H1 += A;
+        H2 += B;
+        H3 += C;
+        H4 += D;
+        H5 += E;
+
+        //
+        // reset start of the buffer.
+        //
+        xOff = 0;
+        for (int i = 0; i &lt; 16; i++)
+        {
+            X[i] = 0;
+        }
+    }
+}
+
+
+
+

Added: trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA256Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,295 @@
+package org.bouncycastle.crypto.digests;
+
+
+import org.bouncycastle.crypto.digests.GeneralDigest;
+import org.bouncycastle.crypto.util.Pack;
+
+
+/**
+ * FIPS 180-2 implementation of SHA-256.
+ *
+ * &lt;pre&gt;
+ *         block  word  digest
+ * SHA-1   512    32    160
+ * SHA-256 512    32    256
+ * SHA-384 1024   64    384
+ * SHA-512 1024   64    512
+ * &lt;/pre&gt;
+ */
+public class SHA256Digest
+    extends GeneralDigest
+{
+    private static final int    DIGEST_LENGTH = 32;
+
+    private int     H1, H2, H3, H4, H5, H6, H7, H8;
+
+    private int[]   X = new int[64];
+    private int     xOff;
+
+    /**
+     * Standard constructor
+     */
+    public SHA256Digest()
+    {
+        reset();
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA256Digest(SHA256Digest t)
+    {
+        super(t);
+
+        H1 = t.H1;
+        H2 = t.H2;
+        H3 = t.H3;
+        H4 = t.H4;
+        H5 = t.H5;
+        H6 = t.H6;
+        H7 = t.H7;
+        H8 = t.H8;
+
+        System.arraycopy(t.X, 0, X, 0, t.X.length);
+        xOff = t.xOff;
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;SHA-256&quot;;
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    protected void processWord(
+        byte[]  in,
+        int     inOff)
+    {
+        // Note: Inlined for performance
+//        X[xOff] = Pack.bigEndianToInt(in, inOff);
+        int n = in[inOff] &lt;&lt; 24;
+        n |= (in[++inOff] &amp; 0xff) &lt;&lt; 16;
+        n |= (in[++inOff] &amp; 0xff) &lt;&lt; 8;
+        n |= (in[++inOff] &amp; 0xff);
+        X[xOff] = n;
+
+        if (++xOff == 16)
+        {
+            processBlock();
+        }
+    }
+
+    protected void processLength(
+        long    bitLength)
+    {
+        if (xOff &gt; 14)
+        {
+            processBlock();
+        }
+
+        X[14] = (int)(bitLength &gt;&gt;&gt; 32);
+        X[15] = (int)(bitLength &amp; 0xffffffff);
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.intToBigEndian(H1, out, outOff);
+        Pack.intToBigEndian(H2, out, outOff + 4);
+        Pack.intToBigEndian(H3, out, outOff + 8);
+        Pack.intToBigEndian(H4, out, outOff + 12);
+        Pack.intToBigEndian(H5, out, outOff + 16);
+        Pack.intToBigEndian(H6, out, outOff + 20);
+        Pack.intToBigEndian(H7, out, outOff + 24);
+        Pack.intToBigEndian(H8, out, outOff + 28);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        /* SHA-256 initial hash value
+         * The first 32 bits of the fractional parts of the square roots
+         * of the first eight prime numbers
+         */
+
+        H1 = 0x6a09e667;
+        H2 = 0xbb67ae85;
+        H3 = 0x3c6ef372;
+        H4 = 0xa54ff53a;
+        H5 = 0x510e527f;
+        H6 = 0x9b05688c;
+        H7 = 0x1f83d9ab;
+        H8 = 0x5be0cd19;
+
+        xOff = 0;
+        for (int i = 0; i != X.length; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    protected void processBlock()
+    {
+        //
+        // expand 16 word block into 64 word blocks.
+        //
+        for (int t = 16; t &lt;= 63; t++)
+        {
+            X[t] = Theta1(X[t - 2]) + X[t - 7] + Theta0(X[t - 15]) + X[t - 16];
+        }
+
+        //
+        // set up working variables.
+        //
+        int     a = H1;
+        int     b = H2;
+        int     c = H3;
+        int     d = H4;
+        int     e = H5;
+        int     f = H6;
+        int     g = H7;
+        int     h = H8;
+
+        int t = 0;     
+        for(int i = 0; i &lt; 8; i ++)
+        {
+            // t = 8 * i
+            h += Sum1(e) + Ch(e, f, g) + K[t] + X[t];
+            d += h;
+            h += Sum0(a) + Maj(a, b, c);
+            ++t;
+
+            // t = 8 * i + 1
+            g += Sum1(d) + Ch(d, e, f) + K[t] + X[t];
+            c += g;
+            g += Sum0(h) + Maj(h, a, b);
+            ++t;
+
+            // t = 8 * i + 2
+            f += Sum1(c) + Ch(c, d, e) + K[t] + X[t];
+            b += f;
+            f += Sum0(g) + Maj(g, h, a);
+            ++t;
+
+            // t = 8 * i + 3
+            e += Sum1(b) + Ch(b, c, d) + K[t] + X[t];
+            a += e;
+            e += Sum0(f) + Maj(f, g, h);
+            ++t;
+
+            // t = 8 * i + 4
+            d += Sum1(a) + Ch(a, b, c) + K[t] + X[t];
+            h += d;
+            d += Sum0(e) + Maj(e, f, g);
+            ++t;
+
+            // t = 8 * i + 5
+            c += Sum1(h) + Ch(h, a, b) + K[t] + X[t];
+            g += c;
+            c += Sum0(d) + Maj(d, e, f);
+            ++t;
+
+            // t = 8 * i + 6
+            b += Sum1(g) + Ch(g, h, a) + K[t] + X[t];
+            f += b;
+            b += Sum0(c) + Maj(c, d, e);
+            ++t;
+
+            // t = 8 * i + 7
+            a += Sum1(f) + Ch(f, g, h) + K[t] + X[t];
+            e += a;
+            a += Sum0(b) + Maj(b, c, d);
+            ++t;
+        }
+
+        H1 += a;
+        H2 += b;
+        H3 += c;
+        H4 += d;
+        H5 += e;
+        H6 += f;
+        H7 += g;
+        H8 += h;
+
+        //
+        // reset the offset and clean out the word buffer.
+        //
+        xOff = 0;
+        for (int i = 0; i &lt; 16; i++)
+        {
+            X[i] = 0;
+        }
+    }
+
+    /* SHA-256 functions */
+    private int Ch(
+        int    x,
+        int    y,
+        int    z)
+    {
+        return (x &amp; y) ^ ((~x) &amp; z);
+    }
+
+    private int Maj(
+        int    x,
+        int    y,
+        int    z)
+    {
+        return (x &amp; y) ^ (x &amp; z) ^ (y &amp; z);
+    }
+
+    private int Sum0(
+        int    x)
+    {
+        return ((x &gt;&gt;&gt; 2) | (x &lt;&lt; 30)) ^ ((x &gt;&gt;&gt; 13) | (x &lt;&lt; 19)) ^ ((x &gt;&gt;&gt; 22) | (x &lt;&lt; 10));
+    }
+
+    private int Sum1(
+        int    x)
+    {
+        return ((x &gt;&gt;&gt; 6) | (x &lt;&lt; 26)) ^ ((x &gt;&gt;&gt; 11) | (x &lt;&lt; 21)) ^ ((x &gt;&gt;&gt; 25) | (x &lt;&lt; 7));
+    }
+
+    private int Theta0(
+        int    x)
+    {
+        return ((x &gt;&gt;&gt; 7) | (x &lt;&lt; 25)) ^ ((x &gt;&gt;&gt; 18) | (x &lt;&lt; 14)) ^ (x &gt;&gt;&gt; 3);
+    }
+
+    private int Theta1(
+        int    x)
+    {
+        return ((x &gt;&gt;&gt; 17) | (x &lt;&lt; 15)) ^ ((x &gt;&gt;&gt; 19) | (x &lt;&lt; 13)) ^ (x &gt;&gt;&gt; 10);
+    }
+
+    /* SHA-256 Constants
+     * (represent the first 32 bits of the fractional parts of the
+     * cube roots of the first sixty-four prime numbers)
+     */
+    static final int K[] = {
+        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+    };
+}
+

Added: trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA384Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,87 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.util.Pack;
+
+
+/**
+ * FIPS 180-2 implementation of SHA-384.
+ *
+ * &lt;pre&gt;
+ *         block  word  digest
+ * SHA-1   512    32    160
+ * SHA-256 512    32    256
+ * SHA-384 1024   64    384
+ * SHA-512 1024   64    512
+ * &lt;/pre&gt;
+ */
+public class SHA384Digest
+    extends LongDigest
+{
+
+    private static final int    DIGEST_LENGTH = 48;
+
+    /**
+     * Standard constructor
+     */
+    public SHA384Digest()
+    {
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA384Digest(SHA384Digest t)
+    {
+        super(t);
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;SHA-384&quot;;
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.longToBigEndian(H1, out, outOff);
+        Pack.longToBigEndian(H2, out, outOff + 8);
+        Pack.longToBigEndian(H3, out, outOff + 16);
+        Pack.longToBigEndian(H4, out, outOff + 24);
+        Pack.longToBigEndian(H5, out, outOff + 32);
+        Pack.longToBigEndian(H6, out, outOff + 40);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        /* SHA-384 initial hash value
+         * The first 64 bits of the fractional parts of the square roots
+         * of the 9th through 16th prime numbers
+         */
+        H1 = 0xcbbb9d5dc1059ed8l;
+        H2 = 0x629a292a367cd507l;
+        H3 = 0x9159015a3070dd17l;
+        H4 = 0x152fecd8f70e5939l;
+        H5 = 0x67332667ffc00b31l;
+        H6 = 0x8eb44a8768581511l;
+        H7 = 0xdb0c2e0d64f98fa7l;
+        H8 = 0x47b5481dbefa4fa4l;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/SHA512Digest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,89 @@
+package org.bouncycastle.crypto.digests;
+
+import org.bouncycastle.crypto.util.Pack;
+
+
+/**
+ * FIPS 180-2 implementation of SHA-512.
+ *
+ * &lt;pre&gt;
+ *         block  word  digest
+ * SHA-1   512    32    160
+ * SHA-256 512    32    256
+ * SHA-384 1024   64    384
+ * SHA-512 1024   64    512
+ * &lt;/pre&gt;
+ */
+public class SHA512Digest
+    extends LongDigest
+{
+    private static final int    DIGEST_LENGTH = 64;
+
+    /**
+     * Standard constructor
+     */
+    public SHA512Digest()
+    {
+    }
+
+    /**
+     * Copy constructor.  This will copy the state of the provided
+     * message digest.
+     */
+    public SHA512Digest(SHA512Digest t)
+    {
+        super(t);
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;SHA-512&quot;;
+    }
+
+    public int getDigestSize()
+    {
+        return DIGEST_LENGTH;
+    }
+
+    public int doFinal(
+        byte[]  out,
+        int     outOff)
+    {
+        finish();
+
+        Pack.longToBigEndian(H1, out, outOff);
+        Pack.longToBigEndian(H2, out, outOff + 8);
+        Pack.longToBigEndian(H3, out, outOff + 16);
+        Pack.longToBigEndian(H4, out, outOff + 24);
+        Pack.longToBigEndian(H5, out, outOff + 32);
+        Pack.longToBigEndian(H6, out, outOff + 40);
+        Pack.longToBigEndian(H7, out, outOff + 48);
+        Pack.longToBigEndian(H8, out, outOff + 56);
+
+        reset();
+
+        return DIGEST_LENGTH;
+    }
+
+    /**
+     * reset the chaining variables
+     */
+    public void reset()
+    {
+        super.reset();
+
+        /* SHA-512 initial hash value
+         * The first 64 bits of the fractional parts of the square roots
+         * of the first eight prime numbers
+         */
+        H1 = 0x6a09e667f3bcc908L;
+        H2 = 0xbb67ae8584caa73bL;
+        H3 = 0x3c6ef372fe94f82bL;
+        H4 = 0xa54ff53a5f1d36f1L;
+        H5 = 0x510e527fade682d1L;
+        H6 = 0x9b05688c2b3e6c1fL;
+        H7 = 0x1f83d9abfb41bd6bL;
+        H8 = 0x5be0cd19137e2179L;
+    }
+}
+

Added: trunk/src/org/bouncycastle/crypto/digests/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/digests/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/digests/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Message digest classes.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/encodings/PKCS1Encoding.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,247 @@
+package org.bouncycastle.crypto.encodings;
+
+// import java.security.AccessController;
+// import java.security.PrivilegedAction;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.AsymmetricBlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.InvalidCipherTextException;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+/**
+ * this does your basic PKCS 1 v1.5 padding - whether or not you should be using this
+ * depends on your application - see PKCS1 Version 2 for details.
+ */
+public class PKCS1Encoding
+    implements AsymmetricBlockCipher
+{
+    /**
+     * some providers fail to include the leading zero in PKCS1 encoded blocks. If you need to
+     * work with one of these set the system property org.bouncycastle.pkcs1.strict to false.
+     * &lt;p&gt;
+     * The system property is checked during construction of the encoding object, it is set to
+     * true by default.
+     * &lt;/p&gt;
+     */
+    public static final String STRICT_LENGTH_ENABLED_PROPERTY = &quot;org.bouncycastle.pkcs1.strict&quot;;
+
+    private static final int HEADER_LENGTH = 10;
+
+    private SecureRandom            random;
+    private AsymmetricBlockCipher   engine;
+    private boolean                 forEncryption;
+    private boolean                 forPrivateKey;
+    private boolean                 useStrictLength;
+
+    /**
+     * Basic constructor.
+     * @param cipher
+     */
+    public PKCS1Encoding(AsymmetricBlockCipher cipher)
+    {
+        this.engine = cipher;
+        this.useStrictLength = useStrict();
+    }
+
+    //
+    // for J2ME compatibility
+    //
+    private boolean useStrict()
+    {
+        // required if security manager has been installed.
+        String strict = null; /*(String)AccessController.doPrivileged(new PrivilegedAction()
+        {
+            public Object run()
+            {
+                return System.getProperty(STRICT_LENGTH_ENABLED_PROPERTY);
+            }
+        }); */
+
+        return strict == null || strict.equals(&quot;true&quot;);
+    }
+
+    public AsymmetricBlockCipher getUnderlyingCipher()
+    {
+        return engine;
+    }
+
+    public void init(
+        boolean             forEncryption,
+        CipherParameters    param)
+    {
+        AsymmetricKeyParameter  kParam;
+
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+            this.random = rParam.getRandom();  
+            kParam = (AsymmetricKeyParameter)rParam.getParameters();
+        }
+        else
+        {
+            this.random = new SecureRandom();
+            kParam = (AsymmetricKeyParameter)param;
+        }
+
+        engine.init(forEncryption, param);
+
+        this.forPrivateKey = kParam.isPrivate();
+        this.forEncryption = forEncryption;
+    }
+
+    public int getInputBlockSize()
+    {
+        int     baseBlockSize = engine.getInputBlockSize();
+
+        if (forEncryption)
+        {
+            return baseBlockSize - HEADER_LENGTH;
+        }
+        else
+        {
+            return baseBlockSize;
+        }
+    }
+
+    public int getOutputBlockSize()
+    {
+        int     baseBlockSize = engine.getOutputBlockSize();
+
+        if (forEncryption)
+        {
+            return baseBlockSize;
+        }
+        else
+        {
+            return baseBlockSize - HEADER_LENGTH;
+        }
+    }
+
+    public byte[] processBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+        throws InvalidCipherTextException
+    {
+        if (forEncryption)
+        {
+            return encodeBlock(in, inOff, inLen);
+        }
+        else
+        {
+            return decodeBlock(in, inOff, inLen);
+        }
+    }
+
+    private byte[] encodeBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+        throws InvalidCipherTextException
+    {
+        if (inLen &gt; getInputBlockSize())
+        {
+            throw new IllegalArgumentException(&quot;input data too large&quot;);
+        }
+
+        byte[]  block = new byte[engine.getInputBlockSize()];
+
+        if (forPrivateKey)
+        {
+            block[0] = 0x01;                        // type code 1
+
+            for (int i = 1; i != block.length - inLen - 1; i++)
+            {
+                block[i] = (byte)0xFF;
+            }
+        }
+        else
+        {
+            random.nextBytes(block);                // random fill
+
+            block[0] = 0x02;                        // type code 2
+
+            //
+            // a zero byte marks the end of the padding, so all
+            // the pad bytes must be non-zero.
+            //
+            for (int i = 1; i != block.length - inLen - 1; i++)
+            {
+                while (block[i] == 0)
+                {
+                    block[i] = (byte)11; // 
+                    int test = random.nextInt();
+                }
+            }
+        }
+
+        block[block.length - inLen - 1] = 0x00;       // mark the end of the padding
+        System.arraycopy(in, inOff, block, block.length - inLen, inLen);
+
+        return engine.processBlock(block, 0, block.length);
+    }
+
+    /**
+     * @exception InvalidCipherTextException if the decrypted block is not in PKCS1 format.
+     */
+    private byte[] decodeBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+        throws InvalidCipherTextException
+    {
+        byte[]  block = engine.processBlock(in, inOff, inLen);
+
+        if (block.length &lt; getOutputBlockSize())
+        {
+            throw new InvalidCipherTextException(&quot;block truncated&quot;);
+        }
+
+        byte type = block[0];
+
+        if (type != 1 &amp;&amp; type != 2)
+        {
+            throw new InvalidCipherTextException(&quot;unknown block type&quot;);
+        }
+
+        if (useStrictLength &amp;&amp; block.length != engine.getOutputBlockSize())
+        {
+            throw new InvalidCipherTextException(&quot;block incorrect size&quot;);
+        }
+
+        //
+        // find and extract the message block.
+        //
+        int start;
+
+        for (start = 1; start != block.length; start++)
+        {
+            byte pad = block[start];
+
+            if (pad == 0)
+            {
+                break;
+            }
+            if (type == 1 &amp;&amp; pad != (byte)0xff)
+            {
+                throw new InvalidCipherTextException(&quot;block padding incorrect&quot;);
+            }
+        }
+
+        start++;           // data should start at the next byte
+
+        if (start &gt; block.length || start &lt; HEADER_LENGTH)
+        {
+            throw new InvalidCipherTextException(&quot;no data in block&quot;);
+        }
+
+        byte[]  result = new byte[block.length - start];
+
+        System.arraycopy(block, start, result, 0, result.length);
+
+        return result;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/encodings/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/encodings/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/encodings/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Block encodings for asymmetric ciphers.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/AESFastEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,876 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * an implementation of the AES (Rijndael), from FIPS-197.
+ * &lt;p&gt;
+ * For further details see: &lt;a href=&quot;<A HREF="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</A>&quot;&gt;<A HREF="http://csrc.nist.gov/encryption/aes/&lt;/a">http://csrc.nist.gov/encryption/aes/&lt;/a</A>&gt;.
+ *
+ * This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
+ * &lt;a href=&quot;<A HREF="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</A>&quot;&gt;<A HREF="http://fp.gladman.plus.com/cryptography_technology/rijndael/&lt;/a">http://fp.gladman.plus.com/cryptography_technology/rijndael/&lt;/a</A>&gt;
+ *
+ * There are three levels of tradeoff of speed vs memory
+ * Because java has no preprocessor, they are written as three separate classes from which to choose
+ *
+ * The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
+ * and 4 for decryption.
+ *
+ * The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
+ * adding 12 rotate operations per round to compute the values contained in the other tables from
+ * the contents of the first
+ *
+ * The slowest version uses no static tables at all and computes the values in each round
+ * &lt;p&gt;
+ * This file contains the fast version with 8Kbytes of static tables for round precomputation
+ *
+ */
+public class AESFastEngine
+    implements BlockCipher
+{
+    // The S box
+    private static final byte[] S = {
+        (byte)99, (byte)124, (byte)119, (byte)123, (byte)242, (byte)107, (byte)111, (byte)197,
+        (byte)48,   (byte)1, (byte)103,  (byte)43, (byte)254, (byte)215, (byte)171, (byte)118,
+        (byte)202, (byte)130, (byte)201, (byte)125, (byte)250,  (byte)89,  (byte)71, (byte)240,
+        (byte)173, (byte)212, (byte)162, (byte)175, (byte)156, (byte)164, (byte)114, (byte)192,
+        (byte)183, (byte)253, (byte)147,  (byte)38,  (byte)54,  (byte)63, (byte)247, (byte)204,
+        (byte)52, (byte)165, (byte)229, (byte)241, (byte)113, (byte)216,  (byte)49,  (byte)21,
+        (byte)4, (byte)199,  (byte)35, (byte)195,  (byte)24, (byte)150,   (byte)5, (byte)154,
+        (byte)7,  (byte)18, (byte)128, (byte)226, (byte)235,  (byte)39, (byte)178, (byte)117,
+        (byte)9, (byte)131,  (byte)44,  (byte)26,  (byte)27, (byte)110,  (byte)90, (byte)160,
+        (byte)82,  (byte)59, (byte)214, (byte)179,  (byte)41, (byte)227,  (byte)47, (byte)132,
+        (byte)83, (byte)209,   (byte)0, (byte)237,  (byte)32, (byte)252, (byte)177,  (byte)91,
+        (byte)106, (byte)203, (byte)190,  (byte)57,  (byte)74,  (byte)76,  (byte)88, (byte)207,
+        (byte)208, (byte)239, (byte)170, (byte)251,  (byte)67,  (byte)77,  (byte)51, (byte)133,
+        (byte)69, (byte)249,   (byte)2, (byte)127,  (byte)80,  (byte)60, (byte)159, (byte)168,
+        (byte)81, (byte)163,  (byte)64, (byte)143, (byte)146, (byte)157,  (byte)56, (byte)245,
+        (byte)188, (byte)182, (byte)218,  (byte)33,  (byte)16, (byte)255, (byte)243, (byte)210,
+        (byte)205,  (byte)12,  (byte)19, (byte)236,  (byte)95, (byte)151,  (byte)68,  (byte)23,
+        (byte)196, (byte)167, (byte)126,  (byte)61, (byte)100,  (byte)93,  (byte)25, (byte)115,
+        (byte)96, (byte)129,  (byte)79, (byte)220,  (byte)34,  (byte)42, (byte)144, (byte)136,
+        (byte)70, (byte)238, (byte)184,  (byte)20, (byte)222,  (byte)94,  (byte)11, (byte)219,
+        (byte)224,  (byte)50,  (byte)58,  (byte)10,  (byte)73,   (byte)6,  (byte)36,  (byte)92,
+        (byte)194, (byte)211, (byte)172,  (byte)98, (byte)145, (byte)149, (byte)228, (byte)121,
+        (byte)231, (byte)200,  (byte)55, (byte)109, (byte)141, (byte)213,  (byte)78, (byte)169,
+        (byte)108,  (byte)86, (byte)244, (byte)234, (byte)101, (byte)122, (byte)174,   (byte)8,
+        (byte)186, (byte)120,  (byte)37,  (byte)46,  (byte)28, (byte)166, (byte)180, (byte)198,
+        (byte)232, (byte)221, (byte)116,  (byte)31,  (byte)75, (byte)189, (byte)139, (byte)138,
+        (byte)112,  (byte)62, (byte)181, (byte)102,  (byte)72,   (byte)3, (byte)246,  (byte)14,
+        (byte)97,  (byte)53,  (byte)87, (byte)185, (byte)134, (byte)193,  (byte)29, (byte)158,
+        (byte)225, (byte)248, (byte)152,  (byte)17, (byte)105, (byte)217, (byte)142, (byte)148,
+        (byte)155,  (byte)30, (byte)135, (byte)233, (byte)206,  (byte)85,  (byte)40, (byte)223,
+        (byte)140, (byte)161, (byte)137,  (byte)13, (byte)191, (byte)230,  (byte)66, (byte)104,
+        (byte)65, (byte)153,  (byte)45,  (byte)15, (byte)176,  (byte)84, (byte)187,  (byte)22,
+    };
+
+    // The inverse S-box
+    private static final byte[] Si = {
+        (byte)82,   (byte)9, (byte)106, (byte)213,  (byte)48,  (byte)54, (byte)165,  (byte)56,
+        (byte)191,  (byte)64, (byte)163, (byte)158, (byte)129, (byte)243, (byte)215, (byte)251,
+        (byte)124, (byte)227,  (byte)57, (byte)130, (byte)155,  (byte)47, (byte)255, (byte)135,
+        (byte)52, (byte)142,  (byte)67,  (byte)68, (byte)196, (byte)222, (byte)233, (byte)203,
+        (byte)84, (byte)123, (byte)148,  (byte)50, (byte)166, (byte)194,  (byte)35,  (byte)61,
+        (byte)238,  (byte)76, (byte)149,  (byte)11,  (byte)66, (byte)250, (byte)195,  (byte)78,
+        (byte)8,  (byte)46, (byte)161, (byte)102,  (byte)40, (byte)217,  (byte)36, (byte)178,
+        (byte)118,  (byte)91, (byte)162,  (byte)73, (byte)109, (byte)139, (byte)209,  (byte)37,
+        (byte)114, (byte)248, (byte)246, (byte)100, (byte)134, (byte)104, (byte)152,  (byte)22,
+        (byte)212, (byte)164,  (byte)92, (byte)204,  (byte)93, (byte)101, (byte)182, (byte)146,
+        (byte)108, (byte)112,  (byte)72,  (byte)80, (byte)253, (byte)237, (byte)185, (byte)218,
+        (byte)94,  (byte)21,  (byte)70,  (byte)87, (byte)167, (byte)141, (byte)157, (byte)132,
+        (byte)144, (byte)216, (byte)171,   (byte)0, (byte)140, (byte)188, (byte)211,  (byte)10,
+        (byte)247, (byte)228,  (byte)88,   (byte)5, (byte)184, (byte)179,  (byte)69,   (byte)6,
+        (byte)208,  (byte)44,  (byte)30, (byte)143, (byte)202,  (byte)63,  (byte)15,   (byte)2,
+        (byte)193, (byte)175, (byte)189,   (byte)3,   (byte)1,  (byte)19, (byte)138, (byte)107,
+        (byte)58, (byte)145,  (byte)17,  (byte)65,  (byte)79, (byte)103, (byte)220, (byte)234,
+        (byte)151, (byte)242, (byte)207, (byte)206, (byte)240, (byte)180, (byte)230, (byte)115,
+        (byte)150, (byte)172, (byte)116,  (byte)34, (byte)231, (byte)173,  (byte)53, (byte)133,
+        (byte)226, (byte)249,  (byte)55, (byte)232,  (byte)28, (byte)117, (byte)223, (byte)110,
+        (byte)71, (byte)241,  (byte)26, (byte)113,  (byte)29,  (byte)41, (byte)197, (byte)137,
+        (byte)111, (byte)183,  (byte)98,  (byte)14, (byte)170,  (byte)24, (byte)190,  (byte)27,
+        (byte)252,  (byte)86,  (byte)62,  (byte)75, (byte)198, (byte)210, (byte)121,  (byte)32,
+        (byte)154, (byte)219, (byte)192, (byte)254, (byte)120, (byte)205,  (byte)90, (byte)244,
+        (byte)31, (byte)221, (byte)168,  (byte)51, (byte)136,   (byte)7, (byte)199,  (byte)49,
+        (byte)177,  (byte)18,  (byte)16,  (byte)89,  (byte)39, (byte)128, (byte)236,  (byte)95,
+        (byte)96,  (byte)81, (byte)127, (byte)169,  (byte)25, (byte)181,  (byte)74,  (byte)13,
+        (byte)45, (byte)229, (byte)122, (byte)159, (byte)147, (byte)201, (byte)156, (byte)239,
+        (byte)160, (byte)224,  (byte)59,  (byte)77, (byte)174,  (byte)42, (byte)245, (byte)176,
+        (byte)200, (byte)235, (byte)187,  (byte)60, (byte)131,  (byte)83, (byte)153,  (byte)97,
+        (byte)23,  (byte)43,   (byte)4, (byte)126, (byte)186, (byte)119, (byte)214,  (byte)38,
+        (byte)225, (byte)105,  (byte)20,  (byte)99,  (byte)85,  (byte)33,  (byte)12, (byte)125,
+        };
+
+    // vector used in calculating key schedule (powers of x in GF(256))
+    private static final int[] rcon = {
+         0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
+         0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 };
+
+    // precomputation tables of calculations for rounds
+    private static final int[] T0 =
+    {
+     0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6, 0x0df2f2ff, 
+     0xbd6b6bd6, 0xb16f6fde, 0x54c5c591, 0x50303060, 0x03010102, 
+     0xa96767ce, 0x7d2b2b56, 0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 
+     0x9a7676ec, 0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa, 
+     0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb, 0xecadad41, 
+     0x67d4d4b3, 0xfda2a25f, 0xeaafaf45, 0xbf9c9c23, 0xf7a4a453, 
+     0x967272e4, 0x5bc0c09b, 0xc2b7b775, 0x1cfdfde1, 0xae93933d, 
+     0x6a26264c, 0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83, 
+     0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9, 0x937171e2, 
+     0x73d8d8ab, 0x53313162, 0x3f15152a, 0x0c040408, 0x52c7c795, 
+     0x65232346, 0x5ec3c39d, 0x28181830, 0xa1969637, 0x0f05050a, 
+     0xb59a9a2f, 0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df, 
+     0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea, 0x1b090912, 
+     0x9e83831d, 0x742c2c58, 0x2e1a1a34, 0x2d1b1b36, 0xb26e6edc, 
+     0xee5a5ab4, 0xfba0a05b, 0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 
+     0xceb3b37d, 0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413, 
+     0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1, 0x60202040, 
+     0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6, 0xbe6a6ad4, 0x46cbcb8d, 
+     0xd9bebe67, 0x4b393972, 0xde4a4a94, 0xd44c4c98, 0xe85858b0, 
+     0x4acfcf85, 0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed, 
+     0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511, 0xcf45458a, 
+     0x10f9f9e9, 0x06020204, 0x817f7ffe, 0xf05050a0, 0x443c3c78, 
+     0xba9f9f25, 0xe3a8a84b, 0xf35151a2, 0xfea3a35d, 0xc0404080, 
+     0x8a8f8f05, 0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1, 
+     0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142, 0x30101020, 
+     0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf, 0x4ccdcd81, 0x140c0c18, 
+     0x35131326, 0x2fececc3, 0xe15f5fbe, 0xa2979735, 0xcc444488, 
+     0x3917172e, 0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a, 
+     0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6, 0xa06060c0, 
+     0x98818119, 0xd14f4f9e, 0x7fdcdca3, 0x66222244, 0x7e2a2a54, 
+     0xab90903b, 0x8388880b, 0xca46468c, 0x29eeeec7, 0xd3b8b86b, 
+     0x3c141428, 0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad, 
+     0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14, 0xdb494992, 
+     0x0a06060c, 0x6c242448, 0xe45c5cb8, 0x5dc2c29f, 0x6ed3d3bd, 
+     0xefacac43, 0xa66262c4, 0xa8919139, 0xa4959531, 0x37e4e4d3, 
+     0x8b7979f2, 0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda, 
+     0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949, 0xb46c6cd8, 
+     0xfa5656ac, 0x07f4f4f3, 0x25eaeacf, 0xaf6565ca, 0x8e7a7af4, 
+     0xe9aeae47, 0x18080810, 0xd5baba6f, 0x887878f0, 0x6f25254a, 
+     0x722e2e5c, 0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697, 
+     0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e, 0xdd4b4b96, 
+     0xdcbdbd61, 0x868b8b0d, 0x858a8a0f, 0x907070e0, 0x423e3e7c, 
+     0xc4b5b571, 0xaa6666cc, 0xd8484890, 0x05030306, 0x01f6f6f7, 
+     0x120e0e1c, 0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969, 
+     0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27, 0x38e1e1d9, 
+     0x13f8f8eb, 0xb398982b, 0x33111122, 0xbb6969d2, 0x70d9d9a9, 
+     0x898e8e07, 0xa7949433, 0xb69b9b2d, 0x221e1e3c, 0x92878715, 
+     0x20e9e9c9, 0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5, 
+     0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a, 0xdabfbf65, 
+     0x31e6e6d7, 0xc6424284, 0xb86868d0, 0xc3414182, 0xb0999929, 
+     0x772d2d5a, 0x110f0f1e, 0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 
+     0x3a16162c};
+
+    private static final int[] T1 =
+    {
+     0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d, 0xf2f2ff0d, 
+     0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154, 0x30306050, 0x01010203, 
+     0x6767cea9, 0x2b2b567d, 0xfefee719, 0xd7d7b562, 0xabab4de6, 
+     0x7676ec9a, 0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87, 
+     0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b, 0xadad41ec, 
+     0xd4d4b367, 0xa2a25ffd, 0xafaf45ea, 0x9c9c23bf, 0xa4a453f7, 
+     0x7272e496, 0xc0c09b5b, 0xb7b775c2, 0xfdfde11c, 0x93933dae, 
+     0x26264c6a, 0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f, 
+     0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908, 0x7171e293, 
+     0xd8d8ab73, 0x31316253, 0x15152a3f, 0x0404080c, 0xc7c79552, 
+     0x23234665, 0xc3c39d5e, 0x18183028, 0x969637a1, 0x05050a0f, 
+     0x9a9a2fb5, 0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d, 
+     0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f, 0x0909121b, 
+     0x83831d9e, 0x2c2c5874, 0x1a1a342e, 0x1b1b362d, 0x6e6edcb2, 
+     0x5a5ab4ee, 0xa0a05bfb, 0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 
+     0xb3b37dce, 0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397, 
+     0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c, 0x20204060, 
+     0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed, 0x6a6ad4be, 0xcbcb8d46, 
+     0xbebe67d9, 0x3939724b, 0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 
+     0xcfcf854a, 0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16, 
+     0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194, 0x45458acf, 
+     0xf9f9e910, 0x02020406, 0x7f7ffe81, 0x5050a0f0, 0x3c3c7844, 
+     0x9f9f25ba, 0xa8a84be3, 0x5151a2f3, 0xa3a35dfe, 0x404080c0, 
+     0x8f8f058a, 0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104, 
+     0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263, 0x10102030, 
+     0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d, 0xcdcd814c, 0x0c0c1814, 
+     0x13132635, 0xececc32f, 0x5f5fbee1, 0x979735a2, 0x444488cc, 
+     0x17172e39, 0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47, 
+     0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695, 0x6060c0a0, 
+     0x81811998, 0x4f4f9ed1, 0xdcdca37f, 0x22224466, 0x2a2a547e, 
+     0x90903bab, 0x88880b83, 0x46468cca, 0xeeeec729, 0xb8b86bd3, 
+     0x1414283c, 0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76, 
+     0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e, 0x494992db, 
+     0x06060c0a, 0x2424486c, 0x5c5cb8e4, 0xc2c29f5d, 0xd3d3bd6e, 
+     0xacac43ef, 0x6262c4a6, 0x919139a8, 0x959531a4, 0xe4e4d337, 
+     0x7979f28b, 0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7, 
+     0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0, 0x6c6cd8b4, 
+     0x5656acfa, 0xf4f4f307, 0xeaeacf25, 0x6565caaf, 0x7a7af48e, 
+     0xaeae47e9, 0x08081018, 0xbaba6fd5, 0x7878f088, 0x25254a6f, 
+     0x2e2e5c72, 0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751, 
+     0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21, 0x4b4b96dd, 
+     0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85, 0x7070e090, 0x3e3e7c42, 
+     0xb5b571c4, 0x6666ccaa, 0x484890d8, 0x03030605, 0xf6f6f701, 
+     0x0e0e1c12, 0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0, 
+     0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9, 0xe1e1d938, 
+     0xf8f8eb13, 0x98982bb3, 0x11112233, 0x6969d2bb, 0xd9d9a970, 
+     0x8e8e0789, 0x949433a7, 0x9b9b2db6, 0x1e1e3c22, 0x87871592, 
+     0xe9e9c920, 0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a, 
+     0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17, 0xbfbf65da, 
+     0xe6e6d731, 0x424284c6, 0x6868d0b8, 0x414182c3, 0x999929b0, 
+     0x2d2d5a77, 0x0f0f1e11, 0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 
+     0x16162c3a};
+
+    private static final int[] T2 =
+    {
+     0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b, 0xf2ff0df2, 
+     0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5, 0x30605030, 0x01020301, 
+     0x67cea967, 0x2b567d2b, 0xfee719fe, 0xd7b562d7, 0xab4de6ab, 
+     0x76ec9a76, 0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d, 
+     0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0, 0xad41ecad, 
+     0xd4b367d4, 0xa25ffda2, 0xaf45eaaf, 0x9c23bf9c, 0xa453f7a4, 
+     0x72e49672, 0xc09b5bc0, 0xb775c2b7, 0xfde11cfd, 0x933dae93, 
+     0x264c6a26, 0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc, 
+     0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1, 0x71e29371, 
+     0xd8ab73d8, 0x31625331, 0x152a3f15, 0x04080c04, 0xc79552c7, 
+     0x23466523, 0xc39d5ec3, 0x18302818, 0x9637a196, 0x050a0f05, 
+     0x9a2fb59a, 0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2, 
+     0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75, 0x09121b09, 
+     0x831d9e83, 0x2c58742c, 0x1a342e1a, 0x1b362d1b, 0x6edcb26e, 
+     0x5ab4ee5a, 0xa05bfba0, 0x52a4f652, 0x3b764d3b, 0xd6b761d6, 
+     0xb37dceb3, 0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784, 
+     0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced, 0x20406020, 
+     0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b, 0x6ad4be6a, 0xcb8d46cb, 
+     0xbe67d9be, 0x39724b39, 0x4a94de4a, 0x4c98d44c, 0x58b0e858, 
+     0xcf854acf, 0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb, 
+     0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485, 0x458acf45, 
+     0xf9e910f9, 0x02040602, 0x7ffe817f, 0x50a0f050, 0x3c78443c, 
+     0x9f25ba9f, 0xa84be3a8, 0x51a2f351, 0xa35dfea3, 0x4080c040, 
+     0x8f058a8f, 0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5, 
+     0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321, 0x10203010, 
+     0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2, 0xcd814ccd, 0x0c18140c, 
+     0x13263513, 0xecc32fec, 0x5fbee15f, 0x9735a297, 0x4488cc44, 
+     0x172e3917, 0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d, 
+     0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573, 0x60c0a060, 
+     0x81199881, 0x4f9ed14f, 0xdca37fdc, 0x22446622, 0x2a547e2a, 
+     0x903bab90, 0x880b8388, 0x468cca46, 0xeec729ee, 0xb86bd3b8, 
+     0x14283c14, 0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db, 
+     0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a, 0x4992db49, 
+     0x060c0a06, 0x24486c24, 0x5cb8e45c, 0xc29f5dc2, 0xd3bd6ed3, 
+     0xac43efac, 0x62c4a662, 0x9139a891, 0x9531a495, 0xe4d337e4, 
+     0x79f28b79, 0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d, 
+     0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9, 0x6cd8b46c, 
+     0x56acfa56, 0xf4f307f4, 0xeacf25ea, 0x65caaf65, 0x7af48e7a, 
+     0xae47e9ae, 0x08101808, 0xba6fd5ba, 0x78f08878, 0x254a6f25, 
+     0x2e5c722e, 0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6, 
+     0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f, 0x4b96dd4b, 
+     0xbd61dcbd, 0x8b0d868b, 0x8a0f858a, 0x70e09070, 0x3e7c423e, 
+     0xb571c4b5, 0x66ccaa66, 0x4890d848, 0x03060503, 0xf6f701f6, 
+     0x0e1c120e, 0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9, 
+     0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e, 0xe1d938e1, 
+     0xf8eb13f8, 0x982bb398, 0x11223311, 0x69d2bb69, 0xd9a970d9, 
+     0x8e07898e, 0x9433a794, 0x9b2db69b, 0x1e3c221e, 0x87159287, 
+     0xe9c920e9, 0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf, 
+     0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d, 0xbf65dabf, 
+     0xe6d731e6, 0x4284c642, 0x68d0b868, 0x4182c341, 0x9929b099, 
+     0x2d5a772d, 0x0f1e110f, 0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 
+     0x162c3a16};
+
+    private static final int[] T3 =
+    {
+     0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b, 0xff0df2f2, 
+     0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5, 0x60503030, 0x02030101, 
+     0xcea96767, 0x567d2b2b, 0xe719fefe, 0xb562d7d7, 0x4de6abab, 
+     0xec9a7676, 0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d, 
+     0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0, 0x41ecadad, 
+     0xb367d4d4, 0x5ffda2a2, 0x45eaafaf, 0x23bf9c9c, 0x53f7a4a4, 
+     0xe4967272, 0x9b5bc0c0, 0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 
+     0x4c6a2626, 0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc, 
+     0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1, 0xe2937171, 
+     0xab73d8d8, 0x62533131, 0x2a3f1515, 0x080c0404, 0x9552c7c7, 
+     0x46652323, 0x9d5ec3c3, 0x30281818, 0x37a19696, 0x0a0f0505, 
+     0x2fb59a9a, 0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2, 
+     0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575, 0x121b0909, 
+     0x1d9e8383, 0x58742c2c, 0x342e1a1a, 0x362d1b1b, 0xdcb26e6e, 
+     0xb4ee5a5a, 0x5bfba0a0, 0xa4f65252, 0x764d3b3b, 0xb761d6d6, 
+     0x7dceb3b3, 0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484, 
+     0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded, 0x40602020, 
+     0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b, 0xd4be6a6a, 0x8d46cbcb, 
+     0x67d9bebe, 0x724b3939, 0x94de4a4a, 0x98d44c4c, 0xb0e85858, 
+     0x854acfcf, 0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb, 
+     0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585, 0x8acf4545, 
+     0xe910f9f9, 0x04060202, 0xfe817f7f, 0xa0f05050, 0x78443c3c, 
+     0x25ba9f9f, 0x4be3a8a8, 0xa2f35151, 0x5dfea3a3, 0x80c04040, 
+     0x058a8f8f, 0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5, 
+     0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121, 0x20301010, 
+     0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2, 0x814ccdcd, 0x18140c0c, 
+     0x26351313, 0xc32fecec, 0xbee15f5f, 0x35a29797, 0x88cc4444, 
+     0x2e391717, 0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d, 
+     0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373, 0xc0a06060, 
+     0x19988181, 0x9ed14f4f, 0xa37fdcdc, 0x44662222, 0x547e2a2a, 
+     0x3bab9090, 0x0b838888, 0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 
+     0x283c1414, 0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb, 
+     0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a, 0x92db4949, 
+     0x0c0a0606, 0x486c2424, 0xb8e45c5c, 0x9f5dc2c2, 0xbd6ed3d3, 
+     0x43efacac, 0xc4a66262, 0x39a89191, 0x31a49595, 0xd337e4e4, 
+     0xf28b7979, 0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d, 
+     0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9, 0xd8b46c6c, 
+     0xacfa5656, 0xf307f4f4, 0xcf25eaea, 0xcaaf6565, 0xf48e7a7a, 
+     0x47e9aeae, 0x10180808, 0x6fd5baba, 0xf0887878, 0x4a6f2525, 
+     0x5c722e2e, 0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6, 
+     0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f, 0x96dd4b4b, 
+     0x61dcbdbd, 0x0d868b8b, 0x0f858a8a, 0xe0907070, 0x7c423e3e, 
+     0x71c4b5b5, 0xccaa6666, 0x90d84848, 0x06050303, 0xf701f6f6, 
+     0x1c120e0e, 0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9, 
+     0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e, 0xd938e1e1, 
+     0xeb13f8f8, 0x2bb39898, 0x22331111, 0xd2bb6969, 0xa970d9d9, 
+     0x07898e8e, 0x33a79494, 0x2db69b9b, 0x3c221e1e, 0x15928787, 
+     0xc920e9e9, 0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf, 
+     0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d, 0x65dabfbf, 
+     0xd731e6e6, 0x84c64242, 0xd0b86868, 0x82c34141, 0x29b09999, 
+     0x5a772d2d, 0x1e110f0f, 0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 
+     0x2c3a1616};
+
+    private static final int[] Tinv0 =
+    {
+     0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, 
+     0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, 
+     0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 
+     0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 
+     0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, 
+     0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, 
+     0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, 
+     0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 
+     0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, 
+     0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, 
+     0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, 
+     0x2aab5566, 0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3, 
+     0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, 
+     0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, 
+     0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, 
+     0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd, 
+     0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, 
+     0x055dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, 
+     0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, 
+     0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000, 
+     0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, 
+     0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, 
+     0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0x0fe75793, 0xd296eeb4, 
+     0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 
+     0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0x0b0d090e, 
+     0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, 
+     0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, 
+     0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 
+     0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, 
+     0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, 
+     0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, 
+     0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 
+     0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, 
+     0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0x0d927850, 
+     0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, 
+     0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 
+     0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x097826cd, 
+     0xf418596e, 0x01b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, 
+     0x08cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, 
+     0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 
+     0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, 
+     0xf7daec41, 0x0e50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, 
+     0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 
+     0x7f516546, 0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 
+     0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, 
+     0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, 
+     0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, 
+     0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 
+     0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, 
+     0x0c25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, 
+     0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, 
+     0x4257b8d0};
+
+    private static final int[] Tinv1 =
+    {
+     0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 0x6bab3bcb, 
+     0x459d1ff1, 0x58faacab, 0x03e34b93, 0xfa302055, 0x6d76adf6, 
+     0x76cc8891, 0x4c02f525, 0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 
+     0xa362b58f, 0x5ab1de49, 0x1bba2567, 0x0eea4598, 0xc0fe5de1, 
+     0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 0x5f8f03e7, 
+     0x9c921595, 0x7a6dbfeb, 0x595295da, 0x83bed42d, 0x217458d3, 
+     0x69e04929, 0xc8c98e44, 0x89c2756a, 0x798ef478, 0x3e58996b, 
+     0x71b927dd, 0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 
+     0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 0x7764b1e0, 
+     0xae6bbb84, 0xa081fe1c, 0x2b08f994, 0x68487058, 0xfd458f19, 
+     0x6cde9487, 0xf87b52b7, 0xd373ab23, 0x024b72e2, 0x8f1fe357, 
+     0xab55662a, 0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x0837d3a5, 
+     0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 0x1ccf8a2b, 
+     0xb479a792, 0xf207f3f0, 0xe2694ea1, 0xf4da65cd, 0xbe0506d5, 
+     0x6234d11f, 0xfea6c48a, 0x532e349d, 0x55f3a2a0, 0xe18a0532, 
+     0xebf6a475, 0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 
+     0x8a213ef9, 0x06dd963d, 0x053eddae, 0xbde64d46, 0x8d5491b5, 
+     0x5dc47105, 0xd406046f, 0x155060ff, 0xfb981924, 0xe9bdd697, 
+     0x434089cc, 0x9ed96777, 0x42e8b0bd, 0x8b890788, 0x5b19e738, 
+     0xeec879db, 0x0a7ca147, 0x0f427ce9, 0x1e84f8c9, 0x00000000, 
+     0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 0xff0efdfb, 
+     0x38850f56, 0xd5ae3d1e, 0x392d3627, 0xd90f0a64, 0xa65c6821, 
+     0x545b9bd1, 0x2e36243a, 0x670a0cb1, 0xe757930f, 0x96eeb4d2, 
+     0x919b1b9e, 0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 
+     0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 0x0d090e0b, 
+     0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 0x19f15785, 0x0775af4c, 
+     0xdd99eebb, 0x607fa3fd, 0x2601f79f, 0xf5725cbc, 0x3b6644c5, 
+     0x7efb5b34, 0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 
+     0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 0x244a857d, 
+     0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 0x2f9e1d4b, 0x30b2dcf3, 
+     0x52860dec, 0xe3c177d0, 0x16b32b6c, 0xb970a999, 0x489411fa, 
+     0x64e94722, 0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 
+     0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0x0bd49836, 0x81f5a6cf, 
+     0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 0x9d3a2ce4, 0x9278500d, 
+     0xcc5f6a9b, 0x467e5462, 0x138df6c2, 0xb8d890e8, 0xf7392e5e, 
+     0xafc382f5, 0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 
+     0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 0x7826cd09, 
+     0x18596ef4, 0xb79aec01, 0x9a4f83a8, 0x6e95e665, 0xe6ffaa7e, 
+     0xcfbc2108, 0xe815efe6, 0x9be7bad9, 0x366f4ace, 0x099fead4, 
+     0x7cb029d6, 0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 
+     0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 0x9804f14a, 
+     0xdaec41f7, 0x50cd7f0e, 0xf691172f, 0xd64d768d, 0xb0ef434d, 
+     0x4daacc54, 0x0496e4df, 0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 
+     0x5165467f, 0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 
+     0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 0x61d79a8c, 
+     0x0ca1377a, 0x14f8598e, 0x3c13eb89, 0x27a9ceee, 0xc961b735, 
+     0xe51ce1ed, 0xb1477a3c, 0xdfd29c59, 0x73f2553f, 0xce141879, 
+     0x37c773bf, 0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 
+     0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 0xc31d1672, 
+     0x25e2bc0c, 0x493c288b, 0x950dff41, 0x01a83971, 0xb30c08de, 
+     0xe4b4d89c, 0xc1566490, 0x84cb7b61, 0xb632d570, 0x5c6c4874, 
+     0x57b8d042};
+
+    private static final int[] Tinv2 =
+    {
+     0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 0xab3bcb6b, 
+     0x9d1ff145, 0xfaacab58, 0xe34b9303, 0x302055fa, 0x76adf66d, 
+     0xcc889176, 0x02f5254c, 0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 
+     0x62b58fa3, 0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 
+     0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 0x8f03e75f, 
+     0x9215959c, 0x6dbfeb7a, 0x5295da59, 0xbed42d83, 0x7458d321, 
+     0xe0492969, 0xc98e44c8, 0xc2756a89, 0x8ef47879, 0x58996b3e, 
+     0xb927dd71, 0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 
+     0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 0x64b1e077, 
+     0x6bbb84ae, 0x81fe1ca0, 0x08f9942b, 0x48705868, 0x458f19fd, 
+     0xde94876c, 0x7b52b7f8, 0x73ab23d3, 0x4b72e202, 0x1fe3578f, 
+     0x55662aab, 0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 
+     0x2830f287, 0xbf23b2a5, 0x0302ba6a, 0x16ed5c82, 0xcf8a2b1c, 
+     0x79a792b4, 0x07f3f0f2, 0x694ea1e2, 0xda65cdf4, 0x0506d5be, 
+     0x34d11f62, 0xa6c48afe, 0x2e349d53, 0xf3a2a055, 0x8a0532e1, 
+     0xf6a475eb, 0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 
+     0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 0x5491b58d, 
+     0xc471055d, 0x06046fd4, 0x5060ff15, 0x981924fb, 0xbdd697e9, 
+     0x4089cc43, 0xd967779e, 0xe8b0bd42, 0x8907888b, 0x19e7385b, 
+     0xc879dbee, 0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x00000000, 
+     0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 0x0efdfbff, 
+     0x850f5638, 0xae3d1ed5, 0x2d362739, 0x0f0a64d9, 0x5c6821a6, 
+     0x5b9bd154, 0x36243a2e, 0x0a0cb167, 0x57930fe7, 0xeeb4d296, 
+     0x9b1b9e91, 0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 
+     0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 0x090e0b0d, 
+     0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 0xf1578519, 0x75af4c07, 
+     0x99eebbdd, 0x7fa3fd60, 0x01f79f26, 0x725cbcf5, 0x6644c53b, 
+     0xfb5b347e, 0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 
+     0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 0x4a857d24, 
+     0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 0x9e1d4b2f, 0xb2dcf330, 
+     0x860dec52, 0xc177d0e3, 0xb32b6c16, 0x70a999b9, 0x9411fa48, 
+     0xe9472264, 0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 
+     0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 0xf5a6cf81, 
+     0x7aa528de, 0xb7da268e, 0xad3fa4bf, 0x3a2ce49d, 0x78500d92, 
+     0x5f6a9bcc, 0x7e546246, 0x8df6c213, 0xd890e8b8, 0x392e5ef7, 
+     0xc382f5af, 0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 
+     0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 0x26cd0978, 
+     0x596ef418, 0x9aec01b7, 0x4f83a89a, 0x95e6656e, 0xffaa7ee6, 
+     0xbc2108cf, 0x15efe6e8, 0xe7bad99b, 0x6f4ace36, 0x9fead409, 
+     0xb029d67c, 0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 
+     0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 0x04f14a98, 
+     0xec41f7da, 0xcd7f0e50, 0x91172ff6, 0x4d768dd6, 0xef434db0, 
+     0xaacc544d, 0x96e4df04, 0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 
+     0x65467f51, 0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0x0bfb2e41, 
+     0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 0xd79a8c61, 
+     0xa1377a0c, 0xf8598e14, 0x13eb893c, 0xa9ceee27, 0x61b735c9, 
+     0x1ce1ede5, 0x477a3cb1, 0xd29c59df, 0xf2553f73, 0x141879ce, 
+     0xc773bf37, 0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 
+     0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 0x1d1672c3, 
+     0xe2bc0c25, 0x3c288b49, 0x0dff4195, 0xa8397101, 0x0c08deb3, 
+     0xb4d89ce4, 0x566490c1, 0xcb7b6184, 0x32d570b6, 0x6c48745c, 
+     0xb8d04257};
+
+    private static final int[] Tinv3 =
+    {
+     0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 0x3bcb6bab, 
+     0x1ff1459d, 0xacab58fa, 0x4b9303e3, 0x2055fa30, 0xadf66d76, 
+     0x889176cc, 0xf5254c02, 0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 
+     0xb58fa362, 0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 
+     0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 0x03e75f8f, 
+     0x15959c92, 0xbfeb7a6d, 0x95da5952, 0xd42d83be, 0x58d32174, 
+     0x492969e0, 0x8e44c8c9, 0x756a89c2, 0xf478798e, 0x996b3e58, 
+     0x27dd71b9, 0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 
+     0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 0xb1e07764, 
+     0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 0x70586848, 0x8f19fd45, 
+     0x94876cde, 0x52b7f87b, 0xab23d373, 0x72e2024b, 0xe3578f1f, 
+     0x662aab55, 0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 
+     0x30f28728, 0x23b2a5bf, 0x02ba6a03, 0xed5c8216, 0x8a2b1ccf, 
+     0xa792b479, 0xf3f0f207, 0x4ea1e269, 0x65cdf4da, 0x06d5be05, 
+     0xd11f6234, 0xc48afea6, 0x349d532e, 0xa2a055f3, 0x0532e18a, 
+     0xa475ebf6, 0x0b39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 
+     0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 0x91b58d54, 
+     0x71055dc4, 0x046fd406, 0x60ff1550, 0x1924fb98, 0xd697e9bd, 
+     0x89cc4340, 0x67779ed9, 0xb0bd42e8, 0x07888b89, 0xe7385b19, 
+     0x79dbeec8, 0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x00000000, 
+     0x09838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 0xfdfbff0e, 
+     0x0f563885, 0x3d1ed5ae, 0x3627392d, 0x0a64d90f, 0x6821a65c, 
+     0x9bd1545b, 0x243a2e36, 0x0cb1670a, 0x930fe757, 0xb4d296ee, 
+     0x1b9e919b, 0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 
+     0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 0x0e0b0d09, 
+     0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 0x578519f1, 0xaf4c0775, 
+     0xeebbdd99, 0xa3fd607f, 0xf79f2601, 0x5cbcf572, 0x44c53b66, 
+     0x5b347efb, 0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 
+     0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 0x857d244a, 
+     0xd2f83dbb, 0xae1132f9, 0xc76da129, 0x1d4b2f9e, 0xdcf330b2, 
+     0x0dec5286, 0x77d0e3c1, 0x2b6c16b3, 0xa999b970, 0x11fa4894, 
+     0x472264e9, 0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 
+     0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 0xa6cf81f5, 
+     0xa528de7a, 0xda268eb7, 0x3fa4bfad, 0x2ce49d3a, 0x500d9278, 
+     0x6a9bcc5f, 0x5462467e, 0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 
+     0x82f5afc3, 0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 
+     0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 0xcd097826, 
+     0x6ef41859, 0xec01b79a, 0x83a89a4f, 0xe6656e95, 0xaa7ee6ff, 
+     0x2108cfbc, 0xefe6e815, 0xbad99be7, 0x4ace366f, 0xead4099f, 
+     0x29d67cb0, 0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 
+     0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 0xf14a9804, 
+     0x41f7daec, 0x7f0e50cd, 0x172ff691, 0x768dd64d, 0x434db0ef, 
+     0xcc544daa, 0xe4df0496, 0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 
+     0x467f5165, 0x9d04ea5e, 0x015d358c, 0xfa737487, 0xfb2e410b, 
+     0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 0x9a8c61d7, 
+     0x377a0ca1, 0x598e14f8, 0xeb893c13, 0xceee27a9, 0xb735c961, 
+     0xe1ede51c, 0x7a3cb147, 0x9c59dfd2, 0x553f73f2, 0x1879ce14, 
+     0x73bf37c7, 0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 
+     0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 0x1672c31d, 
+     0xbc0c25e2, 0x288b493c, 0xff41950d, 0x397101a8, 0x08deb30c, 
+     0xd89ce4b4, 0x6490c156, 0x7b6184cb, 0xd570b632, 0x48745c6c, 
+     0xd04257b8};
+
+    private int shift(
+        int     r,
+        int     shift)
+    {
+        return (r &gt;&gt;&gt; shift) | (r &lt;&lt; -shift);
+    }
+
+    /* multiply four bytes in GF(2^8) by 'x' {02} in parallel */
+
+    private static final int m1 = 0x80808080;
+    private static final int m2 = 0x7f7f7f7f;
+    private static final int m3 = 0x0000001b;
+
+    private int FFmulX(int x)
+    {
+        return (((x &amp; m2) &lt;&lt; 1) ^ (((x &amp; m1) &gt;&gt;&gt; 7) * m3));
+    }
+
+    /* 
+       The following defines provide alternative definitions of FFmulX that might
+       give improved performance if a fast 32-bit multiply is not available.
+       
+       private int FFmulX(int x) { int u = x &amp; m1; u |= (u &gt;&gt; 1); return ((x &amp; m2) &lt;&lt; 1) ^ ((u &gt;&gt;&gt; 3) | (u &gt;&gt;&gt; 6)); } 
+       private static final int  m4 = 0x1b1b1b1b;
+       private int FFmulX(int x) { int u = x &amp; m1; return ((x &amp; m2) &lt;&lt; 1) ^ ((u - (u &gt;&gt;&gt; 7)) &amp; m4); } 
+
+    */
+
+    private int inv_mcol(int x)
+    {
+        int f2 = FFmulX(x);
+        int f4 = FFmulX(f2);
+        int f8 = FFmulX(f4);
+        int f9 = x ^ f8;
+        
+        return f2 ^ f4 ^ f8 ^ shift(f2 ^ f9, 8) ^ shift(f4 ^ f9, 16) ^ shift(f9, 24);
+    }
+
+
+    private int subWord(int x)
+    {
+        return (S[x&amp;255]&amp;255 | ((S[(x&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) | ((S[(x&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) | S[(x&gt;&gt;24)&amp;255]&lt;&lt;24);
+    }
+
+    /**
+     * Calculate the necessary round keys
+     * The number of calculations depends on key size and block size
+     * AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
+     * This code is written assuming those are the only possible values
+     */
+    private int[][] generateWorkingKey(
+                                    byte[] key,
+                                    boolean forEncryption)
+    {
+        int         KC = key.length / 4;  // key length in words
+        int         t;
+        
+        if (((KC != 4) &amp;&amp; (KC != 6) &amp;&amp; (KC != 8)) || ((KC * 4) != key.length))
+        {
+            throw new IllegalArgumentException(&quot;Key length not 128/192/256 bits.&quot;);
+        }
+
+        ROUNDS = KC + 6;  // This is not always true for the generalized Rijndael that allows larger block sizes
+        int[][] W = new int[ROUNDS+1][4];   // 4 words in a block
+        
+        //
+        // copy the key into the round key array
+        //
+        
+        t = 0;
+        int i = 0;
+        while (i &lt; key.length)
+        {
+            W[t &gt;&gt; 2][t &amp; 3] = (key[i]&amp;0xff) | ((key[i+1]&amp;0xff) &lt;&lt; 8) | ((key[i+2]&amp;0xff) &lt;&lt; 16) | (key[i+3] &lt;&lt; 24);
+            i+=4;
+            t++;
+        }
+        
+        //
+        // while not enough round key material calculated
+        // calculate new values
+        //
+        int k = (ROUNDS + 1) &lt;&lt; 2;
+        for (i = KC; (i &lt; k); i++)
+        {
+            int temp = W[(i - 1) &gt;&gt; 2][(i - 1) &amp; 3];
+            if ((i % KC) == 0)
+            {
+                temp = subWord(shift(temp, 8)) ^ rcon[(i / KC) - 1];
+            }
+            else if ((KC &gt; 6) &amp;&amp; ((i % KC) == 4))
+            {
+                temp = subWord(temp);
+            }
+
+            W[i &gt;&gt; 2][i &amp; 3] = W[(i - KC) &gt;&gt; 2][(i - KC) &amp; 3] ^ temp;
+        }
+
+        if (!forEncryption)
+        {
+            for (int j = 1; j &lt; ROUNDS; j++)
+            {
+                for (i = 0; i &lt; 4; i++)
+                {
+                    W[j][i] = inv_mcol(W[j][i]);
+                }
+            }
+        }
+
+        return W;
+    }
+
+    private int         ROUNDS;
+    private int[][]     WorkingKey = null;
+    private int         C0, C1, C2, C3;
+    private boolean     forEncryption;
+
+    private static final int BLOCK_SIZE = 16;
+
+    /**
+     * default constructor - 128 bit block size.
+     */
+    public AESFastEngine()
+    {
+    }
+
+    /**
+     * initialise an AES cipher.
+     *
+     * @param forEncryption whether or not we are for encryption.
+     * @param params the parameters required to set up the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean           forEncryption,
+        CipherParameters  params)
+    {
+        if (params instanceof KeyParameter)
+        {
+            WorkingKey = generateWorkingKey(((KeyParameter)params).getKey(), forEncryption);
+            this.forEncryption = forEncryption;
+            return;
+        }
+
+        throw new IllegalArgumentException(&quot;invalid parameter passed to AES init - &quot; + params.getClass().getName());
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;AES&quot;;
+    }
+
+    public int getBlockSize()
+    {
+        return BLOCK_SIZE;
+    }
+
+    public int processBlock(
+        byte[] in,
+        int inOff,
+        byte[] out,
+        int outOff)
+    {
+        if (WorkingKey == null)
+        {
+            throw new IllegalStateException(&quot;AES engine not initialised&quot;);
+        }
+
+        if ((inOff + (32 / 2)) &gt; in.length)
+        {
+            throw new DataLengthException(&quot;input buffer too short&quot;);
+        }
+
+        if ((outOff + (32 / 2)) &gt; out.length)
+        {
+            throw new DataLengthException(&quot;output buffer too short&quot;);
+        }
+
+        if (forEncryption)
+        {
+            unpackBlock(in, inOff);
+            encryptBlock(WorkingKey);
+            packBlock(out, outOff);
+        }
+        else
+        {
+            unpackBlock(in, inOff);
+            decryptBlock(WorkingKey);
+            packBlock(out, outOff);
+        }
+
+        return BLOCK_SIZE;
+    }
+
+    public void reset()
+    {
+    }
+
+    private void unpackBlock(
+        byte[]      bytes,
+        int         off)
+    {
+        int     index = off;
+
+        C0 = (bytes[index++] &amp; 0xff);
+        C0 |= (bytes[index++] &amp; 0xff) &lt;&lt; 8;
+        C0 |= (bytes[index++] &amp; 0xff) &lt;&lt; 16;
+        C0 |= bytes[index++] &lt;&lt; 24;
+
+        C1 = (bytes[index++] &amp; 0xff);
+        C1 |= (bytes[index++] &amp; 0xff) &lt;&lt; 8;
+        C1 |= (bytes[index++] &amp; 0xff) &lt;&lt; 16;
+        C1 |= bytes[index++] &lt;&lt; 24;
+
+        C2 = (bytes[index++] &amp; 0xff);
+        C2 |= (bytes[index++] &amp; 0xff) &lt;&lt; 8;
+        C2 |= (bytes[index++] &amp; 0xff) &lt;&lt; 16;
+        C2 |= bytes[index++] &lt;&lt; 24;
+
+        C3 = (bytes[index++] &amp; 0xff);
+        C3 |= (bytes[index++] &amp; 0xff) &lt;&lt; 8;
+        C3 |= (bytes[index++] &amp; 0xff) &lt;&lt; 16;
+        C3 |= bytes[index++] &lt;&lt; 24;
+    }
+
+    private void packBlock(
+        byte[]      bytes,
+        int         off)
+    {
+        int     index = off;
+
+        bytes[index++] = (byte)C0;
+        bytes[index++] = (byte)(C0 &gt;&gt; 8);
+        bytes[index++] = (byte)(C0 &gt;&gt; 16);
+        bytes[index++] = (byte)(C0 &gt;&gt; 24);
+
+        bytes[index++] = (byte)C1;
+        bytes[index++] = (byte)(C1 &gt;&gt; 8);
+        bytes[index++] = (byte)(C1 &gt;&gt; 16);
+        bytes[index++] = (byte)(C1 &gt;&gt; 24);
+
+        bytes[index++] = (byte)C2;
+        bytes[index++] = (byte)(C2 &gt;&gt; 8);
+        bytes[index++] = (byte)(C2 &gt;&gt; 16);
+        bytes[index++] = (byte)(C2 &gt;&gt; 24);
+
+        bytes[index++] = (byte)C3;
+        bytes[index++] = (byte)(C3 &gt;&gt; 8);
+        bytes[index++] = (byte)(C3 &gt;&gt; 16);
+        bytes[index++] = (byte)(C3 &gt;&gt; 24);
+    }
+
+    private void encryptBlock(int[][] KW)
+    {
+        int r, r0, r1, r2, r3;
+        
+        C0 ^= KW[0][0];
+        C1 ^= KW[0][1];
+        C2 ^= KW[0][2];
+        C3 ^= KW[0][3];
+
+        r = 1;
+        while (r &lt; ROUNDS - 1)
+        {
+            r0 = T0[C0&amp;255] ^ T1[(C1&gt;&gt;8)&amp;255] ^ T2[(C2&gt;&gt;16)&amp;255] ^ T3[(C3&gt;&gt;24)&amp;255] ^ KW[r][0];
+            r1 = T0[C1&amp;255] ^ T1[(C2&gt;&gt;8)&amp;255] ^ T2[(C3&gt;&gt;16)&amp;255] ^ T3[(C0&gt;&gt;24)&amp;255] ^ KW[r][1];
+            r2 = T0[C2&amp;255] ^ T1[(C3&gt;&gt;8)&amp;255] ^ T2[(C0&gt;&gt;16)&amp;255] ^ T3[(C1&gt;&gt;24)&amp;255] ^ KW[r][2];
+            r3 = T0[C3&amp;255] ^ T1[(C0&gt;&gt;8)&amp;255] ^ T2[(C1&gt;&gt;16)&amp;255] ^ T3[(C2&gt;&gt;24)&amp;255] ^ KW[r++][3];
+            C0 = T0[r0&amp;255] ^ T1[(r1&gt;&gt;8)&amp;255] ^ T2[(r2&gt;&gt;16)&amp;255] ^ T3[(r3&gt;&gt;24)&amp;255] ^ KW[r][0];
+            C1 = T0[r1&amp;255] ^ T1[(r2&gt;&gt;8)&amp;255] ^ T2[(r3&gt;&gt;16)&amp;255] ^ T3[(r0&gt;&gt;24)&amp;255] ^ KW[r][1];
+            C2 = T0[r2&amp;255] ^ T1[(r3&gt;&gt;8)&amp;255] ^ T2[(r0&gt;&gt;16)&amp;255] ^ T3[(r1&gt;&gt;24)&amp;255] ^ KW[r][2];
+            C3 = T0[r3&amp;255] ^ T1[(r0&gt;&gt;8)&amp;255] ^ T2[(r1&gt;&gt;16)&amp;255] ^ T3[(r2&gt;&gt;24)&amp;255] ^ KW[r++][3];
+        }
+
+        r0 = T0[C0&amp;255] ^ T1[(C1&gt;&gt;8)&amp;255] ^ T2[(C2&gt;&gt;16)&amp;255] ^ T3[(C3&gt;&gt;24)&amp;255] ^ KW[r][0];
+        r1 = T0[C1&amp;255] ^ T1[(C2&gt;&gt;8)&amp;255] ^ T2[(C3&gt;&gt;16)&amp;255] ^ T3[(C0&gt;&gt;24)&amp;255] ^ KW[r][1];
+        r2 = T0[C2&amp;255] ^ T1[(C3&gt;&gt;8)&amp;255] ^ T2[(C0&gt;&gt;16)&amp;255] ^ T3[(C1&gt;&gt;24)&amp;255] ^ KW[r][2];
+        r3 = T0[C3&amp;255] ^ T1[(C0&gt;&gt;8)&amp;255] ^ T2[(C1&gt;&gt;16)&amp;255] ^ T3[(C2&gt;&gt;24)&amp;255] ^ KW[r++][3];
+        
+        // the final round's table is a simple function of S so we don't use a whole other four tables for it
+
+        C0 = (S[r0&amp;255]&amp;255) ^ ((S[(r1&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((S[(r2&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (S[(r3&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[r][0];
+        C1 = (S[r1&amp;255]&amp;255) ^ ((S[(r2&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((S[(r3&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (S[(r0&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[r][1];
+        C2 = (S[r2&amp;255]&amp;255) ^ ((S[(r3&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((S[(r0&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (S[(r1&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[r][2];
+        C3 = (S[r3&amp;255]&amp;255) ^ ((S[(r0&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((S[(r1&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (S[(r2&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[r][3];
+
+    }
+
+    private void decryptBlock(int[][] KW)
+    {
+        int r0, r1, r2, r3;
+
+        C0 ^= KW[ROUNDS][0];
+        C1 ^= KW[ROUNDS][1];
+        C2 ^= KW[ROUNDS][2];
+        C3 ^= KW[ROUNDS][3];
+
+        int r = ROUNDS-1; 
+        
+        while (r&gt;1) 
+        {
+            r0 = Tinv0[C0&amp;255] ^ Tinv1[(C3&gt;&gt;8)&amp;255] ^ Tinv2[(C2&gt;&gt;16)&amp;255] ^ Tinv3[(C1&gt;&gt;24)&amp;255] ^ KW[r][0];
+            r1 = Tinv0[C1&amp;255] ^ Tinv1[(C0&gt;&gt;8)&amp;255] ^ Tinv2[(C3&gt;&gt;16)&amp;255] ^ Tinv3[(C2&gt;&gt;24)&amp;255] ^ KW[r][1];
+            r2 = Tinv0[C2&amp;255] ^ Tinv1[(C1&gt;&gt;8)&amp;255] ^ Tinv2[(C0&gt;&gt;16)&amp;255] ^ Tinv3[(C3&gt;&gt;24)&amp;255] ^ KW[r][2];
+            r3 = Tinv0[C3&amp;255] ^ Tinv1[(C2&gt;&gt;8)&amp;255] ^ Tinv2[(C1&gt;&gt;16)&amp;255] ^ Tinv3[(C0&gt;&gt;24)&amp;255] ^ KW[r--][3];
+            C0 = Tinv0[r0&amp;255] ^ Tinv1[(r3&gt;&gt;8)&amp;255] ^ Tinv2[(r2&gt;&gt;16)&amp;255] ^ Tinv3[(r1&gt;&gt;24)&amp;255] ^ KW[r][0];
+            C1 = Tinv0[r1&amp;255] ^ Tinv1[(r0&gt;&gt;8)&amp;255] ^ Tinv2[(r3&gt;&gt;16)&amp;255] ^ Tinv3[(r2&gt;&gt;24)&amp;255] ^ KW[r][1];
+            C2 = Tinv0[r2&amp;255] ^ Tinv1[(r1&gt;&gt;8)&amp;255] ^ Tinv2[(r0&gt;&gt;16)&amp;255] ^ Tinv3[(r3&gt;&gt;24)&amp;255] ^ KW[r][2];
+            C3 = Tinv0[r3&amp;255] ^ Tinv1[(r2&gt;&gt;8)&amp;255] ^ Tinv2[(r1&gt;&gt;16)&amp;255] ^ Tinv3[(r0&gt;&gt;24)&amp;255] ^ KW[r--][3];
+        }
+
+        r0 = Tinv0[C0&amp;255] ^ Tinv1[(C3&gt;&gt;8)&amp;255] ^ Tinv2[(C2&gt;&gt;16)&amp;255] ^ Tinv3[(C1&gt;&gt;24)&amp;255] ^ KW[r][0];
+        r1 = Tinv0[C1&amp;255] ^ Tinv1[(C0&gt;&gt;8)&amp;255] ^ Tinv2[(C3&gt;&gt;16)&amp;255] ^ Tinv3[(C2&gt;&gt;24)&amp;255] ^ KW[r][1];
+        r2 = Tinv0[C2&amp;255] ^ Tinv1[(C1&gt;&gt;8)&amp;255] ^ Tinv2[(C0&gt;&gt;16)&amp;255] ^ Tinv3[(C3&gt;&gt;24)&amp;255] ^ KW[r][2];
+        r3 = Tinv0[C3&amp;255] ^ Tinv1[(C2&gt;&gt;8)&amp;255] ^ Tinv2[(C1&gt;&gt;16)&amp;255] ^ Tinv3[(C0&gt;&gt;24)&amp;255] ^ KW[r][3];
+        
+        // the final round's table is a simple function of Si so we don't use a whole other four tables for it
+
+        C0 = (Si[r0&amp;255]&amp;255) ^ ((Si[(r3&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((Si[(r2&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (Si[(r1&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[0][0];
+        C1 = (Si[r1&amp;255]&amp;255) ^ ((Si[(r0&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((Si[(r3&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (Si[(r2&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[0][1];
+        C2 = (Si[r2&amp;255]&amp;255) ^ ((Si[(r1&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((Si[(r0&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (Si[(r3&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[0][2];
+        C3 = (Si[r3&amp;255]&amp;255) ^ ((Si[(r2&gt;&gt;8)&amp;255]&amp;255)&lt;&lt;8) ^ ((Si[(r1&gt;&gt;16)&amp;255]&amp;255)&lt;&lt;16) ^ (Si[(r0&gt;&gt;24)&amp;255]&lt;&lt;24) ^ KW[0][3];
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/DESEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/DESEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/DESEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/DESEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,494 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * a class that provides a basic DES engine.
+ */
+public class DESEngine
+    implements BlockCipher
+{
+    protected static final int  BLOCK_SIZE = 8;
+
+    private int[]               workingKey = null;
+
+    /**
+     * standard constructor.
+     */
+    public DESEngine()
+    {
+    }
+
+    /**
+     * initialise a DES cipher.
+     *
+     * @param encrypting whether or not we are for encryption.
+     * @param params the parameters required to set up the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean           encrypting,
+        CipherParameters  params)
+    {
+        if (params instanceof KeyParameter)
+        {
+            if (((KeyParameter)params).getKey().length &gt; 8)
+            {
+                throw new IllegalArgumentException(&quot;DES key too long - should be 8 bytes&quot;);
+            }
+            
+            workingKey = generateWorkingKey(encrypting,
+                                  ((KeyParameter)params).getKey());
+
+            return;
+        }
+
+        throw new IllegalArgumentException(&quot;invalid parameter passed to DES init - &quot; + params.getClass().getName());
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;DES&quot;;
+    }
+
+    public int getBlockSize()
+    {
+        return BLOCK_SIZE;
+    }
+
+    public int processBlock(
+        byte[] in,
+        int inOff,
+        byte[] out,
+        int outOff)
+    {
+        if (workingKey == null)
+        {
+            throw new IllegalStateException(&quot;DES engine not initialised&quot;);
+        }
+
+        if ((inOff + BLOCK_SIZE) &gt; in.length)
+        {
+            throw new DataLengthException(&quot;input buffer too short&quot;);
+        }
+
+        if ((outOff + BLOCK_SIZE) &gt; out.length)
+        {
+            throw new DataLengthException(&quot;output buffer too short&quot;);
+        }
+
+        desFunc(workingKey, in, inOff, out, outOff);
+
+        return BLOCK_SIZE;
+    }
+
+    public void reset()
+    {
+    }
+
+    /**
+     * what follows is mainly taken from &quot;Applied Cryptography&quot;, by
+     * Bruce Schneier, however it also bears great resemblance to Richard
+     * Outerbridge's D3DES...
+     */
+
+//    private static final short[]    Df_Key =
+//        {
+//            0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
+//            0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,
+//            0x89,0xab,0xcd,0xef,0x01,0x23,0x45,0x67
+//        };
+
+    private static final short[]    bytebit =
+        {
+            0200, 0100, 040, 020, 010, 04, 02, 01
+        };
+
+    private static final int[]    bigbyte =
+        {
+            0x800000, 0x400000, 0x200000, 0x100000,
+            0x80000,  0x40000,  0x20000,  0x10000,
+            0x8000,      0x4000,   0x2000,   0x1000,
+            0x800,    0x400,    0x200,    0x100,
+            0x80,      0x40,        0x20,     0x10,
+            0x8,      0x4,      0x2,      0x1
+        };
+
+    /*
+     * Use the key schedule specified in the Standard (ANSI X3.92-1981).
+     */
+
+    private static final byte[]    pc1 =
+        {
+            56, 48, 40, 32, 24, 16,  8,   0, 57, 49, 41, 33, 25, 17,
+             9,  1, 58, 50, 42, 34, 26,  18, 10,  2, 59, 51, 43, 35,
+            62, 54, 46, 38, 30, 22, 14,   6, 61, 53, 45, 37, 29, 21,
+            13,  5, 60, 52, 44, 36, 28,  20, 12,  4, 27, 19, 11,  3
+        };
+
+    private static final byte[] totrot =
+        {
+            1, 2, 4, 6, 8, 10, 12, 14,
+            15, 17, 19, 21, 23, 25, 27, 28
+        };
+
+    private static final byte[] pc2 =
+        {
+            13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
+            22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
+            40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
+            43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31
+        };
+
+    private static final int[] SP1 = {
+        0x01010400, 0x00000000, 0x00010000, 0x01010404,
+        0x01010004, 0x00010404, 0x00000004, 0x00010000,
+        0x00000400, 0x01010400, 0x01010404, 0x00000400,
+        0x01000404, 0x01010004, 0x01000000, 0x00000004,
+        0x00000404, 0x01000400, 0x01000400, 0x00010400,
+        0x00010400, 0x01010000, 0x01010000, 0x01000404,
+        0x00010004, 0x01000004, 0x01000004, 0x00010004,
+        0x00000000, 0x00000404, 0x00010404, 0x01000000,
+        0x00010000, 0x01010404, 0x00000004, 0x01010000,
+        0x01010400, 0x01000000, 0x01000000, 0x00000400,
+        0x01010004, 0x00010000, 0x00010400, 0x01000004,
+        0x00000400, 0x00000004, 0x01000404, 0x00010404,
+        0x01010404, 0x00010004, 0x01010000, 0x01000404,
+        0x01000004, 0x00000404, 0x00010404, 0x01010400,
+        0x00000404, 0x01000400, 0x01000400, 0x00000000,
+        0x00010004, 0x00010400, 0x00000000, 0x01010004
+    };
+
+    private static final int[] SP2 = {
+        0x80108020, 0x80008000, 0x00008000, 0x00108020,
+        0x00100000, 0x00000020, 0x80100020, 0x80008020,
+        0x80000020, 0x80108020, 0x80108000, 0x80000000,
+        0x80008000, 0x00100000, 0x00000020, 0x80100020,
+        0x00108000, 0x00100020, 0x80008020, 0x00000000,
+        0x80000000, 0x00008000, 0x00108020, 0x80100000,
+        0x00100020, 0x80000020, 0x00000000, 0x00108000,
+        0x00008020, 0x80108000, 0x80100000, 0x00008020,
+        0x00000000, 0x00108020, 0x80100020, 0x00100000,
+        0x80008020, 0x80100000, 0x80108000, 0x00008000,
+        0x80100000, 0x80008000, 0x00000020, 0x80108020,
+        0x00108020, 0x00000020, 0x00008000, 0x80000000,
+        0x00008020, 0x80108000, 0x00100000, 0x80000020,
+        0x00100020, 0x80008020, 0x80000020, 0x00100020,
+        0x00108000, 0x00000000, 0x80008000, 0x00008020,
+        0x80000000, 0x80100020, 0x80108020, 0x00108000
+    };
+
+    private static final int[] SP3 = {
+        0x00000208, 0x08020200, 0x00000000, 0x08020008,
+        0x08000200, 0x00000000, 0x00020208, 0x08000200,
+        0x00020008, 0x08000008, 0x08000008, 0x00020000,
+        0x08020208, 0x00020008, 0x08020000, 0x00000208,
+        0x08000000, 0x00000008, 0x08020200, 0x00000200,
+        0x00020200, 0x08020000, 0x08020008, 0x00020208,
+        0x08000208, 0x00020200, 0x00020000, 0x08000208,
+        0x00000008, 0x08020208, 0x00000200, 0x08000000,
+        0x08020200, 0x08000000, 0x00020008, 0x00000208,
+        0x00020000, 0x08020200, 0x08000200, 0x00000000,
+        0x00000200, 0x00020008, 0x08020208, 0x08000200,
+        0x08000008, 0x00000200, 0x00000000, 0x08020008,
+        0x08000208, 0x00020000, 0x08000000, 0x08020208,
+        0x00000008, 0x00020208, 0x00020200, 0x08000008,
+        0x08020000, 0x08000208, 0x00000208, 0x08020000,
+        0x00020208, 0x00000008, 0x08020008, 0x00020200
+    };
+
+    private static final int[] SP4 = {
+        0x00802001, 0x00002081, 0x00002081, 0x00000080,
+        0x00802080, 0x00800081, 0x00800001, 0x00002001,
+        0x00000000, 0x00802000, 0x00802000, 0x00802081,
+        0x00000081, 0x00000000, 0x00800080, 0x00800001,
+        0x00000001, 0x00002000, 0x00800000, 0x00802001,
+        0x00000080, 0x00800000, 0x00002001, 0x00002080,
+        0x00800081, 0x00000001, 0x00002080, 0x00800080,
+        0x00002000, 0x00802080, 0x00802081, 0x00000081,
+        0x00800080, 0x00800001, 0x00802000, 0x00802081,
+        0x00000081, 0x00000000, 0x00000000, 0x00802000,
+        0x00002080, 0x00800080, 0x00800081, 0x00000001,
+        0x00802001, 0x00002081, 0x00002081, 0x00000080,
+        0x00802081, 0x00000081, 0x00000001, 0x00002000,
+        0x00800001, 0x00002001, 0x00802080, 0x00800081,
+        0x00002001, 0x00002080, 0x00800000, 0x00802001,
+        0x00000080, 0x00800000, 0x00002000, 0x00802080
+    };
+
+    private static final int[] SP5 = {
+        0x00000100, 0x02080100, 0x02080000, 0x42000100,
+        0x00080000, 0x00000100, 0x40000000, 0x02080000,
+        0x40080100, 0x00080000, 0x02000100, 0x40080100,
+        0x42000100, 0x42080000, 0x00080100, 0x40000000,
+        0x02000000, 0x40080000, 0x40080000, 0x00000000,
+        0x40000100, 0x42080100, 0x42080100, 0x02000100,
+        0x42080000, 0x40000100, 0x00000000, 0x42000000,
+        0x02080100, 0x02000000, 0x42000000, 0x00080100,
+        0x00080000, 0x42000100, 0x00000100, 0x02000000,
+        0x40000000, 0x02080000, 0x42000100, 0x40080100,
+        0x02000100, 0x40000000, 0x42080000, 0x02080100,
+        0x40080100, 0x00000100, 0x02000000, 0x42080000,
+        0x42080100, 0x00080100, 0x42000000, 0x42080100,
+        0x02080000, 0x00000000, 0x40080000, 0x42000000,
+        0x00080100, 0x02000100, 0x40000100, 0x00080000,
+        0x00000000, 0x40080000, 0x02080100, 0x40000100
+    };
+
+    private static final int[] SP6 = {
+        0x20000010, 0x20400000, 0x00004000, 0x20404010,
+        0x20400000, 0x00000010, 0x20404010, 0x00400000,
+        0x20004000, 0x00404010, 0x00400000, 0x20000010,
+        0x00400010, 0x20004000, 0x20000000, 0x00004010,
+        0x00000000, 0x00400010, 0x20004010, 0x00004000,
+        0x00404000, 0x20004010, 0x00000010, 0x20400010,
+        0x20400010, 0x00000000, 0x00404010, 0x20404000,
+        0x00004010, 0x00404000, 0x20404000, 0x20000000,
+        0x20004000, 0x00000010, 0x20400010, 0x00404000,
+        0x20404010, 0x00400000, 0x00004010, 0x20000010,
+        0x00400000, 0x20004000, 0x20000000, 0x00004010,
+        0x20000010, 0x20404010, 0x00404000, 0x20400000,
+        0x00404010, 0x20404000, 0x00000000, 0x20400010,
+        0x00000010, 0x00004000, 0x20400000, 0x00404010,
+        0x00004000, 0x00400010, 0x20004010, 0x00000000,
+        0x20404000, 0x20000000, 0x00400010, 0x20004010
+    };
+
+    private static final int[] SP7 = {
+        0x00200000, 0x04200002, 0x04000802, 0x00000000,
+        0x00000800, 0x04000802, 0x00200802, 0x04200800,
+        0x04200802, 0x00200000, 0x00000000, 0x04000002,
+        0x00000002, 0x04000000, 0x04200002, 0x00000802,
+        0x04000800, 0x00200802, 0x00200002, 0x04000800,
+        0x04000002, 0x04200000, 0x04200800, 0x00200002,
+        0x04200000, 0x00000800, 0x00000802, 0x04200802,
+        0x00200800, 0x00000002, 0x04000000, 0x00200800,
+        0x04000000, 0x00200800, 0x00200000, 0x04000802,
+        0x04000802, 0x04200002, 0x04200002, 0x00000002,
+        0x00200002, 0x04000000, 0x04000800, 0x00200000,
+        0x04200800, 0x00000802, 0x00200802, 0x04200800,
+        0x00000802, 0x04000002, 0x04200802, 0x04200000,
+        0x00200800, 0x00000000, 0x00000002, 0x04200802,
+        0x00000000, 0x00200802, 0x04200000, 0x00000800,
+        0x04000002, 0x04000800, 0x00000800, 0x00200002
+    };
+
+    private static final int[] SP8 = {
+        0x10001040, 0x00001000, 0x00040000, 0x10041040,
+        0x10000000, 0x10001040, 0x00000040, 0x10000000,
+        0x00040040, 0x10040000, 0x10041040, 0x00041000,
+        0x10041000, 0x00041040, 0x00001000, 0x00000040,
+        0x10040000, 0x10000040, 0x10001000, 0x00001040,
+        0x00041000, 0x00040040, 0x10040040, 0x10041000,
+        0x00001040, 0x00000000, 0x00000000, 0x10040040,
+        0x10000040, 0x10001000, 0x00041040, 0x00040000,
+        0x00041040, 0x00040000, 0x10041000, 0x00001000,
+        0x00000040, 0x10040040, 0x00001000, 0x00041040,
+        0x10001000, 0x00000040, 0x10000040, 0x10040000,
+        0x10040040, 0x10000000, 0x00040000, 0x10001040,
+        0x00000000, 0x10041040, 0x00040040, 0x10000040,
+        0x10040000, 0x10001000, 0x10001040, 0x00000000,
+        0x10041040, 0x00041000, 0x00041000, 0x00001040,
+        0x00001040, 0x00040040, 0x10000000, 0x10041000
+    };
+
+    /**
+     * generate an integer based working key based on our secret key
+     * and what we processing we are planning to do.
+     *
+     * Acknowledgements for this routine go to James Gillogly &amp; Phil Karn.
+     *         (whoever, and wherever they are!).
+     */
+    protected int[] generateWorkingKey(
+        boolean encrypting,
+        byte[]  key)
+    {
+        int[]       newKey = new int[32];
+        boolean[]   pc1m = new boolean[56],
+                    pcr = new boolean[56];
+
+        for (int j = 0; j &lt; 56; j++)
+        {
+            int    l = pc1[j];
+
+            pc1m[j] = ((key[l &gt;&gt;&gt; 3] &amp; bytebit[l &amp; 07]) != 0);
+        }
+
+        for (int i = 0; i &lt; 16; i++)
+        {
+            int    l, m, n;
+
+            if (encrypting)
+            {
+                m = i &lt;&lt; 1;
+            }
+            else
+            {
+                m = (15 - i) &lt;&lt; 1;
+            }
+
+            n = m + 1;
+            newKey[m] = newKey[n] = 0;
+
+            for (int j = 0; j &lt; 28; j++)
+            {
+                l = j + totrot[i];
+                if (l &lt; 28)
+                {
+                    pcr[j] = pc1m[l];
+                }
+                else
+                {
+                    pcr[j] = pc1m[l - 28];
+                }
+            }
+
+            for (int j = 28; j &lt; 56; j++)
+            {
+                l = j + totrot[i];
+                if (l &lt; 56)
+                {
+                    pcr[j] = pc1m[l];
+                }
+                else
+                {
+                    pcr[j] = pc1m[l - 28];
+                }
+            }
+
+            for (int j = 0; j &lt; 24; j++)
+            {
+                if (pcr[pc2[j]])
+                {
+                    newKey[m] |= bigbyte[j];
+                }
+
+                if (pcr[pc2[j + 24]])
+                {
+                    newKey[n] |= bigbyte[j];
+                }
+            }
+        }
+
+        //
+        // store the processed key
+        //
+        for (int i = 0; i != 32; i += 2)
+        {
+            int    i1, i2;
+
+            i1 = newKey[i];
+            i2 = newKey[i + 1];
+
+            newKey[i] = ((i1 &amp; 0x00fc0000) &lt;&lt; 6) | ((i1 &amp; 0x00000fc0) &lt;&lt; 10)
+                                   | ((i2 &amp; 0x00fc0000) &gt;&gt;&gt; 10) | ((i2 &amp; 0x00000fc0) &gt;&gt;&gt; 6);
+
+            newKey[i + 1] = ((i1 &amp; 0x0003f000) &lt;&lt; 12) | ((i1 &amp; 0x0000003f) &lt;&lt; 16)
+                                   | ((i2 &amp; 0x0003f000) &gt;&gt;&gt; 4) | (i2 &amp; 0x0000003f);
+        }
+
+        return newKey;
+    }
+
+    /**
+     * the DES engine.
+     */
+    protected void desFunc(
+        int[]   wKey,
+        byte[]  in,
+        int     inOff,
+        byte[]  out,
+        int     outOff)
+    {
+        int     work, right, left;
+
+        left     = (in[inOff + 0] &amp; 0xff) &lt;&lt; 24;
+        left    |= (in[inOff + 1] &amp; 0xff) &lt;&lt; 16;
+        left    |= (in[inOff + 2] &amp; 0xff) &lt;&lt; 8;
+        left    |= (in[inOff + 3] &amp; 0xff);
+
+        right     = (in[inOff + 4] &amp; 0xff) &lt;&lt; 24;
+        right    |= (in[inOff + 5] &amp; 0xff) &lt;&lt; 16;
+        right    |= (in[inOff + 6] &amp; 0xff) &lt;&lt; 8;
+        right    |= (in[inOff + 7] &amp; 0xff);
+
+        work = ((left &gt;&gt;&gt; 4) ^ right) &amp; 0x0f0f0f0f;
+        right ^= work;
+        left ^= (work &lt;&lt; 4);
+        work = ((left &gt;&gt;&gt; 16) ^ right) &amp; 0x0000ffff;
+        right ^= work;
+        left ^= (work &lt;&lt; 16);
+        work = ((right &gt;&gt;&gt; 2) ^ left) &amp; 0x33333333;
+        left ^= work;
+        right ^= (work &lt;&lt; 2);
+        work = ((right &gt;&gt;&gt; 8) ^ left) &amp; 0x00ff00ff;
+        left ^= work;
+        right ^= (work &lt;&lt; 8);
+        right = ((right &lt;&lt; 1) | ((right &gt;&gt;&gt; 31) &amp; 1)) &amp; 0xffffffff;
+        work = (left ^ right) &amp; 0xaaaaaaaa;
+        left ^= work;
+        right ^= work;
+        left = ((left &lt;&lt; 1) | ((left &gt;&gt;&gt; 31) &amp; 1)) &amp; 0xffffffff;
+
+        for (int round = 0; round &lt; 8; round++)
+        {
+            int     fval;
+
+            work  = (right &lt;&lt; 28) | (right &gt;&gt;&gt; 4);
+            work ^= wKey[round * 4 + 0];
+            fval  = SP7[ work      &amp; 0x3f];
+            fval |= SP5[(work &gt;&gt;&gt;  8) &amp; 0x3f];
+            fval |= SP3[(work &gt;&gt;&gt; 16) &amp; 0x3f];
+            fval |= SP1[(work &gt;&gt;&gt; 24) &amp; 0x3f];
+            work  = right ^ wKey[round * 4 + 1];
+            fval |= SP8[ work      &amp; 0x3f];
+            fval |= SP6[(work &gt;&gt;&gt;  8) &amp; 0x3f];
+            fval |= SP4[(work &gt;&gt;&gt; 16) &amp; 0x3f];
+            fval |= SP2[(work &gt;&gt;&gt; 24) &amp; 0x3f];
+            left ^= fval;
+            work  = (left &lt;&lt; 28) | (left &gt;&gt;&gt; 4);
+            work ^= wKey[round * 4 + 2];
+            fval  = SP7[ work      &amp; 0x3f];
+            fval |= SP5[(work &gt;&gt;&gt;  8) &amp; 0x3f];
+            fval |= SP3[(work &gt;&gt;&gt; 16) &amp; 0x3f];
+            fval |= SP1[(work &gt;&gt;&gt; 24) &amp; 0x3f];
+            work  = left ^ wKey[round * 4 + 3];
+            fval |= SP8[ work      &amp; 0x3f];
+            fval |= SP6[(work &gt;&gt;&gt;  8) &amp; 0x3f];
+            fval |= SP4[(work &gt;&gt;&gt; 16) &amp; 0x3f];
+            fval |= SP2[(work &gt;&gt;&gt; 24) &amp; 0x3f];
+            right ^= fval;
+        }
+
+        right = (right &lt;&lt; 31) | (right &gt;&gt;&gt; 1);
+        work = (left ^ right) &amp; 0xaaaaaaaa;
+        left ^= work;
+        right ^= work;
+        left = (left &lt;&lt; 31) | (left &gt;&gt;&gt; 1);
+        work = ((left &gt;&gt;&gt; 8) ^ right) &amp; 0x00ff00ff;
+        right ^= work;
+        left ^= (work &lt;&lt; 8);
+        work = ((left &gt;&gt;&gt; 2) ^ right) &amp; 0x33333333;
+        right ^= work;
+        left ^= (work &lt;&lt; 2);
+        work = ((right &gt;&gt;&gt; 16) ^ left) &amp; 0x0000ffff;
+        left ^= work;
+        right ^= (work &lt;&lt; 16);
+        work = ((right &gt;&gt;&gt; 4) ^ left) &amp; 0x0f0f0f0f;
+        left ^= work;
+        right ^= (work &lt;&lt; 4);
+
+        out[outOff + 0] = (byte)((right &gt;&gt;&gt; 24) &amp; 0xff);
+        out[outOff + 1] = (byte)((right &gt;&gt;&gt; 16) &amp; 0xff);
+        out[outOff + 2] = (byte)((right &gt;&gt;&gt;  8) &amp; 0xff);
+        out[outOff + 3] = (byte)(right         &amp; 0xff);
+        out[outOff + 4] = (byte)((left &gt;&gt;&gt; 24) &amp; 0xff);
+        out[outOff + 5] = (byte)((left &gt;&gt;&gt; 16) &amp; 0xff);
+        out[outOff + 6] = (byte)((left &gt;&gt;&gt;  8) &amp; 0xff);
+        out[outOff + 7] = (byte)(left         &amp; 0xff);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/DESedeEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * a class that provides a basic DESede (or Triple DES) engine.
+ */
+public class DESedeEngine
+    extends DESEngine
+{
+    protected static final int  BLOCK_SIZE = 8;
+
+    private int[]               workingKey1 = null;
+    private int[]               workingKey2 = null;
+    private int[]               workingKey3 = null;
+
+    private boolean             forEncryption;
+
+    /**
+     * standard constructor.
+     */
+    public DESedeEngine()
+    {
+    }
+
+    /**
+     * initialise a DESede cipher.
+     *
+     * @param encrypting whether or not we are for encryption.
+     * @param params the parameters required to set up the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean           encrypting,
+        CipherParameters  params)
+    {
+        if (!(params instanceof KeyParameter))
+        {
+            throw new IllegalArgumentException(&quot;invalid parameter passed to DESede init - &quot; + params.getClass().getName());
+        }
+
+        byte[] keyMaster = ((KeyParameter)params).getKey();
+
+        if (keyMaster.length &gt; 24)
+        {
+            throw new IllegalArgumentException(&quot;key size greater than 24 bytes&quot;);
+        }
+
+        this.forEncryption = encrypting;
+
+        byte[] key1 = new byte[8];
+        System.arraycopy(keyMaster, 0, key1, 0, key1.length);
+        workingKey1 = generateWorkingKey(encrypting, key1);
+
+        byte[] key2 = new byte[8];
+        System.arraycopy(keyMaster, 8, key2, 0, key2.length);
+        workingKey2 = generateWorkingKey(!encrypting, key2);
+
+        if (keyMaster.length == 24)
+        {
+            byte[] key3 = new byte[8];
+            System.arraycopy(keyMaster, 16, key3, 0, key3.length);
+            workingKey3 = generateWorkingKey(encrypting, key3);
+        }
+        else    // 16 byte key
+        {
+            workingKey3 = workingKey1;
+        }
+    }
+
+    public String getAlgorithmName()
+    {
+        return &quot;DESede&quot;;
+    }
+
+    public int getBlockSize()
+    {
+        return BLOCK_SIZE;
+    }
+
+    public int processBlock(
+        byte[] in,
+        int inOff,
+        byte[] out,
+        int outOff)
+    {
+        if (workingKey1 == null)
+        {
+            throw new IllegalStateException(&quot;DESede engine not initialised&quot;);
+        }
+
+        if ((inOff + BLOCK_SIZE) &gt; in.length)
+        {
+            throw new DataLengthException(&quot;input buffer too short&quot;);
+        }
+
+        if ((outOff + BLOCK_SIZE) &gt; out.length)
+        {
+            throw new DataLengthException(&quot;output buffer too short&quot;);
+        }
+
+        byte[] temp = new byte[BLOCK_SIZE];
+
+        if (forEncryption)
+        {
+            desFunc(workingKey1, in, inOff, temp, 0);
+            desFunc(workingKey2, temp, 0, temp, 0);
+            desFunc(workingKey3, temp, 0, out, outOff);
+        }
+        else
+        {
+            desFunc(workingKey3, in, inOff, temp, 0);
+            desFunc(workingKey2, temp, 0, temp, 0);
+            desFunc(workingKey1, temp, 0, out, outOff);
+        }
+
+        return BLOCK_SIZE;
+    }
+
+    public void reset()
+    {
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/RSABlindedEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,126 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.AsymmetricBlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;
+import org.bouncycastle.util.BigIntegers;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+/**
+ * this does your basic RSA algorithm with blinding
+ */
+public class RSABlindedEngine
+    implements AsymmetricBlockCipher
+{
+    private static BigInteger ONE = BigInteger.valueOf(1);
+
+    private RSACoreEngine    core = new RSACoreEngine();
+    private RSAKeyParameters key;
+    private SecureRandom     random;
+
+    /**
+     * initialise the RSA engine.
+     *
+     * @param forEncryption true if we are encrypting, false otherwise.
+     * @param param the necessary RSA key parameters.
+     */
+    public void init(
+        boolean             forEncryption,
+        CipherParameters    param)
+    {
+        core.init(forEncryption, param);
+
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+            key = (RSAKeyParameters)rParam.getParameters();
+            random = rParam.getRandom();
+        }
+        else
+        {
+            key = (RSAKeyParameters)param;
+            random = new SecureRandom();
+        }
+    }
+
+    /**
+     * Return the maximum size for an input block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * encryption, and the same length as the key size on decryption.
+     *
+     * @return maximum size for an input block.
+     */
+    public int getInputBlockSize()
+    {
+        return core.getInputBlockSize();
+    }
+
+    /**
+     * Return the maximum size for an output block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * decryption, and the same length as the key size on encryption.
+     *
+     * @return maximum size for an output block.
+     */
+    public int getOutputBlockSize()
+    {
+        return core.getOutputBlockSize();
+    }
+
+    /**
+     * Process a single block using the basic RSA algorithm.
+     *
+     * @param in the input array.
+     * @param inOff the offset into the input buffer where the data starts.
+     * @param inLen the length of the data to be processed.
+     * @return the result of the RSA process.
+     * @exception DataLengthException the input block is too large.
+     */
+    public byte[] processBlock(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+    {
+        if (key == null)
+        {
+            throw new IllegalStateException(&quot;RSA engine not initialised&quot;);
+        }
+
+        BigInteger input = core.convertInput(in, inOff, inLen);
+
+        BigInteger result;
+        if (key instanceof RSAPrivateCrtKeyParameters)
+        {
+            RSAPrivateCrtKeyParameters k = (RSAPrivateCrtKeyParameters)key;
+
+            BigInteger e = k.getPublicExponent();
+            if (e != null)   // can't do blinding without a public exponent
+            {
+                BigInteger m = k.getModulus();
+                BigInteger r = BigIntegers.createRandomInRange(ONE, m.subtract(ONE), random);
+
+                BigInteger blindedInput = r.modPow(e, m).multiply(input).mod(m);
+                BigInteger blindedResult = core.processBlock(blindedInput);
+
+                BigInteger rInv = r.modInverse(m);
+                result = blindedResult.multiply(rInv).mod(m);
+            }
+            else
+            {
+                result = core.processBlock(input);
+            }
+        }
+        else
+        {
+            result = core.processBlock(input);
+        }
+
+        return core.convertOutput(result);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/RSACoreEngine.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,203 @@
+package org.bouncycastle.crypto.engines;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters;
+
+import ewe.math.BigInteger;
+
+/**
+ * this does your basic RSA algorithm.
+ */
+class RSACoreEngine
+{
+    private RSAKeyParameters key;
+    private boolean          forEncryption;
+
+    /**
+     * initialise the RSA engine.
+     *
+     * @param forEncryption true if we are encrypting, false otherwise.
+     * @param param the necessary RSA key parameters.
+     */
+    public void init(
+        boolean          forEncryption,
+        CipherParameters param)
+    {
+        if (param instanceof ParametersWithRandom)
+        {
+            ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+            key = (RSAKeyParameters)rParam.getParameters();
+        }
+        else
+        {
+            key = (RSAKeyParameters)param;
+        }
+
+        this.forEncryption = forEncryption;
+    }
+
+    /**
+     * Return the maximum size for an input block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * encryption, and the same length as the key size on decryption.
+     *
+     * @return maximum size for an input block.
+     */
+    public int getInputBlockSize()
+    {
+        int     bitSize = key.getModulus().bitLength();
+
+        if (forEncryption)
+        {
+            return (bitSize + 7) / 8 - 1;
+        }
+        else
+        {
+            return (bitSize + 7) / 8;
+        }
+    }
+
+    /**
+     * Return the maximum size for an output block to this engine.
+     * For RSA this is always one byte less than the key size on
+     * decryption, and the same length as the key size on encryption.
+     *
+     * @return maximum size for an output block.
+     */
+    public int getOutputBlockSize()
+    {
+        int     bitSize = key.getModulus().bitLength();
+
+        if (forEncryption)
+        {
+            return (bitSize + 7) / 8;
+        }
+        else
+        {
+            return (bitSize + 7) / 8 - 1;
+        }
+    }
+
+    public BigInteger convertInput(
+        byte[]  in,
+        int     inOff,
+        int     inLen)
+    {
+        if (inLen &gt; (getInputBlockSize() + 1))
+        {
+            throw new DataLengthException(&quot;input too large for RSA cipher.&quot;);
+        }
+        else if (inLen == (getInputBlockSize() + 1) &amp;&amp; !forEncryption)
+        {
+            throw new DataLengthException(&quot;input too large for RSA cipher.&quot;);
+        }
+
+        byte[]  block;
+
+        if (inOff != 0 || inLen != in.length)
+        {
+            block = new byte[inLen];
+
+            System.arraycopy(in, inOff, block, 0, inLen);
+        }
+        else
+        {
+            block = in;
+        }
+
+        BigInteger res = new BigInteger(1, block);
+        if (res.compareTo(key.getModulus()) &gt;= 0)
+        {
+            throw new DataLengthException(&quot;input too large for RSA cipher.&quot;);
+        }
+
+        return res;
+    }
+
+    public byte[] convertOutput(
+        BigInteger result)
+    {
+        byte[]      output = result.toByteArray();
+
+        if (forEncryption)
+        {
+            if (output[0] == 0 &amp;&amp; output.length &gt; getOutputBlockSize())        // have ended up with an extra zero byte, copy down.
+            {
+                byte[]  tmp = new byte[output.length - 1];
+
+                System.arraycopy(output, 1, tmp, 0, tmp.length);
+
+                return tmp;
+            }
+
+            if (output.length &lt; getOutputBlockSize())     // have ended up with less bytes than normal, lengthen
+            {
+                byte[]  tmp = new byte[getOutputBlockSize()];
+
+                System.arraycopy(output, 0, tmp, tmp.length - output.length, output.length);
+
+                return tmp;
+            }
+        }
+        else
+        {
+            if (output[0] == 0)        // have ended up with an extra zero byte, copy down.
+            {
+                byte[]  tmp = new byte[output.length - 1];
+
+                System.arraycopy(output, 1, tmp, 0, tmp.length);
+
+                return tmp;
+            }
+        }
+
+        return output;
+    }
+
+    public BigInteger processBlock(BigInteger input)
+    {
+        if (key instanceof RSAPrivateCrtKeyParameters)
+        {
+            //
+            // we have the extra factors, use the Chinese Remainder Theorem - the author
+            // wishes to express his thanks to Dirk Bonekaemper at rtsffm.com for
+            // advice regarding the expression of this.
+            //
+            RSAPrivateCrtKeyParameters crtKey = (RSAPrivateCrtKeyParameters)key;
+
+            BigInteger p = crtKey.getP();
+            BigInteger q = crtKey.getQ();
+            BigInteger dP = crtKey.getDP();
+            BigInteger dQ = crtKey.getDQ();
+            BigInteger qInv = crtKey.getQInv();
+
+            BigInteger mP, mQ, h, m;
+
+            // mP = ((input mod p) ^ dP)) mod p
+            mP = (input.remainder(p)).modPow(dP, p);
+
+            // mQ = ((input mod q) ^ dQ)) mod q
+            mQ = (input.remainder(q)).modPow(dQ, q);
+
+            // h = qInv * (mP - mQ) mod p
+            h = mP.subtract(mQ);
+            h = h.multiply(qInv);
+            h = h.mod(p);               // mod (in Java) returns the positive residual
+
+            // m = h * q + mQ
+            m = h.multiply(q);
+            m = m.add(mQ);
+
+            return m;
+        }
+        else
+        {
+            return input.modPow(
+                        key.getExponent(), key.getModulus());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/engines/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/engines/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/engines/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Basic cipher classes.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/DHBasicKeyPairGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,42 @@
+package org.bouncycastle.crypto.generators;
+
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;
+import org.bouncycastle.crypto.KeyGenerationParameters;
+import org.bouncycastle.crypto.params.DHKeyGenerationParameters;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+
+import ewe.math.BigInteger;
+
+/**
+ * a basic Diffie-Hellman key pair generator.
+ *
+ * This generates keys consistent for use with the basic algorithm for
+ * Diffie-Hellman.
+ */
+public class DHBasicKeyPairGenerator
+    implements AsymmetricCipherKeyPairGenerator
+{
+    private DHKeyGenerationParameters param;
+
+    public void init(
+        KeyGenerationParameters param)
+    {
+        this.param = (DHKeyGenerationParameters)param;
+    }
+
+    public AsymmetricCipherKeyPair generateKeyPair()
+    {
+        DHKeyGeneratorHelper helper = DHKeyGeneratorHelper.INSTANCE;
+        DHParameters dhp = param.getParameters();
+
+        BigInteger x = helper.calculatePrivate(dhp, param.getRandom()); 
+        BigInteger y = helper.calculatePublic(dhp, x);
+
+        return new AsymmetricCipherKeyPair(
+            new DHPublicKeyParameters(y, dhp),
+            new DHPrivateKeyParameters(x, dhp));
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/DHKeyGeneratorHelper.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,51 @@
+package org.bouncycastle.crypto.generators;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.util.BigIntegers;
+
+class DHKeyGeneratorHelper
+{
+    static final DHKeyGeneratorHelper INSTANCE = new DHKeyGeneratorHelper();
+
+    private static final BigInteger ONE = BigInteger.valueOf(1);
+    private static final BigInteger TWO = BigInteger.valueOf(2);
+
+    private DHKeyGeneratorHelper()
+    {
+    }
+
+    BigInteger calculatePrivate(DHParameters dhParams, SecureRandom random)
+    {
+        BigInteger p = dhParams.getP();
+        int limit = dhParams.getL();
+
+        if (limit != 0)
+        {
+            return new BigInteger(limit, random).setBit(limit - 1);
+        }
+
+        BigInteger min = TWO;
+        int m = dhParams.getM();
+        if (m != 0)
+        {
+            min = ONE.shiftLeft(m - 1);
+        }
+
+        BigInteger max = p.subtract(TWO);
+        BigInteger q = dhParams.getQ();
+        if (q != null)
+        {
+            max = q.subtract(TWO);
+        }
+
+        return BigIntegers.createRandomInRange(min, max, random);
+    }
+
+    BigInteger calculatePublic(DHParameters dhParams, BigInteger x)
+    {
+        return dhParams.getG().modPow(x, dhParams.getP());
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/ECKeyPairGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,53 @@
+package org.bouncycastle.crypto.generators;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;
+import org.bouncycastle.crypto.KeyGenerationParameters;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECKeyGenerationParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.math.ec.ECPoint;
+
+public class ECKeyPairGenerator
+    implements AsymmetricCipherKeyPairGenerator, ECConstants
+{
+    ECDomainParameters  params;
+    SecureRandom        random;
+
+    public void init(
+        KeyGenerationParameters param)
+    {
+        ECKeyGenerationParameters  ecP = (ECKeyGenerationParameters)param;
+
+        this.random = ecP.getRandom();
+        this.params = ecP.getDomainParameters();
+    }
+
+    /**
+     * Given the domain parameters this routine generates an EC key
+     * pair in accordance with X9.62 section 5.2.1 pages 26, 27.
+     */
+    public AsymmetricCipherKeyPair generateKeyPair()
+    {
+        BigInteger n = params.getN();
+        int        nBitLength = n.bitLength();
+        BigInteger d;
+
+        do
+        {
+            d = new BigInteger(nBitLength, random);
+        }
+        while (d.equals(ZERO)  || (d.compareTo(n) &gt;= 0));
+
+        ECPoint Q = params.getG().multiply(d);
+
+        return new AsymmetricCipherKeyPair(
+            new ECPublicKeyParameters(Q, params),
+            new ECPrivateKeyParameters(d, params));
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/generators/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/generators/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/generators/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Generators for keys, key pairs and password based encryption algorithms.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/io/SignerInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/io/SignerInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,52 @@
+package org.bouncycastle.crypto.io;
+
+import ewe.io.FilterInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.crypto.Signer;
+
+public class SignerInputStream
+    extends FilterInputStream
+{
+    protected Signer signer;
+
+    public SignerInputStream(
+        InputStream stream,
+        Signer      signer)
+    {
+        super(stream);
+        this.signer = signer;
+    }
+
+    public int read()
+        throws IOException
+    {
+        int b = in.read();
+
+        if (b &gt;= 0)
+        {
+            signer.update((byte)b);
+        }
+        return b;
+    }
+
+    public int read(
+        byte[] b,
+        int off,
+        int len)
+        throws IOException
+    {
+        int n = in.read(b, off, len);
+        if (n &gt; 0)
+        {
+            signer.update(b, off, n);
+        }
+        return n;
+    }
+
+    public Signer getSigner()
+    {
+        return signer;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/io/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/io/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/io/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Classes for doing &quot;enhanced&quot; I/O with Digests and MACs.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/macs/HMac.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/macs/HMac.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/macs/HMac.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/macs/HMac.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/macs/HMac.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,199 @@
+package org.bouncycastle.crypto.macs;
+
+import ewe.util.Hashtable;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.ExtendedDigest;
+import org.bouncycastle.crypto.Mac;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * HMAC implementation based on RFC2104
+ *
+ * H(K XOR opad, H(K XOR ipad, text))
+ */
+public class HMac
+    implements Mac
+{
+    private final static byte IPAD = (byte)0x36;
+    private final static byte OPAD = (byte)0x5C;
+
+    private Digest digest;
+    private int digestSize;
+    private int blockLength;
+    
+    private byte[] inputPad;
+    private byte[] outputPad;
+
+    private static Hashtable blockLengths;
+    
+    static
+    {
+        blockLengths = new Hashtable();
+        
+        blockLengths.put(&quot;GOST3411&quot;, new Integer(32));
+        
+        blockLengths.put(&quot;MD2&quot;, new Integer(16));
+        blockLengths.put(&quot;MD4&quot;, new Integer(64));
+        blockLengths.put(&quot;MD5&quot;, new Integer(64));
+        
+        blockLengths.put(&quot;RIPEMD128&quot;, new Integer(64));
+        blockLengths.put(&quot;RIPEMD160&quot;, new Integer(64));
+        
+        blockLengths.put(&quot;SHA-1&quot;, new Integer(64));
+        blockLengths.put(&quot;SHA-224&quot;, new Integer(64));
+        blockLengths.put(&quot;SHA-256&quot;, new Integer(64));
+        blockLengths.put(&quot;SHA-384&quot;, new Integer(128));
+        blockLengths.put(&quot;SHA-512&quot;, new Integer(128));
+        
+        blockLengths.put(&quot;Tiger&quot;, new Integer(64));
+        blockLengths.put(&quot;Whirlpool&quot;, new Integer(64));
+    }
+    
+    private static int getByteLength(
+        Digest digest)
+    {
+        if (digest instanceof ExtendedDigest)
+        {
+            return ((ExtendedDigest)digest).getByteLength();
+        }
+        
+        Integer  b = (Integer)blockLengths.get(digest.getAlgorithmName());
+        
+        if (b == null)
+        {       
+            throw new IllegalArgumentException(&quot;unknown digest passed: &quot; + digest.getAlgorithmName());
+        }
+        
+        return b.intValue();
+    }
+    
+    /**
+     * Base constructor for one of the standard digest algorithms that the 
+     * byteLength of the algorithm is know for.
+     * 
+     * @param digest the digest.
+     */
+    public HMac(
+        Digest digest)
+    {
+        this(digest, getByteLength(digest));
+    }
+
+    private HMac(
+        Digest digest,
+        int    byteLength)
+    {
+        this.digest = digest;
+        digestSize = digest.getDigestSize();
+
+        this.blockLength = byteLength;
+
+        inputPad = new byte[blockLength];
+        outputPad = new byte[blockLength];
+    }
+    
+    public String getAlgorithmName()
+    {
+        return digest.getAlgorithmName() + &quot;/HMAC&quot;;
+    }
+
+    public Digest getUnderlyingDigest()
+    {
+        return digest;
+    }
+
+    public void init(
+        CipherParameters params)
+    {
+        digest.reset();
+
+        byte[] key = ((KeyParameter)params).getKey();
+
+        if (key.length &gt; blockLength)
+        {
+            digest.update(key, 0, key.length);
+            digest.doFinal(inputPad, 0);
+            for (int i = digestSize; i &lt; inputPad.length; i++)
+            {
+                inputPad[i] = 0;
+            }
+        }
+        else
+        {
+            System.arraycopy(key, 0, inputPad, 0, key.length);
+            for (int i = key.length; i &lt; inputPad.length; i++)
+            {
+                inputPad[i] = 0;
+            }
+        }
+
+        outputPad = new byte[inputPad.length];
+        System.arraycopy(inputPad, 0, outputPad, 0, inputPad.length);
+
+        for (int i = 0; i &lt; inputPad.length; i++)
+        {
+            inputPad[i] ^= IPAD;
+        }
+
+        for (int i = 0; i &lt; outputPad.length; i++)
+        {
+            outputPad[i] ^= OPAD;
+        }
+
+        digest.update(inputPad, 0, inputPad.length);
+    }
+
+    public int getMacSize()
+    {
+        return digestSize;
+    }
+
+    public void update(
+        byte in)
+    {
+        digest.update(in);
+    }
+
+    public void update(
+        byte[] in,
+        int inOff,
+        int len)
+    {
+        digest.update(in, inOff, len);
+    }
+
+    public int doFinal(
+        byte[] out,
+        int outOff)
+    {
+        byte[] tmp = new byte[digestSize];
+        digest.doFinal(tmp, 0);
+
+        digest.update(outputPad, 0, outputPad.length);
+        digest.update(tmp, 0, tmp.length);
+
+        int     len = digest.doFinal(out, outOff);
+
+        reset();
+
+        return len;
+    }
+
+    /**
+     * Reset the mac generator.
+     */
+    public void reset()
+    {
+        /*
+         * reset the underlying digest.
+         */
+        digest.reset();
+
+        /*
+         * reinitialize the digest.
+         */
+        digest.update(inputPad, 0, inputPad.length);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/macs/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/macs/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/macs/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Classes for creating MACs and HMACs.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/modes/CBCBlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,235 @@
+package org.bouncycastle.crypto.modes;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.params.ParametersWithIV;
+import org.bouncycastle.util.Arrays;
+
+/**
+ * implements Cipher-Block-Chaining (CBC) mode on top of a simple cipher.
+ */
+public class CBCBlockCipher
+    implements BlockCipher
+{
+    private byte[]          IV;
+    private byte[]          cbcV;
+    private byte[]          cbcNextV;
+
+    private int             blockSize;
+    private BlockCipher     cipher = null;
+    private boolean         encrypting;
+
+    /**
+     * Basic constructor.
+     *
+     * @param cipher the block cipher to be used as the basis of chaining.
+     */
+    public CBCBlockCipher(
+        BlockCipher cipher)
+    {
+        this.cipher = cipher;
+        this.blockSize = cipher.getBlockSize();
+
+        this.IV = new byte[blockSize];
+        this.cbcV = new byte[blockSize];
+        this.cbcNextV = new byte[blockSize];
+    }
+
+    /**
+     * return the underlying block cipher that we are wrapping.
+     *
+     * @return the underlying block cipher that we are wrapping.
+     */
+    public BlockCipher getUnderlyingCipher()
+    {
+        return cipher;
+    }
+
+    /**
+     * Initialise the cipher and, possibly, the initialisation vector (IV).
+     * If an IV isn't passed as part of the parameter, the IV will be all zeros.
+     *
+     * @param encrypting if true the cipher is initialised for
+     *  encryption, if false for decryption.
+     * @param params the key and other data required by the cipher.
+     * @exception IllegalArgumentException if the params argument is
+     * inappropriate.
+     */
+    public void init(
+        boolean             encrypting,
+        CipherParameters    params)
+        throws IllegalArgumentException
+    {
+        this.encrypting = encrypting;
+        
+        if (params instanceof ParametersWithIV)
+        {
+                ParametersWithIV ivParam = (ParametersWithIV)params;
+                byte[]      iv = ivParam.getIV();
+
+                if (iv.length != blockSize)
+                {
+                    throw new IllegalArgumentException(&quot;initialisation vector must be the same length as block size&quot;);
+                }
+
+                System.arraycopy(iv, 0, IV, 0, iv.length);
+
+                reset();
+
+                cipher.init(encrypting, ivParam.getParameters());
+        }
+        else
+        {
+                reset();
+
+                cipher.init(encrypting, params);
+        }
+    }
+
+    /**
+     * return the algorithm name and mode.
+     *
+     * @return the name of the underlying algorithm followed by &quot;/CBC&quot;.
+     */
+    public String getAlgorithmName()
+    {
+        return cipher.getAlgorithmName() + &quot;/CBC&quot;;
+    }
+
+    /**
+     * return the block size of the underlying cipher.
+     *
+     * @return the block size of the underlying cipher.
+     */
+    public int getBlockSize()
+    {
+        return cipher.getBlockSize();
+    }
+
+    /**
+     * Process one block of input from the array in and write it to
+     * the out array.
+     *
+     * @param in the array containing the input data.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the output data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    public int processBlock(
+        byte[]      in,
+        int         inOff,
+        byte[]      out,
+        int         outOff)
+        throws DataLengthException, IllegalStateException
+    {
+        return (encrypting) ? encryptBlock(in, inOff, out, outOff) : decryptBlock(in, inOff, out, outOff);
+    }
+
+    /**
+     * reset the chaining vector back to the IV and reset the underlying
+     * cipher.
+     */
+    public void reset()
+    {
+        System.arraycopy(IV, 0, cbcV, 0, IV.length);
+        Arrays.fill(cbcNextV, (byte)0);
+
+        cipher.reset();
+    }
+
+    /**
+     * Do the appropriate chaining step for CBC mode encryption.
+     *
+     * @param in the array containing the data to be encrypted.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the encrypted data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    private int encryptBlock(
+        byte[]      in,
+        int         inOff,
+        byte[]      out,
+        int         outOff)
+        throws DataLengthException, IllegalStateException
+    {
+        if ((inOff + blockSize) &gt; in.length)
+        {
+            throw new DataLengthException(&quot;input buffer too short&quot;);
+        }
+
+        /*
+         * XOR the cbcV and the input,
+         * then encrypt the cbcV
+         */
+        for (int i = 0; i &lt; blockSize; i++)
+        {
+            cbcV[i] ^= in[inOff + i];
+        }
+
+        int length = cipher.processBlock(cbcV, 0, out, outOff);
+
+        /*
+         * copy ciphertext to cbcV
+         */
+        System.arraycopy(out, outOff, cbcV, 0, cbcV.length);
+
+        return length;
+    }
+
+    /**
+     * Do the appropriate chaining step for CBC mode decryption.
+     *
+     * @param in the array containing the data to be decrypted.
+     * @param inOff offset into the in array the data starts at.
+     * @param out the array the decrypted data will be copied into.
+     * @param outOff the offset into the out array the output will start at.
+     * @exception DataLengthException if there isn't enough data in in, or
+     * space in out.
+     * @exception IllegalStateException if the cipher isn't initialised.
+     * @return the number of bytes processed and produced.
+     */
+    private int decryptBlock(
+        byte[]      in,
+        int         inOff,
+        byte[]      out,
+        int         outOff)
+        throws DataLengthException, IllegalStateException
+    {
+        if ((inOff + blockSize) &gt; in.length)
+        {
+            throw new DataLengthException(&quot;input buffer too short&quot;);
+        }
+
+        System.arraycopy(in, inOff, cbcNextV, 0, blockSize);
+
+        int length = cipher.processBlock(in, inOff, out, outOff);
+
+        /*
+         * XOR the cbcV and the output
+         */
+        for (int i = 0; i &lt; blockSize; i++)
+        {
+            out[outOff + i] ^= cbcV[i];
+        }
+
+        /*
+         * swap the back up buffer into next position
+         */
+        byte[]  tmp;
+
+        tmp = cbcV;
+        cbcV = cbcNextV;
+        cbcNextV = tmp;
+
+        return length;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/modes/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/modes/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/modes/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Modes for symmetric ciphers.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Base classes for the lightweight API.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/AsymmetricKeyParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,20 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class AsymmetricKeyParameter
+    implements CipherParameters
+{
+    boolean privateKey;
+
+    public AsymmetricKeyParameter(
+        boolean privateKey)
+    {
+        this.privateKey = privateKey;
+    }
+
+    public boolean isPrivate()
+    {
+        return privateKey;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHKeyGenerationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.KeyGenerationParameters;
+
+public class DHKeyGenerationParameters
+    extends KeyGenerationParameters
+{
+    private DHParameters    params;
+
+    public DHKeyGenerationParameters(
+        SecureRandom    random,
+        DHParameters    params)
+    {
+        super(random, getStrength(params));
+
+        this.params = params;
+    }
+
+    public DHParameters getParameters()
+    {
+        return params;
+    }
+
+    static int getStrength(DHParameters params)
+    {
+        return params.getL() != 0 ? params.getL() : params.getP().bitLength();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,54 @@
+package org.bouncycastle.crypto.params;
+
+
+public class DHKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private DHParameters    params;
+
+    protected DHKeyParameters(
+        boolean         isPrivate,
+        DHParameters    params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }   
+
+    public DHParameters getParameters()
+    {
+        return params;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHKeyParameters))
+        {
+            return false;
+        }
+
+        DHKeyParameters    dhKey = (DHKeyParameters)obj;
+
+        if (params == null)
+        {
+            return dhKey.getParameters() == null;
+        }
+        else
+        { 
+            return params.equals(dhKey.getParameters());
+        }
+    }
+    
+    public int hashCode()
+    {
+        int code = isPrivate() ? 0 : 1;
+        
+        if (params != null)
+        {
+            code ^= params.hashCode();
+        }
+        
+        return code;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,188 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+import ewe.math.BigInteger;
+
+public class DHParameters
+    implements CipherParameters
+{
+    private static final int DEFAULT_MINIMUM_LENGTH = 160;
+
+    // not final due to compiler bug in &quot;simpler&quot; JDKs
+    private BigInteger              g;
+    private BigInteger              p;
+    private BigInteger              q;
+    private BigInteger              j;
+    private int                     m;
+    private int                     l;
+    private DHValidationParameters  validation;
+
+    private static int getDefaultMParam(
+        int lParam)
+    {
+        if (lParam == 0)
+        {
+            return DEFAULT_MINIMUM_LENGTH;
+        }
+
+        return lParam &lt; DEFAULT_MINIMUM_LENGTH ? lParam : DEFAULT_MINIMUM_LENGTH;
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g)
+    {
+        this(p, g, null, 0);
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g,
+        BigInteger  q)
+    {
+        this(p, g, q, 0);
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g,
+        BigInteger  q,
+        int         l)
+    {
+        this(p, g, q, getDefaultMParam(l), l, null, null);
+    }
+
+    public DHParameters(
+        BigInteger  p,
+        BigInteger  g,
+        BigInteger  q,
+        int         m,
+        int         l)
+    {
+        this(p, g, q, m, l, null, null);
+    }
+
+    public DHParameters(
+        BigInteger              p,
+        BigInteger              g,
+        BigInteger              q,
+        BigInteger              j,
+        DHValidationParameters  validation)
+    {
+        this(p, g, q, DEFAULT_MINIMUM_LENGTH, 0, j, validation);
+    }
+
+    public DHParameters(
+        BigInteger              p,
+        BigInteger              g,
+        BigInteger              q,
+        int                     m,
+        int                     l,
+        BigInteger              j,
+        DHValidationParameters  validation)
+    {
+        if (l != 0)
+        {
+            if (l &gt;= p.bitLength())
+            {
+                throw new IllegalArgumentException(&quot;when l value specified, it must be less than bitlength(p)&quot;);
+            }
+            if (l &lt; m)
+            {
+                throw new IllegalArgumentException(&quot;when l value specified, it may not be less than m value&quot;);
+            }
+        }
+
+        this.g = g;
+        this.p = p;
+        this.q = q;
+        this.m = m;
+        this.l = l;
+        this.j = j;
+        this.validation = validation;
+    }
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    public BigInteger getG()
+    {
+        return g;
+    }
+
+    public BigInteger getQ()
+    {
+        return q;
+    }
+
+    /**
+     * Return the subgroup factor J.
+     *
+     * @return subgroup factor
+     */
+    public BigInteger getJ()
+    {
+        return j;
+    }
+
+    /**
+     * Return the minimum length of the private value.
+     *
+     * @return the minimum length of the private value in bits.
+     */
+    public int getM()
+    {
+        return m;
+    }
+
+    /**
+     * Return the private value length in bits - if set, zero otherwise
+     *
+     * @return the private value length in bits, zero otherwise.
+     */
+    public int getL()
+    {
+        return l;
+    }
+
+    public DHValidationParameters getValidationParameters()
+    {
+        return validation;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHParameters))
+        {
+            return false;
+        }
+
+        DHParameters    pm = (DHParameters)obj;
+
+        if (this.getQ() != null)
+        {
+            if (!this.getQ().equals(pm.getQ()))
+            {
+                return false;
+            }
+        }
+        else
+        {
+            if (pm.getQ() != null)
+            {
+                return false;
+            }
+        }
+
+        return pm.getP().equals(p) &amp;&amp; pm.getG().equals(g);
+    }
+    
+    public int hashCode()
+    {
+        return getP().hashCode() ^ getG().hashCode() ^ (getQ() != null ? getQ().hashCode() : 0);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHPrivateKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DHPrivateKeyParameters
+    extends DHKeyParameters
+{
+    private BigInteger      x;
+
+    public DHPrivateKeyParameters(
+        BigInteger      x,
+        DHParameters    params)
+    {
+        super(true, params);
+
+        this.x = x;
+    }   
+
+    public BigInteger getX()
+    {
+        return x;
+    }
+
+    public int hashCode()
+    {
+        return x.hashCode() ^ super.hashCode();
+    }
+    
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHPrivateKeyParameters))
+        {
+            return false;
+        }
+
+        DHPrivateKeyParameters  other = (DHPrivateKeyParameters)obj;
+
+        return other.getX().equals(this.x) &amp;&amp; super.equals(obj);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DHPublicKeyParameters
+    extends DHKeyParameters
+{
+    private BigInteger      y;
+
+    public DHPublicKeyParameters(
+        BigInteger      y,
+        DHParameters    params)
+    {
+        super(false, params);
+
+        this.y = y;
+    }   
+
+    public BigInteger getY()
+    {
+        return y;
+    }
+
+    public int hashCode()
+    {
+        return y.hashCode() ^ super.hashCode();
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DHPublicKeyParameters))
+        {
+            return false;
+        }
+
+        DHPublicKeyParameters   other = (DHPublicKeyParameters)obj;
+
+        return other.getY().equals(y) &amp;&amp; super.equals(obj);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DHValidationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,50 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.util.Arrays;
+
+public class DHValidationParameters
+{
+    private byte[]  seed;
+    private int     counter;
+
+    public DHValidationParameters(
+        byte[]  seed,
+        int     counter)
+    {
+        this.seed = seed;
+        this.counter = counter;
+    }
+
+    public int getCounter()
+    {
+        return counter;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+
+    public boolean equals(
+        Object o)
+    {
+        if (!(o instanceof DHValidationParameters))
+        {
+            return false;
+        }
+
+        DHValidationParameters  other = (DHValidationParameters)o;
+
+        if (other.counter != this.counter)
+        {
+            return false;
+        }
+
+        return Arrays.areEqual(this.seed, other.seed);
+    }
+
+    public int hashCode()
+    {
+        return counter ^ Arrays.hashCode(seed);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,21 @@
+package org.bouncycastle.crypto.params;
+
+public class DSAKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private DSAParameters    params;
+
+    public DSAKeyParameters(
+        boolean         isPrivate,
+        DSAParameters   params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }   
+
+    public DSAParameters getParameters()
+    {
+        return params;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,74 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class DSAParameters
+    implements CipherParameters
+{
+    private BigInteger              g;
+    private BigInteger              q;
+    private BigInteger              p;
+    private DSAValidationParameters validation;
+
+    public DSAParameters(
+        BigInteger  p,
+        BigInteger  q,
+        BigInteger  g)
+    {
+        this.g = g;
+        this.p = p;
+        this.q = q;
+    }   
+
+    public DSAParameters(
+        BigInteger              p,
+        BigInteger              q,
+        BigInteger              g,
+        DSAValidationParameters params)
+    {
+        this.g = g;
+        this.p = p;
+        this.q = q;
+        this.validation = params;
+    }   
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    public BigInteger getQ()
+    {
+        return q;
+    }
+
+    public BigInteger getG()
+    {
+        return g;
+    }
+
+    public DSAValidationParameters getValidationParameters()
+    {
+        return validation;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof DSAParameters))
+        {
+            return false;
+        }
+
+        DSAParameters    pm = (DSAParameters)obj;
+
+        return (pm.getP().equals(p) &amp;&amp; pm.getQ().equals(q) &amp;&amp; pm.getG().equals(g));
+    }
+    
+    public int hashCode()
+    {
+        return getP().hashCode() ^ getQ().hashCode() ^ getG().hashCode();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAPrivateKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DSAPrivateKeyParameters
+    extends DSAKeyParameters
+{
+    private BigInteger      x;
+
+    public DSAPrivateKeyParameters(
+        BigInteger      x,
+        DSAParameters   params)
+    {
+        super(true, params);
+
+        this.x = x;
+    }   
+
+    public BigInteger getX()
+    {
+        return x;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class DSAPublicKeyParameters
+    extends DSAKeyParameters
+{
+    private BigInteger      y;
+
+    public DSAPublicKeyParameters(
+        BigInteger      y,
+        DSAParameters   params)
+    {
+        super(false, params);
+
+        this.y = y;
+    }   
+
+    public BigInteger getY()
+    {
+        return y;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/DSAValidationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,50 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.util.Arrays;
+
+public class DSAValidationParameters
+{
+    private byte[]  seed;
+    private int     counter;
+
+    public DSAValidationParameters(
+        byte[]  seed,
+        int     counter)
+    {
+        this.seed = seed;
+        this.counter = counter;
+    }
+
+    public int getCounter()
+    {
+        return counter;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+
+    public int hashCode()
+    {
+        return counter ^ Arrays.hashCode(seed);
+    }
+    
+    public boolean equals(
+        Object o)
+    {
+        if (!(o instanceof DSAValidationParameters))
+        {
+            return false;
+        }
+
+        DSAValidationParameters  other = (DSAValidationParameters)o;
+
+        if (other.counter != this.counter)
+        {
+            return false;
+        }
+
+        return Arrays.areEqual(this.seed, other.seed);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECDomainParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,81 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.math.ec.ECCurve;
+import org.bouncycastle.math.ec.ECPoint;
+
+public class ECDomainParameters
+    implements ECConstants
+{
+    ECCurve     curve;
+    byte[]      seed;
+    ECPoint     G;
+    BigInteger  n;
+    BigInteger  h;
+
+    public ECDomainParameters(
+        ECCurve     curve,
+        ECPoint     G,
+        BigInteger  n)
+    {
+        this.curve = curve;
+        this.G = G;
+        this.n = n;
+        this.h = ONE;
+        this.seed = null;
+    }
+
+    public ECDomainParameters(
+        ECCurve     curve,
+        ECPoint     G,
+        BigInteger  n,
+        BigInteger  h)
+    {
+        this.curve = curve;
+        this.G = G;
+        this.n = n;
+        this.h = h;
+        this.seed = null;
+    }
+
+    public ECDomainParameters(
+        ECCurve     curve,
+        ECPoint     G,
+        BigInteger  n,
+        BigInteger  h,
+        byte[]      seed)
+    {
+        this.curve = curve;
+        this.G = G;
+        this.n = n;
+        this.h = h;
+        this.seed = seed;
+    }
+
+    public ECCurve getCurve()
+    {
+        return curve;
+    }
+
+    public ECPoint getG()
+    {
+        return G;
+    }
+
+    public BigInteger getN()
+    {
+        return n;
+    }
+
+    public BigInteger getH()
+    {
+        return h;
+    }
+
+    public byte[] getSeed()
+    {
+        return seed;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECKeyGenerationParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.KeyGenerationParameters;
+
+public class ECKeyGenerationParameters
+    extends KeyGenerationParameters
+{
+    private ECDomainParameters  domainParams;
+
+    public ECKeyGenerationParameters(
+        ECDomainParameters      domainParams,
+        SecureRandom            random)
+    {
+        super(random, domainParams.getN().bitLength());
+
+        this.domainParams = domainParams;
+    }
+
+    public ECDomainParameters getDomainParameters()
+    {
+        return domainParams;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,21 @@
+package org.bouncycastle.crypto.params;
+
+public class ECKeyParameters
+    extends AsymmetricKeyParameter
+{
+    ECDomainParameters params;
+
+    protected ECKeyParameters(
+        boolean             isPrivate,
+        ECDomainParameters  params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }
+
+    public ECDomainParameters getParameters()
+    {
+        return params;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECPrivateKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class ECPrivateKeyParameters
+    extends ECKeyParameters
+{
+    BigInteger d;
+
+    public ECPrivateKeyParameters(
+        BigInteger          d,
+        ECDomainParameters  params)
+    {
+        super(true, params);
+        this.d = d;
+    }
+
+    public BigInteger getD()
+    {
+        return d;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ECPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,22 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.math.ec.ECPoint;
+
+public class ECPublicKeyParameters
+    extends ECKeyParameters
+{
+    ECPoint Q;
+
+    public ECPublicKeyParameters(
+        ECPoint             Q,
+        ECDomainParameters  params)
+    {
+        super(false, params);
+        this.Q = Q;
+    }
+
+    public ECPoint getQ()
+    {
+        return Q;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ElGamalKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,47 @@
+package org.bouncycastle.crypto.params;
+
+
+public class ElGamalKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private ElGamalParameters    params;
+
+    protected ElGamalKeyParameters(
+        boolean         isPrivate,
+        ElGamalParameters    params)
+    {
+        super(isPrivate);
+
+        this.params = params;
+    }   
+
+    public ElGamalParameters getParameters()
+    {
+        return params;
+    }
+
+    public int hashCode()
+    {
+        return (params != null) ? params.hashCode() : 0;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof ElGamalKeyParameters))
+        {
+            return false;
+        }
+
+        ElGamalKeyParameters    dhKey = (ElGamalKeyParameters)obj;
+
+        if (params == null)
+        {
+            return dhKey.getParameters() == null;
+        }
+        else
+        { 
+            return params.equals(dhKey.getParameters());
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ElGamalParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,69 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class ElGamalParameters
+    implements CipherParameters
+{
+    private BigInteger              g;
+    private BigInteger              p;
+    private int                     l;
+
+    public ElGamalParameters(
+        BigInteger  p,
+        BigInteger  g)
+    {
+        this(p, g, 0);
+    }
+
+    public ElGamalParameters(
+        BigInteger  p,
+        BigInteger  g,
+        int         l)
+    {
+        this.g = g;
+        this.p = p;
+        this.l = l;
+    }
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    /**
+     * return the generator - g
+     */
+    public BigInteger getG()
+    {
+        return g;
+    }
+
+    /**
+     * return private value limit - l
+     */
+    public int getL()
+    {
+        return l;
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof ElGamalParameters))
+        {
+            return false;
+        }
+
+        ElGamalParameters    pm = (ElGamalParameters)obj;
+
+        return pm.getP().equals(p) &amp;&amp; pm.getG().equals(g) &amp;&amp; pm.getL() == l;
+    }
+    
+    public int hashCode()
+    {
+        return (getP().hashCode() ^ getG().hashCode()) + l;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ElGamalPublicKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,41 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class ElGamalPublicKeyParameters
+    extends ElGamalKeyParameters
+{
+    private BigInteger      y;
+
+    public ElGamalPublicKeyParameters(
+        BigInteger      y,
+        ElGamalParameters    params)
+    {
+        super(false, params);
+
+        this.y = y;
+    }   
+
+    public BigInteger getY()
+    {
+        return y;
+    }
+
+    public int hashCode()
+    {
+        return y.hashCode() ^ super.hashCode();
+    }
+
+    public boolean equals(
+        Object  obj)
+    {
+        if (!(obj instanceof ElGamalPublicKeyParameters))
+        {
+            return false;
+        }
+
+        ElGamalPublicKeyParameters   other = (ElGamalPublicKeyParameters)obj;
+
+        return other.getY().equals(y) &amp;&amp; super.equals(obj);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/KeyParameter.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/KeyParameter.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/KeyParameter.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/KeyParameter.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class KeyParameter
+    implements CipherParameters
+{
+    private byte[]  key;
+
+    public KeyParameter(
+        byte[]  key)
+    {
+        this(key, 0, key.length);
+    }
+
+    public KeyParameter(
+        byte[]  key,
+        int     keyOff,
+        int     keyLen)
+    {
+        this.key = new byte[keyLen];
+
+        System.arraycopy(key, keyOff, this.key, 0, keyLen);
+    }
+
+    public byte[] getKey()
+    {
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ParametersWithIV.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+public class ParametersWithIV
+    implements CipherParameters
+{
+    private byte[]              iv;
+    private CipherParameters    parameters;
+
+    public ParametersWithIV(
+        CipherParameters    parameters,
+        byte[]              iv)
+    {
+        this(parameters, iv, 0, iv.length);
+    }
+
+    public ParametersWithIV(
+        CipherParameters    parameters,
+        byte[]              iv,
+        int                 ivOff,
+        int                 ivLen)
+    {
+        this.iv = new byte[ivLen];
+        this.parameters = parameters;
+
+        System.arraycopy(iv, ivOff, this.iv, 0, ivLen);
+    }
+
+    public byte[] getIV()
+    {
+        return iv;
+    }
+
+    public CipherParameters getParameters()
+    {
+        return parameters;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/ParametersWithRandom.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,36 @@
+package org.bouncycastle.crypto.params;
+
+import org.bouncycastle.crypto.CipherParameters;
+
+import ewe.security.SecureRandom;
+
+public class ParametersWithRandom
+    implements CipherParameters
+{
+    private SecureRandom        random;
+    private CipherParameters    parameters;
+
+    public ParametersWithRandom(
+        CipherParameters    parameters,
+        SecureRandom        random)
+    {
+        this.random = random;
+        this.parameters = parameters;
+    }
+
+    public ParametersWithRandom(
+        CipherParameters    parameters)
+    {
+        this(parameters, new SecureRandom());
+    }
+
+    public SecureRandom getRandom()
+    {
+        return random;
+    }
+
+    public CipherParameters getParameters()
+    {
+        return parameters;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/RSAKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,31 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class RSAKeyParameters
+    extends AsymmetricKeyParameter
+{
+    private BigInteger      modulus;
+    private BigInteger      exponent;
+
+    public RSAKeyParameters(
+        boolean     isPrivate,
+        BigInteger  modulus,
+        BigInteger  exponent)
+    {
+        super(isPrivate);
+
+        this.modulus = modulus;
+        this.exponent = exponent;
+    }   
+
+    public BigInteger getModulus()
+    {
+        return modulus;
+    }
+
+    public BigInteger getExponent()
+    {
+        return exponent;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/RSAPrivateCrtKeyParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,67 @@
+package org.bouncycastle.crypto.params;
+
+import ewe.math.BigInteger;
+
+public class RSAPrivateCrtKeyParameters
+    extends RSAKeyParameters
+{
+    private BigInteger  e;
+    private BigInteger  p;
+    private BigInteger  q;
+    private BigInteger  dP;
+    private BigInteger  dQ;
+    private BigInteger  qInv;
+
+    /**
+     * 
+     */
+    public RSAPrivateCrtKeyParameters(
+        BigInteger  modulus,
+        BigInteger  publicExponent,
+        BigInteger  privateExponent,
+        BigInteger  p,
+        BigInteger  q,
+        BigInteger  dP,
+        BigInteger  dQ,
+        BigInteger  qInv)
+    {
+        super(true, modulus, privateExponent);
+
+        this.e = publicExponent;
+        this.p = p;
+        this.q = q;
+        this.dP = dP;
+        this.dQ = dQ;
+        this.qInv = qInv;
+    }
+
+    public BigInteger getPublicExponent()
+    {
+        return e;
+    }
+
+    public BigInteger getP()
+    {
+        return p;
+    }
+
+    public BigInteger getQ()
+    {
+        return q;
+    }
+
+    public BigInteger getDP()
+    {
+        return dP;
+    }
+
+    public BigInteger getDQ()
+    {
+        return dQ;
+    }
+
+    public BigInteger getQInv()
+    {
+        return qInv;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/params/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/params/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/params/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Classes for parameter objects for ciphers and generators.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator$SeedGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/prng/ThreadedSeedGenerator.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,100 @@
+package org.bouncycastle.crypto.prng;
+
+/**
+ * A thread based seed generator - one source of randomness.
+ * &lt;p&gt;
+ * Based on an idea from Marcus Lippert.
+ * &lt;/p&gt;
+ */
+public class ThreadedSeedGenerator
+{
+    static ewe.security.SecureRandom rs = null;
+    private class SeedGenerator
+        /* implements Runnable */
+    {
+        /* private volatile int counter = 0;
+         private volatile boolean stop = false;
+
+        public void run()
+        {
+            while (!this.stop)
+            {
+                this.counter++;
+            }
+
+        }
+       */
+        public byte[] generateSeed(
+            int numbytes,
+            boolean fast)
+        {
+            // Thread t = new Thread(this);
+            byte[] result = new byte[numbytes];
+            if (rs == null) rs = new ewe.security.SecureRandom();
+            rs.nextBytes(result);
+
+           /* this.counter = 0;
+            this.stop = false;
+            int last = 0;
+            int end;
+
+            t.start();
+            if(fast)
+            {
+                end = numbytes;
+            }
+            else
+            {
+                end = numbytes * 8;
+            }
+            for (int i = 0; i &lt; end; i++)
+            {
+                while (this.counter == last)
+                {
+                    try
+                    {
+                        Thread.sleep(1);
+                    }
+                    catch (InterruptedException e)
+                    {
+                        // ignore
+                    }
+                }
+                last = this.counter;
+                if (fast)
+                {
+                    result[i] = (byte) (last &amp; 0xff);
+                }
+                else
+                {
+                    int bytepos = i/8;
+                    result[bytepos] = (byte) ((result[bytepos] &lt;&lt; 1) | (last &amp; 1));
+                }
+
+            }
+            stop = true;
+            */
+            return result;
+        }
+    }
+
+    /**
+     * Generate seed bytes. Set fast to false for best quality.
+     * &lt;p&gt;
+     * If fast is set to true, the code should be round about 8 times faster when
+     * generating a long sequence of random bytes. 20 bytes of random values using
+     * the fast mode take less than half a second on a Nokia e70. If fast is set to false,
+     * it takes round about 2500 ms.
+     * &lt;/p&gt;
+     * @param numBytes the number of bytes to generate
+     * @param fast true if fast mode should be used
+     */
+    public byte[] generateSeed(
+        int numBytes,
+        boolean fast)
+    {
+        SeedGenerator gen = new SeedGenerator();
+
+        return gen.generateSeed(numBytes, fast);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/prng/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/prng/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/prng/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Lightweight psuedo-random number generators.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/DSADigestSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,154 @@
+package org.bouncycastle.crypto.signers;
+
+import ewe.io.IOException;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1EncodableVector;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+public class DSADigestSigner
+    implements Signer
+{
+    private final Digest digest;
+    private final DSA dsaSigner;
+    private boolean forSigning;
+
+    public DSADigestSigner(
+        DSA    signer,
+        Digest digest)
+    {
+        this.digest = digest;
+        this.dsaSigner = signer;
+    }
+
+    public void init(
+        boolean           forSigning,
+        CipherParameters   parameters)
+    {
+        this.forSigning = forSigning;
+
+        AsymmetricKeyParameter k;
+
+        if (parameters instanceof ParametersWithRandom)
+        {
+            k = (AsymmetricKeyParameter)((ParametersWithRandom)parameters).getParameters();
+        }
+        else
+        {
+            k = (AsymmetricKeyParameter)parameters;
+        }
+
+        if (forSigning &amp;&amp; !k.isPrivate())
+        {
+            throw new IllegalArgumentException(&quot;Signing Requires Private Key.&quot;);
+        }
+
+        if (!forSigning &amp;&amp; k.isPrivate())
+        {
+            throw new IllegalArgumentException(&quot;Verification Requires Public Key.&quot;);
+        }
+
+        reset();
+
+        dsaSigner.init(forSigning, parameters);
+    }
+
+    /**
+     * update the internal digest with the byte b
+     */
+    public void update(
+        byte input)
+    {
+        digest.update(input);
+    }
+
+    /**
+     * update the internal digest with the byte array in
+     */
+    public void update(
+        byte[]  input,
+        int     inOff,
+        int     length)
+    {
+        digest.update(input, inOff, length);
+    }
+
+    /**
+     * Generate a signature for the message we've been loaded with using
+     * the key we were initialised with.
+     */
+    public byte[] generateSignature()
+    {
+        if (!forSigning)
+        {
+            throw new IllegalStateException(&quot;DSADigestSigner not initialised for signature generation.&quot;);
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        BigInteger[] sig = dsaSigner.generateSignature(hash);
+
+        return derEncode(sig[0], sig[1]);
+    }
+
+    public boolean verifySignature(
+        byte[] signature)
+    {
+        if (forSigning)
+        {
+            throw new IllegalStateException(&quot;DSADigestSigner not initialised for verification&quot;);
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        try
+        {
+            BigInteger[] sig = derDecode(signature);
+            return dsaSigner.verifySignature(hash, sig[0], sig[1]);
+        }
+        catch (IOException e)
+        {
+            return false;
+        }
+    }
+
+    public void reset()
+    {
+        digest.reset();
+    }
+
+    private byte[] derEncode(
+        BigInteger  r,
+        BigInteger  s)
+    {
+        ASN1EncodableVector v = new ASN1EncodableVector();
+        v.add(new DERInteger(r));
+        v.add(new DERInteger(s));
+
+        return new DERSequence(v).getDEREncoded();
+    }
+
+    private BigInteger[] derDecode(
+        byte[] encoding)
+        throws IOException
+    {
+        ASN1Sequence s = (ASN1Sequence)ASN1Object.fromByteArray(encoding);
+
+        return new BigInteger[]
+        {
+            ((DERInteger)s.getObjectAt(0)).getValue(),
+            ((DERInteger)s.getObjectAt(1)).getValue()
+        };
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/DSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/DSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/DSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/DSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,138 @@
+package org.bouncycastle.crypto.signers;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.DSAKeyParameters;
+import org.bouncycastle.crypto.params.DSAParameters;
+import org.bouncycastle.crypto.params.DSAPrivateKeyParameters;
+import org.bouncycastle.crypto.params.DSAPublicKeyParameters;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+/**
+ * The Digital Signature Algorithm - as described in &quot;Handbook of Applied
+ * Cryptography&quot;, pages 452 - 453.
+ */
+public class DSASigner
+    implements DSA
+{
+    DSAKeyParameters key;
+
+    SecureRandom    random;
+
+    public void init(
+        boolean                 forSigning,
+        CipherParameters        param)
+    {
+        if (forSigning)
+        {
+            if (param instanceof ParametersWithRandom)
+            {
+                ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+                this.random = rParam.getRandom();
+                this.key = (DSAPrivateKeyParameters)rParam.getParameters();
+            }
+            else
+            {
+                this.random = new SecureRandom();
+                this.key = (DSAPrivateKeyParameters)param;
+            }
+        }
+        else
+        {
+            this.key = (DSAPublicKeyParameters)param;
+        }
+    }
+
+    /**
+     * generate a signature for the given message using the key we were
+     * initialised with. For conventional DSA the message should be a SHA-1
+     * hash of the message of interest.
+     *
+     * @param message the message that will be verified later.
+     */
+    public BigInteger[] generateSignature(
+        byte[] message)
+    {
+        DSAParameters   params = key.getParameters();
+        BigInteger      m = calculateE(params.getQ(), message);
+        BigInteger      k;
+        int                  qBitLength = params.getQ().bitLength();
+
+        do 
+        {
+            k = new BigInteger(qBitLength, random);
+        }
+        while (k.compareTo(params.getQ()) &gt;= 0);
+
+        BigInteger  r = params.getG().modPow(k, params.getP()).mod(params.getQ());
+
+        k = k.modInverse(params.getQ()).multiply(
+                    m.add(((DSAPrivateKeyParameters)key).getX().multiply(r)));
+
+        BigInteger  s = k.mod(params.getQ());
+
+        BigInteger[]  res = new BigInteger[2];
+
+        res[0] = r;
+        res[1] = s;
+
+        return res;
+    }
+
+    /**
+     * return true if the value r and s represent a DSA signature for
+     * the passed in message for standard DSA the message should be a
+     * SHA-1 hash of the real message to be verified.
+     */
+    public boolean verifySignature(
+        byte[]      message,
+        BigInteger  r,
+        BigInteger  s)
+    {
+        DSAParameters   params = key.getParameters();
+        BigInteger      m = calculateE(params.getQ(), message);
+        BigInteger      zero = BigInteger.valueOf(0);
+
+        if (zero.compareTo(r) &gt;= 0 || params.getQ().compareTo(r) &lt;= 0)
+        {
+            return false;
+        }
+
+        if (zero.compareTo(s) &gt;= 0 || params.getQ().compareTo(s) &lt;= 0)
+        {
+            return false;
+        }
+
+        BigInteger  w = s.modInverse(params.getQ());
+
+        BigInteger  u1 = m.multiply(w).mod(params.getQ());
+        BigInteger  u2 = r.multiply(w).mod(params.getQ());
+
+        u1 = params.getG().modPow(u1, params.getP());
+        u2 = ((DSAPublicKeyParameters)key).getY().modPow(u2, params.getP());
+
+        BigInteger  v = u1.multiply(u2).mod(params.getP()).mod(params.getQ());
+
+        return v.equals(r);
+    }
+
+    private BigInteger calculateE(BigInteger n, byte[] message)
+    {
+        if (n.bitLength() &gt;= message.length * 8)
+        {
+            return new BigInteger(1, message);
+        }
+        else
+        {
+            byte[] trunc = new byte[n.bitLength() / 8];
+
+            System.arraycopy(message, 0, trunc, 0, trunc.length);
+
+            return new BigInteger(1, trunc);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/ECDSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,164 @@
+package org.bouncycastle.crypto.signers;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.ECKeyParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.math.ec.ECAlgorithms;
+import org.bouncycastle.math.ec.ECConstants;
+import org.bouncycastle.math.ec.ECPoint;
+
+/**
+ * EC-DSA as described in X9.62
+ */
+public class ECDSASigner
+    implements ECConstants, DSA
+{
+    ECKeyParameters key;
+
+    SecureRandom    random;
+
+    public void init(
+        boolean                 forSigning,
+        CipherParameters        param)
+    {
+        if (forSigning)
+        {
+            if (param instanceof ParametersWithRandom)
+            {
+                ParametersWithRandom    rParam = (ParametersWithRandom)param;
+
+                this.random = rParam.getRandom();
+                this.key = (ECPrivateKeyParameters)rParam.getParameters();
+            }
+            else
+            {
+                this.random = new SecureRandom();
+                this.key = (ECPrivateKeyParameters)param;
+            }
+        }
+        else
+        {
+            this.key = (ECPublicKeyParameters)param;
+        }
+    }
+
+    // 5.3 pg 28
+    /**
+     * generate a signature for the given message using the key we were
+     * initialised with. For conventional DSA the message should be a SHA-1
+     * hash of the message of interest.
+     *
+     * @param message the message that will be verified later.
+     */
+    public BigInteger[] generateSignature(
+        byte[] message)
+    {
+        BigInteger n = key.getParameters().getN();
+        BigInteger e = calculateE(n, message);
+        BigInteger r = null;
+        BigInteger s = null;
+
+        // 5.3.2
+        do // generate s
+        {
+            BigInteger k = null;
+            int        nBitLength = n.bitLength();
+
+            do // generate r
+            {
+                do
+                {
+                    k = new BigInteger(nBitLength, random);
+                }
+                while (k.equals(ZERO) || k.compareTo(n) &gt;= 0);
+
+                ECPoint p = key.getParameters().getG().multiply(k);
+
+                // 5.3.3
+                BigInteger x = p.getX().toBigInteger();
+
+                r = x.mod(n);
+            }
+            while (r.equals(ZERO));
+
+            BigInteger d = ((ECPrivateKeyParameters)key).getD();
+
+            s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
+        }
+        while (s.equals(ZERO));
+
+        BigInteger[]  res = new BigInteger[2];
+
+        res[0] = r;
+        res[1] = s;
+
+        return res;
+    }
+
+    // 5.4 pg 29
+    /**
+     * return true if the value r and s represent a DSA signature for
+     * the passed in message (for standard DSA the message should be
+     * a SHA-1 hash of the real message to be verified).
+     */
+    public boolean verifySignature(
+        byte[]      message,
+        BigInteger  r,
+        BigInteger  s)
+    {
+        BigInteger n = key.getParameters().getN();
+        BigInteger e = calculateE(n, message);
+
+        // r in the range [1,n-1]
+        if (r.compareTo(ONE) &lt; 0 || r.compareTo(n) &gt;= 0)
+        {
+            return false;
+        }
+
+        // s in the range [1,n-1]
+        if (s.compareTo(ONE) &lt; 0 || s.compareTo(n) &gt;= 0)
+        {
+            return false;
+        }
+
+        BigInteger c = s.modInverse(n);
+
+        BigInteger u1 = e.multiply(c).mod(n);
+        BigInteger u2 = r.multiply(c).mod(n);
+
+        ECPoint G = key.getParameters().getG();
+        ECPoint Q = ((ECPublicKeyParameters)key).getQ();
+
+        ECPoint point = ECAlgorithms.sumOfTwoMultiplies(G, u1, Q, u2);
+
+        BigInteger v = point.getX().toBigInteger().mod(n);
+
+        return v.equals(r);
+    }
+
+    private BigInteger calculateE(BigInteger n, byte[] message)
+    {  
+        if (n.bitLength() &gt; message.length * 8)
+        {
+            return new BigInteger(1, message);
+        }
+        else
+        {
+            int messageBitLength = message.length * 8;
+            BigInteger trunc = new BigInteger(1, message);
+
+            if (messageBitLength - n.bitLength() &gt; 0)
+            {
+                trunc = trunc.shiftRight(messageBitLength - n.bitLength());
+            }
+
+            return trunc;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/signers/GenericSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/GenericSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,136 @@
+package org.bouncycastle.crypto.signers;
+
+import org.bouncycastle.crypto.AsymmetricBlockCipher;
+import org.bouncycastle.crypto.CipherParameters;
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.DataLengthException;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.util.Arrays;
+
+public class GenericSigner
+    implements Signer
+{
+    private final AsymmetricBlockCipher engine;
+    private final Digest digest;
+    private boolean forSigning;
+
+    public GenericSigner(
+        AsymmetricBlockCipher engine,
+        Digest                digest)
+    {
+        this.engine = engine;
+        this.digest = digest;
+    }
+
+    /**
+     * initialise the signer for signing or verification.
+     *
+     * @param forSigning
+     *            true if for signing, false otherwise
+     * @param parameters
+     *            necessary parameters.
+     */
+    public void init(
+        boolean          forSigning,
+        CipherParameters parameters)
+    {
+        this.forSigning = forSigning;
+        AsymmetricKeyParameter k;
+
+        if (parameters instanceof ParametersWithRandom)
+        {
+            k = (AsymmetricKeyParameter)((ParametersWithRandom)parameters).getParameters();
+        }
+        else
+        {
+            k = (AsymmetricKeyParameter)parameters;
+        }
+
+        if (forSigning &amp;&amp; !k.isPrivate())
+        {
+            throw new IllegalArgumentException(&quot;signing requires private key&quot;);
+        }
+
+        if (!forSigning &amp;&amp; k.isPrivate())
+        {
+            throw new IllegalArgumentException(&quot;verification requires public key&quot;);
+        }
+
+        reset();
+
+        engine.init(forSigning, parameters);
+    }
+
+    /**
+     * update the internal digest with the byte b
+     */
+    public void update(
+        byte input)
+    {
+        digest.update(input);
+    }
+
+    /**
+     * update the internal digest with the byte array in
+     */
+    public void update(
+        byte[]  input,
+        int     inOff,
+        int     length)
+    {
+        digest.update(input, inOff, length);
+    }
+
+    /**
+     * Generate a signature for the message we've been loaded with using the key
+     * we were initialised with.
+     */
+    public byte[] generateSignature()
+        throws CryptoException, DataLengthException
+    {
+        if (!forSigning)
+        {
+            throw new IllegalStateException(&quot;GenericSigner not initialised for signature generation.&quot;);
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        return engine.processBlock(hash, 0, hash.length);
+    }
+
+    /**
+     * return true if the internal state represents the signature described in
+     * the passed in array.
+     */
+    public boolean verifySignature(
+        byte[] signature)
+    {
+        if (forSigning)
+        {
+            throw new IllegalStateException(&quot;GenericSigner not initialised for verification&quot;);
+        }
+
+        byte[] hash = new byte[digest.getDigestSize()];
+        digest.doFinal(hash, 0);
+
+        try
+        {
+            byte[] sig = engine.processBlock(signature, 0, signature.length);
+
+            return Arrays.constantTimeAreEqual(sig, hash);
+        }
+        catch (Exception e)
+        {
+            return false;
+        }
+    }
+
+    public void reset()
+    {
+        digest.reset();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/signers/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/signers/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/signers/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Basic signers.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/AlertDescription.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/AlertDescription.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,46 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.2
+ */
+public class AlertDescription
+{
+    public static final short close_notify = 0;
+    public static final short unexpected_message = 10;
+    public static final short bad_record_mac = 20;
+    public static final short decryption_failed = 21;
+    public static final short record_overflow = 22;
+    public static final short decompression_failure = 30;
+    public static final short handshake_failure = 40;
+    /* 41 is not defined, for historical reasons */
+    public static final short bad_certificate = 42;
+    public static final short unsupported_certificate = 43;
+    public static final short certificate_revoked = 44;
+    public static final short certificate_expired = 45;
+    public static final short certificate_unknown = 46;
+    public static final short illegal_parameter = 47;
+    public static final short unknown_ca = 48;
+    public static final short access_denied = 49;
+    public static final short decode_error = 50;
+    public static final short decrypt_error = 51;
+    public static final short export_restriction = 60;
+    public static final short protocol_version = 70;
+    public static final short insufficient_security = 71;
+    public static final short internal_error = 80;
+    public static final short user_canceled = 90;
+    public static final short no_renegotiation = 100;
+
+    /*
+     *  RFC 3546
+     */
+    public static final short unsupported_extension = 110;
+    public static final short certificate_unobtainable = 111;
+    public static final short unrecognized_name = 112;
+    public static final short bad_certificate_status_response = 113;
+    public static final short bad_certificate_hash_value = 114;
+
+    /*
+     *  RFC 4279
+     */
+    public static final short unknown_psk_identity = 115;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/AlertLevel.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/AlertLevel.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.2
+ */
+public class AlertLevel
+{
+    public static final short warning = 1;
+    public static final short fatal = 2;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/AlwaysValidVerifyer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+
+/**
+ * A certificate verifyer, that will always return true.
+ * 
+ * &lt;pre&gt;
+ * DO NOT USE THIS FILE UNLESS YOU KNOW EXACTLY WHAT YOU ARE DOING.
+ * &lt;/pre&gt;
+ * 
+ * @deprecated Perform certificate verification in TlsAuthentication implementation
+ */
+public class AlwaysValidVerifyer implements CertificateVerifyer
+{
+    /**
+     * Return true.
+     * 
+     * @see org.bouncycastle.crypto.tls.CertificateVerifyer#isValid(org.bouncycastle.asn1.x509.X509CertificateStructure[])
+     */
+    public boolean isValid(X509CertificateStructure[] certs)
+    {
+        return true;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ByteQueue.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ByteQueue.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,123 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * A queue for bytes. This file could be more optimized.
+ */
+public class ByteQueue
+{
+    /**
+     * @return The smallest number which can be written as 2^x which is bigger than i.
+     */
+    public static final int nextTwoPow(int i)
+    {
+        /*
+         * This code is based of a lot of code I found on the Internet which mostly
+         * referenced a book called &quot;Hacking delight&quot;.
+         */
+        i |= (i &gt;&gt; 1);
+        i |= (i &gt;&gt; 2);
+        i |= (i &gt;&gt; 4);
+        i |= (i &gt;&gt; 8);
+        i |= (i &gt;&gt; 16);
+        return i + 1;
+    }
+
+    /**
+     * The initial size for our buffer.
+     */
+    private static final int INITBUFSIZE = 1024;
+
+    /**
+     * The buffer where we store our data.
+     */
+    private byte[] databuf = new byte[ByteQueue.INITBUFSIZE];
+
+    /**
+     * How many bytes at the beginning of the buffer are skipped.
+     */
+    private int skipped = 0;
+
+    /**
+     * How many bytes in the buffer are valid data.
+     */
+    private int available = 0;
+
+    /**
+     * Read data from the buffer.
+     * 
+     * @param buf The buffer where the read data will be copied to.
+     * @param offset How many bytes to skip at the beginning of buf.
+     * @param len How many bytes to read at all.
+     * @param skip How many bytes from our data to skip.
+     */
+    public void read(byte[] buf, int offset, int len, int skip)
+    {
+        if ((available - skip) &lt; len)
+        {
+            throw new TlsRuntimeException(&quot;Not enough data to read&quot;);
+        }
+        if ((buf.length - offset) &lt; len)
+        {
+            throw new TlsRuntimeException(&quot;Buffer size of &quot; + buf.length
+                + &quot; is too small for a read of &quot; + len + &quot; bytes&quot;);
+        }
+        System.arraycopy(databuf, skipped + skip, buf, offset, len);
+        return;
+    }
+
+    /**
+     * Add some data to our buffer.
+     * 
+     * @param data A byte-array to read data from.
+     * @param offset How many bytes to skip at the beginning of the array.
+     * @param len How many bytes to read from the array.
+     */
+    public void addData(byte[] data, int offset, int len)
+    {
+        if ((skipped + available + len) &gt; databuf.length)
+        {
+            byte[] tmp = new byte[ByteQueue.nextTwoPow(data.length)];
+            System.arraycopy(databuf, skipped, tmp, 0, available);
+            skipped = 0;
+            databuf = tmp;
+        }
+        System.arraycopy(data, offset, databuf, skipped + available, len);
+        available += len;
+    }
+
+    /**
+     * Remove some bytes from our data from the beginning.
+     * 
+     * @param i How many bytes to remove.
+     */
+    public void removeData(int i)
+    {
+        if (i &gt; available)
+        {
+            throw new TlsRuntimeException(&quot;Cannot remove &quot; + i + &quot; bytes, only got &quot; + available);
+        }
+
+        /*
+         * Skip the data.
+         */
+        available -= i;
+        skipped += i;
+
+        /*
+         * If more than half of our data is skipped, we will move the data in the buffer.
+         */
+        if (skipped &gt; (databuf.length / 2))
+        {
+            System.arraycopy(databuf, skipped, databuf, 0, available);
+            skipped = 0;
+        }
+    }
+
+    /**
+     * @return The number of bytes which are available in this buffer.
+     */
+    public int size()
+    {
+        return available;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/Certificate.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/Certificate.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/Certificate.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/Certificate.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/Certificate.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,122 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+
+/**
+ * A representation for a certificate chain as used by a tls server.
+ */
+public class Certificate
+{
+    public static final Certificate EMPTY_CHAIN = new Certificate(new X509CertificateStructure[0]);
+
+    /**
+     * The certificates.
+     */
+    protected X509CertificateStructure[] certs;
+
+    /**
+     * Parse the ServerCertificate message.
+     * 
+     * @param is The stream where to parse from.
+     * @return A Certificate object with the certs, the server has sended.
+     * @throws IOException If something goes wrong during parsing.
+     */
+    protected static Certificate parse(InputStream is) throws IOException
+    {
+        X509CertificateStructure[] certs;
+        int left = TlsUtils.readUint24(is);
+        if (left == 0)
+        {
+            return EMPTY_CHAIN;
+        }
+        Vector tmp = new Vector();
+        while (left &gt; 0)
+        {
+            int size = TlsUtils.readUint24(is);
+            left -= 3 + size;
+            byte[] buf = new byte[size];
+            TlsUtils.readFully(buf, is);
+            ByteArrayInputStream bis = new ByteArrayInputStream(buf);
+            ASN1InputStream ais = new ASN1InputStream(bis);
+            DERObject o = ais.readObject();
+            tmp.addElement(X509CertificateStructure.getInstance(o));
+            if (bis.available() &gt; 0)
+            {
+                throw new IllegalArgumentException(
+                    &quot;Sorry, there is garbage data left after the certificate&quot;);
+            }
+        }
+        certs = new X509CertificateStructure[tmp.size()];
+        for (int i = 0; i &lt; tmp.size(); i++)
+        {
+            certs[i] = (X509CertificateStructure)tmp.elementAt(i);
+        }
+        return new Certificate(certs);
+    }
+
+    /**
+     * Encodes version of the ClientCertificate message
+     * 
+     * @param os stream to write the message to
+     * @throws IOException If something goes wrong
+     */
+    protected void encode(OutputStream os) throws IOException
+    {
+        Vector encCerts = new Vector();
+        int totalSize = 0;
+        for (int i = 0; i &lt; this.certs.length; ++i)
+        {
+            byte[] encCert = certs[i].getEncoded(ASN1Encodable.DER);
+            encCerts.addElement(encCert);
+            totalSize += encCert.length + 3;
+        }
+
+        TlsUtils.writeUint24(totalSize + 3, os);
+        TlsUtils.writeUint24(totalSize, os);
+
+        for (int i = 0; i &lt; encCerts.size(); ++i)
+        {
+            byte[] encCert = (byte[])encCerts.elementAt(i);
+            TlsUtils.writeOpaque24(encCert, os);
+        }
+    }
+
+    /**
+     * Private constructor from a cert array.
+     * 
+     * @param certs The certs the chain should contain.
+     */
+    public Certificate(X509CertificateStructure[] certs)
+    {
+        if (certs == null)
+        {
+            throw new IllegalArgumentException(&quot;'certs' cannot be null&quot;);
+        }
+
+        this.certs = certs;
+    }
+
+    /**
+     * @return An array which contains the certs, this chain contains.
+     */
+    public X509CertificateStructure[] getCerts()
+    {
+        X509CertificateStructure[] result = new X509CertificateStructure[certs.length];
+        System.arraycopy(certs, 0, result, 0, certs.length);
+        return result;
+    }
+
+    public boolean isEmpty()
+    {
+        return certs.length == 0;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CertificateRequest.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,28 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.util.Vector;
+
+public class CertificateRequest
+{
+    private short[] certificateTypes;
+    private Vector certificateAuthorities;
+
+    public CertificateRequest(short[] certificateTypes, Vector certificateAuthorities)
+    {
+        this.certificateTypes = certificateTypes;
+        this.certificateAuthorities = certificateAuthorities;
+    }
+
+    public short[] getCertificateTypes()
+    {
+        return certificateTypes;
+    }
+
+    /**
+     * @return Vector of X500Name
+     */
+    public Vector getCertificateAuthorities()
+    {
+        return certificateAuthorities;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CertificateVerifyer.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+
+/**
+ * This should be implemented by any class which can find out, if a given certificate
+ * chain is being accepted by an client.
+ * 
+ * @deprecated Perform certificate verification in TlsAuthentication implementation
+ */
+public interface CertificateVerifyer
+{
+    /**
+     * @param certs The certs, which are part of the chain.
+     * @return True, if the chain is accepted, false otherwise.
+     */
+    public boolean isValid(X509CertificateStructure[] certs);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CipherSuite.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CipherSuite.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,135 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 A.5
+ */
+public class CipherSuite
+{
+    public static final int TLS_NULL_WITH_NULL_NULL = 0x0000;
+    public static final int TLS_RSA_WITH_NULL_MD5 = 0x0001;
+    public static final int TLS_RSA_WITH_NULL_SHA = 0x0002;
+    public static final int TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 0x0003;
+    public static final int TLS_RSA_WITH_RC4_128_MD5 = 0x0004;
+    public static final int TLS_RSA_WITH_RC4_128_SHA = 0x0005;
+    public static final int TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 0x0006;
+    public static final int TLS_RSA_WITH_IDEA_CBC_SHA = 0x0007;
+    public static final int TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0008;
+    public static final int TLS_RSA_WITH_DES_CBC_SHA = 0x0009;
+    public static final int TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000A;
+    public static final int TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x000B;
+    public static final int TLS_DH_DSS_WITH_DES_CBC_SHA = 0x000C;
+    public static final int TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 0x000D;
+    public static final int TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x000E;
+    public static final int TLS_DH_RSA_WITH_DES_CBC_SHA = 0x000F;
+    public static final int TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 0x0010;
+    public static final int TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x0011;
+    public static final int TLS_DHE_DSS_WITH_DES_CBC_SHA = 0x0012;
+    public static final int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 0x0013;
+    public static final int TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0014;
+    public static final int TLS_DHE_RSA_WITH_DES_CBC_SHA = 0x0015;
+    public static final int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016;
+    public static final int TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 0x0017;
+    public static final int TLS_DH_anon_WITH_RC4_128_MD5 = 0x0018;
+    public static final int TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 0x0019;
+    public static final int TLS_DH_anon_WITH_DES_CBC_SHA = 0x001A;
+    public static final int TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 0x001B;
+
+    /*
+     * RFC 3268
+     */
+    public static final int TLS_RSA_WITH_AES_128_CBC_SHA = 0x002F;
+    public static final int TLS_DH_DSS_WITH_AES_128_CBC_SHA = 0x0030;
+    public static final int TLS_DH_RSA_WITH_AES_128_CBC_SHA = 0x0031;
+    public static final int TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 0x0032;
+    public static final int TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033;
+    public static final int TLS_DH_anon_WITH_AES_128_CBC_SHA = 0x0034;
+    public static final int TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035;
+    public static final int TLS_DH_DSS_WITH_AES_256_CBC_SHA = 0x0036;
+    public static final int TLS_DH_RSA_WITH_AES_256_CBC_SHA = 0x0037;
+    public static final int TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 0x0038;
+    public static final int TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039;
+    public static final int TLS_DH_anon_WITH_AES_256_CBC_SHA = 0x003A;
+
+    /*
+     * RFC 4279
+     */
+    public static final int TLS_PSK_WITH_RC4_128_SHA = 0x008A;
+    public static final int TLS_PSK_WITH_3DES_EDE_CBC_SHA = 0x008B;
+    public static final int TLS_PSK_WITH_AES_128_CBC_SHA = 0x008C;
+    public static final int TLS_PSK_WITH_AES_256_CBC_SHA = 0x008D;
+    public static final int TLS_DHE_PSK_WITH_RC4_128_SHA = 0x008E;
+    public static final int TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 0x008F;
+    public static final int TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 0x0090;
+    public static final int TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 0x0091;
+    public static final int TLS_RSA_PSK_WITH_RC4_128_SHA = 0x0092;
+    public static final int TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 0x0093;
+    public static final int TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 0x0094;
+    public static final int TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 0x0095;
+
+    /*
+     * RFC 4492
+     */
+    public static final int TLS_ECDH_ECDSA_WITH_NULL_SHA = 0xC001;
+    public static final int TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xC002;
+    public static final int TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC003;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xC004;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xC005;
+    public static final int TLS_ECDHE_ECDSA_WITH_NULL_SHA = 0xC006;
+    public static final int TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xC007;
+    public static final int TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC008;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00A;
+    public static final int TLS_ECDH_RSA_WITH_NULL_SHA = 0xC00B;
+    public static final int TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xC00C;
+    public static final int TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xC00D;
+    public static final int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xC00E;
+    public static final int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xC00F;
+    public static final int TLS_ECDHE_RSA_WITH_NULL_SHA = 0xC010;
+    public static final int TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xC011;
+    public static final int TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xC012;
+    public static final int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013;
+    public static final int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014;
+    public static final int TLS_ECDH_anon_WITH_NULL_SHA = 0xC015;
+    public static final int TLS_ECDH_anon_WITH_RC4_128_SHA = 0xC016;
+    public static final int TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = 0xC017;
+    public static final int TLS_ECDH_anon_WITH_AES_128_CBC_SHA = 0xC018;
+    public static final int TLS_ECDH_anon_WITH_AES_256_CBC_SHA = 0xC019;
+
+    /*
+     * RFC 5054
+     */
+    public static final int TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 0xC01A;
+    public static final int TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 0xC01B;
+    public static final int TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 0xC01C;
+    public static final int TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 0xC01D;
+    public static final int TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 0xC01E;
+    public static final int TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 0xC01F;
+    public static final int TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 0xC020;
+    public static final int TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 0xC021;
+    public static final int TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 0xC022;
+
+    /*
+     * RFC 5289
+     */
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC025;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC026;
+    public static final int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027;
+    public static final int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028;
+    public static final int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xC029;
+    public static final int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xC02A;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02B;
+    public static final int TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02C;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02D;
+    public static final int TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02E;
+    public static final int TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F;
+    public static final int TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030;
+    public static final int TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xC031;
+    public static final int TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xC032;
+
+    /*
+     * RFC 5746
+     */
+    public static final int TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00FF;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ClientCertificateType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.4.4
+ */
+public class ClientCertificateType
+{
+    public static final short rsa_sign = 1;
+    public static final short dss_sign = 2;
+    public static final short rsa_fixed_dh = 3;
+    public static final short dss_fixed_dh = 4;
+
+    /*
+     * RFC 4492 5.5
+     */
+    public static final short ecdsa_sign = 64;
+    public static final short rsa_fixed_ecdh = 65;
+    public static final short ecdsa_fixed_ecdh = 66;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CombinedHash.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CombinedHash.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,80 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.digests.MD5Digest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+
+/**
+ * A combined hash, which implements md5(m) || sha1(m).
+ */
+class CombinedHash implements Digest
+{
+    private MD5Digest md5;
+    private SHA1Digest sha1;
+
+    CombinedHash()
+    {
+        this.md5 = new MD5Digest();
+        this.sha1 = new SHA1Digest();
+    }
+
+    CombinedHash(CombinedHash t)
+    {
+        this.md5 = new MD5Digest(t.md5);
+        this.sha1 = new SHA1Digest(t.sha1);
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#getAlgorithmName()
+     */
+    public String getAlgorithmName()
+    {
+        return md5.getAlgorithmName() + &quot; and &quot; + sha1.getAlgorithmName() + &quot; for TLS 1.0&quot;;
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#getDigestSize()
+     */
+    public int getDigestSize()
+    {
+        return 16 + 20;
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#update(byte)
+     */
+    public void update(byte in)
+    {
+        md5.update(in);
+        sha1.update(in);
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#update(byte[],int,int)
+     */
+    public void update(byte[] in, int inOff, int len)
+    {
+        md5.update(in, inOff, len);
+        sha1.update(in, inOff, len);
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#doFinal(byte[],int)
+     */
+    public int doFinal(byte[] out, int outOff)
+    {
+        int i1 = md5.doFinal(out, outOff);
+        int i2 = sha1.doFinal(out, outOff + 16);
+        return i1 + i2;
+    }
+
+    /**
+     * @see org.bouncycastle.crypto.Digest#reset()
+     */
+    public void reset()
+    {
+        md5.reset();
+        sha1.reset();
+    }
+
+}

Added: trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/CompressionMethod.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 6.1
+ */
+public class CompressionMethod
+{
+    public static final short NULL = 0;
+
+    /*
+     * RFC 3749 2
+     */
+    public static final short DEFLATE = 1;
+
+    /*
+     * Values from 224 decimal (0xE0) through 255 decimal (0xFF)
+     * inclusive are reserved for private use.
+     */
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ContentType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ContentType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ContentType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ContentType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ContentType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 6.2.1
+ */
+public class ContentType
+{
+    public static final short change_cipher_spec = 20;
+    public static final short alert = 21;
+    public static final short handshake = 22;
+    public static final short application_data = 23;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/DefaultTlsCipherFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,70 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.digests.MD5Digest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+import org.bouncycastle.crypto.digests.SHA256Digest;
+import org.bouncycastle.crypto.digests.SHA384Digest;
+import org.bouncycastle.crypto.engines.AESFastEngine;
+import org.bouncycastle.crypto.engines.DESedeEngine;
+import org.bouncycastle.crypto.modes.CBCBlockCipher;
+
+public class DefaultTlsCipherFactory implements TlsCipherFactory
+{
+    public TlsCipher createCipher(TlsClientContext context, int encryptionAlgorithm, int digestAlgorithm) throws IOException
+    {
+        switch (encryptionAlgorithm)
+        {
+            case EncryptionAlgorithm._3DES_EDE_CBC:
+                return createDESedeCipher(context, 24, digestAlgorithm);
+            case EncryptionAlgorithm.AES_128_CBC:
+                return createAESCipher(context, 16, digestAlgorithm);
+            case EncryptionAlgorithm.AES_256_CBC:
+                return createAESCipher(context, 32, digestAlgorithm);
+            default:
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    protected TlsCipher createAESCipher(TlsClientContext context, int cipherKeySize, int digestAlgorithm) throws IOException
+    {
+        return new TlsBlockCipher(context, createAESBlockCipher(),
+            createAESBlockCipher(), createDigest(digestAlgorithm), createDigest(digestAlgorithm), cipherKeySize);
+    }
+
+    protected TlsCipher createDESedeCipher(TlsClientContext context, int cipherKeySize, int digestAlgorithm) throws IOException
+    {
+        return new TlsBlockCipher(context, createDESedeBlockCipher(),
+            createDESedeBlockCipher(), createDigest(digestAlgorithm), createDigest(digestAlgorithm), cipherKeySize);
+    }
+
+    protected BlockCipher createAESBlockCipher()
+    {
+        return new CBCBlockCipher(new AESFastEngine());
+    }
+
+    protected BlockCipher createDESedeBlockCipher()
+    {
+        return new CBCBlockCipher(new DESedeEngine());
+    }
+
+    protected Digest createDigest(int digestAlgorithm) throws IOException
+    {
+        switch (digestAlgorithm)
+        {
+            case DigestAlgorithm.MD5:
+                return new MD5Digest();
+            case DigestAlgorithm.SHA:
+                return new SHA1Digest();
+            case DigestAlgorithm.SHA256:
+                return new SHA256Digest();
+            case DigestAlgorithm.SHA384:
+                return new SHA384Digest();
+            default:
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/DefaultTlsClient.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,238 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+
+public abstract class DefaultTlsClient implements TlsClient
+{
+    protected TlsCipherFactory cipherFactory;
+
+    protected TlsClientContext context;
+
+    protected int selectedCipherSuite;
+    protected int selectedCompressionMethod;
+
+    public DefaultTlsClient()
+    {
+        this(new DefaultTlsCipherFactory());
+    }
+
+    public DefaultTlsClient(TlsCipherFactory cipherFactory)
+    {
+        this.cipherFactory = cipherFactory;
+    }
+
+    public void init(TlsClientContext context)
+    {
+        this.context = context;
+    }
+
+    public int[] getCipherSuites()
+    {
+        return new int[] {
+            CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA,
+            CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+            CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+        };
+    }
+
+    public Hashtable getClientExtensions()
+    {
+        return null;
+    }
+
+    public short[] getCompressionMethods()
+    {
+        return new short[] { CompressionMethod.NULL };
+    }
+
+    public void notifySessionID(byte[] sessionID)
+    {
+        // Currently ignored 
+    }
+
+    public void notifySelectedCipherSuite(int selectedCipherSuite)
+    {
+        this.selectedCipherSuite = selectedCipherSuite;
+    }
+
+    public void notifySelectedCompressionMethod(short selectedCompressionMethod)
+    {
+        this.selectedCompressionMethod = selectedCompressionMethod;
+    }
+
+    public void notifySecureRenegotiation(boolean secureRenegotiation) throws IOException
+    {
+        if (!secureRenegotiation)
+        {
+            /*
+             * RFC 5746 3.4. If the extension is not present, the server does not support
+             * secure renegotiation; set secure_renegotiation flag to FALSE. In this case,
+             * some clients may want to terminate the handshake instead of continuing; see
+             * Section 4.1 for discussion.
+             */
+//            throw new TlsFatalAlert(AlertDescription.handshake_failure);
+        }
+    }
+
+    public void processServerExtensions(Hashtable serverExtensions)
+    {
+    }
+
+    public TlsKeyExchange getKeyExchange() throws IOException
+    {
+        switch (selectedCipherSuite)
+        {
+            case CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA:
+                return createRSAKeyExchange();
+
+            case CipherSuite.TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_256_CBC_SHA:
+                return createDHKeyExchange(KeyExchangeAlgorithm.DH_DSS);
+
+            case CipherSuite.TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_256_CBC_SHA:
+                return createDHKeyExchange(KeyExchangeAlgorithm.DH_RSA);
+
+            case CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA:
+                return createDHEKeyExchange(KeyExchangeAlgorithm.DHE_DSS);
+
+            case CipherSuite.TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
+                return createDHEKeyExchange(KeyExchangeAlgorithm.DHE_RSA);
+
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
+                return createECDHKeyExchange(KeyExchangeAlgorithm.ECDH_ECDSA);
+
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
+                return createECDHEKeyExchange(KeyExchangeAlgorithm.ECDHE_ECDSA);
+
+            case CipherSuite.TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
+                return createECDHKeyExchange(KeyExchangeAlgorithm.ECDH_RSA);
+
+            case CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
+                return createECDHEKeyExchange(KeyExchangeAlgorithm.ECDHE_RSA);
+
+            default:
+                /*
+                 * Note: internal error here; the TlsProtocolHandler verifies that the
+                 * server-selected cipher suite was in the list of client-offered cipher
+                 * suites, so if we now can't produce an implementation, we shouldn't have
+                 * offered it!
+                 */
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public TlsCompression getCompression() throws IOException
+    {
+        switch (selectedCompressionMethod)
+        {
+            case CompressionMethod.NULL:
+                return new TlsNullCompression();
+
+            default:
+                /*
+                 * Note: internal error here; the TlsProtocolHandler verifies that the
+                 * server-selected compression method was in the list of client-offered compression
+                 * methods, so if we now can't produce an implementation, we shouldn't have
+                 * offered it!
+                 */
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public TlsCipher getCipher() throws IOException
+    {
+        switch (selectedCipherSuite)
+        {
+            case CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
+                return cipherFactory.createCipher(context, EncryptionAlgorithm._3DES_EDE_CBC, DigestAlgorithm.SHA);
+
+            case CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
+                return cipherFactory.createCipher(context, EncryptionAlgorithm.AES_128_CBC, DigestAlgorithm.SHA);
+
+            case CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DH_DSS_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DH_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
+            case CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
+                return cipherFactory.createCipher(context, EncryptionAlgorithm.AES_256_CBC, DigestAlgorithm.SHA);
+
+            default:
+                /*
+                 * Note: internal error here; the TlsProtocolHandler verifies that the
+                 * server-selected cipher suite was in the list of client-offered cipher
+                 * suites, so if we now can't produce an implementation, we shouldn't have
+                 * offered it!
+                 */
+                throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    protected TlsKeyExchange createDHKeyExchange(int keyExchange)
+    {
+        return new TlsDHKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createDHEKeyExchange(int keyExchange)
+    {
+        return new TlsDHEKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createECDHKeyExchange(int keyExchange)
+    {
+        return new TlsECDHKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createECDHEKeyExchange(int keyExchange)
+    {
+        return new TlsECDHEKeyExchange(context, keyExchange);
+    }
+
+    protected TlsKeyExchange createRSAKeyExchange()
+    {
+        return new TlsRSAKeyExchange(context);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/DigestAlgorithm.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.crypto.tls;
+
+public class DigestAlgorithm
+{
+    /*
+     * Note that the values here are implementation-specific and arbitrary.
+     * It is recommended not to depend on the particular values (e.g. serialization).
+     */
+    public static final int NULL = 0;
+    public static final int MD5 = 1;
+    public static final int SHA = 2;
+
+    /*
+     * RFC 5289
+     */
+    public static final int SHA256 = 3;
+    public static final int SHA384 = 4;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ECCurveType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ECCurveType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,28 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 4492 5.4
+ */
+public class ECCurveType
+{
+    /**
+     * Indicates the elliptic curve domain parameters are conveyed verbosely, and the
+     * underlying finite field is a prime field.
+     */
+    public static final short explicit_prime = 1;
+
+    /**
+     * Indicates the elliptic curve domain parameters are conveyed verbosely, and the
+     * underlying finite field is a characteristic-2 field.
+     */
+    public static final short explicit_char2 = 2;
+
+    /**
+     * Indicates that a named curve is used. This option SHOULD be used when applicable.
+     */
+    public static final short named_curve = 3;
+
+    /*
+     * Values 248 through 255 are reserved for private use.
+     */
+}

Added: trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/EncryptionAlgorithm.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,29 @@
+package org.bouncycastle.crypto.tls;
+
+public class EncryptionAlgorithm
+{
+    /*
+     * Note that the values here are implementation-specific and arbitrary.
+     * It is recommended not to depend on the particular values (e.g. serialization).
+     */
+    public static final int NULL = 0;
+    public static final int RC4_40 = 1;
+    public static final int RC4_128 = 2;
+    public static final int RC2_CBC_40 = 3;
+    public static final int IDEA_CBC = 4;
+    public static final int DES40_CBC = 5;
+    public static final int DES_CBC = 6;
+    public static final int _3DES_EDE_CBC = 7;
+
+    /*
+     * RFC 3268
+     */
+    public static final int AES_128_CBC = 8;
+    public static final int AES_256_CBC = 9;
+
+    /*
+     * RFC 5289
+     */
+    public static final int AES_128_GCM = 10;
+    public static final int AES_256_GCM = 11;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/ExtensionType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/ExtensionType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 4366 2.3
+ */
+public class ExtensionType
+{
+    public static final int server_name = 0;
+    public static final int max_fragment_length = 1;
+    public static final int client_certificate_url = 2;
+    public static final int trusted_ca_keys = 3;
+    public static final int truncated_hmac = 4;
+    public static final int status_request = 5;
+
+    /*
+     * RFC 4492
+     */
+    public static final int elliptic_curves = 10;
+    public static final int ec_point_formats = 11;
+
+    /*
+     * RFC 5054 2.8.1
+     */
+    public static final int srp = 12;
+
+    /*
+     * RFC 5746 6
+     */
+    public static final int renegotiation_info = 0xff01;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/HandshakeType.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/HandshakeType.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,18 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * RFC 2246 7.4
+ */
+public class HandshakeType
+{
+    public static final short hello_request = 0;
+    public static final short client_hello = 1;
+    public static final short server_hello = 2;
+    public static final short certificate = 11;
+    public static final short server_key_exchange = 12;
+    public static final short certificate_request = 13;
+    public static final short server_hello_done = 14;
+    public static final short certificate_verify = 15;
+    public static final short client_key_exchange = 16;
+    public static final short finished = 20;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/KeyExchangeAlgorithm.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,33 @@
+package org.bouncycastle.crypto.tls;
+
+public class KeyExchangeAlgorithm
+{
+    /*
+     * Note that the values here are implementation-specific and arbitrary.
+     * It is recommended not to depend on the particular values (e.g. serialization).
+     */
+    public static final int NULL = 0;
+    public static final int RSA = 1;
+    public static final int RSA_EXPORT = 2;
+    public static final int DHE_DSS = 3;
+    public static final int DHE_DSS_EXPORT = 4;
+    public static final int DHE_RSA = 5;
+    public static final int DHE_RSA_EXPORT = 6;
+    public static final int DH_DSS = 7;
+    public static final int DH_DSS_EXPORT = 8;
+    public static final int DH_RSA = 9;
+    public static final int DH_RSA_EXPORT = 10;
+    public static final int DH_anon = 11;
+    public static final int DH_anon_EXPORT = 12;
+    public static final int PSK = 13;
+    public static final int DHE_PSK = 14;
+    public static final int RSA_PSK = 15;
+    public static final int ECDH_ECDSA = 16;
+    public static final int ECDHE_ECDSA = 17;
+    public static final int ECDH_RSA = 18;
+    public static final int ECDHE_RSA = 19;
+    public static final int ECDH_anon = 20;
+    public static final int SRP = 21;
+    public static final int SRP_DSS = 22;
+    public static final int SRP_RSA = 23;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/LegacyTlsAuthentication.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,32 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+/**
+ * A temporary class to wrap old CertificateVerifyer stuff for new TlsAuthentication
+ * 
+ * @deprecated
+ */
+public class LegacyTlsAuthentication implements TlsAuthentication
+{
+    protected CertificateVerifyer verifyer;
+
+    public LegacyTlsAuthentication(CertificateVerifyer verifyer)
+    {
+        this.verifyer = verifyer;
+    }
+
+    public void notifyServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        if (!this.verifyer.isValid(serverCertificate.getCerts()))
+        {
+            throw new TlsFatalAlert(AlertDescription.user_canceled);
+        }
+    }
+
+    public TlsCredentials getClientCredentials(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        return null;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/LegacyTlsClient.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,29 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+/**
+ * A temporary class to use LegacyTlsAuthentication
+ * 
+ * @deprecated
+ */
+public class LegacyTlsClient extends DefaultTlsClient
+{
+    /** @deprecated */
+    protected CertificateVerifyer verifyer;
+
+    /**
+     * @deprecated
+     */
+    public LegacyTlsClient(CertificateVerifyer verifyer)
+    {
+        super();
+
+        this.verifyer = verifyer;
+    }
+
+    public TlsAuthentication getAuthentication() throws IOException
+    {
+        return new LegacyTlsAuthentication(verifyer);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/NamedCurve.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/NamedCurve.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,100 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.asn1.sec.SECNamedCurves;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+
+/**
+ * RFC 4492 5.1.1
+ * 
+ * The named curves defined here are those specified in SEC 2 [13]. Note that many of
+ * these curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11]. Values 0xFE00
+ * through 0xFEFF are reserved for private use. Values 0xFF01 and 0xFF02 indicate that the
+ * client supports arbitrary prime and characteristic-2 curves, respectively (the curve
+ * parameters must be encoded explicitly in ECParameters).
+ */
+public class NamedCurve
+{
+    public static final int sect163k1 = 1;
+    public static final int sect163r1 = 2;
+    public static final int sect163r2 = 3;
+    public static final int sect193r1 = 4;
+    public static final int sect193r2 = 5;
+    public static final int sect233k1 = 6;
+    public static final int sect233r1 = 7;
+    public static final int sect239k1 = 8;
+    public static final int sect283k1 = 9;
+    public static final int sect283r1 = 10;
+    public static final int sect409k1 = 11;
+    public static final int sect409r1 = 12;
+    public static final int sect571k1 = 13;
+    public static final int sect571r1 = 14;
+    public static final int secp160k1 = 15;
+    public static final int secp160r1 = 16;
+    public static final int secp160r2 = 17;
+    public static final int secp192k1 = 18;
+    public static final int secp192r1 = 19;
+    public static final int secp224k1 = 20;
+    public static final int secp224r1 = 21;
+    public static final int secp256k1 = 22;
+    public static final int secp256r1 = 23;
+    public static final int secp384r1 = 24;
+    public static final int secp521r1 = 25;
+
+    /*
+     * reserved (0xFE00..0xFEFF)
+     */
+
+    public static final int arbitrary_explicit_prime_curves = 0xFF01;
+    public static final int arbitrary_explicit_char2_curves = 0xFF02;
+
+    private static final String[] curveNames = new String[] {
+        &quot;sect163k1&quot;,
+        &quot;sect163r1&quot;,
+        &quot;sect163r2&quot;,
+        &quot;sect193r1&quot;,
+        &quot;sect193r2&quot;,
+        &quot;sect233k1&quot;,
+        &quot;sect233r1&quot;,
+        &quot;sect239k1&quot;,
+        &quot;sect283k1&quot;,
+        &quot;sect283r1&quot;,
+        &quot;sect409k1&quot;,
+        &quot;sect409r1&quot;,
+        &quot;sect571k1&quot;,
+        &quot;sect571r1&quot;,
+        &quot;secp160k1&quot;,
+        &quot;secp160r1&quot;,
+        &quot;secp160r2&quot;,
+        &quot;secp192k1&quot;,
+        &quot;secp192r1&quot;,
+        &quot;secp224k1&quot;,
+        &quot;secp224r1&quot;,
+        &quot;secp256k1&quot;,
+        &quot;secp256r1&quot;,
+        &quot;secp384r1&quot;,
+        &quot;secp521r1&quot;, };
+
+    static ECDomainParameters getECParameters(int namedCurve)
+    {
+        int index = namedCurve - 1;
+        if (index &lt; 0 || index &gt;= curveNames.length)
+        {
+            return null;
+        }
+
+        String curveName = curveNames[index];
+
+        // Lazily created the first time a particular curve is accessed
+        X9ECParameters ecP = SECNamedCurves.getByName(curveName);
+
+        if (ecP == null)
+        {
+            return null;
+        }
+
+        // It's a bit inefficient to do this conversion every time
+        return new ECDomainParameters(ecP.getCurve(), ecP.getG(), ecP.getN(), ecP.getH(),
+            ecP.getSeed());
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/RecordStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/RecordStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/RecordStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/RecordStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,158 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+/**
+ * An implementation of the TLS 1.0 record layer.
+ */
+class RecordStream
+{
+    private TlsProtocolHandler handler;
+    private InputStream is;
+    private OutputStream os;
+    private CombinedHash hash;
+    private TlsCompression readCompression = null;
+    private TlsCompression writeCompression = null;
+    private TlsCipher readCipher = null;
+    private TlsCipher writeCipher = null;
+    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+
+    RecordStream(TlsProtocolHandler handler, InputStream is, OutputStream os)
+    {
+        this.handler = handler;
+        this.is = is;
+        this.os = os;
+        this.hash = new CombinedHash();
+        this.readCompression = new TlsNullCompression();
+        this.writeCompression = this.readCompression;
+        this.readCipher = new TlsNullCipher();
+        this.writeCipher = this.readCipher;
+    }
+
+    void clientCipherSpecDecided(TlsCompression tlsCompression, TlsCipher tlsCipher)
+    {
+        this.writeCompression = tlsCompression;
+        this.writeCipher = tlsCipher;
+    }
+
+    void serverClientSpecReceived()
+    {
+        this.readCompression = this.writeCompression;
+        this.readCipher = this.writeCipher;
+    }
+
+    public void readData() throws IOException
+    {
+        short type = TlsUtils.readUint8(is);
+        TlsUtils.checkVersion(is, handler);
+        int size = TlsUtils.readUint16(is);
+        byte[] buf = decodeAndVerify(type, is, size);
+        handler.processData(type, buf, 0, buf.length);
+    }
+
+    protected byte[] decodeAndVerify(short type, InputStream is, int len) throws IOException
+    {
+        byte[] buf = new byte[len];
+        TlsUtils.readFully(buf, is);
+        byte[] decoded = readCipher.decodeCiphertext(type, buf, 0, buf.length);
+
+        OutputStream cOut = readCompression.decompress(buffer);
+
+        if (cOut == buffer)
+        {
+            return decoded;
+        }
+
+        cOut.write(decoded, 0, decoded.length);
+        cOut.flush();
+        return getBufferContents();
+    }
+
+    protected void writeMessage(short type, byte[] message, int offset, int len) throws IOException
+    {
+        if (type == ContentType.handshake)
+        {
+            updateHandshakeData(message, offset, len);
+        }
+
+        OutputStream cOut = writeCompression.compress(buffer);
+
+        byte[] ciphertext;
+        if (cOut == buffer)
+        {
+            ciphertext = writeCipher.encodePlaintext(type, message, offset, len);
+        }
+        else
+        {
+            cOut.write(message, offset, len);
+            cOut.flush();
+            byte[] compressed = getBufferContents();
+            ciphertext = writeCipher.encodePlaintext(type, compressed, 0, compressed.length);
+        }
+
+        byte[] writeMessage = new byte[ciphertext.length + 5];
+        TlsUtils.writeUint8(type, writeMessage, 0);
+        TlsUtils.writeVersion(writeMessage, 1);
+        TlsUtils.writeUint16(ciphertext.length, writeMessage, 3);
+        System.arraycopy(ciphertext, 0, writeMessage, 5, ciphertext.length);
+        os.write(writeMessage);
+        os.flush();
+    }
+
+    void updateHandshakeData(byte[] message, int offset, int len)
+    {
+        hash.update(message, offset, len);
+    }
+
+    byte[] getCurrentHash()
+    {
+        return doFinal(new CombinedHash(hash));
+    }
+
+    protected void close() throws IOException
+    {
+        IOException e = null;
+        try
+        {
+            is.close();
+        }
+        catch (IOException ex)
+        {
+            e = ex;
+        }
+        try
+        {
+            os.close();
+        }
+        catch (IOException ex)
+        {
+            e = ex;
+        }
+        if (e != null)
+        {
+            throw e;
+        }
+    }
+
+    protected void flush() throws IOException
+    {
+        os.flush();
+    }
+
+    private byte[] getBufferContents()
+    {
+        byte[] contents = buffer.toByteArray();
+        buffer.reset();
+        return contents;
+    }
+
+    private static byte[] doFinal(CombinedHash ch)
+    {
+        byte[] bs = new byte[ch.getDigestSize()];
+        ch.doFinal(bs, 0);
+        return bs;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/SecurityParameters.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,23 @@
+package org.bouncycastle.crypto.tls;
+
+public class SecurityParameters
+{
+    byte[] clientRandom = null;
+    byte[] serverRandom = null;
+    byte[] masterSecret = null;
+
+    public byte[] getClientRandom()
+    {
+        return clientRandom;
+    }
+
+    public byte[] getServerRandom()
+    {
+        return serverRandom;
+    }
+
+    public byte[] getMasterSecret()
+    {
+        return masterSecret;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsAgreementCredentials.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+
+public interface TlsAgreementCredentials extends TlsCredentials
+{
+    byte[] generateAgreement(AsymmetricKeyParameter serverPublicKey) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsAuthentication.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,24 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsAuthentication
+{
+    /**
+     * Called by the protocol handler to report the server certificate
+     * Note: this method is responsible for certificate verification and validation
+     * 
+     * @param serverCertificate the server certificate received
+     * @throws IOException
+     */
+    void notifyServerCertificate(Certificate serverCertificate) throws IOException;
+
+    /**
+     * Return client credentials in response to server's certificate request
+     * 
+     * @param certificateRequest details of the certificate request
+     * @return a TlsCredentials object or null for no client authentication
+     * @throws IOException
+     */
+    TlsCredentials getClientCredentials(CertificateRequest certificateRequest) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsBlockCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,219 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.BlockCipher;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.params.KeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithIV;
+import org.bouncycastle.util.Arrays;
+
+/**
+ * A generic TLS 1.0 block cipher. This can be used for AES or 3DES for example.
+ */
+public class TlsBlockCipher implements TlsCipher
+{
+    protected TlsClientContext context;
+
+    protected BlockCipher encryptCipher;
+    protected BlockCipher decryptCipher;
+
+    protected TlsMac writeMac;
+    protected TlsMac readMac;
+
+    public TlsBlockCipher(TlsClientContext context, BlockCipher encryptCipher,
+        BlockCipher decryptCipher, Digest writeDigest, Digest readDigest, int cipherKeySize)
+    {
+        this.context = context;
+        this.encryptCipher = encryptCipher;
+        this.decryptCipher = decryptCipher;
+
+        int prfSize = (2 * cipherKeySize) + writeDigest.getDigestSize()
+            + readDigest.getDigestSize() + encryptCipher.getBlockSize()
+            + decryptCipher.getBlockSize();
+
+        SecurityParameters securityParameters = context.getSecurityParameters();
+
+        byte[] key_block = TlsUtils.PRF(securityParameters.masterSecret, &quot;key expansion&quot;,
+            TlsUtils.concat(securityParameters.serverRandom, securityParameters.clientRandom),
+            prfSize);
+
+        int offset = 0;
+
+        // Init MACs
+        writeMac = new TlsMac(writeDigest, key_block, offset, writeDigest.getDigestSize());
+        offset += writeDigest.getDigestSize();
+        readMac = new TlsMac(readDigest, key_block, offset, readDigest.getDigestSize());
+        offset += readDigest.getDigestSize();
+
+        // Init Ciphers
+        this.initCipher(true, encryptCipher, key_block, cipherKeySize, offset, offset
+            + (cipherKeySize * 2));
+        offset += cipherKeySize;
+        this.initCipher(false, decryptCipher, key_block, cipherKeySize, offset, offset
+            + cipherKeySize + encryptCipher.getBlockSize());
+
+    }
+
+    protected void initCipher(boolean forEncryption, BlockCipher cipher, byte[] key_block,
+        int key_size, int key_offset, int iv_offset)
+    {
+        KeyParameter key_parameter = new KeyParameter(key_block, key_offset, key_size);
+        ParametersWithIV parameters_with_iv = new ParametersWithIV(key_parameter, key_block,
+            iv_offset, cipher.getBlockSize());
+        cipher.init(forEncryption, parameters_with_iv);
+    }
+
+    public byte[] encodePlaintext(short type, byte[] plaintext, int offset, int len)
+    {
+        int blocksize = encryptCipher.getBlockSize();
+
+        // Add a random number of extra blocks worth of padding
+        int minPaddingSize = blocksize - ((len + writeMac.getSize() + 1) % blocksize);
+        int maxExtraPadBlocks = (255 - minPaddingSize) / blocksize;
+        int actualExtraPadBlocks = chooseExtraPadBlocks(context.getSecureRandom(), maxExtraPadBlocks);
+        int paddingsize = minPaddingSize + (actualExtraPadBlocks * blocksize);
+
+        int totalsize = len + writeMac.getSize() + paddingsize + 1;
+        byte[] outbuf = new byte[totalsize];
+        System.arraycopy(plaintext, offset, outbuf, 0, len);
+        byte[] mac = writeMac.calculateMac(type, plaintext, offset, len);
+        System.arraycopy(mac, 0, outbuf, len, mac.length);
+        int paddoffset = len + mac.length;
+        for (int i = 0; i &lt;= paddingsize; i++)
+        {
+            outbuf[i + paddoffset] = (byte)paddingsize;
+        }
+        for (int i = 0; i &lt; totalsize; i += blocksize)
+        {
+            encryptCipher.processBlock(outbuf, i, outbuf, i);
+        }
+        return outbuf;
+    }
+
+    public byte[] decodeCiphertext(short type, byte[] ciphertext, int offset, int len)
+        throws IOException
+    {
+        // TODO TLS 1.1 (RFC 4346) introduces an explicit IV
+
+        int minLength = readMac.getSize() + 1;
+        int blocksize = decryptCipher.getBlockSize();
+        boolean decrypterror = false;
+
+        /*
+         * ciphertext must be at least (macsize + 1) bytes long
+         */
+        if (len &lt; minLength)
+        {
+            throw new TlsFatalAlert(AlertDescription.decode_error);
+        }
+
+        /*
+         * ciphertext must be a multiple of blocksize
+         */
+        if (len % blocksize != 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.decryption_failed);
+        }
+
+        /*
+         * Decrypt all the ciphertext using the blockcipher
+         */
+        for (int i = 0; i &lt; len; i += blocksize)
+        {
+            decryptCipher.processBlock(ciphertext, i + offset, ciphertext, i + offset);
+        }
+
+        /*
+         * Check if padding is correct
+         */
+        int lastByteOffset = offset + len - 1;
+
+        byte paddingsizebyte = ciphertext[lastByteOffset];
+
+        // Note: interpret as unsigned byte
+        int paddingsize = paddingsizebyte &amp; 0xff;
+
+        int maxPaddingSize = len - minLength;
+        if (paddingsize &gt; maxPaddingSize)
+        {
+            decrypterror = true;
+            paddingsize = 0;
+        }
+        else
+        {
+            /*
+             * Now, check all the padding-bytes (constant-time comparison).
+             */
+            byte diff = 0;
+            for (int i = lastByteOffset - paddingsize; i &lt; lastByteOffset; ++i)
+            {
+                diff |= (ciphertext[i] ^ paddingsizebyte);
+            }
+            if (diff != 0)
+            {
+                /* Wrong padding */
+                decrypterror = true;
+                paddingsize = 0;
+            }
+        }
+
+        /*
+         * We now don't care if padding verification has failed or not, we will calculate
+         * the mac to give an attacker no kind of timing profile he can use to find out if
+         * mac verification failed or padding verification failed.
+         */
+        int plaintextlength = len - minLength - paddingsize;
+        byte[] calculatedMac = readMac.calculateMac(type, ciphertext, offset, plaintextlength);
+
+        /*
+         * Check all bytes in the mac (constant-time comparison).
+         */
+        byte[] decryptedMac = new byte[calculatedMac.length];
+        System.arraycopy(ciphertext, offset + plaintextlength, decryptedMac, 0,
+            calculatedMac.length);
+
+        if (!Arrays.constantTimeAreEqual(calculatedMac, decryptedMac))
+        {
+            decrypterror = true;
+        }
+
+        /*
+         * Now, it is safe to fail.
+         */
+        if (decrypterror)
+        {
+            throw new TlsFatalAlert(AlertDescription.bad_record_mac);
+        }
+
+        byte[] plaintext = new byte[plaintextlength];
+        System.arraycopy(ciphertext, offset, plaintext, 0, plaintextlength);
+        return plaintext;
+    }
+
+    protected int chooseExtraPadBlocks(SecureRandom r, int max)
+    {
+//        return r.nextInt(max + 1);
+
+        int x = r.nextInt();
+        int n = lowestBitSet(x);
+        return Math.min(n, max);
+    }
+
+    protected int lowestBitSet(int x)
+    {
+        if (x == 0)
+        {
+            return 32;
+        }
+
+        int n = 0;
+        while ((x &amp; 1) == 0)
+        {
+            ++n;
+            x &gt;&gt;= 1;
+        }
+        return n;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsCipher
+{
+    byte[] encodePlaintext(short type, byte[] plaintext, int offset, int len) throws IOException;
+
+    byte[] decodeCiphertext(short type, byte[] ciphertext, int offset, int len) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCipherFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,11 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsCipherFactory
+{
+    /**
+     * See enumeration classes EncryptionAlgorithm and DigestAlgorithm for appropriate argument values
+     */
+    TlsCipher createCipher(TlsClientContext context, int encryptionAlgorithm, int digestAlgorithm) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsClient.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClient.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsClient.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsClient.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,35 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.util.Hashtable;
+
+public interface TlsClient
+{
+    void init(TlsClientContext context);
+
+    int[] getCipherSuites();
+
+    short[] getCompressionMethods();
+
+    // Hashtable is (Integer -&gt; byte[])
+    Hashtable getClientExtensions() throws IOException;
+
+    void notifySessionID(byte[] sessionID);
+
+    void notifySelectedCipherSuite(int selectedCipherSuite);
+
+    void notifySelectedCompressionMethod(short selectedCompressionMethod);
+
+    void notifySecureRenegotiation(boolean secureNegotiation) throws IOException;
+
+    // Hashtable is (Integer -&gt; byte[])
+    void processServerExtensions(Hashtable serverExtensions);
+
+    TlsKeyExchange getKeyExchange() throws IOException;
+
+    TlsAuthentication getAuthentication() throws IOException;
+
+    TlsCompression getCompression() throws IOException;
+
+    TlsCipher getCipher() throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsClientContext.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,14 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+public interface TlsClientContext
+{
+    SecureRandom getSecureRandom();
+
+    SecurityParameters getSecurityParameters();
+
+    Object getUserObject();
+
+    void setUserObject(Object userObject);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsClientContextImpl.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+class TlsClientContextImpl implements TlsClientContext
+{
+    private SecureRandom secureRandom;
+    private SecurityParameters securityParameters;
+
+    private Object userObject = null;
+
+    TlsClientContextImpl(SecureRandom secureRandom, SecurityParameters securityParameters)
+    {
+        this.secureRandom = secureRandom;
+        this.securityParameters = securityParameters;
+    }
+
+    public SecureRandom getSecureRandom()
+    {
+        return secureRandom;
+    }
+
+    public SecurityParameters getSecurityParameters()
+    {
+        return securityParameters;
+    }
+
+    public Object getUserObject()
+    {
+        return userObject;
+    }
+
+    public void setUserObject(Object userObject)
+    {
+        this.userObject = userObject;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCompression.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCompression.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.OutputStream;
+
+public interface TlsCompression
+{
+    OutputStream compress(OutputStream output);
+
+    OutputStream decompress(OutputStream output);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsCredentials.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,6 @@
+package org.bouncycastle.crypto.tls;
+
+public interface TlsCredentials
+{
+    Certificate getCertificate();
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDHEKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,57 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.io.SignerInputStream;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+
+class TlsDHEKeyExchange extends TlsDHKeyExchange
+{
+    TlsDHEKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        super(context, keyExchange);
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        SecurityParameters securityParameters = context.getSecurityParameters();
+
+        Signer signer = initSigner(tlsSigner, securityParameters);
+        InputStream sigIn = new SignerInputStream(is, signer);
+
+        byte[] pBytes = TlsUtils.readOpaque16(sigIn);
+        byte[] gBytes = TlsUtils.readOpaque16(sigIn);
+        byte[] YsBytes = TlsUtils.readOpaque16(sigIn);
+
+        byte[] sigByte = TlsUtils.readOpaque16(is);
+        if (!signer.verifySignature(sigByte))
+        {
+            throw new TlsFatalAlert(AlertDescription.bad_certificate);
+        }
+
+        BigInteger p = new BigInteger(1, pBytes);
+        BigInteger g = new BigInteger(1, gBytes);
+        BigInteger Ys = new BigInteger(1, YsBytes);
+
+        this.dhAgreeServerPublicKey = validateDHPublicKey(new DHPublicKeyParameters(Ys,
+            new DHParameters(p, g)));
+    }
+
+    protected Signer initSigner(TlsSigner tlsSigner, SecurityParameters securityParameters)
+    {
+        Signer signer = tlsSigner.createVerifyer(this.serverPublicKey);
+        signer.update(securityParameters.clientRandom, 0, securityParameters.clientRandom.length);
+        signer.update(securityParameters.serverRandom, 0, securityParameters.serverRandom.length);
+        return signer;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDHKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,250 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.agreement.DHBasicAgreement;
+import org.bouncycastle.crypto.generators.DHBasicKeyPairGenerator;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.DHKeyGenerationParameters;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPrivateKeyParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.util.PublicKeyFactory;
+import org.bouncycastle.util.BigIntegers;
+
+/**
+ * TLS 1.0 DH key exchange.
+ */
+class TlsDHKeyExchange implements TlsKeyExchange
+{
+    protected static final BigInteger ONE = BigInteger.valueOf(1);
+    protected static final BigInteger TWO = BigInteger.valueOf(2);
+
+    protected TlsClientContext context;
+    protected int keyExchange;
+    protected TlsSigner tlsSigner;
+
+    protected AsymmetricKeyParameter serverPublicKey = null;
+    protected DHPublicKeyParameters dhAgreeServerPublicKey = null;
+    protected TlsAgreementCredentials agreementCredentials;
+    protected DHPrivateKeyParameters dhAgreeClientPrivateKey = null;
+
+    TlsDHKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        switch (keyExchange)
+        {
+            case KeyExchangeAlgorithm.DH_RSA:
+            case KeyExchangeAlgorithm.DH_DSS:
+                this.tlsSigner = null;
+                break;
+            case KeyExchangeAlgorithm.DHE_RSA:
+                this.tlsSigner = new TlsRSASigner();
+                break;
+            case KeyExchangeAlgorithm.DHE_DSS:
+                this.tlsSigner = new TlsDSSSigner();
+                break;
+            default:
+                throw new IllegalArgumentException(&quot;unsupported key exchange algorithm&quot;);
+        }
+
+        this.context = context;
+        this.keyExchange = keyExchange;
+    }
+
+    public void skipServerCertificate() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        X509CertificateStructure x509Cert = serverCertificate.certs[0];
+        SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();
+
+        try
+        {
+            this.serverPublicKey = PublicKeyFactory.createKey(keyInfo);
+        }
+        catch (RuntimeException e)
+        {
+            throw new TlsFatalAlert(AlertDescription.unsupported_certificate);
+        }
+
+        if (tlsSigner == null)
+        {
+            try
+            {
+                this.dhAgreeServerPublicKey = validateDHPublicKey((DHPublicKeyParameters)this.serverPublicKey);
+            }
+            catch (ClassCastException e)
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.keyAgreement);
+        }
+        else
+        {
+            if (!tlsSigner.isValidPublicKey(this.serverPublicKey))
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.digitalSignature);
+        }
+
+        // TODO 
+        /*
+         * Perform various checks per RFC2246 7.4.2: &quot;Unless otherwise specified, the
+         * signing algorithm for the certificate must be the same as the algorithm for the
+         * certificate key.&quot;
+         */
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        // OK
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i &lt; types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.rsa_fixed_dh:
+                case ClientCertificateType.dss_fixed_dh:
+                case ClientCertificateType.ecdsa_sign:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void skipClientCredentials() throws IOException
+    {
+        this.agreementCredentials = null;
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (clientCredentials instanceof TlsAgreementCredentials)
+        {
+            // TODO Validate client cert has matching parameters (see 'areCompatibleParameters')?
+
+            this.agreementCredentials = (TlsAgreementCredentials)clientCredentials;
+        }
+        else if (clientCredentials instanceof TlsSignerCredentials)
+        {
+            // OK
+        }
+        else
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public void generateClientKeyExchange(OutputStream os) throws IOException
+    {
+        /*
+         * RFC 2246 7.4.7.2 If the client certificate already contains a suitable
+         * Diffie-Hellman key, then Yc is implicit and does not need to be sent again. In
+         * this case, the Client Key Exchange message will be sent, but will be empty.
+         */
+        if (agreementCredentials != null)
+        {
+            TlsUtils.writeUint24(0, os);
+        }
+        else
+        {
+            generateEphemeralClientKeyExchange(dhAgreeServerPublicKey.getParameters(), os);
+        }
+    }
+
+    public byte[] generatePremasterSecret() throws IOException
+    {
+        if (agreementCredentials != null)
+        {
+            return agreementCredentials.generateAgreement(dhAgreeServerPublicKey);
+        }
+
+        return calculateDHBasicAgreement(dhAgreeServerPublicKey, dhAgreeClientPrivateKey);
+    }
+
+    protected boolean areCompatibleParameters(DHParameters a, DHParameters b)
+    {
+        return a.getP().equals(b.getP()) &amp;&amp; a.getG().equals(b.getG());
+    }
+
+    protected byte[] calculateDHBasicAgreement(DHPublicKeyParameters publicKey,
+        DHPrivateKeyParameters privateKey)
+    {
+        DHBasicAgreement dhAgree = new DHBasicAgreement();
+        dhAgree.init(dhAgreeClientPrivateKey);
+        BigInteger agreement = dhAgree.calculateAgreement(dhAgreeServerPublicKey);
+        return BigIntegers.asUnsignedByteArray(agreement);
+    }
+
+    protected AsymmetricCipherKeyPair generateDHKeyPair(DHParameters dhParams)
+    {
+        DHBasicKeyPairGenerator dhGen = new DHBasicKeyPairGenerator();
+        dhGen.init(new DHKeyGenerationParameters(context.getSecureRandom(), dhParams));
+        return dhGen.generateKeyPair();
+    }
+
+    protected void generateEphemeralClientKeyExchange(DHParameters dhParams, OutputStream os)
+        throws IOException
+    {
+        AsymmetricCipherKeyPair dhAgreeClientKeyPair = generateDHKeyPair(dhParams);
+        this.dhAgreeClientPrivateKey = (DHPrivateKeyParameters)dhAgreeClientKeyPair.getPrivate();
+
+        BigInteger Yc = ((DHPublicKeyParameters)dhAgreeClientKeyPair.getPublic()).getY();
+        byte[] keData = BigIntegers.asUnsignedByteArray(Yc);
+        TlsUtils.writeUint24(keData.length + 2, os);
+        TlsUtils.writeOpaque16(keData, os);
+    }
+
+    protected DHPublicKeyParameters validateDHPublicKey(DHPublicKeyParameters key)
+        throws IOException
+    {
+        BigInteger Y = key.getY();
+        DHParameters params = key.getParameters();
+        BigInteger p = params.getP();
+        BigInteger g = params.getG();
+
+        if (!p.isProbablePrime(2))
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+        if (g.compareTo(TWO) &lt; 0 || g.compareTo(p.subtract(TWO)) &gt; 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+        if (Y.compareTo(TWO) &lt; 0 || Y.compareTo(p.subtract(ONE)) &gt; 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+
+        // TODO See RFC 2631 for more discussion of Diffie-Hellman validation
+
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,34 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.digests.NullDigest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.signers.DSADigestSigner;
+
+abstract class TlsDSASigner implements TlsSigner
+{
+    public byte[] calculateRawSignature(SecureRandom secureRandom, AsymmetricKeyParameter privateKey, byte[] md5andsha1)
+        throws CryptoException
+    {
+        // Note: Only use the SHA1 part of the hash
+        Signer signer = new DSADigestSigner(createDSAImpl(), new NullDigest());
+        signer.init(true, new ParametersWithRandom(privateKey, secureRandom));
+        signer.update(md5andsha1, 16, 20);
+        return signer.generateSignature();
+    }
+
+    public Signer createVerifyer(AsymmetricKeyParameter publicKey)
+    {
+        Signer verifyer = new DSADigestSigner(createDSAImpl(), new SHA1Digest());
+        verifyer.init(false, publicKey);
+        return verifyer;
+    }
+
+    protected abstract DSA createDSAImpl();
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsDSSSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.DSAPublicKeyParameters;
+import org.bouncycastle.crypto.signers.DSASigner;
+
+class TlsDSSSigner extends TlsDSASigner
+{
+    public boolean isValidPublicKey(AsymmetricKeyParameter publicKey)
+    {
+        return publicKey instanceof DSAPublicKeyParameters;
+    }
+
+    protected DSA createDSAImpl()
+    {
+        return new DSASigner();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsECDHEKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,112 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.io.SignerInputStream;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.math.ec.ECPoint;
+
+/**
+ * ECDHE key exchange (see RFC 4492)
+ */
+class TlsECDHEKeyExchange extends TlsECDHKeyExchange
+{
+    TlsECDHEKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        super(context, keyExchange);
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        SecurityParameters securityParameters = context.getSecurityParameters();
+
+        Signer signer = initSigner(tlsSigner, securityParameters);
+        InputStream sigIn = new SignerInputStream(is, signer);
+
+        short curveType = TlsUtils.readUint8(sigIn);
+        ECDomainParameters curve_params;
+
+        //  Currently, we only support named curves
+        if (curveType == ECCurveType.named_curve)
+        {
+            int namedCurve = TlsUtils.readUint16(sigIn);
+
+            // TODO Check namedCurve is one we offered?
+
+            curve_params = NamedCurve.getECParameters(namedCurve);
+        }
+        else
+        {
+            // TODO Add support for explicit curve parameters (read from sigIn)
+
+            throw new TlsFatalAlert(AlertDescription.handshake_failure);
+        }
+
+        byte[] publicBytes = TlsUtils.readOpaque8(sigIn);
+
+        byte[] sigByte = TlsUtils.readOpaque16(is);
+        if (!signer.verifySignature(sigByte))
+        {
+            throw new TlsFatalAlert(AlertDescription.bad_certificate);
+        }
+
+        // TODO Check curve_params not null
+
+        ECPoint Q = curve_params.getCurve().decodePoint(publicBytes);
+
+        this.ecAgreeServerPublicKey = validateECPublicKey(new ECPublicKeyParameters(Q, curve_params));
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        /*
+         * RFC 4492 3. [...] The ECDSA_fixed_ECDH and RSA_fixed_ECDH mechanisms are usable
+         * with ECDH_ECDSA and ECDH_RSA. Their use with ECDHE_ECDSA and ECDHE_RSA is
+         * prohibited because the use of a long-term ECDH client key would jeopardize the
+         * forward secrecy property of these algorithms.
+         */
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i &lt; types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.ecdsa_sign:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (clientCredentials instanceof TlsSignerCredentials)
+        {
+            // OK
+        }
+        else
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    protected Signer initSigner(TlsSigner tlsSigner, SecurityParameters securityParameters)
+    {
+        Signer signer = tlsSigner.createVerifyer(this.serverPublicKey);
+        signer.update(securityParameters.clientRandom, 0, securityParameters.clientRandom.length);
+        signer.update(securityParameters.serverRandom, 0, securityParameters.serverRandom.length);
+        return signer;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsECDHKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,245 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.crypto.AsymmetricCipherKeyPair;
+import org.bouncycastle.crypto.agreement.ECDHBasicAgreement;
+import org.bouncycastle.crypto.generators.ECKeyPairGenerator;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECKeyGenerationParameters;
+import org.bouncycastle.crypto.params.ECPrivateKeyParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.util.PublicKeyFactory;
+import org.bouncycastle.util.BigIntegers;
+
+/**
+ * ECDH key exchange (see RFC 4492)
+ */
+class TlsECDHKeyExchange implements TlsKeyExchange
+{
+    protected TlsClientContext context;
+    protected int keyExchange;
+    protected TlsSigner tlsSigner;
+
+    protected AsymmetricKeyParameter serverPublicKey;
+    protected ECPublicKeyParameters ecAgreeServerPublicKey;
+    protected TlsAgreementCredentials agreementCredentials;
+    protected ECPrivateKeyParameters ecAgreeClientPrivateKey = null;
+
+    TlsECDHKeyExchange(TlsClientContext context, int keyExchange)
+    {
+        switch (keyExchange)
+        {
+            case KeyExchangeAlgorithm.ECDHE_RSA:
+                this.tlsSigner = new TlsRSASigner();
+                break;
+            case KeyExchangeAlgorithm.ECDHE_ECDSA:
+                this.tlsSigner = new TlsECDSASigner();
+                break;
+            case KeyExchangeAlgorithm.ECDH_RSA:
+            case KeyExchangeAlgorithm.ECDH_ECDSA:
+                this.tlsSigner = null;
+                break;
+            default:
+                throw new IllegalArgumentException(&quot;unsupported key exchange algorithm&quot;);
+        }
+
+        this.context = context;
+        this.keyExchange = keyExchange;
+    }
+
+    public void skipServerCertificate() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        X509CertificateStructure x509Cert = serverCertificate.certs[0];
+        SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();
+
+        try
+        {
+            this.serverPublicKey = PublicKeyFactory.createKey(keyInfo);
+        }
+        catch (RuntimeException e)
+        {
+            throw new TlsFatalAlert(AlertDescription.unsupported_certificate);
+        }
+
+        if (tlsSigner == null)
+        {
+            try
+            {
+                this.ecAgreeServerPublicKey = validateECPublicKey((ECPublicKeyParameters)this.serverPublicKey);
+            }
+            catch (ClassCastException e)
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.keyAgreement);
+        }
+        else
+        {
+            if (!tlsSigner.isValidPublicKey(this.serverPublicKey))
+            {
+                throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+            }
+
+            TlsUtils.validateKeyUsage(x509Cert, KeyUsage.digitalSignature);
+        }
+        
+        // TODO 
+        /*
+         * Perform various checks per RFC2246 7.4.2: &quot;Unless otherwise specified, the
+         * signing algorithm for the certificate must be the same as the algorithm for the
+         * certificate key.&quot;
+         */
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        // do nothing
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        /*
+         * RFC 4492 3. [...] The ECDSA_fixed_ECDH and RSA_fixed_ECDH mechanisms are usable
+         * with ECDH_ECDSA and ECDH_RSA. Their use with ECDHE_ECDSA and ECDHE_RSA is
+         * prohibited because the use of a long-term ECDH client key would jeopardize the
+         * forward secrecy property of these algorithms.
+         */
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i &lt; types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.ecdsa_sign:
+                case ClientCertificateType.rsa_fixed_ecdh:
+                case ClientCertificateType.ecdsa_fixed_ecdh:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void skipClientCredentials() throws IOException
+    {
+        this.agreementCredentials = null;
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (clientCredentials instanceof TlsAgreementCredentials)
+        {
+            // TODO Validate client cert has matching parameters (see 'areOnSameCurve')?
+
+            this.agreementCredentials = (TlsAgreementCredentials)clientCredentials;
+        }
+        else if (clientCredentials instanceof TlsSignerCredentials)
+        {
+            // OK
+        }
+        else
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public void generateClientKeyExchange(OutputStream os) throws IOException
+    {
+        if (agreementCredentials != null)
+        {
+            TlsUtils.writeUint24(0, os);
+        }
+        else
+        {
+            generateEphemeralClientKeyExchange(ecAgreeServerPublicKey.getParameters(), os);
+        }
+    }
+
+    public byte[] generatePremasterSecret() throws IOException
+    {
+        if (agreementCredentials != null)
+        {
+            return agreementCredentials.generateAgreement(ecAgreeServerPublicKey);
+        }
+
+        return calculateECDHBasicAgreement(ecAgreeServerPublicKey, ecAgreeClientPrivateKey);
+    }
+
+    protected boolean areOnSameCurve(ECDomainParameters a, ECDomainParameters b)
+    {
+        // TODO Move to ECDomainParameters.equals() or other utility method?
+        return a.getCurve().equals(b.getCurve()) &amp;&amp; a.getG().equals(b.getG())
+            &amp;&amp; a.getN().equals(b.getN()) &amp;&amp; a.getH().equals(b.getH());
+    }
+
+    protected byte[] externalizeKey(ECPublicKeyParameters keyParameters) throws IOException
+    {
+        // TODO Add support for compressed encoding and SPF extension
+
+        /*
+         * RFC 4492 5.7. ...an elliptic curve point in uncompressed or compressed format.
+         * Here, the format MUST conform to what the server has requested through a
+         * Supported Point Formats Extension if this extension was used, and MUST be
+         * uncompressed if this extension was not used.
+         */
+        return keyParameters.getQ().getEncoded();
+    }
+
+    protected AsymmetricCipherKeyPair generateECKeyPair(ECDomainParameters ecParams)
+    {
+        ECKeyPairGenerator keyPairGenerator = new ECKeyPairGenerator();
+        ECKeyGenerationParameters keyGenerationParameters = new ECKeyGenerationParameters(ecParams,
+            context.getSecureRandom());
+        keyPairGenerator.init(keyGenerationParameters);
+        return keyPairGenerator.generateKeyPair();
+    }
+
+    protected void generateEphemeralClientKeyExchange(ECDomainParameters ecParams, OutputStream os)
+        throws IOException
+    {
+        AsymmetricCipherKeyPair ecAgreeClientKeyPair = generateECKeyPair(ecParams);
+        this.ecAgreeClientPrivateKey = (ECPrivateKeyParameters)ecAgreeClientKeyPair.getPrivate();
+
+        byte[] keData = externalizeKey((ECPublicKeyParameters)ecAgreeClientKeyPair.getPublic());
+        TlsUtils.writeUint24(keData.length + 1, os);
+        TlsUtils.writeOpaque8(keData, os);
+    }
+
+    protected byte[] calculateECDHBasicAgreement(ECPublicKeyParameters publicKey,
+        ECPrivateKeyParameters privateKey)
+    {
+        ECDHBasicAgreement basicAgreement = new ECDHBasicAgreement();
+        basicAgreement.init(privateKey);
+        BigInteger agreement = basicAgreement.calculateAgreement(publicKey);
+        return BigIntegers.asUnsignedByteArray(agreement);
+    }
+
+    protected ECPublicKeyParameters validateECPublicKey(ECPublicKeyParameters key)
+        throws IOException
+    {
+        // TODO Check RFC 4492 for validation
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsECDSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.crypto.tls;
+
+import org.bouncycastle.crypto.DSA;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.signers.ECDSASigner;
+
+class TlsECDSASigner extends TlsDSASigner
+{
+    public boolean isValidPublicKey(AsymmetricKeyParameter publicKey)
+    {
+        return publicKey instanceof ECPublicKeyParameters;
+    }
+
+    protected DSA createDSAImpl()
+    {
+        return new ECDSASigner();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsFatalAlert.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,20 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public class TlsFatalAlert extends IOException
+{
+    private static final long serialVersionUID = 3584313123679111168L;
+
+    private short alertDescription;
+
+    public TlsFatalAlert(short alertDescription)
+    {
+        this.alertDescription = alertDescription;
+    }
+
+    public short getAlertDescription()
+    {
+        return alertDescription;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsInputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+
+/**
+ * An InputStream for an TLS 1.0 connection.
+ */
+class TlsInputStream extends InputStream
+{
+    private byte[] buf = new byte[1];
+    private TlsProtocolHandler handler = null;
+
+    TlsInputStream(TlsProtocolHandler handler)
+    {
+        this.handler = handler;
+    }
+
+    public int read(byte[] buf, int offset, int len) throws IOException
+    {
+        return this.handler.readApplicationData(buf, offset, len);
+    }
+
+    public int read() throws IOException
+    {
+        if (this.read(buf) &lt; 0)
+        {
+            return -1;
+        }
+        return buf[0] &amp; 0xff;
+    }
+
+    public void close() throws IOException
+    {
+        handler.close();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,30 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+/**
+ * A generic interface for key exchange implementations in TLS 1.0.
+ */
+public interface TlsKeyExchange
+{
+    void skipServerCertificate() throws IOException;
+
+    void processServerCertificate(Certificate serverCertificate) throws IOException;
+
+    void skipServerKeyExchange() throws IOException;
+
+    void processServerKeyExchange(InputStream is)
+        throws IOException;
+
+    void validateCertificateRequest(CertificateRequest certificateRequest) throws IOException;
+
+    void skipClientCredentials() throws IOException;
+
+    void processClientCredentials(TlsCredentials clientCredentials) throws IOException;
+
+    void generateClientKeyExchange(OutputStream os) throws IOException;
+
+    byte[] generatePremasterSecret() throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsMac.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsMac.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsMac.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsMac.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,78 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.macs.HMac;
+import org.bouncycastle.crypto.params.KeyParameter;
+
+/**
+ * A generic TLS MAC implementation, which can be used with any kind of Digest to act as
+ * an HMAC.
+ */
+public class TlsMac
+{
+    protected long seqNo;
+    protected HMac mac;
+
+    /**
+     * Generate a new instance of an TlsMac.
+     * 
+     * @param digest The digest to use.
+     * @param key_block A byte-array where the key for this mac is located.
+     * @param offset The number of bytes to skip, before the key starts in the buffer.
+     * @param len The length of the key.
+     */
+    public TlsMac(Digest digest, byte[] key_block, int offset, int len)
+    {
+        this.mac = new HMac(digest);
+        KeyParameter param = new KeyParameter(key_block, offset, len);
+        this.mac.init(param);
+        this.seqNo = 0;
+    }
+
+    /**
+     * @return The Keysize of the mac.
+     */
+    public int getSize()
+    {
+        return mac.getMacSize();
+    }
+
+    /**
+     * Calculate the mac for some given data.
+     * &lt;p/&gt;
+     * TlsMac will keep track of the sequence number internally.
+     * 
+     * @param type The message type of the message.
+     * @param message A byte-buffer containing the message.
+     * @param offset The number of bytes to skip, before the message starts.
+     * @param len The length of the message.
+     * @return A new byte-buffer containing the mac value.
+     */
+    public byte[] calculateMac(short type, byte[] message, int offset, int len)
+    {
+        ByteArrayOutputStream bosMac = new ByteArrayOutputStream(13);
+        try
+        {
+            TlsUtils.writeUint64(seqNo++, bosMac);
+            TlsUtils.writeUint8(type, bosMac);
+            TlsUtils.writeVersion(bosMac);
+            TlsUtils.writeUint16(len, bosMac);
+        }
+        catch (IOException e)
+        {
+            // This should never happen
+            throw new IllegalStateException(&quot;Internal error during mac calculation&quot;);
+        }
+
+        byte[] macHeader = bosMac.toByteArray();
+        mac.update(macHeader, 0, macHeader.length);
+        mac.update(message, offset, len);
+
+        byte[] result = new byte[mac.getMacSize()];
+        mac.doFinal(result, 0);
+        return result;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsNullCipher.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,24 @@
+package org.bouncycastle.crypto.tls;
+
+/**
+ * A NULL CipherSuite in java, this should only be used during handshake.
+ */
+public class TlsNullCipher implements TlsCipher
+{
+    public byte[] encodePlaintext(short type, byte[] plaintext, int offset, int len)
+    {
+        return copyData(plaintext, offset, len);
+    }
+
+    public byte[] decodeCiphertext(short type, byte[] ciphertext, int offset, int len)
+    {
+        return copyData(ciphertext, offset, len);
+    }
+
+    protected byte[] copyData(byte[] text, int offset, int len)
+    {
+        byte[] result = new byte[len];
+        System.arraycopy(text, offset, result, 0, len);
+        return result;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsNullCompression.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,16 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.OutputStream;
+
+public class TlsNullCompression implements TlsCompression
+{
+    public OutputStream compress(OutputStream output)
+    {
+        return output;
+    }
+
+    public OutputStream decompress(OutputStream output)
+    {
+        return output;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsOutputStream.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+/**
+ * An OutputStream for an TLS connection.
+ */
+class TlsOutputStream extends OutputStream
+{
+    private byte[] buf = new byte[1];
+    private TlsProtocolHandler handler;
+
+    TlsOutputStream(TlsProtocolHandler handler)
+    {
+        this.handler = handler;
+    }
+
+    public void write(byte buf[], int offset, int len) throws IOException
+    {
+        this.handler.writeData(buf, offset, len);
+    }
+
+    public void write(int arg0) throws IOException
+    {
+        buf[0] = (byte)arg0;
+        this.write(buf, 0, 1);
+    }
+
+    public void close() throws IOException
+    {
+        handler.close();
+    }
+
+    public void flush() throws IOException
+    {
+        handler.flush();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsProtocolHandler.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1210 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.ByteArrayInputStream;
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.security.SecureRandom;
+import ewe.util.Enumeration;
+import ewe.util.Hashtable;
+import ewe.util.Vector;
+
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.x500.X500Name;
+import org.bouncycastle.crypto.prng.ThreadedSeedGenerator;
+import org.bouncycastle.util.Arrays;
+
+/**
+ * An implementation of all high level protocols in TLS 1.0.
+ */
+public class TlsProtocolHandler
+{
+    private static final Integer EXT_RenegotiationInfo = new Integer(ExtensionType.renegotiation_info);
+
+    /*
+     * Our Connection states
+     */
+    private static final short CS_CLIENT_HELLO_SEND = 1;
+    private static final short CS_SERVER_HELLO_RECEIVED = 2;
+    private static final short CS_SERVER_CERTIFICATE_RECEIVED = 3;
+    private static final short CS_SERVER_KEY_EXCHANGE_RECEIVED = 4;
+    private static final short CS_CERTIFICATE_REQUEST_RECEIVED = 5;
+    private static final short CS_SERVER_HELLO_DONE_RECEIVED = 6;
+    private static final short CS_CLIENT_KEY_EXCHANGE_SEND = 7;
+    private static final short CS_CERTIFICATE_VERIFY_SEND = 8;
+    private static final short CS_CLIENT_CHANGE_CIPHER_SPEC_SEND = 9;
+    private static final short CS_CLIENT_FINISHED_SEND = 10;
+    private static final short CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED = 11;
+    private static final short CS_DONE = 12;
+
+    private static final byte[] emptybuf = new byte[0];
+
+    private static final String TLS_ERROR_MESSAGE = &quot;Internal TLS error, this could be an attack&quot;;
+
+    /*
+     * Queues for data from some protocols.
+     */
+    private ByteQueue applicationDataQueue = new ByteQueue();
+    private ByteQueue changeCipherSpecQueue = new ByteQueue();
+    private ByteQueue alertQueue = new ByteQueue();
+    private ByteQueue handshakeQueue = new ByteQueue();
+
+    /*
+     * The Record Stream we use
+     */
+    private RecordStream rs;
+    private SecureRandom random;
+
+    private TlsInputStream tlsInputStream = null;
+    private TlsOutputStream tlsOutputStream = null;
+
+    private boolean closed = false;
+    private boolean failedWithError = false;
+    private boolean appDataReady = false;
+    private Hashtable clientExtensions;
+
+    private SecurityParameters securityParameters = null;
+
+    private TlsClientContextImpl tlsClientContext = null;
+    private TlsClient tlsClient = null;
+    private int[] offeredCipherSuites = null;
+    private short[] offeredCompressionMethods = null;
+    private TlsKeyExchange keyExchange = null;
+    private TlsAuthentication authentication = null;
+    private CertificateRequest certificateRequest = null;
+
+    private short connection_state = 0;
+
+    private static SecureRandom createSecureRandom()
+    {
+        /*
+         * We use our threaded seed generator to generate a good random seed. If the user
+         * has a better random seed, he should use the constructor with a SecureRandom.
+         */
+        ThreadedSeedGenerator tsg = new ThreadedSeedGenerator();
+        SecureRandom random = new SecureRandom();
+
+        /*
+         * Hopefully, 20 bytes in fast mode are good enough.
+         */
+        random.setSeed(tsg.generateSeed(20, true));
+
+        return random;
+    }
+
+    public TlsProtocolHandler(InputStream is, OutputStream os)
+    {
+        this(is, os, createSecureRandom());
+    }
+
+    public TlsProtocolHandler(InputStream is, OutputStream os, SecureRandom sr)
+    {
+        this.rs = new RecordStream(this, is, os);
+        this.random = sr;
+    }
+
+    protected void processData(short protocol, byte[] buf, int offset, int len) throws IOException
+    {
+        /*
+         * Have a look at the protocol type, and add it to the correct queue.
+         */
+        switch (protocol)
+        {
+            case ContentType.change_cipher_spec:
+                changeCipherSpecQueue.addData(buf, offset, len);
+                processChangeCipherSpec();
+                break;
+            case ContentType.alert:
+                alertQueue.addData(buf, offset, len);
+                processAlert();
+                break;
+            case ContentType.handshake:
+                handshakeQueue.addData(buf, offset, len);
+                processHandshake();
+                break;
+            case ContentType.application_data:
+                if (!appDataReady)
+                {
+                    this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+                applicationDataQueue.addData(buf, offset, len);
+                processApplicationData();
+                break;
+            default:
+                /*
+                 * Uh, we don't know this protocol.
+                 *
+                 * RFC2246 defines on page 13, that we should ignore this.
+                 */
+        }
+    }
+
+    private void processHandshake() throws IOException
+    {
+        boolean read;
+        do
+        {
+            read = false;
+            /*
+             * We need the first 4 bytes, they contain type and length of the message.
+             */
+            if (handshakeQueue.size() &gt;= 4)
+            {
+                byte[] beginning = new byte[4];
+                handshakeQueue.read(beginning, 0, 4, 0);
+                ByteArrayInputStream bis = new ByteArrayInputStream(beginning);
+                short type = TlsUtils.readUint8(bis);
+                int len = TlsUtils.readUint24(bis);
+
+                /*
+                 * Check if we have enough bytes in the buffer to read the full message.
+                 */
+                if (handshakeQueue.size() &gt;= (len + 4))
+                {
+                    /*
+                     * Read the message.
+                     */
+                    byte[] buf = new byte[len];
+                    handshakeQueue.read(buf, 0, len, 4);
+                    handshakeQueue.removeData(len + 4);
+
+                    /*
+                     * RFC 2246 7.4.9. The value handshake_messages includes all handshake
+                     * messages starting at client hello up to, but not including, this
+                     * finished message. [..] Note: [Also,] Hello Request messages are
+                     * omitted from handshake hashes.
+                     */
+                    switch (type)
+                    {
+                        case HandshakeType.hello_request:
+                        case HandshakeType.finished:
+                            break;
+                        default:
+                            rs.updateHandshakeData(beginning, 0, 4);
+                            rs.updateHandshakeData(buf, 0, len);
+                            break;
+                    }
+
+                    /*
+                     * Now, parse the message.
+                     */
+                    processHandshakeMessage(type, buf);
+                    read = true;
+                }
+            }
+        }
+        while (read);
+    }
+
+    private void processHandshakeMessage(short type, byte[] buf) throws IOException
+    {
+        ByteArrayInputStream is = new ByteArrayInputStream(buf);
+
+        switch (type)
+        {
+            case HandshakeType.certificate:
+            {
+                switch (connection_state)
+                {
+                    case CS_SERVER_HELLO_RECEIVED:
+                    {
+                        // Parse the Certificate message and send to cipher suite
+
+                        Certificate serverCertificate = Certificate.parse(is);
+
+                        assertEmpty(is);
+
+                        this.keyExchange.processServerCertificate(serverCertificate);
+
+                        this.authentication = tlsClient.getAuthentication();
+                        this.authentication.notifyServerCertificate(serverCertificate);
+
+                        break;
+                    }
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+
+                connection_state = CS_SERVER_CERTIFICATE_RECEIVED;
+                break;
+            }
+            case HandshakeType.finished:
+                switch (connection_state)
+                {
+                    case CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED:
+                        /*
+                         * Read the checksum from the finished message, it has always 12
+                         * bytes.
+                         */
+                        byte[] serverVerifyData = new byte[12];
+                        TlsUtils.readFully(serverVerifyData, is);
+
+                        assertEmpty(is);
+
+                        /*
+                         * Calculate our own checksum.
+                         */
+                        byte[] expectedServerVerifyData = TlsUtils.PRF(
+                            securityParameters.masterSecret, &quot;server finished&quot;,
+                            rs.getCurrentHash(), 12);
+
+                        /*
+                         * Compare both checksums.
+                         */
+                        if (!Arrays.constantTimeAreEqual(expectedServerVerifyData, serverVerifyData))
+                        {
+                            /*
+                             * Wrong checksum in the finished message.
+                             */
+                            this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+                        }
+
+                        connection_state = CS_DONE;
+
+                        /*
+                         * We are now ready to receive application data.
+                         */
+                        this.appDataReady = true;
+                        break;
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+                break;
+            case HandshakeType.server_hello:
+                switch (connection_state)
+                {
+                    case CS_CLIENT_HELLO_SEND:
+                        /*
+                         * Read the server hello message
+                         */
+                        TlsUtils.checkVersion(is, this);
+
+                        /*
+                         * Read the server random
+                         */
+                        securityParameters.serverRandom = new byte[32];
+                        TlsUtils.readFully(securityParameters.serverRandom, is);
+
+                        byte[] sessionID = TlsUtils.readOpaque8(is);
+                        if (sessionID.length &gt; 32)
+                        {
+                            this.failWithError(AlertLevel.fatal, AlertDescription.illegal_parameter);
+                        }
+
+                        this.tlsClient.notifySessionID(sessionID);
+
+                        /*
+                         * Find out which CipherSuite the server has chosen and check that
+                         * it was one of the offered ones.
+                         */
+                        int selectedCipherSuite = TlsUtils.readUint16(is);
+                        if (!arrayContains(offeredCipherSuites, selectedCipherSuite)
+                            || selectedCipherSuite == CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV)
+                        {
+                            this.failWithError(AlertLevel.fatal, AlertDescription.illegal_parameter);
+                        }
+
+                        this.tlsClient.notifySelectedCipherSuite(selectedCipherSuite);
+
+                        /*
+                         * Find out which CompressionMethod the server has chosen and check that
+                         * it was one of the offered ones.
+                         */
+                        short selectedCompressionMethod = TlsUtils.readUint8(is);
+                        if (!arrayContains(offeredCompressionMethods, selectedCompressionMethod))
+                        {
+                            this.failWithError(AlertLevel.fatal, AlertDescription.illegal_parameter);
+                        }
+
+                        this.tlsClient.notifySelectedCompressionMethod(selectedCompressionMethod);
+
+                        /*
+                         * RFC3546 2.2 The extended server hello message format MAY be
+                         * sent in place of the server hello message when the client has
+                         * requested extended functionality via the extended client hello
+                         * message specified in Section 2.1. ... Note that the extended
+                         * server hello message is only sent in response to an extended
+                         * client hello message. This prevents the possibility that the
+                         * extended server hello message could &quot;break&quot; existing TLS 1.0
+                         * clients.
+                         */
+
+                        /*
+                         * TODO RFC 3546 2.3 If [...] the older session is resumed, then
+                         * the server MUST ignore extensions appearing in the client
+                         * hello, and send a server hello containing no extensions.
+                         */
+
+                        // Integer -&gt; byte[]
+                        Hashtable serverExtensions = new Hashtable();
+
+                        if (is.available() &gt; 0)
+                        {
+                            // Process extensions from extended server hello
+                            byte[] extBytes = TlsUtils.readOpaque16(is);
+
+                            ByteArrayInputStream ext = new ByteArrayInputStream(extBytes);
+                            while (ext.available() &gt; 0)
+                            {
+                                Integer extType = new Integer(TlsUtils.readUint16(ext));
+                                byte[] extValue = TlsUtils.readOpaque16(ext);
+
+                                /*
+                                 * RFC 5746 Note that sending a &quot;renegotiation_info&quot;
+                                 * extension in response to a ClientHello containing only
+                                 * the SCSV is an explicit exception to the prohibition in
+                                 * RFC 5246, Section 7.4.1.4, on the server sending
+                                 * unsolicited extensions and is only allowed because the
+                                 * client is signaling its willingness to receive the
+                                 * extension via the TLS_EMPTY_RENEGOTIATION_INFO_SCSV
+                                 * SCSV. TLS implementations MUST continue to comply with
+                                 * Section 7.4.1.4 for all other extensions.
+                                 */
+
+                                if (!extType.equals(EXT_RenegotiationInfo)
+                                    &amp;&amp; clientExtensions.get(extType) == null)
+                                {
+                                    /*
+                                     * RFC 3546 2.3 Note that for all extension types
+                                     * (including those defined in future), the extension
+                                     * type MUST NOT appear in the extended server hello
+                                     * unless the same extension type appeared in the
+                                     * corresponding client hello. Thus clients MUST abort
+                                     * the handshake if they receive an extension type in
+                                     * the extended server hello that they did not request
+                                     * in the associated (extended) client hello.
+                                     */
+                                    this.failWithError(AlertLevel.fatal,
+                                        AlertDescription.unsupported_extension);
+                                }
+
+                                if (serverExtensions.containsKey(extType))
+                                {
+                                    /*
+                                     * RFC 3546 2.3 Also note that when multiple
+                                     * extensions of different types are present in the
+                                     * extended client hello or the extended server hello,
+                                     * the extensions may appear in any order. There MUST
+                                     * NOT be more than one extension of the same type.
+                                     */
+                                    this.failWithError(AlertLevel.fatal,
+                                        AlertDescription.illegal_parameter);
+                                }
+
+                                serverExtensions.put(extType, extValue);
+                            }
+                        }
+
+                        assertEmpty(is);
+
+                        /*
+                         * RFC 5746 3.4. When a ServerHello is received, the client MUST
+                         * check if it includes the &quot;renegotiation_info&quot; extension:
+                         */
+                        {
+                            boolean secure_negotiation = serverExtensions.containsKey(EXT_RenegotiationInfo);
+
+                            /*
+                             * If the extension is present, set the secure_renegotiation
+                             * flag to TRUE. The client MUST then verify that the length
+                             * of the &quot;renegotiated_connection&quot; field is zero, and if it
+                             * is not, MUST abort the handshake (by sending a fatal
+                             * handshake_failure alert).
+                             */
+                            if (secure_negotiation)
+                            {
+                                byte[] renegExtValue = (byte[])serverExtensions.get(EXT_RenegotiationInfo);
+
+                                if (!Arrays.constantTimeAreEqual(renegExtValue,
+                                    createRenegotiationInfo(emptybuf)))
+                                {
+                                    this.failWithError(AlertLevel.fatal,
+                                        AlertDescription.handshake_failure);
+                                }
+                            }
+
+                            tlsClient.notifySecureRenegotiation(secure_negotiation);
+                        }
+
+                        if (clientExtensions != null)
+                        {
+                            tlsClient.processServerExtensions(serverExtensions);
+                        }
+
+                        this.keyExchange = tlsClient.getKeyExchange();
+
+                        connection_state = CS_SERVER_HELLO_RECEIVED;
+                        break;
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+                break;
+            case HandshakeType.server_hello_done:
+                switch (connection_state)
+                {
+                    case CS_SERVER_CERTIFICATE_RECEIVED:
+
+                        // There was no server key exchange message; check it's OK
+                        this.keyExchange.skipServerKeyExchange();
+
+                        // NB: Fall through to next case label
+
+                    case CS_SERVER_KEY_EXCHANGE_RECEIVED:
+                    case CS_CERTIFICATE_REQUEST_RECEIVED:
+
+                        assertEmpty(is);
+
+                        connection_state = CS_SERVER_HELLO_DONE_RECEIVED;
+
+                        TlsCredentials clientCreds = null;
+                        if (certificateRequest == null)
+                        {
+                            this.keyExchange.skipClientCredentials();
+                        }
+                        else
+                        {
+                            clientCreds = this.authentication.getClientCredentials(certificateRequest);
+
+                            Certificate clientCert;
+                            if (clientCreds == null)
+                            {
+                                this.keyExchange.skipClientCredentials();
+                                clientCert = Certificate.EMPTY_CHAIN;
+                            }
+                            else
+                            {
+                                this.keyExchange.processClientCredentials(clientCreds);
+                                clientCert = clientCreds.getCertificate();
+                            }
+
+                            sendClientCertificate(clientCert);
+                        }
+
+                        /*
+                         * Send the client key exchange message, depending on the key
+                         * exchange we are using in our CipherSuite.
+                         */
+                        sendClientKeyExchange();
+
+                        connection_state = CS_CLIENT_KEY_EXCHANGE_SEND;
+
+                        if (clientCreds != null &amp;&amp; clientCreds instanceof TlsSignerCredentials)
+                        {
+                            TlsSignerCredentials signerCreds = (TlsSignerCredentials)clientCreds;
+                            byte[] md5andsha1 = rs.getCurrentHash();
+                            byte[] clientCertificateSignature = signerCreds.generateCertificateSignature(
+                                md5andsha1);
+                            sendCertificateVerify(clientCertificateSignature);
+
+                            connection_state = CS_CERTIFICATE_VERIFY_SEND;
+                        }
+
+                        /*
+                         * Now, we send change cipher state
+                         */
+                        byte[] cmessage = new byte[1];
+                        cmessage[0] = 1;
+                        rs.writeMessage(ContentType.change_cipher_spec, cmessage, 0,
+                            cmessage.length);
+
+                        connection_state = CS_CLIENT_CHANGE_CIPHER_SPEC_SEND;
+
+                        /*
+                         * Calculate the master_secret
+                         */
+                        byte[] pms = this.keyExchange.generatePremasterSecret();
+
+                        securityParameters.masterSecret = TlsUtils.PRF(pms, &quot;master secret&quot;,
+                            TlsUtils.concat(securityParameters.clientRandom,
+                                securityParameters.serverRandom), 48);
+
+                        // TODO Is there a way to ensure the data is really overwritten?
+                        /*
+                         * RFC 2246 8.1. The pre_master_secret should be deleted from
+                         * memory once the master_secret has been computed.
+                         */
+                        Arrays.fill(pms, (byte)0);
+
+                        /*
+                         * Initialize our cipher suite
+                         */
+                        rs.clientCipherSpecDecided(tlsClient.getCompression(), tlsClient.getCipher());
+
+                        /*
+                         * Send our finished message.
+                         */
+                        byte[] clientVerifyData = TlsUtils.PRF(securityParameters.masterSecret,
+                            &quot;client finished&quot;, rs.getCurrentHash(), 12);
+
+                        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+                        TlsUtils.writeUint8(HandshakeType.finished, bos);
+                        TlsUtils.writeOpaque24(clientVerifyData, bos);
+                        byte[] message = bos.toByteArray();
+
+                        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+
+                        this.connection_state = CS_CLIENT_FINISHED_SEND;
+                        break;
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+                }
+                break;
+            case HandshakeType.server_key_exchange:
+            {
+                switch (connection_state)
+                {
+                    case CS_SERVER_HELLO_RECEIVED:
+
+                        // There was no server certificate message; check it's OK
+                        this.keyExchange.skipServerCertificate();
+                        this.authentication = null;
+
+                        // NB: Fall through to next case label
+
+                    case CS_SERVER_CERTIFICATE_RECEIVED:
+
+                        this.keyExchange.processServerKeyExchange(is);
+
+                        assertEmpty(is);
+                        break;
+
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+
+                this.connection_state = CS_SERVER_KEY_EXCHANGE_RECEIVED;
+                break;
+            }
+            case HandshakeType.certificate_request:
+            {
+                switch (connection_state)
+                {
+                    case CS_SERVER_CERTIFICATE_RECEIVED:
+
+                        // There was no server key exchange message; check it's OK
+                        this.keyExchange.skipServerKeyExchange();
+
+                        // NB: Fall through to next case label
+
+                    case CS_SERVER_KEY_EXCHANGE_RECEIVED:
+                    {
+                    	if (this.authentication == null)
+                    	{
+                            /*
+                             * RFC 2246 7.4.4. It is a fatal handshake_failure alert
+                             * for an anonymous server to request client identification.
+                             */
+                    		this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+                    	}
+
+                        int numTypes = TlsUtils.readUint8(is);
+                        short[] certificateTypes = new short[numTypes];
+                        for (int i = 0; i &lt; numTypes; ++i)
+                        {
+                            certificateTypes[i] = TlsUtils.readUint8(is);
+                        }
+
+                        byte[] authorities = TlsUtils.readOpaque16(is);
+
+                        assertEmpty(is);
+
+                        Vector authorityDNs = new Vector();
+
+                        ByteArrayInputStream bis = new ByteArrayInputStream(authorities);
+                        while (bis.available() &gt; 0)
+                        {
+                            byte[] dnBytes = TlsUtils.readOpaque16(bis);
+                            authorityDNs.addElement(X500Name.getInstance(ASN1Object.fromByteArray(dnBytes)));
+                        }
+
+                        this.certificateRequest = new CertificateRequest(certificateTypes,
+                            authorityDNs);
+                        this.keyExchange.validateCertificateRequest(this.certificateRequest);
+
+                        break;
+                    }
+                    default:
+                        this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                }
+
+                this.connection_state = CS_CERTIFICATE_REQUEST_RECEIVED;
+                break;
+            }
+            case HandshakeType.hello_request:
+                /*
+                 * RFC 2246 7.4.1.1 Hello request This message will be ignored by the
+                 * client if the client is currently negotiating a session. This message
+                 * may be ignored by the client if it does not wish to renegotiate a
+                 * session, or the client may, if it wishes, respond with a
+                 * no_renegotiation alert.
+                 */
+                if (connection_state == CS_DONE)
+                {
+                    // Renegotiation not supported yet
+                    sendAlert(AlertLevel.warning, AlertDescription.no_renegotiation);
+                }
+                break;
+            case HandshakeType.client_key_exchange:
+            case HandshakeType.certificate_verify:
+            case HandshakeType.client_hello:
+            default:
+                // We do not support this!
+                this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+                break;
+        }
+    }
+
+    private void processApplicationData()
+    {
+        /*
+         * There is nothing we need to do here.
+         *
+         * This function could be used for callbacks when application data arrives in the
+         * future.
+         */
+    }
+
+    private void processAlert() throws IOException
+    {
+        while (alertQueue.size() &gt;= 2)
+        {
+            /*
+             * An alert is always 2 bytes. Read the alert.
+             */
+            byte[] tmp = new byte[2];
+            alertQueue.read(tmp, 0, 2, 0);
+            alertQueue.removeData(2);
+            short level = tmp[0];
+            short description = tmp[1];
+            if (level == AlertLevel.fatal)
+            {
+                /*
+                 * This is a fatal error.
+                 */
+                this.failedWithError = true;
+                this.closed = true;
+                /*
+                 * Now try to close the stream, ignore errors.
+                 */
+                try
+                {
+                    rs.close();
+                }
+                catch (Exception e)
+                {
+
+                }
+                throw new IOException(TLS_ERROR_MESSAGE);
+            }
+            else
+            {
+                /*
+                 * This is just a warning.
+                 */
+                if (description == AlertDescription.close_notify)
+                {
+                    /*
+                     * Close notify
+                     */
+                    this.failWithError(AlertLevel.warning, AlertDescription.close_notify);
+                }
+                /*
+                 * If it is just a warning, we continue.
+                 */
+            }
+        }
+    }
+
+    /**
+     * This method is called, when a change cipher spec message is received.
+     *
+     * @throws IOException If the message has an invalid content or the handshake is not
+     *             in the correct state.
+     */
+    private void processChangeCipherSpec() throws IOException
+    {
+        while (changeCipherSpecQueue.size() &gt; 0)
+        {
+            /*
+             * A change cipher spec message is only one byte with the value 1.
+             */
+            byte[] b = new byte[1];
+            changeCipherSpecQueue.read(b, 0, 1, 0);
+            changeCipherSpecQueue.removeData(1);
+            if (b[0] != 1)
+            {
+                /*
+                 * This should never happen.
+                 */
+                this.failWithError(AlertLevel.fatal, AlertDescription.unexpected_message);
+            }
+
+            /*
+             * Check if we are in the correct connection state.
+             */
+            if (this.connection_state != CS_CLIENT_FINISHED_SEND)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.handshake_failure);
+            }
+
+            rs.serverClientSpecReceived();
+
+            this.connection_state = CS_SERVER_CHANGE_CIPHER_SPEC_RECEIVED;
+        }
+    }
+
+    private void sendClientCertificate(Certificate clientCert) throws IOException
+    {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.certificate, bos);
+        clientCert.encode(bos);
+        byte[] message = bos.toByteArray();
+
+        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+    }
+
+    private void sendClientKeyExchange() throws IOException
+    {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.client_key_exchange, bos);
+        this.keyExchange.generateClientKeyExchange(bos);
+        byte[] message = bos.toByteArray();
+
+        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+    }
+
+    private void sendCertificateVerify(byte[] data) throws IOException
+    {
+        /*
+         * Send signature of handshake messages so far to prove we are the owner of the
+         * cert See RFC 2246 sections 4.7, 7.4.3 and 7.4.8
+         */
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.certificate_verify, bos);
+        TlsUtils.writeUint24(data.length + 2, bos);
+        TlsUtils.writeOpaque16(data, bos);
+        byte[] message = bos.toByteArray();
+
+        rs.writeMessage(ContentType.handshake, message, 0, message.length);
+    }
+
+    /**
+     * Connects to the remote system.
+     *
+     * @param verifyer Will be used when a certificate is received to verify that this
+     *            certificate is accepted by the client.
+     * @throws IOException If handshake was not successful.
+     *
+     * @deprecated use version taking TlsClient
+     */
+    public void connect(CertificateVerifyer verifyer) throws IOException
+    {
+        this.connect(new LegacyTlsClient(verifyer));
+    }
+
+    /**
+     * Connects to the remote system using client authentication
+     *
+     * @param tlsClient
+     * @throws IOException If handshake was not successful.
+     */
+    public void connect(TlsClient tlsClient) throws IOException
+    {
+        if (tlsClient == null)
+        {
+            throw new IllegalArgumentException(&quot;'tlsClient' cannot be null&quot;);
+        }
+        if (this.tlsClient != null)
+        {
+            throw new IllegalStateException(&quot;connect can only be called once&quot;);
+        }
+
+        /*
+         * Send Client hello
+         *
+         * First, generate some random data.
+         */
+        this.securityParameters = new SecurityParameters();
+        this.securityParameters.clientRandom = new byte[32];
+        random.nextBytes(securityParameters.clientRandom);
+        TlsUtils.writeGMTUnixTime(securityParameters.clientRandom, 0);
+
+        this.tlsClientContext = new TlsClientContextImpl(random, securityParameters);
+        this.tlsClient = tlsClient;
+        this.tlsClient.init(tlsClientContext);
+
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        TlsUtils.writeVersion(os);
+        os.write(securityParameters.clientRandom);
+
+        /*
+         * Length of Session id
+         */
+        TlsUtils.writeUint8((short)0, os);
+
+        /*
+         * Cipher suites
+         */
+        this.offeredCipherSuites = this.tlsClient.getCipherSuites();
+
+        // Integer -&gt; byte[]
+        this.clientExtensions = this.tlsClient.getClientExtensions();
+
+        // Cipher Suites (and SCSV)
+        {
+            /*
+             * RFC 5746 3.4. The client MUST include either an empty &quot;renegotiation_info&quot;
+             * extension, or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV signaling cipher suite
+             * value in the ClientHello. Including both is NOT RECOMMENDED.
+             */
+            boolean noRenegExt = clientExtensions == null
+                || clientExtensions.get(EXT_RenegotiationInfo) == null;
+
+            int count = offeredCipherSuites.length;
+            if (noRenegExt)
+            {
+                // Note: 1 extra slot for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
+                ++count;
+            }
+
+            TlsUtils.writeUint16(2 * count, os);
+            TlsUtils.writeUint16Array(offeredCipherSuites, os);
+
+            if (noRenegExt)
+            {
+                TlsUtils.writeUint16(CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV, os);
+            }
+        }
+
+        // Compression methods
+        this.offeredCompressionMethods = this.tlsClient.getCompressionMethods();
+
+        TlsUtils.writeUint8((short)offeredCompressionMethods.length, os);
+        TlsUtils.writeUint8Array(offeredCompressionMethods, os);
+
+        // Extensions
+        if (clientExtensions != null)
+        {
+            ByteArrayOutputStream ext = new ByteArrayOutputStream();
+
+            Enumeration keys = clientExtensions.keys();
+            while (keys.hasMoreElements())
+            {
+                Integer extType = (Integer)keys.nextElement();
+                writeExtension(ext, extType, (byte[])clientExtensions.get(extType));
+            }
+
+            TlsUtils.writeOpaque16(ext.toByteArray(), os);
+        }
+
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        TlsUtils.writeUint8(HandshakeType.client_hello, bos);
+        TlsUtils.writeUint24(os.size(), bos);
+        bos.write(os.toByteArray());
+        byte[] message = bos.toByteArray();
+
+        safeWriteMessage(ContentType.handshake, message, 0, message.length);
+
+        connection_state = CS_CLIENT_HELLO_SEND;
+
+        /*
+         * We will now read data, until we have completed the handshake.
+         */
+        while (connection_state != CS_DONE)
+        {
+            safeReadData();
+        }
+
+        this.tlsInputStream = new TlsInputStream(this);
+        this.tlsOutputStream = new TlsOutputStream(this);
+    }
+
+    /**
+     * Read data from the network. The method will return immediately, if there is still
+     * some data left in the buffer, or block until some application data has been read
+     * from the network.
+     *
+     * @param buf The buffer where the data will be copied to.
+     * @param offset The position where the data will be placed in the buffer.
+     * @param len The maximum number of bytes to read.
+     * @return The number of bytes read.
+     * @throws IOException If something goes wrong during reading data.
+     */
+    protected int readApplicationData(byte[] buf, int offset, int len) throws IOException
+    {
+        while (applicationDataQueue.size() == 0)
+        {
+            /*
+             * We need to read some data.
+             */
+            if (this.closed)
+            {
+                if (this.failedWithError)
+                {
+                    /*
+                     * Something went terribly wrong, we should throw an IOException
+                     */
+                    throw new IOException(TLS_ERROR_MESSAGE);
+                }
+
+                /*
+                 * Connection has been closed, there is no more data to read.
+                 */
+                return -1;
+            }
+
+            safeReadData();
+        }
+        len = Math.min(len, applicationDataQueue.size());
+        applicationDataQueue.read(buf, offset, len, 0);
+        applicationDataQueue.removeData(len);
+        return len;
+    }
+
+    private void safeReadData() throws IOException
+    {
+        try
+        {
+            rs.readData();
+        }
+        catch (TlsFatalAlert e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, e.getAlertDescription());
+            }
+            throw e;
+        }
+   /*     catch (IOException e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+    */    catch (RuntimeException e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+    }
+
+    private void safeWriteMessage(short type, byte[] buf, int offset, int len) throws IOException
+    {
+        try
+        {
+            rs.writeMessage(type, buf, offset, len);
+        }
+        catch (TlsFatalAlert e)
+        {
+            if (!this.closed)
+            {
+                this.failWithError(AlertLevel.fatal, e.getAlertDescription());
+            }
+            throw e;
+        }
+        catch (IOException e)
+        {
+            if (!closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+        catch (RuntimeException e)
+        {
+            if (!closed)
+            {
+                this.failWithError(AlertLevel.fatal, AlertDescription.internal_error);
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Send some application data to the remote system.
+     * &lt;p/&gt;
+     * The method will handle fragmentation internally.
+     *
+     * @param buf The buffer with the data.
+     * @param offset The position in the buffer where the data is placed.
+     * @param len The length of the data.
+     * @throws IOException If something goes wrong during sending.
+     */
+    protected void writeData(byte[] buf, int offset, int len) throws IOException
+    {
+        if (this.closed)
+        {
+            if (this.failedWithError)
+            {
+                throw new IOException(TLS_ERROR_MESSAGE);
+            }
+
+            throw new IOException(&quot;Sorry, connection has been closed, you cannot write more data&quot;);
+        }
+
+        /*
+         * Protect against known IV attack!
+         *
+         * DO NOT REMOVE THIS LINE, EXCEPT YOU KNOW EXACTLY WHAT YOU ARE DOING HERE.
+         */
+        safeWriteMessage(ContentType.application_data, emptybuf, 0, 0);
+
+        do
+        {
+            /*
+             * We are only allowed to write fragments up to 2^14 bytes.
+             */
+            int toWrite = Math.min(len, 1 &lt;&lt; 14);
+
+            safeWriteMessage(ContentType.application_data, buf, offset, toWrite);
+
+            offset += toWrite;
+            len -= toWrite;
+        }
+        while (len &gt; 0);
+
+    }
+
+    /**
+     * @return An OutputStream which can be used to send data.
+     */
+    public OutputStream getOutputStream()
+    {
+        return this.tlsOutputStream;
+    }
+
+    /**
+     * @return An InputStream which can be used to read data.
+     */
+    public InputStream getInputStream()
+    {
+        return this.tlsInputStream;
+    }
+
+    /**
+     * Terminate this connection with an alert.
+     * &lt;p/&gt;
+     * Can be used for normal closure too.
+     *
+     * @param alertLevel The level of the alert, an be AlertLevel.fatal or AL_warning.
+     * @param alertDescription The exact alert message.
+     * @throws IOException If alert was fatal.
+     */
+    private void failWithError(short alertLevel, short alertDescription) throws IOException
+    {
+        /*
+         * Check if the connection is still open.
+         */
+        if (!closed)
+        {
+            /*
+             * Prepare the message
+             */
+            this.closed = true;
+
+            if (alertLevel == AlertLevel.fatal)
+            {
+                /*
+                 * This is a fatal message.
+                 */
+                this.failedWithError = true;
+            }
+            sendAlert(alertLevel, alertDescription);
+            rs.close();
+            if (alertLevel == AlertLevel.fatal)
+            {
+                throw new IOException(TLS_ERROR_MESSAGE);
+            }
+        }
+        else
+        {
+            throw new IOException(TLS_ERROR_MESSAGE);
+        }
+    }
+
+    private void sendAlert(short alertLevel, short alertDescription) throws IOException
+    {
+        byte[] error = new byte[2];
+        error[0] = (byte)alertLevel;
+        error[1] = (byte)alertDescription;
+
+        rs.writeMessage(ContentType.alert, error, 0, 2);
+    }
+
+    /**
+     * Closes this connection.
+     *
+     * @throws IOException If something goes wrong during closing.
+     */
+    public void close() throws IOException
+    {
+        if (!closed)
+        {
+            this.failWithError(AlertLevel.warning, AlertDescription.close_notify);
+        }
+    }
+
+    /**
+     * Make sure the InputStream is now empty. Fail otherwise.
+     *
+     * @param is The InputStream to check.
+     * @throws IOException If is is not empty.
+     */
+    protected void assertEmpty(ByteArrayInputStream is) throws IOException
+    {
+        if (is.available() &gt; 0)
+        {
+            throw new TlsFatalAlert(AlertDescription.decode_error);
+        }
+    }
+
+    protected void flush() throws IOException
+    {
+        rs.flush();
+    }
+
+    private static boolean arrayContains(short[] a, short n)
+    {
+        for (int i = 0; i &lt; a.length; ++i)
+        {
+            if (a[i] == n)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean arrayContains(int[] a, int n)
+    {
+        for (int i = 0; i &lt; a.length; ++i)
+        {
+            if (a[i] == n)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static byte[] createRenegotiationInfo(byte[] renegotiated_connection)
+        throws IOException
+    {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        TlsUtils.writeOpaque8(renegotiated_connection, buf);
+        return buf.toByteArray();
+    }
+
+    private static void writeExtension(OutputStream output, Integer extType, byte[] extValue)
+        throws IOException
+    {
+        TlsUtils.writeUint16(extType.intValue(), output);
+        TlsUtils.writeOpaque16(extValue, output);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsRSAKeyExchange.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,192 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.crypto.InvalidCipherTextException;
+import org.bouncycastle.crypto.encodings.PKCS1Encoding;
+import org.bouncycastle.crypto.engines.RSABlindedEngine;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.util.PublicKeyFactory;
+
+/**
+ * TLS 1.0 RSA key exchange.
+ */
+class TlsRSAKeyExchange implements TlsKeyExchange
+{
+    protected TlsClientContext context;
+
+    protected AsymmetricKeyParameter serverPublicKey = null;
+
+    protected RSAKeyParameters rsaServerPublicKey = null;
+
+    protected byte[] premasterSecret;
+
+    TlsRSAKeyExchange(TlsClientContext context)
+    {
+        this.context = context;
+    }
+
+    public void skipServerCertificate() throws IOException
+    {
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void processServerCertificate(Certificate serverCertificate) throws IOException
+    {
+        X509CertificateStructure x509Cert = serverCertificate.certs[0];
+        SubjectPublicKeyInfo keyInfo = x509Cert.getSubjectPublicKeyInfo();
+
+        try
+        {
+            this.serverPublicKey = PublicKeyFactory.createKey(keyInfo);
+        }
+        catch (RuntimeException e)
+        {
+            throw new TlsFatalAlert(AlertDescription.unsupported_certificate);
+        }
+
+        // Sanity check the PublicKeyFactory
+        if (this.serverPublicKey.isPrivate())
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+
+        this.rsaServerPublicKey = validateRSAPublicKey((RSAKeyParameters)this.serverPublicKey);
+
+        TlsUtils.validateKeyUsage(x509Cert, KeyUsage.keyEncipherment);
+
+        // TODO 
+        /*
+         * Perform various checks per RFC2246 7.4.2: &quot;Unless otherwise specified, the
+         * signing algorithm for the certificate must be the same as the algorithm for the
+         * certificate key.&quot;
+         */
+    }
+
+    public void skipServerKeyExchange() throws IOException
+    {
+        // OK
+    }
+
+    public void processServerKeyExchange(InputStream is)
+        throws IOException
+    {
+        // TODO
+        throw new TlsFatalAlert(AlertDescription.unexpected_message);
+    }
+
+    public void validateCertificateRequest(CertificateRequest certificateRequest)
+        throws IOException
+    {
+        short[] types = certificateRequest.getCertificateTypes();
+        for (int i = 0; i &lt; types.length; ++i)
+        {
+            switch (types[i])
+            {
+                case ClientCertificateType.rsa_sign:
+                case ClientCertificateType.dss_sign:
+                case ClientCertificateType.ecdsa_sign:
+                    break;
+                default:
+                    throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+            }
+        }
+    }
+
+    public void skipClientCredentials() throws IOException
+    {
+        // OK
+    }
+
+    public void processClientCredentials(TlsCredentials clientCredentials) throws IOException
+    {
+        if (!(clientCredentials instanceof TlsSignerCredentials))
+        {
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public void generateClientKeyExchange(OutputStream os) throws IOException
+    {
+        /*
+         * Choose a PremasterSecret and send it encrypted to the server
+         */
+    	
+        premasterSecret = new byte[48];
+        context.getSecureRandom().nextBytes(premasterSecret);
+        TlsUtils.writeVersion(premasterSecret, 0);
+        RSABlindedEngine rbe = new RSABlindedEngine();
+        PKCS1Encoding encoding = new PKCS1Encoding(rbe);
+        encoding.init(true, new ParametersWithRandom(this.rsaServerPublicKey, context.getSecureRandom()));
+
+        try
+        {
+            byte[] keData = encoding.processBlock(premasterSecret, 0, premasterSecret.length);
+            TlsUtils.writeUint24(keData.length + 2, os);
+            TlsUtils.writeOpaque16(keData, os);
+        }
+        catch (InvalidCipherTextException e)
+        {
+            /*
+             * This should never happen, only during decryption.
+             */
+            throw new TlsFatalAlert(AlertDescription.internal_error);
+        }
+    }
+
+    public byte[] generatePremasterSecret() throws IOException
+    {
+        byte[] tmp = this.premasterSecret;
+        this.premasterSecret = null;
+        return tmp;
+    }
+
+    // Would be needed to process RSA_EXPORT server key exchange
+//    protected void processRSAServerKeyExchange(InputStream is, Signer signer) throws IOException
+//    {
+//        InputStream sigIn = is;
+//        if (signer != null)
+//        {
+//            sigIn = new SignerInputStream(is, signer);
+//        }
+//
+//        byte[] modulusBytes = TlsUtils.readOpaque16(sigIn);
+//        byte[] exponentBytes = TlsUtils.readOpaque16(sigIn);
+//
+//        if (signer != null)
+//        {
+//            byte[] sigByte = TlsUtils.readOpaque16(is);
+//
+//            if (!signer.verifySignature(sigByte))
+//            {
+//                handler.failWithError(AlertLevel.fatal, AlertDescription.bad_certificate);
+//            }
+//        }
+//
+//        BigInteger modulus = new BigInteger(1, modulusBytes);
+//        BigInteger exponent = new BigInteger(1, exponentBytes);
+//
+//        this.rsaServerPublicKey = validateRSAPublicKey(new RSAKeyParameters(false, modulus,
+//            exponent));
+//    }
+
+    protected RSAKeyParameters validateRSAPublicKey(RSAKeyParameters key) throws IOException
+    {
+        // TODO What is the minimum bit length required?
+//        key.getModulus().bitLength();
+
+        if (!key.getExponent().isProbablePrime(2))
+        {
+            throw new TlsFatalAlert(AlertDescription.illegal_parameter);
+        }
+
+        return key;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsRSASigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.digests.NullDigest;
+import org.bouncycastle.crypto.encodings.PKCS1Encoding;
+import org.bouncycastle.crypto.engines.RSABlindedEngine;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.ParametersWithRandom;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+import org.bouncycastle.crypto.signers.GenericSigner;
+
+class TlsRSASigner implements TlsSigner
+{
+    public byte[] calculateRawSignature(SecureRandom random, AsymmetricKeyParameter privateKey, byte[] md5andsha1)
+        throws CryptoException
+    {
+        Signer sig = new GenericSigner(new PKCS1Encoding(new RSABlindedEngine()), new NullDigest());
+        sig.init(true, new ParametersWithRandom(privateKey, random));
+        sig.update(md5andsha1, 0, md5andsha1.length);
+        return sig.generateSignature();
+    }
+
+    public Signer createVerifyer(AsymmetricKeyParameter publicKey)
+    {
+        Signer s = new GenericSigner(new PKCS1Encoding(new RSABlindedEngine()), new CombinedHash());
+        s.init(false, publicKey);
+        return s;
+    }
+
+    public boolean isValidPublicKey(AsymmetricKeyParameter publicKey)
+    {
+        return publicKey instanceof RSAKeyParameters &amp;&amp; !publicKey.isPrivate();
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsRuntimeException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,25 @@
+package org.bouncycastle.crypto.tls;
+
+public class TlsRuntimeException extends RuntimeException
+{
+    private static final long serialVersionUID = 1928023487348344086L;
+
+    Throwable e;
+
+    public TlsRuntimeException(String message, Throwable e)
+    {
+        super(message);
+
+        this.e = e;
+    }
+
+    public TlsRuntimeException(String message)
+    {
+        super(message);
+    }
+
+    public Throwable getCause()
+    {
+        return e;
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsSigner.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsSigner.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,17 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.security.SecureRandom;
+
+import org.bouncycastle.crypto.CryptoException;
+import org.bouncycastle.crypto.Signer;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+
+interface TlsSigner
+{
+    byte[] calculateRawSignature(SecureRandom random, AsymmetricKeyParameter privateKey, byte[] md5andsha1)
+        throws CryptoException;
+
+    Signer createVerifyer(AsymmetricKeyParameter publicKey);
+
+    boolean isValidPublicKey(AsymmetricKeyParameter publicKey);
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsSignerCredentials.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,8 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+
+public interface TlsSignerCredentials extends TlsCredentials
+{
+    byte[] generateCertificateSignature(byte[] md5andsha1) throws IOException;
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsSocket.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsSocket.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,44 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+import ewe.net.Socket;
+import ewe.net.UnknownHostException;
+
+
+public class TlsSocket {
+	public Socket socket;
+	public InputStream inputStream;
+	public OutputStream outputStream;
+
+	public TlsSocket(CertificateVerifyer certificateVerifyer, Socket s) throws UnknownHostException, IOException {
+		socket = s;
+
+		if (certificateVerifyer == null) {
+			inputStream = s.getInputStream();
+			outputStream = s.getOutputStream();
+		} else {
+	        OutputStream os = socket.getOutputStream();
+	        InputStream is = socket.getInputStream();
+
+	        TlsProtocolHandler tph = new TlsProtocolHandler(is, os);
+	        tph.connect(certificateVerifyer);
+
+			inputStream  = tph.getInputStream();
+			outputStream = tph.getOutputStream();
+		}
+	}
+
+	public boolean close() {
+		boolean b = true;
+		try {
+			outputStream.close();
+			inputStream.close();
+		} catch (IOException e) {
+			b = false;
+		}
+		boolean a = socket.close();
+		return a &amp;&amp; b;
+	}
+}

Added: trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/tls/TlsUtils.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/TlsUtils.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,319 @@
+package org.bouncycastle.crypto.tls;
+
+import ewe.io.EOFException;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.x509.KeyUsage;
+import org.bouncycastle.asn1.x509.X509CertificateStructure;
+import org.bouncycastle.asn1.x509.X509Extension;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.crypto.Digest;
+import org.bouncycastle.crypto.digests.MD5Digest;
+import org.bouncycastle.crypto.digests.SHA1Digest;
+import org.bouncycastle.crypto.macs.HMac;
+import org.bouncycastle.crypto.params.KeyParameter;
+import org.bouncycastle.util.Strings;
+import org.bouncycastle.util.io.Streams;
+
+/**
+ * Some helper fuctions for MicroTLS.
+ */
+public class TlsUtils
+{
+    protected static void writeUint8(short i, OutputStream os) throws IOException
+    {
+        os.write(i);
+    }
+
+    protected static void writeUint8(short i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)i;
+    }
+
+    protected static void writeUint16(int i, OutputStream os) throws IOException
+    {
+        os.write(i &gt;&gt; 8);
+        os.write(i);
+    }
+
+    protected static void writeUint16(int i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i &gt;&gt; 8);
+        buf[offset + 1] = (byte)i;
+    }
+
+    protected static void writeUint24(int i, OutputStream os) throws IOException
+    {
+        os.write(i &gt;&gt; 16);
+        os.write(i &gt;&gt; 8);
+        os.write(i);
+    }
+
+    protected static void writeUint24(int i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i &gt;&gt; 16);
+        buf[offset + 1] = (byte)(i &gt;&gt; 8);
+        buf[offset + 2] = (byte)(i);
+    }
+
+    protected static void writeUint32(long i, OutputStream os) throws IOException
+    {
+        os.write((int)(i &gt;&gt; 24));
+        os.write((int)(i &gt;&gt; 16));
+        os.write((int)(i &gt;&gt; 8));
+        os.write((int)(i));
+    }
+
+    protected static void writeUint32(long i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i &gt;&gt; 24);
+        buf[offset + 1] = (byte)(i &gt;&gt; 16);
+        buf[offset + 2] = (byte)(i &gt;&gt; 8);
+        buf[offset + 3] = (byte)(i);
+    }
+
+    protected static void writeUint64(long i, OutputStream os) throws IOException
+    {
+        os.write((int)(i &gt;&gt; 56));
+        os.write((int)(i &gt;&gt; 48));
+        os.write((int)(i &gt;&gt; 40));
+        os.write((int)(i &gt;&gt; 32));
+        os.write((int)(i &gt;&gt; 24));
+        os.write((int)(i &gt;&gt; 16));
+        os.write((int)(i &gt;&gt; 8));
+        os.write((int)(i));
+    }
+
+
+    protected static void writeUint64(long i, byte[] buf, int offset)
+    {
+        buf[offset] = (byte)(i &gt;&gt; 56);
+        buf[offset + 1] = (byte)(i &gt;&gt; 48);
+        buf[offset + 2] = (byte)(i &gt;&gt; 40);
+        buf[offset + 3] = (byte)(i &gt;&gt; 32);
+        buf[offset + 4] = (byte)(i &gt;&gt; 24);
+        buf[offset + 5] = (byte)(i &gt;&gt; 16);
+        buf[offset + 6] = (byte)(i &gt;&gt; 8);
+        buf[offset + 7] = (byte)(i);
+    }
+
+    protected static void writeOpaque8(byte[] buf, OutputStream os) throws IOException
+    {
+        writeUint8((short)buf.length, os);
+        os.write(buf);
+    }
+
+    protected static void writeOpaque16(byte[] buf, OutputStream os) throws IOException
+    {
+        writeUint16(buf.length, os);
+        os.write(buf);
+    }
+
+    protected static void writeOpaque24(byte[] buf, OutputStream os) throws IOException
+    {
+        writeUint24(buf.length, os);
+        os.write(buf);
+    }
+
+    protected static void writeUint8Array(short[] uints, OutputStream os) throws IOException
+    {
+        for (int i = 0; i &lt; uints.length; ++i)
+        {
+            writeUint8(uints[i], os);
+        }
+    }
+
+    protected static void writeUint16Array(int[] uints, OutputStream os) throws IOException
+    {
+        for (int i = 0; i &lt; uints.length; ++i)
+        {
+            writeUint16(uints[i], os);
+        }
+    }
+
+    protected static short readUint8(InputStream is) throws IOException
+    {
+        int i = is.read();
+        if (i == -1)
+        {
+            throw new EOFException();
+        }
+        return (short)i;
+    }
+
+    protected static int readUint16(InputStream is) throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        if ((i1 | i2) &lt; 0)
+        {
+            throw new EOFException();
+        }
+        return i1 &lt;&lt; 8 | i2;
+    }
+
+    protected static int readUint24(InputStream is) throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        int i3 = is.read();
+        if ((i1 | i2 | i3) &lt; 0)
+        {
+            throw new EOFException();
+        }
+        return (i1 &lt;&lt; 16) | (i2 &lt;&lt; 8) | i3;
+    }
+
+    protected static long readUint32(InputStream is) throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        int i3 = is.read();
+        int i4 = is.read();
+        if ((i1 | i2 | i3 | i4) &lt; 0)
+        {
+            throw new EOFException();
+        }
+        return (((long)i1) &lt;&lt; 24) | (((long)i2) &lt;&lt; 16) | (((long)i3) &lt;&lt; 8) | ((long)i4);
+    }
+
+    protected static void readFully(byte[] buf, InputStream is) throws IOException
+    {
+        if (Streams.readFully(is, buf) != buf.length)
+        {
+            throw new EOFException();
+        }
+    }
+
+    protected static byte[] readOpaque8(InputStream is) throws IOException
+    {
+        short length = readUint8(is);
+        byte[] value = new byte[length];
+        readFully(value, is);
+        return value;
+    }
+
+    protected static byte[] readOpaque16(InputStream is) throws IOException
+    {
+        int length = readUint16(is);
+        byte[] value = new byte[length];
+        readFully(value, is);
+        return value;
+    }
+
+    protected static void checkVersion(byte[] readVersion, TlsProtocolHandler handler)
+        throws IOException
+    {
+        if ((readVersion[0] != 3) || (readVersion[1] != 1))
+        {
+            throw new TlsFatalAlert(AlertDescription.protocol_version);
+        }
+    }
+
+    protected static void checkVersion(InputStream is, TlsProtocolHandler handler)
+        throws IOException
+    {
+        int i1 = is.read();
+        int i2 = is.read();
+        if ((i1 != 3) || (i2 != 1))
+        {
+            throw new TlsFatalAlert(AlertDescription.protocol_version);
+        }
+    }
+
+    protected static void writeGMTUnixTime(byte[] buf, int offset)
+    {
+        int t = (int)(System.currentTimeMillis() / 1000L);
+        buf[offset] = (byte)(t &gt;&gt; 24);
+        buf[offset + 1] = (byte)(t &gt;&gt; 16);
+        buf[offset + 2] = (byte)(t &gt;&gt; 8);
+        buf[offset + 3] = (byte)t;
+    }
+
+    protected static void writeVersion(OutputStream os) throws IOException
+    {
+        os.write(3);
+        os.write(1);
+    }
+
+    protected static void writeVersion(byte[] buf, int offset) throws IOException
+    {
+        buf[offset] = 3;
+        buf[offset + 1] = 1;
+    }
+
+    private static void hmac_hash(Digest digest, byte[] secret, byte[] seed, byte[] out)
+    {
+        HMac mac = new HMac(digest);
+        KeyParameter param = new KeyParameter(secret);
+        byte[] a = seed;
+        int size = digest.getDigestSize();
+        int iterations = (out.length + size - 1) / size;
+        byte[] buf = new byte[mac.getMacSize()];
+        byte[] buf2 = new byte[mac.getMacSize()];
+        for (int i = 0; i &lt; iterations; i++)
+        {
+            mac.init(param);
+            mac.update(a, 0, a.length);
+            mac.doFinal(buf, 0);
+            a = buf;
+            mac.init(param);
+            mac.update(a, 0, a.length);
+            mac.update(seed, 0, seed.length);
+            mac.doFinal(buf2, 0);
+            System.arraycopy(buf2, 0, out, (size * i), Math.min(size, out.length - (size * i)));
+        }
+    }
+
+    protected static byte[] PRF(byte[] secret, String asciiLabel, byte[] seed, int size)
+    {
+        byte[] label = Strings.toByteArray(asciiLabel);
+
+        int s_half = (secret.length + 1) / 2;
+        byte[] s1 = new byte[s_half];
+        byte[] s2 = new byte[s_half];
+        System.arraycopy(secret, 0, s1, 0, s_half);
+        System.arraycopy(secret, secret.length - s_half, s2, 0, s_half);
+
+        byte[] ls = concat(label, seed);
+
+        byte[] buf = new byte[size];
+        byte[] prf = new byte[size];
+        hmac_hash(new MD5Digest(), s1, ls, prf);
+        hmac_hash(new SHA1Digest(), s2, ls, buf);
+        for (int i = 0; i &lt; size; i++)
+        {
+            buf[i] ^= prf[i];
+        }
+        return buf;
+    }
+
+    static byte[] concat(byte[] a, byte[] b)
+    {
+        byte[] c = new byte[a.length + b.length];
+        System.arraycopy(a, 0, c, 0, a.length);
+        System.arraycopy(b, 0, c, a.length, b.length);
+        return c;
+    }
+
+    static void validateKeyUsage(X509CertificateStructure c, int keyUsageBits) throws IOException
+    {
+        X509Extensions exts = c.getTBSCertificate().getExtensions();
+        if (exts != null)
+        {
+            X509Extension ext = exts.getExtension(X509Extension.keyUsage);
+            if (ext != null)
+            {
+                DERBitString ku = KeyUsage.getInstance(ext);
+                int bits = ku.getBytes()[0] &amp; 0xff;
+                if ((bits &amp; keyUsageBits) != keyUsageBits)
+                {
+                    throw new TlsFatalAlert(AlertDescription.certificate_unknown);
+                }
+            }
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/tls/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/tls/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/tls/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+A lightweight TLS API.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/crypto/util/Pack.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/util/Pack.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/util/Pack.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/util/Pack.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/util/Pack.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,64 @@
+package org.bouncycastle.crypto.util;
+
+public abstract class Pack
+{
+    public static int bigEndianToInt(byte[] bs, int off)
+    {
+        int n = bs[  off] &lt;&lt; 24;
+        n |= (bs[++off] &amp; 0xff) &lt;&lt; 16;
+        n |= (bs[++off] &amp; 0xff) &lt;&lt; 8;
+        n |= (bs[++off] &amp; 0xff);
+        return n;
+    }
+
+    public static void intToBigEndian(int n, byte[] bs, int off)
+    {
+        bs[  off] = (byte)(n &gt;&gt;&gt; 24);
+        bs[++off] = (byte)(n &gt;&gt;&gt; 16);
+        bs[++off] = (byte)(n &gt;&gt;&gt;  8);
+        bs[++off] = (byte)(n       );
+    }
+
+    public static long bigEndianToLong(byte[] bs, int off)
+    {
+        int hi = bigEndianToInt(bs, off);
+        int lo = bigEndianToInt(bs, off + 4);
+        return ((long)(hi &amp; 0xffffffffL) &lt;&lt; 32) | (long)(lo &amp; 0xffffffffL);
+    }
+
+    public static void longToBigEndian(long n, byte[] bs, int off)
+    {
+        intToBigEndian((int)(n &gt;&gt;&gt; 32), bs, off);
+        intToBigEndian((int)(n &amp; 0xffffffffL), bs, off + 4);
+    }
+
+    public static int littleEndianToInt(byte[] bs, int off)
+    {
+        int n = bs[  off];
+        n |= (bs[++off] &amp; 0xff) &lt;&lt; 8;
+        n |= (bs[++off] &amp; 0xff) &lt;&lt; 16;
+        n |= (bs[++off] &amp; 0xff) &lt;&lt; 24;
+        return n;
+    }
+
+    public static void intToLittleEndian(int n, byte[] bs, int off)
+    {
+        bs[  off] = (byte)(n       );
+        bs[++off] = (byte)(n &gt;&gt;&gt;  8);
+        bs[++off] = (byte)(n &gt;&gt;&gt; 16);
+        bs[++off] = (byte)(n &gt;&gt;&gt; 24);
+    }
+
+    public static long littleEndianToLong(byte[] bs, int off)
+    {
+        int lo = littleEndianToInt(bs, off);
+        int hi = littleEndianToInt(bs, off + 4);
+        return ((long)(hi &amp; 0xffffffffL) &lt;&lt; 32) | (long)(lo &amp; 0xffffffffL);
+    }
+
+    public static void longToLittleEndian(long n, byte[] bs, int off)
+    {
+        intToLittleEndian((int)(n &amp; 0xffffffffL), bs, off);
+        intToLittleEndian((int)(n &gt;&gt;&gt; 32), bs, off + 4);
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java
===================================================================
--- trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/util/PublicKeyFactory.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,215 @@
+package org.bouncycastle.crypto.util;
+
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Object;
+import org.bouncycastle.asn1.ASN1OctetString;
+import org.bouncycastle.asn1.ASN1Sequence;
+import org.bouncycastle.asn1.DERBitString;
+import org.bouncycastle.asn1.DEREncodable;
+import org.bouncycastle.asn1.DERInteger;
+import org.bouncycastle.asn1.DERObject;
+import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.DEROctetString;
+import org.bouncycastle.asn1.nist.NISTNamedCurves;
+import org.bouncycastle.asn1.oiw.ElGamalParameter;
+import org.bouncycastle.asn1.oiw.OIWObjectIdentifiers;
+import org.bouncycastle.asn1.pkcs.DHParameter;
+import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
+import org.bouncycastle.asn1.sec.SECNamedCurves;
+import org.bouncycastle.asn1.teletrust.TeleTrusTNamedCurves;
+import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
+import org.bouncycastle.asn1.x509.DSAParameter;
+import org.bouncycastle.asn1.x509.RSAPublicKeyStructure;
+import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
+import org.bouncycastle.asn1.x509.X509ObjectIdentifiers;
+import org.bouncycastle.asn1.x9.DHDomainParameters;
+import org.bouncycastle.asn1.x9.DHPublicKey;
+import org.bouncycastle.asn1.x9.DHValidationParms;
+import org.bouncycastle.asn1.x9.X962NamedCurves;
+import org.bouncycastle.asn1.x9.X962Parameters;
+import org.bouncycastle.asn1.x9.X9ECParameters;
+import org.bouncycastle.asn1.x9.X9ECPoint;
+import org.bouncycastle.asn1.x9.X9ObjectIdentifiers;
+import org.bouncycastle.crypto.params.AsymmetricKeyParameter;
+import org.bouncycastle.crypto.params.DHParameters;
+import org.bouncycastle.crypto.params.DHPublicKeyParameters;
+import org.bouncycastle.crypto.params.DHValidationParameters;
+import org.bouncycastle.crypto.params.DSAParameters;
+import org.bouncycastle.crypto.params.DSAPublicKeyParameters;
+import org.bouncycastle.crypto.params.ECDomainParameters;
+import org.bouncycastle.crypto.params.ECPublicKeyParameters;
+import org.bouncycastle.crypto.params.ElGamalParameters;
+import org.bouncycastle.crypto.params.ElGamalPublicKeyParameters;
+import org.bouncycastle.crypto.params.RSAKeyParameters;
+
+/**
+ * Factory to create asymmetric public key parameters for asymmetric ciphers from range of
+ * ASN.1 encoded SubjectPublicKeyInfo objects.
+ */
+public class PublicKeyFactory
+{
+    /**
+     * Create a public key from a SubjectPublicKeyInfo encoding
+     * 
+     * @param keyInfoData the SubjectPublicKeyInfo encoding
+     * @return the appropriate key parameter
+     * @throws IOException on an error decoding the key
+     */
+    public static AsymmetricKeyParameter createKey(byte[] keyInfoData) throws IOException
+    {
+        return createKey(SubjectPublicKeyInfo.getInstance(ASN1Object.fromByteArray(keyInfoData)));
+    }
+
+    /**
+     * Create a public key from a SubjectPublicKeyInfo encoding read from a stream
+     * 
+     * @param inStr the stream to read the SubjectPublicKeyInfo encoding from
+     * @return the appropriate key parameter
+     * @throws IOException on an error decoding the key
+     */
+    public static AsymmetricKeyParameter createKey(InputStream inStr) throws IOException
+    {
+        return createKey(SubjectPublicKeyInfo.getInstance(new ASN1InputStream(inStr).readObject()));
+    }
+
+    /**
+     * Create a public key from the passed in SubjectPublicKeyInfo
+     * 
+     * @param keyInfo the SubjectPublicKeyInfo containing the key data
+     * @return the appropriate key parameter
+     * @throws IOException on an error decoding the key
+     */
+    public static AsymmetricKeyParameter createKey(SubjectPublicKeyInfo keyInfo) throws IOException
+    {
+        AlgorithmIdentifier algId = keyInfo.getAlgorithmId();
+
+        if (algId.getObjectId().equals(PKCSObjectIdentifiers.rsaEncryption)
+            || algId.getObjectId().equals(X509ObjectIdentifiers.id_ea_rsa))
+        {
+            RSAPublicKeyStructure pubKey = new RSAPublicKeyStructure(
+                (ASN1Sequence)keyInfo.getPublicKey());
+
+            return new RSAKeyParameters(false, pubKey.getModulus(), pubKey.getPublicExponent());
+        }
+        else if (algId.getObjectId().equals(X9ObjectIdentifiers.dhpublicnumber))
+        {
+            DHPublicKey dhPublicKey = DHPublicKey.getInstance(keyInfo.getPublicKey());
+
+            BigInteger y = dhPublicKey.getY().getValue();
+
+            DHDomainParameters dhParams = DHDomainParameters.getInstance(keyInfo.getAlgorithmId().getParameters());
+
+            BigInteger p = dhParams.getP().getValue();
+            BigInteger g = dhParams.getG().getValue();
+            BigInteger q = dhParams.getQ().getValue();
+
+            BigInteger j = null;
+            if (dhParams.getJ() != null)
+            {
+                j = dhParams.getJ().getValue();
+            }
+
+            DHValidationParameters validation = null;
+            DHValidationParms dhValidationParms = dhParams.getValidationParms();
+            if (dhValidationParms != null)
+            {
+                byte[] seed = dhValidationParms.getSeed().getBytes();
+                BigInteger pgenCounter = dhValidationParms.getPgenCounter().getValue();
+
+                // TODO Check pgenCounter size?
+
+                validation = new DHValidationParameters(seed, pgenCounter.intValue());
+            }
+
+            return new DHPublicKeyParameters(y, new DHParameters(p, g, q, j, validation));
+        }
+        else if (algId.getObjectId().equals(PKCSObjectIdentifiers.dhKeyAgreement))
+        {
+            DHParameter params = new DHParameter(
+                (ASN1Sequence)keyInfo.getAlgorithmId().getParameters());
+            DERInteger derY = (DERInteger)keyInfo.getPublicKey();
+
+            BigInteger lVal = params.getL();
+            int l = lVal == null ? 0 : lVal.intValue();
+            DHParameters dhParams = new DHParameters(params.getP(), params.getG(), null, l);
+
+            return new DHPublicKeyParameters(derY.getValue(), dhParams);
+        }
+        else if (algId.getObjectId().equals(OIWObjectIdentifiers.elGamalAlgorithm))
+        {
+            ElGamalParameter params = new ElGamalParameter(
+                (ASN1Sequence)keyInfo.getAlgorithmId().getParameters());
+            DERInteger derY = (DERInteger)keyInfo.getPublicKey();
+
+            return new ElGamalPublicKeyParameters(derY.getValue(), new ElGamalParameters(
+                params.getP(), params.getG()));
+        }
+        else if (algId.getObjectId().equals(X9ObjectIdentifiers.id_dsa)
+            || algId.getObjectId().equals(OIWObjectIdentifiers.dsaWithSHA1))
+        {
+            DERInteger derY = (DERInteger)keyInfo.getPublicKey();
+            DEREncodable de = keyInfo.getAlgorithmId().getParameters();
+
+            DSAParameters parameters = null;
+            if (de != null)
+            {
+                DSAParameter params = DSAParameter.getInstance(de.getDERObject());
+                parameters = new DSAParameters(params.getP(), params.getQ(), params.getG());
+            }
+
+            return new DSAPublicKeyParameters(derY.getValue(), parameters);
+        }
+        else if (algId.getObjectId().equals(X9ObjectIdentifiers.id_ecPublicKey))
+        {
+            X962Parameters params = new X962Parameters(
+                (DERObject)keyInfo.getAlgorithmId().getParameters());
+            ECDomainParameters dParams = null;
+
+            if (params.isNamedCurve())
+            {
+                DERObjectIdentifier oid = (DERObjectIdentifier)params.getParameters();
+                X9ECParameters ecP = X962NamedCurves.getByOID(oid);
+
+                if (ecP == null)
+                {
+                    ecP = SECNamedCurves.getByOID(oid);
+
+                    if (ecP == null)
+                    {
+                        ecP = NISTNamedCurves.getByOID(oid);
+
+                        if (ecP == null)
+                        {
+                            ecP = TeleTrusTNamedCurves.getByOID(oid);
+                        }
+                    }
+                }
+
+                dParams = new ECDomainParameters(ecP.getCurve(), ecP.getG(), ecP.getN(),
+                    ecP.getH(), ecP.getSeed());
+            }
+            else
+            {
+                X9ECParameters ecP = new X9ECParameters((ASN1Sequence)params.getParameters());
+                dParams = new ECDomainParameters(ecP.getCurve(), ecP.getG(), ecP.getN(),
+                    ecP.getH(), ecP.getSeed());
+            }
+
+            DERBitString bits = keyInfo.getPublicKeyData();
+            byte[] data = bits.getBytes();
+            ASN1OctetString key = new DEROctetString(data);
+
+            X9ECPoint derQ = new X9ECPoint(dParams.getCurve(), key);
+
+            return new ECPublicKeyParameters(derQ.getPoint(), dParams);
+        }
+        else
+        {
+            throw new RuntimeException(&quot;algorithm identifier in key not recognised&quot;);
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/crypto/util/package.html
===================================================================
--- trunk/src/org/bouncycastle/crypto/util/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/crypto/util/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Some general utility/conversion classes.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECAlgorithms.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECAlgorithms.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,92 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+public class ECAlgorithms
+{
+    public static ECPoint sumOfTwoMultiplies(ECPoint P, BigInteger a,
+        ECPoint Q, BigInteger b)
+    {
+        ECCurve c = P.getCurve();
+        if (!c.equals(Q.getCurve()))
+        {
+            throw new IllegalArgumentException(&quot;P and Q must be on same curve&quot;);
+        }
+
+        // Point multiplication for Koblitz curves (using WTNAF) beats Shamir's trick
+        if (c instanceof ECCurve.F2m)
+        {
+            ECCurve.F2m f2mCurve = (ECCurve.F2m)c;
+            if (f2mCurve.isKoblitz())
+            {
+                return P.multiply(a).add(Q.multiply(b));
+            }
+        }
+
+        return implShamirsTrick(P, a, Q, b);
+    }
+
+    /*
+     * &quot;Shamir's Trick&quot;, originally due to E. G. Straus
+     * (Addition chains of vectors. American Mathematical Monthly,
+     * 71(7):806-808, Aug./Sept. 1964)
+     * &lt;pre&gt;
+     * Input: The points P, Q, scalar k = (km?, ... , k1, k0)
+     * and scalar l = (lm?, ... , l1, l0).
+     * Output: R = k * P + l * Q.
+     * 1: Z &lt;- P + Q
+     * 2: R &lt;- O
+     * 3: for i from m-1 down to 0 do
+     * 4:        R &lt;- R + R        {point doubling}
+     * 5:        if (ki = 1) and (li = 0) then R &lt;- R + P end if
+     * 6:        if (ki = 0) and (li = 1) then R &lt;- R + Q end if
+     * 7:        if (ki = 1) and (li = 1) then R &lt;- R + Z end if
+     * 8: end for
+     * 9: return R
+     * &lt;/pre&gt;
+     */
+    public static ECPoint shamirsTrick(ECPoint P, BigInteger k,
+        ECPoint Q, BigInteger l)
+    {
+        if (!P.getCurve().equals(Q.getCurve()))
+        {
+            throw new IllegalArgumentException(&quot;P and Q must be on same curve&quot;);
+        }
+
+        return implShamirsTrick(P, k, Q, l);
+    }
+
+    private static ECPoint implShamirsTrick(ECPoint P, BigInteger k,
+        ECPoint Q, BigInteger l)
+    {
+        int m = Math.max(k.bitLength(), l.bitLength());
+        ECPoint Z = P.add(Q);
+        ECPoint R = P.getCurve().getInfinity();
+
+        for (int i = m - 1; i &gt;= 0; --i)
+        {
+            R = R.twice();
+
+            if (k.testBit(i))
+            {
+                if (l.testBit(i))
+                {
+                    R = R.add(Z);
+                }
+                else
+                {
+                    R = R.add(P);
+                }
+            }
+            else
+            {
+                if (l.testBit(i))
+                {
+                    R = R.add(Q);
+                }
+            }
+        }
+
+        return R;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ECConstants.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECConstants.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECConstants.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECConstants.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECConstants.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+public interface ECConstants
+{
+    public static final BigInteger ZERO = BigInteger.valueOf(0);
+    public static final BigInteger ONE = BigInteger.valueOf(1);
+    public static final BigInteger TWO = BigInteger.valueOf(2);
+    public static final BigInteger THREE = BigInteger.valueOf(3);
+    public static final BigInteger FOUR = BigInteger.valueOf(4);
+}

Added: trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECCurve$F2m.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECCurve$Fp.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECCurve.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECCurve.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECCurve.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECCurve.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECCurve.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,668 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+import ewe.util.Random;
+
+/**
+ * base class for an elliptic curve
+ */
+public abstract class ECCurve
+{
+    ECFieldElement a, b;
+
+    public abstract int getFieldSize();
+
+    public abstract ECFieldElement fromBigInteger(BigInteger x);
+
+    public abstract ECPoint createPoint(BigInteger x, BigInteger y, boolean withCompression);
+
+    public abstract ECPoint decodePoint(byte[] encoded);
+
+    public abstract ECPoint getInfinity();
+
+    public ECFieldElement getA()
+    {
+        return a;
+    }
+
+    public ECFieldElement getB()
+    {
+        return b;
+    }
+
+    /**
+     * Elliptic curve over Fp
+     */
+    public static class Fp extends ECCurve
+    {
+        BigInteger q;
+        ECPoint.Fp infinity;
+
+        public Fp(BigInteger q, BigInteger a, BigInteger b)
+        {
+            this.q = q;
+            this.a = fromBigInteger(a);
+            this.b = fromBigInteger(b);
+            this.infinity = new ECPoint.Fp(this, null, null);
+        }
+
+        public BigInteger getQ()
+        {
+            return q;
+        }
+
+        public int getFieldSize()
+        {
+            return q.bitLength();
+        }
+
+        public ECFieldElement fromBigInteger(BigInteger x)
+        {
+            return new ECFieldElement.Fp(this.q, x);
+        }
+
+        public ECPoint createPoint(BigInteger x, BigInteger y, boolean withCompression)
+        {
+            return new ECPoint.Fp(this, fromBigInteger(x), fromBigInteger(y), withCompression);
+        }
+
+        /**
+         * Decode a point on this curve from its ASN.1 encoding. The different
+         * encodings are taken account of, including point compression for
+         * &lt;code&gt;F&lt;sub&gt;p&lt;/sub&gt;&lt;/code&gt; (X9.62 s 4.2.1 pg 17).
+         * @return The decoded point.
+         */
+        public ECPoint decodePoint(byte[] encoded)
+        {
+            ECPoint p = null;
+
+            switch (encoded[0])
+            {
+                // infinity
+            case 0x00:
+                if (encoded.length &gt; 1)
+                {
+                    throw new RuntimeException(&quot;Invalid point encoding&quot;);
+                }
+                p = getInfinity();
+                break;
+                // compressed
+            case 0x02:
+            case 0x03:
+                int ytilde = encoded[0] &amp; 1;
+                byte[]  i = new byte[encoded.length - 1];
+
+                System.arraycopy(encoded, 1, i, 0, i.length);
+
+                ECFieldElement x = new ECFieldElement.Fp(this.q, new BigInteger(1, i));
+                ECFieldElement alpha = x.multiply(x.square().add(a)).add(b);
+                ECFieldElement beta = alpha.sqrt();
+
+                //
+                // if we can't find a sqrt we haven't got a point on the
+                // curve - run!
+                //
+                if (beta == null)
+                {
+                    throw new RuntimeException(&quot;Invalid point compression&quot;);
+                }
+
+                int bit0 = (beta.toBigInteger().testBit(0) ? 1 : 0);
+
+                if (bit0 == ytilde)
+                {
+                    p = new ECPoint.Fp(this, x, beta, true);
+                }
+                else
+                {
+                    p = new ECPoint.Fp(this, x,
+                        new ECFieldElement.Fp(this.q, q.subtract(beta.toBigInteger())), true);
+                }
+                break;
+                // uncompressed
+            case 0x04:
+                // hybrid
+            case 0x06:
+            case 0x07:
+                byte[]  xEnc = new byte[(encoded.length - 1) / 2];
+                byte[]  yEnc = new byte[(encoded.length - 1) / 2];
+
+                System.arraycopy(encoded, 1, xEnc, 0, xEnc.length);
+                System.arraycopy(encoded, xEnc.length + 1, yEnc, 0, yEnc.length);
+
+                p = new ECPoint.Fp(this,
+                        new ECFieldElement.Fp(this.q, new BigInteger(1, xEnc)),
+                        new ECFieldElement.Fp(this.q, new BigInteger(1, yEnc)));
+                break;
+            default:
+                throw new RuntimeException(&quot;Invalid point encoding 0x&quot; + Integer.toString(encoded[0], 16));
+            }
+
+            return p;
+        }
+
+        public ECPoint getInfinity()
+        {
+            return infinity;
+        }
+
+        public boolean equals(
+            Object anObject) 
+        {
+            if (anObject == this) 
+            {
+                return true;
+            }
+
+            if (!(anObject instanceof ECCurve.Fp)) 
+            {
+                return false;
+            }
+
+            ECCurve.Fp other = (ECCurve.Fp) anObject;
+
+            return this.q.equals(other.q) 
+                    &amp;&amp; a.equals(other.a) &amp;&amp; b.equals(other.b);
+        }
+
+        public int hashCode() 
+        {
+            return a.hashCode() ^ b.hashCode() ^ q.hashCode();
+        }
+    }
+
+    /**
+     * Elliptic curves over F2m. The Weierstrass equation is given by
+     * &lt;code&gt;y&lt;sup&gt;2&lt;/sup&gt; + xy = x&lt;sup&gt;3&lt;/sup&gt; + ax&lt;sup&gt;2&lt;/sup&gt; + b&lt;/code&gt;.
+     */
+    public static class F2m extends ECCurve
+    {
+        /**
+         * The exponent &lt;code&gt;m&lt;/code&gt; of &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         */
+        private int m;  // can't be final - JDK 1.1
+
+        /**
+         * TPB: The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction polynomial
+         * &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        private int k1;  // can't be final - JDK 1.1
+
+        /**
+         * TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        private int k2;  // can't be final - JDK 1.1
+
+        /**
+         * TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        private int k3;  // can't be final - JDK 1.1
+
+        /**
+         * The order of the base point of the curve.
+         */
+        private BigInteger n;  // can't be final - JDK 1.1
+
+        /**
+         * The cofactor of the curve.
+         */
+        private BigInteger h;  // can't be final - JDK 1.1
+        
+         /**
+         * The point at infinity on this curve.
+         */
+        private ECPoint.F2m infinity;  // can't be final - JDK 1.1
+
+        /**
+         * The parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve if this is
+         * a Koblitz curve.
+         */
+        private byte mu = 0;
+
+        /**
+         * The auxiliary values &lt;code&gt;s&lt;sub&gt;0&lt;/sub&gt;&lt;/code&gt; and
+         * &lt;code&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; used for partial modular reduction for
+         * Koblitz curves.
+         */
+        private BigInteger[] si = null;
+
+        /**
+         * Constructor for Trinomial Polynomial Basis (TPB).
+         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param k The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction
+         * polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param a The coefficient &lt;code&gt;a&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param b The coefficient &lt;code&gt;b&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         */
+        public F2m(
+            int m,
+            int k,
+            BigInteger a,
+            BigInteger b)
+        {
+            this(m, k, 0, 0, a, b, null, null);
+        }
+
+        /**
+         * Constructor for Trinomial Polynomial Basis (TPB).
+         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param k The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction
+         * polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param a The coefficient &lt;code&gt;a&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param b The coefficient &lt;code&gt;b&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param n The order of the main subgroup of the elliptic curve.
+         * @param h The cofactor of the elliptic curve, i.e.
+         * &lt;code&gt;#E&lt;sub&gt;a&lt;/sub&gt;(F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;) = h * n&lt;/code&gt;.
+         */
+        public F2m(
+            int m, 
+            int k, 
+            BigInteger a, 
+            BigInteger b,
+            BigInteger n,
+            BigInteger h)
+        {
+            this(m, k, 0, 0, a, b, n, h);
+        }
+
+        /**
+         * Constructor for Pentanomial Polynomial Basis (PPB).
+         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param k1 The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param k2 The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param k3 The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param a The coefficient &lt;code&gt;a&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param b The coefficient &lt;code&gt;b&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         */
+        public F2m(
+            int m,
+            int k1,
+            int k2,
+            int k3,
+            BigInteger a,
+            BigInteger b)
+        {
+            this(m, k1, k2, k3, a, b, null, null);
+        }
+
+        /**
+         * Constructor for Pentanomial Polynomial Basis (PPB).
+         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param k1 The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param k2 The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param k3 The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param a The coefficient &lt;code&gt;a&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param b The coefficient &lt;code&gt;b&lt;/code&gt; in the Weierstrass equation
+         * for non-supersingular elliptic curves over
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param n The order of the main subgroup of the elliptic curve.
+         * @param h The cofactor of the elliptic curve, i.e.
+         * &lt;code&gt;#E&lt;sub&gt;a&lt;/sub&gt;(F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;) = h * n&lt;/code&gt;.
+         */
+        public F2m(
+            int m, 
+            int k1, 
+            int k2, 
+            int k3,
+            BigInteger a, 
+            BigInteger b,
+            BigInteger n,
+            BigInteger h)
+        {
+            this.m = m;
+            this.k1 = k1;
+            this.k2 = k2;
+            this.k3 = k3;
+            this.n = n;
+            this.h = h;
+
+            if (k1 == 0)
+            {
+                throw new IllegalArgumentException(&quot;k1 must be &gt; 0&quot;);
+            }
+
+            if (k2 == 0)
+            {
+                if (k3 != 0)
+                {
+                    throw new IllegalArgumentException(&quot;k3 must be 0 if k2 == 0&quot;);
+                }
+            }
+            else
+            {
+                if (k2 &lt;= k1)
+                {
+                    throw new IllegalArgumentException(&quot;k2 must be &gt; k1&quot;);
+                }
+
+                if (k3 &lt;= k2)
+                {
+                    throw new IllegalArgumentException(&quot;k3 must be &gt; k2&quot;);
+                }
+            }
+
+            this.a = fromBigInteger(a);
+            this.b = fromBigInteger(b);
+            this.infinity = new ECPoint.F2m(this, null, null);
+        }
+
+        public int getFieldSize()
+        {
+            return m;
+        }
+
+        public ECFieldElement fromBigInteger(BigInteger x)
+        {
+            return new ECFieldElement.F2m(this.m, this.k1, this.k2, this.k3, x);
+        }
+
+        public ECPoint createPoint(BigInteger x, BigInteger y, boolean withCompression)
+        {
+            return new ECPoint.F2m(this, fromBigInteger(x), fromBigInteger(y), withCompression);
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECCurve#decodePoint(byte[])
+         */
+        public ECPoint decodePoint(byte[] encoded)
+        {
+            ECPoint p = null;
+
+            switch (encoded[0])
+            {
+                // infinity
+            case 0x00:
+                if (encoded.length &gt; 1)
+                {
+                    throw new RuntimeException(&quot;Invalid point encoding&quot;);
+                }
+                p = getInfinity();
+                break;
+                // compressed
+            case 0x02:
+            case 0x03:
+                byte[] enc = new byte[encoded.length - 1];
+                System.arraycopy(encoded, 1, enc, 0, enc.length);
+                if (encoded[0] == 0x02) 
+                {
+                        p = decompressPoint(enc, 0);
+                }
+                else 
+                {
+                        p = decompressPoint(enc, 1);
+                }
+                break;
+                // uncompressed
+            case 0x04:
+                // hybrid
+            case 0x06:
+            case 0x07:
+                byte[] xEnc = new byte[(encoded.length - 1) / 2];
+                byte[] yEnc = new byte[(encoded.length - 1) / 2];
+
+                System.arraycopy(encoded, 1, xEnc, 0, xEnc.length);
+                System.arraycopy(encoded, xEnc.length + 1, yEnc, 0, yEnc.length);
+
+                p = new ECPoint.F2m(this,
+                    new ECFieldElement.F2m(this.m, this.k1, this.k2, this.k3,
+                        new BigInteger(1, xEnc)),
+                    new ECFieldElement.F2m(this.m, this.k1, this.k2, this.k3,
+                        new BigInteger(1, yEnc)), false);
+                break;
+
+            default:
+                throw new RuntimeException(&quot;Invalid point encoding 0x&quot; + Integer.toString(encoded[0], 16));
+            }
+
+            return p;
+        }
+
+        public ECPoint getInfinity()
+        {
+            return infinity;
+        }
+
+        /**
+         * Returns true if this is a Koblitz curve (ABC curve).
+         * @return true if this is a Koblitz curve (ABC curve), false otherwise
+         */
+        public boolean isKoblitz()
+        {
+            return ((n != null) &amp;&amp; (h != null) &amp;&amp;
+                    ((a.toBigInteger().equals(ECConstants.ZERO)) ||
+                    (a.toBigInteger().equals(ECConstants.ONE))) &amp;&amp;
+                    (b.toBigInteger().equals(ECConstants.ONE)));
+        }
+
+        /**
+         * Returns the parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+         * @return &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+         * @throws IllegalArgumentException if the given ECCurve is not a
+         * Koblitz curve.
+         */
+        synchronized byte getMu()
+        {
+            if (mu == 0)
+            {
+                mu = Tnaf.getMu(this);
+            }
+            return mu;
+        }
+
+        /**
+         * @return the auxiliary values &lt;code&gt;s&lt;sub&gt;0&lt;/sub&gt;&lt;/code&gt; and
+         * &lt;code&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; used for partial modular reduction for
+         * Koblitz curves.
+         */
+        synchronized BigInteger[] getSi()
+        {
+            if (si == null)
+            {
+                si = Tnaf.getSi(this);
+            }
+            return si;
+        }
+
+        /**
+         * Decompresses a compressed point P = (xp, yp) (X9.62 s 4.2.2).
+         * 
+         * @param xEnc
+         *            The encoding of field element xp.
+         * @param ypBit
+         *            ~yp, an indication bit for the decompression of yp.
+         * @return the decompressed point.
+         */
+        private ECPoint decompressPoint(
+            byte[] xEnc, 
+            int ypBit)
+        {
+            ECFieldElement xp = new ECFieldElement.F2m(
+                    this.m, this.k1, this.k2, this.k3, new BigInteger(1, xEnc));
+            ECFieldElement yp = null;
+            if (xp.toBigInteger().equals(ECConstants.ZERO))
+            {
+                yp = (ECFieldElement.F2m)b;
+                for (int i = 0; i &lt; m - 1; i++)
+                {
+                    yp = yp.square();
+                }
+            }
+            else
+            {
+                ECFieldElement beta = xp.add(a).add(
+                        b.multiply(xp.square().invert()));
+                ECFieldElement z = solveQuadradicEquation(beta);
+                if (z == null)
+                {
+                    throw new RuntimeException(&quot;Invalid point compression&quot;);
+                }
+                int zBit = 0;
+                if (z.toBigInteger().testBit(0))
+                {
+                    zBit = 1;
+                }
+                if (zBit != ypBit)
+                {
+                    z = z.add(new ECFieldElement.F2m(this.m, this.k1, this.k2,
+                            this.k3, ECConstants.ONE));
+                }
+                yp = xp.multiply(z);
+            }
+            
+            return new ECPoint.F2m(this, xp, yp);
+        }
+        
+        /**
+         * Solves a quadratic equation &lt;code&gt;z&lt;sup&gt;2&lt;/sup&gt; + z = beta&lt;/code&gt;(X9.62
+         * D.1.6) The other solution is &lt;code&gt;z + 1&lt;/code&gt;.
+         * 
+         * @param beta
+         *            The value to solve the qradratic equation for.
+         * @return the solution for &lt;code&gt;z&lt;sup&gt;2&lt;/sup&gt; + z = beta&lt;/code&gt; or
+         *         &lt;code&gt;null&lt;/code&gt; if no solution exists.
+         */
+        private ECFieldElement solveQuadradicEquation(ECFieldElement beta)
+        {
+            ECFieldElement zeroElement = new ECFieldElement.F2m(
+                    this.m, this.k1, this.k2, this.k3, ECConstants.ZERO);
+
+            if (beta.toBigInteger().equals(ECConstants.ZERO))
+            {
+                return zeroElement;
+            }
+
+            ECFieldElement z = null;
+            ECFieldElement gamma = zeroElement;
+
+            Random rand = new Random();
+            do
+            {
+                ECFieldElement t = new ECFieldElement.F2m(this.m, this.k1,
+                        this.k2, this.k3, new BigInteger(m, rand));
+                z = zeroElement;
+                ECFieldElement w = beta;
+                for (int i = 1; i &lt;= m - 1; i++)
+                {
+                    ECFieldElement w2 = w.square();
+                    z = z.square().add(w2.multiply(t));
+                    w = w2.add(beta);
+                }
+                if (!w.toBigInteger().equals(ECConstants.ZERO))
+                {
+                    return null;
+                }
+                gamma = z.square().add(z);
+            }
+            while (gamma.toBigInteger().equals(ECConstants.ZERO));
+
+            return z;
+        }
+        
+        public boolean equals(
+            Object anObject)
+        {
+            if (anObject == this) 
+            {
+                return true;
+            }
+
+            if (!(anObject instanceof ECCurve.F2m)) 
+            {
+                return false;
+            }
+
+            ECCurve.F2m other = (ECCurve.F2m)anObject;
+            
+            return (this.m == other.m) &amp;&amp; (this.k1 == other.k1)
+                &amp;&amp; (this.k2 == other.k2) &amp;&amp; (this.k3 == other.k3)
+                &amp;&amp; a.equals(other.a) &amp;&amp; b.equals(other.b);
+        }
+
+        public int hashCode()
+        {
+            return this.a.hashCode() ^ this.b.hashCode() ^ m ^ k1 ^ k2 ^ k3;
+        }
+
+        public int getM()
+        {
+            return m;
+        }
+
+        /**
+         * Return true if curve uses a Trinomial basis.
+         * 
+         * @return true if curve Trinomial, false otherwise.
+         */
+        public boolean isTrinomial()
+        {
+            return k2 == 0 &amp;&amp; k3 == 0;
+        }
+        
+        public int getK1()
+        {
+            return k1;
+        }
+
+        public int getK2()
+        {
+            return k2;
+        }
+
+        public int getK3()
+        {
+            return k3;
+        }
+
+        public BigInteger getN()
+        {
+            return n;
+        }
+
+        public BigInteger getH()
+        {
+            return h;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECFieldElement$F2m.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECFieldElement$Fp.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECFieldElement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECFieldElement.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECFieldElement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECFieldElement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,1196 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+import ewe.util.Random;
+
+public abstract class ECFieldElement
+    implements ECConstants
+{
+
+    public abstract BigInteger     toBigInteger();
+    public abstract String         getFieldName();
+    public abstract int            getFieldSize();
+    public abstract ECFieldElement add(ECFieldElement b);
+    public abstract ECFieldElement subtract(ECFieldElement b);
+    public abstract ECFieldElement multiply(ECFieldElement b);
+    public abstract ECFieldElement divide(ECFieldElement b);
+    public abstract ECFieldElement negate();
+    public abstract ECFieldElement square();
+    public abstract ECFieldElement invert();
+    public abstract ECFieldElement sqrt();
+
+    public String toString()
+    {
+        return this.toBigInteger().toString(2);
+    }
+
+    public static class Fp extends ECFieldElement
+    {
+        BigInteger x;
+
+        BigInteger q;
+        
+        public Fp(BigInteger q, BigInteger x)
+        {
+            this.x = x;
+            
+            if (x.compareTo(q) &gt;= 0)
+            {
+                throw new IllegalArgumentException(&quot;x value too large in field element&quot;);
+            }
+
+            this.q = q;
+        }
+
+        public BigInteger toBigInteger()
+        {
+            return x;
+        }
+
+        /**
+         * return the field name for this field.
+         *
+         * @return the string &quot;Fp&quot;.
+         */
+        public String getFieldName()
+        {
+            return &quot;Fp&quot;;
+        }
+
+        public int getFieldSize()
+        {
+            return q.bitLength();
+        }
+
+        public BigInteger getQ()
+        {
+            return q;
+        }
+        
+        public ECFieldElement add(ECFieldElement b)
+        {
+            return new Fp(q, x.add(b.toBigInteger()).mod(q));
+        }
+
+        public ECFieldElement subtract(ECFieldElement b)
+        {
+            return new Fp(q, x.subtract(b.toBigInteger()).mod(q));
+        }
+
+        public ECFieldElement multiply(ECFieldElement b)
+        {
+            return new Fp(q, x.multiply(b.toBigInteger()).mod(q));
+        }
+
+        public ECFieldElement divide(ECFieldElement b)
+        {
+            return new Fp(q, x.multiply(b.toBigInteger().modInverse(q)).mod(q));
+        }
+
+        public ECFieldElement negate()
+        {
+            return new Fp(q, x.negate().mod(q));
+        }
+
+        public ECFieldElement square()
+        {
+            return new Fp(q, x.multiply(x).mod(q));
+        }
+
+        public ECFieldElement invert()
+        {
+            return new Fp(q, x.modInverse(q));
+        }
+
+        // D.1.4 91
+        /**
+         * return a sqrt root - the routine verifies that the calculation
+         * returns the right value - if none exists it returns null.
+         */
+        public ECFieldElement sqrt()
+        {
+            if (!q.testBit(0))
+            {
+                throw new RuntimeException(&quot;not done yet&quot;);
+            }
+
+            // note: even though this class implements ECConstants don't be tempted to
+            // remove the explicit declaration, some J2ME environments don't cope.
+            // p mod 4 == 3
+            if (q.testBit(1))
+            {
+                // z = g^(u+1) + p, p = 4u + 3
+                ECFieldElement z = new Fp(q, x.modPow(q.shiftRight(2).add(ECConstants.ONE), q));
+
+                return z.square().equals(this) ? z : null;
+            }
+
+            // p mod 4 == 1
+            BigInteger qMinusOne = q.subtract(ECConstants.ONE);
+
+            BigInteger legendreExponent = qMinusOne.shiftRight(1);
+            if (!(x.modPow(legendreExponent, q).equals(ECConstants.ONE)))
+            {
+                return null;
+            }
+
+            BigInteger u = qMinusOne.shiftRight(2);
+            BigInteger k = u.shiftLeft(1).add(ECConstants.ONE);
+
+            BigInteger Q = this.x;
+            BigInteger fourQ = Q.shiftLeft(2).mod(q);
+
+            BigInteger U, V;
+            Random rand = new Random();
+            do
+            {
+                BigInteger P;
+                do
+                {
+                    P = new BigInteger(q.bitLength(), rand);
+                }
+                while (P.compareTo(q) &gt;= 0
+                    || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, q).equals(qMinusOne)));
+
+                BigInteger[] result = lucasSequence(q, P, Q, k);
+                U = result[0];
+                V = result[1];
+
+                if (V.multiply(V).mod(q).equals(fourQ))
+                {
+                    // Integer division by 2, mod q
+                    if (V.testBit(0))
+                    {
+                        V = V.add(q);
+                    }
+
+                    V = V.shiftRight(1);
+
+                    //assert V.multiply(V).mod(q).equals(x);
+
+                    return new ECFieldElement.Fp(q, V);
+                }
+            }
+            while (U.equals(ECConstants.ONE) || U.equals(qMinusOne));
+
+            return null;
+
+//            BigInteger qMinusOne = q.subtract(ECConstants.ONE);
+//            BigInteger legendreExponent = qMinusOne.shiftRight(1); //divide(ECConstants.TWO);
+//            if (!(x.modPow(legendreExponent, q).equals(ECConstants.ONE)))
+//            {
+//                return null;
+//            }
+//
+//            Random rand = new Random();
+//            BigInteger fourX = x.shiftLeft(2);
+//
+//            BigInteger r;
+//            do
+//            {
+//                r = new BigInteger(q.bitLength(), rand);
+//            }
+//            while (r.compareTo(q) &gt;= 0
+//                || !(r.multiply(r).subtract(fourX).modPow(legendreExponent, q).equals(qMinusOne)));
+//
+//            BigInteger n1 = qMinusOne.shiftRight(2); //.divide(ECConstants.FOUR);
+//            BigInteger n2 = n1.add(ECConstants.ONE); //q.add(ECConstants.THREE).divide(ECConstants.FOUR);
+//
+//            BigInteger wOne = WOne(r, x, q);
+//            BigInteger wSum = W(n1, wOne, q).add(W(n2, wOne, q)).mod(q);
+//            BigInteger twoR = r.shiftLeft(1); //ECConstants.TWO.multiply(r);
+//
+//            BigInteger root = twoR.modPow(q.subtract(ECConstants.TWO), q)
+//                .multiply(x).mod(q)
+//                .multiply(wSum).mod(q);
+//
+//            return new Fp(q, root);
+        }
+
+//        private static BigInteger W(BigInteger n, BigInteger wOne, BigInteger p)
+//        {
+//            if (n.equals(ECConstants.ONE))
+//            {
+//                return wOne;
+//            }
+//            boolean isEven = !n.testBit(0);
+//            n = n.shiftRight(1);//divide(ECConstants.TWO);
+//            if (isEven)
+//            {
+//                BigInteger w = W(n, wOne, p);
+//                return w.multiply(w).subtract(ECConstants.TWO).mod(p);
+//            }
+//            BigInteger w1 = W(n.add(ECConstants.ONE), wOne, p);
+//            BigInteger w2 = W(n, wOne, p);
+//            return w1.multiply(w2).subtract(wOne).mod(p);
+//        }
+//
+//        private BigInteger WOne(BigInteger r, BigInteger x, BigInteger p)
+//        {
+//            return r.multiply(r).multiply(x.modPow(q.subtract(ECConstants.TWO), q)).subtract(ECConstants.TWO).mod(p);
+//        }
+
+        private static BigInteger[] lucasSequence(
+            BigInteger  p,
+            BigInteger  P,
+            BigInteger  Q,
+            BigInteger  k)
+        {
+            int n = k.bitLength();
+            int s = k.getLowestSetBit();
+
+            BigInteger Uh = ECConstants.ONE;
+            BigInteger Vl = ECConstants.TWO;
+            BigInteger Vh = P;
+            BigInteger Ql = ECConstants.ONE;
+            BigInteger Qh = ECConstants.ONE;
+
+            for (int j = n - 1; j &gt;= s + 1; --j)
+            {
+                Ql = Ql.multiply(Qh).mod(p);
+
+                if (k.testBit(j))
+                {
+                    Qh = Ql.multiply(Q).mod(p);
+                    Uh = Uh.multiply(Vh).mod(p);
+                    Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
+                    Vh = Vh.multiply(Vh).subtract(Qh.shiftLeft(1)).mod(p);
+                }
+                else
+                {
+                    Qh = Ql;
+                    Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
+                    Vh = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
+                    Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
+                }
+            }
+
+            Ql = Ql.multiply(Qh).mod(p);
+            Qh = Ql.multiply(Q).mod(p);
+            Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
+            Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
+            Ql = Ql.multiply(Qh).mod(p);
+
+            for (int j = 1; j &lt;= s; ++j)
+            {
+                Uh = Uh.multiply(Vl).mod(p);
+                Vl = Vl.multiply(Vl).subtract(Ql.shiftLeft(1)).mod(p);
+                Ql = Ql.multiply(Ql).mod(p);
+            }
+
+            return new BigInteger[]{ Uh, Vl };
+        }
+        
+        public boolean equals(Object other)
+        {
+            if (other == this)
+            {
+                return true;
+            }
+
+            if (!(other instanceof ECFieldElement.Fp))
+            {
+                return false;
+            }
+            
+            ECFieldElement.Fp o = (ECFieldElement.Fp)other;
+            return q.equals(o.q) &amp;&amp; x.equals(o.x);
+        }
+
+        public int hashCode()
+        {
+            return q.hashCode() ^ x.hashCode();
+        }
+    }
+
+//    /**
+//     * Class representing the Elements of the finite field
+//     * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt; in polynomial basis (PB)
+//     * representation. Both trinomial (TPB) and pentanomial (PPB) polynomial
+//     * basis representations are supported. Gaussian normal basis (GNB)
+//     * representation is not supported.
+//     */
+//    public static class F2m extends ECFieldElement
+//    {
+//        BigInteger x;
+//
+//        /**
+//         * Indicates gaussian normal basis representation (GNB). Number chosen
+//         * according to X9.62. GNB is not implemented at present.
+//         */
+//        public static final int GNB = 1;
+//
+//        /**
+//         * Indicates trinomial basis representation (TPB). Number chosen
+//         * according to X9.62.
+//         */
+//        public static final int TPB = 2;
+//
+//        /**
+//         * Indicates pentanomial basis representation (PPB). Number chosen
+//         * according to X9.62.
+//         */
+//        public static final int PPB = 3;
+//
+//        /**
+//         * TPB or PPB.
+//         */
+//        private int representation;
+//
+//        /**
+//         * The exponent &lt;code&gt;m&lt;/code&gt; of &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+//         */
+//        private int m;
+//
+//        /**
+//         * TPB: The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction polynomial
+//         * &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         * PPB: The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         */
+//        private int k1;
+//
+//        /**
+//         * TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+//         * PPB: The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         */
+//        private int k2;
+//
+//        /**
+//         * TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+//         * PPB: The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         */
+//        private int k3;
+//        
+//        /**
+//         * Constructor for PPB.
+//         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+//         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+//         * @param k1 The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+//         * @param k2 The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+//         * @param k3 The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+//         * @param x The BigInteger representing the value of the field element.
+//         */
+//        public F2m(
+//            int m, 
+//            int k1, 
+//            int k2, 
+//            int k3,
+//            BigInteger x)
+//        {
+////            super(x);
+//            this.x = x;
+//
+//            if ((k2 == 0) &amp;&amp; (k3 == 0))
+//            {
+//                this.representation = TPB;
+//            }
+//            else
+//            {
+//                if (k2 &gt;= k3)
+//                {
+//                    throw new IllegalArgumentException(
+//                            &quot;k2 must be smaller than k3&quot;);
+//                }
+//                if (k2 &lt;= 0)
+//                {
+//                    throw new IllegalArgumentException(
+//                            &quot;k2 must be larger than 0&quot;);
+//                }
+//                this.representation = PPB;
+//            }
+//
+//            if (x.signum() &lt; 0)
+//            {
+//                throw new IllegalArgumentException(&quot;x value cannot be negative&quot;);
+//            }
+//
+//            this.m = m;
+//            this.k1 = k1;
+//            this.k2 = k2;
+//            this.k3 = k3;
+//        }
+//
+//        /**
+//         * Constructor for TPB.
+//         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+//         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+//         * @param k The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction
+//         * polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+//         * @param x The BigInteger representing the value of the field element.
+//         */
+//        public F2m(int m, int k, BigInteger x)
+//        {
+//            // Set k1 to k, and set k2 and k3 to 0
+//            this(m, k, 0, 0, x);
+//        }
+//
+//        public BigInteger toBigInteger()
+//        {
+//            return x;
+//        }
+//
+//        public String getFieldName()
+//        {
+//            return &quot;F2m&quot;;
+//        }
+//
+//        public int getFieldSize()
+//        {
+//            return m;
+//        }
+//
+//        /**
+//         * Checks, if the ECFieldElements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
+//         * are elements of the same field &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;
+//         * (having the same representation).
+//         * @param a field element.
+//         * @param b field element to be compared.
+//         * @throws IllegalArgumentException if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
+//         * are not elements of the same field
+//         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt; (having the same
+//         * representation). 
+//         */
+//        public static void checkFieldElements(
+//            ECFieldElement a,
+//            ECFieldElement b)
+//        {
+//            if ((!(a instanceof F2m)) || (!(b instanceof F2m)))
+//            {
+//                throw new IllegalArgumentException(&quot;Field elements are not &quot;
+//                        + &quot;both instances of ECFieldElement.F2m&quot;);
+//            }
+//
+//            if ((a.toBigInteger().signum() &lt; 0) || (b.toBigInteger().signum() &lt; 0))
+//            {
+//                throw new IllegalArgumentException(
+//                        &quot;x value may not be negative&quot;);
+//            }
+//
+//            ECFieldElement.F2m aF2m = (ECFieldElement.F2m)a;
+//            ECFieldElement.F2m bF2m = (ECFieldElement.F2m)b;
+//
+//            if ((aF2m.m != bF2m.m) || (aF2m.k1 != bF2m.k1)
+//                    || (aF2m.k2 != bF2m.k2) || (aF2m.k3 != bF2m.k3))
+//            {
+//                throw new IllegalArgumentException(&quot;Field elements are not &quot;
+//                        + &quot;elements of the same field F2m&quot;);
+//            }
+//
+//            if (aF2m.representation != bF2m.representation)
+//            {
+//                // Should never occur
+//                throw new IllegalArgumentException(
+//                        &quot;One of the field &quot;
+//                                + &quot;elements are not elements has incorrect representation&quot;);
+//            }
+//        }
+//
+//        /**
+//         * Computes &lt;code&gt;z * a(z) mod f(z)&lt;/code&gt;, where &lt;code&gt;f(z)&lt;/code&gt; is
+//         * the reduction polynomial of &lt;code&gt;this&lt;/code&gt;.
+//         * @param a The polynomial &lt;code&gt;a(z)&lt;/code&gt; to be multiplied by
+//         * &lt;code&gt;z mod f(z)&lt;/code&gt;.
+//         * @return &lt;code&gt;z * a(z) mod f(z)&lt;/code&gt;
+//         */
+//        private BigInteger multZModF(final BigInteger a)
+//        {
+//            // Left-shift of a(z)
+//            BigInteger az = a.shiftLeft(1);
+//            if (az.testBit(this.m)) 
+//            {
+//                // If the coefficient of z^m in a(z) equals 1, reduction
+//                // modulo f(z) is performed: Add f(z) to to a(z):
+//                // Step 1: Unset mth coeffient of a(z)
+//                az = az.clearBit(this.m);
+//
+//                // Step 2: Add r(z) to a(z), where r(z) is defined as
+//                // f(z) = z^m + r(z), and k1, k2, k3 are the positions of
+//                // the non-zero coefficients in r(z)
+//                az = az.flipBit(0);
+//                az = az.flipBit(this.k1);
+//                if (this.representation == PPB) 
+//                {
+//                    az = az.flipBit(this.k2);
+//                    az = az.flipBit(this.k3);
+//                }
+//            }
+//            return az;
+//        }
+//
+//        public ECFieldElement add(final ECFieldElement b)
+//        {
+//            // No check performed here for performance reasons. Instead the
+//            // elements involved are checked in ECPoint.F2m
+//            // checkFieldElements(this, b);
+//            if (b.toBigInteger().signum() == 0)
+//            {
+//                return this;
+//            }
+//
+//            return new F2m(this.m, this.k1, this.k2, this.k3, this.x.xor(b.toBigInteger()));
+//        }
+//
+//        public ECFieldElement subtract(final ECFieldElement b)
+//        {
+//            // Addition and subtraction are the same in F2m
+//            return add(b);
+//        }
+//
+//
+//        public ECFieldElement multiply(final ECFieldElement b)
+//        {
+//            // Left-to-right shift-and-add field multiplication in F2m
+//            // Input: Binary polynomials a(z) and b(z) of degree at most m-1
+//            // Output: c(z) = a(z) * b(z) mod f(z)
+//
+//            // No check performed here for performance reasons. Instead the
+//            // elements involved are checked in ECPoint.F2m
+//            // checkFieldElements(this, b);
+//            final BigInteger az = this.x;
+//            BigInteger bz = b.toBigInteger();
+//            BigInteger cz;
+//
+//            // Compute c(z) = a(z) * b(z) mod f(z)
+//            if (az.testBit(0)) 
+//            {
+//                cz = bz;
+//            } 
+//            else 
+//            {
+//                cz = ECConstants.ZERO;
+//            }
+//
+//            for (int i = 1; i &lt; this.m; i++) 
+//            {
+//                // b(z) := z * b(z) mod f(z)
+//                bz = multZModF(bz);
+//
+//                if (az.testBit(i)) 
+//                {
+//                    // If the coefficient of x^i in a(z) equals 1, b(z) is added
+//                    // to c(z)
+//                    cz = cz.xor(bz);
+//                }
+//            }
+//            return new ECFieldElement.F2m(m, this.k1, this.k2, this.k3, cz);
+//        }
+//
+//
+//        public ECFieldElement divide(final ECFieldElement b)
+//        {
+//            // There may be more efficient implementations
+//            ECFieldElement bInv = b.invert();
+//            return multiply(bInv);
+//        }
+//
+//        public ECFieldElement negate()
+//        {
+//            // -x == x holds for all x in F2m
+//            return this;
+//        }
+//
+//        public ECFieldElement square()
+//        {
+//            // Naive implementation, can probably be speeded up using modular
+//            // reduction
+//            return multiply(this);
+//        }
+//
+//        public ECFieldElement invert()
+//        {
+//            // Inversion in F2m using the extended Euclidean algorithm
+//            // Input: A nonzero polynomial a(z) of degree at most m-1
+//            // Output: a(z)^(-1) mod f(z)
+//
+//            // u(z) := a(z)
+//            BigInteger uz = this.x;
+//            if (uz.signum() &lt;= 0) 
+//            {
+//                throw new ArithmeticException(&quot;x is zero or negative, &quot; +
+//                        &quot;inversion is impossible&quot;);
+//            }
+//
+//            // v(z) := f(z)
+//            BigInteger vz = ECConstants.ZERO.setBit(m);
+//            vz = vz.setBit(0);
+//            vz = vz.setBit(this.k1);
+//            if (this.representation == PPB) 
+//            {
+//                vz = vz.setBit(this.k2);
+//                vz = vz.setBit(this.k3);
+//            }
+//
+//            // g1(z) := 1, g2(z) := 0
+//            BigInteger g1z = ECConstants.ONE;
+//            BigInteger g2z = ECConstants.ZERO;
+//
+//            // while u != 1
+//            while (!(uz.equals(ECConstants.ZERO))) 
+//            {
+//                // j := deg(u(z)) - deg(v(z))
+//                int j = uz.bitLength() - vz.bitLength();
+//
+//                // If j &lt; 0 then: u(z) &lt;-&gt; v(z), g1(z) &lt;-&gt; g2(z), j := -j
+//                if (j &lt; 0) 
+//                {
+//                    final BigInteger uzCopy = uz;
+//                    uz = vz;
+//                    vz = uzCopy;
+//
+//                    final BigInteger g1zCopy = g1z;
+//                    g1z = g2z;
+//                    g2z = g1zCopy;
+//
+//                    j = -j;
+//                }
+//
+//                // u(z) := u(z) + z^j * v(z)
+//                // Note, that no reduction modulo f(z) is required, because
+//                // deg(u(z) + z^j * v(z)) &lt;= max(deg(u(z)), j + deg(v(z)))
+//                // = max(deg(u(z)), deg(u(z)) - deg(v(z)) + deg(v(z))
+//                // = deg(u(z))
+//                uz = uz.xor(vz.shiftLeft(j));
+//
+//                // g1(z) := g1(z) + z^j * g2(z)
+//                g1z = g1z.xor(g2z.shiftLeft(j));
+////                if (g1z.bitLength() &gt; this.m) {
+////                    throw new ArithmeticException(
+////                            &quot;deg(g1z) &gt;= m, g1z = &quot; + g1z.toString(2));
+////                }
+//            }
+//            return new ECFieldElement.F2m(
+//                    this.m, this.k1, this.k2, this.k3, g2z);
+//        }
+//
+//        public ECFieldElement sqrt()
+//        {
+//            throw new RuntimeException(&quot;Not implemented&quot;);
+//        }
+//
+//        /**
+//         * @return the representation of the field
+//         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;, either of
+//         * TPB (trinomial
+//         * basis representation) or
+//         * PPB (pentanomial
+//         * basis representation).
+//         */
+//        public int getRepresentation()
+//        {
+//            return this.representation;
+//        }
+//
+//        /**
+//         * @return the degree &lt;code&gt;m&lt;/code&gt; of the reduction polynomial
+//         * &lt;code&gt;f(z)&lt;/code&gt;.
+//         */
+//        public int getM()
+//        {
+//            return this.m;
+//        }
+//
+//        /**
+//         * @return TPB: The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction polynomial
+//         * &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         * PPB: The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         */
+//        public int getK1()
+//        {
+//            return this.k1;
+//        }
+//
+//        /**
+//         * @return TPB: Always returns &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+//         * PPB: The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         */
+//        public int getK2()
+//        {
+//            return this.k2;
+//        }
+//
+//        /**
+//         * @return TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+//         * PPB: The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+//         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+//         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+//         */
+//        public int getK3()
+//        {
+//            return this.k3;
+//        }
+//
+//        public boolean equals(Object anObject)
+//        {
+//            if (anObject == this) 
+//            {
+//                return true;
+//            }
+//
+//            if (!(anObject instanceof ECFieldElement.F2m)) 
+//            {
+//                return false;
+//            }
+//
+//            ECFieldElement.F2m b = (ECFieldElement.F2m)anObject;
+//            
+//            return ((this.m == b.m) &amp;&amp; (this.k1 == b.k1) &amp;&amp; (this.k2 == b.k2)
+//                &amp;&amp; (this.k3 == b.k3)
+//                &amp;&amp; (this.representation == b.representation)
+//                &amp;&amp; (this.x.equals(b.x)));
+//        }
+//
+//        public int hashCode()
+//        {
+//            return x.hashCode() ^ m ^ k1 ^ k2 ^ k3;
+//        }
+//    }
+
+    /**
+     * Class representing the Elements of the finite field
+     * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt; in polynomial basis (PB)
+     * representation. Both trinomial (TPB) and pentanomial (PPB) polynomial
+     * basis representations are supported. Gaussian normal basis (GNB)
+     * representation is not supported.
+     */
+    public static class F2m extends ECFieldElement
+    {
+        /**
+         * Indicates gaussian normal basis representation (GNB). Number chosen
+         * according to X9.62. GNB is not implemented at present.
+         */
+        public static final int GNB = 1;
+
+        /**
+         * Indicates trinomial basis representation (TPB). Number chosen
+         * according to X9.62.
+         */
+        public static final int TPB = 2;
+
+        /**
+         * Indicates pentanomial basis representation (PPB). Number chosen
+         * according to X9.62.
+         */
+        public static final int PPB = 3;
+
+        /**
+         * TPB or PPB.
+         */
+        private int representation;
+
+        /**
+         * The exponent &lt;code&gt;m&lt;/code&gt; of &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         */
+        private int m;
+
+        /**
+         * TPB: The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction polynomial
+         * &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        private int k1;
+
+        /**
+         * TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        private int k2;
+
+        /**
+         * TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        private int k3;
+
+        /**
+         * The &lt;code&gt;IntArray&lt;/code&gt; holding the bits.
+         */
+        private IntArray x;
+
+        /**
+         * The number of &lt;code&gt;int&lt;/code&gt;s required to hold &lt;code&gt;m&lt;/code&gt; bits.
+         */
+        private int t;
+
+        /**
+         * Constructor for PPB.
+         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param k1 The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param k2 The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param k3 The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param x The BigInteger representing the value of the field element.
+         */
+        public F2m(
+            int m, 
+            int k1, 
+            int k2, 
+            int k3,
+            BigInteger x)
+        {
+            // t = m / 32 rounded up to the next integer
+            t = (m + 31) &gt;&gt; 5;
+            this.x = new IntArray(x, t);
+
+            if ((k2 == 0) &amp;&amp; (k3 == 0))
+            {
+                this.representation = TPB;
+            }
+            else
+            {
+                if (k2 &gt;= k3)
+                {
+                    throw new IllegalArgumentException(
+                            &quot;k2 must be smaller than k3&quot;);
+                }
+                if (k2 &lt;= 0)
+                {
+                    throw new IllegalArgumentException(
+                            &quot;k2 must be larger than 0&quot;);
+                }
+                this.representation = PPB;
+            }
+
+            if (x.signum() &lt; 0)
+            {
+                throw new IllegalArgumentException(&quot;x value cannot be negative&quot;);
+            }
+
+            this.m = m;
+            this.k1 = k1;
+            this.k2 = k2;
+            this.k3 = k3;
+        }
+
+        /**
+         * Constructor for TPB.
+         * @param m  The exponent &lt;code&gt;m&lt;/code&gt; of
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;.
+         * @param k The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction
+         * polynomial &lt;code&gt;f(z)&lt;/code&gt;.
+         * @param x The BigInteger representing the value of the field element.
+         */
+        public F2m(int m, int k, BigInteger x)
+        {
+            // Set k1 to k, and set k2 and k3 to 0
+            this(m, k, 0, 0, x);
+        }
+
+        private F2m(int m, int k1, int k2, int k3, IntArray x)
+        {
+            t = (m + 31) &gt;&gt; 5;
+            this.x = x;
+            this.m = m;
+            this.k1 = k1;
+            this.k2 = k2;
+            this.k3 = k3;
+
+            if ((k2 == 0) &amp;&amp; (k3 == 0))
+            {
+                this.representation = TPB;
+            }
+            else
+            {
+                this.representation = PPB;
+            }
+
+        }
+
+        public BigInteger toBigInteger()
+        {
+            return x.toBigInteger();
+        }
+
+        public String getFieldName()
+        {
+            return &quot;F2m&quot;;
+        }
+
+        public int getFieldSize()
+        {
+            return m;
+        }
+
+        /**
+         * Checks, if the ECFieldElements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
+         * are elements of the same field &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;
+         * (having the same representation).
+         * @param a field element.
+         * @param b field element to be compared.
+         * @throws IllegalArgumentException if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
+         * are not elements of the same field
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt; (having the same
+         * representation). 
+         */
+        public static void checkFieldElements(
+            ECFieldElement a,
+            ECFieldElement b)
+        {
+            if ((!(a instanceof F2m)) || (!(b instanceof F2m)))
+            {
+                throw new IllegalArgumentException(&quot;Field elements are not &quot;
+                        + &quot;both instances of ECFieldElement.F2m&quot;);
+            }
+
+            ECFieldElement.F2m aF2m = (ECFieldElement.F2m)a;
+            ECFieldElement.F2m bF2m = (ECFieldElement.F2m)b;
+
+            if ((aF2m.m != bF2m.m) || (aF2m.k1 != bF2m.k1)
+                    || (aF2m.k2 != bF2m.k2) || (aF2m.k3 != bF2m.k3))
+            {
+                throw new IllegalArgumentException(&quot;Field elements are not &quot;
+                        + &quot;elements of the same field F2m&quot;);
+            }
+
+            if (aF2m.representation != bF2m.representation)
+            {
+                // Should never occur
+                throw new IllegalArgumentException(
+                        &quot;One of the field &quot;
+                                + &quot;elements are not elements has incorrect representation&quot;);
+            }
+        }
+
+        public ECFieldElement add(final ECFieldElement b)
+        {
+            // No check performed here for performance reasons. Instead the
+            // elements involved are checked in ECPoint.F2m
+            // checkFieldElements(this, b);
+            IntArray iarrClone = (IntArray)this.x.clone();
+            F2m bF2m = (F2m)b;
+            iarrClone.addShifted(bF2m.x, 0);
+            return new F2m(m, k1, k2, k3, iarrClone);
+        }
+
+        public ECFieldElement subtract(final ECFieldElement b)
+        {
+            // Addition and subtraction are the same in F2m
+            return add(b);
+        }
+
+        public ECFieldElement multiply(final ECFieldElement b)
+        {
+            // Right-to-left comb multiplication in the IntArray
+            // Input: Binary polynomials a(z) and b(z) of degree at most m-1
+            // Output: c(z) = a(z) * b(z) mod f(z)
+
+            // No check performed here for performance reasons. Instead the
+            // elements involved are checked in ECPoint.F2m
+            // checkFieldElements(this, b);
+            F2m bF2m = (F2m)b;
+            IntArray mult = x.multiply(bF2m.x, m);
+            mult.reduce(m, new int[]{k1, k2, k3});
+            return new F2m(m, k1, k2, k3, mult);
+        }
+
+        public ECFieldElement divide(final ECFieldElement b)
+        {
+            // There may be more efficient implementations
+            ECFieldElement bInv = b.invert();
+            return multiply(bInv);
+        }
+
+        public ECFieldElement negate()
+        {
+            // -x == x holds for all x in F2m
+            return this;
+        }
+
+        public ECFieldElement square()
+        {
+            IntArray squared = x.square(m);
+            squared.reduce(m, new int[]{k1, k2, k3});
+            return new F2m(m, k1, k2, k3, squared);
+        }
+
+
+        public ECFieldElement invert()
+        {
+            // Inversion in F2m using the extended Euclidean algorithm
+            // Input: A nonzero polynomial a(z) of degree at most m-1
+            // Output: a(z)^(-1) mod f(z)
+
+            // u(z) := a(z)
+            IntArray uz = (IntArray)this.x.clone();
+
+            // v(z) := f(z)
+            IntArray vz = new IntArray(t);
+            vz.setBit(m);
+            vz.setBit(0);
+            vz.setBit(this.k1);
+            if (this.representation == PPB) 
+            {
+                vz.setBit(this.k2);
+                vz.setBit(this.k3);
+            }
+
+            // g1(z) := 1, g2(z) := 0
+            IntArray g1z = new IntArray(t);
+            g1z.setBit(0);
+            IntArray g2z = new IntArray(t);
+
+            // while u != 0
+            while (!uz.isZero())
+//            while (uz.getUsedLength() &gt; 0)
+//            while (uz.bitLength() &gt; 1)
+            {
+                // j := deg(u(z)) - deg(v(z))
+                int j = uz.bitLength() - vz.bitLength();
+
+                // If j &lt; 0 then: u(z) &lt;-&gt; v(z), g1(z) &lt;-&gt; g2(z), j := -j
+                if (j &lt; 0) 
+                {
+                    final IntArray uzCopy = uz;
+                    uz = vz;
+                    vz = uzCopy;
+
+                    final IntArray g1zCopy = g1z;
+                    g1z = g2z;
+                    g2z = g1zCopy;
+
+                    j = -j;
+                }
+
+                // u(z) := u(z) + z^j * v(z)
+                // Note, that no reduction modulo f(z) is required, because
+                // deg(u(z) + z^j * v(z)) &lt;= max(deg(u(z)), j + deg(v(z)))
+                // = max(deg(u(z)), deg(u(z)) - deg(v(z)) + deg(v(z))
+                // = deg(u(z))
+                // uz = uz.xor(vz.shiftLeft(j));
+                // jInt = n / 32
+                int jInt = j &gt;&gt; 5;
+                // jInt = n % 32
+                int jBit = j &amp; 0x1F;
+                IntArray vzShift = vz.shiftLeft(jBit);
+                uz.addShifted(vzShift, jInt);
+
+                // g1(z) := g1(z) + z^j * g2(z)
+//                g1z = g1z.xor(g2z.shiftLeft(j));
+                IntArray g2zShift = g2z.shiftLeft(jBit);
+                g1z.addShifted(g2zShift, jInt);
+                
+            }
+            return new ECFieldElement.F2m(
+                    this.m, this.k1, this.k2, this.k3, g2z);
+        }
+
+        public ECFieldElement sqrt()
+        {
+            throw new RuntimeException(&quot;Not implemented&quot;);
+        }
+
+        /**
+         * @return the representation of the field
+         * &lt;code&gt;F&lt;sub&gt;2&lt;sup&gt;m&lt;/sup&gt;&lt;/sub&gt;&lt;/code&gt;, either of
+         * TPB (trinomial
+         * basis representation) or
+         * PPB (pentanomial
+         * basis representation).
+         */
+        public int getRepresentation()
+        {
+            return this.representation;
+        }
+
+        /**
+         * @return the degree &lt;code&gt;m&lt;/code&gt; of the reduction polynomial
+         * &lt;code&gt;f(z)&lt;/code&gt;.
+         */
+        public int getM()
+        {
+            return this.m;
+        }
+
+        /**
+         * @return TPB: The integer &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k&lt;/sup&gt; + 1&lt;/code&gt; represents the reduction polynomial
+         * &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k1&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        public int getK1()
+        {
+            return this.k1;
+        }
+
+        /**
+         * @return TPB: Always returns &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k2&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        public int getK2()
+        {
+            return this.k2;
+        }
+
+        /**
+         * @return TPB: Always set to &lt;code&gt;0&lt;/code&gt;&lt;br&gt;
+         * PPB: The integer &lt;code&gt;k3&lt;/code&gt; where &lt;code&gt;x&lt;sup&gt;m&lt;/sup&gt; +
+         * x&lt;sup&gt;k3&lt;/sup&gt; + x&lt;sup&gt;k2&lt;/sup&gt; + x&lt;sup&gt;k1&lt;/sup&gt; + 1&lt;/code&gt;
+         * represents the reduction polynomial &lt;code&gt;f(z)&lt;/code&gt;.&lt;br&gt;
+         */
+        public int getK3()
+        {
+            return this.k3;
+        }
+
+        public boolean equals(Object anObject)
+        {
+            if (anObject == this) 
+            {
+                return true;
+            }
+
+            if (!(anObject instanceof ECFieldElement.F2m)) 
+            {
+                return false;
+            }
+
+            ECFieldElement.F2m b = (ECFieldElement.F2m)anObject;
+            
+            return ((this.m == b.m) &amp;&amp; (this.k1 == b.k1) &amp;&amp; (this.k2 == b.k2)
+                &amp;&amp; (this.k3 == b.k3)
+                &amp;&amp; (this.representation == b.representation)
+                &amp;&amp; (this.x.equals(b.x)));
+        }
+
+        public int hashCode()
+        {
+            return x.hashCode() ^ m ^ k1 ^ k2 ^ k3;
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,19 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Interface for classes encapsulating a point multiplication algorithm
+ * for &lt;code&gt;ECPoint&lt;/code&gt;s.
+ */
+interface ECMultiplier
+{
+    /**
+     * Multiplies the &lt;code&gt;ECPoint p&lt;/code&gt; by &lt;code&gt;k&lt;/code&gt;, i.e.
+     * &lt;code&gt;p&lt;/code&gt; is added &lt;code&gt;k&lt;/code&gt; times to itself.
+     * @param p The &lt;code&gt;ECPoint&lt;/code&gt; to be multiplied.
+     * @param k The factor by which &lt;code&gt;p&lt;/code&gt; i multiplied.
+     * @return &lt;code&gt;p&lt;/code&gt; multiplied by &lt;code&gt;k&lt;/code&gt;.
+     */
+    ECPoint multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo);
+}

Added: trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECPoint$F2m.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECPoint$Fp.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECPoint.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ECPoint.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ECPoint.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ECPoint.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ECPoint.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,588 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+import org.bouncycastle.asn1.x9.X9IntegerConverter;
+
+/**
+ * base class for points on elliptic curves.
+ */
+public abstract class ECPoint
+{
+    ECCurve        curve;
+    ECFieldElement x;
+    ECFieldElement y;
+
+    protected boolean withCompression;
+
+    protected ECMultiplier multiplier = null;
+
+    protected PreCompInfo preCompInfo = null;
+
+    private static X9IntegerConverter converter = new X9IntegerConverter();
+
+    protected ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y)
+    {
+        this.curve = curve;
+        this.x = x;
+        this.y = y;
+    }
+    
+    public ECCurve getCurve()
+    {
+        return curve;
+    }
+    
+    public ECFieldElement getX()
+    {
+        return x;
+    }
+
+    public ECFieldElement getY()
+    {
+        return y;
+    }
+
+    public boolean isInfinity()
+    {
+        return x == null &amp;&amp; y == null;
+    }
+
+    public boolean isCompressed()
+    {
+        return withCompression;
+    }
+
+    public boolean equals(
+        Object  other)
+    {
+        if (other == this)
+        {
+            return true;
+        }
+
+        if (!(other instanceof ECPoint))
+        {
+            return false;
+        }
+
+        ECPoint o = (ECPoint)other;
+
+        if (this.isInfinity())
+        {
+            return o.isInfinity();
+        }
+
+        return x.equals(o.x) &amp;&amp; y.equals(o.y);
+    }
+
+    public int hashCode()
+    {
+        if (this.isInfinity())
+        {
+            return 0;
+        }
+        
+        return x.hashCode() ^ y.hashCode();
+    }
+
+//    /**
+//     * Mainly for testing. Explicitly set the &lt;code&gt;ECMultiplier&lt;/code&gt;.
+//     * @param multiplier The &lt;code&gt;ECMultiplier&lt;/code&gt; to be used to multiply
+//     * this &lt;code&gt;ECPoint&lt;/code&gt;.
+//     */
+//    public void setECMultiplier(ECMultiplier multiplier)
+//    {
+//        this.multiplier = multiplier;
+//    }
+
+    /**
+     * Sets the &lt;code&gt;PreCompInfo&lt;/code&gt;. Used by &lt;code&gt;ECMultiplier&lt;/code&gt;s
+     * to save the precomputation for this &lt;code&gt;ECPoint&lt;/code&gt; to store the
+     * precomputation result for use by subsequent multiplication.
+     * @param preCompInfo The values precomputed by the
+     * &lt;code&gt;ECMultiplier&lt;/code&gt;.
+     */
+    void setPreCompInfo(PreCompInfo preCompInfo)
+    {
+        this.preCompInfo = preCompInfo;
+    }
+
+    public abstract byte[] getEncoded();
+
+    public abstract ECPoint add(ECPoint b);
+    public abstract ECPoint subtract(ECPoint b);
+    public abstract ECPoint negate();
+    public abstract ECPoint twice();
+
+    /**
+     * Sets the default &lt;code&gt;ECMultiplier&lt;/code&gt;, unless already set. 
+     */
+    synchronized void assertECMultiplier()
+    {
+        if (this.multiplier == null)
+        {
+            this.multiplier = new FpNafMultiplier();
+        }
+    }
+
+    /**
+     * Multiplies this &lt;code&gt;ECPoint&lt;/code&gt; by the given number.
+     * @param k The multiplicator.
+     * @return &lt;code&gt;k * this&lt;/code&gt;.
+     */
+    public ECPoint multiply(BigInteger k)
+    {
+        if (k.signum() &lt; 0)
+        {
+            throw new IllegalArgumentException(&quot;The multiplicator cannot be negative&quot;);
+        }
+
+        if (this.isInfinity())
+        {
+            return this;
+        }
+
+        if (k.signum() == 0)
+        {
+            return this.curve.getInfinity();
+        }
+
+        assertECMultiplier();
+        return this.multiplier.multiply(this, k, preCompInfo);
+    }
+
+    /**
+     * Elliptic curve points over Fp
+     */
+    public static class Fp extends ECPoint
+    {
+        
+        /**
+         * Create a point which encodes with point compression.
+         * 
+         * @param curve the curve to use
+         * @param x affine x co-ordinate
+         * @param y affine y co-ordinate
+         */
+        public Fp(ECCurve curve, ECFieldElement x, ECFieldElement y)
+        {
+            this(curve, x, y, false);
+        }
+
+        /**
+         * Create a point that encodes with or without point compresion.
+         * 
+         * @param curve the curve to use
+         * @param x affine x co-ordinate
+         * @param y affine y co-ordinate
+         * @param withCompression if true encode with point compression
+         */
+        public Fp(ECCurve curve, ECFieldElement x, ECFieldElement y, boolean withCompression)
+        {
+            super(curve, x, y);
+
+            if ((x != null &amp;&amp; y == null) || (x == null &amp;&amp; y != null))
+            {
+                throw new IllegalArgumentException(&quot;Exactly one of the field elements is null&quot;);
+            }
+
+            this.withCompression = withCompression;
+        }
+         
+        /**
+         * return the field element encoded with point compression. (S 4.3.6)
+         */
+        public byte[] getEncoded()
+        {
+            if (this.isInfinity()) 
+            {
+                return new byte[1];
+            }
+
+            int qLength = converter.getByteLength(x);
+            
+            if (withCompression)
+            {
+                byte    PC;
+    
+                if (this.getY().toBigInteger().testBit(0))
+                {
+                    PC = 0x03;
+                }
+                else
+                {
+                    PC = 0x02;
+                }
+    
+                byte[]  X = converter.integerToBytes(this.getX().toBigInteger(), qLength);
+                byte[]  PO = new byte[X.length + 1];
+    
+                PO[0] = PC;
+                System.arraycopy(X, 0, PO, 1, X.length);
+    
+                return PO;
+            }
+            else
+            {
+                byte[]  X = converter.integerToBytes(this.getX().toBigInteger(), qLength);
+                byte[]  Y = converter.integerToBytes(this.getY().toBigInteger(), qLength);
+                byte[]  PO = new byte[X.length + Y.length + 1];
+                
+                PO[0] = 0x04;
+                System.arraycopy(X, 0, PO, 1, X.length);
+                System.arraycopy(Y, 0, PO, X.length + 1, Y.length);
+
+                return PO;
+            }
+        }
+
+        // B.3 pg 62
+        public ECPoint add(ECPoint b)
+        {
+            if (this.isInfinity())
+            {
+                return b;
+            }
+
+            if (b.isInfinity())
+            {
+                return this;
+            }
+
+            // Check if b = this or b = -this
+            if (this.x.equals(b.x))
+            {
+                if (this.y.equals(b.y))
+                {
+                    // this = b, i.e. this must be doubled
+                    return this.twice();
+                }
+
+                // this = -b, i.e. the result is the point at infinity
+                return this.curve.getInfinity();
+            }
+
+            ECFieldElement gamma = b.y.subtract(this.y).divide(b.x.subtract(this.x));
+
+            ECFieldElement x3 = gamma.square().subtract(this.x).subtract(b.x);
+            ECFieldElement y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);
+
+            return new ECPoint.Fp(curve, x3, y3);
+        }
+
+        // B.3 pg 62
+        public ECPoint twice()
+        {
+            if (this.isInfinity())
+            {
+                // Twice identity element (point at infinity) is identity
+                return this;
+            }
+
+            if (this.y.toBigInteger().signum() == 0) 
+            {
+                // if y1 == 0, then (x1, y1) == (x1, -y1)
+                // and hence this = -this and thus 2(x1, y1) == infinity
+                return this.curve.getInfinity();
+            }
+
+            ECFieldElement TWO = this.curve.fromBigInteger(BigInteger.valueOf(2));
+            ECFieldElement THREE = this.curve.fromBigInteger(BigInteger.valueOf(3));
+            ECFieldElement gamma = this.x.square().multiply(THREE).add(curve.a).divide(y.multiply(TWO));
+
+            ECFieldElement x3 = gamma.square().subtract(this.x.multiply(TWO));
+            ECFieldElement y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);
+                
+            return new ECPoint.Fp(curve, x3, y3, this.withCompression);
+        }
+
+        // D.3.2 pg 102 (see Note:)
+        public ECPoint subtract(ECPoint b)
+        {
+            if (b.isInfinity())
+            {
+                return this;
+            }
+
+            // Add -b
+            return add(b.negate());
+        }
+
+        public ECPoint negate()
+        {
+            return new ECPoint.Fp(curve, this.x, this.y.negate(), this.withCompression);
+        }
+
+        /**
+         * Sets the default &lt;code&gt;ECMultiplier&lt;/code&gt;, unless already set. 
+         */
+        synchronized void assertECMultiplier()
+        {
+            if (this.multiplier == null)
+            {
+                this.multiplier = new WNafMultiplier();
+            }
+        }
+    }
+
+    /**
+     * Elliptic curve points over F2m
+     */
+    public static class F2m extends ECPoint
+    {
+        /**
+         * @param curve base curve
+         * @param x x point
+         * @param y y point
+         */
+        public F2m(ECCurve curve, ECFieldElement x, ECFieldElement y)
+        {
+            this(curve, x, y, false);
+        }
+        
+        /**
+         * @param curve base curve
+         * @param x x point
+         * @param y y point
+         * @param withCompression true if encode with point compression.
+         */
+        public F2m(ECCurve curve, ECFieldElement x, ECFieldElement y, boolean withCompression)
+        {
+            super(curve, x, y);
+
+            if ((x != null &amp;&amp; y == null) || (x == null &amp;&amp; y != null))
+            {
+                throw new IllegalArgumentException(&quot;Exactly one of the field elements is null&quot;);
+            }
+            
+            if (x != null)
+            {
+                // Check if x and y are elements of the same field
+                ECFieldElement.F2m.checkFieldElements(this.x, this.y);
+    
+                // Check if x and a are elements of the same field
+                if (curve != null)
+                {
+                    ECFieldElement.F2m.checkFieldElements(this.x, this.curve.getA());
+                }
+            }
+            
+            this.withCompression = withCompression;
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#getEncoded()
+         */
+        public byte[] getEncoded()
+        {
+            if (this.isInfinity()) 
+            {
+                return new byte[1];
+            }
+
+            int byteCount = converter.getByteLength(this.x);
+            byte[] X = converter.integerToBytes(this.getX().toBigInteger(), byteCount);
+            byte[] PO;
+
+            if (withCompression)
+            {
+                // See X9.62 4.3.6 and 4.2.2
+                PO = new byte[byteCount + 1];
+
+                PO[0] = 0x02;
+                // X9.62 4.2.2 and 4.3.6:
+                // if x = 0 then ypTilde := 0, else ypTilde is the rightmost
+                // bit of y * x^(-1)
+                // if ypTilde = 0, then PC := 02, else PC := 03
+                // Note: PC === PO[0]
+                if (!(this.getX().toBigInteger().equals(ECConstants.ZERO)))
+                {
+                    if (this.getY().multiply(this.getX().invert())
+                            .toBigInteger().testBit(0))
+                    {
+                        // ypTilde = 1, hence PC = 03
+                        PO[0] = 0x03;
+                    }
+                }
+
+                System.arraycopy(X, 0, PO, 1, byteCount);
+            }
+            else
+            {
+                byte[] Y = converter.integerToBytes(this.getY().toBigInteger(), byteCount);
+    
+                PO = new byte[byteCount + byteCount + 1];
+    
+                PO[0] = 0x04;
+                System.arraycopy(X, 0, PO, 1, byteCount);
+                System.arraycopy(Y, 0, PO, byteCount + 1, byteCount);    
+            }
+
+            return PO;
+        }
+
+        /**
+         * Check, if two &lt;code&gt;ECPoint&lt;/code&gt;s can be added or subtracted.
+         * @param a The first &lt;code&gt;ECPoint&lt;/code&gt; to check.
+         * @param b The second &lt;code&gt;ECPoint&lt;/code&gt; to check.
+         * @throws IllegalArgumentException if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;
+         * cannot be added.
+         */
+        private static void checkPoints(ECPoint a, ECPoint b)
+        {
+            // Check, if points are on the same curve
+            if (!(a.curve.equals(b.curve)))
+            {
+                throw new IllegalArgumentException(&quot;Only points on the same &quot;
+                        + &quot;curve can be added or subtracted&quot;);
+            }
+
+//            ECFieldElement.F2m.checkFieldElements(a.x, b.x);
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#add(org.bouncycastle.math.ec.ECPoint)
+         */
+        public ECPoint add(ECPoint b)
+        {
+            checkPoints(this, b);
+            return addSimple((ECPoint.F2m)b);
+        }
+
+        /**
+         * Adds another &lt;code&gt;ECPoints.F2m&lt;/code&gt; to &lt;code&gt;this&lt;/code&gt; without
+         * checking if both points are on the same curve. Used by multiplication
+         * algorithms, because there all points are a multiple of the same point
+         * and hence the checks can be omitted.
+         * @param b The other &lt;code&gt;ECPoints.F2m&lt;/code&gt; to add to
+         * &lt;code&gt;this&lt;/code&gt;.
+         * @return &lt;code&gt;this + b&lt;/code&gt;
+         */
+        public ECPoint.F2m addSimple(ECPoint.F2m b)
+        {
+            ECPoint.F2m other = b;
+            if (this.isInfinity())
+            {
+                return other;
+            }
+
+            if (other.isInfinity())
+            {
+                return this;
+            }
+
+            ECFieldElement.F2m x2 = (ECFieldElement.F2m)other.getX();
+            ECFieldElement.F2m y2 = (ECFieldElement.F2m)other.getY();
+
+            // Check if other = this or other = -this
+            if (this.x.equals(x2))
+            {
+                if (this.y.equals(y2))
+                {
+                    // this = other, i.e. this must be doubled
+                    return (ECPoint.F2m)this.twice();
+                }
+
+                // this = -other, i.e. the result is the point at infinity
+                return (ECPoint.F2m)this.curve.getInfinity();
+            }
+
+            ECFieldElement.F2m lambda
+                = (ECFieldElement.F2m)(this.y.add(y2)).divide(this.x.add(x2));
+
+            ECFieldElement.F2m x3
+                = (ECFieldElement.F2m)lambda.square().add(lambda).add(this.x).add(x2).add(this.curve.getA());
+
+            ECFieldElement.F2m y3
+                = (ECFieldElement.F2m)lambda.multiply(this.x.add(x3)).add(x3).add(this.y);
+
+            return new ECPoint.F2m(curve, x3, y3, withCompression);
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#subtract(org.bouncycastle.math.ec.ECPoint)
+         */
+        public ECPoint subtract(ECPoint b)
+        {
+            checkPoints(this, b);
+            return subtractSimple((ECPoint.F2m)b);
+        }
+
+        /**
+         * Subtracts another &lt;code&gt;ECPoints.F2m&lt;/code&gt; from &lt;code&gt;this&lt;/code&gt;
+         * without checking if both points are on the same curve. Used by
+         * multiplication algorithms, because there all points are a multiple
+         * of the same point and hence the checks can be omitted.
+         * @param b The other &lt;code&gt;ECPoints.F2m&lt;/code&gt; to subtract from
+         * &lt;code&gt;this&lt;/code&gt;.
+         * @return &lt;code&gt;this - b&lt;/code&gt;
+         */
+        public ECPoint.F2m subtractSimple(ECPoint.F2m b)
+        {
+            if (b.isInfinity())
+            {
+                return this;
+            }
+
+            // Add -b
+            return addSimple((ECPoint.F2m)b.negate());
+        }
+
+        /* (non-Javadoc)
+         * @see org.bouncycastle.math.ec.ECPoint#twice()
+         */
+        public ECPoint twice()
+        {
+            if (this.isInfinity()) 
+            {
+                // Twice identity element (point at infinity) is identity
+                return this;
+            }
+
+            if (this.x.toBigInteger().signum() == 0) 
+            {
+                // if x1 == 0, then (x1, y1) == (x1, x1 + y1)
+                // and hence this = -this and thus 2(x1, y1) == infinity
+                return this.curve.getInfinity();
+            }
+
+            ECFieldElement.F2m lambda
+                = (ECFieldElement.F2m)this.x.add(this.y.divide(this.x));
+
+            ECFieldElement.F2m x3
+                = (ECFieldElement.F2m)lambda.square().add(lambda).
+                    add(this.curve.getA());
+
+            ECFieldElement ONE = this.curve.fromBigInteger(ECConstants.ONE);
+            ECFieldElement.F2m y3
+                = (ECFieldElement.F2m)this.x.square().add(
+                    x3.multiply(lambda.add(ONE)));
+
+            return new ECPoint.F2m(this.curve, x3, y3, withCompression);
+        }
+
+        public ECPoint negate()
+        {
+            return new ECPoint.F2m(curve, this.getX(), this.getY().add(this.getX()), withCompression);
+        }
+
+        /**
+         * Sets the appropriate &lt;code&gt;ECMultiplier&lt;/code&gt;, unless already set. 
+         */
+        synchronized void assertECMultiplier()
+        {
+            if (this.multiplier == null)
+            {
+                if (((ECCurve.F2m)this.curve).isKoblitz())
+                {
+                    this.multiplier = new WTauNafMultiplier();
+                }
+                else
+                {
+                    this.multiplier = new WNafMultiplier();
+                }
+            }
+        }
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/FpNafMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class implementing the NAF (Non-Adjacent Form) multiplication algorithm.
+ */
+class FpNafMultiplier implements ECMultiplier
+{
+    /**
+     * D.3.2 pg 101
+     * @see org.bouncycastle.math.ec.ECMultiplier#multiply(org.bouncycastle.math.ec.ECPoint, java.math.BigInteger)
+     */
+    public ECPoint multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo)
+    {
+        // TODO Probably should try to add this
+        // BigInteger e = k.mod(n); // n == order of p
+        BigInteger e = k;
+        BigInteger h = e.multiply(BigInteger.valueOf(3));
+
+        ECPoint neg = p.negate();
+        ECPoint R = p;
+
+        for (int i = h.bitLength() - 2; i &gt; 0; --i)
+        {             
+            R = R.twice();
+
+            boolean hBit = h.testBit(i);
+            boolean eBit = e.testBit(i);
+
+            if (hBit != eBit)
+            {
+                R = R.add(hBit ? p : neg);
+            }
+        }
+
+        return R;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/IntArray.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/IntArray.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/IntArray.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/IntArray.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/IntArray.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,518 @@
+package org.bouncycastle.math.ec;
+
+import org.bouncycastle.util.Arrays;
+
+import ewe.math.BigInteger;
+
+class IntArray
+{
+    // TODO make m fixed for the IntArray, and hence compute T once and for all
+
+    private int[] m_ints;
+
+    public IntArray(int intLen)
+    {
+        m_ints = new int[intLen];
+    }
+
+    public IntArray(int[] ints)
+    {
+        m_ints = ints;
+    }
+
+    public IntArray(BigInteger bigInt)
+    {
+        this(bigInt, 0);
+    }
+
+    public IntArray(BigInteger bigInt, int minIntLen)
+    {
+        if (bigInt.signum() == -1)
+        {
+            throw new IllegalArgumentException(&quot;Only positive Integers allowed&quot;);
+        }
+        if (bigInt.equals(ECConstants.ZERO))
+        {
+            m_ints = new int[] { 0 };
+            return;
+        }
+
+        byte[] barr = bigInt.toByteArray();
+        int barrLen = barr.length;
+        int barrStart = 0;
+        if (barr[0] == 0)
+        {
+            // First byte is 0 to enforce highest (=sign) bit is zero.
+            // In this case ignore barr[0].
+            barrLen--;
+            barrStart = 1;
+        }
+        int intLen = (barrLen + 3) / 4;
+        if (intLen &lt; minIntLen)
+        {
+            m_ints = new int[minIntLen];
+        }
+        else
+        {
+            m_ints = new int[intLen];
+        }
+
+        int iarrJ = intLen - 1;
+        int rem = barrLen % 4 + barrStart;
+        int temp = 0;
+        int barrI = barrStart;
+        if (barrStart &lt; rem)
+        {
+            for (; barrI &lt; rem; barrI++)
+            {
+                temp &lt;&lt;= 8;
+                int barrBarrI = barr[barrI];
+                if (barrBarrI &lt; 0)
+                {
+                    barrBarrI += 256;
+                }
+                temp |= barrBarrI;
+            }
+            m_ints[iarrJ--] = temp;
+        }
+
+        for (; iarrJ &gt;= 0; iarrJ--)
+        {
+            temp = 0;
+            for (int i = 0; i &lt; 4; i++)
+            {
+                temp &lt;&lt;= 8;
+                int barrBarrI = barr[barrI++];
+                if (barrBarrI &lt; 0)
+                {
+                    barrBarrI += 256;
+                }
+                temp |= barrBarrI;
+            }
+            m_ints[iarrJ] = temp;
+        }
+    }
+
+    public boolean isZero()
+    {
+        return m_ints.length == 0
+            || (m_ints[0] == 0 &amp;&amp; getUsedLength() == 0);
+    }
+
+    public int getUsedLength()
+    {
+        int highestIntPos = m_ints.length;
+
+        if (highestIntPos &lt; 1)
+        {
+            return 0;
+        }
+
+        // Check if first element will act as sentinel
+        if (m_ints[0] != 0)
+        {
+            while (m_ints[--highestIntPos] == 0)
+            {
+            }
+            return highestIntPos + 1;
+        }
+
+        do
+        {
+            if (m_ints[--highestIntPos] != 0)
+            {
+                return highestIntPos + 1;
+            }
+        }
+        while (highestIntPos &gt; 0);
+
+        return 0;
+    }
+
+    public int bitLength()
+    {
+        // JDK 1.5: see Integer.numberOfLeadingZeros()
+        int intLen = getUsedLength();
+        if (intLen == 0)
+        {
+            return 0;
+        }
+
+        int last = intLen - 1;
+        int highest = m_ints[last];
+        int bits = (last &lt;&lt; 5) + 1;
+
+        // A couple of binary search steps
+        if ((highest &amp; 0xffff0000) != 0)
+        {
+            if ((highest &amp; 0xff000000) != 0)
+            {
+                bits += 24;
+                highest &gt;&gt;&gt;= 24;
+            }
+            else
+            {
+                bits += 16;
+                highest &gt;&gt;&gt;= 16;
+            }
+        }
+        else if (highest &gt; 0x000000ff)
+        {
+            bits += 8;
+            highest &gt;&gt;&gt;= 8;
+        }
+
+        while (highest != 1)
+        {
+            ++bits;
+            highest &gt;&gt;&gt;= 1;
+        }
+
+        return bits;
+    }
+
+    private int[] resizedInts(int newLen)
+    {
+        int[] newInts = new int[newLen];
+        int oldLen = m_ints.length;
+        int copyLen = oldLen &lt; newLen ? oldLen : newLen;
+        System.arraycopy(m_ints, 0, newInts, 0, copyLen);
+        return newInts;
+    }
+
+    public BigInteger toBigInteger()
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return ECConstants.ZERO;
+        }
+
+        int highestInt = m_ints[usedLen - 1];
+        byte[] temp = new byte[4];
+        int barrI = 0;
+        boolean trailingZeroBytesDone = false;
+        for (int j = 3; j &gt;= 0; j--)
+        {
+            byte thisByte = (byte) (highestInt &gt;&gt;&gt; (8 * j));
+            if (trailingZeroBytesDone || (thisByte != 0))
+            {
+                trailingZeroBytesDone = true;
+                temp[barrI++] = thisByte;
+            }
+        }
+
+        int barrLen = 4 * (usedLen - 1) + barrI;
+        byte[] barr = new byte[barrLen];
+        for (int j = 0; j &lt; barrI; j++)
+        {
+            barr[j] = temp[j];
+        }
+        // Highest value int is done now
+
+        for (int iarrJ = usedLen - 2; iarrJ &gt;= 0; iarrJ--)
+        {
+            for (int j = 3; j &gt;= 0; j--)
+            {
+                barr[barrI++] = (byte) (m_ints[iarrJ] &gt;&gt;&gt; (8 * j));
+            }
+        }
+        return new BigInteger(1, barr);
+    }
+
+    public void shiftLeft()
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return;
+        }
+        if (m_ints[usedLen - 1] &lt; 0)
+        {
+            // highest bit of highest used byte is set, so shifting left will
+            // make the IntArray one byte longer
+            usedLen++;
+            if (usedLen &gt; m_ints.length)
+            {
+                // make the m_ints one byte longer, because we need one more
+                // byte which is not available in m_ints
+                m_ints = resizedInts(m_ints.length + 1);
+            }
+        }
+
+        boolean carry = false;
+        for (int i = 0; i &lt; usedLen; i++)
+        {
+            // nextCarry is true if highest bit is set
+            boolean nextCarry = m_ints[i] &lt; 0;
+            m_ints[i] &lt;&lt;= 1;
+            if (carry)
+            {
+                // set lowest bit
+                m_ints[i] |= 1;
+            }
+            carry = nextCarry;
+        }
+    }
+
+    public IntArray shiftLeft(int n)
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return this;
+        }
+
+        if (n == 0)
+        {
+            return this;
+        }
+
+        if (n &gt; 31)
+        {
+            throw new IllegalArgumentException(&quot;shiftLeft() for max 31 bits &quot;
+                + &quot;, &quot; + n + &quot;bit shift is not possible&quot;);
+        }
+
+        int[] newInts = new int[usedLen + 1];
+
+        int nm32 = 32 - n;
+        newInts[0] = m_ints[0] &lt;&lt; n;
+        for (int i = 1; i &lt; usedLen; i++)
+        {
+            newInts[i] = (m_ints[i] &lt;&lt; n) | (m_ints[i - 1] &gt;&gt;&gt; nm32);
+        }
+        newInts[usedLen] = m_ints[usedLen - 1] &gt;&gt;&gt; nm32;
+
+        return new IntArray(newInts);
+    }
+
+    public void addShifted(IntArray other, int shift)
+    {
+        int usedLenOther = other.getUsedLength();
+        int newMinUsedLen = usedLenOther + shift;
+        if (newMinUsedLen &gt; m_ints.length)
+        {
+            m_ints = resizedInts(newMinUsedLen);
+            //System.out.println(&quot;Resize required&quot;);
+        }
+
+        for (int i = 0; i &lt; usedLenOther; i++)
+        {
+            m_ints[i + shift] ^= other.m_ints[i];
+        }
+    }
+
+    public int getLength()
+    {
+        return m_ints.length;
+    }
+
+    public boolean testBit(int n)
+    {
+        // theInt = n / 32
+        int theInt = n &gt;&gt; 5;
+        // theBit = n % 32
+        int theBit = n &amp; 0x1F;
+        int tester = 1 &lt;&lt; theBit;
+        return ((m_ints[theInt] &amp; tester) != 0);
+    }
+
+    public void flipBit(int n)
+    {
+        // theInt = n / 32
+        int theInt = n &gt;&gt; 5;
+        // theBit = n % 32
+        int theBit = n &amp; 0x1F;
+        int flipper = 1 &lt;&lt; theBit;
+        m_ints[theInt] ^= flipper;
+    }
+
+    public void setBit(int n)
+    {
+        // theInt = n / 32
+        int theInt = n &gt;&gt; 5;
+        // theBit = n % 32
+        int theBit = n &amp; 0x1F;
+        int setter = 1 &lt;&lt; theBit;
+        m_ints[theInt] |= setter;
+    }
+
+    public IntArray multiply(IntArray other, int m)
+    {
+        // Lenght of c is 2m bits rounded up to the next int (32 bit)
+        int t = (m + 31) &gt;&gt; 5;
+        if (m_ints.length &lt; t)
+        {
+            m_ints = resizedInts(t);
+        }
+
+        IntArray b = new IntArray(other.resizedInts(other.getLength() + 1));
+        IntArray c = new IntArray((m + m + 31) &gt;&gt; 5);
+        // IntArray c = new IntArray(t + t);
+        int testBit = 1;
+        for (int k = 0; k &lt; 32; k++)
+        {
+            for (int j = 0; j &lt; t; j++)
+            {
+                if ((m_ints[j] &amp; testBit) != 0)
+                {
+                    // The kth bit of m_ints[j] is set
+                    c.addShifted(b, j);
+                }
+            }
+            testBit &lt;&lt;= 1;
+            b.shiftLeft();
+        }
+        return c;
+    }
+
+    // public IntArray multiplyLeftToRight(IntArray other, int m) {
+    // // Lenght of c is 2m bits rounded up to the next int (32 bit)
+    // int t = (m + 31) / 32;
+    // if (m_ints.length &lt; t) {
+    // m_ints = resizedInts(t);
+    // }
+    //
+    // IntArray b = new IntArray(other.resizedInts(other.getLength() + 1));
+    // IntArray c = new IntArray((m + m + 31) / 32);
+    // // IntArray c = new IntArray(t + t);
+    // int testBit = 1 &lt;&lt; 31;
+    // for (int k = 31; k &gt;= 0; k--) {
+    // for (int j = 0; j &lt; t; j++) {
+    // if ((m_ints[j] &amp; testBit) != 0) {
+    // // The kth bit of m_ints[j] is set
+    // c.addShifted(b, j);
+    // }
+    // }
+    // testBit &gt;&gt;&gt;= 1;
+    // if (k &gt; 0) {
+    // c.shiftLeft();
+    // }
+    // }
+    // return c;
+    // }
+
+    // TODO note, redPol.length must be 3 for TPB and 5 for PPB
+    public void reduce(int m, int[] redPol)
+    {
+        for (int i = m + m - 2; i &gt;= m; i--)
+        {
+            if (testBit(i))
+            {
+                int bit = i - m;
+                flipBit(bit);
+                flipBit(i);
+                int l = redPol.length;
+                while (--l &gt;= 0)
+                {
+                    flipBit(redPol[l] + bit);
+                }
+            }
+        }
+        m_ints = resizedInts((m + 31) &gt;&gt; 5);
+    }
+
+    public IntArray square(int m)
+    {
+        // TODO make the table static final
+        final int[] table = { 0x0, 0x1, 0x4, 0x5, 0x10, 0x11, 0x14, 0x15, 0x40,
+            0x41, 0x44, 0x45, 0x50, 0x51, 0x54, 0x55 };
+
+        int t = (m + 31) &gt;&gt; 5;
+        if (m_ints.length &lt; t)
+        {
+            m_ints = resizedInts(t);
+        }
+
+        IntArray c = new IntArray(t + t);
+
+        // TODO twice the same code, put in separate private method
+        for (int i = 0; i &lt; t; i++)
+        {
+            int v0 = 0;
+            for (int j = 0; j &lt; 4; j++)
+            {
+                v0 = v0 &gt;&gt;&gt; 8;
+                int u = (m_ints[i] &gt;&gt;&gt; (j * 4)) &amp; 0xF;
+                int w = table[u] &lt;&lt; 24;
+                v0 |= w;
+            }
+            c.m_ints[i + i] = v0;
+
+            v0 = 0;
+            int upper = m_ints[i] &gt;&gt;&gt; 16;
+            for (int j = 0; j &lt; 4; j++)
+            {
+                v0 = v0 &gt;&gt;&gt; 8;
+                int u = (upper &gt;&gt;&gt; (j * 4)) &amp; 0xF;
+                int w = table[u] &lt;&lt; 24;
+                v0 |= w;
+            }
+            c.m_ints[i + i + 1] = v0;
+        }
+        return c;
+    }
+
+    public boolean equals(Object o)
+    {
+        if (!(o instanceof IntArray))
+        {
+            return false;
+        }
+        IntArray other = (IntArray) o;
+        int usedLen = getUsedLength();
+        if (other.getUsedLength() != usedLen)
+        {
+            return false;
+        }
+        for (int i = 0; i &lt; usedLen; i++)
+        {
+            if (m_ints[i] != other.m_ints[i])
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public int hashCode()
+    {
+        int usedLen = getUsedLength();
+        int hash = 1;
+        for (int i = 0; i &lt; usedLen; i++)
+        {
+            hash = hash * 31 + m_ints[i];
+        }
+        return hash;
+    }
+
+    public Object clone()
+    {
+        return new IntArray(Arrays.clone(m_ints));
+    }
+
+    public String toString()
+    {
+        int usedLen = getUsedLength();
+        if (usedLen == 0)
+        {
+            return &quot;0&quot;;
+        }
+
+        StringBuffer sb = new StringBuffer(Integer
+            .toBinaryString(m_ints[usedLen - 1]));
+        for (int iarrJ = usedLen - 2; iarrJ &gt;= 0; iarrJ--)
+        {
+            String hexString = Integer.toBinaryString(m_ints[iarrJ]);
+
+            // Add leading zeroes, except for highest significant int
+            for (int i = hexString.length(); i &lt; 8; i++)
+            {
+                hexString = &quot;0&quot; + hexString;
+            }
+            sb.append(hexString);
+        }
+        return sb.toString();
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/PreCompInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/PreCompInfo.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/PreCompInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/PreCompInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,10 @@
+package org.bouncycastle.math.ec;
+
+/**
+ * Interface for classes storing precomputation data for multiplication
+ * algorithms. Used as a Memento (see GOF patterns) for
+ * &lt;code&gt;WNafMultiplier&lt;/code&gt;.
+ */
+interface PreCompInfo
+{
+}

Added: trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/SimpleBigDecimal.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,253 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class representing a simple version of a big decimal. A
+ * &lt;code&gt;SimpleBigDecimal&lt;/code&gt; is basically a
+ * {@link java.math.BigInteger BigInteger} with a few digits on the right of
+ * the decimal point. The number of (binary) digits on the right of the decimal
+ * point is called the &lt;code&gt;scale&lt;/code&gt; of the &lt;code&gt;SimpleBigDecimal&lt;/code&gt;.
+ * Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
+ * automatically, but must be set manually. All &lt;code&gt;SimpleBigDecimal&lt;/code&gt;s
+ * taking part in the same arithmetic operation must have equal scale. The
+ * result of a multiplication of two &lt;code&gt;SimpleBigDecimal&lt;/code&gt;s returns a
+ * &lt;code&gt;SimpleBigDecimal&lt;/code&gt; with double scale.
+ */
+class SimpleBigDecimal
+    //extends Number   // not in J2ME - add compatibility class?
+{
+    private static final long serialVersionUID = 1L;
+
+    private final BigInteger bigInt;
+    private final int scale;
+
+    /**
+     * Returns a &lt;code&gt;SimpleBigDecimal&lt;/code&gt; representing the same numerical
+     * value as &lt;code&gt;value&lt;/code&gt;.
+     * @param value The value of the &lt;code&gt;SimpleBigDecimal&lt;/code&gt; to be
+     * created. 
+     * @param scale The scale of the &lt;code&gt;SimpleBigDecimal&lt;/code&gt; to be
+     * created. 
+     * @return The such created &lt;code&gt;SimpleBigDecimal&lt;/code&gt;.
+     */
+    public static SimpleBigDecimal getInstance(BigInteger value, int scale)
+    {
+        return new SimpleBigDecimal(value.shiftLeft(scale), scale);
+    }
+
+    /**
+     * Constructor for &lt;code&gt;SimpleBigDecimal&lt;/code&gt;. The value of the
+     * constructed &lt;code&gt;SimpleBigDecimal&lt;/code&gt; equals &lt;code&gt;bigInt / 
+     * 2&lt;sup&gt;scale&lt;/sup&gt;&lt;/code&gt;.
+     * @param bigInt The &lt;code&gt;bigInt&lt;/code&gt; value parameter.
+     * @param scale The scale of the constructed &lt;code&gt;SimpleBigDecimal&lt;/code&gt;.
+     */
+    public SimpleBigDecimal(BigInteger bigInt, int scale)
+    {
+        if (scale &lt; 0)
+        {
+            throw new IllegalArgumentException(&quot;scale may not be negative&quot;);
+        }
+
+        this.bigInt = bigInt;
+        this.scale = scale;
+    }
+
+    private SimpleBigDecimal(SimpleBigDecimal limBigDec)
+    {
+        bigInt = limBigDec.bigInt;
+        scale = limBigDec.scale;
+    }
+
+    private void checkScale(SimpleBigDecimal b)
+    {
+        if (scale != b.scale)
+        {
+            throw new IllegalArgumentException(&quot;Only SimpleBigDecimal of &quot; +
+                &quot;same scale allowed in arithmetic operations&quot;);
+        }
+    }
+
+    public SimpleBigDecimal adjustScale(int newScale)
+    {
+        if (newScale &lt; 0)
+        {
+            throw new IllegalArgumentException(&quot;scale may not be negative&quot;);
+        }
+
+        if (newScale == scale)
+        {
+            return new SimpleBigDecimal(this);
+        }
+
+        return new SimpleBigDecimal(bigInt.shiftLeft(newScale - scale),
+                newScale);
+    }
+
+    public SimpleBigDecimal add(SimpleBigDecimal b)
+    {
+        checkScale(b);
+        return new SimpleBigDecimal(bigInt.add(b.bigInt), scale);
+    }
+
+    public SimpleBigDecimal add(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.add(b.shiftLeft(scale)), scale);
+    }
+
+    public SimpleBigDecimal negate()
+    {
+        return new SimpleBigDecimal(bigInt.negate(), scale);
+    }
+
+    public SimpleBigDecimal subtract(SimpleBigDecimal b)
+    {
+        return add(b.negate());
+    }
+
+    public SimpleBigDecimal subtract(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.subtract(b.shiftLeft(scale)),
+                scale);
+    }
+
+    public SimpleBigDecimal multiply(SimpleBigDecimal b)
+    {
+        checkScale(b);
+        return new SimpleBigDecimal(bigInt.multiply(b.bigInt), scale + scale);
+    }
+
+    public SimpleBigDecimal multiply(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.multiply(b), scale);
+    }
+
+    public SimpleBigDecimal divide(SimpleBigDecimal b)
+    {
+        checkScale(b);
+        BigInteger dividend = bigInt.shiftLeft(scale);
+        return new SimpleBigDecimal(dividend.divide(b.bigInt), scale);
+    }
+
+    public SimpleBigDecimal divide(BigInteger b)
+    {
+        return new SimpleBigDecimal(bigInt.divide(b), scale);
+    }
+
+    public SimpleBigDecimal shiftLeft(int n)
+    {
+        return new SimpleBigDecimal(bigInt.shiftLeft(n), scale);
+    }
+
+    public int compareTo(SimpleBigDecimal val)
+    {
+        checkScale(val);
+        return bigInt.compareTo(val.bigInt);
+    }
+
+    public int compareTo(BigInteger val)
+    {
+        return bigInt.compareTo(val.shiftLeft(scale));
+    }
+
+    public BigInteger floor()
+    {
+        return bigInt.shiftRight(scale);
+    }
+
+    public BigInteger round()
+    {
+        SimpleBigDecimal oneHalf = new SimpleBigDecimal(ECConstants.ONE, 1);
+        return add(oneHalf.adjustScale(scale)).floor();
+    }
+
+    public int intValue()
+    {
+        return floor().intValue();
+    }
+    
+    public long longValue()
+    {
+        return floor().longValue();
+    }
+          /* NON-J2ME compliant.
+    public double doubleValue()
+    {
+        return Double.valueOf(toString()).doubleValue();
+    }
+
+    public float floatValue()
+    {
+        return Float.valueOf(toString()).floatValue();
+    }
+       */
+    public int getScale()
+    {
+        return scale;
+    }
+
+    public String toString()
+    {
+        if (scale == 0)
+        {
+            return bigInt.toString();
+        }
+
+        BigInteger floorBigInt = floor();
+        
+        BigInteger fract = bigInt.subtract(floorBigInt.shiftLeft(scale));
+        if (bigInt.signum() == -1)
+        {
+            fract = ECConstants.ONE.shiftLeft(scale).subtract(fract);
+        }
+
+        if ((floorBigInt.signum() == -1) &amp;&amp; (!(fract.equals(ECConstants.ZERO))))
+        {
+            floorBigInt = floorBigInt.add(ECConstants.ONE);
+        }
+        String leftOfPoint = floorBigInt.toString();
+
+        char[] fractCharArr = new char[scale];
+        String fractStr = fract.toString(2);
+        int fractLen = fractStr.length();
+        int zeroes = scale - fractLen;
+        for (int i = 0; i &lt; zeroes; i++)
+        {
+            fractCharArr[i] = '0';
+        }
+        for (int j = 0; j &lt; fractLen; j++)
+        {
+            fractCharArr[zeroes + j] = fractStr.charAt(j);
+        }
+        String rightOfPoint = new String(fractCharArr);
+
+        StringBuffer sb = new StringBuffer(leftOfPoint);
+        sb.append(&quot;.&quot;);
+        sb.append(rightOfPoint);
+
+        return sb.toString();
+    }
+
+    public boolean equals(Object o)
+    {
+        if (this == o)
+        {
+            return true;
+        }
+
+        if (!(o instanceof SimpleBigDecimal))
+        {
+            return false;
+        }
+
+        SimpleBigDecimal other = (SimpleBigDecimal)o;
+        return ((bigInt.equals(other.bigInt)) &amp;&amp; (scale == other.scale));
+    }
+
+    public int hashCode()
+    {
+        return bigInt.hashCode() ^ scale;
+    }
+
+}

Added: trunk/src/org/bouncycastle/math/ec/Tnaf.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/Tnaf.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/Tnaf.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/Tnaf.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/Tnaf.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,844 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class holding methods for point multiplication based on the window
+ * &tau;-adic nonadjacent form (WTNAF). The algorithms are based on the
+ * paper &quot;Improved Algorithms for Arithmetic on Anomalous Binary Curves&quot;
+ * by Jerome A. Solinas. The paper first appeared in the Proceedings of
+ * Crypto 1997.
+ */
+class Tnaf
+{
+    private static final BigInteger MINUS_ONE = ECConstants.ONE.negate();
+    private static final BigInteger MINUS_TWO = ECConstants.TWO.negate();
+    private static final BigInteger MINUS_THREE = ECConstants.THREE.negate();
+
+    /**
+     * The window width of WTNAF. The standard value of 4 is slightly less
+     * than optimal for running time, but keeps space requirements for
+     * precomputation low. For typical curves, a value of 5 or 6 results in
+     * a better running time. When changing this value, the
+     * &lt;code&gt;&alpha;&lt;sub&gt;u&lt;/sub&gt;&lt;/code&gt;'s must be computed differently, see
+     * e.g. &quot;Guide to Elliptic Curve Cryptography&quot;, Darrel Hankerson,
+     * Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
+     * p. 121-122
+     */
+    public static final byte WIDTH = 4;
+
+    /**
+     * 2&lt;sup&gt;4&lt;/sup&gt;
+     */
+    public static final byte POW_2_WIDTH = 16;
+
+    /**
+     * The &lt;code&gt;&alpha;&lt;sub&gt;u&lt;/sub&gt;&lt;/code&gt;'s for &lt;code&gt;a=0&lt;/code&gt; as an array
+     * of &lt;code&gt;ZTauElement&lt;/code&gt;s.
+     */
+    public static final ZTauElement[] alpha0 = {
+        null,
+        new ZTauElement(ECConstants.ONE, ECConstants.ZERO), null,
+        new ZTauElement(MINUS_THREE, MINUS_ONE), null,
+        new ZTauElement(MINUS_ONE, MINUS_ONE), null,
+        new ZTauElement(ECConstants.ONE, MINUS_ONE), null
+    };
+
+    /**
+     * The &lt;code&gt;&alpha;&lt;sub&gt;u&lt;/sub&gt;&lt;/code&gt;'s for &lt;code&gt;a=0&lt;/code&gt; as an array
+     * of TNAFs.
+     */
+    public static final byte[][] alpha0Tnaf = {
+        null, {1}, null, {-1, 0, 1}, null, {1, 0, 1}, null, {-1, 0, 0, 1}
+    };
+
+    /**
+     * The &lt;code&gt;&alpha;&lt;sub&gt;u&lt;/sub&gt;&lt;/code&gt;'s for &lt;code&gt;a=1&lt;/code&gt; as an array
+     * of &lt;code&gt;ZTauElement&lt;/code&gt;s.
+     */
+    public static final ZTauElement[] alpha1 = {null,
+        new ZTauElement(ECConstants.ONE, ECConstants.ZERO), null,
+        new ZTauElement(MINUS_THREE, ECConstants.ONE), null,
+        new ZTauElement(MINUS_ONE, ECConstants.ONE), null,
+        new ZTauElement(ECConstants.ONE, ECConstants.ONE), null
+    };
+
+    /**
+     * The &lt;code&gt;&alpha;&lt;sub&gt;u&lt;/sub&gt;&lt;/code&gt;'s for &lt;code&gt;a=1&lt;/code&gt; as an array
+     * of TNAFs.
+     */
+    public static final byte[][] alpha1Tnaf = {
+        null, {1}, null, {-1, 0, 1}, null, {1, 0, 1}, null, {-1, 0, 0, -1}
+    };
+
+    /**
+     * Computes the norm of an element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @param mu The parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+     * @param lambda The element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @return The norm of &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    public static BigInteger norm(final byte mu, ZTauElement lambda)
+    {
+        BigInteger norm;
+
+        // s1 = u^2
+        BigInteger s1 = lambda.u.multiply(lambda.u);
+
+        // s2 = u * v
+        BigInteger s2 = lambda.u.multiply(lambda.v);
+
+        // s3 = 2 * v^2
+        BigInteger s3 = lambda.v.multiply(lambda.v).shiftLeft(1);
+
+        if (mu == 1)
+        {
+            norm = s1.add(s2).add(s3);
+        }
+        else if (mu == -1)
+        {
+            norm = s1.subtract(s2).add(s3);
+        }
+        else
+        {
+            throw new IllegalArgumentException(&quot;mu must be 1 or -1&quot;);
+        }
+
+        return norm;
+    }
+
+    /**
+     * Computes the norm of an element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;R&lt;/b&gt;[&tau;]&lt;/code&gt;, where &lt;code&gt;&lambda; = u + v&tau;&lt;/code&gt;
+     * and &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt; are real numbers (elements of
+     * &lt;code&gt;&lt;b&gt;R&lt;/b&gt;&lt;/code&gt;). 
+     * @param mu The parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+     * @param u The real part of the element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;R&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @param v The &lt;code&gt;&tau;&lt;/code&gt;-adic part of the element
+     * &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;R&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @return The norm of &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    public static SimpleBigDecimal norm(final byte mu, SimpleBigDecimal u,
+            SimpleBigDecimal v)
+    {
+        SimpleBigDecimal norm;
+
+        // s1 = u^2
+        SimpleBigDecimal s1 = u.multiply(u);
+
+        // s2 = u * v
+        SimpleBigDecimal s2 = u.multiply(v);
+
+        // s3 = 2 * v^2
+        SimpleBigDecimal s3 = v.multiply(v).shiftLeft(1);
+
+        if (mu == 1)
+        {
+            norm = s1.add(s2).add(s3);
+        }
+        else if (mu == -1)
+        {
+            norm = s1.subtract(s2).add(s3);
+        }
+        else
+        {
+            throw new IllegalArgumentException(&quot;mu must be 1 or -1&quot;);
+        }
+
+        return norm;
+    }
+
+    /**
+     * Rounds an element &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;R&lt;/b&gt;[&tau;]&lt;/code&gt;
+     * to an element of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;, such that their difference
+     * has minimal norm. &lt;code&gt;&lambda;&lt;/code&gt; is given as
+     * &lt;code&gt;&lambda; = &lambda;&lt;sub&gt;0&lt;/sub&gt; + &lambda;&lt;sub&gt;1&lt;/sub&gt;&tau;&lt;/code&gt;.
+     * @param lambda0 The component &lt;code&gt;&lambda;&lt;sub&gt;0&lt;/sub&gt;&lt;/code&gt;.
+     * @param lambda1 The component &lt;code&gt;&lambda;&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;.
+     * @param mu The parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve. Must
+     * equal 1 or -1.
+     * @return The rounded element of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @throws IllegalArgumentException if &lt;code&gt;lambda0&lt;/code&gt; and
+     * &lt;code&gt;lambda1&lt;/code&gt; do not have same scale.
+     */
+    public static ZTauElement round(SimpleBigDecimal lambda0,
+            SimpleBigDecimal lambda1, byte mu)
+    {
+        int scale = lambda0.getScale();
+        if (lambda1.getScale() != scale)
+        {
+            throw new IllegalArgumentException(&quot;lambda0 and lambda1 do not &quot; +
+                    &quot;have same scale&quot;);
+        }
+
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException(&quot;mu must be 1 or -1&quot;);
+        }
+
+        BigInteger f0 = lambda0.round();
+        BigInteger f1 = lambda1.round();
+
+        SimpleBigDecimal eta0 = lambda0.subtract(f0);
+        SimpleBigDecimal eta1 = lambda1.subtract(f1);
+
+        // eta = 2*eta0 + mu*eta1
+        SimpleBigDecimal eta = eta0.add(eta0);
+        if (mu == 1)
+        {
+            eta = eta.add(eta1);
+        }
+        else
+        {
+            // mu == -1
+            eta = eta.subtract(eta1);
+        }
+
+        // check1 = eta0 - 3*mu*eta1
+        // check2 = eta0 + 4*mu*eta1
+        SimpleBigDecimal threeEta1 = eta1.add(eta1).add(eta1);
+        SimpleBigDecimal fourEta1 = threeEta1.add(eta1);
+        SimpleBigDecimal check1;
+        SimpleBigDecimal check2;
+        if (mu == 1)
+        {
+            check1 = eta0.subtract(threeEta1);
+            check2 = eta0.add(fourEta1);
+        }
+        else
+        {
+            // mu == -1
+            check1 = eta0.add(threeEta1);
+            check2 = eta0.subtract(fourEta1);
+        }
+
+        byte h0 = 0;
+        byte h1 = 0;
+
+        // if eta &gt;= 1
+        if (eta.compareTo(ECConstants.ONE) &gt;= 0)
+        {
+            if (check1.compareTo(MINUS_ONE) &lt; 0)
+            {
+                h1 = mu;
+            }
+            else
+            {
+                h0 = 1;
+            }
+        }
+        else
+        {
+            // eta &lt; 1
+            if (check2.compareTo(ECConstants.TWO) &gt;= 0)
+            {
+                h1 = mu;
+            }
+        }
+
+        // if eta &lt; -1
+        if (eta.compareTo(MINUS_ONE) &lt; 0)
+        {
+            if (check1.compareTo(ECConstants.ONE) &gt;= 0)
+            {
+                h1 = (byte)-mu;
+            }
+            else
+            {
+                h0 = -1;
+            }
+        }
+        else
+        {
+            // eta &gt;= -1
+            if (check2.compareTo(MINUS_TWO) &lt; 0)
+            {
+                h1 = (byte)-mu;
+            }
+        }
+
+        BigInteger q0 = f0.add(BigInteger.valueOf(h0));
+        BigInteger q1 = f1.add(BigInteger.valueOf(h1));
+        return new ZTauElement(q0, q1);
+    }
+
+    /**
+     * Approximate division by &lt;code&gt;n&lt;/code&gt;. For an integer
+     * &lt;code&gt;k&lt;/code&gt;, the value &lt;code&gt;&lambda; = s k / n&lt;/code&gt; is
+     * computed to &lt;code&gt;c&lt;/code&gt; bits of accuracy.
+     * @param k The parameter &lt;code&gt;k&lt;/code&gt;.
+     * @param s The curve parameter &lt;code&gt;s&lt;sub&gt;0&lt;/sub&gt;&lt;/code&gt; or
+     * &lt;code&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;.
+     * @param vm The Lucas Sequence element &lt;code&gt;V&lt;sub&gt;m&lt;/sub&gt;&lt;/code&gt;.
+     * @param a The parameter &lt;code&gt;a&lt;/code&gt; of the elliptic curve.
+     * @param m The bit length of the finite field
+     * &lt;code&gt;&lt;b&gt;F&lt;/b&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/code&gt;.
+     * @param c The number of bits of accuracy, i.e. the scale of the returned
+     * &lt;code&gt;SimpleBigDecimal&lt;/code&gt;.
+     * @return The value &lt;code&gt;&lambda; = s k / n&lt;/code&gt; computed to
+     * &lt;code&gt;c&lt;/code&gt; bits of accuracy.
+     */
+    public static SimpleBigDecimal approximateDivisionByN(BigInteger k,
+            BigInteger s, BigInteger vm, byte a, int m, int c)
+    {
+        int _k = (m + 5)/2 + c;
+        BigInteger ns = k.shiftRight(m - _k - 2 + a);
+
+        BigInteger gs = s.multiply(ns);
+
+        BigInteger hs = gs.shiftRight(m);
+
+        BigInteger js = vm.multiply(hs);
+
+        BigInteger gsPlusJs = gs.add(js);
+        BigInteger ls = gsPlusJs.shiftRight(_k-c);
+        if (gsPlusJs.testBit(_k-c-1))
+        {
+            // round up
+            ls = ls.add(ECConstants.ONE);
+        }
+
+        return new SimpleBigDecimal(ls, c);
+    }
+
+    /**
+     * Computes the &lt;code&gt;&tau;&lt;/code&gt;-adic NAF (non-adjacent form) of an
+     * element &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @param mu The parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+     * @param lambda The element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @return The &lt;code&gt;&tau;&lt;/code&gt;-adic NAF of &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    public static byte[] tauAdicNaf(byte mu, ZTauElement lambda)
+    {
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException(&quot;mu must be 1 or -1&quot;);
+        }
+        
+        BigInteger norm = norm(mu, lambda);
+
+        // Ceiling of log2 of the norm 
+        int log2Norm = norm.bitLength();
+
+        // If length(TNAF) &gt; 30, then length(TNAF) &lt; log2Norm + 3.52
+        int maxLength = log2Norm &gt; 30 ? log2Norm + 4 : 34;
+
+        // The array holding the TNAF
+        byte[] u = new byte[maxLength];
+        int i = 0;
+
+        // The actual length of the TNAF
+        int length = 0;
+
+        BigInteger r0 = lambda.u;
+        BigInteger r1 = lambda.v;
+
+        while(!((r0.equals(ECConstants.ZERO)) &amp;&amp; (r1.equals(ECConstants.ZERO))))
+        {
+            // If r0 is odd
+            if (r0.testBit(0))
+            {
+                u[i] = (byte) ECConstants.TWO.subtract((r0.subtract(r1.shiftLeft(1))).mod(ECConstants.FOUR)).intValue();
+
+                // r0 = r0 - u[i]
+                if (u[i] == 1)
+                {
+                    r0 = r0.clearBit(0);
+                }
+                else
+                {
+                    // u[i] == -1
+                    r0 = r0.add(ECConstants.ONE);
+                }
+                length = i;
+            }
+            else
+            {
+                u[i] = 0;
+            }
+
+            BigInteger t = r0;
+            BigInteger s = r0.shiftRight(1);
+            if (mu == 1)
+            {
+                r0 = r1.add(s);
+            }
+            else
+            {
+                // mu == -1
+                r0 = r1.subtract(s);
+            }
+
+            r1 = t.shiftRight(1).negate();
+            i++;
+        }
+
+        length++;
+
+        // Reduce the TNAF array to its actual length
+        byte[] tnaf = new byte[length];
+        System.arraycopy(u, 0, tnaf, 0, length);
+        return tnaf;
+    }
+
+    /**
+     * Applies the operation &lt;code&gt;&tau;()&lt;/code&gt; to an
+     * &lt;code&gt;ECPoint.F2m&lt;/code&gt;. 
+     * @param p The ECPoint.F2m to which &lt;code&gt;&tau;()&lt;/code&gt; is applied.
+     * @return &lt;code&gt;&tau;(p)&lt;/code&gt;
+     */
+    public static ECPoint.F2m tau(ECPoint.F2m p)
+    {
+        if (p.isInfinity())
+        {
+            return p;
+        }
+
+        ECFieldElement x = p.getX();
+        ECFieldElement y = p.getY();
+
+        return new ECPoint.F2m(p.getCurve(), x.square(), y.square(), p.isCompressed());
+    }
+
+    /**
+     * Returns the parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+     * @param curve The elliptic curve from which to obtain &lt;code&gt;&mu;&lt;/code&gt;.
+     * The curve must be a Koblitz curve, i.e. &lt;code&gt;a&lt;/code&gt; equals
+     * &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; equals
+     * &lt;code&gt;1&lt;/code&gt;. 
+     * @return &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+     * @throws IllegalArgumentException if the given ECCurve is not a Koblitz
+     * curve.
+     */
+    public static byte getMu(ECCurve.F2m curve)
+    {
+        BigInteger a = curve.getA().toBigInteger();
+        byte mu;
+
+        if (a.equals(ECConstants.ZERO))
+        {
+            mu = -1;
+        }
+        else if (a.equals(ECConstants.ONE))
+        {
+            mu = 1;
+        }
+        else
+        {
+            throw new IllegalArgumentException(&quot;No Koblitz curve (ABC), &quot; +
+                    &quot;TNAF multiplication not possible&quot;);
+        }
+        return mu;
+    }
+
+    /**
+     * Calculates the Lucas Sequence elements &lt;code&gt;U&lt;sub&gt;k-1&lt;/sub&gt;&lt;/code&gt; and
+     * &lt;code&gt;U&lt;sub&gt;k&lt;/sub&gt;&lt;/code&gt; or &lt;code&gt;V&lt;sub&gt;k-1&lt;/sub&gt;&lt;/code&gt; and
+     * &lt;code&gt;V&lt;sub&gt;k&lt;/sub&gt;&lt;/code&gt;.
+     * @param mu The parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+     * @param k The index of the second element of the Lucas Sequence to be
+     * returned.
+     * @param doV If set to true, computes &lt;code&gt;V&lt;sub&gt;k-1&lt;/sub&gt;&lt;/code&gt; and
+     * &lt;code&gt;V&lt;sub&gt;k&lt;/sub&gt;&lt;/code&gt;, otherwise &lt;code&gt;U&lt;sub&gt;k-1&lt;/sub&gt;&lt;/code&gt; and
+     * &lt;code&gt;U&lt;sub&gt;k&lt;/sub&gt;&lt;/code&gt;.
+     * @return An array with 2 elements, containing &lt;code&gt;U&lt;sub&gt;k-1&lt;/sub&gt;&lt;/code&gt;
+     * and &lt;code&gt;U&lt;sub&gt;k&lt;/sub&gt;&lt;/code&gt; or &lt;code&gt;V&lt;sub&gt;k-1&lt;/sub&gt;&lt;/code&gt;
+     * and &lt;code&gt;V&lt;sub&gt;k&lt;/sub&gt;&lt;/code&gt;.
+     */
+    public static BigInteger[] getLucas(byte mu, int k, boolean doV)
+    {
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException(&quot;mu must be 1 or -1&quot;);
+        }
+
+        BigInteger u0;
+        BigInteger u1;
+        BigInteger u2;
+
+        if (doV)
+        {
+            u0 = ECConstants.TWO;
+            u1 = BigInteger.valueOf(mu);
+        }
+        else
+        {
+            u0 = ECConstants.ZERO;
+            u1 = ECConstants.ONE;
+        }
+
+        for (int i = 1; i &lt; k; i++)
+        {
+            // u2 = mu*u1 - 2*u0;
+            BigInteger s = null;
+            if (mu == 1)
+            {
+                s = u1;
+            }
+            else
+            {
+                // mu == -1
+                s = u1.negate();
+            }
+            
+            u2 = s.subtract(u0.shiftLeft(1));
+            u0 = u1;
+            u1 = u2;
+//            System.out.println(i + &quot;: &quot; + u2);
+//            System.out.println();
+        }
+
+        BigInteger[] retVal = {u0, u1};
+        return retVal;
+    }
+
+    /**
+     * Computes the auxiliary value &lt;code&gt;t&lt;sub&gt;w&lt;/sub&gt;&lt;/code&gt;. If the width is
+     * 4, then for &lt;code&gt;mu = 1&lt;/code&gt;, &lt;code&gt;t&lt;sub&gt;w&lt;/sub&gt; = 6&lt;/code&gt; and for
+     * &lt;code&gt;mu = -1&lt;/code&gt;, &lt;code&gt;t&lt;sub&gt;w&lt;/sub&gt; = 10&lt;/code&gt; 
+     * @param mu The parameter &lt;code&gt;&mu;&lt;/code&gt; of the elliptic curve.
+     * @param w The window width of the WTNAF.
+     * @return the auxiliary value &lt;code&gt;t&lt;sub&gt;w&lt;/sub&gt;&lt;/code&gt;
+     */
+    public static BigInteger getTw(byte mu, int w)
+    {
+        if (w == 4)
+        {
+            if (mu == 1)
+            {
+                return BigInteger.valueOf(6);
+            }
+            else
+            {
+                // mu == -1
+                return BigInteger.valueOf(10);
+            }
+        }
+        else
+        {
+            // For w &lt;&gt; 4, the values must be computed
+            BigInteger[] us = getLucas(mu, w, false);
+            BigInteger twoToW = ECConstants.ZERO.setBit(w);
+            BigInteger u1invert = us[1].modInverse(twoToW);
+            BigInteger tw;
+            tw = ECConstants.TWO.multiply(us[0]).multiply(u1invert).mod(twoToW);
+//            System.out.println(&quot;mu = &quot; + mu);
+//            System.out.println(&quot;tw = &quot; + tw);
+            return tw;
+        }
+    }
+
+    /**
+     * Computes the auxiliary values &lt;code&gt;s&lt;sub&gt;0&lt;/sub&gt;&lt;/code&gt; and
+     * &lt;code&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; used for partial modular reduction. 
+     * @param curve The elliptic curve for which to compute
+     * &lt;code&gt;s&lt;sub&gt;0&lt;/sub&gt;&lt;/code&gt; and &lt;code&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;.
+     * @throws IllegalArgumentException if &lt;code&gt;curve&lt;/code&gt; is not a
+     * Koblitz curve (Anomalous Binary Curve, ABC).
+     */
+    public static BigInteger[] getSi(ECCurve.F2m curve)
+    {
+        if (!curve.isKoblitz())
+        {
+            throw new IllegalArgumentException(&quot;si is defined for Koblitz curves only&quot;);
+        }
+
+        int m = curve.getM();
+        int a = curve.getA().toBigInteger().intValue();
+        byte mu = curve.getMu();
+        int h = curve.getH().intValue();
+        int index = m + 3 - a;
+        BigInteger[] ui = getLucas(mu, index, false);
+
+        BigInteger dividend0;
+        BigInteger dividend1;
+        if (mu == 1)
+        {
+            dividend0 = ECConstants.ONE.subtract(ui[1]);
+            dividend1 = ECConstants.ONE.subtract(ui[0]);
+        }
+        else if (mu == -1)
+        {
+            dividend0 = ECConstants.ONE.add(ui[1]);
+            dividend1 = ECConstants.ONE.add(ui[0]);
+        }
+        else
+        {
+            throw new IllegalArgumentException(&quot;mu must be 1 or -1&quot;);
+        }
+
+        BigInteger[] si = new BigInteger[2];
+
+        if (h == 2)
+        {
+            si[0] = dividend0.shiftRight(1);
+            si[1] = dividend1.shiftRight(1).negate();
+        }
+        else if (h == 4)
+        {
+            si[0] = dividend0.shiftRight(2);
+            si[1] = dividend1.shiftRight(2).negate();
+        }
+        else
+        {
+            throw new IllegalArgumentException(&quot;h (Cofactor) must be 2 or 4&quot;);
+        }
+
+        return si;
+    }
+
+    /**
+     * Partial modular reduction modulo
+     * &lt;code&gt;(&tau;&lt;sup&gt;m&lt;/sup&gt; - 1)/(&tau; - 1)&lt;/code&gt;.
+     * @param k The integer to be reduced.
+     * @param m The bitlength of the underlying finite field.
+     * @param a The parameter &lt;code&gt;a&lt;/code&gt; of the elliptic curve.
+     * @param s The auxiliary values &lt;code&gt;s&lt;sub&gt;0&lt;/sub&gt;&lt;/code&gt; and
+     * &lt;code&gt;s&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;.
+     * @param mu The parameter &mu; of the elliptic curve.
+     * @param c The precision (number of bits of accuracy) of the partial
+     * modular reduction.
+     * @return &lt;code&gt;&rho; := k partmod (&tau;&lt;sup&gt;m&lt;/sup&gt; - 1)/(&tau; - 1)&lt;/code&gt;
+     */
+    public static ZTauElement partModReduction(BigInteger k, int m, byte a,
+            BigInteger[] s, byte mu, byte c)
+    {
+        // d0 = s[0] + mu*s[1]; mu is either 1 or -1
+        BigInteger d0;
+        if (mu == 1)
+        {
+            d0 = s[0].add(s[1]);
+        }
+        else
+        {
+            d0 = s[0].subtract(s[1]);
+        }
+
+        BigInteger[] v = getLucas(mu, m, true);
+        BigInteger vm = v[1];
+
+        SimpleBigDecimal lambda0 = approximateDivisionByN(
+                k, s[0], vm, a, m, c);
+        
+        SimpleBigDecimal lambda1 = approximateDivisionByN(
+                k, s[1], vm, a, m, c);
+
+        ZTauElement q = round(lambda0, lambda1, mu);
+
+        // r0 = n - d0*q0 - 2*s1*q1
+        BigInteger r0 = k.subtract(d0.multiply(q.u)).subtract(
+                BigInteger.valueOf(2).multiply(s[1]).multiply(q.v));
+
+        // r1 = s1*q0 - s0*q1
+        BigInteger r1 = s[1].multiply(q.u).subtract(s[0].multiply(q.v));
+        
+        return new ZTauElement(r0, r1);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by a &lt;code&gt;BigInteger&lt;/code&gt; using the reduced &lt;code&gt;&tau;&lt;/code&gt;-adic
+     * NAF (RTNAF) method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param k The &lt;code&gt;BigInteger&lt;/code&gt; by which to multiply &lt;code&gt;p&lt;/code&gt;.
+     * @return &lt;code&gt;k * p&lt;/code&gt;
+     */
+    public static ECPoint.F2m multiplyRTnaf(ECPoint.F2m p, BigInteger k)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m) p.getCurve();
+        int m = curve.getM();
+        byte a = (byte) curve.getA().toBigInteger().intValue();
+        byte mu = curve.getMu();
+        BigInteger[] s = curve.getSi();
+        ZTauElement rho = partModReduction(k, m, a, s, mu, (byte)10);
+
+        return multiplyTnaf(p, rho);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by an element &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;
+     * using the &lt;code&gt;&tau;&lt;/code&gt;-adic NAF (TNAF) method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param lambda The element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @return &lt;code&gt;&lambda; * p&lt;/code&gt;
+     */
+    public static ECPoint.F2m multiplyTnaf(ECPoint.F2m p, ZTauElement lambda)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m)p.getCurve();
+        byte mu = curve.getMu();
+        byte[] u = tauAdicNaf(mu, lambda);
+
+        ECPoint.F2m q = multiplyFromTnaf(p, u);
+
+        return q;
+    }
+
+    /**
+    * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+    * by an element &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;
+    * using the &lt;code&gt;&tau;&lt;/code&gt;-adic NAF (TNAF) method, given the TNAF
+    * of &lt;code&gt;&lambda;&lt;/code&gt;.
+    * @param p The ECPoint.F2m to multiply.
+    * @param u The the TNAF of &lt;code&gt;&lambda;&lt;/code&gt;..
+    * @return &lt;code&gt;&lambda; * p&lt;/code&gt;
+    */
+    public static ECPoint.F2m multiplyFromTnaf(ECPoint.F2m p, byte[] u)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m)p.getCurve();
+        ECPoint.F2m q = (ECPoint.F2m) curve.getInfinity();
+        for (int i = u.length - 1; i &gt;= 0; i--)
+        {
+            q = tau(q);
+            if (u[i] == 1)
+            {
+                q = (ECPoint.F2m)q.addSimple(p);
+            }
+            else if (u[i] == -1)
+            {
+                q = (ECPoint.F2m)q.subtractSimple(p);
+            }
+        }
+        return q;
+    }
+
+    /**
+     * Computes the &lt;code&gt;[&tau;]&lt;/code&gt;-adic window NAF of an element
+     * &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @param mu The parameter &mu; of the elliptic curve.
+     * @param lambda The element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt; of which to compute the
+     * &lt;code&gt;[&tau;]&lt;/code&gt;-adic NAF.
+     * @param width The window width of the resulting WNAF.
+     * @param pow2w 2&lt;sup&gt;width&lt;/sup&gt;.
+     * @param tw The auxiliary value &lt;code&gt;t&lt;sub&gt;w&lt;/sub&gt;&lt;/code&gt;.
+     * @param alpha The &lt;code&gt;&alpha;&lt;sub&gt;u&lt;/sub&gt;&lt;/code&gt;'s for the window width.
+     * @return The &lt;code&gt;[&tau;]&lt;/code&gt;-adic window NAF of
+     * &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    public static byte[] tauAdicWNaf(byte mu, ZTauElement lambda,
+            byte width, BigInteger pow2w, BigInteger tw, ZTauElement[] alpha)
+    {
+        if (!((mu == 1) || (mu == -1)))
+        {
+            throw new IllegalArgumentException(&quot;mu must be 1 or -1&quot;);
+        }
+
+        BigInteger norm = norm(mu, lambda);
+
+        // Ceiling of log2 of the norm 
+        int log2Norm = norm.bitLength();
+
+        // If length(TNAF) &gt; 30, then length(TNAF) &lt; log2Norm + 3.52
+        int maxLength = log2Norm &gt; 30 ? log2Norm + 4 + width : 34 + width;
+
+        // The array holding the TNAF
+        byte[] u = new byte[maxLength];
+
+        // 2^(width - 1)
+        BigInteger pow2wMin1 = pow2w.shiftRight(1);
+
+        // Split lambda into two BigIntegers to simplify calculations
+        BigInteger r0 = lambda.u;
+        BigInteger r1 = lambda.v;
+        int i = 0;
+
+        // while lambda &lt;&gt; (0, 0)
+        while (!((r0.equals(ECConstants.ZERO))&amp;&amp;(r1.equals(ECConstants.ZERO))))
+        {
+            // if r0 is odd
+            if (r0.testBit(0))
+            {
+                // uUnMod = r0 + r1*tw mod 2^width
+                BigInteger uUnMod
+                    = r0.add(r1.multiply(tw)).mod(pow2w);
+                
+                byte uLocal;
+                // if uUnMod &gt;= 2^(width - 1)
+                if (uUnMod.compareTo(pow2wMin1) &gt;= 0)
+                {
+                    uLocal = (byte) uUnMod.subtract(pow2w).intValue();
+                }
+                else
+                {
+                    uLocal = (byte) uUnMod.intValue();
+                }
+                // uLocal is now in [-2^(width-1), 2^(width-1)-1]
+
+                u[i] = uLocal;
+                boolean s = true;
+                if (uLocal &lt; 0)
+                {
+                    s = false;
+                    uLocal = (byte)-uLocal;
+                }
+                // uLocal is now &gt;= 0
+
+                if (s)
+                {
+                    r0 = r0.subtract(alpha[uLocal].u);
+                    r1 = r1.subtract(alpha[uLocal].v);
+                }
+                else
+                {
+                    r0 = r0.add(alpha[uLocal].u);
+                    r1 = r1.add(alpha[uLocal].v);
+                }
+            }
+            else
+            {
+                u[i] = 0;
+            }
+
+            BigInteger t = r0;
+
+            if (mu == 1)
+            {
+                r0 = r1.add(r0.shiftRight(1));
+            }
+            else
+            {
+                // mu == -1
+                r0 = r1.subtract(r0.shiftRight(1));
+            }
+            r1 = t.shiftRight(1).negate();
+            i++;
+        }
+        return u;
+    }
+
+    /**
+     * Does the precomputation for WTNAF multiplication.
+     * @param p The &lt;code&gt;ECPoint&lt;/code&gt; for which to do the precomputation.
+     * @param a The parameter &lt;code&gt;a&lt;/code&gt; of the elliptic curve.
+     * @return The precomputation array for &lt;code&gt;p&lt;/code&gt;. 
+     */
+    public static ECPoint.F2m[] getPreComp(ECPoint.F2m p, byte a)
+    {
+        ECPoint.F2m[] pu;
+        pu = new ECPoint.F2m[16];
+        pu[1] = p;
+        byte[][] alphaTnaf;
+        if (a == 0)
+        {
+            alphaTnaf = Tnaf.alpha0Tnaf;
+        }
+        else
+        {
+            // a == 1
+            alphaTnaf = Tnaf.alpha1Tnaf;
+        }
+
+        int precompLen = alphaTnaf.length;
+        for (int i = 3; i &lt; precompLen; i = i + 2)
+        {
+            pu[i] = Tnaf.multiplyFromTnaf(p, alphaTnaf[i]);
+        }
+        
+        return pu;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WNafMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WNafMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,240 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class implementing the WNAF (Window Non-Adjacent Form) multiplication
+ * algorithm.
+ */
+class WNafMultiplier implements ECMultiplier
+{
+    /**
+     * Computes the Window NAF (non-adjacent Form) of an integer.
+     * @param width The width &lt;code&gt;w&lt;/code&gt; of the Window NAF. The width is
+     * defined as the minimal number &lt;code&gt;w&lt;/code&gt;, such that for any
+     * &lt;code&gt;w&lt;/code&gt; consecutive digits in the resulting representation, at
+     * most one is non-zero.
+     * @param k The integer of which the Window NAF is computed.
+     * @return The Window NAF of the given width, such that the following holds:
+     * &lt;code&gt;k = &sum;&lt;sub&gt;i=0&lt;/sub&gt;&lt;sup&gt;l-1&lt;/sup&gt; k&lt;sub&gt;i&lt;/sub&gt;2&lt;sup&gt;i&lt;/sup&gt;
+     * &lt;/code&gt;, where the &lt;code&gt;k&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt; denote the elements of the
+     * returned &lt;code&gt;byte[]&lt;/code&gt;.
+     */
+    public byte[] windowNaf(byte width, BigInteger k)
+    {
+        // The window NAF is at most 1 element longer than the binary
+        // representation of the integer k. byte can be used instead of short or
+        // int unless the window width is larger than 8. For larger width use
+        // short or int. However, a width of more than 8 is not efficient for
+        // m = log2(q) smaller than 2305 Bits. Note: Values for m larger than
+        // 1000 Bits are currently not used in practice.
+        byte[] wnaf = new byte[k.bitLength() + 1];
+
+        // 2^width as short and BigInteger
+        short pow2wB = (short)(1 &lt;&lt; width);
+        BigInteger pow2wBI = BigInteger.valueOf(pow2wB);
+
+        int i = 0;
+
+        // The actual length of the WNAF
+        int length = 0;
+
+        // while k &gt;= 1
+        while (k.signum() &gt; 0)
+        {
+            // if k is odd
+            if (k.testBit(0))
+            {
+                // k mod 2^width
+                BigInteger remainder = k.mod(pow2wBI);
+
+                // if remainder &gt; 2^(width - 1) - 1
+                if (remainder.testBit(width - 1))
+                {
+                    wnaf[i] = (byte)(remainder.intValue() - pow2wB);
+                }
+                else
+                {
+                    wnaf[i] = (byte)remainder.intValue();
+                }
+                // wnaf[i] is now in [-2^(width-1), 2^(width-1)-1]
+
+                k = k.subtract(BigInteger.valueOf(wnaf[i]));
+                length = i;
+            }
+            else
+            {
+                wnaf[i] = 0;
+            }
+
+            // k = k/2
+            k = k.shiftRight(1);
+            i++;
+        }
+
+        length++;
+
+        // Reduce the WNAF array to its actual length
+        byte[] wnafShort = new byte[length];
+        System.arraycopy(wnaf, 0, wnafShort, 0, length);
+        return wnafShort;
+    }
+
+    /**
+     * Multiplies &lt;code&gt;this&lt;/code&gt; by an integer &lt;code&gt;k&lt;/code&gt; using the
+     * Window NAF method.
+     * @param k The integer by which &lt;code&gt;this&lt;/code&gt; is multiplied.
+     * @return A new &lt;code&gt;ECPoint&lt;/code&gt; which equals &lt;code&gt;this&lt;/code&gt;
+     * multiplied by &lt;code&gt;k&lt;/code&gt;.
+     */
+    public ECPoint multiply(ECPoint p, BigInteger k, PreCompInfo preCompInfo)
+    {
+        WNafPreCompInfo wnafPreCompInfo;
+
+        if ((preCompInfo != null) &amp;&amp; (preCompInfo instanceof WNafPreCompInfo))
+        {
+            wnafPreCompInfo = (WNafPreCompInfo)preCompInfo;
+        }
+        else
+        {
+            // Ignore empty PreCompInfo or PreCompInfo of incorrect type
+            wnafPreCompInfo = new WNafPreCompInfo();
+        }
+
+        // floor(log2(k))
+        int m = k.bitLength();
+
+        // width of the Window NAF
+        byte width;
+
+        // Required length of precomputation array
+        int reqPreCompLen;
+
+        // Determine optimal width and corresponding length of precomputation
+        // array based on literature values
+        if (m &lt; 13)
+        {
+            width = 2;
+            reqPreCompLen = 1;
+        }
+        else
+        {
+            if (m &lt; 41)
+            {
+                width = 3;
+                reqPreCompLen = 2;
+            }
+            else
+            {
+                if (m &lt; 121)
+                {
+                    width = 4;
+                    reqPreCompLen = 4;
+                }
+                else
+                {
+                    if (m &lt; 337)
+                    {
+                        width = 5;
+                        reqPreCompLen = 8;
+                    }
+                    else
+                    {
+                        if (m &lt; 897)
+                        {
+                            width = 6;
+                            reqPreCompLen = 16;
+                        }
+                        else
+                        {
+                            if (m &lt; 2305)
+                            {
+                                width = 7;
+                                reqPreCompLen = 32;
+                            }
+                            else
+                            {
+                                width = 8;
+                                reqPreCompLen = 127;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        // The length of the precomputation array
+        int preCompLen = 1;
+
+        ECPoint[] preComp = wnafPreCompInfo.getPreComp();
+        ECPoint twiceP = wnafPreCompInfo.getTwiceP();
+
+        // Check if the precomputed ECPoints already exist
+        if (preComp == null)
+        {
+            // Precomputation must be performed from scratch, create an empty
+            // precomputation array of desired length
+            preComp = new ECPoint[]{ p };
+        }
+        else
+        {
+            // Take the already precomputed ECPoints to start with
+            preCompLen = preComp.length;
+        }
+
+        if (twiceP == null)
+        {
+            // Compute twice(p)
+            twiceP = p.twice();
+        }
+
+        if (preCompLen &lt; reqPreCompLen)
+        {
+            // Precomputation array must be made bigger, copy existing preComp
+            // array into the larger new preComp array
+            ECPoint[] oldPreComp = preComp;
+            preComp = new ECPoint[reqPreCompLen];
+            System.arraycopy(oldPreComp, 0, preComp, 0, preCompLen);
+
+            for (int i = preCompLen; i &lt; reqPreCompLen; i++)
+            {
+                // Compute the new ECPoints for the precomputation array.
+                // The values 1, 3, 5, ..., 2^(width-1)-1 times p are
+                // computed
+                preComp[i] = twiceP.add(preComp[i - 1]);
+            }            
+        }
+
+        // Compute the Window NAF of the desired width
+        byte[] wnaf = windowNaf(width, k);
+        int l = wnaf.length;
+
+        // Apply the Window NAF to p using the precomputed ECPoint values.
+        ECPoint q = p.getCurve().getInfinity();
+        for (int i = l - 1; i &gt;= 0; i--)
+        {
+            q = q.twice();
+
+            if (wnaf[i] != 0)
+            {
+                if (wnaf[i] &gt; 0)
+                {
+                    q = q.add(preComp[(wnaf[i] - 1)/2]);
+                }
+                else
+                {
+                    // wnaf[i] &lt; 0
+                    q = q.subtract(preComp[(-wnaf[i] - 1)/2]);
+                }
+            }
+        }
+
+        // Set PreCompInfo in ECPoint, such that it is available for next
+        // multiplication.
+        wnafPreCompInfo.setPreComp(preComp);
+        wnafPreCompInfo.setTwiceP(twiceP);
+        p.setPreCompInfo(wnafPreCompInfo);
+        return q;
+    }
+
+}

Added: trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WNafPreCompInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,44 @@
+package org.bouncycastle.math.ec;
+
+/**
+ * Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
+ * algorithm.
+ */
+class WNafPreCompInfo implements PreCompInfo
+{
+    /**
+     * Array holding the precomputed &lt;code&gt;ECPoint&lt;/code&gt;s used for the Window
+     * NAF multiplication in &lt;code&gt;
+     * {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
+     * WNafMultiplier.multiply()}&lt;/code&gt;.
+     */
+    private ECPoint[] preComp = null;
+
+    /**
+     * Holds an &lt;code&gt;ECPoint&lt;/code&gt; representing twice(this). Used for the
+     * Window NAF multiplication in &lt;code&gt;
+     * {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
+     * WNafMultiplier.multiply()}&lt;/code&gt;.
+     */
+    private ECPoint twiceP = null;
+
+    protected ECPoint[] getPreComp()
+    {
+        return preComp;
+    }
+
+    protected void setPreComp(ECPoint[] preComp)
+    {
+        this.preComp = preComp;
+    }
+
+    protected ECPoint getTwiceP()
+    {
+        return twiceP;
+    }
+
+    protected void setTwiceP(ECPoint twiceThis)
+    {
+        this.twiceP = twiceThis;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WTauNafMultiplier.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,119 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class implementing the WTNAF (Window
+ * &lt;code&gt;&tau;&lt;/code&gt;-adic Non-Adjacent Form) algorithm.
+ */
+class WTauNafMultiplier implements ECMultiplier
+{
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by &lt;code&gt;k&lt;/code&gt; using the reduced &lt;code&gt;&tau;&lt;/code&gt;-adic NAF (RTNAF)
+     * method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param k The integer by which to multiply &lt;code&gt;k&lt;/code&gt;.
+     * @return &lt;code&gt;p&lt;/code&gt; multiplied by &lt;code&gt;k&lt;/code&gt;.
+     */
+    public ECPoint multiply(ECPoint point, BigInteger k, PreCompInfo preCompInfo)
+    {
+        if (!(point instanceof ECPoint.F2m))
+        {
+            throw new IllegalArgumentException(&quot;Only ECPoint.F2m can be &quot; +
+                    &quot;used in WTauNafMultiplier&quot;);
+        }
+
+        ECPoint.F2m p = (ECPoint.F2m)point;
+
+        ECCurve.F2m curve = (ECCurve.F2m) p.getCurve();
+        int m = curve.getM();
+        byte a = curve.getA().toBigInteger().byteValue();
+        byte mu = curve.getMu();
+        BigInteger[] s = curve.getSi();
+
+        ZTauElement rho = Tnaf.partModReduction(k, m, a, s, mu, (byte)10);
+
+        return multiplyWTnaf(p, rho, preCompInfo, a, mu);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by an element &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt; using
+     * the &lt;code&gt;&tau;&lt;/code&gt;-adic NAF (TNAF) method.
+     * @param p The ECPoint.F2m to multiply.
+     * @param lambda The element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt; of which to compute the
+     * &lt;code&gt;[&tau;]&lt;/code&gt;-adic NAF.
+     * @return &lt;code&gt;p&lt;/code&gt; multiplied by &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    private ECPoint.F2m multiplyWTnaf(ECPoint.F2m p, ZTauElement lambda,
+            PreCompInfo preCompInfo, byte a, byte mu)
+    {
+        ZTauElement[] alpha;
+        if (a == 0)
+        {
+            alpha = Tnaf.alpha0;
+        }
+        else
+        {
+            // a == 1
+            alpha = Tnaf.alpha1;
+        }
+
+        BigInteger tw = Tnaf.getTw(mu, Tnaf.WIDTH);
+
+        byte[]u = Tnaf.tauAdicWNaf(mu, lambda, Tnaf.WIDTH,
+                BigInteger.valueOf(Tnaf.POW_2_WIDTH), tw, alpha);
+
+        return multiplyFromWTnaf(p, u, preCompInfo);
+    }
+
+    /**
+     * Multiplies a {@link org.bouncycastle.math.ec.ECPoint.F2m ECPoint.F2m}
+     * by an element &lt;code&gt;&lambda;&lt;/code&gt; of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;
+     * using the window &lt;code&gt;&tau;&lt;/code&gt;-adic NAF (TNAF) method, given the
+     * WTNAF of &lt;code&gt;&lambda;&lt;/code&gt;.
+     * @param p The ECPoint.F2m to multiply.
+     * @param u The the WTNAF of &lt;code&gt;&lambda;&lt;/code&gt;..
+     * @return &lt;code&gt;&lambda; * p&lt;/code&gt;
+     */
+    private static ECPoint.F2m multiplyFromWTnaf(ECPoint.F2m p, byte[] u,
+            PreCompInfo preCompInfo)
+    {
+        ECCurve.F2m curve = (ECCurve.F2m)p.getCurve();
+        byte a = curve.getA().toBigInteger().byteValue();
+
+        ECPoint.F2m[] pu;
+        if ((preCompInfo == null) || !(preCompInfo instanceof WTauNafPreCompInfo))
+        {
+            pu = Tnaf.getPreComp(p, a);
+            p.setPreCompInfo(new WTauNafPreCompInfo(pu));
+        }
+        else
+        {
+            pu = ((WTauNafPreCompInfo)preCompInfo).getPreComp();
+        }
+
+        // q = infinity
+        ECPoint.F2m q = (ECPoint.F2m) p.getCurve().getInfinity();
+        for (int i = u.length - 1; i &gt;= 0; i--)
+        {
+            q = Tnaf.tau(q);
+            if (u[i] != 0)
+            {
+                if (u[i] &gt; 0)
+                {
+                    q = q.addSimple(pu[u[i]]);
+                }
+                else
+                {
+                    // u[i] &lt; 0
+                    q = q.subtractSimple(pu[-u[i]]);
+                }
+            }
+        }
+
+        return q;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/WTauNafPreCompInfo.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,39 @@
+package org.bouncycastle.math.ec;
+
+/**
+ * Class holding precomputation data for the WTNAF (Window
+ * &lt;code&gt;&tau;&lt;/code&gt;-adic Non-Adjacent Form) algorithm.
+ */
+class WTauNafPreCompInfo implements PreCompInfo
+{
+    /**
+     * Array holding the precomputed &lt;code&gt;ECPoint.F2m&lt;/code&gt;s used for the
+     * WTNAF multiplication in &lt;code&gt;
+     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
+     * WTauNafMultiplier.multiply()}&lt;/code&gt;.
+     */
+    private ECPoint.F2m[] preComp = null;
+
+    /**
+     * Constructor for &lt;code&gt;WTauNafPreCompInfo&lt;/code&gt;
+     * @param preComp Array holding the precomputed &lt;code&gt;ECPoint.F2m&lt;/code&gt;s
+     * used for the WTNAF multiplication in &lt;code&gt;
+     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
+     * WTauNafMultiplier.multiply()}&lt;/code&gt;.
+     */
+    WTauNafPreCompInfo(ECPoint.F2m[] preComp)
+    {
+        this.preComp = preComp;
+    }
+
+    /**
+     * @return the array holding the precomputed &lt;code&gt;ECPoint.F2m&lt;/code&gt;s
+     * used for the WTNAF multiplication in &lt;code&gt;
+     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
+     * WTauNafMultiplier.multiply()}&lt;/code&gt;.
+     */
+    protected ECPoint.F2m[] getPreComp()
+    {
+        return preComp;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/ZTauElement.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/math/ec/ZTauElement.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/math/ec/ZTauElement.java
===================================================================
--- trunk/src/org/bouncycastle/math/ec/ZTauElement.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/ZTauElement.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,37 @@
+package org.bouncycastle.math.ec;
+
+import ewe.math.BigInteger;
+
+/**
+ * Class representing an element of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;. Let
+ * &lt;code&gt;&lambda;&lt;/code&gt; be an element of &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;. Then
+ * &lt;code&gt;&lambda;&lt;/code&gt; is given as &lt;code&gt;&lambda; = u + v&tau;&lt;/code&gt;. The
+ * components &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; may be used directly, there
+ * are no accessor methods.
+ * Immutable class.
+ */
+class ZTauElement
+{
+    /**
+     * The &quot;real&quot; part of &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    public final BigInteger u;
+
+    /**
+     * The &quot;&lt;code&gt;&tau;&lt;/code&gt;-adic&quot; part of &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    public final BigInteger v;
+
+    /**
+     * Constructor for an element &lt;code&gt;&lambda;&lt;/code&gt; of
+     * &lt;code&gt;&lt;b&gt;Z&lt;/b&gt;[&tau;]&lt;/code&gt;.
+     * @param u The &quot;real&quot; part of &lt;code&gt;&lambda;&lt;/code&gt;.
+     * @param v The &quot;&lt;code&gt;&tau;&lt;/code&gt;-adic&quot; part of
+     * &lt;code&gt;&lambda;&lt;/code&gt;.
+     */
+    public ZTauElement(BigInteger u, BigInteger v)
+    {
+        this.u = u;
+        this.v = v;
+    }
+}

Added: trunk/src/org/bouncycastle/math/ec/package.html
===================================================================
--- trunk/src/org/bouncycastle/math/ec/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/math/ec/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Math support for Elliptic Curve.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/util/Arrays.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/Arrays.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/Arrays.java
===================================================================
--- trunk/src/org/bouncycastle/util/Arrays.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/Arrays.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,244 @@
+package org.bouncycastle.util;
+
+/**
+ * General array utilities.
+ */
+public final class Arrays
+{
+    private Arrays() 
+    {
+        // static class, hide constructor
+    }
+    
+    public static boolean areEqual(
+        boolean[]  a,
+        boolean[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static boolean areEqual(
+        char[]  a,
+        char[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static boolean areEqual(
+        byte[]  a,
+        byte[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * A constant time equals comparison - does not terminate early if
+     * test will fail.
+     *
+     * @param a first array
+     * @param b second array
+     * @return true if arrays equal, false otherwise.
+     */
+    public static boolean constantTimeAreEqual(
+        byte[]  a,
+        byte[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        int nonEqual = 0;
+
+        for (int i = 0; i != a.length; i++)
+        {
+            nonEqual |= (a[i] ^ b[i]);
+        }
+
+        return nonEqual == 0;
+    }
+
+    public static boolean areEqual(
+        int[]  a,
+        int[]  b)
+    {
+        if (a == b)
+        {
+            return true;
+        }
+
+        if (a == null || b == null)
+        {
+            return false;
+        }
+
+        if (a.length != b.length)
+        {
+            return false;
+        }
+
+        for (int i = 0; i != a.length; i++)
+        {
+            if (a[i] != b[i])
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static void fill(
+        byte[] array,
+        byte value)
+    {
+        for (int i = 0; i &lt; array.length; i++)
+        {
+            array[i] = value;
+        }
+    }
+    
+    public static void fill(
+        long[] array,
+        long value)
+    {
+        for (int i = 0; i &lt; array.length; i++)
+        {
+            array[i] = value;
+        }
+    }
+
+    public static void fill(
+        short[] array, 
+        short value)
+    {
+        for (int i = 0; i &lt; array.length; i++)
+        {
+            array[i] = value;
+        }
+    }
+
+    public static int hashCode(byte[] data)
+    {
+        if (data == null)
+        {
+            return 0;
+        }
+
+        int i = data.length;
+        int hc = i + 1;
+
+        while (--i &gt;= 0)
+        {
+            hc *= 257;
+            hc ^= data[i];
+        }
+
+        return hc;
+    }
+
+    public static byte[] clone(byte[] data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+        byte[] copy = new byte[data.length];
+
+        System.arraycopy(data, 0, copy, 0, data.length);
+
+        return copy;
+    }
+
+    public static int[] clone(int[] data)
+    {
+        if (data == null)
+        {
+            return null;
+        }
+        int[] copy = new int[data.length];
+
+        System.arraycopy(data, 0, copy, 0, data.length);
+
+        return copy;
+    }
+}

Added: trunk/src/org/bouncycastle/util/BigIntegers.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/BigIntegers.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/BigIntegers.java
===================================================================
--- trunk/src/org/bouncycastle/util/BigIntegers.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/BigIntegers.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,78 @@
+package org.bouncycastle.util;
+
+import ewe.math.BigInteger;
+import ewe.security.SecureRandom;
+
+/**
+ * BigInteger utilities.
+ */
+public final class BigIntegers
+{
+    private static final int MAX_ITERATIONS = 1000;
+    private static final BigInteger ZERO = BigInteger.valueOf(0);
+
+    /**
+     * Return the passed in value as an unsigned byte array.
+     * 
+     * @param value value to be converted.
+     * @return a byte array without a leading zero byte if present in the signed encoding.
+     */
+    public static byte[] asUnsignedByteArray(
+        BigInteger value)
+    {
+        byte[] bytes = value.toByteArray();
+        
+        if (bytes[0] == 0)
+        {
+            byte[] tmp = new byte[bytes.length - 1];
+            
+            System.arraycopy(bytes, 1, tmp, 0, tmp.length);
+            
+            return tmp;
+        }
+        
+        return bytes;
+    }
+
+    /**
+     * Return a random BigInteger not less than 'min' and not greater than 'max'
+     * 
+     * @param min the least value that may be generated
+     * @param max the greatest value that may be generated
+     * @param random the source of randomness
+     * @return a random BigInteger value in the range [min,max]
+     */
+    public static BigInteger createRandomInRange(
+        BigInteger      min,
+        BigInteger      max,
+        SecureRandom    random)
+    {
+        int cmp = min.compareTo(max);
+        if (cmp &gt;= 0)
+        {
+            if (cmp &gt; 0)
+            {
+                throw new IllegalArgumentException(&quot;'min' may not be greater than 'max'&quot;);
+            }
+
+            return min;
+        }
+
+        if (min.bitLength() &gt; max.bitLength() / 2)
+        {
+            return createRandomInRange(ZERO, max.subtract(min), random).add(min);
+        }
+
+        for (int i = 0; i &lt; MAX_ITERATIONS; ++i)
+        {
+            BigInteger x = new BigInteger(max.bitLength(), random);
+            if (x.compareTo(min) &gt;= 0 &amp;&amp; x.compareTo(max) &lt;= 0)
+            {
+                return x;
+            }
+        }
+
+        // fall back to a faster (restricted) method
+        return new BigInteger(max.subtract(min).bitLength() - 1, random).add(min);
+    }
+}

Added: trunk/src/org/bouncycastle/util/Strings.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/Strings.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/Strings.java
===================================================================
--- trunk/src/org/bouncycastle/util/Strings.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/Strings.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,258 @@
+package org.bouncycastle.util;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.util.Vector;
+
+public final class Strings
+{
+    public static String fromUTF8ByteArray(byte[] bytes)
+    {
+        int i = 0;
+        int length = 0;
+
+        while (i &lt; bytes.length)
+        {
+            length++;
+            if ((bytes[i] &amp; 0xf0) == 0xf0)
+            {
+                // surrogate pair
+                length++;
+                i += 4;
+            }
+            else if ((bytes[i] &amp; 0xe0) == 0xe0)
+            {
+                i += 3;
+            }
+            else if ((bytes[i] &amp; 0xc0) == 0xc0)
+            {
+                i += 2;
+            }
+            else
+            {
+                i += 1;
+            }
+        }
+
+        char[] cs = new char[length];
+
+        i = 0;
+        length = 0;
+
+        while (i &lt; bytes.length)
+        {
+            char ch;
+
+            if ((bytes[i] &amp; 0xf0) == 0xf0)
+            {
+                int codePoint = ((bytes[i] &amp; 0x03) &lt;&lt; 18) | ((bytes[i+1] &amp; 0x3F) &lt;&lt; 12) | ((bytes[i+2] &amp; 0x3F) &lt;&lt; 6) | (bytes[i+3] &amp; 0x3F);
+                int U = codePoint - 0x10000;
+                char W1 = (char)(0xD800 | (U &gt;&gt; 10));
+                char W2 = (char)(0xDC00 | (U &amp; 0x3FF));
+                cs[length++] = W1;
+                ch = W2;
+                i += 4;
+            }
+            else if ((bytes[i] &amp; 0xe0) == 0xe0)
+            {
+                ch = (char)(((bytes[i] &amp; 0x0f) &lt;&lt; 12)
+                        | ((bytes[i + 1] &amp; 0x3f) &lt;&lt; 6) | (bytes[i + 2] &amp; 0x3f));
+                i += 3;
+            }
+            else if ((bytes[i] &amp; 0xd0) == 0xd0)
+            {
+                ch = (char)(((bytes[i] &amp; 0x1f) &lt;&lt; 6) | (bytes[i + 1] &amp; 0x3f));
+                i += 2;
+            }
+            else if ((bytes[i] &amp; 0xc0) == 0xc0)
+            {
+                ch = (char)(((bytes[i] &amp; 0x1f) &lt;&lt; 6) | (bytes[i + 1] &amp; 0x3f));
+                i += 2;
+            }
+            else
+            {
+                ch = (char)(bytes[i] &amp; 0xff);
+                i += 1;
+            }
+
+            cs[length++] = ch;
+        }
+
+        return new String(cs);
+    }
+    
+    public static byte[] toUTF8ByteArray(String string)
+    {
+        return toUTF8ByteArray(string.toCharArray());
+    }
+
+    public static byte[] toUTF8ByteArray(char[] string)
+    {
+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+        char[] c = string;
+        int i = 0;
+
+        while (i &lt; c.length)
+        {
+            char ch = c[i];
+
+            if (ch &lt; 0x0080)
+            {
+                bOut.write(ch);
+            }
+            else if (ch &lt; 0x0800)
+            {
+                bOut.write(0xc0 | (ch &gt;&gt; 6));
+                bOut.write(0x80 | (ch &amp; 0x3f));
+            }
+            // surrogate pair
+            else if (ch &gt;= 0xD800 &amp;&amp; ch &lt;= 0xDFFF)
+            {
+                // in error - can only happen, if the Java String class has a
+                // bug.
+                if (i + 1 &gt;= c.length)
+                {
+                    throw new IllegalStateException(&quot;invalid UTF-16 codepoint&quot;);
+                }
+                char W1 = ch;
+                ch = c[++i];
+                char W2 = ch;
+                // in error - can only happen, if the Java String class has a
+                // bug.
+                if (W1 &gt; 0xDBFF)
+                {
+                    throw new IllegalStateException(&quot;invalid UTF-16 codepoint&quot;);
+                }
+                int codePoint = (((W1 &amp; 0x03FF) &lt;&lt; 10) | (W2 &amp; 0x03FF)) + 0x10000;
+                bOut.write(0xf0 | (codePoint &gt;&gt; 18));
+                bOut.write(0x80 | ((codePoint &gt;&gt; 12) &amp; 0x3F));
+                bOut.write(0x80 | ((codePoint &gt;&gt; 6) &amp; 0x3F));
+                bOut.write(0x80 | (codePoint &amp; 0x3F));
+            }
+            else
+            {
+                bOut.write(0xe0 | (ch &gt;&gt; 12));
+                bOut.write(0x80 | ((ch &gt;&gt; 6) &amp; 0x3F));
+                bOut.write(0x80 | (ch &amp; 0x3F));
+            }
+
+            i++;
+        }
+        
+        return bOut.toByteArray();
+    }
+    
+    /**
+     * A locale independent version of toUpperCase.
+     * 
+     * @param string input to be converted
+     * @return a US Ascii uppercase version
+     */
+    public static String toUpperCase(String string)
+    {
+        boolean changed = false;
+        char[] chars = string.toCharArray();
+        
+        for (int i = 0; i != chars.length; i++)
+        {
+            char ch = chars[i];
+            if ('a' &lt;= ch &amp;&amp; 'z' &gt;= ch)
+            {
+                changed = true;
+                chars[i] = (char)(ch - 'a' + 'A');
+            }
+        }
+        
+        if (changed)
+        {
+            return new String(chars);
+        }
+        
+        return string;
+    }
+    
+    /**
+     * A locale independent version of toLowerCase.
+     * 
+     * @param string input to be converted
+     * @return a US ASCII lowercase version
+     */
+    public static String toLowerCase(String string)
+    {
+        boolean changed = false;
+        char[] chars = string.toCharArray();
+        
+        for (int i = 0; i != chars.length; i++)
+        {
+            char ch = chars[i];
+            if ('A' &lt;= ch &amp;&amp; 'Z' &gt;= ch)
+            {
+                changed = true;
+                chars[i] = (char)(ch - 'A' + 'a');
+            }
+        }
+        
+        if (changed)
+        {
+            return new String(chars);
+        }
+        
+        return string;
+    }
+
+    public static byte[] toByteArray(char[] chars)
+    {
+        byte[] bytes = new byte[chars.length];
+
+        for (int i = 0; i != bytes.length; i++)
+        {
+            bytes[i] = (byte)chars[i];
+        }
+
+        return bytes;
+    }
+
+    public static byte[] toByteArray(String string)
+    {
+        byte[] bytes = new byte[string.length()];
+
+        for (int i = 0; i != bytes.length; i++)
+        {
+            char ch = string.charAt(i);
+
+            bytes[i] = (byte)ch;
+        }
+
+        return bytes;
+    }
+
+    public static String[] split(String input, char delimiter)
+    {
+        Vector           v = new Vector();
+        boolean moreTokens = true;
+        String subString;
+
+        while (moreTokens)
+        {
+            int tokenLocation = input.indexOf(delimiter);
+            if (tokenLocation &gt; 0)
+            {
+                subString = input.substring(0, tokenLocation);
+                v.addElement(subString);
+                input = input.substring(tokenLocation + 1);
+            }
+            else
+            {
+                moreTokens = false;
+                v.addElement(input);
+            }
+        }
+
+        String[] res = new String[v.size()];
+
+        for (int i = 0; i != res.length; i++)
+        {
+            res[i] = (String)v.elementAt(i);
+        }
+        return res;
+    }
+}

Added: trunk/src/org/bouncycastle/util/encoders/Encoder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/encoders/Encoder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/encoders/Encoder.java
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/Encoder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/Encoder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,17 @@
+package org.bouncycastle.util.encoders;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+/**
+ * Encode and decode byte arrays (typically from binary to 7-bit ASCII 
+ * encodings).
+ */
+public interface Encoder
+{
+    int encode(byte[] data, int off, int length, OutputStream out) throws IOException;
+    
+    int decode(byte[] data, int off, int length, OutputStream out) throws IOException;
+
+    int decode(String data, OutputStream out) throws IOException;
+}

Added: trunk/src/org/bouncycastle/util/encoders/Hex.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/encoders/Hex.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/encoders/Hex.java
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/Hex.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/Hex.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,131 @@
+package org.bouncycastle.util.encoders;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class Hex
+{
+    private static final Encoder encoder = new HexEncoder();
+    
+    /**
+     * encode the input data producing a Hex encoded byte array.
+     *
+     * @return a byte array containing the Hex encoded data.
+     */
+    public static byte[] encode(
+        byte[]    data)
+    {
+        return encode(data, 0, data.length);
+    }
+    
+    /**
+     * encode the input data producing a Hex encoded byte array.
+     *
+     * @return a byte array containing the Hex encoded data.
+     */
+    public static byte[] encode(
+        byte[]    data,
+        int       off,
+        int       length)
+    {
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        
+        try
+        {
+            encoder.encode(data, off, length, bOut);
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException(&quot;exception encoding Hex string: &quot; + e);
+        }
+        
+        return bOut.toByteArray();
+    }
+
+    /**
+     * Hex encode the byte data writing it to the given output stream.
+     *
+     * @return the number of bytes produced.
+     */
+    public static int encode(
+        byte[]         data,
+        OutputStream   out)
+        throws IOException
+    {
+        return encoder.encode(data, 0, data.length, out);
+    }
+    
+    /**
+     * Hex encode the byte data writing it to the given output stream.
+     *
+     * @return the number of bytes produced.
+     */
+    public static int encode(
+        byte[]         data,
+        int            off,
+        int            length,
+        OutputStream   out)
+        throws IOException
+    {
+        return encoder.encode(data, off, length, out);
+    }
+    
+    /**
+     * decode the Hex encoded input data. It is assumed the input data is valid.
+     *
+     * @return a byte array representing the decoded data.
+     */
+    public static byte[] decode(
+        byte[]    data)
+    {
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        
+        try
+        {
+            encoder.decode(data, 0, data.length, bOut);
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException(&quot;exception decoding Hex string: &quot; + e);
+        }
+        
+        return bOut.toByteArray();
+    }
+    
+    /**
+     * decode the Hex encoded String data - whitespace will be ignored.
+     *
+     * @return a byte array representing the decoded data.
+     */
+    public static byte[] decode(
+        String    data)
+    {
+        ByteArrayOutputStream    bOut = new ByteArrayOutputStream();
+        
+        try
+        {
+            encoder.decode(data, bOut);
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException(&quot;exception decoding Hex string: &quot; + e);
+        }
+        
+        return bOut.toByteArray();
+    }
+    
+    /**
+     * decode the Hex encoded String data writing it to the given output stream,
+     * whitespace characters will be ignored.
+     *
+     * @return the number of bytes produced.
+     */
+    public static int decode(
+        String          data,
+        OutputStream    out)
+        throws IOException
+    {
+        return encoder.decode(data, out);
+    }
+}

Added: trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/encoders/HexEncoder.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/encoders/HexEncoder.java
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/HexEncoder.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/HexEncoder.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,172 @@
+package org.bouncycastle.util.encoders;
+
+import ewe.io.IOException;
+import ewe.io.OutputStream;
+
+public class HexEncoder
+    implements Encoder
+{
+    protected final byte[] encodingTable =
+        {
+            (byte)'0', (byte)'1', (byte)'2', (byte)'3', (byte)'4', (byte)'5', (byte)'6', (byte)'7',
+            (byte)'8', (byte)'9', (byte)'a', (byte)'b', (byte)'c', (byte)'d', (byte)'e', (byte)'f'
+        };
+    
+    /*
+     * set up the decoding table.
+     */
+    protected final byte[] decodingTable = new byte[128];
+
+    protected void initialiseDecodingTable()
+    {
+        for (int i = 0; i &lt; encodingTable.length; i++)
+        {
+            decodingTable[encodingTable[i]] = (byte)i;
+        }
+        
+        decodingTable['A'] = decodingTable['a'];
+        decodingTable['B'] = decodingTable['b'];
+        decodingTable['C'] = decodingTable['c'];
+        decodingTable['D'] = decodingTable['d'];
+        decodingTable['E'] = decodingTable['e'];
+        decodingTable['F'] = decodingTable['f'];
+    }
+    
+    public HexEncoder()
+    {
+        initialiseDecodingTable();
+    }
+    
+    /**
+     * encode the input data producing a Hex output stream.
+     *
+     * @return the number of bytes produced.
+     */
+    public int encode(
+        byte[]                data,
+        int                    off,
+        int                    length,
+        OutputStream    out) 
+        throws IOException
+    {        
+        for (int i = off; i &lt; (off + length); i++)
+        {
+            int    v = data[i] &amp; 0xff;
+
+            out.write(encodingTable[(v &gt;&gt;&gt; 4)]);
+            out.write(encodingTable[v &amp; 0xf]);
+        }
+
+        return length * 2;
+    }
+
+    private boolean ignore(
+        char    c)
+    {
+        return (c == '\n' || c =='\r' || c == '\t' || c == ' ');
+    }
+    
+    /**
+     * decode the Hex encoded byte data writing it to the given output stream,
+     * whitespace characters will be ignored.
+     *
+     * @return the number of bytes produced.
+     */
+    public int decode(
+        byte[]          data,
+        int             off,
+        int             length,
+        OutputStream    out)
+        throws IOException
+    {
+        byte    b1, b2;
+        int     outLen = 0;
+        
+        int     end = off + length;
+        
+        while (end &gt; off)
+        {
+            if (!ignore((char)data[end - 1]))
+            {
+                break;
+            }
+            
+            end--;
+        }
+        
+        int i = off;
+        while (i &lt; end)
+        {
+            while (i &lt; end &amp;&amp; ignore((char)data[i]))
+            {
+                i++;
+            }
+            
+            b1 = decodingTable[data[i++]];
+            
+            while (i &lt; end &amp;&amp; ignore((char)data[i]))
+            {
+                i++;
+            }
+            
+            b2 = decodingTable[data[i++]];
+
+            out.write((b1 &lt;&lt; 4) | b2);
+            
+            outLen++;
+        }
+
+        return outLen;
+    }
+    
+    /**
+     * decode the Hex encoded String data writing it to the given output stream,
+     * whitespace characters will be ignored.
+     *
+     * @return the number of bytes produced.
+     */
+    public int decode(
+        String          data,
+        OutputStream    out)
+        throws IOException
+    {
+        byte    b1, b2;
+        int     length = 0;
+        
+        int     end = data.length();
+        
+        while (end &gt; 0)
+        {
+            if (!ignore(data.charAt(end - 1)))
+            {
+                break;
+            }
+            
+            end--;
+        }
+        
+        int i = 0;
+        while (i &lt; end)
+        {
+            while (i &lt; end &amp;&amp; ignore(data.charAt(i)))
+            {
+                i++;
+            }
+            
+            b1 = decodingTable[data.charAt(i++)];
+            
+            while (i &lt; end &amp;&amp; ignore(data.charAt(i)))
+            {
+                i++;
+            }
+            
+            b2 = decodingTable[data.charAt(i++)];
+
+            out.write((b1 &lt;&lt; 4) | b2);
+            
+            length++;
+        }
+
+        return length;
+    }
+}

Added: trunk/src/org/bouncycastle/util/encoders/package.html
===================================================================
--- trunk/src/org/bouncycastle/util/encoders/package.html	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/encoders/package.html	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,5 @@
+&lt;html&gt;
+&lt;body bgcolor=&quot;#ffffff&quot;&gt;
+Classes for producing and reading Base64 and Hex strings.
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/io/StreamOverflowException.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/io/StreamOverflowException.java
===================================================================
--- trunk/src/org/bouncycastle/util/io/StreamOverflowException.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/io/StreamOverflowException.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,12 @@
+package org.bouncycastle.util.io;
+
+import ewe.io.IOException;
+
+public class StreamOverflowException
+    extends IOException
+{
+    public StreamOverflowException(String msg)
+    {
+        super(msg);
+    }
+}

Added: trunk/src/org/bouncycastle/util/io/Streams.class
===================================================================
(Binary files differ)


Property changes on: trunk/src/org/bouncycastle/util/io/Streams.class
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: trunk/src/org/bouncycastle/util/io/Streams.java
===================================================================
--- trunk/src/org/bouncycastle/util/io/Streams.java	                        (rev 0)
+++ trunk/src/org/bouncycastle/util/io/Streams.java	2011-08-25 00:55:34 UTC (rev 3058)
@@ -0,0 +1,87 @@
+package org.bouncycastle.util.io;
+
+import ewe.io.ByteArrayOutputStream;
+import ewe.io.IOException;
+import ewe.io.InputStream;
+import ewe.io.OutputStream;
+
+public final class Streams
+{
+    private static int BUFFER_SIZE = 512;
+
+    public static void drain(InputStream inStr)
+        throws IOException
+    {
+        byte[] bs = new byte[BUFFER_SIZE];
+        while (inStr.read(bs, 0, bs.length) &gt;= 0)
+        {
+        }
+    }
+
+    public static byte[] readAll(InputStream inStr)
+        throws IOException
+    {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        pipeAll(inStr, buf);
+        return buf.toByteArray();
+    }
+
+    public static byte[] readAllLimited(InputStream inStr, int limit)
+        throws IOException
+    {
+        ByteArrayOutputStream buf = new ByteArrayOutputStream();
+        pipeAllLimited(inStr, limit, buf);
+        return buf.toByteArray();
+    }
+
+    public static int readFully(InputStream inStr, byte[] buf)
+        throws IOException
+    {
+        return readFully(inStr, buf, 0, buf.length);
+    }
+
+    public static int readFully(InputStream inStr, byte[] buf, int off, int len)
+        throws IOException
+    {
+        int totalRead = 0;
+        while (totalRead &lt; len)
+        {
+            int numRead = inStr.read(buf, off + totalRead, len - totalRead);
+            if (numRead &lt; 0)
+            {
+                break;
+            }
+            totalRead += numRead;
+        }
+        return totalRead;
+    }
+
+    public static void pipeAll(InputStream inStr, OutputStream outStr)
+        throws IOException
+    {
+        byte[] bs = new byte[BUFFER_SIZE];
+        int numRead;
+        while ((numRead = inStr.read(bs, 0, bs.length)) &gt;= 0)
+        {
+            outStr.write(bs, 0, numRead);
+        }
+    }
+
+    public static long pipeAllLimited(InputStream inStr, long limit, OutputStream outStr)
+        throws IOException
+    {
+        long total = 0;
+        byte[] bs = new byte[BUFFER_SIZE];
+        int numRead;
+        while ((numRead = inStr.read(bs, 0, bs.length)) &gt;= 0)
+        {
+            total += numRead;
+            if (total &gt; limit)
+            {
+                throw new StreamOverflowException(&quot;Data Overflow&quot;);
+            }
+            outStr.write(bs, 0, numRead);
+        }
+        return total;
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003053.html">[Cachewolf-svn] r3062 - trunk
</A></li>
	<LI>Next message: <A HREF="003050.html">[Cachewolf-svn] r3059 - in trunk/src/CacheWolf: . utils
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3049">[ date ]</a>
              <a href="thread.html#3049">[ thread ]</a>
              <a href="subject.html#3049">[ subject ]</a>
              <a href="author.html#3049">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/cachewolf-svn">More information about the Cachewolf-svn
mailing list</a><br>
</body></html>
